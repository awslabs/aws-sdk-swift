// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension LexModelsV2ClientTypes.ActiveContext: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// The active context used in the test execution.
    public struct ActiveContext: Swift.Equatable {
        /// The name of active context.
        /// This member is required.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension LexModelsV2ClientTypes.AdvancedRecognitionSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioRecognitionStrategy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audioRecognitionStrategy = self.audioRecognitionStrategy {
            try encodeContainer.encode(audioRecognitionStrategy.rawValue, forKey: .audioRecognitionStrategy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioRecognitionStrategyDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AudioRecognitionStrategy.self, forKey: .audioRecognitionStrategy)
        audioRecognitionStrategy = audioRecognitionStrategyDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Provides settings that enable advanced recognition settings for slot values.
    public struct AdvancedRecognitionSetting: Swift.Equatable {
        /// Enables using the slot values as a custom vocabulary for recognizing user utterances.
        public var audioRecognitionStrategy: LexModelsV2ClientTypes.AudioRecognitionStrategy?

        public init(
            audioRecognitionStrategy: LexModelsV2ClientTypes.AudioRecognitionStrategy? = nil
        )
        {
            self.audioRecognitionStrategy = audioRecognitionStrategy
        }
    }

}

extension LexModelsV2ClientTypes.AgentTurnResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actualAgentPrompt
        case actualElicitedSlot
        case actualIntent
        case errorDetails
        case expectedAgentPrompt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actualAgentPrompt = self.actualAgentPrompt {
            try encodeContainer.encode(actualAgentPrompt, forKey: .actualAgentPrompt)
        }
        if let actualElicitedSlot = self.actualElicitedSlot {
            try encodeContainer.encode(actualElicitedSlot, forKey: .actualElicitedSlot)
        }
        if let actualIntent = self.actualIntent {
            try encodeContainer.encode(actualIntent, forKey: .actualIntent)
        }
        if let errorDetails = self.errorDetails {
            try encodeContainer.encode(errorDetails, forKey: .errorDetails)
        }
        if let expectedAgentPrompt = self.expectedAgentPrompt {
            try encodeContainer.encode(expectedAgentPrompt, forKey: .expectedAgentPrompt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expectedAgentPromptDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expectedAgentPrompt)
        expectedAgentPrompt = expectedAgentPromptDecoded
        let actualAgentPromptDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actualAgentPrompt)
        actualAgentPrompt = actualAgentPromptDecoded
        let errorDetailsDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ExecutionErrorDetails.self, forKey: .errorDetails)
        errorDetails = errorDetailsDecoded
        let actualElicitedSlotDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actualElicitedSlot)
        actualElicitedSlot = actualElicitedSlotDecoded
        let actualIntentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actualIntent)
        actualIntent = actualIntentDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// The information about the agent turn in a test set execution.
    public struct AgentTurnResult: Swift.Equatable {
        /// The actual agent prompt for the agent turn in a test set execution.
        public var actualAgentPrompt: Swift.String?
        /// The actual elicited slot for the agent turn in a test set execution.
        public var actualElicitedSlot: Swift.String?
        /// The actual intent for the agent turn in a test set execution.
        public var actualIntent: Swift.String?
        /// Details about an error in an execution of a test set.
        public var errorDetails: LexModelsV2ClientTypes.ExecutionErrorDetails?
        /// The expected agent prompt for the agent turn in a test set execution.
        /// This member is required.
        public var expectedAgentPrompt: Swift.String?

        public init(
            actualAgentPrompt: Swift.String? = nil,
            actualElicitedSlot: Swift.String? = nil,
            actualIntent: Swift.String? = nil,
            errorDetails: LexModelsV2ClientTypes.ExecutionErrorDetails? = nil,
            expectedAgentPrompt: Swift.String? = nil
        )
        {
            self.actualAgentPrompt = actualAgentPrompt
            self.actualElicitedSlot = actualElicitedSlot
            self.actualIntent = actualIntent
            self.errorDetails = errorDetails
            self.expectedAgentPrompt = expectedAgentPrompt
        }
    }

}

extension LexModelsV2ClientTypes.AgentTurnSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentPrompt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentPrompt = self.agentPrompt {
            try encodeContainer.encode(agentPrompt, forKey: .agentPrompt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentPromptDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentPrompt)
        agentPrompt = agentPromptDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// The specification of an agent turn.
    public struct AgentTurnSpecification: Swift.Equatable {
        /// The agent prompt for the agent turn in a test set.
        /// This member is required.
        public var agentPrompt: Swift.String?

        public init(
            agentPrompt: Swift.String? = nil
        )
        {
            self.agentPrompt = agentPrompt
        }
    }

}

extension LexModelsV2ClientTypes.AggregatedUtterancesFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case `operator` = "operator"
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AggregatedUtterancesFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let operatorDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AggregatedUtterancesFilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Filters responses returned by the ListAggregatedUtterances operation.
    public struct AggregatedUtterancesFilter: Swift.Equatable {
        /// The name of the field to filter the utterance list.
        /// This member is required.
        public var name: LexModelsV2ClientTypes.AggregatedUtterancesFilterName?
        /// The operator to use for the filter. Specify EQ when the ListAggregatedUtterances operation should return only utterances that equal the specified value. Specify CO when the ListAggregatedUtterances operation should return utterances that contain the specified value.
        /// This member is required.
        public var `operator`: LexModelsV2ClientTypes.AggregatedUtterancesFilterOperator?
        /// The value to use for filtering the list of bots.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: LexModelsV2ClientTypes.AggregatedUtterancesFilterName? = nil,
            `operator`: LexModelsV2ClientTypes.AggregatedUtterancesFilterOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum AggregatedUtterancesFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case utterance
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregatedUtterancesFilterName] {
            return [
                .utterance,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .utterance: return "Utterance"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AggregatedUtterancesFilterName(rawValue: rawValue) ?? AggregatedUtterancesFilterName.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes {
    public enum AggregatedUtterancesFilterOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case contains
        case equals
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregatedUtterancesFilterOperator] {
            return [
                .contains,
                .equals,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contains: return "CO"
            case .equals: return "EQ"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AggregatedUtterancesFilterOperator(rawValue: rawValue) ?? AggregatedUtterancesFilterOperator.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes {
    public enum AggregatedUtterancesSortAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case hitcount
        case missedcount
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregatedUtterancesSortAttribute] {
            return [
                .hitcount,
                .missedcount,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .hitcount: return "HitCount"
            case .missedcount: return "MissedCount"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AggregatedUtterancesSortAttribute(rawValue: rawValue) ?? AggregatedUtterancesSortAttribute.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.AggregatedUtterancesSortBy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute
        case order
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = self.attribute {
            try encodeContainer.encode(attribute.rawValue, forKey: .attribute)
        }
        if let order = self.order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AggregatedUtterancesSortAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let orderDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SortOrder.self, forKey: .order)
        order = orderDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Specifies attributes for sorting a list of utterances.
    public struct AggregatedUtterancesSortBy: Swift.Equatable {
        /// The utterance attribute to sort by.
        /// This member is required.
        public var attribute: LexModelsV2ClientTypes.AggregatedUtterancesSortAttribute?
        /// Specifies whether to sort the aggregated utterances in ascending or descending order.
        /// This member is required.
        public var order: LexModelsV2ClientTypes.SortOrder?

        public init(
            attribute: LexModelsV2ClientTypes.AggregatedUtterancesSortAttribute? = nil,
            order: LexModelsV2ClientTypes.SortOrder? = nil
        )
        {
            self.attribute = attribute
            self.order = order
        }
    }

}

extension LexModelsV2ClientTypes.AggregatedUtterancesSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containsDataFromDeletedResources
        case hitCount
        case missedCount
        case utterance
        case utteranceFirstRecordedInAggregationDuration
        case utteranceLastRecordedInAggregationDuration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containsDataFromDeletedResources = self.containsDataFromDeletedResources {
            try encodeContainer.encode(containsDataFromDeletedResources, forKey: .containsDataFromDeletedResources)
        }
        if let hitCount = self.hitCount {
            try encodeContainer.encode(hitCount, forKey: .hitCount)
        }
        if let missedCount = self.missedCount {
            try encodeContainer.encode(missedCount, forKey: .missedCount)
        }
        if let utterance = self.utterance {
            try encodeContainer.encode(utterance, forKey: .utterance)
        }
        if let utteranceFirstRecordedInAggregationDuration = self.utteranceFirstRecordedInAggregationDuration {
            try encodeContainer.encodeTimestamp(utteranceFirstRecordedInAggregationDuration, format: .epochSeconds, forKey: .utteranceFirstRecordedInAggregationDuration)
        }
        if let utteranceLastRecordedInAggregationDuration = self.utteranceLastRecordedInAggregationDuration {
            try encodeContainer.encodeTimestamp(utteranceLastRecordedInAggregationDuration, format: .epochSeconds, forKey: .utteranceLastRecordedInAggregationDuration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let utteranceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .utterance)
        utterance = utteranceDecoded
        let hitCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .hitCount)
        hitCount = hitCountDecoded
        let missedCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .missedCount)
        missedCount = missedCountDecoded
        let utteranceFirstRecordedInAggregationDurationDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .utteranceFirstRecordedInAggregationDuration)
        utteranceFirstRecordedInAggregationDuration = utteranceFirstRecordedInAggregationDurationDecoded
        let utteranceLastRecordedInAggregationDurationDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .utteranceLastRecordedInAggregationDuration)
        utteranceLastRecordedInAggregationDuration = utteranceLastRecordedInAggregationDurationDecoded
        let containsDataFromDeletedResourcesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .containsDataFromDeletedResources)
        containsDataFromDeletedResources = containsDataFromDeletedResourcesDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Provides summary information for aggregated utterances. The ListAggregatedUtterances operations combines all instances of the same utterance into a single aggregated summary.
    public struct AggregatedUtterancesSummary: Swift.Equatable {
        /// Aggregated utterance data may contain utterances from versions of your bot that have since been deleted. When the aggregated contains this kind of data, this field is set to true.
        public var containsDataFromDeletedResources: Swift.Bool?
        /// The number of times that the utterance was detected by Amazon Lex during the time period. When an utterance is detected, it activates an intent or a slot.
        public var hitCount: Swift.Int?
        /// The number of times that the utterance was missed by Amazon Lex An utterance is missed when it doesn't activate an intent or slot.
        public var missedCount: Swift.Int?
        /// The text of the utterance. If the utterance was used with the RecognizeUtterance operation, the text is the transcription of the audio utterance.
        public var utterance: Swift.String?
        /// The date and time that the utterance was first recorded in the time window for aggregation. An utterance may have been sent to Amazon Lex before that time, but only utterances within the time window are counted.
        public var utteranceFirstRecordedInAggregationDuration: ClientRuntime.Date?
        /// The last date and time that an utterance was recorded in the time window for aggregation. An utterance may be sent to Amazon Lex after that time, but only utterances within the time window are counted.
        public var utteranceLastRecordedInAggregationDuration: ClientRuntime.Date?

        public init(
            containsDataFromDeletedResources: Swift.Bool? = nil,
            hitCount: Swift.Int? = nil,
            missedCount: Swift.Int? = nil,
            utterance: Swift.String? = nil,
            utteranceFirstRecordedInAggregationDuration: ClientRuntime.Date? = nil,
            utteranceLastRecordedInAggregationDuration: ClientRuntime.Date? = nil
        )
        {
            self.containsDataFromDeletedResources = containsDataFromDeletedResources
            self.hitCount = hitCount
            self.missedCount = missedCount
            self.utterance = utterance
            self.utteranceFirstRecordedInAggregationDuration = utteranceFirstRecordedInAggregationDuration
            self.utteranceLastRecordedInAggregationDuration = utteranceLastRecordedInAggregationDuration
        }
    }

}

extension LexModelsV2ClientTypes.AllowedInputTypes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowAudioInput
        case allowDTMFInput
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowAudioInput = self.allowAudioInput {
            try encodeContainer.encode(allowAudioInput, forKey: .allowAudioInput)
        }
        if let allowDTMFInput = self.allowDTMFInput {
            try encodeContainer.encode(allowDTMFInput, forKey: .allowDTMFInput)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowAudioInputDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowAudioInput)
        allowAudioInput = allowAudioInputDecoded
        let allowDTMFInputDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowDTMFInput)
        allowDTMFInput = allowDTMFInputDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Specifies the allowed input types.
    public struct AllowedInputTypes: Swift.Equatable {
        /// Indicates whether audio input is allowed.
        /// This member is required.
        public var allowAudioInput: Swift.Bool?
        /// Indicates whether DTMF input is allowed.
        /// This member is required.
        public var allowDTMFInput: Swift.Bool?

        public init(
            allowAudioInput: Swift.Bool? = nil,
            allowDTMFInput: Swift.Bool? = nil
        )
        {
            self.allowAudioInput = allowAudioInput
            self.allowDTMFInput = allowDTMFInput
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum AnalyticsBinByName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case conversationstarttime
        case utterancetimestamp
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalyticsBinByName] {
            return [
                .conversationstarttime,
                .utterancetimestamp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .conversationstarttime: return "ConversationStartTime"
            case .utterancetimestamp: return "UtteranceTimestamp"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalyticsBinByName(rawValue: rawValue) ?? AnalyticsBinByName.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.AnalyticsBinBySpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interval
        case name
        case order
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let interval = self.interval {
            try encodeContainer.encode(interval.rawValue, forKey: .interval)
        }
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let order = self.order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsBinByName.self, forKey: .name)
        name = nameDecoded
        let intervalDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsInterval.self, forKey: .interval)
        interval = intervalDecoded
        let orderDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsSortOrder.self, forKey: .order)
        order = orderDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Contains the time metric, interval, and method by which to bin the analytics data.
    public struct AnalyticsBinBySpecification: Swift.Equatable {
        /// Specifies the interval of time by which to bin the analytics data.
        /// This member is required.
        public var interval: LexModelsV2ClientTypes.AnalyticsInterval?
        /// Specifies the time metric by which to bin the analytics data.
        /// This member is required.
        public var name: LexModelsV2ClientTypes.AnalyticsBinByName?
        /// Specifies whether to bin the analytics data in ascending or descending order. If this field is left blank, the default order is by the key of the bin in descending order.
        public var order: LexModelsV2ClientTypes.AnalyticsSortOrder?

        public init(
            interval: LexModelsV2ClientTypes.AnalyticsInterval? = nil,
            name: LexModelsV2ClientTypes.AnalyticsBinByName? = nil,
            order: LexModelsV2ClientTypes.AnalyticsSortOrder? = nil
        )
        {
            self.interval = interval
            self.name = name
            self.order = order
        }
    }

}

extension LexModelsV2ClientTypes.AnalyticsBinKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsBinByName.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .value)
        value = valueDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// An object containing the criterion by which to bin the results and the value that defines that bin.
    public struct AnalyticsBinKey: Swift.Equatable {
        /// The criterion by which to bin the results.
        public var name: LexModelsV2ClientTypes.AnalyticsBinByName?
        /// The value of the criterion that defines the bin.
        public var value: Swift.Int?

        public init(
            name: LexModelsV2ClientTypes.AnalyticsBinByName? = nil,
            value: Swift.Int? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum AnalyticsCommonFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case botaliasid
        case botversion
        case channel
        case localeid
        case modality
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalyticsCommonFilterName] {
            return [
                .botaliasid,
                .botversion,
                .channel,
                .localeid,
                .modality,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .botaliasid: return "BotAliasId"
            case .botversion: return "BotVersion"
            case .channel: return "Channel"
            case .localeid: return "LocaleId"
            case .modality: return "Modality"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalyticsCommonFilterName(rawValue: rawValue) ?? AnalyticsCommonFilterName.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes {
    public enum AnalyticsFilterOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equals
        case greaterthan
        case lessthan
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalyticsFilterOperator] {
            return [
                .equals,
                .greaterthan,
                .lessthan,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQ"
            case .greaterthan: return "GT"
            case .lessthan: return "LT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalyticsFilterOperator(rawValue: rawValue) ?? AnalyticsFilterOperator.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes {
    public enum AnalyticsIntentField: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case intentendstate
        case intentlevel
        case intentname
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalyticsIntentField] {
            return [
                .intentendstate,
                .intentlevel,
                .intentname,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .intentendstate: return "IntentEndState"
            case .intentlevel: return "IntentLevel"
            case .intentname: return "IntentName"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalyticsIntentField(rawValue: rawValue) ?? AnalyticsIntentField.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.AnalyticsIntentFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case `operator` = "operator"
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for analyticsfiltervalue0 in values {
                try valuesContainer.encode(analyticsfiltervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsIntentFilterName.self, forKey: .name)
        name = nameDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsFilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// Contains fields describing a condition by which to filter the intents. The expression may be understood as name
    ///     operator
    ///
    /// values. For example:
    ///
    /// * IntentName CO Book – The intent name contains the string "Book."
    ///
    /// * BotVersion EQ 2 – The bot version is equal to two.
    ///
    ///
    /// The operators that each filter supports are listed below:
    ///
    /// * BotAlias – EQ.
    ///
    /// * BotVersion – EQ.
    ///
    /// * LocaleId – EQ.
    ///
    /// * Modality – EQ.
    ///
    /// * Channel – EQ.
    ///
    /// * SessionId – EQ.
    ///
    /// * OriginatingRequestId – EQ.
    ///
    /// * IntentName – EQ, CO.
    ///
    /// * IntentEndState – EQ, CO.
    public struct AnalyticsIntentFilter: Swift.Equatable {
        /// The category by which to filter the intents. The descriptions for each option are as follows:
        ///
        /// * BotAlias – The name of the bot alias.
        ///
        /// * BotVersion – The version of the bot.
        ///
        /// * LocaleId – The locale of the bot.
        ///
        /// * Modality – The modality of the session with the bot (audio, DTMF, or text).
        ///
        /// * Channel – The channel that the bot is integrated with.
        ///
        /// * SessionId – The identifier of the session with the bot.
        ///
        /// * OriginatingRequestId – The identifier of the first request in a session.
        ///
        /// * IntentName – The name of the intent.
        ///
        /// * IntentEndState – The final state of the intent.
        /// This member is required.
        public var name: LexModelsV2ClientTypes.AnalyticsIntentFilterName?
        /// The operation by which to filter the category. The following operations are possible:
        ///
        /// * CO – Contains
        ///
        /// * EQ – Equals
        ///
        /// * GT – Greater than
        ///
        /// * LT – Less than
        ///
        ///
        /// The operators that each filter supports are listed below:
        ///
        /// * BotAlias – EQ.
        ///
        /// * BotVersion – EQ.
        ///
        /// * LocaleId – EQ.
        ///
        /// * Modality – EQ.
        ///
        /// * Channel – EQ.
        ///
        /// * SessionId – EQ.
        ///
        /// * OriginatingRequestId – EQ.
        ///
        /// * IntentName – EQ, CO.
        ///
        /// * IntentEndState – EQ, CO.
        /// This member is required.
        public var `operator`: LexModelsV2ClientTypes.AnalyticsFilterOperator?
        /// An array containing the values of the category by which to apply the operator to filter the results. You can provide multiple values if the operator is EQ or CO. If you provide multiple values, you filter for results that equal/contain any of the values. For example, if the name, operator, and values fields are Modality, EQ, and [Speech, Text], the operation filters for results where the modality was either Speech or Text.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: LexModelsV2ClientTypes.AnalyticsIntentFilterName? = nil,
            `operator`: LexModelsV2ClientTypes.AnalyticsFilterOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum AnalyticsIntentFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case botaliasid
        case botversion
        case channel
        case intentendstate
        case intentname
        case localeid
        case modality
        case originatingrequestid
        case sessionid
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalyticsIntentFilterName] {
            return [
                .botaliasid,
                .botversion,
                .channel,
                .intentendstate,
                .intentname,
                .localeid,
                .modality,
                .originatingrequestid,
                .sessionid,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .botaliasid: return "BotAliasId"
            case .botversion: return "BotVersion"
            case .channel: return "Channel"
            case .intentendstate: return "IntentEndState"
            case .intentname: return "IntentName"
            case .localeid: return "LocaleId"
            case .modality: return "Modality"
            case .originatingrequestid: return "OriginatingRequestId"
            case .sessionid: return "SessionId"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalyticsIntentFilterName(rawValue: rawValue) ?? AnalyticsIntentFilterName.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.AnalyticsIntentGroupByKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsIntentField.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Contains the category by which the intent analytics were grouped and a member of that category.
    public struct AnalyticsIntentGroupByKey: Swift.Equatable {
        /// A category by which the intent analytics were grouped.
        public var name: LexModelsV2ClientTypes.AnalyticsIntentField?
        /// A member of the category by which the intent analytics were grouped.
        public var value: Swift.String?

        public init(
            name: LexModelsV2ClientTypes.AnalyticsIntentField? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension LexModelsV2ClientTypes.AnalyticsIntentGroupBySpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsIntentField.self, forKey: .name)
        name = nameDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Contains the category by which to group the intents.
    public struct AnalyticsIntentGroupBySpecification: Swift.Equatable {
        /// Specifies whether to group the intent stages by their name or their end state.
        /// This member is required.
        public var name: LexModelsV2ClientTypes.AnalyticsIntentField?

        public init(
            name: LexModelsV2ClientTypes.AnalyticsIntentField? = nil
        )
        {
            self.name = name
        }
    }

}

extension LexModelsV2ClientTypes.AnalyticsIntentMetric: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case order
        case statistic
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let order = self.order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
        if let statistic = self.statistic {
            try encodeContainer.encode(statistic.rawValue, forKey: .statistic)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsIntentMetricName.self, forKey: .name)
        name = nameDecoded
        let statisticDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsMetricStatistic.self, forKey: .statistic)
        statistic = statisticDecoded
        let orderDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsSortOrder.self, forKey: .order)
        order = orderDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Contains the metric and the summary statistic you want to calculate, and the order in which to sort the results, for the intents in the bot.
    public struct AnalyticsIntentMetric: Swift.Equatable {
        /// The metric for which you want to get intent summary statistics.
        ///
        /// * Count – The number of times the intent was invoked.
        ///
        /// * Success – The number of times the intent succeeded.
        ///
        /// * Failure – The number of times the intent failed.
        ///
        /// * Switched – The number of times there was a switch to a different intent.
        ///
        /// * Dropped – The number of times the user dropped the intent.
        /// This member is required.
        public var name: LexModelsV2ClientTypes.AnalyticsIntentMetricName?
        /// Specifies whether to sort the results in ascending or descending order.
        public var order: LexModelsV2ClientTypes.AnalyticsSortOrder?
        /// The summary statistic to calculate.
        ///
        /// * Sum – The total count for the category you provide in name.
        ///
        /// * Average – The total count divided by the number of intents in the category you provide in name.
        ///
        /// * Max – The highest count in the category you provide in name.
        /// This member is required.
        public var statistic: LexModelsV2ClientTypes.AnalyticsMetricStatistic?

        public init(
            name: LexModelsV2ClientTypes.AnalyticsIntentMetricName? = nil,
            order: LexModelsV2ClientTypes.AnalyticsSortOrder? = nil,
            statistic: LexModelsV2ClientTypes.AnalyticsMetricStatistic? = nil
        )
        {
            self.name = name
            self.order = order
            self.statistic = statistic
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum AnalyticsIntentMetricName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case count
        case dropped
        case failure
        case success
        case switched
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalyticsIntentMetricName] {
            return [
                .count,
                .dropped,
                .failure,
                .success,
                .switched,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .count: return "Count"
            case .dropped: return "Dropped"
            case .failure: return "Failure"
            case .success: return "Success"
            case .switched: return "Switched"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalyticsIntentMetricName(rawValue: rawValue) ?? AnalyticsIntentMetricName.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.AnalyticsIntentMetricResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case statistic
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let statistic = self.statistic {
            try encodeContainer.encode(statistic.rawValue, forKey: .statistic)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsIntentMetricName.self, forKey: .name)
        name = nameDecoded
        let statisticDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsMetricStatistic.self, forKey: .statistic)
        statistic = statisticDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// An object containing the results for the intent metric you requested.
    public struct AnalyticsIntentMetricResult: Swift.Equatable {
        /// The metric that you requested. See [Key definitions](https://docs.aws.amazon.com/lexv2/latest/dg/analytics-key-definitions.html) for more details about these metrics.
        ///
        /// * Count – The number of times the intent was invoked.
        ///
        /// * Success – The number of times the intent succeeded.
        ///
        /// * Failure – The number of times the intent failed.
        ///
        /// * Switched – The number of times there was a switch to a different intent.
        ///
        /// * Dropped – The number of times the user dropped the intent.
        public var name: LexModelsV2ClientTypes.AnalyticsIntentMetricName?
        /// The statistic that you requested to calculate.
        ///
        /// * Sum – The total count for the category you provide in name.
        ///
        /// * Average – The total count divided by the number of intents in the category you provide in name.
        ///
        /// * Max – The highest count in the category you provide in name.
        public var statistic: LexModelsV2ClientTypes.AnalyticsMetricStatistic?
        /// The value of the summary statistic for the metric that you requested.
        public var value: Swift.Double?

        public init(
            name: LexModelsV2ClientTypes.AnalyticsIntentMetricName? = nil,
            statistic: LexModelsV2ClientTypes.AnalyticsMetricStatistic? = nil,
            value: Swift.Double? = nil
        )
        {
            self.name = name
            self.statistic = statistic
            self.value = value
        }
    }

}

extension LexModelsV2ClientTypes.AnalyticsIntentNodeSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case intentCount
        case intentLevel
        case intentName
        case intentPath
        case nodeType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let intentCount = self.intentCount {
            try encodeContainer.encode(intentCount, forKey: .intentCount)
        }
        if let intentLevel = self.intentLevel {
            try encodeContainer.encode(intentLevel, forKey: .intentLevel)
        }
        if let intentName = self.intentName {
            try encodeContainer.encode(intentName, forKey: .intentName)
        }
        if let intentPath = self.intentPath {
            try encodeContainer.encode(intentPath, forKey: .intentPath)
        }
        if let nodeType = self.nodeType {
            try encodeContainer.encode(nodeType.rawValue, forKey: .nodeType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intentName)
        intentName = intentNameDecoded
        let intentPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intentPath)
        intentPath = intentPathDecoded
        let intentCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .intentCount)
        intentCount = intentCountDecoded
        let intentLevelDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .intentLevel)
        intentLevel = intentLevelDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsNodeType.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// An object containing information about the requested path.
    public struct AnalyticsIntentNodeSummary: Swift.Equatable {
        /// The total number of sessions that follow the given path to the given intent.
        public var intentCount: Swift.Int?
        /// The number of intents up to and including the requested path.
        public var intentLevel: Swift.Int?
        /// The name of the intent at the end of the requested path.
        public var intentName: Swift.String?
        /// The path.
        public var intentPath: Swift.String?
        /// Specifies whether the node is the end of a path (Exit) or not (Inner).
        public var nodeType: LexModelsV2ClientTypes.AnalyticsNodeType?

        public init(
            intentCount: Swift.Int? = nil,
            intentLevel: Swift.Int? = nil,
            intentName: Swift.String? = nil,
            intentPath: Swift.String? = nil,
            nodeType: LexModelsV2ClientTypes.AnalyticsNodeType? = nil
        )
        {
            self.intentCount = intentCount
            self.intentLevel = intentLevel
            self.intentName = intentName
            self.intentPath = intentPath
            self.nodeType = nodeType
        }
    }

}

extension LexModelsV2ClientTypes.AnalyticsIntentResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case binKeys
        case groupByKeys
        case metricsResults
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let binKeys = binKeys {
            var binKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .binKeys)
            for analyticsbinkey0 in binKeys {
                try binKeysContainer.encode(analyticsbinkey0)
            }
        }
        if let groupByKeys = groupByKeys {
            var groupByKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupByKeys)
            for analyticsintentgroupbykey0 in groupByKeys {
                try groupByKeysContainer.encode(analyticsintentgroupbykey0)
            }
        }
        if let metricsResults = metricsResults {
            var metricsResultsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricsResults)
            for analyticsintentmetricresult0 in metricsResults {
                try metricsResultsContainer.encode(analyticsintentmetricresult0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let binKeysContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AnalyticsBinKey?].self, forKey: .binKeys)
        var binKeysDecoded0:[LexModelsV2ClientTypes.AnalyticsBinKey]? = nil
        if let binKeysContainer = binKeysContainer {
            binKeysDecoded0 = [LexModelsV2ClientTypes.AnalyticsBinKey]()
            for structure0 in binKeysContainer {
                if let structure0 = structure0 {
                    binKeysDecoded0?.append(structure0)
                }
            }
        }
        binKeys = binKeysDecoded0
        let groupByKeysContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AnalyticsIntentGroupByKey?].self, forKey: .groupByKeys)
        var groupByKeysDecoded0:[LexModelsV2ClientTypes.AnalyticsIntentGroupByKey]? = nil
        if let groupByKeysContainer = groupByKeysContainer {
            groupByKeysDecoded0 = [LexModelsV2ClientTypes.AnalyticsIntentGroupByKey]()
            for structure0 in groupByKeysContainer {
                if let structure0 = structure0 {
                    groupByKeysDecoded0?.append(structure0)
                }
            }
        }
        groupByKeys = groupByKeysDecoded0
        let metricsResultsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AnalyticsIntentMetricResult?].self, forKey: .metricsResults)
        var metricsResultsDecoded0:[LexModelsV2ClientTypes.AnalyticsIntentMetricResult]? = nil
        if let metricsResultsContainer = metricsResultsContainer {
            metricsResultsDecoded0 = [LexModelsV2ClientTypes.AnalyticsIntentMetricResult]()
            for structure0 in metricsResultsContainer {
                if let structure0 = structure0 {
                    metricsResultsDecoded0?.append(structure0)
                }
            }
        }
        metricsResults = metricsResultsDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// An object containing the results for the intent metrics you requested and the bin and/or group(s) they refer to, if applicable.
    public struct AnalyticsIntentResult: Swift.Equatable {
        /// A list of objects containing the criteria you requested for binning results and the values of the bins.
        public var binKeys: [LexModelsV2ClientTypes.AnalyticsBinKey]?
        /// A list of objects containing the criteria you requested for grouping results and the values of the groups.
        public var groupByKeys: [LexModelsV2ClientTypes.AnalyticsIntentGroupByKey]?
        /// A list of objects, each of which contains a metric you want to list, the statistic for the metric you want to return, and the method by which to organize the results.
        public var metricsResults: [LexModelsV2ClientTypes.AnalyticsIntentMetricResult]?

        public init(
            binKeys: [LexModelsV2ClientTypes.AnalyticsBinKey]? = nil,
            groupByKeys: [LexModelsV2ClientTypes.AnalyticsIntentGroupByKey]? = nil,
            metricsResults: [LexModelsV2ClientTypes.AnalyticsIntentMetricResult]? = nil
        )
        {
            self.binKeys = binKeys
            self.groupByKeys = groupByKeys
            self.metricsResults = metricsResults
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum AnalyticsIntentStageField: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case intentstagename
        case switchedtointent
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalyticsIntentStageField] {
            return [
                .intentstagename,
                .switchedtointent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .intentstagename: return "IntentStageName"
            case .switchedtointent: return "SwitchedToIntent"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalyticsIntentStageField(rawValue: rawValue) ?? AnalyticsIntentStageField.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.AnalyticsIntentStageFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case `operator` = "operator"
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for analyticsfiltervalue0 in values {
                try valuesContainer.encode(analyticsfiltervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsIntentStageFilterName.self, forKey: .name)
        name = nameDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsFilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// Contains fields describing a condition by which to filter the intent stages. The expression may be understood as name
    ///     operator
    ///
    /// values. For example:
    ///
    /// * IntentName CO Book – The intent name contains the string "Book."
    ///
    /// * BotVersion EQ 2 – The bot version is equal to two.
    ///
    ///
    /// The operators that each filter supports are listed below:
    ///
    /// * BotAlias – EQ.
    ///
    /// * BotVersion – EQ.
    ///
    /// * LocaleId – EQ.
    ///
    /// * Modality – EQ.
    ///
    /// * Channel – EQ.
    ///
    /// * SessionId – EQ.
    ///
    /// * OriginatingRequestId – EQ.
    ///
    /// * IntentName – EQ, CO.
    ///
    /// * IntentStageName – EQ, CO.
    public struct AnalyticsIntentStageFilter: Swift.Equatable {
        /// The category by which to filter the intent stages. The descriptions for each option are as follows:
        ///
        /// * BotAlias – The name of the bot alias.
        ///
        /// * BotVersion – The version of the bot.
        ///
        /// * LocaleId – The locale of the bot.
        ///
        /// * Modality – The modality of the session with the bot (audio, DTMF, or text).
        ///
        /// * Channel – The channel that the bot is integrated with.
        ///
        /// * SessionId – The identifier of the session with the bot.
        ///
        /// * OriginatingRequestId – The identifier of the first request in a session.
        ///
        /// * IntentName – The name of the intent.
        ///
        /// * IntentStageName – The stage in the intent.
        /// This member is required.
        public var name: LexModelsV2ClientTypes.AnalyticsIntentStageFilterName?
        /// The operation by which to filter the category. The following operations are possible:
        ///
        /// * CO – Contains
        ///
        /// * EQ – Equals
        ///
        /// * GT – Greater than
        ///
        /// * LT – Less than
        ///
        ///
        /// The operators that each filter supports are listed below:
        ///
        /// * BotAlias – EQ.
        ///
        /// * BotVersion – EQ.
        ///
        /// * LocaleId – EQ.
        ///
        /// * Modality – EQ.
        ///
        /// * Channel – EQ.
        ///
        /// * SessionId – EQ.
        ///
        /// * OriginatingRequestId – EQ.
        ///
        /// * IntentName – EQ, CO.
        ///
        /// * IntentStageName – EQ, CO.
        /// This member is required.
        public var `operator`: LexModelsV2ClientTypes.AnalyticsFilterOperator?
        /// An array containing the values of the category by which to apply the operator to filter the results. You can provide multiple values if the operator is EQ or CO. If you provide multiple values, you filter for results that equal/contain any of the values. For example, if the name, operator, and values fields are Modality, EQ, and [Speech, Text], the operation filters for results where the modality was either Speech or Text.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: LexModelsV2ClientTypes.AnalyticsIntentStageFilterName? = nil,
            `operator`: LexModelsV2ClientTypes.AnalyticsFilterOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum AnalyticsIntentStageFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case botaliasid
        case botversion
        case channel
        case intentname
        case intentstagename
        case localeid
        case modality
        case originatingrequestid
        case sessionid
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalyticsIntentStageFilterName] {
            return [
                .botaliasid,
                .botversion,
                .channel,
                .intentname,
                .intentstagename,
                .localeid,
                .modality,
                .originatingrequestid,
                .sessionid,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .botaliasid: return "BotAliasId"
            case .botversion: return "BotVersion"
            case .channel: return "Channel"
            case .intentname: return "IntentName"
            case .intentstagename: return "IntentStageName"
            case .localeid: return "LocaleId"
            case .modality: return "Modality"
            case .originatingrequestid: return "OriginatingRequestId"
            case .sessionid: return "SessionId"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalyticsIntentStageFilterName(rawValue: rawValue) ?? AnalyticsIntentStageFilterName.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.AnalyticsIntentStageGroupByKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsIntentStageField.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Contains the category by which the intent stage analytics and the values for that category were grouped.
    public struct AnalyticsIntentStageGroupByKey: Swift.Equatable {
        /// A category by which the intent stage analytics were grouped.
        public var name: LexModelsV2ClientTypes.AnalyticsIntentStageField?
        /// A member of the category by which the intent stage analytics were grouped.
        public var value: Swift.String?

        public init(
            name: LexModelsV2ClientTypes.AnalyticsIntentStageField? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension LexModelsV2ClientTypes.AnalyticsIntentStageGroupBySpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsIntentStageField.self, forKey: .name)
        name = nameDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Contains the category by which to group the intent stages.
    public struct AnalyticsIntentStageGroupBySpecification: Swift.Equatable {
        /// Specifies whether to group the intent stages by their name or the intent to which the session was switched.
        /// This member is required.
        public var name: LexModelsV2ClientTypes.AnalyticsIntentStageField?

        public init(
            name: LexModelsV2ClientTypes.AnalyticsIntentStageField? = nil
        )
        {
            self.name = name
        }
    }

}

extension LexModelsV2ClientTypes.AnalyticsIntentStageMetric: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case order
        case statistic
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let order = self.order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
        if let statistic = self.statistic {
            try encodeContainer.encode(statistic.rawValue, forKey: .statistic)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsIntentStageMetricName.self, forKey: .name)
        name = nameDecoded
        let statisticDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsMetricStatistic.self, forKey: .statistic)
        statistic = statisticDecoded
        let orderDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsSortOrder.self, forKey: .order)
        order = orderDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Contains the metric and the summary statistic you want to calculate, and the order in which to sort the results, for the intent stages across the user sessions with the bot.
    public struct AnalyticsIntentStageMetric: Swift.Equatable {
        /// The metric for which you want to get intent stage summary statistics. See [Key definitions](https://docs.aws.amazon.com/lexv2/latest/dg/analytics-key-definitions.html) for more details about these metrics.
        ///
        /// * Count – The number of times the intent stage occurred.
        ///
        /// * Success – The number of times the intent stage succeeded.
        ///
        /// * Failure – The number of times the intent stage failed.
        ///
        /// * Dropped – The number of times the user dropped the intent stage.
        ///
        /// * Retry – The number of times the bot tried to elicit a response from the user at this stage.
        /// This member is required.
        public var name: LexModelsV2ClientTypes.AnalyticsIntentStageMetricName?
        /// Specifies whether to sort the results in ascending or descending order of the summary statistic (value in the response).
        public var order: LexModelsV2ClientTypes.AnalyticsSortOrder?
        /// The summary statistic to calculate.
        ///
        /// * Sum – The total count for the category you provide in name.
        ///
        /// * Average – The total count divided by the number of intent stages in the category you provide in name.
        ///
        /// * Max – The highest count in the category you provide in name.
        /// This member is required.
        public var statistic: LexModelsV2ClientTypes.AnalyticsMetricStatistic?

        public init(
            name: LexModelsV2ClientTypes.AnalyticsIntentStageMetricName? = nil,
            order: LexModelsV2ClientTypes.AnalyticsSortOrder? = nil,
            statistic: LexModelsV2ClientTypes.AnalyticsMetricStatistic? = nil
        )
        {
            self.name = name
            self.order = order
            self.statistic = statistic
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum AnalyticsIntentStageMetricName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case count
        case dropped
        case failed
        case retry
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalyticsIntentStageMetricName] {
            return [
                .count,
                .dropped,
                .failed,
                .retry,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .count: return "Count"
            case .dropped: return "Dropped"
            case .failed: return "Failed"
            case .retry: return "Retry"
            case .success: return "Success"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalyticsIntentStageMetricName(rawValue: rawValue) ?? AnalyticsIntentStageMetricName.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.AnalyticsIntentStageMetricResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case statistic
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let statistic = self.statistic {
            try encodeContainer.encode(statistic.rawValue, forKey: .statistic)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsIntentStageMetricName.self, forKey: .name)
        name = nameDecoded
        let statisticDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsMetricStatistic.self, forKey: .statistic)
        statistic = statisticDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// An object containing the results for an intent stage metric you requested.
    public struct AnalyticsIntentStageMetricResult: Swift.Equatable {
        /// The metric that you requested.
        ///
        /// * Count – The number of times the intent stage occurred.
        ///
        /// * Success – The number of times the intent stage succeeded.
        ///
        /// * Failure – The number of times the intent stage failed.
        ///
        /// * Dropped – The number of times the user dropped the intent stage.
        ///
        /// * Retry – The number of times the bot tried to elicit a response from the user at this stage.
        public var name: LexModelsV2ClientTypes.AnalyticsIntentStageMetricName?
        /// The summary statistic that you requested to calculate.
        ///
        /// * Sum – The total count for the category you provide in name.
        ///
        /// * Average – The total count divided by the number of intent stages in the category you provide in name.
        ///
        /// * Max – The highest count in the category you provide in name.
        public var statistic: LexModelsV2ClientTypes.AnalyticsMetricStatistic?
        /// The value of the summary statistic for the metric that you requested.
        public var value: Swift.Double?

        public init(
            name: LexModelsV2ClientTypes.AnalyticsIntentStageMetricName? = nil,
            statistic: LexModelsV2ClientTypes.AnalyticsMetricStatistic? = nil,
            value: Swift.Double? = nil
        )
        {
            self.name = name
            self.statistic = statistic
            self.value = value
        }
    }

}

extension LexModelsV2ClientTypes.AnalyticsIntentStageResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case binKeys
        case groupByKeys
        case metricsResults
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let binKeys = binKeys {
            var binKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .binKeys)
            for analyticsbinkey0 in binKeys {
                try binKeysContainer.encode(analyticsbinkey0)
            }
        }
        if let groupByKeys = groupByKeys {
            var groupByKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupByKeys)
            for analyticsintentstagegroupbykey0 in groupByKeys {
                try groupByKeysContainer.encode(analyticsintentstagegroupbykey0)
            }
        }
        if let metricsResults = metricsResults {
            var metricsResultsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricsResults)
            for analyticsintentstagemetricresult0 in metricsResults {
                try metricsResultsContainer.encode(analyticsintentstagemetricresult0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let binKeysContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AnalyticsBinKey?].self, forKey: .binKeys)
        var binKeysDecoded0:[LexModelsV2ClientTypes.AnalyticsBinKey]? = nil
        if let binKeysContainer = binKeysContainer {
            binKeysDecoded0 = [LexModelsV2ClientTypes.AnalyticsBinKey]()
            for structure0 in binKeysContainer {
                if let structure0 = structure0 {
                    binKeysDecoded0?.append(structure0)
                }
            }
        }
        binKeys = binKeysDecoded0
        let groupByKeysContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AnalyticsIntentStageGroupByKey?].self, forKey: .groupByKeys)
        var groupByKeysDecoded0:[LexModelsV2ClientTypes.AnalyticsIntentStageGroupByKey]? = nil
        if let groupByKeysContainer = groupByKeysContainer {
            groupByKeysDecoded0 = [LexModelsV2ClientTypes.AnalyticsIntentStageGroupByKey]()
            for structure0 in groupByKeysContainer {
                if let structure0 = structure0 {
                    groupByKeysDecoded0?.append(structure0)
                }
            }
        }
        groupByKeys = groupByKeysDecoded0
        let metricsResultsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AnalyticsIntentStageMetricResult?].self, forKey: .metricsResults)
        var metricsResultsDecoded0:[LexModelsV2ClientTypes.AnalyticsIntentStageMetricResult]? = nil
        if let metricsResultsContainer = metricsResultsContainer {
            metricsResultsDecoded0 = [LexModelsV2ClientTypes.AnalyticsIntentStageMetricResult]()
            for structure0 in metricsResultsContainer {
                if let structure0 = structure0 {
                    metricsResultsDecoded0?.append(structure0)
                }
            }
        }
        metricsResults = metricsResultsDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// An object containing the results for the intent stage metrics you requested and the bin and/or group they refer to, if applicable.
    public struct AnalyticsIntentStageResult: Swift.Equatable {
        /// A list of objects containing the criteria you requested for binning results and the values of the bins.
        public var binKeys: [LexModelsV2ClientTypes.AnalyticsBinKey]?
        /// A list of objects containing the criteria you requested for grouping results and the values of the bins.
        public var groupByKeys: [LexModelsV2ClientTypes.AnalyticsIntentStageGroupByKey]?
        /// A list of objects, each of which contains a metric you want to list, the statistic for the metric you want to return, and the method by which to organize the results.
        public var metricsResults: [LexModelsV2ClientTypes.AnalyticsIntentStageMetricResult]?

        public init(
            binKeys: [LexModelsV2ClientTypes.AnalyticsBinKey]? = nil,
            groupByKeys: [LexModelsV2ClientTypes.AnalyticsIntentStageGroupByKey]? = nil,
            metricsResults: [LexModelsV2ClientTypes.AnalyticsIntentStageMetricResult]? = nil
        )
        {
            self.binKeys = binKeys
            self.groupByKeys = groupByKeys
            self.metricsResults = metricsResults
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum AnalyticsInterval: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case oneday
        case onehour
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalyticsInterval] {
            return [
                .oneday,
                .onehour,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .oneday: return "OneDay"
            case .onehour: return "OneHour"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalyticsInterval(rawValue: rawValue) ?? AnalyticsInterval.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes {
    public enum AnalyticsMetricStatistic: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case avg
        case max
        case sum
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalyticsMetricStatistic] {
            return [
                .avg,
                .max,
                .sum,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .avg: return "Avg"
            case .max: return "Max"
            case .sum: return "Sum"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalyticsMetricStatistic(rawValue: rawValue) ?? AnalyticsMetricStatistic.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes {
    public enum AnalyticsModality: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dtmf
        case multimode
        case speech
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalyticsModality] {
            return [
                .dtmf,
                .multimode,
                .speech,
                .text,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dtmf: return "DTMF"
            case .multimode: return "MultiMode"
            case .speech: return "Speech"
            case .text: return "Text"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalyticsModality(rawValue: rawValue) ?? AnalyticsModality.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes {
    public enum AnalyticsNodeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case exit
        case inner
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalyticsNodeType] {
            return [
                .exit,
                .inner,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .exit: return "Exit"
            case .inner: return "Inner"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalyticsNodeType(rawValue: rawValue) ?? AnalyticsNodeType.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.AnalyticsPathFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case `operator` = "operator"
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for analyticsfiltervalue0 in values {
                try valuesContainer.encode(analyticsfiltervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsCommonFilterName.self, forKey: .name)
        name = nameDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsFilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// Contains fields describing a condition by which to filter the paths. The expression may be understood as name
    ///     operator
    ///
    /// values. For example:
    ///
    /// * LocaleId EQ en – The locale is "en".
    ///
    /// * BotVersion EQ 2 – The bot version is equal to two.
    ///
    ///
    /// The operators that each filter supports are listed below:
    ///
    /// * BotAlias – EQ.
    ///
    /// * BotVersion – EQ.
    ///
    /// * LocaleId – EQ.
    ///
    /// * Modality – EQ.
    ///
    /// * Channel – EQ.
    public struct AnalyticsPathFilter: Swift.Equatable {
        /// The category by which to filter the intent paths. The descriptions for each option are as follows:
        ///
        /// * BotAlias – The name of the bot alias.
        ///
        /// * BotVersion – The version of the bot.
        ///
        /// * LocaleId – The locale of the bot.
        ///
        /// * Modality – The modality of the session with the bot (audio, DTMF, or text).
        ///
        /// * Channel – The channel that the bot is integrated with.
        /// This member is required.
        public var name: LexModelsV2ClientTypes.AnalyticsCommonFilterName?
        /// The operation by which to filter the category. The following operations are possible:
        ///
        /// * CO – Contains
        ///
        /// * EQ – Equals
        ///
        /// * GT – Greater than
        ///
        /// * LT – Less than
        ///
        ///
        /// The operators that each filter supports are listed below:
        ///
        /// * BotAlias – EQ.
        ///
        /// * BotVersion – EQ.
        ///
        /// * LocaleId – EQ.
        ///
        /// * Modality – EQ.
        ///
        /// * Channel – EQ.
        /// This member is required.
        public var `operator`: LexModelsV2ClientTypes.AnalyticsFilterOperator?
        /// An array containing the values of the category by which to apply the operator to filter the results. You can provide multiple values if the operator is EQ or CO. If you provide multiple values, you filter for results that equal/contain any of the values. For example, if the name, operator, and values fields are Modality, EQ, and [Speech, Text], the operation filters for results where the modality was either Speech or Text.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: LexModelsV2ClientTypes.AnalyticsCommonFilterName? = nil,
            `operator`: LexModelsV2ClientTypes.AnalyticsFilterOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum AnalyticsSessionField: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case conversationendstate
        case localeid
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalyticsSessionField] {
            return [
                .conversationendstate,
                .localeid,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .conversationendstate: return "ConversationEndState"
            case .localeid: return "LocaleId"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalyticsSessionField(rawValue: rawValue) ?? AnalyticsSessionField.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.AnalyticsSessionFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case `operator` = "operator"
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for analyticsfiltervalue0 in values {
                try valuesContainer.encode(analyticsfiltervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsSessionFilterName.self, forKey: .name)
        name = nameDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsFilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// Contains fields describing a condition by which to filter the sessions. The expression may be understood as name
    ///     operator
    ///
    /// values. For example:
    ///
    /// * LocaleId EQ en – The locale is "en".
    ///
    /// * Duration GT 200 – The duration is greater than 200 seconds.
    ///
    ///
    /// The operators that each filter supports are listed below:
    ///
    /// * BotAlias – EQ.
    ///
    /// * BotVersion – EQ.
    ///
    /// * LocaleId – EQ.
    ///
    /// * Modality – EQ.
    ///
    /// * Channel – EQ.
    ///
    /// * Duration – EQ, GT, LT.
    ///
    /// * conversationEndState – EQ, CO.
    ///
    /// * SessionId – EQ.
    ///
    /// * OriginatingRequestId – EQ.
    ///
    /// * IntentPath – EQ.
    public struct AnalyticsSessionFilter: Swift.Equatable {
        /// The category by which to filter the sessions. The descriptions for each option are as follows:
        ///
        /// * BotAlias – The name of the bot alias.
        ///
        /// * BotVersion – The version of the bot.
        ///
        /// * LocaleId – The locale of the bot.
        ///
        /// * Modality – The modality of the session with the bot (audio, DTMF, or text).
        ///
        /// * Channel – The channel that the bot is integrated with.
        ///
        /// * Duration – The duration of the session.
        ///
        /// * conversationEndState – The final state of the session.
        ///
        /// * SessionId – The identifier of the session with the bot.
        ///
        /// * OriginatingRequestId – The identifier of the first request in a session.
        ///
        /// * IntentPath – The order of intents taken in a session.
        /// This member is required.
        public var name: LexModelsV2ClientTypes.AnalyticsSessionFilterName?
        /// The operation by which to filter the category. The following operations are possible:
        ///
        /// * CO – Contains
        ///
        /// * EQ – Equals
        ///
        /// * GT – Greater than
        ///
        /// * LT – Less than
        ///
        ///
        /// The operators that each filter supports are listed below:
        ///
        /// * BotAlias – EQ.
        ///
        /// * BotVersion – EQ.
        ///
        /// * LocaleId – EQ.
        ///
        /// * Modality – EQ.
        ///
        /// * Channel – EQ.
        ///
        /// * Duration – EQ, GT, LT.
        ///
        /// * conversationEndState – EQ, CO.
        ///
        /// * SessionId – EQ.
        ///
        /// * OriginatingRequestId – EQ.
        ///
        /// * IntentPath – EQ.
        /// This member is required.
        public var `operator`: LexModelsV2ClientTypes.AnalyticsFilterOperator?
        /// An array containing the values of the category by which to apply the operator to filter the results. You can provide multiple values if the operator is EQ or CO. If you provide multiple values, you filter for results that equal/contain any of the values. For example, if the name, operator, and values fields are Modality, EQ, and [Speech, Text], the operation filters for results where the modality was either Speech or Text.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: LexModelsV2ClientTypes.AnalyticsSessionFilterName? = nil,
            `operator`: LexModelsV2ClientTypes.AnalyticsFilterOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum AnalyticsSessionFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case botaliasid
        case botversion
        case channel
        case conversationendstate
        case duration
        case intentpath
        case localeid
        case modality
        case originatingrequestid
        case sessionid
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalyticsSessionFilterName] {
            return [
                .botaliasid,
                .botversion,
                .channel,
                .conversationendstate,
                .duration,
                .intentpath,
                .localeid,
                .modality,
                .originatingrequestid,
                .sessionid,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .botaliasid: return "BotAliasId"
            case .botversion: return "BotVersion"
            case .channel: return "Channel"
            case .conversationendstate: return "ConversationEndState"
            case .duration: return "Duration"
            case .intentpath: return "IntentPath"
            case .localeid: return "LocaleId"
            case .modality: return "Modality"
            case .originatingrequestid: return "OriginatingRequestId"
            case .sessionid: return "SessionId"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalyticsSessionFilterName(rawValue: rawValue) ?? AnalyticsSessionFilterName.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.AnalyticsSessionGroupByKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsSessionField.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Contains the category by which the session analytics were grouped and a member of that category.
    public struct AnalyticsSessionGroupByKey: Swift.Equatable {
        /// The category by which the session analytics were grouped.
        public var name: LexModelsV2ClientTypes.AnalyticsSessionField?
        /// A member of the category by which the session analytics were grouped.
        public var value: Swift.String?

        public init(
            name: LexModelsV2ClientTypes.AnalyticsSessionField? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension LexModelsV2ClientTypes.AnalyticsSessionGroupBySpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsSessionField.self, forKey: .name)
        name = nameDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Contains the category by which to group the sessions.
    public struct AnalyticsSessionGroupBySpecification: Swift.Equatable {
        /// Specifies whether to group the session by their end state or their locale.
        /// This member is required.
        public var name: LexModelsV2ClientTypes.AnalyticsSessionField?

        public init(
            name: LexModelsV2ClientTypes.AnalyticsSessionField? = nil
        )
        {
            self.name = name
        }
    }

}

extension LexModelsV2ClientTypes.AnalyticsSessionMetric: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case order
        case statistic
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let order = self.order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
        if let statistic = self.statistic {
            try encodeContainer.encode(statistic.rawValue, forKey: .statistic)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsSessionMetricName.self, forKey: .name)
        name = nameDecoded
        let statisticDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsMetricStatistic.self, forKey: .statistic)
        statistic = statisticDecoded
        let orderDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsSortOrder.self, forKey: .order)
        order = orderDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Contains the metric and the summary statistic you want to calculate, and the order in which to sort the results, for the user sessions with the bot.
    public struct AnalyticsSessionMetric: Swift.Equatable {
        /// The metric for which you want to get session summary statistics.
        ///
        /// * Count – The number of sessions.
        ///
        /// * Success – The number of sessions that succeeded.
        ///
        /// * Failure – The number of sessions that failed.
        ///
        /// * Dropped – The number of sessions that the user dropped.
        ///
        /// * Duration – The duration of sessions.
        ///
        /// * TurnsPerSession – The number of turns in the sessions.
        ///
        /// * Concurrency – The number of sessions occurring in the same period of time.
        /// This member is required.
        public var name: LexModelsV2ClientTypes.AnalyticsSessionMetricName?
        /// Specifies whether to sort the results in ascending or descending order.
        public var order: LexModelsV2ClientTypes.AnalyticsSortOrder?
        /// The summary statistic to calculate.
        ///
        /// * Sum – The total count for the category you provide in name.
        ///
        /// * Average – The total count divided by the number of sessions in the category you provide in name.
        ///
        /// * Max – The highest count in the category you provide in name.
        /// This member is required.
        public var statistic: LexModelsV2ClientTypes.AnalyticsMetricStatistic?

        public init(
            name: LexModelsV2ClientTypes.AnalyticsSessionMetricName? = nil,
            order: LexModelsV2ClientTypes.AnalyticsSortOrder? = nil,
            statistic: LexModelsV2ClientTypes.AnalyticsMetricStatistic? = nil
        )
        {
            self.name = name
            self.order = order
            self.statistic = statistic
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum AnalyticsSessionMetricName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case concurrency
        case count
        case dropped
        case duration
        case failure
        case success
        case turnsperconversation
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalyticsSessionMetricName] {
            return [
                .concurrency,
                .count,
                .dropped,
                .duration,
                .failure,
                .success,
                .turnsperconversation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .concurrency: return "Concurrency"
            case .count: return "Count"
            case .dropped: return "Dropped"
            case .duration: return "Duration"
            case .failure: return "Failure"
            case .success: return "Success"
            case .turnsperconversation: return "TurnsPerConversation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalyticsSessionMetricName(rawValue: rawValue) ?? AnalyticsSessionMetricName.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.AnalyticsSessionMetricResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case statistic
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let statistic = self.statistic {
            try encodeContainer.encode(statistic.rawValue, forKey: .statistic)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsSessionMetricName.self, forKey: .name)
        name = nameDecoded
        let statisticDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsMetricStatistic.self, forKey: .statistic)
        statistic = statisticDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// An object containing the results for a session metric you requested.
    public struct AnalyticsSessionMetricResult: Swift.Equatable {
        /// The metric that you requested.
        ///
        /// * Count – The number of sessions.
        ///
        /// * Success – The number of sessions that succeeded.
        ///
        /// * Failure – The number of sessions that failed.
        ///
        /// * Dropped – The number of sessions that the user dropped.
        ///
        /// * Duration – The duration of sessions.
        ///
        /// * TurnPersession – The number of turns in the sessions.
        ///
        /// * Concurrency – The number of sessions occurring in the same period of time.
        public var name: LexModelsV2ClientTypes.AnalyticsSessionMetricName?
        /// The summary statistic that you requested to calculate.
        ///
        /// * Sum – The total count for the category you provide in name.
        ///
        /// * Average – The total count divided by the number of sessions in the category you provide in name.
        ///
        /// * Max – The highest count in the category you provide in name.
        public var statistic: LexModelsV2ClientTypes.AnalyticsMetricStatistic?
        /// The value of the summary statistic for the metric that you requested.
        public var value: Swift.Double?

        public init(
            name: LexModelsV2ClientTypes.AnalyticsSessionMetricName? = nil,
            statistic: LexModelsV2ClientTypes.AnalyticsMetricStatistic? = nil,
            value: Swift.Double? = nil
        )
        {
            self.name = name
            self.statistic = statistic
            self.value = value
        }
    }

}

extension LexModelsV2ClientTypes.AnalyticsSessionResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case binKeys
        case groupByKeys
        case metricsResults
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let binKeys = binKeys {
            var binKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .binKeys)
            for analyticsbinkey0 in binKeys {
                try binKeysContainer.encode(analyticsbinkey0)
            }
        }
        if let groupByKeys = groupByKeys {
            var groupByKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupByKeys)
            for analyticssessiongroupbykey0 in groupByKeys {
                try groupByKeysContainer.encode(analyticssessiongroupbykey0)
            }
        }
        if let metricsResults = metricsResults {
            var metricsResultsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricsResults)
            for analyticssessionmetricresult0 in metricsResults {
                try metricsResultsContainer.encode(analyticssessionmetricresult0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let binKeysContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AnalyticsBinKey?].self, forKey: .binKeys)
        var binKeysDecoded0:[LexModelsV2ClientTypes.AnalyticsBinKey]? = nil
        if let binKeysContainer = binKeysContainer {
            binKeysDecoded0 = [LexModelsV2ClientTypes.AnalyticsBinKey]()
            for structure0 in binKeysContainer {
                if let structure0 = structure0 {
                    binKeysDecoded0?.append(structure0)
                }
            }
        }
        binKeys = binKeysDecoded0
        let groupByKeysContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AnalyticsSessionGroupByKey?].self, forKey: .groupByKeys)
        var groupByKeysDecoded0:[LexModelsV2ClientTypes.AnalyticsSessionGroupByKey]? = nil
        if let groupByKeysContainer = groupByKeysContainer {
            groupByKeysDecoded0 = [LexModelsV2ClientTypes.AnalyticsSessionGroupByKey]()
            for structure0 in groupByKeysContainer {
                if let structure0 = structure0 {
                    groupByKeysDecoded0?.append(structure0)
                }
            }
        }
        groupByKeys = groupByKeysDecoded0
        let metricsResultsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AnalyticsSessionMetricResult?].self, forKey: .metricsResults)
        var metricsResultsDecoded0:[LexModelsV2ClientTypes.AnalyticsSessionMetricResult]? = nil
        if let metricsResultsContainer = metricsResultsContainer {
            metricsResultsDecoded0 = [LexModelsV2ClientTypes.AnalyticsSessionMetricResult]()
            for structure0 in metricsResultsContainer {
                if let structure0 = structure0 {
                    metricsResultsDecoded0?.append(structure0)
                }
            }
        }
        metricsResults = metricsResultsDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// An object containing the results for the session metrics you requested and the bin and/or group(s) they refer to, if applicable.
    public struct AnalyticsSessionResult: Swift.Equatable {
        /// A list of objects containing the criteria you requested for binning results and the values of the bins.
        public var binKeys: [LexModelsV2ClientTypes.AnalyticsBinKey]?
        /// A list of objects containing the criteria you requested for grouping results and the values of the bins.
        public var groupByKeys: [LexModelsV2ClientTypes.AnalyticsSessionGroupByKey]?
        /// A list of objects, each of which contains a metric you want to list, the statistic for the metric you want to return, and the method by which to organize the results.
        public var metricsResults: [LexModelsV2ClientTypes.AnalyticsSessionMetricResult]?

        public init(
            binKeys: [LexModelsV2ClientTypes.AnalyticsBinKey]? = nil,
            groupByKeys: [LexModelsV2ClientTypes.AnalyticsSessionGroupByKey]? = nil,
            metricsResults: [LexModelsV2ClientTypes.AnalyticsSessionMetricResult]? = nil
        )
        {
            self.binKeys = binKeys
            self.groupByKeys = groupByKeys
            self.metricsResults = metricsResults
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum AnalyticsSessionSortByName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case conversationstarttime
        case duration
        case numberofturns
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalyticsSessionSortByName] {
            return [
                .conversationstarttime,
                .duration,
                .numberofturns,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .conversationstarttime: return "ConversationStartTime"
            case .duration: return "Duration"
            case .numberofturns: return "NumberOfTurns"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalyticsSessionSortByName(rawValue: rawValue) ?? AnalyticsSessionSortByName.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes {
    public enum AnalyticsSortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalyticsSortOrder] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "Ascending"
            case .descending: return "Descending"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalyticsSortOrder(rawValue: rawValue) ?? AnalyticsSortOrder.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.AnalyticsUtteranceAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsUtteranceAttributeName.self, forKey: .name)
        name = nameDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// An object that specifies the last used intent at the time of the utterance as an attribute to return.
    public struct AnalyticsUtteranceAttribute: Swift.Equatable {
        /// An attribute to return. The only available attribute is the intent that the bot mapped the utterance to.
        /// This member is required.
        public var name: LexModelsV2ClientTypes.AnalyticsUtteranceAttributeName?

        public init(
            name: LexModelsV2ClientTypes.AnalyticsUtteranceAttributeName? = nil
        )
        {
            self.name = name
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum AnalyticsUtteranceAttributeName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lastusedintent
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalyticsUtteranceAttributeName] {
            return [
                .lastusedintent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lastusedintent: return "LastUsedIntent"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalyticsUtteranceAttributeName(rawValue: rawValue) ?? AnalyticsUtteranceAttributeName.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.AnalyticsUtteranceAttributeResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastUsedIntent
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastUsedIntent = self.lastUsedIntent {
            try encodeContainer.encode(lastUsedIntent, forKey: .lastUsedIntent)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastUsedIntentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUsedIntent)
        lastUsedIntent = lastUsedIntentDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// An object containing the intent that the bot mapped the utterance to.
    public struct AnalyticsUtteranceAttributeResult: Swift.Equatable {
        /// The intent that the bot mapped the utterance to.
        public var lastUsedIntent: Swift.String?

        public init(
            lastUsedIntent: Swift.String? = nil
        )
        {
            self.lastUsedIntent = lastUsedIntent
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum AnalyticsUtteranceField: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case utterancestate
        case utterancetext
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalyticsUtteranceField] {
            return [
                .utterancestate,
                .utterancetext,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .utterancestate: return "UtteranceState"
            case .utterancetext: return "UtteranceText"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalyticsUtteranceField(rawValue: rawValue) ?? AnalyticsUtteranceField.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.AnalyticsUtteranceFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case `operator` = "operator"
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for analyticsfiltervalue0 in values {
                try valuesContainer.encode(analyticsfiltervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsUtteranceFilterName.self, forKey: .name)
        name = nameDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsFilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// Contains fields describing a condition by which to filter the utterances. The expression may be understood as name
    ///     operator
    ///
    /// values. For example:
    ///
    /// * LocaleId EQ Book – The locale is the string "en".
    ///
    /// * UtteranceText CO help – The text of the utterance contains the string "help".
    ///
    ///
    /// The operators that each filter supports are listed below:
    ///
    /// * BotAlias – EQ.
    ///
    /// * BotVersion – EQ.
    ///
    /// * LocaleId – EQ.
    ///
    /// * Modality – EQ.
    ///
    /// * Channel – EQ.
    ///
    /// * SessionId – EQ.
    ///
    /// * OriginatingRequestId – EQ.
    ///
    /// * UtteranceState – EQ.
    ///
    /// * UtteranceText – EQ, CO.
    public struct AnalyticsUtteranceFilter: Swift.Equatable {
        /// The category by which to filter the utterances. The descriptions for each option are as follows:
        ///
        /// * BotAlias – The name of the bot alias.
        ///
        /// * BotVersion – The version of the bot.
        ///
        /// * LocaleId – The locale of the bot.
        ///
        /// * Modality – The modality of the session with the bot (audio, DTMF, or text).
        ///
        /// * Channel – The channel that the bot is integrated with.
        ///
        /// * SessionId – The identifier of the session with the bot.
        ///
        /// * OriginatingRequestId – The identifier of the first request in a session.
        ///
        /// * UtteranceState – The state of the utterance.
        ///
        /// * UtteranceText – The text in the utterance.
        /// This member is required.
        public var name: LexModelsV2ClientTypes.AnalyticsUtteranceFilterName?
        /// The operation by which to filter the category. The following operations are possible:
        ///
        /// * CO – Contains
        ///
        /// * EQ – Equals
        ///
        /// * GT – Greater than
        ///
        /// * LT – Less than
        ///
        ///
        /// The operators that each filter supports are listed below:
        ///
        /// * BotAlias – EQ.
        ///
        /// * BotVersion – EQ.
        ///
        /// * LocaleId – EQ.
        ///
        /// * Modality – EQ.
        ///
        /// * Channel – EQ.
        ///
        /// * SessionId – EQ.
        ///
        /// * OriginatingRequestId – EQ.
        ///
        /// * UtteranceState – EQ.
        ///
        /// * UtteranceText – EQ, CO.
        /// This member is required.
        public var `operator`: LexModelsV2ClientTypes.AnalyticsFilterOperator?
        /// An array containing the values of the category by which to apply the operator to filter the results. You can provide multiple values if the operator is EQ or CO. If you provide multiple values, you filter for results that equal/contain any of the values. For example, if the name, operator, and values fields are Modality, EQ, and [Speech, Text], the operation filters for results where the modality was either Speech or Text.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: LexModelsV2ClientTypes.AnalyticsUtteranceFilterName? = nil,
            `operator`: LexModelsV2ClientTypes.AnalyticsFilterOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum AnalyticsUtteranceFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case botaliasid
        case botversion
        case channel
        case localeid
        case modality
        case originatingrequestid
        case sessionid
        case utterancestate
        case utterancetext
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalyticsUtteranceFilterName] {
            return [
                .botaliasid,
                .botversion,
                .channel,
                .localeid,
                .modality,
                .originatingrequestid,
                .sessionid,
                .utterancestate,
                .utterancetext,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .botaliasid: return "BotAliasId"
            case .botversion: return "BotVersion"
            case .channel: return "Channel"
            case .localeid: return "LocaleId"
            case .modality: return "Modality"
            case .originatingrequestid: return "OriginatingRequestId"
            case .sessionid: return "SessionId"
            case .utterancestate: return "UtteranceState"
            case .utterancetext: return "UtteranceText"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalyticsUtteranceFilterName(rawValue: rawValue) ?? AnalyticsUtteranceFilterName.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.AnalyticsUtteranceGroupByKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsUtteranceField.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Contains the category by which the utterance analytics were grouped and the values for that category.
    public struct AnalyticsUtteranceGroupByKey: Swift.Equatable {
        /// The category by which the utterance analytics were grouped.
        public var name: LexModelsV2ClientTypes.AnalyticsUtteranceField?
        /// A member of the category by which the utterance analytics were grouped.
        public var value: Swift.String?

        public init(
            name: LexModelsV2ClientTypes.AnalyticsUtteranceField? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension LexModelsV2ClientTypes.AnalyticsUtteranceGroupBySpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsUtteranceField.self, forKey: .name)
        name = nameDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Contains the category by which to group the utterances.
    public struct AnalyticsUtteranceGroupBySpecification: Swift.Equatable {
        /// Specifies whether to group the utterances by their text or their state.
        /// This member is required.
        public var name: LexModelsV2ClientTypes.AnalyticsUtteranceField?

        public init(
            name: LexModelsV2ClientTypes.AnalyticsUtteranceField? = nil
        )
        {
            self.name = name
        }
    }

}

extension LexModelsV2ClientTypes.AnalyticsUtteranceMetric: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case order
        case statistic
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let order = self.order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
        if let statistic = self.statistic {
            try encodeContainer.encode(statistic.rawValue, forKey: .statistic)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsUtteranceMetricName.self, forKey: .name)
        name = nameDecoded
        let statisticDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsMetricStatistic.self, forKey: .statistic)
        statistic = statisticDecoded
        let orderDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsSortOrder.self, forKey: .order)
        order = orderDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Contains the metric and the summary statistic you want to calculate, and the order in which to sort the results, for the utterances across the user sessions with the bot.
    public struct AnalyticsUtteranceMetric: Swift.Equatable {
        /// The metric for which you want to get utterance summary statistics.
        ///
        /// * Count – The number of utterances.
        ///
        /// * Missed – The number of utterances that Amazon Lex failed to recognize.
        ///
        /// * Detected – The number of utterances that Amazon Lex managed to detect.
        ///
        /// * UtteranceTimestamp – The date and time of the utterance.
        /// This member is required.
        public var name: LexModelsV2ClientTypes.AnalyticsUtteranceMetricName?
        /// Specifies whether to sort the results in ascending or descending order.
        public var order: LexModelsV2ClientTypes.AnalyticsSortOrder?
        /// The summary statistic to calculate.
        ///
        /// * Sum – The total count for the category you provide in name.
        ///
        /// * Average – The total count divided by the number of utterances in the category you provide in name.
        ///
        /// * Max – The highest count in the category you provide in name.
        /// This member is required.
        public var statistic: LexModelsV2ClientTypes.AnalyticsMetricStatistic?

        public init(
            name: LexModelsV2ClientTypes.AnalyticsUtteranceMetricName? = nil,
            order: LexModelsV2ClientTypes.AnalyticsSortOrder? = nil,
            statistic: LexModelsV2ClientTypes.AnalyticsMetricStatistic? = nil
        )
        {
            self.name = name
            self.order = order
            self.statistic = statistic
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum AnalyticsUtteranceMetricName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case count
        case detected
        case missed
        case utterancetimestamp
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalyticsUtteranceMetricName] {
            return [
                .count,
                .detected,
                .missed,
                .utterancetimestamp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .count: return "Count"
            case .detected: return "Detected"
            case .missed: return "Missed"
            case .utterancetimestamp: return "UtteranceTimestamp"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalyticsUtteranceMetricName(rawValue: rawValue) ?? AnalyticsUtteranceMetricName.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.AnalyticsUtteranceMetricResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case statistic
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let statistic = self.statistic {
            try encodeContainer.encode(statistic.rawValue, forKey: .statistic)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsUtteranceMetricName.self, forKey: .name)
        name = nameDecoded
        let statisticDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsMetricStatistic.self, forKey: .statistic)
        statistic = statisticDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// An object containing the results for the utterance metric you requested.
    public struct AnalyticsUtteranceMetricResult: Swift.Equatable {
        /// The metric that you requested.
        ///
        /// * Count – The number of utterances.
        ///
        /// * Missed – The number of utterances that Amazon Lex failed to recognize.
        ///
        /// * Detected – The number of utterances that Amazon Lex managed to detect.
        ///
        /// * UtteranceTimestamp – The date and time of the utterance.
        public var name: LexModelsV2ClientTypes.AnalyticsUtteranceMetricName?
        /// The summary statistic that you requested to calculate.
        ///
        /// * Sum – The total count for the category you provide in name.
        ///
        /// * Average – The total count divided by the number of utterances in the category you provide in name.
        ///
        /// * Max – The highest count in the category you provide in name.
        public var statistic: LexModelsV2ClientTypes.AnalyticsMetricStatistic?
        /// The value of the summary statistic for the metric that you requested.
        public var value: Swift.Double?

        public init(
            name: LexModelsV2ClientTypes.AnalyticsUtteranceMetricName? = nil,
            statistic: LexModelsV2ClientTypes.AnalyticsMetricStatistic? = nil,
            value: Swift.Double? = nil
        )
        {
            self.name = name
            self.statistic = statistic
            self.value = value
        }
    }

}

extension LexModelsV2ClientTypes.AnalyticsUtteranceResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeResults
        case binKeys
        case groupByKeys
        case metricsResults
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeResults = attributeResults {
            var attributeResultsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeResults)
            for analyticsutteranceattributeresult0 in attributeResults {
                try attributeResultsContainer.encode(analyticsutteranceattributeresult0)
            }
        }
        if let binKeys = binKeys {
            var binKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .binKeys)
            for analyticsbinkey0 in binKeys {
                try binKeysContainer.encode(analyticsbinkey0)
            }
        }
        if let groupByKeys = groupByKeys {
            var groupByKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupByKeys)
            for analyticsutterancegroupbykey0 in groupByKeys {
                try groupByKeysContainer.encode(analyticsutterancegroupbykey0)
            }
        }
        if let metricsResults = metricsResults {
            var metricsResultsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricsResults)
            for analyticsutterancemetricresult0 in metricsResults {
                try metricsResultsContainer.encode(analyticsutterancemetricresult0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let binKeysContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AnalyticsBinKey?].self, forKey: .binKeys)
        var binKeysDecoded0:[LexModelsV2ClientTypes.AnalyticsBinKey]? = nil
        if let binKeysContainer = binKeysContainer {
            binKeysDecoded0 = [LexModelsV2ClientTypes.AnalyticsBinKey]()
            for structure0 in binKeysContainer {
                if let structure0 = structure0 {
                    binKeysDecoded0?.append(structure0)
                }
            }
        }
        binKeys = binKeysDecoded0
        let groupByKeysContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AnalyticsUtteranceGroupByKey?].self, forKey: .groupByKeys)
        var groupByKeysDecoded0:[LexModelsV2ClientTypes.AnalyticsUtteranceGroupByKey]? = nil
        if let groupByKeysContainer = groupByKeysContainer {
            groupByKeysDecoded0 = [LexModelsV2ClientTypes.AnalyticsUtteranceGroupByKey]()
            for structure0 in groupByKeysContainer {
                if let structure0 = structure0 {
                    groupByKeysDecoded0?.append(structure0)
                }
            }
        }
        groupByKeys = groupByKeysDecoded0
        let metricsResultsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AnalyticsUtteranceMetricResult?].self, forKey: .metricsResults)
        var metricsResultsDecoded0:[LexModelsV2ClientTypes.AnalyticsUtteranceMetricResult]? = nil
        if let metricsResultsContainer = metricsResultsContainer {
            metricsResultsDecoded0 = [LexModelsV2ClientTypes.AnalyticsUtteranceMetricResult]()
            for structure0 in metricsResultsContainer {
                if let structure0 = structure0 {
                    metricsResultsDecoded0?.append(structure0)
                }
            }
        }
        metricsResults = metricsResultsDecoded0
        let attributeResultsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AnalyticsUtteranceAttributeResult?].self, forKey: .attributeResults)
        var attributeResultsDecoded0:[LexModelsV2ClientTypes.AnalyticsUtteranceAttributeResult]? = nil
        if let attributeResultsContainer = attributeResultsContainer {
            attributeResultsDecoded0 = [LexModelsV2ClientTypes.AnalyticsUtteranceAttributeResult]()
            for structure0 in attributeResultsContainer {
                if let structure0 = structure0 {
                    attributeResultsDecoded0?.append(structure0)
                }
            }
        }
        attributeResults = attributeResultsDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// An object containing the results for the utterance metrics you requested and the bin and/or group(s) they refer to, if applicable.
    public struct AnalyticsUtteranceResult: Swift.Equatable {
        /// A list of objects containing information about the last used intent at the time of an utterance.
        public var attributeResults: [LexModelsV2ClientTypes.AnalyticsUtteranceAttributeResult]?
        /// A list of objects containing the criteria you requested for binning results and the values of the bins.
        public var binKeys: [LexModelsV2ClientTypes.AnalyticsBinKey]?
        /// A list of objects containing the criteria you requested for grouping results and the values of the bins.
        public var groupByKeys: [LexModelsV2ClientTypes.AnalyticsUtteranceGroupByKey]?
        /// A list of objects, each of which contains a metric you want to list, the statistic for the metric you want to return, and the method by which to organize the results.
        public var metricsResults: [LexModelsV2ClientTypes.AnalyticsUtteranceMetricResult]?

        public init(
            attributeResults: [LexModelsV2ClientTypes.AnalyticsUtteranceAttributeResult]? = nil,
            binKeys: [LexModelsV2ClientTypes.AnalyticsBinKey]? = nil,
            groupByKeys: [LexModelsV2ClientTypes.AnalyticsUtteranceGroupByKey]? = nil,
            metricsResults: [LexModelsV2ClientTypes.AnalyticsUtteranceMetricResult]? = nil
        )
        {
            self.attributeResults = attributeResults
            self.binKeys = binKeys
            self.groupByKeys = groupByKeys
            self.metricsResults = metricsResults
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum AnalyticsUtteranceSortByName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case utterancetimestamp
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalyticsUtteranceSortByName] {
            return [
                .utterancetimestamp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .utterancetimestamp: return "UtteranceTimestamp"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalyticsUtteranceSortByName(rawValue: rawValue) ?? AnalyticsUtteranceSortByName.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.AssociatedTranscript: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transcript
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transcript = self.transcript {
            try encodeContainer.encode(transcript, forKey: .transcript)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transcriptDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transcript)
        transcript = transcriptDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// The object containing information that associates the recommended intent/slot type with a conversation.
    public struct AssociatedTranscript: Swift.Equatable {
        /// The content of the transcript that meets the search filter criteria. For the JSON format of the transcript, see [Output transcript format](https://docs.aws.amazon.com/lexv2/latest/dg/designing-output-format.html).
        public var transcript: Swift.String?

        public init(
            transcript: Swift.String? = nil
        )
        {
            self.transcript = transcript
        }
    }

}

extension LexModelsV2ClientTypes.AssociatedTranscriptFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AssociatedTranscriptFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// Filters to search for the associated transcript.
    public struct AssociatedTranscriptFilter: Swift.Equatable {
        /// The name of the field to use for filtering. The allowed names are IntentId and SlotTypeId.
        /// This member is required.
        public var name: LexModelsV2ClientTypes.AssociatedTranscriptFilterName?
        /// The values to use to filter the transcript.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: LexModelsV2ClientTypes.AssociatedTranscriptFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum AssociatedTranscriptFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case intentid
        case slottypeid
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociatedTranscriptFilterName] {
            return [
                .intentid,
                .slottypeid,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .intentid: return "IntentId"
            case .slottypeid: return "SlotTypeId"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssociatedTranscriptFilterName(rawValue: rawValue) ?? AssociatedTranscriptFilterName.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.AudioAndDTMFInputSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioSpecification
        case dtmfSpecification
        case startTimeoutMs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audioSpecification = self.audioSpecification {
            try encodeContainer.encode(audioSpecification, forKey: .audioSpecification)
        }
        if let dtmfSpecification = self.dtmfSpecification {
            try encodeContainer.encode(dtmfSpecification, forKey: .dtmfSpecification)
        }
        if let startTimeoutMs = self.startTimeoutMs {
            try encodeContainer.encode(startTimeoutMs, forKey: .startTimeoutMs)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeoutMsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startTimeoutMs)
        startTimeoutMs = startTimeoutMsDecoded
        let audioSpecificationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AudioSpecification.self, forKey: .audioSpecification)
        audioSpecification = audioSpecificationDecoded
        let dtmfSpecificationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.DTMFSpecification.self, forKey: .dtmfSpecification)
        dtmfSpecification = dtmfSpecificationDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Specifies the audio and DTMF input specification.
    public struct AudioAndDTMFInputSpecification: Swift.Equatable {
        /// Specifies the settings on audio input.
        public var audioSpecification: LexModelsV2ClientTypes.AudioSpecification?
        /// Specifies the settings on DTMF input.
        public var dtmfSpecification: LexModelsV2ClientTypes.DTMFSpecification?
        /// Time for which a bot waits before assuming that the customer isn't going to speak or press a key. This timeout is shared between Audio and DTMF inputs.
        /// This member is required.
        public var startTimeoutMs: Swift.Int?

        public init(
            audioSpecification: LexModelsV2ClientTypes.AudioSpecification? = nil,
            dtmfSpecification: LexModelsV2ClientTypes.DTMFSpecification? = nil,
            startTimeoutMs: Swift.Int? = nil
        )
        {
            self.audioSpecification = audioSpecification
            self.dtmfSpecification = dtmfSpecification
            self.startTimeoutMs = startTimeoutMs
        }
    }

}

extension LexModelsV2ClientTypes.AudioLogDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Bucket
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Bucket = self.s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.S3BucketLogDestination.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// The location of audio log files collected when conversation logging is enabled for a bot.
    public struct AudioLogDestination: Swift.Equatable {
        /// The Amazon S3 bucket where the audio log files are stored. The IAM role specified in the roleArn parameter of the [CreateBot](https://docs.aws.amazon.com/lexv2/latest/APIReference/API_CreateBot.html) operation must have permission to write to this bucket.
        /// This member is required.
        public var s3Bucket: LexModelsV2ClientTypes.S3BucketLogDestination?

        public init(
            s3Bucket: LexModelsV2ClientTypes.S3BucketLogDestination? = nil
        )
        {
            self.s3Bucket = s3Bucket
        }
    }

}

extension LexModelsV2ClientTypes.AudioLogSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination
        case enabled
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AudioLogDestination.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Settings for logging audio of conversations between Amazon Lex and a user. You specify whether to log audio and the Amazon S3 bucket where the audio file is stored.
    public struct AudioLogSetting: Swift.Equatable {
        /// The location of audio log files collected when conversation logging is enabled for a bot.
        /// This member is required.
        public var destination: LexModelsV2ClientTypes.AudioLogDestination?
        /// Determines whether audio logging in enabled for the bot.
        /// This member is required.
        public var enabled: Swift.Bool

        public init(
            destination: LexModelsV2ClientTypes.AudioLogDestination? = nil,
            enabled: Swift.Bool = false
        )
        {
            self.destination = destination
            self.enabled = enabled
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum AudioRecognitionStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case useslotvaluesascustomvocabulary
        case sdkUnknown(Swift.String)

        public static var allCases: [AudioRecognitionStrategy] {
            return [
                .useslotvaluesascustomvocabulary,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .useslotvaluesascustomvocabulary: return "UseSlotValuesAsCustomVocabulary"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AudioRecognitionStrategy(rawValue: rawValue) ?? AudioRecognitionStrategy.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.AudioSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTimeoutMs
        case maxLengthMs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTimeoutMs = self.endTimeoutMs {
            try encodeContainer.encode(endTimeoutMs, forKey: .endTimeoutMs)
        }
        if let maxLengthMs = self.maxLengthMs {
            try encodeContainer.encode(maxLengthMs, forKey: .maxLengthMs)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxLengthMsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxLengthMs)
        maxLengthMs = maxLengthMsDecoded
        let endTimeoutMsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endTimeoutMs)
        endTimeoutMs = endTimeoutMsDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Specifies the audio input specifications.
    public struct AudioSpecification: Swift.Equatable {
        /// Time for which a bot waits after the customer stops speaking to assume the utterance is finished.
        /// This member is required.
        public var endTimeoutMs: Swift.Int?
        /// Time for how long Amazon Lex waits before speech input is truncated and the speech is returned to application.
        /// This member is required.
        public var maxLengthMs: Swift.Int?

        public init(
            endTimeoutMs: Swift.Int? = nil,
            maxLengthMs: Swift.Int? = nil
        )
        {
            self.endTimeoutMs = endTimeoutMs
            self.maxLengthMs = maxLengthMs
        }
    }

}

extension BatchCreateCustomVocabularyItemInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customVocabularyItemList
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customVocabularyItemList = customVocabularyItemList {
            var customVocabularyItemListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customVocabularyItemList)
            for newcustomvocabularyitem0 in customVocabularyItemList {
                try customVocabularyItemListContainer.encode(newcustomvocabularyitem0)
            }
        }
    }
}

extension BatchCreateCustomVocabularyItemInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botVersion = botVersion else {
            return nil
        }
        guard let localeId = localeId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botversions/\(botVersion.urlPercentEncoding())/botlocales/\(localeId.urlPercentEncoding())/customvocabulary/DEFAULT/batchcreate"
    }
}

public struct BatchCreateCustomVocabularyItemInput: Swift.Equatable {
    /// The identifier of the bot associated with this custom vocabulary.
    /// This member is required.
    public var botId: Swift.String?
    /// The identifier of the version of the bot associated with this custom vocabulary.
    /// This member is required.
    public var botVersion: Swift.String?
    /// A list of new custom vocabulary items. Each entry must contain a phrase and can optionally contain a displayAs and/or a weight.
    /// This member is required.
    public var customVocabularyItemList: [LexModelsV2ClientTypes.NewCustomVocabularyItem]?
    /// The identifier of the language and locale where this custom vocabulary is used. The string must match one of the supported locales. For more information, see [ Supported Languages ](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html).
    /// This member is required.
    public var localeId: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        customVocabularyItemList: [LexModelsV2ClientTypes.NewCustomVocabularyItem]? = nil,
        localeId: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.customVocabularyItemList = customVocabularyItemList
        self.localeId = localeId
    }
}

struct BatchCreateCustomVocabularyItemInputBody: Swift.Equatable {
    let customVocabularyItemList: [LexModelsV2ClientTypes.NewCustomVocabularyItem]?
}

extension BatchCreateCustomVocabularyItemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customVocabularyItemList
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customVocabularyItemListContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.NewCustomVocabularyItem?].self, forKey: .customVocabularyItemList)
        var customVocabularyItemListDecoded0:[LexModelsV2ClientTypes.NewCustomVocabularyItem]? = nil
        if let customVocabularyItemListContainer = customVocabularyItemListContainer {
            customVocabularyItemListDecoded0 = [LexModelsV2ClientTypes.NewCustomVocabularyItem]()
            for structure0 in customVocabularyItemListContainer {
                if let structure0 = structure0 {
                    customVocabularyItemListDecoded0?.append(structure0)
                }
            }
        }
        customVocabularyItemList = customVocabularyItemListDecoded0
    }
}

enum BatchCreateCustomVocabularyItemOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchCreateCustomVocabularyItemOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchCreateCustomVocabularyItemOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.errors = output.errors
            self.localeId = output.localeId
            self.resources = output.resources
        } else {
            self.botId = nil
            self.botVersion = nil
            self.errors = nil
            self.localeId = nil
            self.resources = nil
        }
    }
}

public struct BatchCreateCustomVocabularyItemOutputResponse: Swift.Equatable {
    /// The identifier of the bot associated with this custom vocabulary.
    public var botId: Swift.String?
    /// The identifier of the version of the bot associated with this custom vocabulary.
    public var botVersion: Swift.String?
    /// A list of custom vocabulary items that failed to create during the operation. The reason for the error is contained within each error object.
    public var errors: [LexModelsV2ClientTypes.FailedCustomVocabularyItem]?
    /// The identifier of the language and locale where this custom vocabulary is used. The string must match one of the supported locales. For more information, see [ Supported Languages ](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html).
    public var localeId: Swift.String?
    /// A list of custom vocabulary items that were successfully created during the operation.
    public var resources: [LexModelsV2ClientTypes.CustomVocabularyItem]?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        errors: [LexModelsV2ClientTypes.FailedCustomVocabularyItem]? = nil,
        localeId: Swift.String? = nil,
        resources: [LexModelsV2ClientTypes.CustomVocabularyItem]? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.errors = errors
        self.localeId = localeId
        self.resources = resources
    }
}

struct BatchCreateCustomVocabularyItemOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let botVersion: Swift.String?
    let localeId: Swift.String?
    let errors: [LexModelsV2ClientTypes.FailedCustomVocabularyItem]?
    let resources: [LexModelsV2ClientTypes.CustomVocabularyItem]?
}

extension BatchCreateCustomVocabularyItemOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botVersion
        case errors
        case localeId
        case resources
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let errorsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.FailedCustomVocabularyItem?].self, forKey: .errors)
        var errorsDecoded0:[LexModelsV2ClientTypes.FailedCustomVocabularyItem]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [LexModelsV2ClientTypes.FailedCustomVocabularyItem]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
        let resourcesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.CustomVocabularyItem?].self, forKey: .resources)
        var resourcesDecoded0:[LexModelsV2ClientTypes.CustomVocabularyItem]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [LexModelsV2ClientTypes.CustomVocabularyItem]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
    }
}

extension BatchDeleteCustomVocabularyItemInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customVocabularyItemList
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customVocabularyItemList = customVocabularyItemList {
            var customVocabularyItemListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customVocabularyItemList)
            for customvocabularyentryid0 in customVocabularyItemList {
                try customVocabularyItemListContainer.encode(customvocabularyentryid0)
            }
        }
    }
}

extension BatchDeleteCustomVocabularyItemInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botVersion = botVersion else {
            return nil
        }
        guard let localeId = localeId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botversions/\(botVersion.urlPercentEncoding())/botlocales/\(localeId.urlPercentEncoding())/customvocabulary/DEFAULT/batchdelete"
    }
}

public struct BatchDeleteCustomVocabularyItemInput: Swift.Equatable {
    /// The identifier of the bot associated with this custom vocabulary.
    /// This member is required.
    public var botId: Swift.String?
    /// The identifier of the version of the bot associated with this custom vocabulary.
    /// This member is required.
    public var botVersion: Swift.String?
    /// A list of custom vocabulary items requested to be deleted. Each entry must contain the unique custom vocabulary entry identifier.
    /// This member is required.
    public var customVocabularyItemList: [LexModelsV2ClientTypes.CustomVocabularyEntryId]?
    /// The identifier of the language and locale where this custom vocabulary is used. The string must match one of the supported locales. For more information, see [ Supported Languages ](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html).
    /// This member is required.
    public var localeId: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        customVocabularyItemList: [LexModelsV2ClientTypes.CustomVocabularyEntryId]? = nil,
        localeId: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.customVocabularyItemList = customVocabularyItemList
        self.localeId = localeId
    }
}

struct BatchDeleteCustomVocabularyItemInputBody: Swift.Equatable {
    let customVocabularyItemList: [LexModelsV2ClientTypes.CustomVocabularyEntryId]?
}

extension BatchDeleteCustomVocabularyItemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customVocabularyItemList
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customVocabularyItemListContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.CustomVocabularyEntryId?].self, forKey: .customVocabularyItemList)
        var customVocabularyItemListDecoded0:[LexModelsV2ClientTypes.CustomVocabularyEntryId]? = nil
        if let customVocabularyItemListContainer = customVocabularyItemListContainer {
            customVocabularyItemListDecoded0 = [LexModelsV2ClientTypes.CustomVocabularyEntryId]()
            for structure0 in customVocabularyItemListContainer {
                if let structure0 = structure0 {
                    customVocabularyItemListDecoded0?.append(structure0)
                }
            }
        }
        customVocabularyItemList = customVocabularyItemListDecoded0
    }
}

enum BatchDeleteCustomVocabularyItemOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchDeleteCustomVocabularyItemOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchDeleteCustomVocabularyItemOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.errors = output.errors
            self.localeId = output.localeId
            self.resources = output.resources
        } else {
            self.botId = nil
            self.botVersion = nil
            self.errors = nil
            self.localeId = nil
            self.resources = nil
        }
    }
}

public struct BatchDeleteCustomVocabularyItemOutputResponse: Swift.Equatable {
    /// The identifier of the bot associated with this custom vocabulary.
    public var botId: Swift.String?
    /// The identifier of the version of the bot associated with this custom vocabulary.
    public var botVersion: Swift.String?
    /// A list of custom vocabulary items that failed to delete during the operation. The reason for the error is contained within each error object.
    public var errors: [LexModelsV2ClientTypes.FailedCustomVocabularyItem]?
    /// The identifier of the language and locale where this custom vocabulary is used. The string must match one of the supported locales. For more information, see Supported languages (https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html).
    public var localeId: Swift.String?
    /// A list of custom vocabulary items that were successfully deleted during the operation.
    public var resources: [LexModelsV2ClientTypes.CustomVocabularyItem]?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        errors: [LexModelsV2ClientTypes.FailedCustomVocabularyItem]? = nil,
        localeId: Swift.String? = nil,
        resources: [LexModelsV2ClientTypes.CustomVocabularyItem]? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.errors = errors
        self.localeId = localeId
        self.resources = resources
    }
}

struct BatchDeleteCustomVocabularyItemOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let botVersion: Swift.String?
    let localeId: Swift.String?
    let errors: [LexModelsV2ClientTypes.FailedCustomVocabularyItem]?
    let resources: [LexModelsV2ClientTypes.CustomVocabularyItem]?
}

extension BatchDeleteCustomVocabularyItemOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botVersion
        case errors
        case localeId
        case resources
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let errorsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.FailedCustomVocabularyItem?].self, forKey: .errors)
        var errorsDecoded0:[LexModelsV2ClientTypes.FailedCustomVocabularyItem]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [LexModelsV2ClientTypes.FailedCustomVocabularyItem]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
        let resourcesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.CustomVocabularyItem?].self, forKey: .resources)
        var resourcesDecoded0:[LexModelsV2ClientTypes.CustomVocabularyItem]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [LexModelsV2ClientTypes.CustomVocabularyItem]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
    }
}

extension BatchUpdateCustomVocabularyItemInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customVocabularyItemList
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customVocabularyItemList = customVocabularyItemList {
            var customVocabularyItemListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customVocabularyItemList)
            for customvocabularyitem0 in customVocabularyItemList {
                try customVocabularyItemListContainer.encode(customvocabularyitem0)
            }
        }
    }
}

extension BatchUpdateCustomVocabularyItemInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botVersion = botVersion else {
            return nil
        }
        guard let localeId = localeId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botversions/\(botVersion.urlPercentEncoding())/botlocales/\(localeId.urlPercentEncoding())/customvocabulary/DEFAULT/batchupdate"
    }
}

public struct BatchUpdateCustomVocabularyItemInput: Swift.Equatable {
    /// The identifier of the bot associated with this custom vocabulary
    /// This member is required.
    public var botId: Swift.String?
    /// The identifier of the version of the bot associated with this custom vocabulary.
    /// This member is required.
    public var botVersion: Swift.String?
    /// A list of custom vocabulary items with updated fields. Each entry must contain a phrase and can optionally contain a displayAs and/or a weight.
    /// This member is required.
    public var customVocabularyItemList: [LexModelsV2ClientTypes.CustomVocabularyItem]?
    /// The identifier of the language and locale where this custom vocabulary is used. The string must match one of the supported locales. For more information, see [ Supported Languages ](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html).
    /// This member is required.
    public var localeId: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        customVocabularyItemList: [LexModelsV2ClientTypes.CustomVocabularyItem]? = nil,
        localeId: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.customVocabularyItemList = customVocabularyItemList
        self.localeId = localeId
    }
}

struct BatchUpdateCustomVocabularyItemInputBody: Swift.Equatable {
    let customVocabularyItemList: [LexModelsV2ClientTypes.CustomVocabularyItem]?
}

extension BatchUpdateCustomVocabularyItemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customVocabularyItemList
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customVocabularyItemListContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.CustomVocabularyItem?].self, forKey: .customVocabularyItemList)
        var customVocabularyItemListDecoded0:[LexModelsV2ClientTypes.CustomVocabularyItem]? = nil
        if let customVocabularyItemListContainer = customVocabularyItemListContainer {
            customVocabularyItemListDecoded0 = [LexModelsV2ClientTypes.CustomVocabularyItem]()
            for structure0 in customVocabularyItemListContainer {
                if let structure0 = structure0 {
                    customVocabularyItemListDecoded0?.append(structure0)
                }
            }
        }
        customVocabularyItemList = customVocabularyItemListDecoded0
    }
}

enum BatchUpdateCustomVocabularyItemOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchUpdateCustomVocabularyItemOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchUpdateCustomVocabularyItemOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.errors = output.errors
            self.localeId = output.localeId
            self.resources = output.resources
        } else {
            self.botId = nil
            self.botVersion = nil
            self.errors = nil
            self.localeId = nil
            self.resources = nil
        }
    }
}

public struct BatchUpdateCustomVocabularyItemOutputResponse: Swift.Equatable {
    /// The identifier of the bot associated with this custom vocabulary.
    public var botId: Swift.String?
    /// The identifier of the version of the bot associated with this custom vocabulary.
    public var botVersion: Swift.String?
    /// A list of custom vocabulary items that failed to update during the operation. The reason for the error is contained within each error object.
    public var errors: [LexModelsV2ClientTypes.FailedCustomVocabularyItem]?
    /// The identifier of the language and locale where this custom vocabulary is used. The string must match one of the supported locales. For more information, see [ Supported Languages ](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html).
    public var localeId: Swift.String?
    /// A list of custom vocabulary items that were successfully updated during the operation.
    public var resources: [LexModelsV2ClientTypes.CustomVocabularyItem]?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        errors: [LexModelsV2ClientTypes.FailedCustomVocabularyItem]? = nil,
        localeId: Swift.String? = nil,
        resources: [LexModelsV2ClientTypes.CustomVocabularyItem]? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.errors = errors
        self.localeId = localeId
        self.resources = resources
    }
}

struct BatchUpdateCustomVocabularyItemOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let botVersion: Swift.String?
    let localeId: Swift.String?
    let errors: [LexModelsV2ClientTypes.FailedCustomVocabularyItem]?
    let resources: [LexModelsV2ClientTypes.CustomVocabularyItem]?
}

extension BatchUpdateCustomVocabularyItemOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botVersion
        case errors
        case localeId
        case resources
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let errorsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.FailedCustomVocabularyItem?].self, forKey: .errors)
        var errorsDecoded0:[LexModelsV2ClientTypes.FailedCustomVocabularyItem]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [LexModelsV2ClientTypes.FailedCustomVocabularyItem]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
        let resourcesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.CustomVocabularyItem?].self, forKey: .resources)
        var resourcesDecoded0:[LexModelsV2ClientTypes.CustomVocabularyItem]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [LexModelsV2ClientTypes.CustomVocabularyItem]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
    }
}

extension LexModelsV2ClientTypes.BotAliasHistoryEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botVersion
        case endDate
        case startDate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botVersion = self.botVersion {
            try encodeContainer.encode(botVersion, forKey: .botVersion)
        }
        if let endDate = self.endDate {
            try encodeContainer.encodeTimestamp(endDate, format: .epochSeconds, forKey: .endDate)
        }
        if let startDate = self.startDate {
            try encodeContainer.encodeTimestamp(startDate, format: .epochSeconds, forKey: .startDate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let startDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endDate)
        endDate = endDateDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Provides a record of an event that affects a bot alias. For example, when the version of a bot that the alias points to changes.
    public struct BotAliasHistoryEvent: Swift.Equatable {
        /// The version of the bot that was used in the event.
        public var botVersion: Swift.String?
        /// The date and time that the event ended.
        public var endDate: ClientRuntime.Date?
        /// The date and time that the event started.
        public var startDate: ClientRuntime.Date?

        public init(
            botVersion: Swift.String? = nil,
            endDate: ClientRuntime.Date? = nil,
            startDate: ClientRuntime.Date? = nil
        )
        {
            self.botVersion = botVersion
            self.endDate = endDate
            self.startDate = startDate
        }
    }

}

extension LexModelsV2ClientTypes.BotAliasLocaleSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeHookSpecification
        case enabled
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeHookSpecification = self.codeHookSpecification {
            try encodeContainer.encode(codeHookSpecification, forKey: .codeHookSpecification)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
        let codeHookSpecificationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.CodeHookSpecification.self, forKey: .codeHookSpecification)
        codeHookSpecification = codeHookSpecificationDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Specifies settings that are unique to a locale. For example, you can use different Lambda function depending on the bot's locale.
    public struct BotAliasLocaleSettings: Swift.Equatable {
        /// Specifies the Lambda function that should be used in the locale.
        public var codeHookSpecification: LexModelsV2ClientTypes.CodeHookSpecification?
        /// Determines whether the locale is enabled for the bot. If the value is false, the locale isn't available for use.
        /// This member is required.
        public var enabled: Swift.Bool

        public init(
            codeHookSpecification: LexModelsV2ClientTypes.CodeHookSpecification? = nil,
            enabled: Swift.Bool = false
        )
        {
            self.codeHookSpecification = codeHookSpecification
            self.enabled = enabled
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum BotAliasStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case creating
        case deleting
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [BotAliasStatus] {
            return [
                .available,
                .creating,
                .deleting,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "Available"
            case .creating: return "Creating"
            case .deleting: return "Deleting"
            case .failed: return "Failed"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BotAliasStatus(rawValue: rawValue) ?? BotAliasStatus.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.BotAliasSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botAliasId
        case botAliasName
        case botAliasStatus
        case botVersion
        case creationDateTime
        case description
        case lastUpdatedDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botAliasId = self.botAliasId {
            try encodeContainer.encode(botAliasId, forKey: .botAliasId)
        }
        if let botAliasName = self.botAliasName {
            try encodeContainer.encode(botAliasName, forKey: .botAliasName)
        }
        if let botAliasStatus = self.botAliasStatus {
            try encodeContainer.encode(botAliasStatus.rawValue, forKey: .botAliasStatus)
        }
        if let botVersion = self.botVersion {
            try encodeContainer.encode(botVersion, forKey: .botVersion)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botAliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botAliasId)
        botAliasId = botAliasIdDecoded
        let botAliasNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botAliasName)
        botAliasName = botAliasNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let botAliasStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotAliasStatus.self, forKey: .botAliasStatus)
        botAliasStatus = botAliasStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Summary information about bot aliases returned from the [ListBotAliases](https://docs.aws.amazon.com/lexv2/latest/APIReference/API_ListBotAliases.html) operation.
    public struct BotAliasSummary: Swift.Equatable {
        /// The unique identifier assigned to the bot alias. You can use this ID to get detailed information about the alias using the [DescribeBotAlias](https://docs.aws.amazon.com/lexv2/latest/APIReference/API_DescribeBotAlias.html) operation.
        public var botAliasId: Swift.String?
        /// The name of the bot alias.
        public var botAliasName: Swift.String?
        /// The current state of the bot alias. If the status is Available, the alias is ready for use.
        public var botAliasStatus: LexModelsV2ClientTypes.BotAliasStatus?
        /// The version of the bot that the bot alias references.
        public var botVersion: Swift.String?
        /// A timestamp of the date and time that the bot alias was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The description of the bot alias.
        public var description: Swift.String?
        /// A timestamp of the date and time that the bot alias was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?

        public init(
            botAliasId: Swift.String? = nil,
            botAliasName: Swift.String? = nil,
            botAliasStatus: LexModelsV2ClientTypes.BotAliasStatus? = nil,
            botVersion: Swift.String? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil
        )
        {
            self.botAliasId = botAliasId
            self.botAliasName = botAliasName
            self.botAliasStatus = botAliasStatus
            self.botVersion = botVersion
            self.creationDateTime = creationDateTime
            self.description = description
            self.lastUpdatedDateTime = lastUpdatedDateTime
        }
    }

}

extension LexModelsV2ClientTypes.BotAliasTestExecutionTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botAliasId
        case botId
        case localeId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botAliasId = self.botAliasId {
            try encodeContainer.encode(botAliasId, forKey: .botAliasId)
        }
        if let botId = self.botId {
            try encodeContainer.encode(botId, forKey: .botId)
        }
        if let localeId = self.localeId {
            try encodeContainer.encode(localeId, forKey: .localeId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botAliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botAliasId)
        botAliasId = botAliasIdDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// The target Amazon S3 location for the test set execution using a bot alias.
    public struct BotAliasTestExecutionTarget: Swift.Equatable {
        /// The bot alias Id of the bot alias used in the test set execution.
        /// This member is required.
        public var botAliasId: Swift.String?
        /// The bot Id of the bot alias used in the test set execution.
        /// This member is required.
        public var botId: Swift.String?
        /// The locale Id of the bot alias used in the test set execution.
        /// This member is required.
        public var localeId: Swift.String?

        public init(
            botAliasId: Swift.String? = nil,
            botId: Swift.String? = nil,
            localeId: Swift.String? = nil
        )
        {
            self.botAliasId = botAliasId
            self.botId = botId
            self.localeId = localeId
        }
    }

}

extension LexModelsV2ClientTypes.BotExportSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botId = self.botId {
            try encodeContainer.encode(botId, forKey: .botId)
        }
        if let botVersion = self.botVersion {
            try encodeContainer.encode(botVersion, forKey: .botVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Provides the identity of a the bot that was exported.
    public struct BotExportSpecification: Swift.Equatable {
        /// The identifier of the bot assigned by Amazon Lex.
        /// This member is required.
        public var botId: Swift.String?
        /// The version of the bot that was exported. This will be either DRAFT or the version number.
        /// This member is required.
        public var botVersion: Swift.String?

        public init(
            botId: Swift.String? = nil,
            botVersion: Swift.String? = nil
        )
        {
            self.botId = botId
            self.botVersion = botVersion
        }
    }

}

extension LexModelsV2ClientTypes.BotFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case `operator` = "operator"
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let operatorDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotFilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Filters the responses returned by the ListBots operation.
    public struct BotFilter: Swift.Equatable {
        /// The name of the field to filter the list of bots.
        /// This member is required.
        public var name: LexModelsV2ClientTypes.BotFilterName?
        /// The operator to use for the filter. Specify EQ when the ListBots operation should return only aliases that equal the specified value. Specify CO when the ListBots operation should return aliases that contain the specified value.
        /// This member is required.
        public var `operator`: LexModelsV2ClientTypes.BotFilterOperator?
        /// The value to use for filtering the list of bots.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: LexModelsV2ClientTypes.BotFilterName? = nil,
            `operator`: LexModelsV2ClientTypes.BotFilterOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum BotFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case botname
        case bottype
        case sdkUnknown(Swift.String)

        public static var allCases: [BotFilterName] {
            return [
                .botname,
                .bottype,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .botname: return "BotName"
            case .bottype: return "BotType"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BotFilterName(rawValue: rawValue) ?? BotFilterName.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes {
    public enum BotFilterOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case contains
        case equals
        case notequals
        case sdkUnknown(Swift.String)

        public static var allCases: [BotFilterOperator] {
            return [
                .contains,
                .equals,
                .notequals,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contains: return "CO"
            case .equals: return "EQ"
            case .notequals: return "NE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BotFilterOperator(rawValue: rawValue) ?? BotFilterOperator.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.BotImportSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botName
        case botTags
        case dataPrivacy
        case idleSessionTTLInSeconds
        case roleArn
        case testBotAliasTags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botName = self.botName {
            try encodeContainer.encode(botName, forKey: .botName)
        }
        if let botTags = botTags {
            var botTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .botTags)
            for (dictKey0, tagMap0) in botTags {
                try botTagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let dataPrivacy = self.dataPrivacy {
            try encodeContainer.encode(dataPrivacy, forKey: .dataPrivacy)
        }
        if let idleSessionTTLInSeconds = self.idleSessionTTLInSeconds {
            try encodeContainer.encode(idleSessionTTLInSeconds, forKey: .idleSessionTTLInSeconds)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let testBotAliasTags = testBotAliasTags {
            var testBotAliasTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .testBotAliasTags)
            for (dictKey0, tagMap0) in testBotAliasTags {
                try testBotAliasTagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botName)
        botName = botNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let dataPrivacyDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.DataPrivacy.self, forKey: .dataPrivacy)
        dataPrivacy = dataPrivacyDecoded
        let idleSessionTTLInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleSessionTTLInSeconds)
        idleSessionTTLInSeconds = idleSessionTTLInSecondsDecoded
        let botTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .botTags)
        var botTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let botTagsContainer = botTagsContainer {
            botTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in botTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    botTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        botTags = botTagsDecoded0
        let testBotAliasTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .testBotAliasTags)
        var testBotAliasTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let testBotAliasTagsContainer = testBotAliasTagsContainer {
            testBotAliasTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in testBotAliasTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    testBotAliasTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        testBotAliasTags = testBotAliasTagsDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// Provides the bot parameters required for importing a bot.
    public struct BotImportSpecification: Swift.Equatable {
        /// The name that Amazon Lex should use for the bot.
        /// This member is required.
        public var botName: Swift.String?
        /// A list of tags to add to the bot. You can only add tags when you import a bot. You can't use the UpdateBot operation to update tags. To update tags, use the TagResource operation.
        public var botTags: [Swift.String:Swift.String]?
        /// By default, data stored by Amazon Lex is encrypted. The DataPrivacy structure provides settings that determine how Amazon Lex handles special cases of securing the data for your bot.
        /// This member is required.
        public var dataPrivacy: LexModelsV2ClientTypes.DataPrivacy?
        /// The time, in seconds, that Amazon Lex should keep information about a user's conversation with the bot. A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Lex deletes any data provided before the timeout. You can specify between 60 (1 minute) and 86,400 (24 hours) seconds.
        public var idleSessionTTLInSeconds: Swift.Int?
        /// The Amazon Resource Name (ARN) of the IAM role used to build and run the bot.
        /// This member is required.
        public var roleArn: Swift.String?
        /// A list of tags to add to the test alias for a bot. You can only add tags when you import a bot. You can't use the UpdateAlias operation to update tags. To update tags on the test alias, use the TagResource operation.
        public var testBotAliasTags: [Swift.String:Swift.String]?

        public init(
            botName: Swift.String? = nil,
            botTags: [Swift.String:Swift.String]? = nil,
            dataPrivacy: LexModelsV2ClientTypes.DataPrivacy? = nil,
            idleSessionTTLInSeconds: Swift.Int? = nil,
            roleArn: Swift.String? = nil,
            testBotAliasTags: [Swift.String:Swift.String]? = nil
        )
        {
            self.botName = botName
            self.botTags = botTags
            self.dataPrivacy = dataPrivacy
            self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
            self.roleArn = roleArn
            self.testBotAliasTags = testBotAliasTags
        }
    }

}

extension LexModelsV2ClientTypes.BotLocaleExportSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botVersion
        case localeId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botId = self.botId {
            try encodeContainer.encode(botId, forKey: .botId)
        }
        if let botVersion = self.botVersion {
            try encodeContainer.encode(botVersion, forKey: .botVersion)
        }
        if let localeId = self.localeId {
            try encodeContainer.encode(localeId, forKey: .localeId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Provides the bot locale parameters required for exporting a bot locale.
    public struct BotLocaleExportSpecification: Swift.Equatable {
        /// The identifier of the bot to create the locale for.
        /// This member is required.
        public var botId: Swift.String?
        /// The version of the bot to export.
        /// This member is required.
        public var botVersion: Swift.String?
        /// The identifier of the language and locale to export. The string must match one of the locales in the bot.
        /// This member is required.
        public var localeId: Swift.String?

        public init(
            botId: Swift.String? = nil,
            botVersion: Swift.String? = nil,
            localeId: Swift.String? = nil
        )
        {
            self.botId = botId
            self.botVersion = botVersion
            self.localeId = localeId
        }
    }

}

extension LexModelsV2ClientTypes.BotLocaleFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case `operator` = "operator"
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotLocaleFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let operatorDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotLocaleFilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Filters responses returned by the ListBotLocales operation.
    public struct BotLocaleFilter: Swift.Equatable {
        /// The name of the field to filter the list of bots.
        /// This member is required.
        public var name: LexModelsV2ClientTypes.BotLocaleFilterName?
        /// The operator to use for the filter. Specify EQ when the ListBotLocales operation should return only aliases that equal the specified value. Specify CO when the ListBotLocales operation should return aliases that contain the specified value.
        /// This member is required.
        public var `operator`: LexModelsV2ClientTypes.BotLocaleFilterOperator?
        /// The value to use for filtering the list of bots.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: LexModelsV2ClientTypes.BotLocaleFilterName? = nil,
            `operator`: LexModelsV2ClientTypes.BotLocaleFilterOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum BotLocaleFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case botlocalename
        case sdkUnknown(Swift.String)

        public static var allCases: [BotLocaleFilterName] {
            return [
                .botlocalename,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .botlocalename: return "BotLocaleName"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BotLocaleFilterName(rawValue: rawValue) ?? BotLocaleFilterName.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes {
    public enum BotLocaleFilterOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case contains
        case equals
        case sdkUnknown(Swift.String)

        public static var allCases: [BotLocaleFilterOperator] {
            return [
                .contains,
                .equals,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contains: return "CO"
            case .equals: return "EQ"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BotLocaleFilterOperator(rawValue: rawValue) ?? BotLocaleFilterOperator.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.BotLocaleHistoryEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case event
        case eventDate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let event = self.event {
            try encodeContainer.encode(event, forKey: .event)
        }
        if let eventDate = self.eventDate {
            try encodeContainer.encodeTimestamp(eventDate, format: .epochSeconds, forKey: .eventDate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .event)
        event = eventDecoded
        let eventDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .eventDate)
        eventDate = eventDateDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Provides information about an event that occurred affecting the bot locale.
    public struct BotLocaleHistoryEvent: Swift.Equatable {
        /// A description of the event that occurred.
        /// This member is required.
        public var event: Swift.String?
        /// A timestamp of the date and time that the event occurred.
        /// This member is required.
        public var eventDate: ClientRuntime.Date?

        public init(
            event: Swift.String? = nil,
            eventDate: ClientRuntime.Date? = nil
        )
        {
            self.event = event
            self.eventDate = eventDate
        }
    }

}

extension LexModelsV2ClientTypes.BotLocaleImportSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botVersion
        case localeId
        case nluIntentConfidenceThreshold
        case voiceSettings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botId = self.botId {
            try encodeContainer.encode(botId, forKey: .botId)
        }
        if let botVersion = self.botVersion {
            try encodeContainer.encode(botVersion, forKey: .botVersion)
        }
        if let localeId = self.localeId {
            try encodeContainer.encode(localeId, forKey: .localeId)
        }
        if let nluIntentConfidenceThreshold = self.nluIntentConfidenceThreshold {
            try encodeContainer.encode(nluIntentConfidenceThreshold, forKey: .nluIntentConfidenceThreshold)
        }
        if let voiceSettings = self.voiceSettings {
            try encodeContainer.encode(voiceSettings, forKey: .voiceSettings)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let nluIntentConfidenceThresholdDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .nluIntentConfidenceThreshold)
        nluIntentConfidenceThreshold = nluIntentConfidenceThresholdDecoded
        let voiceSettingsDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.VoiceSettings.self, forKey: .voiceSettings)
        voiceSettings = voiceSettingsDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Provides the bot locale parameters required for importing a bot locale.
    public struct BotLocaleImportSpecification: Swift.Equatable {
        /// The identifier of the bot to import the locale to.
        /// This member is required.
        public var botId: Swift.String?
        /// The version of the bot to import the locale to. This can only be the DRAFT version of the bot.
        /// This member is required.
        public var botVersion: Swift.String?
        /// The identifier of the language and locale that the bot will be used in. The string must match one of the supported locales. All of the intents, slot types, and slots used in the bot must have the same locale. For more information, see [Supported languages](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html).
        /// This member is required.
        public var localeId: Swift.String?
        /// Determines the threshold where Amazon Lex will insert the AMAZON.FallbackIntent, AMAZON.KendraSearchIntent, or both when returning alternative intents. AMAZON.FallbackIntent and AMAZON.KendraSearchIntent are only inserted if they are configured for the bot. For example, suppose a bot is configured with the confidence threshold of 0.80 and the AMAZON.FallbackIntent. Amazon Lex returns three alternative intents with the following confidence scores: IntentA (0.70), IntentB (0.60), IntentC (0.50). The response from the PostText operation would be:
        ///
        /// * AMAZON.FallbackIntent
        ///
        /// * IntentA
        ///
        /// * IntentB
        ///
        /// * IntentC
        public var nluIntentConfidenceThreshold: Swift.Double?
        /// Defines settings for using an Amazon Polly voice to communicate with a user.
        public var voiceSettings: LexModelsV2ClientTypes.VoiceSettings?

        public init(
            botId: Swift.String? = nil,
            botVersion: Swift.String? = nil,
            localeId: Swift.String? = nil,
            nluIntentConfidenceThreshold: Swift.Double? = nil,
            voiceSettings: LexModelsV2ClientTypes.VoiceSettings? = nil
        )
        {
            self.botId = botId
            self.botVersion = botVersion
            self.localeId = localeId
            self.nluIntentConfidenceThreshold = nluIntentConfidenceThreshold
            self.voiceSettings = voiceSettings
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum BotLocaleSortAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case botlocalename
        case sdkUnknown(Swift.String)

        public static var allCases: [BotLocaleSortAttribute] {
            return [
                .botlocalename,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .botlocalename: return "BotLocaleName"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BotLocaleSortAttribute(rawValue: rawValue) ?? BotLocaleSortAttribute.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.BotLocaleSortBy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute
        case order
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = self.attribute {
            try encodeContainer.encode(attribute.rawValue, forKey: .attribute)
        }
        if let order = self.order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotLocaleSortAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let orderDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SortOrder.self, forKey: .order)
        order = orderDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Specifies attributes for sorting a list of bot locales.
    public struct BotLocaleSortBy: Swift.Equatable {
        /// The bot locale attribute to sort by.
        /// This member is required.
        public var attribute: LexModelsV2ClientTypes.BotLocaleSortAttribute?
        /// Specifies whether to sort the bot locales in ascending or descending order.
        /// This member is required.
        public var order: LexModelsV2ClientTypes.SortOrder?

        public init(
            attribute: LexModelsV2ClientTypes.BotLocaleSortAttribute? = nil,
            order: LexModelsV2ClientTypes.SortOrder? = nil
        )
        {
            self.attribute = attribute
            self.order = order
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum BotLocaleStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case building
        case built
        case creating
        case deleting
        case failed
        case importing
        case notbuilt
        case processing
        case readyexpresstesting
        case sdkUnknown(Swift.String)

        public static var allCases: [BotLocaleStatus] {
            return [
                .building,
                .built,
                .creating,
                .deleting,
                .failed,
                .importing,
                .notbuilt,
                .processing,
                .readyexpresstesting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .building: return "Building"
            case .built: return "Built"
            case .creating: return "Creating"
            case .deleting: return "Deleting"
            case .failed: return "Failed"
            case .importing: return "Importing"
            case .notbuilt: return "NotBuilt"
            case .processing: return "Processing"
            case .readyexpresstesting: return "ReadyExpressTesting"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BotLocaleStatus(rawValue: rawValue) ?? BotLocaleStatus.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.BotLocaleSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botLocaleStatus
        case description
        case lastBuildSubmittedDateTime
        case lastUpdatedDateTime
        case localeId
        case localeName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botLocaleStatus = self.botLocaleStatus {
            try encodeContainer.encode(botLocaleStatus.rawValue, forKey: .botLocaleStatus)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastBuildSubmittedDateTime = self.lastBuildSubmittedDateTime {
            try encodeContainer.encodeTimestamp(lastBuildSubmittedDateTime, format: .epochSeconds, forKey: .lastBuildSubmittedDateTime)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let localeId = self.localeId {
            try encodeContainer.encode(localeId, forKey: .localeId)
        }
        if let localeName = self.localeName {
            try encodeContainer.encode(localeName, forKey: .localeName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let localeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeName)
        localeName = localeNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let botLocaleStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotLocaleStatus.self, forKey: .botLocaleStatus)
        botLocaleStatus = botLocaleStatusDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let lastBuildSubmittedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastBuildSubmittedDateTime)
        lastBuildSubmittedDateTime = lastBuildSubmittedDateTimeDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Summary information about bot locales returned by the [ListBotLocales](https://docs.aws.amazon.com/lexv2/latest/APIReference/API_ListBotLocales.html) operation.
    public struct BotLocaleSummary: Swift.Equatable {
        /// The current status of the bot locale. When the status is Built the locale is ready for use.
        public var botLocaleStatus: LexModelsV2ClientTypes.BotLocaleStatus?
        /// The description of the bot locale.
        public var description: Swift.String?
        /// A timestamp of the date and time that the bot locale was last built.
        public var lastBuildSubmittedDateTime: ClientRuntime.Date?
        /// A timestamp of the date and time that the bot locale was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The language and locale of the bot locale.
        public var localeId: Swift.String?
        /// The name of the bot locale.
        public var localeName: Swift.String?

        public init(
            botLocaleStatus: LexModelsV2ClientTypes.BotLocaleStatus? = nil,
            description: Swift.String? = nil,
            lastBuildSubmittedDateTime: ClientRuntime.Date? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            localeId: Swift.String? = nil,
            localeName: Swift.String? = nil
        )
        {
            self.botLocaleStatus = botLocaleStatus
            self.description = description
            self.lastBuildSubmittedDateTime = lastBuildSubmittedDateTime
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.localeId = localeId
            self.localeName = localeName
        }
    }

}

extension LexModelsV2ClientTypes.BotMember: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botMemberAliasId
        case botMemberAliasName
        case botMemberId
        case botMemberName
        case botMemberVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botMemberAliasId = self.botMemberAliasId {
            try encodeContainer.encode(botMemberAliasId, forKey: .botMemberAliasId)
        }
        if let botMemberAliasName = self.botMemberAliasName {
            try encodeContainer.encode(botMemberAliasName, forKey: .botMemberAliasName)
        }
        if let botMemberId = self.botMemberId {
            try encodeContainer.encode(botMemberId, forKey: .botMemberId)
        }
        if let botMemberName = self.botMemberName {
            try encodeContainer.encode(botMemberName, forKey: .botMemberName)
        }
        if let botMemberVersion = self.botMemberVersion {
            try encodeContainer.encode(botMemberVersion, forKey: .botMemberVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botMemberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botMemberId)
        botMemberId = botMemberIdDecoded
        let botMemberNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botMemberName)
        botMemberName = botMemberNameDecoded
        let botMemberAliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botMemberAliasId)
        botMemberAliasId = botMemberAliasIdDecoded
        let botMemberAliasNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botMemberAliasName)
        botMemberAliasName = botMemberAliasNameDecoded
        let botMemberVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botMemberVersion)
        botMemberVersion = botMemberVersionDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// A bot that is a member of a network of bots.
    public struct BotMember: Swift.Equatable {
        /// The alias ID of a bot that is a member of this network of bots.
        /// This member is required.
        public var botMemberAliasId: Swift.String?
        /// The alias name of a bot that is a member of this network of bots.
        /// This member is required.
        public var botMemberAliasName: Swift.String?
        /// The unique ID of a bot that is a member of this network of bots.
        /// This member is required.
        public var botMemberId: Swift.String?
        /// The unique name of a bot that is a member of this network of bots.
        /// This member is required.
        public var botMemberName: Swift.String?
        /// The version of a bot that is a member of this network of bots.
        /// This member is required.
        public var botMemberVersion: Swift.String?

        public init(
            botMemberAliasId: Swift.String? = nil,
            botMemberAliasName: Swift.String? = nil,
            botMemberId: Swift.String? = nil,
            botMemberName: Swift.String? = nil,
            botMemberVersion: Swift.String? = nil
        )
        {
            self.botMemberAliasId = botMemberAliasId
            self.botMemberAliasName = botMemberAliasName
            self.botMemberId = botMemberId
            self.botMemberName = botMemberName
            self.botMemberVersion = botMemberVersion
        }
    }

}

extension LexModelsV2ClientTypes.BotRecommendationResultStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case intents
        case slotTypes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let intents = self.intents {
            try encodeContainer.encode(intents, forKey: .intents)
        }
        if let slotTypes = self.slotTypes {
            try encodeContainer.encode(slotTypes, forKey: .slotTypes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intentsDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.IntentStatistics.self, forKey: .intents)
        intents = intentsDecoded
        let slotTypesDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SlotTypeStatistics.self, forKey: .slotTypes)
        slotTypes = slotTypesDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// A statistical summary of the bot recommendation results.
    public struct BotRecommendationResultStatistics: Swift.Equatable {
        /// Statistical information about about the intents associated with the bot recommendation results.
        public var intents: LexModelsV2ClientTypes.IntentStatistics?
        /// Statistical information about the slot types associated with the bot recommendation results.
        public var slotTypes: LexModelsV2ClientTypes.SlotTypeStatistics?

        public init(
            intents: LexModelsV2ClientTypes.IntentStatistics? = nil,
            slotTypes: LexModelsV2ClientTypes.SlotTypeStatistics? = nil
        )
        {
            self.intents = intents
            self.slotTypes = slotTypes
        }
    }

}

extension LexModelsV2ClientTypes.BotRecommendationResults: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedTranscriptsUrl
        case botLocaleExportUrl
        case statistics
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedTranscriptsUrl = self.associatedTranscriptsUrl {
            try encodeContainer.encode(associatedTranscriptsUrl, forKey: .associatedTranscriptsUrl)
        }
        if let botLocaleExportUrl = self.botLocaleExportUrl {
            try encodeContainer.encode(botLocaleExportUrl, forKey: .botLocaleExportUrl)
        }
        if let statistics = self.statistics {
            try encodeContainer.encode(statistics, forKey: .statistics)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botLocaleExportUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botLocaleExportUrl)
        botLocaleExportUrl = botLocaleExportUrlDecoded
        let associatedTranscriptsUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedTranscriptsUrl)
        associatedTranscriptsUrl = associatedTranscriptsUrlDecoded
        let statisticsDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotRecommendationResultStatistics.self, forKey: .statistics)
        statistics = statisticsDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// The object representing the URL of the bot definition, the URL of the associated transcript, and a statistical summary of the bot recommendation results.
    public struct BotRecommendationResults: Swift.Equatable {
        /// The presigned url link of the associated transcript.
        public var associatedTranscriptsUrl: Swift.String?
        /// The presigned URL link of the recommended bot definition.
        public var botLocaleExportUrl: Swift.String?
        /// The statistical summary of the bot recommendation results.
        public var statistics: LexModelsV2ClientTypes.BotRecommendationResultStatistics?

        public init(
            associatedTranscriptsUrl: Swift.String? = nil,
            botLocaleExportUrl: Swift.String? = nil,
            statistics: LexModelsV2ClientTypes.BotRecommendationResultStatistics? = nil
        )
        {
            self.associatedTranscriptsUrl = associatedTranscriptsUrl
            self.botLocaleExportUrl = botLocaleExportUrl
            self.statistics = statistics
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum BotRecommendationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleted
        case deleting
        case downloading
        case failed
        case processing
        case stopped
        case stopping
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [BotRecommendationStatus] {
            return [
                .available,
                .deleted,
                .deleting,
                .downloading,
                .failed,
                .processing,
                .stopped,
                .stopping,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "Available"
            case .deleted: return "Deleted"
            case .deleting: return "Deleting"
            case .downloading: return "Downloading"
            case .failed: return "Failed"
            case .processing: return "Processing"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case .updating: return "Updating"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BotRecommendationStatus(rawValue: rawValue) ?? BotRecommendationStatus.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.BotRecommendationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botRecommendationId
        case botRecommendationStatus
        case creationDateTime
        case lastUpdatedDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botRecommendationId = self.botRecommendationId {
            try encodeContainer.encode(botRecommendationId, forKey: .botRecommendationId)
        }
        if let botRecommendationStatus = self.botRecommendationStatus {
            try encodeContainer.encode(botRecommendationStatus.rawValue, forKey: .botRecommendationStatus)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botRecommendationStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotRecommendationStatus.self, forKey: .botRecommendationStatus)
        botRecommendationStatus = botRecommendationStatusDecoded
        let botRecommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botRecommendationId)
        botRecommendationId = botRecommendationIdDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// A summary of the bot recommendation.
    public struct BotRecommendationSummary: Swift.Equatable {
        /// The unique identifier of the bot recommendation to be updated.
        /// This member is required.
        public var botRecommendationId: Swift.String?
        /// The status of the bot recommendation. If the status is Failed, then the reasons for the failure are listed in the failureReasons field.
        /// This member is required.
        public var botRecommendationStatus: LexModelsV2ClientTypes.BotRecommendationStatus?
        /// A timestamp of the date and time that the bot recommendation was created.
        public var creationDateTime: ClientRuntime.Date?
        /// A timestamp of the date and time that the bot recommendation was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?

        public init(
            botRecommendationId: Swift.String? = nil,
            botRecommendationStatus: LexModelsV2ClientTypes.BotRecommendationStatus? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil
        )
        {
            self.botRecommendationId = botRecommendationId
            self.botRecommendationStatus = botRecommendationStatus
            self.creationDateTime = creationDateTime
            self.lastUpdatedDateTime = lastUpdatedDateTime
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum BotSortAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case botname
        case sdkUnknown(Swift.String)

        public static var allCases: [BotSortAttribute] {
            return [
                .botname,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .botname: return "BotName"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BotSortAttribute(rawValue: rawValue) ?? BotSortAttribute.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.BotSortBy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute
        case order
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = self.attribute {
            try encodeContainer.encode(attribute.rawValue, forKey: .attribute)
        }
        if let order = self.order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotSortAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let orderDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SortOrder.self, forKey: .order)
        order = orderDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Specifies attributes for sorting a list of bots.
    public struct BotSortBy: Swift.Equatable {
        /// The attribute to use to sort the list of bots.
        /// This member is required.
        public var attribute: LexModelsV2ClientTypes.BotSortAttribute?
        /// The order to sort the list. You can choose ascending or descending.
        /// This member is required.
        public var order: LexModelsV2ClientTypes.SortOrder?

        public init(
            attribute: LexModelsV2ClientTypes.BotSortAttribute? = nil,
            order: LexModelsV2ClientTypes.SortOrder? = nil
        )
        {
            self.attribute = attribute
            self.order = order
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum BotStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case creating
        case deleting
        case failed
        case importing
        case inactive
        case updating
        case versioning
        case sdkUnknown(Swift.String)

        public static var allCases: [BotStatus] {
            return [
                .available,
                .creating,
                .deleting,
                .failed,
                .importing,
                .inactive,
                .updating,
                .versioning,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "Available"
            case .creating: return "Creating"
            case .deleting: return "Deleting"
            case .failed: return "Failed"
            case .importing: return "Importing"
            case .inactive: return "Inactive"
            case .updating: return "Updating"
            case .versioning: return "Versioning"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BotStatus(rawValue: rawValue) ?? BotStatus.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.BotSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botName
        case botStatus
        case botType
        case description
        case lastUpdatedDateTime
        case latestBotVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botId = self.botId {
            try encodeContainer.encode(botId, forKey: .botId)
        }
        if let botName = self.botName {
            try encodeContainer.encode(botName, forKey: .botName)
        }
        if let botStatus = self.botStatus {
            try encodeContainer.encode(botStatus.rawValue, forKey: .botStatus)
        }
        if let botType = self.botType {
            try encodeContainer.encode(botType.rawValue, forKey: .botType)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let latestBotVersion = self.latestBotVersion {
            try encodeContainer.encode(latestBotVersion, forKey: .latestBotVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botName)
        botName = botNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let botStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotStatus.self, forKey: .botStatus)
        botStatus = botStatusDecoded
        let latestBotVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestBotVersion)
        latestBotVersion = latestBotVersionDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let botTypeDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotType.self, forKey: .botType)
        botType = botTypeDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Summary information about a bot returned by the [ListBots](https://docs.aws.amazon.com/lexv2/latest/APIReference/API_ListBots.html) operation.
    public struct BotSummary: Swift.Equatable {
        /// The unique identifier assigned to the bot. Use this ID to get detailed information about the bot with the [DescribeBot](https://docs.aws.amazon.com/lexv2/latest/APIReference/API_DescribeBot.html) operation.
        public var botId: Swift.String?
        /// The name of the bot.
        public var botName: Swift.String?
        /// The current status of the bot. When the status is Available the bot is ready for use.
        public var botStatus: LexModelsV2ClientTypes.BotStatus?
        /// The type of the bot.
        public var botType: LexModelsV2ClientTypes.BotType?
        /// The description of the bot.
        public var description: Swift.String?
        /// The date and time that the bot was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The latest numerical version in use for the bot.
        public var latestBotVersion: Swift.String?

        public init(
            botId: Swift.String? = nil,
            botName: Swift.String? = nil,
            botStatus: LexModelsV2ClientTypes.BotStatus? = nil,
            botType: LexModelsV2ClientTypes.BotType? = nil,
            description: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            latestBotVersion: Swift.String? = nil
        )
        {
            self.botId = botId
            self.botName = botName
            self.botStatus = botStatus
            self.botType = botType
            self.description = description
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.latestBotVersion = latestBotVersion
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum BotType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bot
        case botnetwork
        case sdkUnknown(Swift.String)

        public static var allCases: [BotType] {
            return [
                .bot,
                .botnetwork,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bot: return "Bot"
            case .botnetwork: return "BotNetwork"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BotType(rawValue: rawValue) ?? BotType.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.BotVersionLocaleDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceBotVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceBotVersion = self.sourceBotVersion {
            try encodeContainer.encode(sourceBotVersion, forKey: .sourceBotVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceBotVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceBotVersion)
        sourceBotVersion = sourceBotVersionDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// The version of a bot used for a bot locale.
    public struct BotVersionLocaleDetails: Swift.Equatable {
        /// The version of a bot used for a bot locale.
        /// This member is required.
        public var sourceBotVersion: Swift.String?

        public init(
            sourceBotVersion: Swift.String? = nil
        )
        {
            self.sourceBotVersion = sourceBotVersion
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum BotVersionSortAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case botversion
        case sdkUnknown(Swift.String)

        public static var allCases: [BotVersionSortAttribute] {
            return [
                .botversion,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .botversion: return "BotVersion"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BotVersionSortAttribute(rawValue: rawValue) ?? BotVersionSortAttribute.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.BotVersionSortBy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute
        case order
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = self.attribute {
            try encodeContainer.encode(attribute.rawValue, forKey: .attribute)
        }
        if let order = self.order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotVersionSortAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let orderDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SortOrder.self, forKey: .order)
        order = orderDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Specifies attributes for sorting a list of bot versions.
    public struct BotVersionSortBy: Swift.Equatable {
        /// The attribute to use to sort the list of versions.
        /// This member is required.
        public var attribute: LexModelsV2ClientTypes.BotVersionSortAttribute?
        /// The order to sort the list. You can specify ascending or descending order.
        /// This member is required.
        public var order: LexModelsV2ClientTypes.SortOrder?

        public init(
            attribute: LexModelsV2ClientTypes.BotVersionSortAttribute? = nil,
            order: LexModelsV2ClientTypes.SortOrder? = nil
        )
        {
            self.attribute = attribute
            self.order = order
        }
    }

}

extension LexModelsV2ClientTypes.BotVersionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botName
        case botStatus
        case botVersion
        case creationDateTime
        case description
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botName = self.botName {
            try encodeContainer.encode(botName, forKey: .botName)
        }
        if let botStatus = self.botStatus {
            try encodeContainer.encode(botStatus.rawValue, forKey: .botStatus)
        }
        if let botVersion = self.botVersion {
            try encodeContainer.encode(botVersion, forKey: .botVersion)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botName)
        botName = botNameDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let botStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotStatus.self, forKey: .botStatus)
        botStatus = botStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Summary information about a bot version returned by the [ListBotVersions](https://docs.aws.amazon.com/lexv2/latest/APIReference/API_ListBotVersions.html) operation.
    public struct BotVersionSummary: Swift.Equatable {
        /// The name of the bot associated with the version.
        public var botName: Swift.String?
        /// The status of the bot. When the status is available, the version of the bot is ready for use.
        public var botStatus: LexModelsV2ClientTypes.BotStatus?
        /// The numeric version of the bot, or DRAFT to indicate that this is the version of the bot that can be updated..
        public var botVersion: Swift.String?
        /// A timestamp of the date and time that the version was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The description of the version.
        public var description: Swift.String?

        public init(
            botName: Swift.String? = nil,
            botStatus: LexModelsV2ClientTypes.BotStatus? = nil,
            botVersion: Swift.String? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil
        )
        {
            self.botName = botName
            self.botStatus = botStatus
            self.botVersion = botVersion
            self.creationDateTime = creationDateTime
            self.description = description
        }
    }

}

extension BuildBotLocaleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botVersion = botVersion else {
            return nil
        }
        guard let localeId = localeId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botversions/\(botVersion.urlPercentEncoding())/botlocales/\(localeId.urlPercentEncoding())"
    }
}

public struct BuildBotLocaleInput: Swift.Equatable {
    /// The identifier of the bot to build. The identifier is returned in the response from the [CreateBot](https://docs.aws.amazon.com/lexv2/latest/APIReference/API_CreateBot.html) operation.
    /// This member is required.
    public var botId: Swift.String?
    /// The version of the bot to build. This can only be the draft version of the bot.
    /// This member is required.
    public var botVersion: Swift.String?
    /// The identifier of the language and locale that the bot will be used in. The string must match one of the supported locales. All of the intents, slot types, and slots used in the bot must have the same locale. For more information, see [Supported languages](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html).
    /// This member is required.
    public var localeId: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        localeId: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.localeId = localeId
    }
}

struct BuildBotLocaleInputBody: Swift.Equatable {
}

extension BuildBotLocaleInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum BuildBotLocaleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BuildBotLocaleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BuildBotLocaleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botLocaleStatus = output.botLocaleStatus
            self.botVersion = output.botVersion
            self.lastBuildSubmittedDateTime = output.lastBuildSubmittedDateTime
            self.localeId = output.localeId
        } else {
            self.botId = nil
            self.botLocaleStatus = nil
            self.botVersion = nil
            self.lastBuildSubmittedDateTime = nil
            self.localeId = nil
        }
    }
}

public struct BuildBotLocaleOutputResponse: Swift.Equatable {
    /// The identifier of the specified bot.
    public var botId: Swift.String?
    /// The bot's build status. When the status is ReadyExpressTesting you can test the bot using the utterances defined for the intents and slot types. When the status is Built, the bot is ready for use and can be tested using any utterance.
    public var botLocaleStatus: LexModelsV2ClientTypes.BotLocaleStatus?
    /// The version of the bot that was built. This is only the draft version of the bot.
    public var botVersion: Swift.String?
    /// A timestamp indicating the date and time that the bot was last built for this locale.
    public var lastBuildSubmittedDateTime: ClientRuntime.Date?
    /// The language and locale specified of where the bot can be used.
    public var localeId: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botLocaleStatus: LexModelsV2ClientTypes.BotLocaleStatus? = nil,
        botVersion: Swift.String? = nil,
        lastBuildSubmittedDateTime: ClientRuntime.Date? = nil,
        localeId: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botLocaleStatus = botLocaleStatus
        self.botVersion = botVersion
        self.lastBuildSubmittedDateTime = lastBuildSubmittedDateTime
        self.localeId = localeId
    }
}

struct BuildBotLocaleOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let botVersion: Swift.String?
    let localeId: Swift.String?
    let botLocaleStatus: LexModelsV2ClientTypes.BotLocaleStatus?
    let lastBuildSubmittedDateTime: ClientRuntime.Date?
}

extension BuildBotLocaleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botLocaleStatus
        case botVersion
        case lastBuildSubmittedDateTime
        case localeId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let botLocaleStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotLocaleStatus.self, forKey: .botLocaleStatus)
        botLocaleStatus = botLocaleStatusDecoded
        let lastBuildSubmittedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastBuildSubmittedDateTime)
        lastBuildSubmittedDateTime = lastBuildSubmittedDateTimeDecoded
    }
}

extension LexModelsV2ClientTypes {
    public enum BuiltInIntentSortAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case intentsignature
        case sdkUnknown(Swift.String)

        public static var allCases: [BuiltInIntentSortAttribute] {
            return [
                .intentsignature,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .intentsignature: return "IntentSignature"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BuiltInIntentSortAttribute(rawValue: rawValue) ?? BuiltInIntentSortAttribute.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.BuiltInIntentSortBy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute
        case order
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = self.attribute {
            try encodeContainer.encode(attribute.rawValue, forKey: .attribute)
        }
        if let order = self.order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BuiltInIntentSortAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let orderDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SortOrder.self, forKey: .order)
        order = orderDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Specifies attributes for sorting a list of built-in intents.
    public struct BuiltInIntentSortBy: Swift.Equatable {
        /// The attribute to use to sort the list of built-in intents.
        /// This member is required.
        public var attribute: LexModelsV2ClientTypes.BuiltInIntentSortAttribute?
        /// The order to sort the list. You can specify ascending or descending order.
        /// This member is required.
        public var order: LexModelsV2ClientTypes.SortOrder?

        public init(
            attribute: LexModelsV2ClientTypes.BuiltInIntentSortAttribute? = nil,
            order: LexModelsV2ClientTypes.SortOrder? = nil
        )
        {
            self.attribute = attribute
            self.order = order
        }
    }

}

extension LexModelsV2ClientTypes.BuiltInIntentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case intentSignature
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let intentSignature = self.intentSignature {
            try encodeContainer.encode(intentSignature, forKey: .intentSignature)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intentSignatureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intentSignature)
        intentSignature = intentSignatureDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Provides summary information about a built-in intent for the [ ListBuiltInIntents ](https://docs.aws.amazon.com/lexv2/latest/APIReference/API_ListBuiltInIntents.html) operation.
    public struct BuiltInIntentSummary: Swift.Equatable {
        /// The description of the intent.
        public var description: Swift.String?
        /// The signature of the built-in intent. Use this to specify the parent intent of a derived intent.
        public var intentSignature: Swift.String?

        public init(
            description: Swift.String? = nil,
            intentSignature: Swift.String? = nil
        )
        {
            self.description = description
            self.intentSignature = intentSignature
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum BuiltInSlotTypeSortAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case slottypesignature
        case sdkUnknown(Swift.String)

        public static var allCases: [BuiltInSlotTypeSortAttribute] {
            return [
                .slottypesignature,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .slottypesignature: return "SlotTypeSignature"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BuiltInSlotTypeSortAttribute(rawValue: rawValue) ?? BuiltInSlotTypeSortAttribute.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.BuiltInSlotTypeSortBy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute
        case order
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = self.attribute {
            try encodeContainer.encode(attribute.rawValue, forKey: .attribute)
        }
        if let order = self.order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BuiltInSlotTypeSortAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let orderDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SortOrder.self, forKey: .order)
        order = orderDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Specifies attributes for sorting a list of built-in slot types.
    public struct BuiltInSlotTypeSortBy: Swift.Equatable {
        /// The attribute to use to sort the list of built-in intents.
        /// This member is required.
        public var attribute: LexModelsV2ClientTypes.BuiltInSlotTypeSortAttribute?
        /// The order to sort the list. You can choose ascending or descending.
        /// This member is required.
        public var order: LexModelsV2ClientTypes.SortOrder?

        public init(
            attribute: LexModelsV2ClientTypes.BuiltInSlotTypeSortAttribute? = nil,
            order: LexModelsV2ClientTypes.SortOrder? = nil
        )
        {
            self.attribute = attribute
            self.order = order
        }
    }

}

extension LexModelsV2ClientTypes.BuiltInSlotTypeSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case slotTypeSignature
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let slotTypeSignature = self.slotTypeSignature {
            try encodeContainer.encode(slotTypeSignature, forKey: .slotTypeSignature)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let slotTypeSignatureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotTypeSignature)
        slotTypeSignature = slotTypeSignatureDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Provides summary information about a built-in slot type for the [ ListBuiltInSlotTypes ](https://docs.aws.amazon.com/lexv2/latest/APIReference/API_ListBuiltInSlotTypes.html) operation.
    public struct BuiltInSlotTypeSummary: Swift.Equatable {
        /// The description of the built-in slot type.
        public var description: Swift.String?
        /// The signature of the built-in slot type. Use this to specify the parent slot type of a derived slot type.
        public var slotTypeSignature: Swift.String?

        public init(
            description: Swift.String? = nil,
            slotTypeSignature: Swift.String? = nil
        )
        {
            self.description = description
            self.slotTypeSignature = slotTypeSignature
        }
    }

}

extension LexModelsV2ClientTypes.Button: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Describes a button to use on a response card used to gather slot values from a user.
    public struct Button: Swift.Equatable {
        /// The text that appears on the button. Use this to tell the user what value is returned when they choose this button.
        /// This member is required.
        public var text: Swift.String?
        /// The value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
        /// This member is required.
        public var value: Swift.String?

        public init(
            text: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.text = text
            self.value = value
        }
    }

}

extension LexModelsV2ClientTypes.CloudWatchLogGroupLogDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogGroupArn
        case logPrefix
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogGroupArn = self.cloudWatchLogGroupArn {
            try encodeContainer.encode(cloudWatchLogGroupArn, forKey: .cloudWatchLogGroupArn)
        }
        if let logPrefix = self.logPrefix {
            try encodeContainer.encode(logPrefix, forKey: .logPrefix)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLogGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogGroupArn)
        cloudWatchLogGroupArn = cloudWatchLogGroupArnDecoded
        let logPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logPrefix)
        logPrefix = logPrefixDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// The Amazon CloudWatch Logs log group where the text and metadata logs are delivered. The log group must exist before you enable logging.
    public struct CloudWatchLogGroupLogDestination: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the log group where text and metadata logs are delivered.
        /// This member is required.
        public var cloudWatchLogGroupArn: Swift.String?
        /// The prefix of the log stream name within the log group that you specified
        /// This member is required.
        public var logPrefix: Swift.String?

        public init(
            cloudWatchLogGroupArn: Swift.String? = nil,
            logPrefix: Swift.String? = nil
        )
        {
            self.cloudWatchLogGroupArn = cloudWatchLogGroupArn
            self.logPrefix = logPrefix
        }
    }

}

extension LexModelsV2ClientTypes.CodeHookSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lambdaCodeHook
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lambdaCodeHook = self.lambdaCodeHook {
            try encodeContainer.encode(lambdaCodeHook, forKey: .lambdaCodeHook)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaCodeHookDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.LambdaCodeHook.self, forKey: .lambdaCodeHook)
        lambdaCodeHook = lambdaCodeHookDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Contains information about code hooks that Amazon Lex calls during a conversation.
    public struct CodeHookSpecification: Swift.Equatable {
        /// Specifies a Lambda function that verifies requests to a bot or fulfills the user's request to a bot.
        /// This member is required.
        public var lambdaCodeHook: LexModelsV2ClientTypes.LambdaCodeHook?

        public init(
            lambdaCodeHook: LexModelsV2ClientTypes.LambdaCodeHook? = nil
        )
        {
            self.lambdaCodeHook = lambdaCodeHook
        }
    }

}

extension LexModelsV2ClientTypes.CompositeSlotTypeSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subSlots
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subSlots = subSlots {
            var subSlotsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subSlots)
            for subslottypecomposition0 in subSlots {
                try subSlotsContainer.encode(subslottypecomposition0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subSlotsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.SubSlotTypeComposition?].self, forKey: .subSlots)
        var subSlotsDecoded0:[LexModelsV2ClientTypes.SubSlotTypeComposition]? = nil
        if let subSlotsContainer = subSlotsContainer {
            subSlotsDecoded0 = [LexModelsV2ClientTypes.SubSlotTypeComposition]()
            for structure0 in subSlotsContainer {
                if let structure0 = structure0 {
                    subSlotsDecoded0?.append(structure0)
                }
            }
        }
        subSlots = subSlotsDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// A composite slot is a combination of two or more slots that capture multiple pieces of information in a single user input.
    public struct CompositeSlotTypeSetting: Swift.Equatable {
        /// Subslots in the composite slot.
        public var subSlots: [LexModelsV2ClientTypes.SubSlotTypeComposition]?

        public init(
            subSlots: [LexModelsV2ClientTypes.SubSlotTypeComposition]? = nil
        )
        {
            self.subSlots = subSlots
        }
    }

}

extension LexModelsV2ClientTypes.Condition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expressionString
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expressionString = self.expressionString {
            try encodeContainer.encode(expressionString, forKey: .expressionString)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expressionString)
        expressionString = expressionStringDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Provides an expression that evaluates to true or false.
    public struct Condition: Swift.Equatable {
        /// The expression string that is evaluated.
        /// This member is required.
        public var expressionString: Swift.String?

        public init(
            expressionString: Swift.String? = nil
        )
        {
            self.expressionString = expressionString
        }
    }

}

extension LexModelsV2ClientTypes.ConditionalBranch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case condition
        case name
        case nextStep
        case response
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let condition = self.condition {
            try encodeContainer.encode(condition, forKey: .condition)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextStep = self.nextStep {
            try encodeContainer.encode(nextStep, forKey: .nextStep)
        }
        if let response = self.response {
            try encodeContainer.encode(response, forKey: .response)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let conditionDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.Condition.self, forKey: .condition)
        condition = conditionDecoded
        let nextStepDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.DialogState.self, forKey: .nextStep)
        nextStep = nextStepDecoded
        let responseDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ResponseSpecification.self, forKey: .response)
        response = responseDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// A set of actions that Amazon Lex should run if the condition is matched.
    public struct ConditionalBranch: Swift.Equatable {
        /// Contains the expression to evaluate. If the condition is true, the branch's actions are taken.
        /// This member is required.
        public var condition: LexModelsV2ClientTypes.Condition?
        /// The name of the branch.
        /// This member is required.
        public var name: Swift.String?
        /// The next step in the conversation.
        /// This member is required.
        public var nextStep: LexModelsV2ClientTypes.DialogState?
        /// Specifies a list of message groups that Amazon Lex uses to respond the user input.
        public var response: LexModelsV2ClientTypes.ResponseSpecification?

        public init(
            condition: LexModelsV2ClientTypes.Condition? = nil,
            name: Swift.String? = nil,
            nextStep: LexModelsV2ClientTypes.DialogState? = nil,
            response: LexModelsV2ClientTypes.ResponseSpecification? = nil
        )
        {
            self.condition = condition
            self.name = name
            self.nextStep = nextStep
            self.response = response
        }
    }

}

extension LexModelsV2ClientTypes.ConditionalSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case active
        case conditionalBranches
        case defaultBranch
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let active = self.active {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let conditionalBranches = conditionalBranches {
            var conditionalBranchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .conditionalBranches)
            for conditionalbranch0 in conditionalBranches {
                try conditionalBranchesContainer.encode(conditionalbranch0)
            }
        }
        if let defaultBranch = self.defaultBranch {
            try encodeContainer.encode(defaultBranch, forKey: .defaultBranch)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .active)
        active = activeDecoded
        let conditionalBranchesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.ConditionalBranch?].self, forKey: .conditionalBranches)
        var conditionalBranchesDecoded0:[LexModelsV2ClientTypes.ConditionalBranch]? = nil
        if let conditionalBranchesContainer = conditionalBranchesContainer {
            conditionalBranchesDecoded0 = [LexModelsV2ClientTypes.ConditionalBranch]()
            for structure0 in conditionalBranchesContainer {
                if let structure0 = structure0 {
                    conditionalBranchesDecoded0?.append(structure0)
                }
            }
        }
        conditionalBranches = conditionalBranchesDecoded0
        let defaultBranchDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.DefaultConditionalBranch.self, forKey: .defaultBranch)
        defaultBranch = defaultBranchDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Provides a list of conditional branches. Branches are evaluated in the order that they are entered in the list. The first branch with a condition that evaluates to true is executed. The last branch in the list is the default branch. The default branch should not have any condition expression. The default branch is executed if no other branch has a matching condition.
    public struct ConditionalSpecification: Swift.Equatable {
        /// Determines whether a conditional branch is active. When active is false, the conditions are not evaluated.
        /// This member is required.
        public var active: Swift.Bool?
        /// A list of conditional branches. A conditional branch is made up of a condition, a response and a next step. The response and next step are executed when the condition is true.
        /// This member is required.
        public var conditionalBranches: [LexModelsV2ClientTypes.ConditionalBranch]?
        /// The conditional branch that should be followed when the conditions for other branches are not satisfied. A conditional branch is made up of a condition, a response and a next step.
        /// This member is required.
        public var defaultBranch: LexModelsV2ClientTypes.DefaultConditionalBranch?

        public init(
            active: Swift.Bool? = nil,
            conditionalBranches: [LexModelsV2ClientTypes.ConditionalBranch]? = nil,
            defaultBranch: LexModelsV2ClientTypes.DefaultConditionalBranch? = nil
        )
        {
            self.active = active
            self.conditionalBranches = conditionalBranches
            self.defaultBranch = defaultBranch
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The action that you tried to perform couldn't be completed because the resource is in a conflicting state. For example, deleting a bot that is in the CREATING state. Try your request again.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LexModelsV2ClientTypes {
    public enum ConversationEndState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dropped
        case failure
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [ConversationEndState] {
            return [
                .dropped,
                .failure,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dropped: return "Dropped"
            case .failure: return "Failure"
            case .success: return "Success"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConversationEndState(rawValue: rawValue) ?? ConversationEndState.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.ConversationLevelIntentClassificationResultItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case intentName
        case matchResult
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let intentName = self.intentName {
            try encodeContainer.encode(intentName, forKey: .intentName)
        }
        if let matchResult = self.matchResult {
            try encodeContainer.encode(matchResult.rawValue, forKey: .matchResult)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intentName)
        intentName = intentNameDecoded
        let matchResultDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestResultMatchStatus.self, forKey: .matchResult)
        matchResult = matchResultDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// The item listing the evaluation of intent level success or failure.
    public struct ConversationLevelIntentClassificationResultItem: Swift.Equatable {
        /// The intent name used in the evaluation of intent level success or failure.
        /// This member is required.
        public var intentName: Swift.String?
        /// The number of times the specific intent is used in the evaluation of intent level success or failure.
        /// This member is required.
        public var matchResult: LexModelsV2ClientTypes.TestResultMatchStatus?

        public init(
            intentName: Swift.String? = nil,
            matchResult: LexModelsV2ClientTypes.TestResultMatchStatus? = nil
        )
        {
            self.intentName = intentName
            self.matchResult = matchResult
        }
    }

}

extension LexModelsV2ClientTypes.ConversationLevelResultDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endToEndResult
        case speechTranscriptionResult
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endToEndResult = self.endToEndResult {
            try encodeContainer.encode(endToEndResult.rawValue, forKey: .endToEndResult)
        }
        if let speechTranscriptionResult = self.speechTranscriptionResult {
            try encodeContainer.encode(speechTranscriptionResult.rawValue, forKey: .speechTranscriptionResult)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endToEndResultDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestResultMatchStatus.self, forKey: .endToEndResult)
        endToEndResult = endToEndResultDecoded
        let speechTranscriptionResultDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestResultMatchStatus.self, forKey: .speechTranscriptionResult)
        speechTranscriptionResult = speechTranscriptionResultDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// The conversation level details of the conversation used in the test set.
    public struct ConversationLevelResultDetail: Swift.Equatable {
        /// The success or failure of the streaming of the conversation.
        /// This member is required.
        public var endToEndResult: LexModelsV2ClientTypes.TestResultMatchStatus?
        /// The speech transcription success or failure details of the conversation.
        public var speechTranscriptionResult: LexModelsV2ClientTypes.TestResultMatchStatus?

        public init(
            endToEndResult: LexModelsV2ClientTypes.TestResultMatchStatus? = nil,
            speechTranscriptionResult: LexModelsV2ClientTypes.TestResultMatchStatus? = nil
        )
        {
            self.endToEndResult = endToEndResult
            self.speechTranscriptionResult = speechTranscriptionResult
        }
    }

}

extension LexModelsV2ClientTypes.ConversationLevelSlotResolutionResultItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case intentName
        case matchResult
        case slotName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let intentName = self.intentName {
            try encodeContainer.encode(intentName, forKey: .intentName)
        }
        if let matchResult = self.matchResult {
            try encodeContainer.encode(matchResult.rawValue, forKey: .matchResult)
        }
        if let slotName = self.slotName {
            try encodeContainer.encode(slotName, forKey: .slotName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intentName)
        intentName = intentNameDecoded
        let slotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotName)
        slotName = slotNameDecoded
        let matchResultDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestResultMatchStatus.self, forKey: .matchResult)
        matchResult = matchResultDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// The slots used for the slot resolution in the conversation.
    public struct ConversationLevelSlotResolutionResultItem: Swift.Equatable {
        /// The intents used in the slots list for the slot resolution details.
        /// This member is required.
        public var intentName: Swift.String?
        /// The number of matching slots used in the slots listings for the slot resolution evaluation.
        /// This member is required.
        public var matchResult: LexModelsV2ClientTypes.TestResultMatchStatus?
        /// The slot name in the slots list for the slot resolution details.
        /// This member is required.
        public var slotName: Swift.String?

        public init(
            intentName: Swift.String? = nil,
            matchResult: LexModelsV2ClientTypes.TestResultMatchStatus? = nil,
            slotName: Swift.String? = nil
        )
        {
            self.intentName = intentName
            self.matchResult = matchResult
            self.slotName = slotName
        }
    }

}

extension LexModelsV2ClientTypes.ConversationLevelTestResultItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conversationId
        case endToEndResult
        case intentClassificationResults
        case slotResolutionResults
        case speechTranscriptionResult
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conversationId = self.conversationId {
            try encodeContainer.encode(conversationId, forKey: .conversationId)
        }
        if let endToEndResult = self.endToEndResult {
            try encodeContainer.encode(endToEndResult.rawValue, forKey: .endToEndResult)
        }
        if let intentClassificationResults = intentClassificationResults {
            var intentClassificationResultsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .intentClassificationResults)
            for conversationlevelintentclassificationresultitem0 in intentClassificationResults {
                try intentClassificationResultsContainer.encode(conversationlevelintentclassificationresultitem0)
            }
        }
        if let slotResolutionResults = slotResolutionResults {
            var slotResolutionResultsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .slotResolutionResults)
            for conversationlevelslotresolutionresultitem0 in slotResolutionResults {
                try slotResolutionResultsContainer.encode(conversationlevelslotresolutionresultitem0)
            }
        }
        if let speechTranscriptionResult = self.speechTranscriptionResult {
            try encodeContainer.encode(speechTranscriptionResult.rawValue, forKey: .speechTranscriptionResult)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conversationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conversationId)
        conversationId = conversationIdDecoded
        let endToEndResultDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestResultMatchStatus.self, forKey: .endToEndResult)
        endToEndResult = endToEndResultDecoded
        let speechTranscriptionResultDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestResultMatchStatus.self, forKey: .speechTranscriptionResult)
        speechTranscriptionResult = speechTranscriptionResultDecoded
        let intentClassificationResultsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.ConversationLevelIntentClassificationResultItem?].self, forKey: .intentClassificationResults)
        var intentClassificationResultsDecoded0:[LexModelsV2ClientTypes.ConversationLevelIntentClassificationResultItem]? = nil
        if let intentClassificationResultsContainer = intentClassificationResultsContainer {
            intentClassificationResultsDecoded0 = [LexModelsV2ClientTypes.ConversationLevelIntentClassificationResultItem]()
            for structure0 in intentClassificationResultsContainer {
                if let structure0 = structure0 {
                    intentClassificationResultsDecoded0?.append(structure0)
                }
            }
        }
        intentClassificationResults = intentClassificationResultsDecoded0
        let slotResolutionResultsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.ConversationLevelSlotResolutionResultItem?].self, forKey: .slotResolutionResults)
        var slotResolutionResultsDecoded0:[LexModelsV2ClientTypes.ConversationLevelSlotResolutionResultItem]? = nil
        if let slotResolutionResultsContainer = slotResolutionResultsContainer {
            slotResolutionResultsDecoded0 = [LexModelsV2ClientTypes.ConversationLevelSlotResolutionResultItem]()
            for structure0 in slotResolutionResultsContainer {
                if let structure0 = structure0 {
                    slotResolutionResultsDecoded0?.append(structure0)
                }
            }
        }
        slotResolutionResults = slotResolutionResultsDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// The test result evaluation item at the conversation level.
    public struct ConversationLevelTestResultItem: Swift.Equatable {
        /// The conversation Id of the test result evaluation item.
        /// This member is required.
        public var conversationId: Swift.String?
        /// The end-to-end success or failure of the test result evaluation item.
        /// This member is required.
        public var endToEndResult: LexModelsV2ClientTypes.TestResultMatchStatus?
        /// The intent classification of the test result evaluation item.
        /// This member is required.
        public var intentClassificationResults: [LexModelsV2ClientTypes.ConversationLevelIntentClassificationResultItem]?
        /// The slot success or failure of the test result evaluation item.
        /// This member is required.
        public var slotResolutionResults: [LexModelsV2ClientTypes.ConversationLevelSlotResolutionResultItem]?
        /// The speech transcription success or failure of the test result evaluation item.
        public var speechTranscriptionResult: LexModelsV2ClientTypes.TestResultMatchStatus?

        public init(
            conversationId: Swift.String? = nil,
            endToEndResult: LexModelsV2ClientTypes.TestResultMatchStatus? = nil,
            intentClassificationResults: [LexModelsV2ClientTypes.ConversationLevelIntentClassificationResultItem]? = nil,
            slotResolutionResults: [LexModelsV2ClientTypes.ConversationLevelSlotResolutionResultItem]? = nil,
            speechTranscriptionResult: LexModelsV2ClientTypes.TestResultMatchStatus? = nil
        )
        {
            self.conversationId = conversationId
            self.endToEndResult = endToEndResult
            self.intentClassificationResults = intentClassificationResults
            self.slotResolutionResults = slotResolutionResults
            self.speechTranscriptionResult = speechTranscriptionResult
        }
    }

}

extension LexModelsV2ClientTypes.ConversationLevelTestResults: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for conversationleveltestresultitem0 in items {
                try itemsContainer.encode(conversationleveltestresultitem0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.ConversationLevelTestResultItem?].self, forKey: .items)
        var itemsDecoded0:[LexModelsV2ClientTypes.ConversationLevelTestResultItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [LexModelsV2ClientTypes.ConversationLevelTestResultItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// The test set results data at the conversation level.
    public struct ConversationLevelTestResults: Swift.Equatable {
        /// The item list in the test set results data at the conversation level.
        /// This member is required.
        public var items: [LexModelsV2ClientTypes.ConversationLevelTestResultItem]?

        public init(
            items: [LexModelsV2ClientTypes.ConversationLevelTestResultItem]? = nil
        )
        {
            self.items = items
        }
    }

}

extension LexModelsV2ClientTypes.ConversationLevelTestResultsFilterBy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endToEndResult
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endToEndResult = self.endToEndResult {
            try encodeContainer.encode(endToEndResult.rawValue, forKey: .endToEndResult)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endToEndResultDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestResultMatchStatus.self, forKey: .endToEndResult)
        endToEndResult = endToEndResultDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// The selection to filter the test set results data at the conversation level.
    public struct ConversationLevelTestResultsFilterBy: Swift.Equatable {
        /// The selection of matched or mismatched end-to-end status to filter test set results data at the conversation level.
        public var endToEndResult: LexModelsV2ClientTypes.TestResultMatchStatus?

        public init(
            endToEndResult: LexModelsV2ClientTypes.TestResultMatchStatus? = nil
        )
        {
            self.endToEndResult = endToEndResult
        }
    }

}

extension LexModelsV2ClientTypes.ConversationLogSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioLogSettings
        case textLogSettings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audioLogSettings = audioLogSettings {
            var audioLogSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .audioLogSettings)
            for audiologsetting0 in audioLogSettings {
                try audioLogSettingsContainer.encode(audiologsetting0)
            }
        }
        if let textLogSettings = textLogSettings {
            var textLogSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .textLogSettings)
            for textlogsetting0 in textLogSettings {
                try textLogSettingsContainer.encode(textlogsetting0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textLogSettingsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.TextLogSetting?].self, forKey: .textLogSettings)
        var textLogSettingsDecoded0:[LexModelsV2ClientTypes.TextLogSetting]? = nil
        if let textLogSettingsContainer = textLogSettingsContainer {
            textLogSettingsDecoded0 = [LexModelsV2ClientTypes.TextLogSetting]()
            for structure0 in textLogSettingsContainer {
                if let structure0 = structure0 {
                    textLogSettingsDecoded0?.append(structure0)
                }
            }
        }
        textLogSettings = textLogSettingsDecoded0
        let audioLogSettingsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AudioLogSetting?].self, forKey: .audioLogSettings)
        var audioLogSettingsDecoded0:[LexModelsV2ClientTypes.AudioLogSetting]? = nil
        if let audioLogSettingsContainer = audioLogSettingsContainer {
            audioLogSettingsDecoded0 = [LexModelsV2ClientTypes.AudioLogSetting]()
            for structure0 in audioLogSettingsContainer {
                if let structure0 = structure0 {
                    audioLogSettingsDecoded0?.append(structure0)
                }
            }
        }
        audioLogSettings = audioLogSettingsDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// Configures conversation logging that saves audio, text, and metadata for the conversations with your users.
    public struct ConversationLogSettings: Swift.Equatable {
        /// The Amazon S3 settings for logging audio to an S3 bucket.
        public var audioLogSettings: [LexModelsV2ClientTypes.AudioLogSetting]?
        /// The Amazon CloudWatch Logs settings for logging text and metadata.
        public var textLogSettings: [LexModelsV2ClientTypes.TextLogSetting]?

        public init(
            audioLogSettings: [LexModelsV2ClientTypes.AudioLogSetting]? = nil,
            textLogSettings: [LexModelsV2ClientTypes.TextLogSetting]? = nil
        )
        {
            self.audioLogSettings = audioLogSettings
            self.textLogSettings = textLogSettings
        }
    }

}

extension LexModelsV2ClientTypes.ConversationLogsDataSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botAliasId
        case botId
        case filter
        case localeId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botAliasId = self.botAliasId {
            try encodeContainer.encode(botAliasId, forKey: .botAliasId)
        }
        if let botId = self.botId {
            try encodeContainer.encode(botId, forKey: .botId)
        }
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let localeId = self.localeId {
            try encodeContainer.encode(localeId, forKey: .localeId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botAliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botAliasId)
        botAliasId = botAliasIdDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let filterDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ConversationLogsDataSourceFilterBy.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// The data source that uses conversation logs.
    public struct ConversationLogsDataSource: Swift.Equatable {
        /// The bot alias Id from the conversation logs.
        /// This member is required.
        public var botAliasId: Swift.String?
        /// The bot Id from the conversation logs.
        /// This member is required.
        public var botId: Swift.String?
        /// The filter for the data source of the conversation log.
        /// This member is required.
        public var filter: LexModelsV2ClientTypes.ConversationLogsDataSourceFilterBy?
        /// The locale Id of the conversation log.
        /// This member is required.
        public var localeId: Swift.String?

        public init(
            botAliasId: Swift.String? = nil,
            botId: Swift.String? = nil,
            filter: LexModelsV2ClientTypes.ConversationLogsDataSourceFilterBy? = nil,
            localeId: Swift.String? = nil
        )
        {
            self.botAliasId = botAliasId
            self.botId = botId
            self.filter = filter
            self.localeId = localeId
        }
    }

}

extension LexModelsV2ClientTypes.ConversationLogsDataSourceFilterBy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case inputMode
        case startTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let inputMode = self.inputMode {
            try encodeContainer.encode(inputMode.rawValue, forKey: .inputMode)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let inputModeDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ConversationLogsInputModeFilter.self, forKey: .inputMode)
        inputMode = inputModeDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// The selected data source to filter the conversation log.
    public struct ConversationLogsDataSourceFilterBy: Swift.Equatable {
        /// The end time for the conversation log.
        /// This member is required.
        public var endTime: ClientRuntime.Date?
        /// The selection to filter by input mode for the conversation logs.
        /// This member is required.
        public var inputMode: LexModelsV2ClientTypes.ConversationLogsInputModeFilter?
        /// The start time for the conversation log.
        /// This member is required.
        public var startTime: ClientRuntime.Date?

        public init(
            endTime: ClientRuntime.Date? = nil,
            inputMode: LexModelsV2ClientTypes.ConversationLogsInputModeFilter? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.endTime = endTime
            self.inputMode = inputMode
            self.startTime = startTime
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum ConversationLogsInputModeFilter: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case speech
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [ConversationLogsInputModeFilter] {
            return [
                .speech,
                .text,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .speech: return "Speech"
            case .text: return "Text"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConversationLogsInputModeFilter(rawValue: rawValue) ?? ConversationLogsInputModeFilter.sdkUnknown(rawValue)
        }
    }
}

extension CreateBotAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botAliasLocaleSettings
        case botAliasName
        case botVersion
        case conversationLogSettings
        case description
        case sentimentAnalysisSettings
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botAliasLocaleSettings = botAliasLocaleSettings {
            var botAliasLocaleSettingsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .botAliasLocaleSettings)
            for (dictKey0, botAliasLocaleSettingsMap0) in botAliasLocaleSettings {
                try botAliasLocaleSettingsContainer.encode(botAliasLocaleSettingsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let botAliasName = self.botAliasName {
            try encodeContainer.encode(botAliasName, forKey: .botAliasName)
        }
        if let botVersion = self.botVersion {
            try encodeContainer.encode(botVersion, forKey: .botVersion)
        }
        if let conversationLogSettings = self.conversationLogSettings {
            try encodeContainer.encode(conversationLogSettings, forKey: .conversationLogSettings)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let sentimentAnalysisSettings = self.sentimentAnalysisSettings {
            try encodeContainer.encode(sentimentAnalysisSettings, forKey: .sentimentAnalysisSettings)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateBotAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botaliases"
    }
}

public struct CreateBotAliasInput: Swift.Equatable {
    /// Maps configuration information to a specific locale. You can use this parameter to specify a specific Lambda function to run different functions in different locales.
    public var botAliasLocaleSettings: [Swift.String:LexModelsV2ClientTypes.BotAliasLocaleSettings]?
    /// The alias to create. The name must be unique for the bot.
    /// This member is required.
    public var botAliasName: Swift.String?
    /// The unique identifier of the bot that the alias applies to.
    /// This member is required.
    public var botId: Swift.String?
    /// The version of the bot that this alias points to. You can use the [UpdateBotAlias](https://docs.aws.amazon.com/lexv2/latest/APIReference/API_UpdateBotAlias.html) operation to change the bot version associated with the alias.
    public var botVersion: Swift.String?
    /// Specifies whether Amazon Lex logs text and audio for a conversation with the bot. When you enable conversation logs, text logs store text input, transcripts of audio input, and associated metadata in Amazon CloudWatch Logs. Audio logs store audio input in Amazon S3.
    public var conversationLogSettings: LexModelsV2ClientTypes.ConversationLogSettings?
    /// A description of the alias. Use this description to help identify the alias.
    public var description: Swift.String?
    /// Determines whether Amazon Lex will use Amazon Comprehend to detect the sentiment of user utterances.
    public var sentimentAnalysisSettings: LexModelsV2ClientTypes.SentimentAnalysisSettings?
    /// A list of tags to add to the bot alias. You can only add tags when you create an alias, you can't use the UpdateBotAlias operation to update the tags on a bot alias. To update tags, use the TagResource operation.
    public var tags: [Swift.String:Swift.String]?

    public init(
        botAliasLocaleSettings: [Swift.String:LexModelsV2ClientTypes.BotAliasLocaleSettings]? = nil,
        botAliasName: Swift.String? = nil,
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        conversationLogSettings: LexModelsV2ClientTypes.ConversationLogSettings? = nil,
        description: Swift.String? = nil,
        sentimentAnalysisSettings: LexModelsV2ClientTypes.SentimentAnalysisSettings? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.botAliasLocaleSettings = botAliasLocaleSettings
        self.botAliasName = botAliasName
        self.botId = botId
        self.botVersion = botVersion
        self.conversationLogSettings = conversationLogSettings
        self.description = description
        self.sentimentAnalysisSettings = sentimentAnalysisSettings
        self.tags = tags
    }
}

struct CreateBotAliasInputBody: Swift.Equatable {
    let botAliasName: Swift.String?
    let description: Swift.String?
    let botVersion: Swift.String?
    let botAliasLocaleSettings: [Swift.String:LexModelsV2ClientTypes.BotAliasLocaleSettings]?
    let conversationLogSettings: LexModelsV2ClientTypes.ConversationLogSettings?
    let sentimentAnalysisSettings: LexModelsV2ClientTypes.SentimentAnalysisSettings?
    let tags: [Swift.String:Swift.String]?
}

extension CreateBotAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botAliasLocaleSettings
        case botAliasName
        case botVersion
        case conversationLogSettings
        case description
        case sentimentAnalysisSettings
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botAliasNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botAliasName)
        botAliasName = botAliasNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let botAliasLocaleSettingsContainer = try containerValues.decodeIfPresent([Swift.String: LexModelsV2ClientTypes.BotAliasLocaleSettings?].self, forKey: .botAliasLocaleSettings)
        var botAliasLocaleSettingsDecoded0: [Swift.String:LexModelsV2ClientTypes.BotAliasLocaleSettings]? = nil
        if let botAliasLocaleSettingsContainer = botAliasLocaleSettingsContainer {
            botAliasLocaleSettingsDecoded0 = [Swift.String:LexModelsV2ClientTypes.BotAliasLocaleSettings]()
            for (key0, botaliaslocalesettings0) in botAliasLocaleSettingsContainer {
                if let botaliaslocalesettings0 = botaliaslocalesettings0 {
                    botAliasLocaleSettingsDecoded0?[key0] = botaliaslocalesettings0
                }
            }
        }
        botAliasLocaleSettings = botAliasLocaleSettingsDecoded0
        let conversationLogSettingsDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ConversationLogSettings.self, forKey: .conversationLogSettings)
        conversationLogSettings = conversationLogSettingsDecoded
        let sentimentAnalysisSettingsDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SentimentAnalysisSettings.self, forKey: .sentimentAnalysisSettings)
        sentimentAnalysisSettings = sentimentAnalysisSettingsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateBotAliasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateBotAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateBotAliasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botAliasId = output.botAliasId
            self.botAliasLocaleSettings = output.botAliasLocaleSettings
            self.botAliasName = output.botAliasName
            self.botAliasStatus = output.botAliasStatus
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.conversationLogSettings = output.conversationLogSettings
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.sentimentAnalysisSettings = output.sentimentAnalysisSettings
            self.tags = output.tags
        } else {
            self.botAliasId = nil
            self.botAliasLocaleSettings = nil
            self.botAliasName = nil
            self.botAliasStatus = nil
            self.botId = nil
            self.botVersion = nil
            self.conversationLogSettings = nil
            self.creationDateTime = nil
            self.description = nil
            self.sentimentAnalysisSettings = nil
            self.tags = nil
        }
    }
}

public struct CreateBotAliasOutputResponse: Swift.Equatable {
    /// The unique identifier of the bot alias.
    public var botAliasId: Swift.String?
    /// Configuration information for a specific locale.
    public var botAliasLocaleSettings: [Swift.String:LexModelsV2ClientTypes.BotAliasLocaleSettings]?
    /// The name specified for the bot alias.
    public var botAliasName: Swift.String?
    /// The current status of the alias. The alias is first put into the Creating state. When the alias is ready to be used, it is put into the Available state. You can use the DescribeBotAlias operation to get the current state of an alias.
    public var botAliasStatus: LexModelsV2ClientTypes.BotAliasStatus?
    /// The unique identifier of the bot that this alias applies to.
    public var botId: Swift.String?
    /// The version of the bot associated with this alias.
    public var botVersion: Swift.String?
    /// The conversation log settings specified for the alias.
    public var conversationLogSettings: LexModelsV2ClientTypes.ConversationLogSettings?
    /// A Unix timestamp indicating the date and time that the bot alias was created.
    public var creationDateTime: ClientRuntime.Date?
    /// The description specified for the bot alias.
    public var description: Swift.String?
    /// Determines whether Amazon Lex will use Amazon Comprehend to detect the sentiment of user utterances.
    public var sentimentAnalysisSettings: LexModelsV2ClientTypes.SentimentAnalysisSettings?
    /// A list of tags associated with the bot alias.
    public var tags: [Swift.String:Swift.String]?

    public init(
        botAliasId: Swift.String? = nil,
        botAliasLocaleSettings: [Swift.String:LexModelsV2ClientTypes.BotAliasLocaleSettings]? = nil,
        botAliasName: Swift.String? = nil,
        botAliasStatus: LexModelsV2ClientTypes.BotAliasStatus? = nil,
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        conversationLogSettings: LexModelsV2ClientTypes.ConversationLogSettings? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        sentimentAnalysisSettings: LexModelsV2ClientTypes.SentimentAnalysisSettings? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.botAliasId = botAliasId
        self.botAliasLocaleSettings = botAliasLocaleSettings
        self.botAliasName = botAliasName
        self.botAliasStatus = botAliasStatus
        self.botId = botId
        self.botVersion = botVersion
        self.conversationLogSettings = conversationLogSettings
        self.creationDateTime = creationDateTime
        self.description = description
        self.sentimentAnalysisSettings = sentimentAnalysisSettings
        self.tags = tags
    }
}

struct CreateBotAliasOutputResponseBody: Swift.Equatable {
    let botAliasId: Swift.String?
    let botAliasName: Swift.String?
    let description: Swift.String?
    let botVersion: Swift.String?
    let botAliasLocaleSettings: [Swift.String:LexModelsV2ClientTypes.BotAliasLocaleSettings]?
    let conversationLogSettings: LexModelsV2ClientTypes.ConversationLogSettings?
    let sentimentAnalysisSettings: LexModelsV2ClientTypes.SentimentAnalysisSettings?
    let botAliasStatus: LexModelsV2ClientTypes.BotAliasStatus?
    let botId: Swift.String?
    let creationDateTime: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension CreateBotAliasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botAliasId
        case botAliasLocaleSettings
        case botAliasName
        case botAliasStatus
        case botId
        case botVersion
        case conversationLogSettings
        case creationDateTime
        case description
        case sentimentAnalysisSettings
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botAliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botAliasId)
        botAliasId = botAliasIdDecoded
        let botAliasNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botAliasName)
        botAliasName = botAliasNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let botAliasLocaleSettingsContainer = try containerValues.decodeIfPresent([Swift.String: LexModelsV2ClientTypes.BotAliasLocaleSettings?].self, forKey: .botAliasLocaleSettings)
        var botAliasLocaleSettingsDecoded0: [Swift.String:LexModelsV2ClientTypes.BotAliasLocaleSettings]? = nil
        if let botAliasLocaleSettingsContainer = botAliasLocaleSettingsContainer {
            botAliasLocaleSettingsDecoded0 = [Swift.String:LexModelsV2ClientTypes.BotAliasLocaleSettings]()
            for (key0, botaliaslocalesettings0) in botAliasLocaleSettingsContainer {
                if let botaliaslocalesettings0 = botaliaslocalesettings0 {
                    botAliasLocaleSettingsDecoded0?[key0] = botaliaslocalesettings0
                }
            }
        }
        botAliasLocaleSettings = botAliasLocaleSettingsDecoded0
        let conversationLogSettingsDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ConversationLogSettings.self, forKey: .conversationLogSettings)
        conversationLogSettings = conversationLogSettingsDecoded
        let sentimentAnalysisSettingsDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SentimentAnalysisSettings.self, forKey: .sentimentAnalysisSettings)
        sentimentAnalysisSettings = sentimentAnalysisSettingsDecoded
        let botAliasStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotAliasStatus.self, forKey: .botAliasStatus)
        botAliasStatus = botAliasStatusDecoded
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateBotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botMembers
        case botName
        case botTags
        case botType
        case dataPrivacy
        case description
        case idleSessionTTLInSeconds
        case roleArn
        case testBotAliasTags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botMembers = botMembers {
            var botMembersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .botMembers)
            for botmember0 in botMembers {
                try botMembersContainer.encode(botmember0)
            }
        }
        if let botName = self.botName {
            try encodeContainer.encode(botName, forKey: .botName)
        }
        if let botTags = botTags {
            var botTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .botTags)
            for (dictKey0, tagMap0) in botTags {
                try botTagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let botType = self.botType {
            try encodeContainer.encode(botType.rawValue, forKey: .botType)
        }
        if let dataPrivacy = self.dataPrivacy {
            try encodeContainer.encode(dataPrivacy, forKey: .dataPrivacy)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let idleSessionTTLInSeconds = self.idleSessionTTLInSeconds {
            try encodeContainer.encode(idleSessionTTLInSeconds, forKey: .idleSessionTTLInSeconds)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let testBotAliasTags = testBotAliasTags {
            var testBotAliasTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .testBotAliasTags)
            for (dictKey0, tagMap0) in testBotAliasTags {
                try testBotAliasTagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateBotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/bots"
    }
}

public struct CreateBotInput: Swift.Equatable {
    /// The list of bot members in a network to be created.
    public var botMembers: [LexModelsV2ClientTypes.BotMember]?
    /// The name of the bot. The bot name must be unique in the account that creates the bot.
    /// This member is required.
    public var botName: Swift.String?
    /// A list of tags to add to the bot. You can only add tags when you create a bot. You can't use the UpdateBot operation to update tags. To update tags, use the TagResource operation.
    public var botTags: [Swift.String:Swift.String]?
    /// The type of a bot to create.
    public var botType: LexModelsV2ClientTypes.BotType?
    /// Provides information on additional privacy protections Amazon Lex should use with the bot's data.
    /// This member is required.
    public var dataPrivacy: LexModelsV2ClientTypes.DataPrivacy?
    /// A description of the bot. It appears in lists to help you identify a particular bot.
    public var description: Swift.String?
    /// The time, in seconds, that Amazon Lex should keep information about a user's conversation with the bot. A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Lex deletes any data provided before the timeout. You can specify between 60 (1 minute) and 86,400 (24 hours) seconds.
    /// This member is required.
    public var idleSessionTTLInSeconds: Swift.Int?
    /// The Amazon Resource Name (ARN) of an IAM role that has permission to access the bot.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A list of tags to add to the test alias for a bot. You can only add tags when you create a bot. You can't use the UpdateAlias operation to update tags. To update tags on the test alias, use the TagResource operation.
    public var testBotAliasTags: [Swift.String:Swift.String]?

    public init(
        botMembers: [LexModelsV2ClientTypes.BotMember]? = nil,
        botName: Swift.String? = nil,
        botTags: [Swift.String:Swift.String]? = nil,
        botType: LexModelsV2ClientTypes.BotType? = nil,
        dataPrivacy: LexModelsV2ClientTypes.DataPrivacy? = nil,
        description: Swift.String? = nil,
        idleSessionTTLInSeconds: Swift.Int? = nil,
        roleArn: Swift.String? = nil,
        testBotAliasTags: [Swift.String:Swift.String]? = nil
    )
    {
        self.botMembers = botMembers
        self.botName = botName
        self.botTags = botTags
        self.botType = botType
        self.dataPrivacy = dataPrivacy
        self.description = description
        self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
        self.roleArn = roleArn
        self.testBotAliasTags = testBotAliasTags
    }
}

struct CreateBotInputBody: Swift.Equatable {
    let botName: Swift.String?
    let description: Swift.String?
    let roleArn: Swift.String?
    let dataPrivacy: LexModelsV2ClientTypes.DataPrivacy?
    let idleSessionTTLInSeconds: Swift.Int?
    let botTags: [Swift.String:Swift.String]?
    let testBotAliasTags: [Swift.String:Swift.String]?
    let botType: LexModelsV2ClientTypes.BotType?
    let botMembers: [LexModelsV2ClientTypes.BotMember]?
}

extension CreateBotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botMembers
        case botName
        case botTags
        case botType
        case dataPrivacy
        case description
        case idleSessionTTLInSeconds
        case roleArn
        case testBotAliasTags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botName)
        botName = botNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let dataPrivacyDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.DataPrivacy.self, forKey: .dataPrivacy)
        dataPrivacy = dataPrivacyDecoded
        let idleSessionTTLInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleSessionTTLInSeconds)
        idleSessionTTLInSeconds = idleSessionTTLInSecondsDecoded
        let botTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .botTags)
        var botTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let botTagsContainer = botTagsContainer {
            botTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in botTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    botTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        botTags = botTagsDecoded0
        let testBotAliasTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .testBotAliasTags)
        var testBotAliasTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let testBotAliasTagsContainer = testBotAliasTagsContainer {
            testBotAliasTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in testBotAliasTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    testBotAliasTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        testBotAliasTags = testBotAliasTagsDecoded0
        let botTypeDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotType.self, forKey: .botType)
        botType = botTypeDecoded
        let botMembersContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.BotMember?].self, forKey: .botMembers)
        var botMembersDecoded0:[LexModelsV2ClientTypes.BotMember]? = nil
        if let botMembersContainer = botMembersContainer {
            botMembersDecoded0 = [LexModelsV2ClientTypes.BotMember]()
            for structure0 in botMembersContainer {
                if let structure0 = structure0 {
                    botMembersDecoded0?.append(structure0)
                }
            }
        }
        botMembers = botMembersDecoded0
    }
}

extension CreateBotLocaleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case localeId
        case nluIntentConfidenceThreshold
        case voiceSettings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let localeId = self.localeId {
            try encodeContainer.encode(localeId, forKey: .localeId)
        }
        if let nluIntentConfidenceThreshold = self.nluIntentConfidenceThreshold {
            try encodeContainer.encode(nluIntentConfidenceThreshold, forKey: .nluIntentConfidenceThreshold)
        }
        if let voiceSettings = self.voiceSettings {
            try encodeContainer.encode(voiceSettings, forKey: .voiceSettings)
        }
    }
}

extension CreateBotLocaleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botVersion = botVersion else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botversions/\(botVersion.urlPercentEncoding())/botlocales"
    }
}

public struct CreateBotLocaleInput: Swift.Equatable {
    /// The identifier of the bot to create the locale for.
    /// This member is required.
    public var botId: Swift.String?
    /// The version of the bot to create the locale for. This can only be the draft version of the bot.
    /// This member is required.
    public var botVersion: Swift.String?
    /// A description of the bot locale. Use this to help identify the bot locale in lists.
    public var description: Swift.String?
    /// The identifier of the language and locale that the bot will be used in. The string must match one of the supported locales. All of the intents, slot types, and slots used in the bot must have the same locale. For more information, see [Supported languages](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html).
    /// This member is required.
    public var localeId: Swift.String?
    /// Determines the threshold where Amazon Lex will insert the AMAZON.FallbackIntent, AMAZON.KendraSearchIntent, or both when returning alternative intents. AMAZON.FallbackIntent and AMAZON.KendraSearchIntent are only inserted if they are configured for the bot. For example, suppose a bot is configured with the confidence threshold of 0.80 and the AMAZON.FallbackIntent. Amazon Lex returns three alternative intents with the following confidence scores: IntentA (0.70), IntentB (0.60), IntentC (0.50). The response from the RecognizeText operation would be:
    ///
    /// * AMAZON.FallbackIntent
    ///
    /// * IntentA
    ///
    /// * IntentB
    ///
    /// * IntentC
    /// This member is required.
    public var nluIntentConfidenceThreshold: Swift.Double?
    /// The Amazon Polly voice ID that Amazon Lex uses for voice interaction with the user.
    public var voiceSettings: LexModelsV2ClientTypes.VoiceSettings?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        description: Swift.String? = nil,
        localeId: Swift.String? = nil,
        nluIntentConfidenceThreshold: Swift.Double? = nil,
        voiceSettings: LexModelsV2ClientTypes.VoiceSettings? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.description = description
        self.localeId = localeId
        self.nluIntentConfidenceThreshold = nluIntentConfidenceThreshold
        self.voiceSettings = voiceSettings
    }
}

struct CreateBotLocaleInputBody: Swift.Equatable {
    let localeId: Swift.String?
    let description: Swift.String?
    let nluIntentConfidenceThreshold: Swift.Double?
    let voiceSettings: LexModelsV2ClientTypes.VoiceSettings?
}

extension CreateBotLocaleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case localeId
        case nluIntentConfidenceThreshold
        case voiceSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nluIntentConfidenceThresholdDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .nluIntentConfidenceThreshold)
        nluIntentConfidenceThreshold = nluIntentConfidenceThresholdDecoded
        let voiceSettingsDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.VoiceSettings.self, forKey: .voiceSettings)
        voiceSettings = voiceSettingsDecoded
    }
}

enum CreateBotLocaleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateBotLocaleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateBotLocaleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botLocaleStatus = output.botLocaleStatus
            self.botVersion = output.botVersion
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.localeId = output.localeId
            self.localeName = output.localeName
            self.nluIntentConfidenceThreshold = output.nluIntentConfidenceThreshold
            self.voiceSettings = output.voiceSettings
        } else {
            self.botId = nil
            self.botLocaleStatus = nil
            self.botVersion = nil
            self.creationDateTime = nil
            self.description = nil
            self.localeId = nil
            self.localeName = nil
            self.nluIntentConfidenceThreshold = nil
            self.voiceSettings = nil
        }
    }
}

public struct CreateBotLocaleOutputResponse: Swift.Equatable {
    /// The specified bot identifier.
    public var botId: Swift.String?
    /// The status of the bot. When the status is Creating the bot locale is being configured. When the status is Building Amazon Lex is building the bot for testing and use. If the status of the bot is ReadyExpressTesting, you can test the bot using the exact utterances specified in the bots' intents. When the bot is ready for full testing or to run, the status is Built. If there was a problem with building the bot, the status is Failed. If the bot was saved but not built, the status is NotBuilt.
    public var botLocaleStatus: LexModelsV2ClientTypes.BotLocaleStatus?
    /// The specified bot version.
    public var botVersion: Swift.String?
    /// A timestamp specifying the date and time that the bot locale was created.
    public var creationDateTime: ClientRuntime.Date?
    /// The specified description of the bot locale.
    public var description: Swift.String?
    /// The specified locale identifier.
    public var localeId: Swift.String?
    /// The specified locale name.
    public var localeName: Swift.String?
    /// The specified confidence threshold for inserting the AMAZON.FallbackIntent and AMAZON.KendraSearchIntent intents.
    public var nluIntentConfidenceThreshold: Swift.Double?
    /// The Amazon Polly voice ID that Amazon Lex uses for voice interaction with the user.
    public var voiceSettings: LexModelsV2ClientTypes.VoiceSettings?

    public init(
        botId: Swift.String? = nil,
        botLocaleStatus: LexModelsV2ClientTypes.BotLocaleStatus? = nil,
        botVersion: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        localeId: Swift.String? = nil,
        localeName: Swift.String? = nil,
        nluIntentConfidenceThreshold: Swift.Double? = nil,
        voiceSettings: LexModelsV2ClientTypes.VoiceSettings? = nil
    )
    {
        self.botId = botId
        self.botLocaleStatus = botLocaleStatus
        self.botVersion = botVersion
        self.creationDateTime = creationDateTime
        self.description = description
        self.localeId = localeId
        self.localeName = localeName
        self.nluIntentConfidenceThreshold = nluIntentConfidenceThreshold
        self.voiceSettings = voiceSettings
    }
}

struct CreateBotLocaleOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let botVersion: Swift.String?
    let localeName: Swift.String?
    let localeId: Swift.String?
    let description: Swift.String?
    let nluIntentConfidenceThreshold: Swift.Double?
    let voiceSettings: LexModelsV2ClientTypes.VoiceSettings?
    let botLocaleStatus: LexModelsV2ClientTypes.BotLocaleStatus?
    let creationDateTime: ClientRuntime.Date?
}

extension CreateBotLocaleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botLocaleStatus
        case botVersion
        case creationDateTime
        case description
        case localeId
        case localeName
        case nluIntentConfidenceThreshold
        case voiceSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeName)
        localeName = localeNameDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nluIntentConfidenceThresholdDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .nluIntentConfidenceThreshold)
        nluIntentConfidenceThreshold = nluIntentConfidenceThresholdDecoded
        let voiceSettingsDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.VoiceSettings.self, forKey: .voiceSettings)
        voiceSettings = voiceSettingsDecoded
        let botLocaleStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotLocaleStatus.self, forKey: .botLocaleStatus)
        botLocaleStatus = botLocaleStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
    }
}

enum CreateBotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateBotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateBotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botMembers = output.botMembers
            self.botName = output.botName
            self.botStatus = output.botStatus
            self.botTags = output.botTags
            self.botType = output.botType
            self.creationDateTime = output.creationDateTime
            self.dataPrivacy = output.dataPrivacy
            self.description = output.description
            self.idleSessionTTLInSeconds = output.idleSessionTTLInSeconds
            self.roleArn = output.roleArn
            self.testBotAliasTags = output.testBotAliasTags
        } else {
            self.botId = nil
            self.botMembers = nil
            self.botName = nil
            self.botStatus = nil
            self.botTags = nil
            self.botType = nil
            self.creationDateTime = nil
            self.dataPrivacy = nil
            self.description = nil
            self.idleSessionTTLInSeconds = nil
            self.roleArn = nil
            self.testBotAliasTags = nil
        }
    }
}

public struct CreateBotOutputResponse: Swift.Equatable {
    /// A unique identifier for a particular bot. You use this to identify the bot when you call other Amazon Lex API operations.
    public var botId: Swift.String?
    /// The list of bots in a network that was created.
    public var botMembers: [LexModelsV2ClientTypes.BotMember]?
    /// The name specified for the bot.
    public var botName: Swift.String?
    /// Shows the current status of the bot. The bot is first in the Creating status. Once the bot is read for use, it changes to the Available status. After the bot is created, you can use the DRAFT version of the bot.
    public var botStatus: LexModelsV2ClientTypes.BotStatus?
    /// A list of tags associated with the bot.
    public var botTags: [Swift.String:Swift.String]?
    /// The type of a bot that was created.
    public var botType: LexModelsV2ClientTypes.BotType?
    /// A timestamp indicating the date and time that the bot was created.
    public var creationDateTime: ClientRuntime.Date?
    /// The data privacy settings specified for the bot.
    public var dataPrivacy: LexModelsV2ClientTypes.DataPrivacy?
    /// The description specified for the bot.
    public var description: Swift.String?
    /// The session idle time specified for the bot.
    public var idleSessionTTLInSeconds: Swift.Int?
    /// The IAM role specified for the bot.
    public var roleArn: Swift.String?
    /// A list of tags associated with the test alias for the bot.
    public var testBotAliasTags: [Swift.String:Swift.String]?

    public init(
        botId: Swift.String? = nil,
        botMembers: [LexModelsV2ClientTypes.BotMember]? = nil,
        botName: Swift.String? = nil,
        botStatus: LexModelsV2ClientTypes.BotStatus? = nil,
        botTags: [Swift.String:Swift.String]? = nil,
        botType: LexModelsV2ClientTypes.BotType? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        dataPrivacy: LexModelsV2ClientTypes.DataPrivacy? = nil,
        description: Swift.String? = nil,
        idleSessionTTLInSeconds: Swift.Int? = nil,
        roleArn: Swift.String? = nil,
        testBotAliasTags: [Swift.String:Swift.String]? = nil
    )
    {
        self.botId = botId
        self.botMembers = botMembers
        self.botName = botName
        self.botStatus = botStatus
        self.botTags = botTags
        self.botType = botType
        self.creationDateTime = creationDateTime
        self.dataPrivacy = dataPrivacy
        self.description = description
        self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
        self.roleArn = roleArn
        self.testBotAliasTags = testBotAliasTags
    }
}

struct CreateBotOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let botName: Swift.String?
    let description: Swift.String?
    let roleArn: Swift.String?
    let dataPrivacy: LexModelsV2ClientTypes.DataPrivacy?
    let idleSessionTTLInSeconds: Swift.Int?
    let botStatus: LexModelsV2ClientTypes.BotStatus?
    let creationDateTime: ClientRuntime.Date?
    let botTags: [Swift.String:Swift.String]?
    let testBotAliasTags: [Swift.String:Swift.String]?
    let botType: LexModelsV2ClientTypes.BotType?
    let botMembers: [LexModelsV2ClientTypes.BotMember]?
}

extension CreateBotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botMembers
        case botName
        case botStatus
        case botTags
        case botType
        case creationDateTime
        case dataPrivacy
        case description
        case idleSessionTTLInSeconds
        case roleArn
        case testBotAliasTags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botName)
        botName = botNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let dataPrivacyDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.DataPrivacy.self, forKey: .dataPrivacy)
        dataPrivacy = dataPrivacyDecoded
        let idleSessionTTLInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleSessionTTLInSeconds)
        idleSessionTTLInSeconds = idleSessionTTLInSecondsDecoded
        let botStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotStatus.self, forKey: .botStatus)
        botStatus = botStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let botTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .botTags)
        var botTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let botTagsContainer = botTagsContainer {
            botTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in botTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    botTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        botTags = botTagsDecoded0
        let testBotAliasTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .testBotAliasTags)
        var testBotAliasTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let testBotAliasTagsContainer = testBotAliasTagsContainer {
            testBotAliasTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in testBotAliasTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    testBotAliasTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        testBotAliasTags = testBotAliasTagsDecoded0
        let botTypeDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotType.self, forKey: .botType)
        botType = botTypeDecoded
        let botMembersContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.BotMember?].self, forKey: .botMembers)
        var botMembersDecoded0:[LexModelsV2ClientTypes.BotMember]? = nil
        if let botMembersContainer = botMembersContainer {
            botMembersDecoded0 = [LexModelsV2ClientTypes.BotMember]()
            for structure0 in botMembersContainer {
                if let structure0 = structure0 {
                    botMembersDecoded0?.append(structure0)
                }
            }
        }
        botMembers = botMembersDecoded0
    }
}

extension CreateBotVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botVersionLocaleSpecification
        case description
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botVersionLocaleSpecification = botVersionLocaleSpecification {
            var botVersionLocaleSpecificationContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .botVersionLocaleSpecification)
            for (dictKey0, botVersionLocaleSpecification0) in botVersionLocaleSpecification {
                try botVersionLocaleSpecificationContainer.encode(botVersionLocaleSpecification0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension CreateBotVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botversions"
    }
}

public struct CreateBotVersionInput: Swift.Equatable {
    /// The identifier of the bot to create the version for.
    /// This member is required.
    public var botId: Swift.String?
    /// Specifies the locales that Amazon Lex adds to this version. You can choose the Draft version or any other previously published version for each locale. When you specify a source version, the locale data is copied from the source version to the new version.
    /// This member is required.
    public var botVersionLocaleSpecification: [Swift.String:LexModelsV2ClientTypes.BotVersionLocaleDetails]?
    /// A description of the version. Use the description to help identify the version in lists.
    public var description: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botVersionLocaleSpecification: [Swift.String:LexModelsV2ClientTypes.BotVersionLocaleDetails]? = nil,
        description: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botVersionLocaleSpecification = botVersionLocaleSpecification
        self.description = description
    }
}

struct CreateBotVersionInputBody: Swift.Equatable {
    let description: Swift.String?
    let botVersionLocaleSpecification: [Swift.String:LexModelsV2ClientTypes.BotVersionLocaleDetails]?
}

extension CreateBotVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botVersionLocaleSpecification
        case description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let botVersionLocaleSpecificationContainer = try containerValues.decodeIfPresent([Swift.String: LexModelsV2ClientTypes.BotVersionLocaleDetails?].self, forKey: .botVersionLocaleSpecification)
        var botVersionLocaleSpecificationDecoded0: [Swift.String:LexModelsV2ClientTypes.BotVersionLocaleDetails]? = nil
        if let botVersionLocaleSpecificationContainer = botVersionLocaleSpecificationContainer {
            botVersionLocaleSpecificationDecoded0 = [Swift.String:LexModelsV2ClientTypes.BotVersionLocaleDetails]()
            for (key0, botversionlocaledetails0) in botVersionLocaleSpecificationContainer {
                if let botversionlocaledetails0 = botversionlocaledetails0 {
                    botVersionLocaleSpecificationDecoded0?[key0] = botversionlocaledetails0
                }
            }
        }
        botVersionLocaleSpecification = botVersionLocaleSpecificationDecoded0
    }
}

enum CreateBotVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateBotVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateBotVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botStatus = output.botStatus
            self.botVersion = output.botVersion
            self.botVersionLocaleSpecification = output.botVersionLocaleSpecification
            self.creationDateTime = output.creationDateTime
            self.description = output.description
        } else {
            self.botId = nil
            self.botStatus = nil
            self.botVersion = nil
            self.botVersionLocaleSpecification = nil
            self.creationDateTime = nil
            self.description = nil
        }
    }
}

public struct CreateBotVersionOutputResponse: Swift.Equatable {
    /// The bot identifier specified in the request.
    public var botId: Swift.String?
    /// When you send a request to create or update a bot, Amazon Lex sets the status response element to Creating. After Amazon Lex builds the bot, it sets status to Available. If Amazon Lex can't build the bot, it sets status to Failed.
    public var botStatus: LexModelsV2ClientTypes.BotStatus?
    /// The version number assigned to the version.
    public var botVersion: Swift.String?
    /// The source versions used for each locale in the new version.
    public var botVersionLocaleSpecification: [Swift.String:LexModelsV2ClientTypes.BotVersionLocaleDetails]?
    /// A timestamp of the date and time that the version was created.
    public var creationDateTime: ClientRuntime.Date?
    /// The description of the version specified in the request.
    public var description: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botStatus: LexModelsV2ClientTypes.BotStatus? = nil,
        botVersion: Swift.String? = nil,
        botVersionLocaleSpecification: [Swift.String:LexModelsV2ClientTypes.BotVersionLocaleDetails]? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botStatus = botStatus
        self.botVersion = botVersion
        self.botVersionLocaleSpecification = botVersionLocaleSpecification
        self.creationDateTime = creationDateTime
        self.description = description
    }
}

struct CreateBotVersionOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let description: Swift.String?
    let botVersion: Swift.String?
    let botVersionLocaleSpecification: [Swift.String:LexModelsV2ClientTypes.BotVersionLocaleDetails]?
    let botStatus: LexModelsV2ClientTypes.BotStatus?
    let creationDateTime: ClientRuntime.Date?
}

extension CreateBotVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botStatus
        case botVersion
        case botVersionLocaleSpecification
        case creationDateTime
        case description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let botVersionLocaleSpecificationContainer = try containerValues.decodeIfPresent([Swift.String: LexModelsV2ClientTypes.BotVersionLocaleDetails?].self, forKey: .botVersionLocaleSpecification)
        var botVersionLocaleSpecificationDecoded0: [Swift.String:LexModelsV2ClientTypes.BotVersionLocaleDetails]? = nil
        if let botVersionLocaleSpecificationContainer = botVersionLocaleSpecificationContainer {
            botVersionLocaleSpecificationDecoded0 = [Swift.String:LexModelsV2ClientTypes.BotVersionLocaleDetails]()
            for (key0, botversionlocaledetails0) in botVersionLocaleSpecificationContainer {
                if let botversionlocaledetails0 = botversionlocaledetails0 {
                    botVersionLocaleSpecificationDecoded0?[key0] = botversionlocaledetails0
                }
            }
        }
        botVersionLocaleSpecification = botVersionLocaleSpecificationDecoded0
        let botStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotStatus.self, forKey: .botStatus)
        botStatus = botStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
    }
}

extension CreateExportInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateExportInput(fileFormat: \(Swift.String(describing: fileFormat)), resourceSpecification: \(Swift.String(describing: resourceSpecification)), filePassword: \"CONTENT_REDACTED\")"}
}

extension CreateExportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileFormat
        case filePassword
        case resourceSpecification
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileFormat = self.fileFormat {
            try encodeContainer.encode(fileFormat.rawValue, forKey: .fileFormat)
        }
        if let filePassword = self.filePassword {
            try encodeContainer.encode(filePassword, forKey: .filePassword)
        }
        if let resourceSpecification = self.resourceSpecification {
            try encodeContainer.encode(resourceSpecification, forKey: .resourceSpecification)
        }
    }
}

extension CreateExportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/exports"
    }
}

public struct CreateExportInput: Swift.Equatable {
    /// The file format of the bot or bot locale definition files.
    /// This member is required.
    public var fileFormat: LexModelsV2ClientTypes.ImportExportFileFormat?
    /// An password to use to encrypt the exported archive. Using a password is optional, but you should encrypt the archive to protect the data in transit between Amazon Lex and your local computer.
    public var filePassword: Swift.String?
    /// Specifies the type of resource to export, either a bot or a bot locale. You can only specify one type of resource to export.
    /// This member is required.
    public var resourceSpecification: LexModelsV2ClientTypes.ExportResourceSpecification?

    public init(
        fileFormat: LexModelsV2ClientTypes.ImportExportFileFormat? = nil,
        filePassword: Swift.String? = nil,
        resourceSpecification: LexModelsV2ClientTypes.ExportResourceSpecification? = nil
    )
    {
        self.fileFormat = fileFormat
        self.filePassword = filePassword
        self.resourceSpecification = resourceSpecification
    }
}

struct CreateExportInputBody: Swift.Equatable {
    let resourceSpecification: LexModelsV2ClientTypes.ExportResourceSpecification?
    let fileFormat: LexModelsV2ClientTypes.ImportExportFileFormat?
    let filePassword: Swift.String?
}

extension CreateExportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileFormat
        case filePassword
        case resourceSpecification
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceSpecificationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ExportResourceSpecification.self, forKey: .resourceSpecification)
        resourceSpecification = resourceSpecificationDecoded
        let fileFormatDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ImportExportFileFormat.self, forKey: .fileFormat)
        fileFormat = fileFormatDecoded
        let filePasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePassword)
        filePassword = filePasswordDecoded
    }
}

enum CreateExportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateExportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateExportOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationDateTime = output.creationDateTime
            self.exportId = output.exportId
            self.exportStatus = output.exportStatus
            self.fileFormat = output.fileFormat
            self.resourceSpecification = output.resourceSpecification
        } else {
            self.creationDateTime = nil
            self.exportId = nil
            self.exportStatus = nil
            self.fileFormat = nil
            self.resourceSpecification = nil
        }
    }
}

public struct CreateExportOutputResponse: Swift.Equatable {
    /// The date and time that the request to export a bot was created.
    public var creationDateTime: ClientRuntime.Date?
    /// An identifier for a specific request to create an export.
    public var exportId: Swift.String?
    /// The status of the export. When the status is Completed, you can use the [DescribeExport](https://docs.aws.amazon.com/lexv2/latest/APIReference/API_DescribeExport.html) operation to get the pre-signed S3 URL link to your exported bot or bot locale.
    public var exportStatus: LexModelsV2ClientTypes.ExportStatus?
    /// The file format used for the bot or bot locale definition files.
    public var fileFormat: LexModelsV2ClientTypes.ImportExportFileFormat?
    /// A description of the type of resource that was exported, either a bot or a bot locale.
    public var resourceSpecification: LexModelsV2ClientTypes.ExportResourceSpecification?

    public init(
        creationDateTime: ClientRuntime.Date? = nil,
        exportId: Swift.String? = nil,
        exportStatus: LexModelsV2ClientTypes.ExportStatus? = nil,
        fileFormat: LexModelsV2ClientTypes.ImportExportFileFormat? = nil,
        resourceSpecification: LexModelsV2ClientTypes.ExportResourceSpecification? = nil
    )
    {
        self.creationDateTime = creationDateTime
        self.exportId = exportId
        self.exportStatus = exportStatus
        self.fileFormat = fileFormat
        self.resourceSpecification = resourceSpecification
    }
}

struct CreateExportOutputResponseBody: Swift.Equatable {
    let exportId: Swift.String?
    let resourceSpecification: LexModelsV2ClientTypes.ExportResourceSpecification?
    let fileFormat: LexModelsV2ClientTypes.ImportExportFileFormat?
    let exportStatus: LexModelsV2ClientTypes.ExportStatus?
    let creationDateTime: ClientRuntime.Date?
}

extension CreateExportOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case exportId
        case exportStatus
        case fileFormat
        case resourceSpecification
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportId)
        exportId = exportIdDecoded
        let resourceSpecificationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ExportResourceSpecification.self, forKey: .resourceSpecification)
        resourceSpecification = resourceSpecificationDecoded
        let fileFormatDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ImportExportFileFormat.self, forKey: .fileFormat)
        fileFormat = fileFormatDecoded
        let exportStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ExportStatus.self, forKey: .exportStatus)
        exportStatus = exportStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
    }
}

extension CreateIntentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case dialogCodeHook
        case fulfillmentCodeHook
        case initialResponseSetting
        case inputContexts
        case intentClosingSetting
        case intentConfirmationSetting
        case intentName
        case kendraConfiguration
        case outputContexts
        case parentIntentSignature
        case sampleUtterances
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dialogCodeHook = self.dialogCodeHook {
            try encodeContainer.encode(dialogCodeHook, forKey: .dialogCodeHook)
        }
        if let fulfillmentCodeHook = self.fulfillmentCodeHook {
            try encodeContainer.encode(fulfillmentCodeHook, forKey: .fulfillmentCodeHook)
        }
        if let initialResponseSetting = self.initialResponseSetting {
            try encodeContainer.encode(initialResponseSetting, forKey: .initialResponseSetting)
        }
        if let inputContexts = inputContexts {
            var inputContextsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputContexts)
            for inputcontext0 in inputContexts {
                try inputContextsContainer.encode(inputcontext0)
            }
        }
        if let intentClosingSetting = self.intentClosingSetting {
            try encodeContainer.encode(intentClosingSetting, forKey: .intentClosingSetting)
        }
        if let intentConfirmationSetting = self.intentConfirmationSetting {
            try encodeContainer.encode(intentConfirmationSetting, forKey: .intentConfirmationSetting)
        }
        if let intentName = self.intentName {
            try encodeContainer.encode(intentName, forKey: .intentName)
        }
        if let kendraConfiguration = self.kendraConfiguration {
            try encodeContainer.encode(kendraConfiguration, forKey: .kendraConfiguration)
        }
        if let outputContexts = outputContexts {
            var outputContextsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputContexts)
            for outputcontext0 in outputContexts {
                try outputContextsContainer.encode(outputcontext0)
            }
        }
        if let parentIntentSignature = self.parentIntentSignature {
            try encodeContainer.encode(parentIntentSignature, forKey: .parentIntentSignature)
        }
        if let sampleUtterances = sampleUtterances {
            var sampleUtterancesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sampleUtterances)
            for sampleutterance0 in sampleUtterances {
                try sampleUtterancesContainer.encode(sampleutterance0)
            }
        }
    }
}

extension CreateIntentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botVersion = botVersion else {
            return nil
        }
        guard let localeId = localeId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botversions/\(botVersion.urlPercentEncoding())/botlocales/\(localeId.urlPercentEncoding())/intents"
    }
}

public struct CreateIntentInput: Swift.Equatable {
    /// The identifier of the bot associated with this intent.
    /// This member is required.
    public var botId: Swift.String?
    /// The version of the bot associated with this intent.
    /// This member is required.
    public var botVersion: Swift.String?
    /// A description of the intent. Use the description to help identify the intent in lists.
    public var description: Swift.String?
    /// Specifies that Amazon Lex invokes the alias Lambda function for each user input. You can invoke this Lambda function to personalize user interaction. For example, suppose that your bot determines that the user's name is John. You Lambda function might retrieve John's information from a backend database and prepopulate some of the values. For example, if you find that John is gluten intolerant, you might set the corresponding intent slot, glutenIntolerant to true. You might find John's phone number and set the corresponding session attribute.
    public var dialogCodeHook: LexModelsV2ClientTypes.DialogCodeHookSettings?
    /// Specifies that Amazon Lex invokes the alias Lambda function when the intent is ready for fulfillment. You can invoke this function to complete the bot's transaction with the user. For example, in a pizza ordering bot, the Lambda function can look up the closest pizza restaurant to the customer's location and then place an order on the customer's behalf.
    public var fulfillmentCodeHook: LexModelsV2ClientTypes.FulfillmentCodeHookSettings?
    /// Configuration settings for the response that is sent to the user at the beginning of a conversation, before eliciting slot values.
    public var initialResponseSetting: LexModelsV2ClientTypes.InitialResponseSetting?
    /// A list of contexts that must be active for this intent to be considered by Amazon Lex. When an intent has an input context list, Amazon Lex only considers using the intent in an interaction with the user when the specified contexts are included in the active context list for the session. If the contexts are not active, then Amazon Lex will not use the intent. A context can be automatically activated using the outputContexts property or it can be set at runtime. For example, if there are two intents with different input contexts that respond to the same utterances, only the intent with the active context will respond. An intent may have up to 5 input contexts. If an intent has multiple input contexts, all of the contexts must be active to consider the intent.
    public var inputContexts: [LexModelsV2ClientTypes.InputContext]?
    /// Sets the response that Amazon Lex sends to the user when the intent is closed.
    public var intentClosingSetting: LexModelsV2ClientTypes.IntentClosingSetting?
    /// Provides prompts that Amazon Lex sends to the user to confirm the completion of an intent. If the user answers "no," the settings contain a statement that is sent to the user to end the intent.
    public var intentConfirmationSetting: LexModelsV2ClientTypes.IntentConfirmationSetting?
    /// The name of the intent. Intent names must be unique in the locale that contains the intent and cannot match the name of any built-in intent.
    /// This member is required.
    public var intentName: Swift.String?
    /// Configuration information required to use the AMAZON.KendraSearchIntent intent to connect to an Amazon Kendra index. The AMAZON.KendraSearchIntent intent is called when Amazon Lex can't determine another intent to invoke.
    public var kendraConfiguration: LexModelsV2ClientTypes.KendraConfiguration?
    /// The identifier of the language and locale where this intent is used. All of the bots, slot types, and slots used by the intent must have the same locale. For more information, see [Supported languages](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html).
    /// This member is required.
    public var localeId: Swift.String?
    /// A lists of contexts that the intent activates when it is fulfilled. You can use an output context to indicate the intents that Amazon Lex should consider for the next turn of the conversation with a customer. When you use the outputContextsList property, all of the contexts specified in the list are activated when the intent is fulfilled. You can set up to 10 output contexts. You can also set the number of conversation turns that the context should be active, or the length of time that the context should be active.
    public var outputContexts: [LexModelsV2ClientTypes.OutputContext]?
    /// A unique identifier for the built-in intent to base this intent on.
    public var parentIntentSignature: Swift.String?
    /// An array of strings that a user might say to signal the intent. For example, "I want a pizza", or "I want a {PizzaSize} pizza". In an utterance, slot names are enclosed in curly braces ("{", "}") to indicate where they should be displayed in the utterance shown to the user..
    public var sampleUtterances: [LexModelsV2ClientTypes.SampleUtterance]?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        description: Swift.String? = nil,
        dialogCodeHook: LexModelsV2ClientTypes.DialogCodeHookSettings? = nil,
        fulfillmentCodeHook: LexModelsV2ClientTypes.FulfillmentCodeHookSettings? = nil,
        initialResponseSetting: LexModelsV2ClientTypes.InitialResponseSetting? = nil,
        inputContexts: [LexModelsV2ClientTypes.InputContext]? = nil,
        intentClosingSetting: LexModelsV2ClientTypes.IntentClosingSetting? = nil,
        intentConfirmationSetting: LexModelsV2ClientTypes.IntentConfirmationSetting? = nil,
        intentName: Swift.String? = nil,
        kendraConfiguration: LexModelsV2ClientTypes.KendraConfiguration? = nil,
        localeId: Swift.String? = nil,
        outputContexts: [LexModelsV2ClientTypes.OutputContext]? = nil,
        parentIntentSignature: Swift.String? = nil,
        sampleUtterances: [LexModelsV2ClientTypes.SampleUtterance]? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.description = description
        self.dialogCodeHook = dialogCodeHook
        self.fulfillmentCodeHook = fulfillmentCodeHook
        self.initialResponseSetting = initialResponseSetting
        self.inputContexts = inputContexts
        self.intentClosingSetting = intentClosingSetting
        self.intentConfirmationSetting = intentConfirmationSetting
        self.intentName = intentName
        self.kendraConfiguration = kendraConfiguration
        self.localeId = localeId
        self.outputContexts = outputContexts
        self.parentIntentSignature = parentIntentSignature
        self.sampleUtterances = sampleUtterances
    }
}

struct CreateIntentInputBody: Swift.Equatable {
    let intentName: Swift.String?
    let description: Swift.String?
    let parentIntentSignature: Swift.String?
    let sampleUtterances: [LexModelsV2ClientTypes.SampleUtterance]?
    let dialogCodeHook: LexModelsV2ClientTypes.DialogCodeHookSettings?
    let fulfillmentCodeHook: LexModelsV2ClientTypes.FulfillmentCodeHookSettings?
    let intentConfirmationSetting: LexModelsV2ClientTypes.IntentConfirmationSetting?
    let intentClosingSetting: LexModelsV2ClientTypes.IntentClosingSetting?
    let inputContexts: [LexModelsV2ClientTypes.InputContext]?
    let outputContexts: [LexModelsV2ClientTypes.OutputContext]?
    let kendraConfiguration: LexModelsV2ClientTypes.KendraConfiguration?
    let initialResponseSetting: LexModelsV2ClientTypes.InitialResponseSetting?
}

extension CreateIntentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case dialogCodeHook
        case fulfillmentCodeHook
        case initialResponseSetting
        case inputContexts
        case intentClosingSetting
        case intentConfirmationSetting
        case intentName
        case kendraConfiguration
        case outputContexts
        case parentIntentSignature
        case sampleUtterances
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intentName)
        intentName = intentNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parentIntentSignatureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentIntentSignature)
        parentIntentSignature = parentIntentSignatureDecoded
        let sampleUtterancesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.SampleUtterance?].self, forKey: .sampleUtterances)
        var sampleUtterancesDecoded0:[LexModelsV2ClientTypes.SampleUtterance]? = nil
        if let sampleUtterancesContainer = sampleUtterancesContainer {
            sampleUtterancesDecoded0 = [LexModelsV2ClientTypes.SampleUtterance]()
            for structure0 in sampleUtterancesContainer {
                if let structure0 = structure0 {
                    sampleUtterancesDecoded0?.append(structure0)
                }
            }
        }
        sampleUtterances = sampleUtterancesDecoded0
        let dialogCodeHookDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.DialogCodeHookSettings.self, forKey: .dialogCodeHook)
        dialogCodeHook = dialogCodeHookDecoded
        let fulfillmentCodeHookDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.FulfillmentCodeHookSettings.self, forKey: .fulfillmentCodeHook)
        fulfillmentCodeHook = fulfillmentCodeHookDecoded
        let intentConfirmationSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.IntentConfirmationSetting.self, forKey: .intentConfirmationSetting)
        intentConfirmationSetting = intentConfirmationSettingDecoded
        let intentClosingSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.IntentClosingSetting.self, forKey: .intentClosingSetting)
        intentClosingSetting = intentClosingSettingDecoded
        let inputContextsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.InputContext?].self, forKey: .inputContexts)
        var inputContextsDecoded0:[LexModelsV2ClientTypes.InputContext]? = nil
        if let inputContextsContainer = inputContextsContainer {
            inputContextsDecoded0 = [LexModelsV2ClientTypes.InputContext]()
            for structure0 in inputContextsContainer {
                if let structure0 = structure0 {
                    inputContextsDecoded0?.append(structure0)
                }
            }
        }
        inputContexts = inputContextsDecoded0
        let outputContextsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.OutputContext?].self, forKey: .outputContexts)
        var outputContextsDecoded0:[LexModelsV2ClientTypes.OutputContext]? = nil
        if let outputContextsContainer = outputContextsContainer {
            outputContextsDecoded0 = [LexModelsV2ClientTypes.OutputContext]()
            for structure0 in outputContextsContainer {
                if let structure0 = structure0 {
                    outputContextsDecoded0?.append(structure0)
                }
            }
        }
        outputContexts = outputContextsDecoded0
        let kendraConfigurationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.KendraConfiguration.self, forKey: .kendraConfiguration)
        kendraConfiguration = kendraConfigurationDecoded
        let initialResponseSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.InitialResponseSetting.self, forKey: .initialResponseSetting)
        initialResponseSetting = initialResponseSettingDecoded
    }
}

enum CreateIntentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateIntentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateIntentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.dialogCodeHook = output.dialogCodeHook
            self.fulfillmentCodeHook = output.fulfillmentCodeHook
            self.initialResponseSetting = output.initialResponseSetting
            self.inputContexts = output.inputContexts
            self.intentClosingSetting = output.intentClosingSetting
            self.intentConfirmationSetting = output.intentConfirmationSetting
            self.intentId = output.intentId
            self.intentName = output.intentName
            self.kendraConfiguration = output.kendraConfiguration
            self.localeId = output.localeId
            self.outputContexts = output.outputContexts
            self.parentIntentSignature = output.parentIntentSignature
            self.sampleUtterances = output.sampleUtterances
        } else {
            self.botId = nil
            self.botVersion = nil
            self.creationDateTime = nil
            self.description = nil
            self.dialogCodeHook = nil
            self.fulfillmentCodeHook = nil
            self.initialResponseSetting = nil
            self.inputContexts = nil
            self.intentClosingSetting = nil
            self.intentConfirmationSetting = nil
            self.intentId = nil
            self.intentName = nil
            self.kendraConfiguration = nil
            self.localeId = nil
            self.outputContexts = nil
            self.parentIntentSignature = nil
            self.sampleUtterances = nil
        }
    }
}

public struct CreateIntentOutputResponse: Swift.Equatable {
    /// The identifier of the bot associated with the intent.
    public var botId: Swift.String?
    /// The version of the bot associated with the intent.
    public var botVersion: Swift.String?
    /// A timestamp of the date and time that the intent was created.
    public var creationDateTime: ClientRuntime.Date?
    /// The description specified for the intent.
    public var description: Swift.String?
    /// The dialog Lambda function specified for the intent.
    public var dialogCodeHook: LexModelsV2ClientTypes.DialogCodeHookSettings?
    /// The fulfillment Lambda function specified for the intent.
    public var fulfillmentCodeHook: LexModelsV2ClientTypes.FulfillmentCodeHookSettings?
    /// Configuration settings for the response that is sent to the user at the beginning of a conversation, before eliciting slot values.
    public var initialResponseSetting: LexModelsV2ClientTypes.InitialResponseSetting?
    /// The list of input contexts specified for the intent.
    public var inputContexts: [LexModelsV2ClientTypes.InputContext]?
    /// The closing setting specified for the intent.
    public var intentClosingSetting: LexModelsV2ClientTypes.IntentClosingSetting?
    /// The confirmation setting specified for the intent.
    public var intentConfirmationSetting: LexModelsV2ClientTypes.IntentConfirmationSetting?
    /// A unique identifier for the intent.
    public var intentId: Swift.String?
    /// The name specified for the intent.
    public var intentName: Swift.String?
    /// Configuration for searching a Amazon Kendra index specified for the intent.
    public var kendraConfiguration: LexModelsV2ClientTypes.KendraConfiguration?
    /// The locale that the intent is specified to use.
    public var localeId: Swift.String?
    /// The list of output contexts specified for the intent.
    public var outputContexts: [LexModelsV2ClientTypes.OutputContext]?
    /// The signature of the parent intent specified for the intent.
    public var parentIntentSignature: Swift.String?
    /// The sample utterances specified for the intent.
    public var sampleUtterances: [LexModelsV2ClientTypes.SampleUtterance]?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        dialogCodeHook: LexModelsV2ClientTypes.DialogCodeHookSettings? = nil,
        fulfillmentCodeHook: LexModelsV2ClientTypes.FulfillmentCodeHookSettings? = nil,
        initialResponseSetting: LexModelsV2ClientTypes.InitialResponseSetting? = nil,
        inputContexts: [LexModelsV2ClientTypes.InputContext]? = nil,
        intentClosingSetting: LexModelsV2ClientTypes.IntentClosingSetting? = nil,
        intentConfirmationSetting: LexModelsV2ClientTypes.IntentConfirmationSetting? = nil,
        intentId: Swift.String? = nil,
        intentName: Swift.String? = nil,
        kendraConfiguration: LexModelsV2ClientTypes.KendraConfiguration? = nil,
        localeId: Swift.String? = nil,
        outputContexts: [LexModelsV2ClientTypes.OutputContext]? = nil,
        parentIntentSignature: Swift.String? = nil,
        sampleUtterances: [LexModelsV2ClientTypes.SampleUtterance]? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.creationDateTime = creationDateTime
        self.description = description
        self.dialogCodeHook = dialogCodeHook
        self.fulfillmentCodeHook = fulfillmentCodeHook
        self.initialResponseSetting = initialResponseSetting
        self.inputContexts = inputContexts
        self.intentClosingSetting = intentClosingSetting
        self.intentConfirmationSetting = intentConfirmationSetting
        self.intentId = intentId
        self.intentName = intentName
        self.kendraConfiguration = kendraConfiguration
        self.localeId = localeId
        self.outputContexts = outputContexts
        self.parentIntentSignature = parentIntentSignature
        self.sampleUtterances = sampleUtterances
    }
}

struct CreateIntentOutputResponseBody: Swift.Equatable {
    let intentId: Swift.String?
    let intentName: Swift.String?
    let description: Swift.String?
    let parentIntentSignature: Swift.String?
    let sampleUtterances: [LexModelsV2ClientTypes.SampleUtterance]?
    let dialogCodeHook: LexModelsV2ClientTypes.DialogCodeHookSettings?
    let fulfillmentCodeHook: LexModelsV2ClientTypes.FulfillmentCodeHookSettings?
    let intentConfirmationSetting: LexModelsV2ClientTypes.IntentConfirmationSetting?
    let intentClosingSetting: LexModelsV2ClientTypes.IntentClosingSetting?
    let inputContexts: [LexModelsV2ClientTypes.InputContext]?
    let outputContexts: [LexModelsV2ClientTypes.OutputContext]?
    let kendraConfiguration: LexModelsV2ClientTypes.KendraConfiguration?
    let botId: Swift.String?
    let botVersion: Swift.String?
    let localeId: Swift.String?
    let creationDateTime: ClientRuntime.Date?
    let initialResponseSetting: LexModelsV2ClientTypes.InitialResponseSetting?
}

extension CreateIntentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botVersion
        case creationDateTime
        case description
        case dialogCodeHook
        case fulfillmentCodeHook
        case initialResponseSetting
        case inputContexts
        case intentClosingSetting
        case intentConfirmationSetting
        case intentId
        case intentName
        case kendraConfiguration
        case localeId
        case outputContexts
        case parentIntentSignature
        case sampleUtterances
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intentId)
        intentId = intentIdDecoded
        let intentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intentName)
        intentName = intentNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parentIntentSignatureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentIntentSignature)
        parentIntentSignature = parentIntentSignatureDecoded
        let sampleUtterancesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.SampleUtterance?].self, forKey: .sampleUtterances)
        var sampleUtterancesDecoded0:[LexModelsV2ClientTypes.SampleUtterance]? = nil
        if let sampleUtterancesContainer = sampleUtterancesContainer {
            sampleUtterancesDecoded0 = [LexModelsV2ClientTypes.SampleUtterance]()
            for structure0 in sampleUtterancesContainer {
                if let structure0 = structure0 {
                    sampleUtterancesDecoded0?.append(structure0)
                }
            }
        }
        sampleUtterances = sampleUtterancesDecoded0
        let dialogCodeHookDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.DialogCodeHookSettings.self, forKey: .dialogCodeHook)
        dialogCodeHook = dialogCodeHookDecoded
        let fulfillmentCodeHookDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.FulfillmentCodeHookSettings.self, forKey: .fulfillmentCodeHook)
        fulfillmentCodeHook = fulfillmentCodeHookDecoded
        let intentConfirmationSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.IntentConfirmationSetting.self, forKey: .intentConfirmationSetting)
        intentConfirmationSetting = intentConfirmationSettingDecoded
        let intentClosingSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.IntentClosingSetting.self, forKey: .intentClosingSetting)
        intentClosingSetting = intentClosingSettingDecoded
        let inputContextsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.InputContext?].self, forKey: .inputContexts)
        var inputContextsDecoded0:[LexModelsV2ClientTypes.InputContext]? = nil
        if let inputContextsContainer = inputContextsContainer {
            inputContextsDecoded0 = [LexModelsV2ClientTypes.InputContext]()
            for structure0 in inputContextsContainer {
                if let structure0 = structure0 {
                    inputContextsDecoded0?.append(structure0)
                }
            }
        }
        inputContexts = inputContextsDecoded0
        let outputContextsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.OutputContext?].self, forKey: .outputContexts)
        var outputContextsDecoded0:[LexModelsV2ClientTypes.OutputContext]? = nil
        if let outputContextsContainer = outputContextsContainer {
            outputContextsDecoded0 = [LexModelsV2ClientTypes.OutputContext]()
            for structure0 in outputContextsContainer {
                if let structure0 = structure0 {
                    outputContextsDecoded0?.append(structure0)
                }
            }
        }
        outputContexts = outputContextsDecoded0
        let kendraConfigurationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.KendraConfiguration.self, forKey: .kendraConfiguration)
        kendraConfiguration = kendraConfigurationDecoded
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let initialResponseSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.InitialResponseSetting.self, forKey: .initialResponseSetting)
        initialResponseSetting = initialResponseSettingDecoded
    }
}

extension CreateResourcePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

extension CreateResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/policy/\(resourceArn.urlPercentEncoding())"
    }
}

public struct CreateResourcePolicyInput: Swift.Equatable {
    /// A resource policy to add to the resource. The policy is a JSON structure that contains one or more statements that define the policy. The policy must follow the IAM syntax. For more information about the contents of a JSON policy document, see [ IAM JSON policy reference ](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies.html). If the policy isn't valid, Amazon Lex returns a validation exception.
    /// This member is required.
    public var policy: Swift.String?
    /// The Amazon Resource Name (ARN) of the bot or bot alias that the resource policy is attached to.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        policy: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.policy = policy
        self.resourceArn = resourceArn
    }
}

struct CreateResourcePolicyInputBody: Swift.Equatable {
    let policy: Swift.String?
}

extension CreateResourcePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum CreateResourcePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateResourcePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateResourcePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceArn = output.resourceArn
            self.revisionId = output.revisionId
        } else {
            self.resourceArn = nil
            self.revisionId = nil
        }
    }
}

public struct CreateResourcePolicyOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the bot or bot alias that the resource policy was attached to.
    public var resourceArn: Swift.String?
    /// The current revision of the resource policy. Use the revision ID to make sure that you are updating the most current version of a resource policy when you add a policy statement to a resource, delete a resource, or update a resource.
    public var revisionId: Swift.String?

    public init(
        resourceArn: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
        self.revisionId = revisionId
    }
}

struct CreateResourcePolicyOutputResponseBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let revisionId: Swift.String?
}

extension CreateResourcePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case revisionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension CreateResourcePolicyStatementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case condition
        case effect
        case principal
        case statementId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            var actionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .action)
            for operation0 in action {
                try actionContainer.encode(operation0)
            }
        }
        if let condition = condition {
            var conditionContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .condition)
            for (dictKey0, conditionMap0) in condition {
                var conditionMap0Container = conditionContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key(stringValue: dictKey0))
                for (dictKey1, conditionKeyValueMap1) in conditionMap0 {
                    try conditionMap0Container.encode(conditionKeyValueMap1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
        if let effect = self.effect {
            try encodeContainer.encode(effect.rawValue, forKey: .effect)
        }
        if let principal = principal {
            var principalContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principal)
            for principal0 in principal {
                try principalContainer.encode(principal0)
            }
        }
        if let statementId = self.statementId {
            try encodeContainer.encode(statementId, forKey: .statementId)
        }
    }
}

extension CreateResourcePolicyStatementInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let expectedRevisionId = expectedRevisionId {
                let expectedRevisionIdQueryItem = ClientRuntime.URLQueryItem(name: "expectedRevisionId".urlPercentEncoding(), value: Swift.String(expectedRevisionId).urlPercentEncoding())
                items.append(expectedRevisionIdQueryItem)
            }
            return items
        }
    }
}

extension CreateResourcePolicyStatementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/policy/\(resourceArn.urlPercentEncoding())/statements"
    }
}

public struct CreateResourcePolicyStatementInput: Swift.Equatable {
    /// The Amazon Lex action that this policy either allows or denies. The action must apply to the resource type of the specified ARN. For more information, see [ Actions, resources, and condition keys for Amazon Lex V2](https://docs.aws.amazon.com/service-authorization/latest/reference/list_amazonlexv2.html).
    /// This member is required.
    public var action: [Swift.String]?
    /// Specifies a condition when the policy is in effect. If the principal of the policy is a service principal, you must provide two condition blocks, one with a SourceAccount global condition key and one with a SourceArn global condition key. For more information, see [IAM JSON policy elements: Condition ](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_condition.html).
    public var condition: [Swift.String:[Swift.String:Swift.String]]?
    /// Determines whether the statement allows or denies access to the resource.
    /// This member is required.
    public var effect: LexModelsV2ClientTypes.Effect?
    /// The identifier of the revision of the policy to edit. If this revision ID doesn't match the current revision ID, Amazon Lex throws an exception. If you don't specify a revision, Amazon Lex overwrites the contents of the policy with the new values.
    public var expectedRevisionId: Swift.String?
    /// An IAM principal, such as an IAM user, IAM role, or Amazon Web Services services that is allowed or denied access to a resource. For more information, see [Amazon Web Services JSON policy elements: Principal](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_principal.html).
    /// This member is required.
    public var principal: [LexModelsV2ClientTypes.Principal]?
    /// The Amazon Resource Name (ARN) of the bot or bot alias that the resource policy is attached to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The name of the statement. The ID is the same as the Sid IAM property. The statement name must be unique within the policy. For more information, see [IAM JSON policy elements: Sid](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_sid.html).
    /// This member is required.
    public var statementId: Swift.String?

    public init(
        action: [Swift.String]? = nil,
        condition: [Swift.String:[Swift.String:Swift.String]]? = nil,
        effect: LexModelsV2ClientTypes.Effect? = nil,
        expectedRevisionId: Swift.String? = nil,
        principal: [LexModelsV2ClientTypes.Principal]? = nil,
        resourceArn: Swift.String? = nil,
        statementId: Swift.String? = nil
    )
    {
        self.action = action
        self.condition = condition
        self.effect = effect
        self.expectedRevisionId = expectedRevisionId
        self.principal = principal
        self.resourceArn = resourceArn
        self.statementId = statementId
    }
}

struct CreateResourcePolicyStatementInputBody: Swift.Equatable {
    let statementId: Swift.String?
    let effect: LexModelsV2ClientTypes.Effect?
    let principal: [LexModelsV2ClientTypes.Principal]?
    let action: [Swift.String]?
    let condition: [Swift.String:[Swift.String:Swift.String]]?
}

extension CreateResourcePolicyStatementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case condition
        case effect
        case principal
        case statementId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementId)
        statementId = statementIdDecoded
        let effectDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.Effect.self, forKey: .effect)
        effect = effectDecoded
        let principalContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.Principal?].self, forKey: .principal)
        var principalDecoded0:[LexModelsV2ClientTypes.Principal]? = nil
        if let principalContainer = principalContainer {
            principalDecoded0 = [LexModelsV2ClientTypes.Principal]()
            for structure0 in principalContainer {
                if let structure0 = structure0 {
                    principalDecoded0?.append(structure0)
                }
            }
        }
        principal = principalDecoded0
        let actionContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .action)
        var actionDecoded0:[Swift.String]? = nil
        if let actionContainer = actionContainer {
            actionDecoded0 = [Swift.String]()
            for string0 in actionContainer {
                if let string0 = string0 {
                    actionDecoded0?.append(string0)
                }
            }
        }
        action = actionDecoded0
        let conditionContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .condition)
        var conditionDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let conditionContainer = conditionContainer {
            conditionDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, conditionkeyvaluemap0) in conditionContainer {
                var conditionkeyvaluemap0Decoded0: [Swift.String: Swift.String]? = nil
                if let conditionkeyvaluemap0 = conditionkeyvaluemap0 {
                    conditionkeyvaluemap0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, conditionvalue1) in conditionkeyvaluemap0 {
                        if let conditionvalue1 = conditionvalue1 {
                            conditionkeyvaluemap0Decoded0?[key1] = conditionvalue1
                        }
                    }
                }
                conditionDecoded0?[key0] = conditionkeyvaluemap0Decoded0
            }
        }
        condition = conditionDecoded0
    }
}

enum CreateResourcePolicyStatementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateResourcePolicyStatementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateResourcePolicyStatementOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceArn = output.resourceArn
            self.revisionId = output.revisionId
        } else {
            self.resourceArn = nil
            self.revisionId = nil
        }
    }
}

public struct CreateResourcePolicyStatementOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the bot or bot alias that the resource policy is attached to.
    public var resourceArn: Swift.String?
    /// The current revision of the resource policy. Use the revision ID to make sure that you are updating the most current version of a resource policy when you add a policy statement to a resource, delete a resource, or update a resource.
    public var revisionId: Swift.String?

    public init(
        resourceArn: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
        self.revisionId = revisionId
    }
}

struct CreateResourcePolicyStatementOutputResponseBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let revisionId: Swift.String?
}

extension CreateResourcePolicyStatementOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case revisionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension CreateSlotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case multipleValuesSetting
        case obfuscationSetting
        case slotName
        case slotTypeId
        case subSlotSetting
        case valueElicitationSetting
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let multipleValuesSetting = self.multipleValuesSetting {
            try encodeContainer.encode(multipleValuesSetting, forKey: .multipleValuesSetting)
        }
        if let obfuscationSetting = self.obfuscationSetting {
            try encodeContainer.encode(obfuscationSetting, forKey: .obfuscationSetting)
        }
        if let slotName = self.slotName {
            try encodeContainer.encode(slotName, forKey: .slotName)
        }
        if let slotTypeId = self.slotTypeId {
            try encodeContainer.encode(slotTypeId, forKey: .slotTypeId)
        }
        if let subSlotSetting = self.subSlotSetting {
            try encodeContainer.encode(subSlotSetting, forKey: .subSlotSetting)
        }
        if let valueElicitationSetting = self.valueElicitationSetting {
            try encodeContainer.encode(valueElicitationSetting, forKey: .valueElicitationSetting)
        }
    }
}

extension CreateSlotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botVersion = botVersion else {
            return nil
        }
        guard let localeId = localeId else {
            return nil
        }
        guard let intentId = intentId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botversions/\(botVersion.urlPercentEncoding())/botlocales/\(localeId.urlPercentEncoding())/intents/\(intentId.urlPercentEncoding())/slots"
    }
}

public struct CreateSlotInput: Swift.Equatable {
    /// The identifier of the bot associated with the slot.
    /// This member is required.
    public var botId: Swift.String?
    /// The version of the bot associated with the slot.
    /// This member is required.
    public var botVersion: Swift.String?
    /// A description of the slot. Use this to help identify the slot in lists.
    public var description: Swift.String?
    /// The identifier of the intent that contains the slot.
    /// This member is required.
    public var intentId: Swift.String?
    /// The identifier of the language and locale that the slot will be used in. The string must match one of the supported locales. All of the bots, intents, slot types used by the slot must have the same locale. For more information, see [Supported languages](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html).
    /// This member is required.
    public var localeId: Swift.String?
    /// Indicates whether the slot returns multiple values in one response. Multi-value slots are only available in the en-US locale. If you set this value to true in any other locale, Amazon Lex throws a ValidationException. If the multipleValuesSetting is not set, the default value is false.
    public var multipleValuesSetting: LexModelsV2ClientTypes.MultipleValuesSetting?
    /// Determines how slot values are used in Amazon CloudWatch logs. If the value of the obfuscationSetting parameter is DefaultObfuscation, slot values are obfuscated in the log output. If the value is None, the actual value is present in the log output. The default is to obfuscate values in the CloudWatch logs.
    public var obfuscationSetting: LexModelsV2ClientTypes.ObfuscationSetting?
    /// The name of the slot. Slot names must be unique within the bot that contains the slot.
    /// This member is required.
    public var slotName: Swift.String?
    /// The unique identifier for the slot type associated with this slot. The slot type determines the values that can be entered into the slot.
    public var slotTypeId: Swift.String?
    /// Specifications for the constituent sub slots and the expression for the composite slot.
    public var subSlotSetting: LexModelsV2ClientTypes.SubSlotSetting?
    /// Specifies prompts that Amazon Lex sends to the user to elicit a response that provides the value for the slot.
    /// This member is required.
    public var valueElicitationSetting: LexModelsV2ClientTypes.SlotValueElicitationSetting?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        description: Swift.String? = nil,
        intentId: Swift.String? = nil,
        localeId: Swift.String? = nil,
        multipleValuesSetting: LexModelsV2ClientTypes.MultipleValuesSetting? = nil,
        obfuscationSetting: LexModelsV2ClientTypes.ObfuscationSetting? = nil,
        slotName: Swift.String? = nil,
        slotTypeId: Swift.String? = nil,
        subSlotSetting: LexModelsV2ClientTypes.SubSlotSetting? = nil,
        valueElicitationSetting: LexModelsV2ClientTypes.SlotValueElicitationSetting? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.description = description
        self.intentId = intentId
        self.localeId = localeId
        self.multipleValuesSetting = multipleValuesSetting
        self.obfuscationSetting = obfuscationSetting
        self.slotName = slotName
        self.slotTypeId = slotTypeId
        self.subSlotSetting = subSlotSetting
        self.valueElicitationSetting = valueElicitationSetting
    }
}

struct CreateSlotInputBody: Swift.Equatable {
    let slotName: Swift.String?
    let description: Swift.String?
    let slotTypeId: Swift.String?
    let valueElicitationSetting: LexModelsV2ClientTypes.SlotValueElicitationSetting?
    let obfuscationSetting: LexModelsV2ClientTypes.ObfuscationSetting?
    let multipleValuesSetting: LexModelsV2ClientTypes.MultipleValuesSetting?
    let subSlotSetting: LexModelsV2ClientTypes.SubSlotSetting?
}

extension CreateSlotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case multipleValuesSetting
        case obfuscationSetting
        case slotName
        case slotTypeId
        case subSlotSetting
        case valueElicitationSetting
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let slotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotName)
        slotName = slotNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let slotTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotTypeId)
        slotTypeId = slotTypeIdDecoded
        let valueElicitationSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SlotValueElicitationSetting.self, forKey: .valueElicitationSetting)
        valueElicitationSetting = valueElicitationSettingDecoded
        let obfuscationSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ObfuscationSetting.self, forKey: .obfuscationSetting)
        obfuscationSetting = obfuscationSettingDecoded
        let multipleValuesSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.MultipleValuesSetting.self, forKey: .multipleValuesSetting)
        multipleValuesSetting = multipleValuesSettingDecoded
        let subSlotSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SubSlotSetting.self, forKey: .subSlotSetting)
        subSlotSetting = subSlotSettingDecoded
    }
}

enum CreateSlotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSlotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSlotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.intentId = output.intentId
            self.localeId = output.localeId
            self.multipleValuesSetting = output.multipleValuesSetting
            self.obfuscationSetting = output.obfuscationSetting
            self.slotId = output.slotId
            self.slotName = output.slotName
            self.slotTypeId = output.slotTypeId
            self.subSlotSetting = output.subSlotSetting
            self.valueElicitationSetting = output.valueElicitationSetting
        } else {
            self.botId = nil
            self.botVersion = nil
            self.creationDateTime = nil
            self.description = nil
            self.intentId = nil
            self.localeId = nil
            self.multipleValuesSetting = nil
            self.obfuscationSetting = nil
            self.slotId = nil
            self.slotName = nil
            self.slotTypeId = nil
            self.subSlotSetting = nil
            self.valueElicitationSetting = nil
        }
    }
}

public struct CreateSlotOutputResponse: Swift.Equatable {
    /// The unique identifier of the bot associated with the slot.
    public var botId: Swift.String?
    /// The version of the bot associated with the slot.
    public var botVersion: Swift.String?
    /// The timestamp of the date and time that the slot was created.
    public var creationDateTime: ClientRuntime.Date?
    /// The description associated with the slot.
    public var description: Swift.String?
    /// The unique identifier of the intent associated with the slot.
    public var intentId: Swift.String?
    /// The language and local specified for the slot.
    public var localeId: Swift.String?
    /// Indicates whether the slot returns multiple values in one response.
    public var multipleValuesSetting: LexModelsV2ClientTypes.MultipleValuesSetting?
    /// Indicates whether the slot is configured to obfuscate values in Amazon CloudWatch logs.
    public var obfuscationSetting: LexModelsV2ClientTypes.ObfuscationSetting?
    /// The unique identifier associated with the slot. Use this to identify the slot when you update or delete it.
    public var slotId: Swift.String?
    /// The name specified for the slot.
    public var slotName: Swift.String?
    /// The unique identifier of the slot type associated with this slot.
    public var slotTypeId: Swift.String?
    /// Specifications for the constituent sub slots and the expression for the composite slot.
    public var subSlotSetting: LexModelsV2ClientTypes.SubSlotSetting?
    /// The value elicitation settings specified for the slot.
    public var valueElicitationSetting: LexModelsV2ClientTypes.SlotValueElicitationSetting?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        intentId: Swift.String? = nil,
        localeId: Swift.String? = nil,
        multipleValuesSetting: LexModelsV2ClientTypes.MultipleValuesSetting? = nil,
        obfuscationSetting: LexModelsV2ClientTypes.ObfuscationSetting? = nil,
        slotId: Swift.String? = nil,
        slotName: Swift.String? = nil,
        slotTypeId: Swift.String? = nil,
        subSlotSetting: LexModelsV2ClientTypes.SubSlotSetting? = nil,
        valueElicitationSetting: LexModelsV2ClientTypes.SlotValueElicitationSetting? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.creationDateTime = creationDateTime
        self.description = description
        self.intentId = intentId
        self.localeId = localeId
        self.multipleValuesSetting = multipleValuesSetting
        self.obfuscationSetting = obfuscationSetting
        self.slotId = slotId
        self.slotName = slotName
        self.slotTypeId = slotTypeId
        self.subSlotSetting = subSlotSetting
        self.valueElicitationSetting = valueElicitationSetting
    }
}

struct CreateSlotOutputResponseBody: Swift.Equatable {
    let slotId: Swift.String?
    let slotName: Swift.String?
    let description: Swift.String?
    let slotTypeId: Swift.String?
    let valueElicitationSetting: LexModelsV2ClientTypes.SlotValueElicitationSetting?
    let obfuscationSetting: LexModelsV2ClientTypes.ObfuscationSetting?
    let botId: Swift.String?
    let botVersion: Swift.String?
    let localeId: Swift.String?
    let intentId: Swift.String?
    let creationDateTime: ClientRuntime.Date?
    let multipleValuesSetting: LexModelsV2ClientTypes.MultipleValuesSetting?
    let subSlotSetting: LexModelsV2ClientTypes.SubSlotSetting?
}

extension CreateSlotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botVersion
        case creationDateTime
        case description
        case intentId
        case localeId
        case multipleValuesSetting
        case obfuscationSetting
        case slotId
        case slotName
        case slotTypeId
        case subSlotSetting
        case valueElicitationSetting
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let slotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotId)
        slotId = slotIdDecoded
        let slotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotName)
        slotName = slotNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let slotTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotTypeId)
        slotTypeId = slotTypeIdDecoded
        let valueElicitationSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SlotValueElicitationSetting.self, forKey: .valueElicitationSetting)
        valueElicitationSetting = valueElicitationSettingDecoded
        let obfuscationSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ObfuscationSetting.self, forKey: .obfuscationSetting)
        obfuscationSetting = obfuscationSettingDecoded
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let intentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intentId)
        intentId = intentIdDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let multipleValuesSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.MultipleValuesSetting.self, forKey: .multipleValuesSetting)
        multipleValuesSetting = multipleValuesSettingDecoded
        let subSlotSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SubSlotSetting.self, forKey: .subSlotSetting)
        subSlotSetting = subSlotSettingDecoded
    }
}

extension CreateSlotTypeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compositeSlotTypeSetting
        case description
        case externalSourceSetting
        case parentSlotTypeSignature
        case slotTypeName
        case slotTypeValues
        case valueSelectionSetting
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compositeSlotTypeSetting = self.compositeSlotTypeSetting {
            try encodeContainer.encode(compositeSlotTypeSetting, forKey: .compositeSlotTypeSetting)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let externalSourceSetting = self.externalSourceSetting {
            try encodeContainer.encode(externalSourceSetting, forKey: .externalSourceSetting)
        }
        if let parentSlotTypeSignature = self.parentSlotTypeSignature {
            try encodeContainer.encode(parentSlotTypeSignature, forKey: .parentSlotTypeSignature)
        }
        if let slotTypeName = self.slotTypeName {
            try encodeContainer.encode(slotTypeName, forKey: .slotTypeName)
        }
        if let slotTypeValues = slotTypeValues {
            var slotTypeValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .slotTypeValues)
            for slottypevalue0 in slotTypeValues {
                try slotTypeValuesContainer.encode(slottypevalue0)
            }
        }
        if let valueSelectionSetting = self.valueSelectionSetting {
            try encodeContainer.encode(valueSelectionSetting, forKey: .valueSelectionSetting)
        }
    }
}

extension CreateSlotTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botVersion = botVersion else {
            return nil
        }
        guard let localeId = localeId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botversions/\(botVersion.urlPercentEncoding())/botlocales/\(localeId.urlPercentEncoding())/slottypes"
    }
}

public struct CreateSlotTypeInput: Swift.Equatable {
    /// The identifier of the bot associated with this slot type.
    /// This member is required.
    public var botId: Swift.String?
    /// The identifier of the bot version associated with this slot type.
    /// This member is required.
    public var botVersion: Swift.String?
    /// Specifications for a composite slot type.
    public var compositeSlotTypeSetting: LexModelsV2ClientTypes.CompositeSlotTypeSetting?
    /// A description of the slot type. Use the description to help identify the slot type in lists.
    public var description: Swift.String?
    /// Sets the type of external information used to create the slot type.
    public var externalSourceSetting: LexModelsV2ClientTypes.ExternalSourceSetting?
    /// The identifier of the language and locale that the slot type will be used in. The string must match one of the supported locales. All of the bots, intents, and slots used by the slot type must have the same locale. For more information, see [Supported languages](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html).
    /// This member is required.
    public var localeId: Swift.String?
    /// The built-in slot type used as a parent of this slot type. When you define a parent slot type, the new slot type has the configuration of the parent slot type. Only AMAZON.AlphaNumeric is supported.
    public var parentSlotTypeSignature: Swift.String?
    /// The name for the slot. A slot type name must be unique within the intent.
    /// This member is required.
    public var slotTypeName: Swift.String?
    /// A list of SlotTypeValue objects that defines the values that the slot type can take. Each value can have a list of synonyms, additional values that help train the machine learning model about the values that it resolves for a slot.
    public var slotTypeValues: [LexModelsV2ClientTypes.SlotTypeValue]?
    /// Determines the strategy that Amazon Lex uses to select a value from the list of possible values. The field can be set to one of the following values:
    ///
    /// * ORIGINAL_VALUE - Returns the value entered by the user, if the user value is similar to the slot value.
    ///
    /// * TOP_RESOLUTION - If there is a resolution list for the slot, return the first value in the resolution list. If there is no resolution list, return null.
    ///
    ///
    /// If you don't specify the valueSelectionSetting parameter, the default is ORIGINAL_VALUE.
    public var valueSelectionSetting: LexModelsV2ClientTypes.SlotValueSelectionSetting?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        compositeSlotTypeSetting: LexModelsV2ClientTypes.CompositeSlotTypeSetting? = nil,
        description: Swift.String? = nil,
        externalSourceSetting: LexModelsV2ClientTypes.ExternalSourceSetting? = nil,
        localeId: Swift.String? = nil,
        parentSlotTypeSignature: Swift.String? = nil,
        slotTypeName: Swift.String? = nil,
        slotTypeValues: [LexModelsV2ClientTypes.SlotTypeValue]? = nil,
        valueSelectionSetting: LexModelsV2ClientTypes.SlotValueSelectionSetting? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.compositeSlotTypeSetting = compositeSlotTypeSetting
        self.description = description
        self.externalSourceSetting = externalSourceSetting
        self.localeId = localeId
        self.parentSlotTypeSignature = parentSlotTypeSignature
        self.slotTypeName = slotTypeName
        self.slotTypeValues = slotTypeValues
        self.valueSelectionSetting = valueSelectionSetting
    }
}

struct CreateSlotTypeInputBody: Swift.Equatable {
    let slotTypeName: Swift.String?
    let description: Swift.String?
    let slotTypeValues: [LexModelsV2ClientTypes.SlotTypeValue]?
    let valueSelectionSetting: LexModelsV2ClientTypes.SlotValueSelectionSetting?
    let parentSlotTypeSignature: Swift.String?
    let externalSourceSetting: LexModelsV2ClientTypes.ExternalSourceSetting?
    let compositeSlotTypeSetting: LexModelsV2ClientTypes.CompositeSlotTypeSetting?
}

extension CreateSlotTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compositeSlotTypeSetting
        case description
        case externalSourceSetting
        case parentSlotTypeSignature
        case slotTypeName
        case slotTypeValues
        case valueSelectionSetting
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let slotTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotTypeName)
        slotTypeName = slotTypeNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let slotTypeValuesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.SlotTypeValue?].self, forKey: .slotTypeValues)
        var slotTypeValuesDecoded0:[LexModelsV2ClientTypes.SlotTypeValue]? = nil
        if let slotTypeValuesContainer = slotTypeValuesContainer {
            slotTypeValuesDecoded0 = [LexModelsV2ClientTypes.SlotTypeValue]()
            for structure0 in slotTypeValuesContainer {
                if let structure0 = structure0 {
                    slotTypeValuesDecoded0?.append(structure0)
                }
            }
        }
        slotTypeValues = slotTypeValuesDecoded0
        let valueSelectionSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SlotValueSelectionSetting.self, forKey: .valueSelectionSetting)
        valueSelectionSetting = valueSelectionSettingDecoded
        let parentSlotTypeSignatureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentSlotTypeSignature)
        parentSlotTypeSignature = parentSlotTypeSignatureDecoded
        let externalSourceSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ExternalSourceSetting.self, forKey: .externalSourceSetting)
        externalSourceSetting = externalSourceSettingDecoded
        let compositeSlotTypeSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.CompositeSlotTypeSetting.self, forKey: .compositeSlotTypeSetting)
        compositeSlotTypeSetting = compositeSlotTypeSettingDecoded
    }
}

enum CreateSlotTypeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSlotTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSlotTypeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.compositeSlotTypeSetting = output.compositeSlotTypeSetting
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.externalSourceSetting = output.externalSourceSetting
            self.localeId = output.localeId
            self.parentSlotTypeSignature = output.parentSlotTypeSignature
            self.slotTypeId = output.slotTypeId
            self.slotTypeName = output.slotTypeName
            self.slotTypeValues = output.slotTypeValues
            self.valueSelectionSetting = output.valueSelectionSetting
        } else {
            self.botId = nil
            self.botVersion = nil
            self.compositeSlotTypeSetting = nil
            self.creationDateTime = nil
            self.description = nil
            self.externalSourceSetting = nil
            self.localeId = nil
            self.parentSlotTypeSignature = nil
            self.slotTypeId = nil
            self.slotTypeName = nil
            self.slotTypeValues = nil
            self.valueSelectionSetting = nil
        }
    }
}

public struct CreateSlotTypeOutputResponse: Swift.Equatable {
    /// The identifier for the bot associated with the slot type.
    public var botId: Swift.String?
    /// The version of the bot associated with the slot type.
    public var botVersion: Swift.String?
    /// Specifications for a composite slot type.
    public var compositeSlotTypeSetting: LexModelsV2ClientTypes.CompositeSlotTypeSetting?
    /// A timestamp of the date and time that the slot type was created.
    public var creationDateTime: ClientRuntime.Date?
    /// The description specified for the slot type.
    public var description: Swift.String?
    /// The type of external information used to create the slot type.
    public var externalSourceSetting: LexModelsV2ClientTypes.ExternalSourceSetting?
    /// The specified language and local specified for the slot type.
    public var localeId: Swift.String?
    /// The signature of the base slot type specified for the slot type.
    public var parentSlotTypeSignature: Swift.String?
    /// The unique identifier assigned to the slot type. Use this to identify the slot type in the UpdateSlotType and DeleteSlotType operations.
    public var slotTypeId: Swift.String?
    /// The name specified for the slot type.
    public var slotTypeName: Swift.String?
    /// The list of values that the slot type can assume.
    public var slotTypeValues: [LexModelsV2ClientTypes.SlotTypeValue]?
    /// The strategy that Amazon Lex uses to select a value from the list of possible values.
    public var valueSelectionSetting: LexModelsV2ClientTypes.SlotValueSelectionSetting?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        compositeSlotTypeSetting: LexModelsV2ClientTypes.CompositeSlotTypeSetting? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        externalSourceSetting: LexModelsV2ClientTypes.ExternalSourceSetting? = nil,
        localeId: Swift.String? = nil,
        parentSlotTypeSignature: Swift.String? = nil,
        slotTypeId: Swift.String? = nil,
        slotTypeName: Swift.String? = nil,
        slotTypeValues: [LexModelsV2ClientTypes.SlotTypeValue]? = nil,
        valueSelectionSetting: LexModelsV2ClientTypes.SlotValueSelectionSetting? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.compositeSlotTypeSetting = compositeSlotTypeSetting
        self.creationDateTime = creationDateTime
        self.description = description
        self.externalSourceSetting = externalSourceSetting
        self.localeId = localeId
        self.parentSlotTypeSignature = parentSlotTypeSignature
        self.slotTypeId = slotTypeId
        self.slotTypeName = slotTypeName
        self.slotTypeValues = slotTypeValues
        self.valueSelectionSetting = valueSelectionSetting
    }
}

struct CreateSlotTypeOutputResponseBody: Swift.Equatable {
    let slotTypeId: Swift.String?
    let slotTypeName: Swift.String?
    let description: Swift.String?
    let slotTypeValues: [LexModelsV2ClientTypes.SlotTypeValue]?
    let valueSelectionSetting: LexModelsV2ClientTypes.SlotValueSelectionSetting?
    let parentSlotTypeSignature: Swift.String?
    let botId: Swift.String?
    let botVersion: Swift.String?
    let localeId: Swift.String?
    let creationDateTime: ClientRuntime.Date?
    let externalSourceSetting: LexModelsV2ClientTypes.ExternalSourceSetting?
    let compositeSlotTypeSetting: LexModelsV2ClientTypes.CompositeSlotTypeSetting?
}

extension CreateSlotTypeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botVersion
        case compositeSlotTypeSetting
        case creationDateTime
        case description
        case externalSourceSetting
        case localeId
        case parentSlotTypeSignature
        case slotTypeId
        case slotTypeName
        case slotTypeValues
        case valueSelectionSetting
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let slotTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotTypeId)
        slotTypeId = slotTypeIdDecoded
        let slotTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotTypeName)
        slotTypeName = slotTypeNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let slotTypeValuesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.SlotTypeValue?].self, forKey: .slotTypeValues)
        var slotTypeValuesDecoded0:[LexModelsV2ClientTypes.SlotTypeValue]? = nil
        if let slotTypeValuesContainer = slotTypeValuesContainer {
            slotTypeValuesDecoded0 = [LexModelsV2ClientTypes.SlotTypeValue]()
            for structure0 in slotTypeValuesContainer {
                if let structure0 = structure0 {
                    slotTypeValuesDecoded0?.append(structure0)
                }
            }
        }
        slotTypeValues = slotTypeValuesDecoded0
        let valueSelectionSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SlotValueSelectionSetting.self, forKey: .valueSelectionSetting)
        valueSelectionSetting = valueSelectionSettingDecoded
        let parentSlotTypeSignatureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentSlotTypeSignature)
        parentSlotTypeSignature = parentSlotTypeSignatureDecoded
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let externalSourceSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ExternalSourceSetting.self, forKey: .externalSourceSetting)
        externalSourceSetting = externalSourceSettingDecoded
        let compositeSlotTypeSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.CompositeSlotTypeSetting.self, forKey: .compositeSlotTypeSetting)
        compositeSlotTypeSetting = compositeSlotTypeSettingDecoded
    }
}

extension CreateTestSetDiscrepancyReportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case target
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let target = self.target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }
}

extension CreateTestSetDiscrepancyReportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let testSetId = testSetId else {
            return nil
        }
        return "/testsets/\(testSetId.urlPercentEncoding())/testsetdiscrepancy"
    }
}

public struct CreateTestSetDiscrepancyReportInput: Swift.Equatable {
    /// The target bot for the test set discrepancy report.
    /// This member is required.
    public var target: LexModelsV2ClientTypes.TestSetDiscrepancyReportResourceTarget?
    /// The test set Id for the test set discrepancy report.
    /// This member is required.
    public var testSetId: Swift.String?

    public init(
        target: LexModelsV2ClientTypes.TestSetDiscrepancyReportResourceTarget? = nil,
        testSetId: Swift.String? = nil
    )
    {
        self.target = target
        self.testSetId = testSetId
    }
}

struct CreateTestSetDiscrepancyReportInputBody: Swift.Equatable {
    let target: LexModelsV2ClientTypes.TestSetDiscrepancyReportResourceTarget?
}

extension CreateTestSetDiscrepancyReportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case target
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestSetDiscrepancyReportResourceTarget.self, forKey: .target)
        target = targetDecoded
    }
}

enum CreateTestSetDiscrepancyReportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateTestSetDiscrepancyReportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateTestSetDiscrepancyReportOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationDateTime = output.creationDateTime
            self.target = output.target
            self.testSetDiscrepancyReportId = output.testSetDiscrepancyReportId
            self.testSetId = output.testSetId
        } else {
            self.creationDateTime = nil
            self.target = nil
            self.testSetDiscrepancyReportId = nil
            self.testSetId = nil
        }
    }
}

public struct CreateTestSetDiscrepancyReportOutputResponse: Swift.Equatable {
    /// The creation date and time for the test set discrepancy report.
    public var creationDateTime: ClientRuntime.Date?
    /// The target bot for the test set discrepancy report.
    public var target: LexModelsV2ClientTypes.TestSetDiscrepancyReportResourceTarget?
    /// The unique identifier of the test set discrepancy report to describe.
    public var testSetDiscrepancyReportId: Swift.String?
    /// The test set Id for the test set discrepancy report.
    public var testSetId: Swift.String?

    public init(
        creationDateTime: ClientRuntime.Date? = nil,
        target: LexModelsV2ClientTypes.TestSetDiscrepancyReportResourceTarget? = nil,
        testSetDiscrepancyReportId: Swift.String? = nil,
        testSetId: Swift.String? = nil
    )
    {
        self.creationDateTime = creationDateTime
        self.target = target
        self.testSetDiscrepancyReportId = testSetDiscrepancyReportId
        self.testSetId = testSetId
    }
}

struct CreateTestSetDiscrepancyReportOutputResponseBody: Swift.Equatable {
    let testSetDiscrepancyReportId: Swift.String?
    let creationDateTime: ClientRuntime.Date?
    let testSetId: Swift.String?
    let target: LexModelsV2ClientTypes.TestSetDiscrepancyReportResourceTarget?
}

extension CreateTestSetDiscrepancyReportOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case target
        case testSetDiscrepancyReportId
        case testSetId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testSetDiscrepancyReportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testSetDiscrepancyReportId)
        testSetDiscrepancyReportId = testSetDiscrepancyReportIdDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let testSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testSetId)
        testSetId = testSetIdDecoded
        let targetDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestSetDiscrepancyReportResourceTarget.self, forKey: .target)
        target = targetDecoded
    }
}

extension CreateUploadUrlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createuploadurl"
    }
}

public struct CreateUploadUrlInput: Swift.Equatable {

    public init() { }
}

struct CreateUploadUrlInputBody: Swift.Equatable {
}

extension CreateUploadUrlInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum CreateUploadUrlOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateUploadUrlOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateUploadUrlOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.importId = output.importId
            self.uploadUrl = output.uploadUrl
        } else {
            self.importId = nil
            self.uploadUrl = nil
        }
    }
}

public struct CreateUploadUrlOutputResponse: Swift.Equatable {
    /// An identifier for a unique import job. Use it when you call the [StartImport](https://docs.aws.amazon.com/lexv2/latest/APIReference/API_StartImport.html) operation.
    public var importId: Swift.String?
    /// A pre-signed S3 write URL. Upload the zip archive file that contains the definition of your bot or bot locale.
    public var uploadUrl: Swift.String?

    public init(
        importId: Swift.String? = nil,
        uploadUrl: Swift.String? = nil
    )
    {
        self.importId = importId
        self.uploadUrl = uploadUrl
    }
}

struct CreateUploadUrlOutputResponseBody: Swift.Equatable {
    let importId: Swift.String?
    let uploadUrl: Swift.String?
}

extension CreateUploadUrlOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importId
        case uploadUrl
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importId)
        importId = importIdDecoded
        let uploadUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadUrl)
        uploadUrl = uploadUrlDecoded
    }
}

extension LexModelsV2ClientTypes.CustomPayload: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// A custom response string that Amazon Lex sends to your application. You define the content and structure the string.
    public struct CustomPayload: Swift.Equatable {
        /// The string that is sent to your application.
        /// This member is required.
        public var value: Swift.String?

        public init(
            value: Swift.String? = nil
        )
        {
            self.value = value
        }
    }

}

extension LexModelsV2ClientTypes.CustomVocabularyEntryId: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case itemId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let itemId = self.itemId {
            try encodeContainer.encode(itemId, forKey: .itemId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .itemId)
        itemId = itemIdDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// The unique entry identifier for the custom vocabulary items.
    public struct CustomVocabularyEntryId: Swift.Equatable {
        /// The unique item identifier for the custom vocabulary items.
        /// This member is required.
        public var itemId: Swift.String?

        public init(
            itemId: Swift.String? = nil
        )
        {
            self.itemId = itemId
        }
    }

}

extension LexModelsV2ClientTypes.CustomVocabularyExportSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botVersion
        case localeId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botId = self.botId {
            try encodeContainer.encode(botId, forKey: .botId)
        }
        if let botVersion = self.botVersion {
            try encodeContainer.encode(botVersion, forKey: .botVersion)
        }
        if let localeId = self.localeId {
            try encodeContainer.encode(localeId, forKey: .localeId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Provides the parameters required for exporting a custom vocabulary.
    public struct CustomVocabularyExportSpecification: Swift.Equatable {
        /// The identifier of the bot that contains the custom vocabulary to export.
        /// This member is required.
        public var botId: Swift.String?
        /// The version of the bot that contains the custom vocabulary to export.
        /// This member is required.
        public var botVersion: Swift.String?
        /// The locale of the bot that contains the custom vocabulary to export.
        /// This member is required.
        public var localeId: Swift.String?

        public init(
            botId: Swift.String? = nil,
            botVersion: Swift.String? = nil,
            localeId: Swift.String? = nil
        )
        {
            self.botId = botId
            self.botVersion = botVersion
            self.localeId = localeId
        }
    }

}

extension LexModelsV2ClientTypes.CustomVocabularyImportSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botVersion
        case localeId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botId = self.botId {
            try encodeContainer.encode(botId, forKey: .botId)
        }
        if let botVersion = self.botVersion {
            try encodeContainer.encode(botVersion, forKey: .botVersion)
        }
        if let localeId = self.localeId {
            try encodeContainer.encode(localeId, forKey: .localeId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Provides the parameters required for importing a custom vocabulary.
    public struct CustomVocabularyImportSpecification: Swift.Equatable {
        /// The identifier of the bot to import the custom vocabulary to.
        /// This member is required.
        public var botId: Swift.String?
        /// The version of the bot to import the custom vocabulary to.
        /// This member is required.
        public var botVersion: Swift.String?
        /// The identifier of the local to import the custom vocabulary to. The value must be en_GB.
        /// This member is required.
        public var localeId: Swift.String?

        public init(
            botId: Swift.String? = nil,
            botVersion: Swift.String? = nil,
            localeId: Swift.String? = nil
        )
        {
            self.botId = botId
            self.botVersion = botVersion
            self.localeId = localeId
        }
    }

}

extension LexModelsV2ClientTypes.CustomVocabularyItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayAs
        case itemId
        case phrase
        case weight
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayAs = self.displayAs {
            try encodeContainer.encode(displayAs, forKey: .displayAs)
        }
        if let itemId = self.itemId {
            try encodeContainer.encode(itemId, forKey: .itemId)
        }
        if let phrase = self.phrase {
            try encodeContainer.encode(phrase, forKey: .phrase)
        }
        if let weight = self.weight {
            try encodeContainer.encode(weight, forKey: .weight)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .itemId)
        itemId = itemIdDecoded
        let phraseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phrase)
        phrase = phraseDecoded
        let weightDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .weight)
        weight = weightDecoded
        let displayAsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayAs)
        displayAs = displayAsDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// The unique custom vocabulary item from the custom vocabulary list.
    public struct CustomVocabularyItem: Swift.Equatable {
        /// The DisplayAs value for the custom vocabulary item from the custom vocabulary list.
        public var displayAs: Swift.String?
        /// The unique item identifer for the custom vocabulary item from the custom vocabulary list.
        /// This member is required.
        public var itemId: Swift.String?
        /// The unique phrase for the custom vocabulary item from the custom vocabulary list.
        /// This member is required.
        public var phrase: Swift.String?
        /// The weight assigned for the custom vocabulary item from the custom vocabulary list.
        public var weight: Swift.Int?

        public init(
            displayAs: Swift.String? = nil,
            itemId: Swift.String? = nil,
            phrase: Swift.String? = nil,
            weight: Swift.Int? = nil
        )
        {
            self.displayAs = displayAs
            self.itemId = itemId
            self.phrase = phrase
            self.weight = weight
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum CustomVocabularyStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creating
        case deleting
        case exporting
        case importing
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomVocabularyStatus] {
            return [
                .creating,
                .deleting,
                .exporting,
                .importing,
                .ready,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creating: return "Creating"
            case .deleting: return "Deleting"
            case .exporting: return "Exporting"
            case .importing: return "Importing"
            case .ready: return "Ready"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CustomVocabularyStatus(rawValue: rawValue) ?? CustomVocabularyStatus.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.DTMFSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionCharacter
        case endCharacter
        case endTimeoutMs
        case maxLength
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deletionCharacter = self.deletionCharacter {
            try encodeContainer.encode(deletionCharacter, forKey: .deletionCharacter)
        }
        if let endCharacter = self.endCharacter {
            try encodeContainer.encode(endCharacter, forKey: .endCharacter)
        }
        if let endTimeoutMs = self.endTimeoutMs {
            try encodeContainer.encode(endTimeoutMs, forKey: .endTimeoutMs)
        }
        if let maxLength = self.maxLength {
            try encodeContainer.encode(maxLength, forKey: .maxLength)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxLength)
        maxLength = maxLengthDecoded
        let endTimeoutMsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endTimeoutMs)
        endTimeoutMs = endTimeoutMsDecoded
        let deletionCharacterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deletionCharacter)
        deletionCharacter = deletionCharacterDecoded
        let endCharacterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endCharacter)
        endCharacter = endCharacterDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Specifies the DTMF input specifications.
    public struct DTMFSpecification: Swift.Equatable {
        /// The DTMF character that clears the accumulated DTMF digits and immediately ends the input.
        /// This member is required.
        public var deletionCharacter: Swift.String?
        /// The DTMF character that immediately ends input. If the user does not press this character, the input ends after the end timeout.
        /// This member is required.
        public var endCharacter: Swift.String?
        /// How long the bot should wait after the last DTMF character input before assuming that the input has concluded.
        /// This member is required.
        public var endTimeoutMs: Swift.Int?
        /// The maximum number of DTMF digits allowed in an utterance.
        /// This member is required.
        public var maxLength: Swift.Int?

        public init(
            deletionCharacter: Swift.String? = nil,
            endCharacter: Swift.String? = nil,
            endTimeoutMs: Swift.Int? = nil,
            maxLength: Swift.Int? = nil
        )
        {
            self.deletionCharacter = deletionCharacter
            self.endCharacter = endCharacter
            self.endTimeoutMs = endTimeoutMs
            self.maxLength = maxLength
        }
    }

}

extension LexModelsV2ClientTypes.DataPrivacy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childDirected
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if childDirected != false {
            try encodeContainer.encode(childDirected, forKey: .childDirected)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let childDirectedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .childDirected) ?? false
        childDirected = childDirectedDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// By default, data stored by Amazon Lex is encrypted. The DataPrivacy structure provides settings that determine how Amazon Lex handles special cases of securing the data for your bot.
    public struct DataPrivacy: Swift.Equatable {
        /// For each Amazon Lex bot created with the Amazon Lex Model Building Service, you must specify whether your use of Amazon Lex is related to a website, program, or other application that is directed or targeted, in whole or in part, to children under age 13 and subject to the Children's Online Privacy Protection Act (COPPA) by specifying true or false in the childDirected field. By specifying true in the childDirected field, you confirm that your use of Amazon Lex is related to a website, program, or other application that is directed or targeted, in whole or in part, to children under age 13 and subject to COPPA. By specifying false in the childDirected field, you confirm that your use of Amazon Lex is not related to a website, program, or other application that is directed or targeted, in whole or in part, to children under age 13 and subject to COPPA. You may not specify a default value for the childDirected field that does not accurately reflect whether your use of Amazon Lex is related to a website, program, or other application that is directed or targeted, in whole or in part, to children under age 13 and subject to COPPA. If your use of Amazon Lex relates to a website, program, or other application that is directed in whole or in part, to children under age 13, you must obtain any required verifiable parental consent under COPPA. For information regarding the use of Amazon Lex in connection with websites, programs, or other applications that are directed or targeted, in whole or in part, to children under age 13, see the [Amazon Lex FAQ](http://aws.amazon.com/lex/faqs#data-security).
        /// This member is required.
        public var childDirected: Swift.Bool

        public init(
            childDirected: Swift.Bool = false
        )
        {
            self.childDirected = childDirected
        }
    }

}

extension LexModelsV2ClientTypes.DateRangeFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endDateTime
        case startDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endDateTime = self.endDateTime {
            try encodeContainer.encodeTimestamp(endDateTime, format: .epochSeconds, forKey: .endDateTime)
        }
        if let startDateTime = self.startDateTime {
            try encodeContainer.encodeTimestamp(startDateTime, format: .epochSeconds, forKey: .startDateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startDateTime)
        startDateTime = startDateTimeDecoded
        let endDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endDateTime)
        endDateTime = endDateTimeDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// The object used for specifying the data range that the customer wants Amazon Lex to read through in the input transcripts.
    public struct DateRangeFilter: Swift.Equatable {
        /// A timestamp indicating the end date for the date range filter.
        /// This member is required.
        public var endDateTime: ClientRuntime.Date?
        /// A timestamp indicating the start date for the date range filter.
        /// This member is required.
        public var startDateTime: ClientRuntime.Date?

        public init(
            endDateTime: ClientRuntime.Date? = nil,
            startDateTime: ClientRuntime.Date? = nil
        )
        {
            self.endDateTime = endDateTime
            self.startDateTime = startDateTime
        }
    }

}

extension LexModelsV2ClientTypes.DefaultConditionalBranch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextStep
        case response
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextStep = self.nextStep {
            try encodeContainer.encode(nextStep, forKey: .nextStep)
        }
        if let response = self.response {
            try encodeContainer.encode(response, forKey: .response)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextStepDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.DialogState.self, forKey: .nextStep)
        nextStep = nextStepDecoded
        let responseDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ResponseSpecification.self, forKey: .response)
        response = responseDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// A set of actions that Amazon Lex should run if none of the other conditions are met.
    public struct DefaultConditionalBranch: Swift.Equatable {
        /// The next step in the conversation.
        public var nextStep: LexModelsV2ClientTypes.DialogState?
        /// Specifies a list of message groups that Amazon Lex uses to respond the user input.
        public var response: LexModelsV2ClientTypes.ResponseSpecification?

        public init(
            nextStep: LexModelsV2ClientTypes.DialogState? = nil,
            response: LexModelsV2ClientTypes.ResponseSpecification? = nil
        )
        {
            self.nextStep = nextStep
            self.response = response
        }
    }

}

extension DeleteBotAliasInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let skipResourceInUseCheck = skipResourceInUseCheck {
                let skipResourceInUseCheckQueryItem = ClientRuntime.URLQueryItem(name: "skipResourceInUseCheck".urlPercentEncoding(), value: Swift.String(skipResourceInUseCheck).urlPercentEncoding())
                items.append(skipResourceInUseCheckQueryItem)
            }
            return items
        }
    }
}

extension DeleteBotAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botAliasId = botAliasId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botaliases/\(botAliasId.urlPercentEncoding())"
    }
}

public struct DeleteBotAliasInput: Swift.Equatable {
    /// The unique identifier of the bot alias to delete.
    /// This member is required.
    public var botAliasId: Swift.String?
    /// The unique identifier of the bot associated with the alias to delete.
    /// This member is required.
    public var botId: Swift.String?
    /// By default, Amazon Lex checks if any other resource, such as a bot network, is using the bot alias before it is deleted and throws a ResourceInUseException exception if the alias is being used by another resource. Set this parameter to true to skip this check and remove the alias even if it is being used by another resource.
    public var skipResourceInUseCheck: Swift.Bool?

    public init(
        botAliasId: Swift.String? = nil,
        botId: Swift.String? = nil,
        skipResourceInUseCheck: Swift.Bool? = nil
    )
    {
        self.botAliasId = botAliasId
        self.botId = botId
        self.skipResourceInUseCheck = skipResourceInUseCheck
    }
}

struct DeleteBotAliasInputBody: Swift.Equatable {
}

extension DeleteBotAliasInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum DeleteBotAliasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteBotAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteBotAliasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botAliasId = output.botAliasId
            self.botAliasStatus = output.botAliasStatus
            self.botId = output.botId
        } else {
            self.botAliasId = nil
            self.botAliasStatus = nil
            self.botId = nil
        }
    }
}

public struct DeleteBotAliasOutputResponse: Swift.Equatable {
    /// The unique identifier of the bot alias to delete.
    public var botAliasId: Swift.String?
    /// The current status of the alias. The status is Deleting while the alias is in the process of being deleted. Once the alias is deleted, it will no longer appear in the list of aliases returned by the ListBotAliases operation.
    public var botAliasStatus: LexModelsV2ClientTypes.BotAliasStatus?
    /// The unique identifier of the bot that contains the alias to delete.
    public var botId: Swift.String?

    public init(
        botAliasId: Swift.String? = nil,
        botAliasStatus: LexModelsV2ClientTypes.BotAliasStatus? = nil,
        botId: Swift.String? = nil
    )
    {
        self.botAliasId = botAliasId
        self.botAliasStatus = botAliasStatus
        self.botId = botId
    }
}

struct DeleteBotAliasOutputResponseBody: Swift.Equatable {
    let botAliasId: Swift.String?
    let botId: Swift.String?
    let botAliasStatus: LexModelsV2ClientTypes.BotAliasStatus?
}

extension DeleteBotAliasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botAliasId
        case botAliasStatus
        case botId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botAliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botAliasId)
        botAliasId = botAliasIdDecoded
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botAliasStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotAliasStatus.self, forKey: .botAliasStatus)
        botAliasStatus = botAliasStatusDecoded
    }
}

extension DeleteBotInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let skipResourceInUseCheck = skipResourceInUseCheck {
                let skipResourceInUseCheckQueryItem = ClientRuntime.URLQueryItem(name: "skipResourceInUseCheck".urlPercentEncoding(), value: Swift.String(skipResourceInUseCheck).urlPercentEncoding())
                items.append(skipResourceInUseCheckQueryItem)
            }
            return items
        }
    }
}

extension DeleteBotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())"
    }
}

public struct DeleteBotInput: Swift.Equatable {
    /// The identifier of the bot to delete.
    /// This member is required.
    public var botId: Swift.String?
    /// By default, Amazon Lex checks if any other resource, such as an alias or bot network, is using the bot version before it is deleted and throws a ResourceInUseException exception if the bot is being used by another resource. Set this parameter to true to skip this check and remove the bot even if it is being used by another resource.
    public var skipResourceInUseCheck: Swift.Bool?

    public init(
        botId: Swift.String? = nil,
        skipResourceInUseCheck: Swift.Bool? = nil
    )
    {
        self.botId = botId
        self.skipResourceInUseCheck = skipResourceInUseCheck
    }
}

struct DeleteBotInputBody: Swift.Equatable {
}

extension DeleteBotInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBotLocaleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botVersion = botVersion else {
            return nil
        }
        guard let localeId = localeId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botversions/\(botVersion.urlPercentEncoding())/botlocales/\(localeId.urlPercentEncoding())"
    }
}

public struct DeleteBotLocaleInput: Swift.Equatable {
    /// The unique identifier of the bot that contains the locale.
    /// This member is required.
    public var botId: Swift.String?
    /// The version of the bot that contains the locale.
    /// This member is required.
    public var botVersion: Swift.String?
    /// The identifier of the language and locale that will be deleted. The string must match one of the supported locales. For more information, see [Supported languages](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html).
    /// This member is required.
    public var localeId: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        localeId: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.localeId = localeId
    }
}

struct DeleteBotLocaleInputBody: Swift.Equatable {
}

extension DeleteBotLocaleInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum DeleteBotLocaleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteBotLocaleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteBotLocaleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botLocaleStatus = output.botLocaleStatus
            self.botVersion = output.botVersion
            self.localeId = output.localeId
        } else {
            self.botId = nil
            self.botLocaleStatus = nil
            self.botVersion = nil
            self.localeId = nil
        }
    }
}

public struct DeleteBotLocaleOutputResponse: Swift.Equatable {
    /// The identifier of the bot that contained the deleted locale.
    public var botId: Swift.String?
    /// The status of deleting the bot locale. The locale first enters the Deleting status. Once the locale is deleted it no longer appears in the list of locales for the bot.
    public var botLocaleStatus: LexModelsV2ClientTypes.BotLocaleStatus?
    /// The version of the bot that contained the deleted locale.
    public var botVersion: Swift.String?
    /// The language and locale of the deleted locale.
    public var localeId: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botLocaleStatus: LexModelsV2ClientTypes.BotLocaleStatus? = nil,
        botVersion: Swift.String? = nil,
        localeId: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botLocaleStatus = botLocaleStatus
        self.botVersion = botVersion
        self.localeId = localeId
    }
}

struct DeleteBotLocaleOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let botVersion: Swift.String?
    let localeId: Swift.String?
    let botLocaleStatus: LexModelsV2ClientTypes.BotLocaleStatus?
}

extension DeleteBotLocaleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botLocaleStatus
        case botVersion
        case localeId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let botLocaleStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotLocaleStatus.self, forKey: .botLocaleStatus)
        botLocaleStatus = botLocaleStatusDecoded
    }
}

enum DeleteBotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteBotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteBotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botStatus = output.botStatus
        } else {
            self.botId = nil
            self.botStatus = nil
        }
    }
}

public struct DeleteBotOutputResponse: Swift.Equatable {
    /// The unique identifier of the bot that Amazon Lex is deleting.
    public var botId: Swift.String?
    /// The current status of the bot. The status is Deleting while the bot and its associated resources are being deleted.
    public var botStatus: LexModelsV2ClientTypes.BotStatus?

    public init(
        botId: Swift.String? = nil,
        botStatus: LexModelsV2ClientTypes.BotStatus? = nil
    )
    {
        self.botId = botId
        self.botStatus = botStatus
    }
}

struct DeleteBotOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let botStatus: LexModelsV2ClientTypes.BotStatus?
}

extension DeleteBotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotStatus.self, forKey: .botStatus)
        botStatus = botStatusDecoded
    }
}

extension DeleteBotVersionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let skipResourceInUseCheck = skipResourceInUseCheck {
                let skipResourceInUseCheckQueryItem = ClientRuntime.URLQueryItem(name: "skipResourceInUseCheck".urlPercentEncoding(), value: Swift.String(skipResourceInUseCheck).urlPercentEncoding())
                items.append(skipResourceInUseCheckQueryItem)
            }
            return items
        }
    }
}

extension DeleteBotVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botVersion = botVersion else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botversions/\(botVersion.urlPercentEncoding())"
    }
}

public struct DeleteBotVersionInput: Swift.Equatable {
    /// The identifier of the bot that contains the version.
    /// This member is required.
    public var botId: Swift.String?
    /// The version of the bot to delete.
    /// This member is required.
    public var botVersion: Swift.String?
    /// By default, Amazon Lex checks if any other resource, such as an alias or bot network, is using the bot version before it is deleted and throws a ResourceInUseException exception if the version is being used by another resource. Set this parameter to true to skip this check and remove the version even if it is being used by another resource.
    public var skipResourceInUseCheck: Swift.Bool?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        skipResourceInUseCheck: Swift.Bool? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.skipResourceInUseCheck = skipResourceInUseCheck
    }
}

struct DeleteBotVersionInputBody: Swift.Equatable {
}

extension DeleteBotVersionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum DeleteBotVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteBotVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteBotVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botStatus = output.botStatus
            self.botVersion = output.botVersion
        } else {
            self.botId = nil
            self.botStatus = nil
            self.botVersion = nil
        }
    }
}

public struct DeleteBotVersionOutputResponse: Swift.Equatable {
    /// The identifier of the bot that is being deleted.
    public var botId: Swift.String?
    /// The current status of the bot.
    public var botStatus: LexModelsV2ClientTypes.BotStatus?
    /// The version of the bot that is being deleted.
    public var botVersion: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botStatus: LexModelsV2ClientTypes.BotStatus? = nil,
        botVersion: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botStatus = botStatus
        self.botVersion = botVersion
    }
}

struct DeleteBotVersionOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let botVersion: Swift.String?
    let botStatus: LexModelsV2ClientTypes.BotStatus?
}

extension DeleteBotVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botStatus
        case botVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let botStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotStatus.self, forKey: .botStatus)
        botStatus = botStatusDecoded
    }
}

extension DeleteCustomVocabularyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botVersion = botVersion else {
            return nil
        }
        guard let localeId = localeId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botversions/\(botVersion.urlPercentEncoding())/botlocales/\(localeId.urlPercentEncoding())/customvocabulary"
    }
}

public struct DeleteCustomVocabularyInput: Swift.Equatable {
    /// The unique identifier of the bot to remove the custom vocabulary from.
    /// This member is required.
    public var botId: Swift.String?
    /// The version of the bot to remove the custom vocabulary from.
    /// This member is required.
    public var botVersion: Swift.String?
    /// The locale identifier for the locale that contains the custom vocabulary to remove.
    /// This member is required.
    public var localeId: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        localeId: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.localeId = localeId
    }
}

struct DeleteCustomVocabularyInputBody: Swift.Equatable {
}

extension DeleteCustomVocabularyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum DeleteCustomVocabularyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteCustomVocabularyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteCustomVocabularyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.customVocabularyStatus = output.customVocabularyStatus
            self.localeId = output.localeId
        } else {
            self.botId = nil
            self.botVersion = nil
            self.customVocabularyStatus = nil
            self.localeId = nil
        }
    }
}

public struct DeleteCustomVocabularyOutputResponse: Swift.Equatable {
    /// The identifier of the bot that the custom vocabulary was removed from.
    public var botId: Swift.String?
    /// The version of the bot that the custom vocabulary was removed from.
    public var botVersion: Swift.String?
    /// The status of removing the custom vocabulary.
    public var customVocabularyStatus: LexModelsV2ClientTypes.CustomVocabularyStatus?
    /// The locale identifier for the locale that the custom vocabulary was removed from.
    public var localeId: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        customVocabularyStatus: LexModelsV2ClientTypes.CustomVocabularyStatus? = nil,
        localeId: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.customVocabularyStatus = customVocabularyStatus
        self.localeId = localeId
    }
}

struct DeleteCustomVocabularyOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let botVersion: Swift.String?
    let localeId: Swift.String?
    let customVocabularyStatus: LexModelsV2ClientTypes.CustomVocabularyStatus?
}

extension DeleteCustomVocabularyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botVersion
        case customVocabularyStatus
        case localeId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let customVocabularyStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.CustomVocabularyStatus.self, forKey: .customVocabularyStatus)
        customVocabularyStatus = customVocabularyStatusDecoded
    }
}

extension DeleteExportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let exportId = exportId else {
            return nil
        }
        return "/exports/\(exportId.urlPercentEncoding())"
    }
}

public struct DeleteExportInput: Swift.Equatable {
    /// The unique identifier of the export to delete.
    /// This member is required.
    public var exportId: Swift.String?

    public init(
        exportId: Swift.String? = nil
    )
    {
        self.exportId = exportId
    }
}

struct DeleteExportInputBody: Swift.Equatable {
}

extension DeleteExportInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum DeleteExportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteExportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteExportOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.exportId = output.exportId
            self.exportStatus = output.exportStatus
        } else {
            self.exportId = nil
            self.exportStatus = nil
        }
    }
}

public struct DeleteExportOutputResponse: Swift.Equatable {
    /// The unique identifier of the deleted export.
    public var exportId: Swift.String?
    /// The current status of the deletion. When the deletion is complete, the export will no longer be returned by the [ListExports](https://docs.aws.amazon.com/lexv2/latest/APIReference/API_ListExports.html) operation and calls to the [ DescribeExport](https://docs.aws.amazon.com/lexv2/latest/APIReference/API_DescribeExport.html) operation with the export identifier will fail.
    public var exportStatus: LexModelsV2ClientTypes.ExportStatus?

    public init(
        exportId: Swift.String? = nil,
        exportStatus: LexModelsV2ClientTypes.ExportStatus? = nil
    )
    {
        self.exportId = exportId
        self.exportStatus = exportStatus
    }
}

struct DeleteExportOutputResponseBody: Swift.Equatable {
    let exportId: Swift.String?
    let exportStatus: LexModelsV2ClientTypes.ExportStatus?
}

extension DeleteExportOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportId
        case exportStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportId)
        exportId = exportIdDecoded
        let exportStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ExportStatus.self, forKey: .exportStatus)
        exportStatus = exportStatusDecoded
    }
}

extension DeleteImportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let importId = importId else {
            return nil
        }
        return "/imports/\(importId.urlPercentEncoding())"
    }
}

public struct DeleteImportInput: Swift.Equatable {
    /// The unique identifier of the import to delete.
    /// This member is required.
    public var importId: Swift.String?

    public init(
        importId: Swift.String? = nil
    )
    {
        self.importId = importId
    }
}

struct DeleteImportInputBody: Swift.Equatable {
}

extension DeleteImportInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum DeleteImportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteImportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteImportOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.importId = output.importId
            self.importStatus = output.importStatus
        } else {
            self.importId = nil
            self.importStatus = nil
        }
    }
}

public struct DeleteImportOutputResponse: Swift.Equatable {
    /// The unique identifier of the deleted import.
    public var importId: Swift.String?
    /// The current status of the deletion. When the deletion is complete, the import will no longer be returned by the [ListImports](https://docs.aws.amazon.com/lexv2/latest/APIReference/API_ListImports.html) operation and calls to the [DescribeImport](https://docs.aws.amazon.com/lexv2/latest/APIReference/API_DescribeImport.html) operation with the import identifier will fail.
    public var importStatus: LexModelsV2ClientTypes.ImportStatus?

    public init(
        importId: Swift.String? = nil,
        importStatus: LexModelsV2ClientTypes.ImportStatus? = nil
    )
    {
        self.importId = importId
        self.importStatus = importStatus
    }
}

struct DeleteImportOutputResponseBody: Swift.Equatable {
    let importId: Swift.String?
    let importStatus: LexModelsV2ClientTypes.ImportStatus?
}

extension DeleteImportOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importId
        case importStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importId)
        importId = importIdDecoded
        let importStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ImportStatus.self, forKey: .importStatus)
        importStatus = importStatusDecoded
    }
}

extension DeleteIntentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botVersion = botVersion else {
            return nil
        }
        guard let localeId = localeId else {
            return nil
        }
        guard let intentId = intentId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botversions/\(botVersion.urlPercentEncoding())/botlocales/\(localeId.urlPercentEncoding())/intents/\(intentId.urlPercentEncoding())"
    }
}

public struct DeleteIntentInput: Swift.Equatable {
    /// The identifier of the bot associated with the intent.
    /// This member is required.
    public var botId: Swift.String?
    /// The version of the bot associated with the intent.
    /// This member is required.
    public var botVersion: Swift.String?
    /// The unique identifier of the intent to delete.
    /// This member is required.
    public var intentId: Swift.String?
    /// The identifier of the language and locale where the bot will be deleted. The string must match one of the supported locales. For more information, see [Supported languages](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html).
    /// This member is required.
    public var localeId: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        intentId: Swift.String? = nil,
        localeId: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.intentId = intentId
        self.localeId = localeId
    }
}

struct DeleteIntentInputBody: Swift.Equatable {
}

extension DeleteIntentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum DeleteIntentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteIntentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteIntentOutputResponse: Swift.Equatable {

    public init() { }
}

extension DeleteResourcePolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let expectedRevisionId = expectedRevisionId {
                let expectedRevisionIdQueryItem = ClientRuntime.URLQueryItem(name: "expectedRevisionId".urlPercentEncoding(), value: Swift.String(expectedRevisionId).urlPercentEncoding())
                items.append(expectedRevisionIdQueryItem)
            }
            return items
        }
    }
}

extension DeleteResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/policy/\(resourceArn.urlPercentEncoding())"
    }
}

public struct DeleteResourcePolicyInput: Swift.Equatable {
    /// The identifier of the revision to edit. If this ID doesn't match the current revision number, Amazon Lex returns an exception If you don't specify a revision ID, Amazon Lex will delete the current policy.
    public var expectedRevisionId: Swift.String?
    /// The Amazon Resource Name (ARN) of the bot or bot alias that has the resource policy attached.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        expectedRevisionId: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.expectedRevisionId = expectedRevisionId
        self.resourceArn = resourceArn
    }
}

struct DeleteResourcePolicyInputBody: Swift.Equatable {
}

extension DeleteResourcePolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum DeleteResourcePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteResourcePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteResourcePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceArn = output.resourceArn
            self.revisionId = output.revisionId
        } else {
            self.resourceArn = nil
            self.revisionId = nil
        }
    }
}

public struct DeleteResourcePolicyOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the bot or bot alias that the resource policy was deleted from.
    public var resourceArn: Swift.String?
    /// The current revision of the resource policy. Use the revision ID to make sure that you are updating the most current version of a resource policy when you add a policy statement to a resource, delete a resource, or update a resource.
    public var revisionId: Swift.String?

    public init(
        resourceArn: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
        self.revisionId = revisionId
    }
}

struct DeleteResourcePolicyOutputResponseBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let revisionId: Swift.String?
}

extension DeleteResourcePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case revisionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension DeleteResourcePolicyStatementInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let expectedRevisionId = expectedRevisionId {
                let expectedRevisionIdQueryItem = ClientRuntime.URLQueryItem(name: "expectedRevisionId".urlPercentEncoding(), value: Swift.String(expectedRevisionId).urlPercentEncoding())
                items.append(expectedRevisionIdQueryItem)
            }
            return items
        }
    }
}

extension DeleteResourcePolicyStatementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        guard let statementId = statementId else {
            return nil
        }
        return "/policy/\(resourceArn.urlPercentEncoding())/statements/\(statementId.urlPercentEncoding())"
    }
}

public struct DeleteResourcePolicyStatementInput: Swift.Equatable {
    /// The identifier of the revision of the policy to delete the statement from. If this revision ID doesn't match the current revision ID, Amazon Lex throws an exception. If you don't specify a revision, Amazon Lex removes the current contents of the statement.
    public var expectedRevisionId: Swift.String?
    /// The Amazon Resource Name (ARN) of the bot or bot alias that the resource policy is attached to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The name of the statement (SID) to delete from the policy.
    /// This member is required.
    public var statementId: Swift.String?

    public init(
        expectedRevisionId: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        statementId: Swift.String? = nil
    )
    {
        self.expectedRevisionId = expectedRevisionId
        self.resourceArn = resourceArn
        self.statementId = statementId
    }
}

struct DeleteResourcePolicyStatementInputBody: Swift.Equatable {
}

extension DeleteResourcePolicyStatementInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum DeleteResourcePolicyStatementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteResourcePolicyStatementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteResourcePolicyStatementOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceArn = output.resourceArn
            self.revisionId = output.revisionId
        } else {
            self.resourceArn = nil
            self.revisionId = nil
        }
    }
}

public struct DeleteResourcePolicyStatementOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the bot or bot alias that the resource policy statement was removed from.
    public var resourceArn: Swift.String?
    /// The current revision of the resource policy. Use the revision ID to make sure that you are updating the most current version of a resource policy when you add a policy statement to a resource, delete a resource, or update a resource.
    public var revisionId: Swift.String?

    public init(
        resourceArn: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
        self.revisionId = revisionId
    }
}

struct DeleteResourcePolicyStatementOutputResponseBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let revisionId: Swift.String?
}

extension DeleteResourcePolicyStatementOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case revisionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension DeleteSlotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botVersion = botVersion else {
            return nil
        }
        guard let localeId = localeId else {
            return nil
        }
        guard let intentId = intentId else {
            return nil
        }
        guard let slotId = slotId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botversions/\(botVersion.urlPercentEncoding())/botlocales/\(localeId.urlPercentEncoding())/intents/\(intentId.urlPercentEncoding())/slots/\(slotId.urlPercentEncoding())"
    }
}

public struct DeleteSlotInput: Swift.Equatable {
    /// The identifier of the bot associated with the slot to delete.
    /// This member is required.
    public var botId: Swift.String?
    /// The version of the bot associated with the slot to delete.
    /// This member is required.
    public var botVersion: Swift.String?
    /// The identifier of the intent associated with the slot.
    /// This member is required.
    public var intentId: Swift.String?
    /// The identifier of the language and locale that the slot will be deleted from. The string must match one of the supported locales. For more information, see [Supported languages](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html).
    /// This member is required.
    public var localeId: Swift.String?
    /// The identifier of the slot to delete.
    /// This member is required.
    public var slotId: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        intentId: Swift.String? = nil,
        localeId: Swift.String? = nil,
        slotId: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.intentId = intentId
        self.localeId = localeId
        self.slotId = slotId
    }
}

struct DeleteSlotInputBody: Swift.Equatable {
}

extension DeleteSlotInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum DeleteSlotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSlotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSlotOutputResponse: Swift.Equatable {

    public init() { }
}

extension DeleteSlotTypeInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let skipResourceInUseCheck = skipResourceInUseCheck {
                let skipResourceInUseCheckQueryItem = ClientRuntime.URLQueryItem(name: "skipResourceInUseCheck".urlPercentEncoding(), value: Swift.String(skipResourceInUseCheck).urlPercentEncoding())
                items.append(skipResourceInUseCheckQueryItem)
            }
            return items
        }
    }
}

extension DeleteSlotTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botVersion = botVersion else {
            return nil
        }
        guard let localeId = localeId else {
            return nil
        }
        guard let slotTypeId = slotTypeId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botversions/\(botVersion.urlPercentEncoding())/botlocales/\(localeId.urlPercentEncoding())/slottypes/\(slotTypeId.urlPercentEncoding())"
    }
}

public struct DeleteSlotTypeInput: Swift.Equatable {
    /// The identifier of the bot associated with the slot type.
    /// This member is required.
    public var botId: Swift.String?
    /// The version of the bot associated with the slot type.
    /// This member is required.
    public var botVersion: Swift.String?
    /// The identifier of the language and locale that the slot type will be deleted from. The string must match one of the supported locales. For more information, see [Supported languages](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html).
    /// This member is required.
    public var localeId: Swift.String?
    /// By default, the DeleteSlotType operations throws a ResourceInUseException exception if you try to delete a slot type used by a slot. Set the skipResourceInUseCheck parameter to true to skip this check and remove the slot type even if a slot uses it.
    public var skipResourceInUseCheck: Swift.Bool?
    /// The identifier of the slot type to delete.
    /// This member is required.
    public var slotTypeId: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        localeId: Swift.String? = nil,
        skipResourceInUseCheck: Swift.Bool? = nil,
        slotTypeId: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.localeId = localeId
        self.skipResourceInUseCheck = skipResourceInUseCheck
        self.slotTypeId = slotTypeId
    }
}

struct DeleteSlotTypeInputBody: Swift.Equatable {
}

extension DeleteSlotTypeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum DeleteSlotTypeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSlotTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSlotTypeOutputResponse: Swift.Equatable {

    public init() { }
}

extension DeleteTestSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let testSetId = testSetId else {
            return nil
        }
        return "/testsets/\(testSetId.urlPercentEncoding())"
    }
}

public struct DeleteTestSetInput: Swift.Equatable {
    /// The test set Id of the test set to be deleted.
    /// This member is required.
    public var testSetId: Swift.String?

    public init(
        testSetId: Swift.String? = nil
    )
    {
        self.testSetId = testSetId
    }
}

struct DeleteTestSetInputBody: Swift.Equatable {
}

extension DeleteTestSetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum DeleteTestSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteTestSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteTestSetOutputResponse: Swift.Equatable {

    public init() { }
}

extension DeleteUtterancesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let sessionId = sessionId {
                let sessionIdQueryItem = ClientRuntime.URLQueryItem(name: "sessionId".urlPercentEncoding(), value: Swift.String(sessionId).urlPercentEncoding())
                items.append(sessionIdQueryItem)
            }
            if let localeId = localeId {
                let localeIdQueryItem = ClientRuntime.URLQueryItem(name: "localeId".urlPercentEncoding(), value: Swift.String(localeId).urlPercentEncoding())
                items.append(localeIdQueryItem)
            }
            return items
        }
    }
}

extension DeleteUtterancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/utterances"
    }
}

public struct DeleteUtterancesInput: Swift.Equatable {
    /// The unique identifier of the bot that contains the utterances.
    /// This member is required.
    public var botId: Swift.String?
    /// The identifier of the language and locale where the utterances were collected. The string must match one of the supported locales. For more information, see [Supported languages](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html).
    public var localeId: Swift.String?
    /// The unique identifier of the session with the user. The ID is returned in the response from the [RecognizeText](https://docs.aws.amazon.com/lexv2/latest/APIReference/API_runtime_RecognizeText.html) and [RecognizeUtterance](https://docs.aws.amazon.com/lexv2/latest/APIReference/API_runtime_RecognizeUtterance.html) operations.
    public var sessionId: Swift.String?

    public init(
        botId: Swift.String? = nil,
        localeId: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.botId = botId
        self.localeId = localeId
        self.sessionId = sessionId
    }
}

struct DeleteUtterancesInputBody: Swift.Equatable {
}

extension DeleteUtterancesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum DeleteUtterancesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteUtterancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteUtterancesOutputResponse: Swift.Equatable {

    public init() { }
}

extension DescribeBotAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botAliasId = botAliasId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botaliases/\(botAliasId.urlPercentEncoding())"
    }
}

public struct DescribeBotAliasInput: Swift.Equatable {
    /// The identifier of the bot alias to describe.
    /// This member is required.
    public var botAliasId: Swift.String?
    /// The identifier of the bot associated with the bot alias to describe.
    /// This member is required.
    public var botId: Swift.String?

    public init(
        botAliasId: Swift.String? = nil,
        botId: Swift.String? = nil
    )
    {
        self.botAliasId = botAliasId
        self.botId = botId
    }
}

struct DescribeBotAliasInputBody: Swift.Equatable {
}

extension DescribeBotAliasInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum DescribeBotAliasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeBotAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeBotAliasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botAliasHistoryEvents = output.botAliasHistoryEvents
            self.botAliasId = output.botAliasId
            self.botAliasLocaleSettings = output.botAliasLocaleSettings
            self.botAliasName = output.botAliasName
            self.botAliasStatus = output.botAliasStatus
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.conversationLogSettings = output.conversationLogSettings
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.lastUpdatedDateTime = output.lastUpdatedDateTime
            self.parentBotNetworks = output.parentBotNetworks
            self.sentimentAnalysisSettings = output.sentimentAnalysisSettings
        } else {
            self.botAliasHistoryEvents = nil
            self.botAliasId = nil
            self.botAliasLocaleSettings = nil
            self.botAliasName = nil
            self.botAliasStatus = nil
            self.botId = nil
            self.botVersion = nil
            self.conversationLogSettings = nil
            self.creationDateTime = nil
            self.description = nil
            self.lastUpdatedDateTime = nil
            self.parentBotNetworks = nil
            self.sentimentAnalysisSettings = nil
        }
    }
}

public struct DescribeBotAliasOutputResponse: Swift.Equatable {
    /// A list of events that affect a bot alias. For example, an event is recorded when the version that the alias points to changes.
    public var botAliasHistoryEvents: [LexModelsV2ClientTypes.BotAliasHistoryEvent]?
    /// The identifier of the bot alias.
    public var botAliasId: Swift.String?
    /// The locale settings that are unique to the alias.
    public var botAliasLocaleSettings: [Swift.String:LexModelsV2ClientTypes.BotAliasLocaleSettings]?
    /// The name of the bot alias.
    public var botAliasName: Swift.String?
    /// The current status of the alias. When the alias is Available, the alias is ready for use with your bot.
    public var botAliasStatus: LexModelsV2ClientTypes.BotAliasStatus?
    /// The identifier of the bot associated with the bot alias.
    public var botId: Swift.String?
    /// The version of the bot associated with the bot alias.
    public var botVersion: Swift.String?
    /// Specifics of how Amazon Lex logs text and audio conversations with the bot associated with the alias.
    public var conversationLogSettings: LexModelsV2ClientTypes.ConversationLogSettings?
    /// A timestamp of the date and time that the alias was created.
    public var creationDateTime: ClientRuntime.Date?
    /// The description of the bot alias.
    public var description: Swift.String?
    /// A timestamp of the date and time that the alias was last updated.
    public var lastUpdatedDateTime: ClientRuntime.Date?
    /// A list of the networks to which the bot alias you described belongs.
    public var parentBotNetworks: [LexModelsV2ClientTypes.ParentBotNetwork]?
    /// Determines whether Amazon Lex will use Amazon Comprehend to detect the sentiment of user utterances.
    public var sentimentAnalysisSettings: LexModelsV2ClientTypes.SentimentAnalysisSettings?

    public init(
        botAliasHistoryEvents: [LexModelsV2ClientTypes.BotAliasHistoryEvent]? = nil,
        botAliasId: Swift.String? = nil,
        botAliasLocaleSettings: [Swift.String:LexModelsV2ClientTypes.BotAliasLocaleSettings]? = nil,
        botAliasName: Swift.String? = nil,
        botAliasStatus: LexModelsV2ClientTypes.BotAliasStatus? = nil,
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        conversationLogSettings: LexModelsV2ClientTypes.ConversationLogSettings? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        lastUpdatedDateTime: ClientRuntime.Date? = nil,
        parentBotNetworks: [LexModelsV2ClientTypes.ParentBotNetwork]? = nil,
        sentimentAnalysisSettings: LexModelsV2ClientTypes.SentimentAnalysisSettings? = nil
    )
    {
        self.botAliasHistoryEvents = botAliasHistoryEvents
        self.botAliasId = botAliasId
        self.botAliasLocaleSettings = botAliasLocaleSettings
        self.botAliasName = botAliasName
        self.botAliasStatus = botAliasStatus
        self.botId = botId
        self.botVersion = botVersion
        self.conversationLogSettings = conversationLogSettings
        self.creationDateTime = creationDateTime
        self.description = description
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.parentBotNetworks = parentBotNetworks
        self.sentimentAnalysisSettings = sentimentAnalysisSettings
    }
}

struct DescribeBotAliasOutputResponseBody: Swift.Equatable {
    let botAliasId: Swift.String?
    let botAliasName: Swift.String?
    let description: Swift.String?
    let botVersion: Swift.String?
    let botAliasLocaleSettings: [Swift.String:LexModelsV2ClientTypes.BotAliasLocaleSettings]?
    let conversationLogSettings: LexModelsV2ClientTypes.ConversationLogSettings?
    let sentimentAnalysisSettings: LexModelsV2ClientTypes.SentimentAnalysisSettings?
    let botAliasHistoryEvents: [LexModelsV2ClientTypes.BotAliasHistoryEvent]?
    let botAliasStatus: LexModelsV2ClientTypes.BotAliasStatus?
    let botId: Swift.String?
    let creationDateTime: ClientRuntime.Date?
    let lastUpdatedDateTime: ClientRuntime.Date?
    let parentBotNetworks: [LexModelsV2ClientTypes.ParentBotNetwork]?
}

extension DescribeBotAliasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botAliasHistoryEvents
        case botAliasId
        case botAliasLocaleSettings
        case botAliasName
        case botAliasStatus
        case botId
        case botVersion
        case conversationLogSettings
        case creationDateTime
        case description
        case lastUpdatedDateTime
        case parentBotNetworks
        case sentimentAnalysisSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botAliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botAliasId)
        botAliasId = botAliasIdDecoded
        let botAliasNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botAliasName)
        botAliasName = botAliasNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let botAliasLocaleSettingsContainer = try containerValues.decodeIfPresent([Swift.String: LexModelsV2ClientTypes.BotAliasLocaleSettings?].self, forKey: .botAliasLocaleSettings)
        var botAliasLocaleSettingsDecoded0: [Swift.String:LexModelsV2ClientTypes.BotAliasLocaleSettings]? = nil
        if let botAliasLocaleSettingsContainer = botAliasLocaleSettingsContainer {
            botAliasLocaleSettingsDecoded0 = [Swift.String:LexModelsV2ClientTypes.BotAliasLocaleSettings]()
            for (key0, botaliaslocalesettings0) in botAliasLocaleSettingsContainer {
                if let botaliaslocalesettings0 = botaliaslocalesettings0 {
                    botAliasLocaleSettingsDecoded0?[key0] = botaliaslocalesettings0
                }
            }
        }
        botAliasLocaleSettings = botAliasLocaleSettingsDecoded0
        let conversationLogSettingsDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ConversationLogSettings.self, forKey: .conversationLogSettings)
        conversationLogSettings = conversationLogSettingsDecoded
        let sentimentAnalysisSettingsDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SentimentAnalysisSettings.self, forKey: .sentimentAnalysisSettings)
        sentimentAnalysisSettings = sentimentAnalysisSettingsDecoded
        let botAliasHistoryEventsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.BotAliasHistoryEvent?].self, forKey: .botAliasHistoryEvents)
        var botAliasHistoryEventsDecoded0:[LexModelsV2ClientTypes.BotAliasHistoryEvent]? = nil
        if let botAliasHistoryEventsContainer = botAliasHistoryEventsContainer {
            botAliasHistoryEventsDecoded0 = [LexModelsV2ClientTypes.BotAliasHistoryEvent]()
            for structure0 in botAliasHistoryEventsContainer {
                if let structure0 = structure0 {
                    botAliasHistoryEventsDecoded0?.append(structure0)
                }
            }
        }
        botAliasHistoryEvents = botAliasHistoryEventsDecoded0
        let botAliasStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotAliasStatus.self, forKey: .botAliasStatus)
        botAliasStatus = botAliasStatusDecoded
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let parentBotNetworksContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.ParentBotNetwork?].self, forKey: .parentBotNetworks)
        var parentBotNetworksDecoded0:[LexModelsV2ClientTypes.ParentBotNetwork]? = nil
        if let parentBotNetworksContainer = parentBotNetworksContainer {
            parentBotNetworksDecoded0 = [LexModelsV2ClientTypes.ParentBotNetwork]()
            for structure0 in parentBotNetworksContainer {
                if let structure0 = structure0 {
                    parentBotNetworksDecoded0?.append(structure0)
                }
            }
        }
        parentBotNetworks = parentBotNetworksDecoded0
    }
}

extension DescribeBotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())"
    }
}

public struct DescribeBotInput: Swift.Equatable {
    /// The unique identifier of the bot to describe.
    /// This member is required.
    public var botId: Swift.String?

    public init(
        botId: Swift.String? = nil
    )
    {
        self.botId = botId
    }
}

struct DescribeBotInputBody: Swift.Equatable {
}

extension DescribeBotInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeBotLocaleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botVersion = botVersion else {
            return nil
        }
        guard let localeId = localeId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botversions/\(botVersion.urlPercentEncoding())/botlocales/\(localeId.urlPercentEncoding())"
    }
}

public struct DescribeBotLocaleInput: Swift.Equatable {
    /// The identifier of the bot associated with the locale.
    /// This member is required.
    public var botId: Swift.String?
    /// The version of the bot associated with the locale.
    /// This member is required.
    public var botVersion: Swift.String?
    /// The unique identifier of the locale to describe. The string must match one of the supported locales. For more information, see [Supported languages](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html).
    /// This member is required.
    public var localeId: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        localeId: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.localeId = localeId
    }
}

struct DescribeBotLocaleInputBody: Swift.Equatable {
}

extension DescribeBotLocaleInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum DescribeBotLocaleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeBotLocaleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeBotLocaleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botLocaleHistoryEvents = output.botLocaleHistoryEvents
            self.botLocaleStatus = output.botLocaleStatus
            self.botVersion = output.botVersion
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.failureReasons = output.failureReasons
            self.intentsCount = output.intentsCount
            self.lastBuildSubmittedDateTime = output.lastBuildSubmittedDateTime
            self.lastUpdatedDateTime = output.lastUpdatedDateTime
            self.localeId = output.localeId
            self.localeName = output.localeName
            self.nluIntentConfidenceThreshold = output.nluIntentConfidenceThreshold
            self.recommendedActions = output.recommendedActions
            self.slotTypesCount = output.slotTypesCount
            self.voiceSettings = output.voiceSettings
        } else {
            self.botId = nil
            self.botLocaleHistoryEvents = nil
            self.botLocaleStatus = nil
            self.botVersion = nil
            self.creationDateTime = nil
            self.description = nil
            self.failureReasons = nil
            self.intentsCount = nil
            self.lastBuildSubmittedDateTime = nil
            self.lastUpdatedDateTime = nil
            self.localeId = nil
            self.localeName = nil
            self.nluIntentConfidenceThreshold = nil
            self.recommendedActions = nil
            self.slotTypesCount = nil
            self.voiceSettings = nil
        }
    }
}

public struct DescribeBotLocaleOutputResponse: Swift.Equatable {
    /// The identifier of the bot associated with the locale.
    public var botId: Swift.String?
    /// History of changes, such as when a locale is used in an alias, that have taken place for the locale.
    public var botLocaleHistoryEvents: [LexModelsV2ClientTypes.BotLocaleHistoryEvent]?
    /// The status of the bot. If the status is Failed, the reasons for the failure are listed in the failureReasons field.
    public var botLocaleStatus: LexModelsV2ClientTypes.BotLocaleStatus?
    /// The version of the bot associated with the locale.
    public var botVersion: Swift.String?
    /// The date and time that the locale was created.
    public var creationDateTime: ClientRuntime.Date?
    /// The description of the locale.
    public var description: Swift.String?
    /// if botLocaleStatus is Failed, Amazon Lex explains why it failed to build the bot.
    public var failureReasons: [Swift.String]?
    /// The number of intents defined for the locale.
    public var intentsCount: Swift.Int?
    /// The date and time that the locale was last submitted for building.
    public var lastBuildSubmittedDateTime: ClientRuntime.Date?
    /// The date and time that the locale was last updated.
    public var lastUpdatedDateTime: ClientRuntime.Date?
    /// The unique identifier of the described locale.
    public var localeId: Swift.String?
    /// The name of the locale.
    public var localeName: Swift.String?
    /// The confidence threshold where Amazon Lex inserts the AMAZON.FallbackIntent and AMAZON.KendraSearchIntent intents in the list of possible intents for an utterance.
    public var nluIntentConfidenceThreshold: Swift.Double?
    /// Recommended actions to take to resolve an error in the failureReasons field.
    public var recommendedActions: [Swift.String]?
    /// The number of slot types defined for the locale.
    public var slotTypesCount: Swift.Int?
    /// The Amazon Polly voice Amazon Lex uses for voice interaction with the user.
    public var voiceSettings: LexModelsV2ClientTypes.VoiceSettings?

    public init(
        botId: Swift.String? = nil,
        botLocaleHistoryEvents: [LexModelsV2ClientTypes.BotLocaleHistoryEvent]? = nil,
        botLocaleStatus: LexModelsV2ClientTypes.BotLocaleStatus? = nil,
        botVersion: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        failureReasons: [Swift.String]? = nil,
        intentsCount: Swift.Int? = nil,
        lastBuildSubmittedDateTime: ClientRuntime.Date? = nil,
        lastUpdatedDateTime: ClientRuntime.Date? = nil,
        localeId: Swift.String? = nil,
        localeName: Swift.String? = nil,
        nluIntentConfidenceThreshold: Swift.Double? = nil,
        recommendedActions: [Swift.String]? = nil,
        slotTypesCount: Swift.Int? = nil,
        voiceSettings: LexModelsV2ClientTypes.VoiceSettings? = nil
    )
    {
        self.botId = botId
        self.botLocaleHistoryEvents = botLocaleHistoryEvents
        self.botLocaleStatus = botLocaleStatus
        self.botVersion = botVersion
        self.creationDateTime = creationDateTime
        self.description = description
        self.failureReasons = failureReasons
        self.intentsCount = intentsCount
        self.lastBuildSubmittedDateTime = lastBuildSubmittedDateTime
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.localeId = localeId
        self.localeName = localeName
        self.nluIntentConfidenceThreshold = nluIntentConfidenceThreshold
        self.recommendedActions = recommendedActions
        self.slotTypesCount = slotTypesCount
        self.voiceSettings = voiceSettings
    }
}

struct DescribeBotLocaleOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let botVersion: Swift.String?
    let localeId: Swift.String?
    let localeName: Swift.String?
    let description: Swift.String?
    let nluIntentConfidenceThreshold: Swift.Double?
    let voiceSettings: LexModelsV2ClientTypes.VoiceSettings?
    let intentsCount: Swift.Int?
    let slotTypesCount: Swift.Int?
    let botLocaleStatus: LexModelsV2ClientTypes.BotLocaleStatus?
    let failureReasons: [Swift.String]?
    let creationDateTime: ClientRuntime.Date?
    let lastUpdatedDateTime: ClientRuntime.Date?
    let lastBuildSubmittedDateTime: ClientRuntime.Date?
    let botLocaleHistoryEvents: [LexModelsV2ClientTypes.BotLocaleHistoryEvent]?
    let recommendedActions: [Swift.String]?
}

extension DescribeBotLocaleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botLocaleHistoryEvents
        case botLocaleStatus
        case botVersion
        case creationDateTime
        case description
        case failureReasons
        case intentsCount
        case lastBuildSubmittedDateTime
        case lastUpdatedDateTime
        case localeId
        case localeName
        case nluIntentConfidenceThreshold
        case recommendedActions
        case slotTypesCount
        case voiceSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let localeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeName)
        localeName = localeNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nluIntentConfidenceThresholdDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .nluIntentConfidenceThreshold)
        nluIntentConfidenceThreshold = nluIntentConfidenceThresholdDecoded
        let voiceSettingsDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.VoiceSettings.self, forKey: .voiceSettings)
        voiceSettings = voiceSettingsDecoded
        let intentsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .intentsCount)
        intentsCount = intentsCountDecoded
        let slotTypesCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .slotTypesCount)
        slotTypesCount = slotTypesCountDecoded
        let botLocaleStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotLocaleStatus.self, forKey: .botLocaleStatus)
        botLocaleStatus = botLocaleStatusDecoded
        let failureReasonsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .failureReasons)
        var failureReasonsDecoded0:[Swift.String]? = nil
        if let failureReasonsContainer = failureReasonsContainer {
            failureReasonsDecoded0 = [Swift.String]()
            for string0 in failureReasonsContainer {
                if let string0 = string0 {
                    failureReasonsDecoded0?.append(string0)
                }
            }
        }
        failureReasons = failureReasonsDecoded0
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let lastBuildSubmittedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastBuildSubmittedDateTime)
        lastBuildSubmittedDateTime = lastBuildSubmittedDateTimeDecoded
        let botLocaleHistoryEventsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.BotLocaleHistoryEvent?].self, forKey: .botLocaleHistoryEvents)
        var botLocaleHistoryEventsDecoded0:[LexModelsV2ClientTypes.BotLocaleHistoryEvent]? = nil
        if let botLocaleHistoryEventsContainer = botLocaleHistoryEventsContainer {
            botLocaleHistoryEventsDecoded0 = [LexModelsV2ClientTypes.BotLocaleHistoryEvent]()
            for structure0 in botLocaleHistoryEventsContainer {
                if let structure0 = structure0 {
                    botLocaleHistoryEventsDecoded0?.append(structure0)
                }
            }
        }
        botLocaleHistoryEvents = botLocaleHistoryEventsDecoded0
        let recommendedActionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .recommendedActions)
        var recommendedActionsDecoded0:[Swift.String]? = nil
        if let recommendedActionsContainer = recommendedActionsContainer {
            recommendedActionsDecoded0 = [Swift.String]()
            for string0 in recommendedActionsContainer {
                if let string0 = string0 {
                    recommendedActionsDecoded0?.append(string0)
                }
            }
        }
        recommendedActions = recommendedActionsDecoded0
    }
}

enum DescribeBotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeBotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeBotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botMembers = output.botMembers
            self.botName = output.botName
            self.botStatus = output.botStatus
            self.botType = output.botType
            self.creationDateTime = output.creationDateTime
            self.dataPrivacy = output.dataPrivacy
            self.description = output.description
            self.failureReasons = output.failureReasons
            self.idleSessionTTLInSeconds = output.idleSessionTTLInSeconds
            self.lastUpdatedDateTime = output.lastUpdatedDateTime
            self.roleArn = output.roleArn
        } else {
            self.botId = nil
            self.botMembers = nil
            self.botName = nil
            self.botStatus = nil
            self.botType = nil
            self.creationDateTime = nil
            self.dataPrivacy = nil
            self.description = nil
            self.failureReasons = nil
            self.idleSessionTTLInSeconds = nil
            self.lastUpdatedDateTime = nil
            self.roleArn = nil
        }
    }
}

public struct DescribeBotOutputResponse: Swift.Equatable {
    /// The unique identifier of the bot.
    public var botId: Swift.String?
    /// The list of bots in the network that was described.
    public var botMembers: [LexModelsV2ClientTypes.BotMember]?
    /// The name of the bot.
    public var botName: Swift.String?
    /// The current status of the bot. When the status is Available the bot is ready to be used in conversations with users.
    public var botStatus: LexModelsV2ClientTypes.BotStatus?
    /// The type of the bot that was described.
    public var botType: LexModelsV2ClientTypes.BotType?
    /// A timestamp of the date and time that the bot was created.
    public var creationDateTime: ClientRuntime.Date?
    /// Settings for managing data privacy of the bot and its conversations with users.
    public var dataPrivacy: LexModelsV2ClientTypes.DataPrivacy?
    /// The description of the bot.
    public var description: Swift.String?
    /// If the botStatus is Failed, this contains a list of reasons that the bot couldn't be built.
    public var failureReasons: [Swift.String]?
    /// The maximum time in seconds that Amazon Lex retains the data gathered in a conversation.
    public var idleSessionTTLInSeconds: Swift.Int?
    /// A timestamp of the date and time that the bot was last updated.
    public var lastUpdatedDateTime: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of an IAM role that has permission to access the bot.
    public var roleArn: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botMembers: [LexModelsV2ClientTypes.BotMember]? = nil,
        botName: Swift.String? = nil,
        botStatus: LexModelsV2ClientTypes.BotStatus? = nil,
        botType: LexModelsV2ClientTypes.BotType? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        dataPrivacy: LexModelsV2ClientTypes.DataPrivacy? = nil,
        description: Swift.String? = nil,
        failureReasons: [Swift.String]? = nil,
        idleSessionTTLInSeconds: Swift.Int? = nil,
        lastUpdatedDateTime: ClientRuntime.Date? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botMembers = botMembers
        self.botName = botName
        self.botStatus = botStatus
        self.botType = botType
        self.creationDateTime = creationDateTime
        self.dataPrivacy = dataPrivacy
        self.description = description
        self.failureReasons = failureReasons
        self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.roleArn = roleArn
    }
}

struct DescribeBotOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let botName: Swift.String?
    let description: Swift.String?
    let roleArn: Swift.String?
    let dataPrivacy: LexModelsV2ClientTypes.DataPrivacy?
    let idleSessionTTLInSeconds: Swift.Int?
    let botStatus: LexModelsV2ClientTypes.BotStatus?
    let creationDateTime: ClientRuntime.Date?
    let lastUpdatedDateTime: ClientRuntime.Date?
    let botType: LexModelsV2ClientTypes.BotType?
    let botMembers: [LexModelsV2ClientTypes.BotMember]?
    let failureReasons: [Swift.String]?
}

extension DescribeBotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botMembers
        case botName
        case botStatus
        case botType
        case creationDateTime
        case dataPrivacy
        case description
        case failureReasons
        case idleSessionTTLInSeconds
        case lastUpdatedDateTime
        case roleArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botName)
        botName = botNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let dataPrivacyDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.DataPrivacy.self, forKey: .dataPrivacy)
        dataPrivacy = dataPrivacyDecoded
        let idleSessionTTLInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleSessionTTLInSeconds)
        idleSessionTTLInSeconds = idleSessionTTLInSecondsDecoded
        let botStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotStatus.self, forKey: .botStatus)
        botStatus = botStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let botTypeDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotType.self, forKey: .botType)
        botType = botTypeDecoded
        let botMembersContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.BotMember?].self, forKey: .botMembers)
        var botMembersDecoded0:[LexModelsV2ClientTypes.BotMember]? = nil
        if let botMembersContainer = botMembersContainer {
            botMembersDecoded0 = [LexModelsV2ClientTypes.BotMember]()
            for structure0 in botMembersContainer {
                if let structure0 = structure0 {
                    botMembersDecoded0?.append(structure0)
                }
            }
        }
        botMembers = botMembersDecoded0
        let failureReasonsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .failureReasons)
        var failureReasonsDecoded0:[Swift.String]? = nil
        if let failureReasonsContainer = failureReasonsContainer {
            failureReasonsDecoded0 = [Swift.String]()
            for string0 in failureReasonsContainer {
                if let string0 = string0 {
                    failureReasonsDecoded0?.append(string0)
                }
            }
        }
        failureReasons = failureReasonsDecoded0
    }
}

extension DescribeBotRecommendationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botVersion = botVersion else {
            return nil
        }
        guard let localeId = localeId else {
            return nil
        }
        guard let botRecommendationId = botRecommendationId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botversions/\(botVersion.urlPercentEncoding())/botlocales/\(localeId.urlPercentEncoding())/botrecommendations/\(botRecommendationId.urlPercentEncoding())"
    }
}

public struct DescribeBotRecommendationInput: Swift.Equatable {
    /// The unique identifier of the bot associated with the bot recommendation.
    /// This member is required.
    public var botId: Swift.String?
    /// The identifier of the bot recommendation to describe.
    /// This member is required.
    public var botRecommendationId: Swift.String?
    /// The version of the bot associated with the bot recommendation.
    /// This member is required.
    public var botVersion: Swift.String?
    /// The identifier of the language and locale of the bot recommendation to describe. The string must match one of the supported locales. For more information, see [Supported languages](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html).
    /// This member is required.
    public var localeId: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botRecommendationId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        localeId: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botRecommendationId = botRecommendationId
        self.botVersion = botVersion
        self.localeId = localeId
    }
}

struct DescribeBotRecommendationInputBody: Swift.Equatable {
}

extension DescribeBotRecommendationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum DescribeBotRecommendationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeBotRecommendationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeBotRecommendationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botRecommendationId = output.botRecommendationId
            self.botRecommendationResults = output.botRecommendationResults
            self.botRecommendationStatus = output.botRecommendationStatus
            self.botVersion = output.botVersion
            self.creationDateTime = output.creationDateTime
            self.encryptionSetting = output.encryptionSetting
            self.failureReasons = output.failureReasons
            self.lastUpdatedDateTime = output.lastUpdatedDateTime
            self.localeId = output.localeId
            self.transcriptSourceSetting = output.transcriptSourceSetting
        } else {
            self.botId = nil
            self.botRecommendationId = nil
            self.botRecommendationResults = nil
            self.botRecommendationStatus = nil
            self.botVersion = nil
            self.creationDateTime = nil
            self.encryptionSetting = nil
            self.failureReasons = nil
            self.lastUpdatedDateTime = nil
            self.localeId = nil
            self.transcriptSourceSetting = nil
        }
    }
}

public struct DescribeBotRecommendationOutputResponse: Swift.Equatable {
    /// The identifier of the bot associated with the bot recommendation.
    public var botId: Swift.String?
    /// The identifier of the bot recommendation being described.
    public var botRecommendationId: Swift.String?
    /// The object representing the URL of the bot definition, the URL of the associated transcript and a statistical summary of the bot recommendation results.
    public var botRecommendationResults: LexModelsV2ClientTypes.BotRecommendationResults?
    /// The status of the bot recommendation. If the status is Failed, then the reasons for the failure are listed in the failureReasons field.
    public var botRecommendationStatus: LexModelsV2ClientTypes.BotRecommendationStatus?
    /// The version of the bot associated with the bot recommendation.
    public var botVersion: Swift.String?
    /// The date and time that the bot recommendation was created.
    public var creationDateTime: ClientRuntime.Date?
    /// The object representing the passwords that were used to encrypt the data related to the bot recommendation results, as well as the KMS key ARN used to encrypt the associated metadata.
    public var encryptionSetting: LexModelsV2ClientTypes.EncryptionSetting?
    /// If botRecommendationStatus is Failed, Amazon Lex explains why.
    public var failureReasons: [Swift.String]?
    /// The date and time that the bot recommendation was last updated.
    public var lastUpdatedDateTime: ClientRuntime.Date?
    /// The identifier of the language and locale of the bot recommendation to describe.
    public var localeId: Swift.String?
    /// The object representing the Amazon S3 bucket containing the transcript, as well as the associated metadata.
    public var transcriptSourceSetting: LexModelsV2ClientTypes.TranscriptSourceSetting?

    public init(
        botId: Swift.String? = nil,
        botRecommendationId: Swift.String? = nil,
        botRecommendationResults: LexModelsV2ClientTypes.BotRecommendationResults? = nil,
        botRecommendationStatus: LexModelsV2ClientTypes.BotRecommendationStatus? = nil,
        botVersion: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        encryptionSetting: LexModelsV2ClientTypes.EncryptionSetting? = nil,
        failureReasons: [Swift.String]? = nil,
        lastUpdatedDateTime: ClientRuntime.Date? = nil,
        localeId: Swift.String? = nil,
        transcriptSourceSetting: LexModelsV2ClientTypes.TranscriptSourceSetting? = nil
    )
    {
        self.botId = botId
        self.botRecommendationId = botRecommendationId
        self.botRecommendationResults = botRecommendationResults
        self.botRecommendationStatus = botRecommendationStatus
        self.botVersion = botVersion
        self.creationDateTime = creationDateTime
        self.encryptionSetting = encryptionSetting
        self.failureReasons = failureReasons
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.localeId = localeId
        self.transcriptSourceSetting = transcriptSourceSetting
    }
}

struct DescribeBotRecommendationOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let botVersion: Swift.String?
    let localeId: Swift.String?
    let botRecommendationStatus: LexModelsV2ClientTypes.BotRecommendationStatus?
    let botRecommendationId: Swift.String?
    let failureReasons: [Swift.String]?
    let creationDateTime: ClientRuntime.Date?
    let lastUpdatedDateTime: ClientRuntime.Date?
    let transcriptSourceSetting: LexModelsV2ClientTypes.TranscriptSourceSetting?
    let encryptionSetting: LexModelsV2ClientTypes.EncryptionSetting?
    let botRecommendationResults: LexModelsV2ClientTypes.BotRecommendationResults?
}

extension DescribeBotRecommendationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botRecommendationId
        case botRecommendationResults
        case botRecommendationStatus
        case botVersion
        case creationDateTime
        case encryptionSetting
        case failureReasons
        case lastUpdatedDateTime
        case localeId
        case transcriptSourceSetting
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let botRecommendationStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotRecommendationStatus.self, forKey: .botRecommendationStatus)
        botRecommendationStatus = botRecommendationStatusDecoded
        let botRecommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botRecommendationId)
        botRecommendationId = botRecommendationIdDecoded
        let failureReasonsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .failureReasons)
        var failureReasonsDecoded0:[Swift.String]? = nil
        if let failureReasonsContainer = failureReasonsContainer {
            failureReasonsDecoded0 = [Swift.String]()
            for string0 in failureReasonsContainer {
                if let string0 = string0 {
                    failureReasonsDecoded0?.append(string0)
                }
            }
        }
        failureReasons = failureReasonsDecoded0
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let transcriptSourceSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TranscriptSourceSetting.self, forKey: .transcriptSourceSetting)
        transcriptSourceSetting = transcriptSourceSettingDecoded
        let encryptionSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.EncryptionSetting.self, forKey: .encryptionSetting)
        encryptionSetting = encryptionSettingDecoded
        let botRecommendationResultsDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotRecommendationResults.self, forKey: .botRecommendationResults)
        botRecommendationResults = botRecommendationResultsDecoded
    }
}

extension DescribeBotVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botVersion = botVersion else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botversions/\(botVersion.urlPercentEncoding())"
    }
}

public struct DescribeBotVersionInput: Swift.Equatable {
    /// The identifier of the bot containing the version to return metadata for.
    /// This member is required.
    public var botId: Swift.String?
    /// The version of the bot to return metadata for.
    /// This member is required.
    public var botVersion: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
    }
}

struct DescribeBotVersionInputBody: Swift.Equatable {
}

extension DescribeBotVersionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum DescribeBotVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeBotVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeBotVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botMembers = output.botMembers
            self.botName = output.botName
            self.botStatus = output.botStatus
            self.botType = output.botType
            self.botVersion = output.botVersion
            self.creationDateTime = output.creationDateTime
            self.dataPrivacy = output.dataPrivacy
            self.description = output.description
            self.failureReasons = output.failureReasons
            self.idleSessionTTLInSeconds = output.idleSessionTTLInSeconds
            self.parentBotNetworks = output.parentBotNetworks
            self.roleArn = output.roleArn
        } else {
            self.botId = nil
            self.botMembers = nil
            self.botName = nil
            self.botStatus = nil
            self.botType = nil
            self.botVersion = nil
            self.creationDateTime = nil
            self.dataPrivacy = nil
            self.description = nil
            self.failureReasons = nil
            self.idleSessionTTLInSeconds = nil
            self.parentBotNetworks = nil
            self.roleArn = nil
        }
    }
}

public struct DescribeBotVersionOutputResponse: Swift.Equatable {
    /// The identifier of the bot that contains the version.
    public var botId: Swift.String?
    /// The members of bot network in the version that was described.
    public var botMembers: [LexModelsV2ClientTypes.BotMember]?
    /// The name of the bot that contains the version.
    public var botName: Swift.String?
    /// The current status of the bot. When the status is Available, the bot version is ready for use.
    public var botStatus: LexModelsV2ClientTypes.BotStatus?
    /// The type of the bot in the version that was described.
    public var botType: LexModelsV2ClientTypes.BotType?
    /// The version of the bot that was described.
    public var botVersion: Swift.String?
    /// A timestamp of the date and time that the bot version was created.
    public var creationDateTime: ClientRuntime.Date?
    /// Data privacy settings for the bot version.
    public var dataPrivacy: LexModelsV2ClientTypes.DataPrivacy?
    /// The description specified for the bot.
    public var description: Swift.String?
    /// If the botStatus is Failed, this contains a list of reasons that the version couldn't be built.
    public var failureReasons: [Swift.String]?
    /// The number of seconds that a session with the bot remains active before it is discarded by Amazon Lex.
    public var idleSessionTTLInSeconds: Swift.Int?
    /// A list of the networks to which the bot version you described belongs.
    public var parentBotNetworks: [LexModelsV2ClientTypes.ParentBotNetwork]?
    /// The Amazon Resource Name (ARN) of an IAM role that has permission to access the bot version.
    public var roleArn: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botMembers: [LexModelsV2ClientTypes.BotMember]? = nil,
        botName: Swift.String? = nil,
        botStatus: LexModelsV2ClientTypes.BotStatus? = nil,
        botType: LexModelsV2ClientTypes.BotType? = nil,
        botVersion: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        dataPrivacy: LexModelsV2ClientTypes.DataPrivacy? = nil,
        description: Swift.String? = nil,
        failureReasons: [Swift.String]? = nil,
        idleSessionTTLInSeconds: Swift.Int? = nil,
        parentBotNetworks: [LexModelsV2ClientTypes.ParentBotNetwork]? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botMembers = botMembers
        self.botName = botName
        self.botStatus = botStatus
        self.botType = botType
        self.botVersion = botVersion
        self.creationDateTime = creationDateTime
        self.dataPrivacy = dataPrivacy
        self.description = description
        self.failureReasons = failureReasons
        self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
        self.parentBotNetworks = parentBotNetworks
        self.roleArn = roleArn
    }
}

struct DescribeBotVersionOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let botName: Swift.String?
    let botVersion: Swift.String?
    let description: Swift.String?
    let roleArn: Swift.String?
    let dataPrivacy: LexModelsV2ClientTypes.DataPrivacy?
    let idleSessionTTLInSeconds: Swift.Int?
    let botStatus: LexModelsV2ClientTypes.BotStatus?
    let failureReasons: [Swift.String]?
    let creationDateTime: ClientRuntime.Date?
    let parentBotNetworks: [LexModelsV2ClientTypes.ParentBotNetwork]?
    let botType: LexModelsV2ClientTypes.BotType?
    let botMembers: [LexModelsV2ClientTypes.BotMember]?
}

extension DescribeBotVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botMembers
        case botName
        case botStatus
        case botType
        case botVersion
        case creationDateTime
        case dataPrivacy
        case description
        case failureReasons
        case idleSessionTTLInSeconds
        case parentBotNetworks
        case roleArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botName)
        botName = botNameDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let dataPrivacyDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.DataPrivacy.self, forKey: .dataPrivacy)
        dataPrivacy = dataPrivacyDecoded
        let idleSessionTTLInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleSessionTTLInSeconds)
        idleSessionTTLInSeconds = idleSessionTTLInSecondsDecoded
        let botStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotStatus.self, forKey: .botStatus)
        botStatus = botStatusDecoded
        let failureReasonsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .failureReasons)
        var failureReasonsDecoded0:[Swift.String]? = nil
        if let failureReasonsContainer = failureReasonsContainer {
            failureReasonsDecoded0 = [Swift.String]()
            for string0 in failureReasonsContainer {
                if let string0 = string0 {
                    failureReasonsDecoded0?.append(string0)
                }
            }
        }
        failureReasons = failureReasonsDecoded0
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let parentBotNetworksContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.ParentBotNetwork?].self, forKey: .parentBotNetworks)
        var parentBotNetworksDecoded0:[LexModelsV2ClientTypes.ParentBotNetwork]? = nil
        if let parentBotNetworksContainer = parentBotNetworksContainer {
            parentBotNetworksDecoded0 = [LexModelsV2ClientTypes.ParentBotNetwork]()
            for structure0 in parentBotNetworksContainer {
                if let structure0 = structure0 {
                    parentBotNetworksDecoded0?.append(structure0)
                }
            }
        }
        parentBotNetworks = parentBotNetworksDecoded0
        let botTypeDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotType.self, forKey: .botType)
        botType = botTypeDecoded
        let botMembersContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.BotMember?].self, forKey: .botMembers)
        var botMembersDecoded0:[LexModelsV2ClientTypes.BotMember]? = nil
        if let botMembersContainer = botMembersContainer {
            botMembersDecoded0 = [LexModelsV2ClientTypes.BotMember]()
            for structure0 in botMembersContainer {
                if let structure0 = structure0 {
                    botMembersDecoded0?.append(structure0)
                }
            }
        }
        botMembers = botMembersDecoded0
    }
}

extension DescribeCustomVocabularyMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botVersion = botVersion else {
            return nil
        }
        guard let localeId = localeId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botversions/\(botVersion.urlPercentEncoding())/botlocales/\(localeId.urlPercentEncoding())/customvocabulary/DEFAULT/metadata"
    }
}

public struct DescribeCustomVocabularyMetadataInput: Swift.Equatable {
    /// The unique identifier of the bot that contains the custom vocabulary.
    /// This member is required.
    public var botId: Swift.String?
    /// The bot version of the bot to return metadata for.
    /// This member is required.
    public var botVersion: Swift.String?
    /// The locale to return the custom vocabulary information for. The locale must be en_GB.
    /// This member is required.
    public var localeId: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        localeId: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.localeId = localeId
    }
}

struct DescribeCustomVocabularyMetadataInputBody: Swift.Equatable {
}

extension DescribeCustomVocabularyMetadataInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum DescribeCustomVocabularyMetadataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeCustomVocabularyMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeCustomVocabularyMetadataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.creationDateTime = output.creationDateTime
            self.customVocabularyStatus = output.customVocabularyStatus
            self.lastUpdatedDateTime = output.lastUpdatedDateTime
            self.localeId = output.localeId
        } else {
            self.botId = nil
            self.botVersion = nil
            self.creationDateTime = nil
            self.customVocabularyStatus = nil
            self.lastUpdatedDateTime = nil
            self.localeId = nil
        }
    }
}

public struct DescribeCustomVocabularyMetadataOutputResponse: Swift.Equatable {
    /// The identifier of the bot that contains the custom vocabulary.
    public var botId: Swift.String?
    /// The version of the bot that contains the custom vocabulary to describe.
    public var botVersion: Swift.String?
    /// The date and time that the custom vocabulary was created.
    public var creationDateTime: ClientRuntime.Date?
    /// The status of the custom vocabulary. If the status is Ready the custom vocabulary is ready to use.
    public var customVocabularyStatus: LexModelsV2ClientTypes.CustomVocabularyStatus?
    /// The date and time that the custom vocabulary was last updated.
    public var lastUpdatedDateTime: ClientRuntime.Date?
    /// The locale that contains the custom vocabulary to describe.
    public var localeId: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        customVocabularyStatus: LexModelsV2ClientTypes.CustomVocabularyStatus? = nil,
        lastUpdatedDateTime: ClientRuntime.Date? = nil,
        localeId: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.creationDateTime = creationDateTime
        self.customVocabularyStatus = customVocabularyStatus
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.localeId = localeId
    }
}

struct DescribeCustomVocabularyMetadataOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let botVersion: Swift.String?
    let localeId: Swift.String?
    let customVocabularyStatus: LexModelsV2ClientTypes.CustomVocabularyStatus?
    let creationDateTime: ClientRuntime.Date?
    let lastUpdatedDateTime: ClientRuntime.Date?
}

extension DescribeCustomVocabularyMetadataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botVersion
        case creationDateTime
        case customVocabularyStatus
        case lastUpdatedDateTime
        case localeId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let customVocabularyStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.CustomVocabularyStatus.self, forKey: .customVocabularyStatus)
        customVocabularyStatus = customVocabularyStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension DescribeExportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let exportId = exportId else {
            return nil
        }
        return "/exports/\(exportId.urlPercentEncoding())"
    }
}

public struct DescribeExportInput: Swift.Equatable {
    /// The unique identifier of the export to describe.
    /// This member is required.
    public var exportId: Swift.String?

    public init(
        exportId: Swift.String? = nil
    )
    {
        self.exportId = exportId
    }
}

struct DescribeExportInputBody: Swift.Equatable {
}

extension DescribeExportInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum DescribeExportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeExportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeExportOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationDateTime = output.creationDateTime
            self.downloadUrl = output.downloadUrl
            self.exportId = output.exportId
            self.exportStatus = output.exportStatus
            self.failureReasons = output.failureReasons
            self.fileFormat = output.fileFormat
            self.lastUpdatedDateTime = output.lastUpdatedDateTime
            self.resourceSpecification = output.resourceSpecification
        } else {
            self.creationDateTime = nil
            self.downloadUrl = nil
            self.exportId = nil
            self.exportStatus = nil
            self.failureReasons = nil
            self.fileFormat = nil
            self.lastUpdatedDateTime = nil
            self.resourceSpecification = nil
        }
    }
}

public struct DescribeExportOutputResponse: Swift.Equatable {
    /// The date and time that the export was created.
    public var creationDateTime: ClientRuntime.Date?
    /// A pre-signed S3 URL that points to the bot or bot locale archive. The URL is only available for 5 minutes after calling the DescribeExport operation.
    public var downloadUrl: Swift.String?
    /// The unique identifier of the described export.
    public var exportId: Swift.String?
    /// The status of the export. When the status is Complete the export archive file is available for download.
    public var exportStatus: LexModelsV2ClientTypes.ExportStatus?
    /// If the exportStatus is failed, contains one or more reasons why the export could not be completed.
    public var failureReasons: [Swift.String]?
    /// The file format used in the files that describe the resource.
    public var fileFormat: LexModelsV2ClientTypes.ImportExportFileFormat?
    /// The last date and time that the export was updated.
    public var lastUpdatedDateTime: ClientRuntime.Date?
    /// The bot, bot ID, and optional locale ID of the exported bot or bot locale.
    public var resourceSpecification: LexModelsV2ClientTypes.ExportResourceSpecification?

    public init(
        creationDateTime: ClientRuntime.Date? = nil,
        downloadUrl: Swift.String? = nil,
        exportId: Swift.String? = nil,
        exportStatus: LexModelsV2ClientTypes.ExportStatus? = nil,
        failureReasons: [Swift.String]? = nil,
        fileFormat: LexModelsV2ClientTypes.ImportExportFileFormat? = nil,
        lastUpdatedDateTime: ClientRuntime.Date? = nil,
        resourceSpecification: LexModelsV2ClientTypes.ExportResourceSpecification? = nil
    )
    {
        self.creationDateTime = creationDateTime
        self.downloadUrl = downloadUrl
        self.exportId = exportId
        self.exportStatus = exportStatus
        self.failureReasons = failureReasons
        self.fileFormat = fileFormat
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.resourceSpecification = resourceSpecification
    }
}

struct DescribeExportOutputResponseBody: Swift.Equatable {
    let exportId: Swift.String?
    let resourceSpecification: LexModelsV2ClientTypes.ExportResourceSpecification?
    let fileFormat: LexModelsV2ClientTypes.ImportExportFileFormat?
    let exportStatus: LexModelsV2ClientTypes.ExportStatus?
    let failureReasons: [Swift.String]?
    let downloadUrl: Swift.String?
    let creationDateTime: ClientRuntime.Date?
    let lastUpdatedDateTime: ClientRuntime.Date?
}

extension DescribeExportOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case downloadUrl
        case exportId
        case exportStatus
        case failureReasons
        case fileFormat
        case lastUpdatedDateTime
        case resourceSpecification
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportId)
        exportId = exportIdDecoded
        let resourceSpecificationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ExportResourceSpecification.self, forKey: .resourceSpecification)
        resourceSpecification = resourceSpecificationDecoded
        let fileFormatDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ImportExportFileFormat.self, forKey: .fileFormat)
        fileFormat = fileFormatDecoded
        let exportStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ExportStatus.self, forKey: .exportStatus)
        exportStatus = exportStatusDecoded
        let failureReasonsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .failureReasons)
        var failureReasonsDecoded0:[Swift.String]? = nil
        if let failureReasonsContainer = failureReasonsContainer {
            failureReasonsDecoded0 = [Swift.String]()
            for string0 in failureReasonsContainer {
                if let string0 = string0 {
                    failureReasonsDecoded0?.append(string0)
                }
            }
        }
        failureReasons = failureReasonsDecoded0
        let downloadUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .downloadUrl)
        downloadUrl = downloadUrlDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension DescribeImportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let importId = importId else {
            return nil
        }
        return "/imports/\(importId.urlPercentEncoding())"
    }
}

public struct DescribeImportInput: Swift.Equatable {
    /// The unique identifier of the import to describe.
    /// This member is required.
    public var importId: Swift.String?

    public init(
        importId: Swift.String? = nil
    )
    {
        self.importId = importId
    }
}

struct DescribeImportInputBody: Swift.Equatable {
}

extension DescribeImportInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum DescribeImportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeImportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeImportOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationDateTime = output.creationDateTime
            self.failureReasons = output.failureReasons
            self.importId = output.importId
            self.importStatus = output.importStatus
            self.importedResourceId = output.importedResourceId
            self.importedResourceName = output.importedResourceName
            self.lastUpdatedDateTime = output.lastUpdatedDateTime
            self.mergeStrategy = output.mergeStrategy
            self.resourceSpecification = output.resourceSpecification
        } else {
            self.creationDateTime = nil
            self.failureReasons = nil
            self.importId = nil
            self.importStatus = nil
            self.importedResourceId = nil
            self.importedResourceName = nil
            self.lastUpdatedDateTime = nil
            self.mergeStrategy = nil
            self.resourceSpecification = nil
        }
    }
}

public struct DescribeImportOutputResponse: Swift.Equatable {
    /// The date and time that the import was created.
    public var creationDateTime: ClientRuntime.Date?
    /// If the importStatus field is Failed, this provides one or more reasons for the failure.
    public var failureReasons: [Swift.String]?
    /// The unique identifier of the described import.
    public var importId: Swift.String?
    /// The status of the import process. When the status is Completed the resource is imported and ready for use.
    public var importStatus: LexModelsV2ClientTypes.ImportStatus?
    /// The unique identifier that Amazon Lex assigned to the resource created by the import.
    public var importedResourceId: Swift.String?
    /// The name of the imported resource.
    public var importedResourceName: Swift.String?
    /// The date and time that the import was last updated.
    public var lastUpdatedDateTime: ClientRuntime.Date?
    /// The strategy used when there was a name conflict between the imported resource and an existing resource. When the merge strategy is FailOnConflict existing resources are not overwritten and the import fails.
    public var mergeStrategy: LexModelsV2ClientTypes.MergeStrategy?
    /// The specifications of the imported bot, bot locale, or custom vocabulary.
    public var resourceSpecification: LexModelsV2ClientTypes.ImportResourceSpecification?

    public init(
        creationDateTime: ClientRuntime.Date? = nil,
        failureReasons: [Swift.String]? = nil,
        importId: Swift.String? = nil,
        importStatus: LexModelsV2ClientTypes.ImportStatus? = nil,
        importedResourceId: Swift.String? = nil,
        importedResourceName: Swift.String? = nil,
        lastUpdatedDateTime: ClientRuntime.Date? = nil,
        mergeStrategy: LexModelsV2ClientTypes.MergeStrategy? = nil,
        resourceSpecification: LexModelsV2ClientTypes.ImportResourceSpecification? = nil
    )
    {
        self.creationDateTime = creationDateTime
        self.failureReasons = failureReasons
        self.importId = importId
        self.importStatus = importStatus
        self.importedResourceId = importedResourceId
        self.importedResourceName = importedResourceName
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.mergeStrategy = mergeStrategy
        self.resourceSpecification = resourceSpecification
    }
}

struct DescribeImportOutputResponseBody: Swift.Equatable {
    let importId: Swift.String?
    let resourceSpecification: LexModelsV2ClientTypes.ImportResourceSpecification?
    let importedResourceId: Swift.String?
    let importedResourceName: Swift.String?
    let mergeStrategy: LexModelsV2ClientTypes.MergeStrategy?
    let importStatus: LexModelsV2ClientTypes.ImportStatus?
    let failureReasons: [Swift.String]?
    let creationDateTime: ClientRuntime.Date?
    let lastUpdatedDateTime: ClientRuntime.Date?
}

extension DescribeImportOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case failureReasons
        case importId
        case importStatus
        case importedResourceId
        case importedResourceName
        case lastUpdatedDateTime
        case mergeStrategy
        case resourceSpecification
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importId)
        importId = importIdDecoded
        let resourceSpecificationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ImportResourceSpecification.self, forKey: .resourceSpecification)
        resourceSpecification = resourceSpecificationDecoded
        let importedResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importedResourceId)
        importedResourceId = importedResourceIdDecoded
        let importedResourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importedResourceName)
        importedResourceName = importedResourceNameDecoded
        let mergeStrategyDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.MergeStrategy.self, forKey: .mergeStrategy)
        mergeStrategy = mergeStrategyDecoded
        let importStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ImportStatus.self, forKey: .importStatus)
        importStatus = importStatusDecoded
        let failureReasonsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .failureReasons)
        var failureReasonsDecoded0:[Swift.String]? = nil
        if let failureReasonsContainer = failureReasonsContainer {
            failureReasonsDecoded0 = [Swift.String]()
            for string0 in failureReasonsContainer {
                if let string0 = string0 {
                    failureReasonsDecoded0?.append(string0)
                }
            }
        }
        failureReasons = failureReasonsDecoded0
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension DescribeIntentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botVersion = botVersion else {
            return nil
        }
        guard let localeId = localeId else {
            return nil
        }
        guard let intentId = intentId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botversions/\(botVersion.urlPercentEncoding())/botlocales/\(localeId.urlPercentEncoding())/intents/\(intentId.urlPercentEncoding())"
    }
}

public struct DescribeIntentInput: Swift.Equatable {
    /// The identifier of the bot associated with the intent.
    /// This member is required.
    public var botId: Swift.String?
    /// The version of the bot associated with the intent.
    /// This member is required.
    public var botVersion: Swift.String?
    /// The identifier of the intent to describe.
    /// This member is required.
    public var intentId: Swift.String?
    /// The identifier of the language and locale of the intent to describe. The string must match one of the supported locales. For more information, see [Supported languages](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html).
    /// This member is required.
    public var localeId: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        intentId: Swift.String? = nil,
        localeId: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.intentId = intentId
        self.localeId = localeId
    }
}

struct DescribeIntentInputBody: Swift.Equatable {
}

extension DescribeIntentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum DescribeIntentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeIntentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeIntentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.dialogCodeHook = output.dialogCodeHook
            self.fulfillmentCodeHook = output.fulfillmentCodeHook
            self.initialResponseSetting = output.initialResponseSetting
            self.inputContexts = output.inputContexts
            self.intentClosingSetting = output.intentClosingSetting
            self.intentConfirmationSetting = output.intentConfirmationSetting
            self.intentId = output.intentId
            self.intentName = output.intentName
            self.kendraConfiguration = output.kendraConfiguration
            self.lastUpdatedDateTime = output.lastUpdatedDateTime
            self.localeId = output.localeId
            self.outputContexts = output.outputContexts
            self.parentIntentSignature = output.parentIntentSignature
            self.sampleUtterances = output.sampleUtterances
            self.slotPriorities = output.slotPriorities
        } else {
            self.botId = nil
            self.botVersion = nil
            self.creationDateTime = nil
            self.description = nil
            self.dialogCodeHook = nil
            self.fulfillmentCodeHook = nil
            self.initialResponseSetting = nil
            self.inputContexts = nil
            self.intentClosingSetting = nil
            self.intentConfirmationSetting = nil
            self.intentId = nil
            self.intentName = nil
            self.kendraConfiguration = nil
            self.lastUpdatedDateTime = nil
            self.localeId = nil
            self.outputContexts = nil
            self.parentIntentSignature = nil
            self.sampleUtterances = nil
            self.slotPriorities = nil
        }
    }
}

public struct DescribeIntentOutputResponse: Swift.Equatable {
    /// The identifier of the bot associated with the intent.
    public var botId: Swift.String?
    /// The version of the bot associated with the intent.
    public var botVersion: Swift.String?
    /// A timestamp of the date and time that the intent was created.
    public var creationDateTime: ClientRuntime.Date?
    /// The description of the intent.
    public var description: Swift.String?
    /// The Lambda function called during each turn of a conversation with the intent.
    public var dialogCodeHook: LexModelsV2ClientTypes.DialogCodeHookSettings?
    /// The Lambda function called when the intent is complete and ready for fulfillment.
    public var fulfillmentCodeHook: LexModelsV2ClientTypes.FulfillmentCodeHookSettings?
    /// Configuration setting for a response sent to the user before Amazon Lex starts eliciting slots.
    public var initialResponseSetting: LexModelsV2ClientTypes.InitialResponseSetting?
    /// A list of contexts that must be active for the intent to be considered for sending to the user.
    public var inputContexts: [LexModelsV2ClientTypes.InputContext]?
    /// The response that Amazon Lex sends to when the intent is closed.
    public var intentClosingSetting: LexModelsV2ClientTypes.IntentClosingSetting?
    /// Prompts that Amazon Lex sends to the user to confirm completion of an intent.
    public var intentConfirmationSetting: LexModelsV2ClientTypes.IntentConfirmationSetting?
    /// The unique identifier assigned to the intent when it was created.
    public var intentId: Swift.String?
    /// The name specified for the intent.
    public var intentName: Swift.String?
    /// Configuration information required to use the AMAZON.KendraSearchIntent intent.
    public var kendraConfiguration: LexModelsV2ClientTypes.KendraConfiguration?
    /// A timestamp of the date and time that the intent was last updated.
    public var lastUpdatedDateTime: ClientRuntime.Date?
    /// The language and locale specified for the intent.
    public var localeId: Swift.String?
    /// A list of contexts that are activated when the intent is fulfilled.
    public var outputContexts: [LexModelsV2ClientTypes.OutputContext]?
    /// The identifier of the built-in intent that this intent is derived from, if any.
    public var parentIntentSignature: Swift.String?
    /// User utterances that trigger this intent.
    public var sampleUtterances: [LexModelsV2ClientTypes.SampleUtterance]?
    /// The list that determines the priority that slots should be elicited from the user.
    public var slotPriorities: [LexModelsV2ClientTypes.SlotPriority]?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        dialogCodeHook: LexModelsV2ClientTypes.DialogCodeHookSettings? = nil,
        fulfillmentCodeHook: LexModelsV2ClientTypes.FulfillmentCodeHookSettings? = nil,
        initialResponseSetting: LexModelsV2ClientTypes.InitialResponseSetting? = nil,
        inputContexts: [LexModelsV2ClientTypes.InputContext]? = nil,
        intentClosingSetting: LexModelsV2ClientTypes.IntentClosingSetting? = nil,
        intentConfirmationSetting: LexModelsV2ClientTypes.IntentConfirmationSetting? = nil,
        intentId: Swift.String? = nil,
        intentName: Swift.String? = nil,
        kendraConfiguration: LexModelsV2ClientTypes.KendraConfiguration? = nil,
        lastUpdatedDateTime: ClientRuntime.Date? = nil,
        localeId: Swift.String? = nil,
        outputContexts: [LexModelsV2ClientTypes.OutputContext]? = nil,
        parentIntentSignature: Swift.String? = nil,
        sampleUtterances: [LexModelsV2ClientTypes.SampleUtterance]? = nil,
        slotPriorities: [LexModelsV2ClientTypes.SlotPriority]? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.creationDateTime = creationDateTime
        self.description = description
        self.dialogCodeHook = dialogCodeHook
        self.fulfillmentCodeHook = fulfillmentCodeHook
        self.initialResponseSetting = initialResponseSetting
        self.inputContexts = inputContexts
        self.intentClosingSetting = intentClosingSetting
        self.intentConfirmationSetting = intentConfirmationSetting
        self.intentId = intentId
        self.intentName = intentName
        self.kendraConfiguration = kendraConfiguration
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.localeId = localeId
        self.outputContexts = outputContexts
        self.parentIntentSignature = parentIntentSignature
        self.sampleUtterances = sampleUtterances
        self.slotPriorities = slotPriorities
    }
}

struct DescribeIntentOutputResponseBody: Swift.Equatable {
    let intentId: Swift.String?
    let intentName: Swift.String?
    let description: Swift.String?
    let parentIntentSignature: Swift.String?
    let sampleUtterances: [LexModelsV2ClientTypes.SampleUtterance]?
    let dialogCodeHook: LexModelsV2ClientTypes.DialogCodeHookSettings?
    let fulfillmentCodeHook: LexModelsV2ClientTypes.FulfillmentCodeHookSettings?
    let slotPriorities: [LexModelsV2ClientTypes.SlotPriority]?
    let intentConfirmationSetting: LexModelsV2ClientTypes.IntentConfirmationSetting?
    let intentClosingSetting: LexModelsV2ClientTypes.IntentClosingSetting?
    let inputContexts: [LexModelsV2ClientTypes.InputContext]?
    let outputContexts: [LexModelsV2ClientTypes.OutputContext]?
    let kendraConfiguration: LexModelsV2ClientTypes.KendraConfiguration?
    let botId: Swift.String?
    let botVersion: Swift.String?
    let localeId: Swift.String?
    let creationDateTime: ClientRuntime.Date?
    let lastUpdatedDateTime: ClientRuntime.Date?
    let initialResponseSetting: LexModelsV2ClientTypes.InitialResponseSetting?
}

extension DescribeIntentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botVersion
        case creationDateTime
        case description
        case dialogCodeHook
        case fulfillmentCodeHook
        case initialResponseSetting
        case inputContexts
        case intentClosingSetting
        case intentConfirmationSetting
        case intentId
        case intentName
        case kendraConfiguration
        case lastUpdatedDateTime
        case localeId
        case outputContexts
        case parentIntentSignature
        case sampleUtterances
        case slotPriorities
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intentId)
        intentId = intentIdDecoded
        let intentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intentName)
        intentName = intentNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parentIntentSignatureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentIntentSignature)
        parentIntentSignature = parentIntentSignatureDecoded
        let sampleUtterancesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.SampleUtterance?].self, forKey: .sampleUtterances)
        var sampleUtterancesDecoded0:[LexModelsV2ClientTypes.SampleUtterance]? = nil
        if let sampleUtterancesContainer = sampleUtterancesContainer {
            sampleUtterancesDecoded0 = [LexModelsV2ClientTypes.SampleUtterance]()
            for structure0 in sampleUtterancesContainer {
                if let structure0 = structure0 {
                    sampleUtterancesDecoded0?.append(structure0)
                }
            }
        }
        sampleUtterances = sampleUtterancesDecoded0
        let dialogCodeHookDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.DialogCodeHookSettings.self, forKey: .dialogCodeHook)
        dialogCodeHook = dialogCodeHookDecoded
        let fulfillmentCodeHookDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.FulfillmentCodeHookSettings.self, forKey: .fulfillmentCodeHook)
        fulfillmentCodeHook = fulfillmentCodeHookDecoded
        let slotPrioritiesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.SlotPriority?].self, forKey: .slotPriorities)
        var slotPrioritiesDecoded0:[LexModelsV2ClientTypes.SlotPriority]? = nil
        if let slotPrioritiesContainer = slotPrioritiesContainer {
            slotPrioritiesDecoded0 = [LexModelsV2ClientTypes.SlotPriority]()
            for structure0 in slotPrioritiesContainer {
                if let structure0 = structure0 {
                    slotPrioritiesDecoded0?.append(structure0)
                }
            }
        }
        slotPriorities = slotPrioritiesDecoded0
        let intentConfirmationSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.IntentConfirmationSetting.self, forKey: .intentConfirmationSetting)
        intentConfirmationSetting = intentConfirmationSettingDecoded
        let intentClosingSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.IntentClosingSetting.self, forKey: .intentClosingSetting)
        intentClosingSetting = intentClosingSettingDecoded
        let inputContextsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.InputContext?].self, forKey: .inputContexts)
        var inputContextsDecoded0:[LexModelsV2ClientTypes.InputContext]? = nil
        if let inputContextsContainer = inputContextsContainer {
            inputContextsDecoded0 = [LexModelsV2ClientTypes.InputContext]()
            for structure0 in inputContextsContainer {
                if let structure0 = structure0 {
                    inputContextsDecoded0?.append(structure0)
                }
            }
        }
        inputContexts = inputContextsDecoded0
        let outputContextsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.OutputContext?].self, forKey: .outputContexts)
        var outputContextsDecoded0:[LexModelsV2ClientTypes.OutputContext]? = nil
        if let outputContextsContainer = outputContextsContainer {
            outputContextsDecoded0 = [LexModelsV2ClientTypes.OutputContext]()
            for structure0 in outputContextsContainer {
                if let structure0 = structure0 {
                    outputContextsDecoded0?.append(structure0)
                }
            }
        }
        outputContexts = outputContextsDecoded0
        let kendraConfigurationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.KendraConfiguration.self, forKey: .kendraConfiguration)
        kendraConfiguration = kendraConfigurationDecoded
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let initialResponseSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.InitialResponseSetting.self, forKey: .initialResponseSetting)
        initialResponseSetting = initialResponseSettingDecoded
    }
}

extension DescribeResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/policy/\(resourceArn.urlPercentEncoding())"
    }
}

public struct DescribeResourcePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the bot or bot alias that the resource policy is attached to.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct DescribeResourcePolicyInputBody: Swift.Equatable {
}

extension DescribeResourcePolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum DescribeResourcePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeResourcePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeResourcePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
            self.resourceArn = output.resourceArn
            self.revisionId = output.revisionId
        } else {
            self.policy = nil
            self.resourceArn = nil
            self.revisionId = nil
        }
    }
}

public struct DescribeResourcePolicyOutputResponse: Swift.Equatable {
    /// The JSON structure that contains the resource policy. For more information about the contents of a JSON policy document, see [ IAM JSON policy reference ](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies.html).
    public var policy: Swift.String?
    /// The Amazon Resource Name (ARN) of the bot or bot alias that the resource policy is attached to.
    public var resourceArn: Swift.String?
    /// The current revision of the resource policy. Use the revision ID to make sure that you are updating the most current version of a resource policy when you add a policy statement to a resource, delete a resource, or update a resource.
    public var revisionId: Swift.String?

    public init(
        policy: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.resourceArn = resourceArn
        self.revisionId = revisionId
    }
}

struct DescribeResourcePolicyOutputResponseBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let policy: Swift.String?
    let revisionId: Swift.String?
}

extension DescribeResourcePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
        case resourceArn
        case revisionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension DescribeSlotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botVersion = botVersion else {
            return nil
        }
        guard let localeId = localeId else {
            return nil
        }
        guard let intentId = intentId else {
            return nil
        }
        guard let slotId = slotId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botversions/\(botVersion.urlPercentEncoding())/botlocales/\(localeId.urlPercentEncoding())/intents/\(intentId.urlPercentEncoding())/slots/\(slotId.urlPercentEncoding())"
    }
}

public struct DescribeSlotInput: Swift.Equatable {
    /// The identifier of the bot associated with the slot.
    /// This member is required.
    public var botId: Swift.String?
    /// The version of the bot associated with the slot.
    /// This member is required.
    public var botVersion: Swift.String?
    /// The identifier of the intent that contains the slot.
    /// This member is required.
    public var intentId: Swift.String?
    /// The identifier of the language and locale of the slot to describe. The string must match one of the supported locales. For more information, see [Supported languages](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html).
    /// This member is required.
    public var localeId: Swift.String?
    /// The unique identifier for the slot.
    /// This member is required.
    public var slotId: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        intentId: Swift.String? = nil,
        localeId: Swift.String? = nil,
        slotId: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.intentId = intentId
        self.localeId = localeId
        self.slotId = slotId
    }
}

struct DescribeSlotInputBody: Swift.Equatable {
}

extension DescribeSlotInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum DescribeSlotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeSlotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSlotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.intentId = output.intentId
            self.lastUpdatedDateTime = output.lastUpdatedDateTime
            self.localeId = output.localeId
            self.multipleValuesSetting = output.multipleValuesSetting
            self.obfuscationSetting = output.obfuscationSetting
            self.slotId = output.slotId
            self.slotName = output.slotName
            self.slotTypeId = output.slotTypeId
            self.subSlotSetting = output.subSlotSetting
            self.valueElicitationSetting = output.valueElicitationSetting
        } else {
            self.botId = nil
            self.botVersion = nil
            self.creationDateTime = nil
            self.description = nil
            self.intentId = nil
            self.lastUpdatedDateTime = nil
            self.localeId = nil
            self.multipleValuesSetting = nil
            self.obfuscationSetting = nil
            self.slotId = nil
            self.slotName = nil
            self.slotTypeId = nil
            self.subSlotSetting = nil
            self.valueElicitationSetting = nil
        }
    }
}

public struct DescribeSlotOutputResponse: Swift.Equatable {
    /// The identifier of the bot associated with the slot.
    public var botId: Swift.String?
    /// The version of the bot associated with the slot.
    public var botVersion: Swift.String?
    /// A timestamp of the date and time that the slot was created.
    public var creationDateTime: ClientRuntime.Date?
    /// The description specified for the slot.
    public var description: Swift.String?
    /// The identifier of the intent associated with the slot.
    public var intentId: Swift.String?
    /// A timestamp of the date and time that the slot was last updated.
    public var lastUpdatedDateTime: ClientRuntime.Date?
    /// The language and locale specified for the slot.
    public var localeId: Swift.String?
    /// Indicates whether the slot accepts multiple values in a single utterance. If the multipleValuesSetting is not set, the default value is false.
    public var multipleValuesSetting: LexModelsV2ClientTypes.MultipleValuesSetting?
    /// Whether slot values are shown in Amazon CloudWatch logs. If the value is None, the actual value of the slot is shown in logs.
    public var obfuscationSetting: LexModelsV2ClientTypes.ObfuscationSetting?
    /// The unique identifier generated for the slot.
    public var slotId: Swift.String?
    /// The name specified for the slot.
    public var slotName: Swift.String?
    /// The identifier of the slot type that determines the values entered into the slot.
    public var slotTypeId: Swift.String?
    /// Specifications for the constituent sub slots and the expression for the composite slot.
    public var subSlotSetting: LexModelsV2ClientTypes.SubSlotSetting?
    /// Prompts that Amazon Lex uses to elicit a value for the slot.
    public var valueElicitationSetting: LexModelsV2ClientTypes.SlotValueElicitationSetting?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        intentId: Swift.String? = nil,
        lastUpdatedDateTime: ClientRuntime.Date? = nil,
        localeId: Swift.String? = nil,
        multipleValuesSetting: LexModelsV2ClientTypes.MultipleValuesSetting? = nil,
        obfuscationSetting: LexModelsV2ClientTypes.ObfuscationSetting? = nil,
        slotId: Swift.String? = nil,
        slotName: Swift.String? = nil,
        slotTypeId: Swift.String? = nil,
        subSlotSetting: LexModelsV2ClientTypes.SubSlotSetting? = nil,
        valueElicitationSetting: LexModelsV2ClientTypes.SlotValueElicitationSetting? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.creationDateTime = creationDateTime
        self.description = description
        self.intentId = intentId
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.localeId = localeId
        self.multipleValuesSetting = multipleValuesSetting
        self.obfuscationSetting = obfuscationSetting
        self.slotId = slotId
        self.slotName = slotName
        self.slotTypeId = slotTypeId
        self.subSlotSetting = subSlotSetting
        self.valueElicitationSetting = valueElicitationSetting
    }
}

struct DescribeSlotOutputResponseBody: Swift.Equatable {
    let slotId: Swift.String?
    let slotName: Swift.String?
    let description: Swift.String?
    let slotTypeId: Swift.String?
    let valueElicitationSetting: LexModelsV2ClientTypes.SlotValueElicitationSetting?
    let obfuscationSetting: LexModelsV2ClientTypes.ObfuscationSetting?
    let botId: Swift.String?
    let botVersion: Swift.String?
    let localeId: Swift.String?
    let intentId: Swift.String?
    let creationDateTime: ClientRuntime.Date?
    let lastUpdatedDateTime: ClientRuntime.Date?
    let multipleValuesSetting: LexModelsV2ClientTypes.MultipleValuesSetting?
    let subSlotSetting: LexModelsV2ClientTypes.SubSlotSetting?
}

extension DescribeSlotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botVersion
        case creationDateTime
        case description
        case intentId
        case lastUpdatedDateTime
        case localeId
        case multipleValuesSetting
        case obfuscationSetting
        case slotId
        case slotName
        case slotTypeId
        case subSlotSetting
        case valueElicitationSetting
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let slotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotId)
        slotId = slotIdDecoded
        let slotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotName)
        slotName = slotNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let slotTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotTypeId)
        slotTypeId = slotTypeIdDecoded
        let valueElicitationSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SlotValueElicitationSetting.self, forKey: .valueElicitationSetting)
        valueElicitationSetting = valueElicitationSettingDecoded
        let obfuscationSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ObfuscationSetting.self, forKey: .obfuscationSetting)
        obfuscationSetting = obfuscationSettingDecoded
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let intentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intentId)
        intentId = intentIdDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let multipleValuesSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.MultipleValuesSetting.self, forKey: .multipleValuesSetting)
        multipleValuesSetting = multipleValuesSettingDecoded
        let subSlotSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SubSlotSetting.self, forKey: .subSlotSetting)
        subSlotSetting = subSlotSettingDecoded
    }
}

extension DescribeSlotTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botVersion = botVersion else {
            return nil
        }
        guard let localeId = localeId else {
            return nil
        }
        guard let slotTypeId = slotTypeId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botversions/\(botVersion.urlPercentEncoding())/botlocales/\(localeId.urlPercentEncoding())/slottypes/\(slotTypeId.urlPercentEncoding())"
    }
}

public struct DescribeSlotTypeInput: Swift.Equatable {
    /// The identifier of the bot associated with the slot type.
    /// This member is required.
    public var botId: Swift.String?
    /// The version of the bot associated with the slot type.
    /// This member is required.
    public var botVersion: Swift.String?
    /// The identifier of the language and locale of the slot type to describe. The string must match one of the supported locales. For more information, see [Supported languages](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html).
    /// This member is required.
    public var localeId: Swift.String?
    /// The identifier of the slot type.
    /// This member is required.
    public var slotTypeId: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        localeId: Swift.String? = nil,
        slotTypeId: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.localeId = localeId
        self.slotTypeId = slotTypeId
    }
}

struct DescribeSlotTypeInputBody: Swift.Equatable {
}

extension DescribeSlotTypeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum DescribeSlotTypeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeSlotTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSlotTypeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.compositeSlotTypeSetting = output.compositeSlotTypeSetting
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.externalSourceSetting = output.externalSourceSetting
            self.lastUpdatedDateTime = output.lastUpdatedDateTime
            self.localeId = output.localeId
            self.parentSlotTypeSignature = output.parentSlotTypeSignature
            self.slotTypeId = output.slotTypeId
            self.slotTypeName = output.slotTypeName
            self.slotTypeValues = output.slotTypeValues
            self.valueSelectionSetting = output.valueSelectionSetting
        } else {
            self.botId = nil
            self.botVersion = nil
            self.compositeSlotTypeSetting = nil
            self.creationDateTime = nil
            self.description = nil
            self.externalSourceSetting = nil
            self.lastUpdatedDateTime = nil
            self.localeId = nil
            self.parentSlotTypeSignature = nil
            self.slotTypeId = nil
            self.slotTypeName = nil
            self.slotTypeValues = nil
            self.valueSelectionSetting = nil
        }
    }
}

public struct DescribeSlotTypeOutputResponse: Swift.Equatable {
    /// The identifier of the bot associated with the slot type.
    public var botId: Swift.String?
    /// The version of the bot associated with the slot type.
    public var botVersion: Swift.String?
    /// Specifications for a composite slot type.
    public var compositeSlotTypeSetting: LexModelsV2ClientTypes.CompositeSlotTypeSetting?
    /// A timestamp of the date and time that the slot type was created.
    public var creationDateTime: ClientRuntime.Date?
    /// The description specified for the slot type.
    public var description: Swift.String?
    /// Provides information about the external source of the slot type's definition.
    public var externalSourceSetting: LexModelsV2ClientTypes.ExternalSourceSetting?
    /// A timestamp of the date and time that the slot type was last updated.
    public var lastUpdatedDateTime: ClientRuntime.Date?
    /// The language and locale specified for the slot type.
    public var localeId: Swift.String?
    /// The built in slot type used as a parent to this slot type.
    public var parentSlotTypeSignature: Swift.String?
    /// The unique identifier for the slot type.
    public var slotTypeId: Swift.String?
    /// The name specified for the slot type.
    public var slotTypeName: Swift.String?
    /// The values that the slot type can take. Includes any synonyms for the slot type values.
    public var slotTypeValues: [LexModelsV2ClientTypes.SlotTypeValue]?
    /// The strategy that Amazon Lex uses to choose a value from a list of possible values.
    public var valueSelectionSetting: LexModelsV2ClientTypes.SlotValueSelectionSetting?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        compositeSlotTypeSetting: LexModelsV2ClientTypes.CompositeSlotTypeSetting? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        externalSourceSetting: LexModelsV2ClientTypes.ExternalSourceSetting? = nil,
        lastUpdatedDateTime: ClientRuntime.Date? = nil,
        localeId: Swift.String? = nil,
        parentSlotTypeSignature: Swift.String? = nil,
        slotTypeId: Swift.String? = nil,
        slotTypeName: Swift.String? = nil,
        slotTypeValues: [LexModelsV2ClientTypes.SlotTypeValue]? = nil,
        valueSelectionSetting: LexModelsV2ClientTypes.SlotValueSelectionSetting? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.compositeSlotTypeSetting = compositeSlotTypeSetting
        self.creationDateTime = creationDateTime
        self.description = description
        self.externalSourceSetting = externalSourceSetting
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.localeId = localeId
        self.parentSlotTypeSignature = parentSlotTypeSignature
        self.slotTypeId = slotTypeId
        self.slotTypeName = slotTypeName
        self.slotTypeValues = slotTypeValues
        self.valueSelectionSetting = valueSelectionSetting
    }
}

struct DescribeSlotTypeOutputResponseBody: Swift.Equatable {
    let slotTypeId: Swift.String?
    let slotTypeName: Swift.String?
    let description: Swift.String?
    let slotTypeValues: [LexModelsV2ClientTypes.SlotTypeValue]?
    let valueSelectionSetting: LexModelsV2ClientTypes.SlotValueSelectionSetting?
    let parentSlotTypeSignature: Swift.String?
    let botId: Swift.String?
    let botVersion: Swift.String?
    let localeId: Swift.String?
    let creationDateTime: ClientRuntime.Date?
    let lastUpdatedDateTime: ClientRuntime.Date?
    let externalSourceSetting: LexModelsV2ClientTypes.ExternalSourceSetting?
    let compositeSlotTypeSetting: LexModelsV2ClientTypes.CompositeSlotTypeSetting?
}

extension DescribeSlotTypeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botVersion
        case compositeSlotTypeSetting
        case creationDateTime
        case description
        case externalSourceSetting
        case lastUpdatedDateTime
        case localeId
        case parentSlotTypeSignature
        case slotTypeId
        case slotTypeName
        case slotTypeValues
        case valueSelectionSetting
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let slotTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotTypeId)
        slotTypeId = slotTypeIdDecoded
        let slotTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotTypeName)
        slotTypeName = slotTypeNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let slotTypeValuesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.SlotTypeValue?].self, forKey: .slotTypeValues)
        var slotTypeValuesDecoded0:[LexModelsV2ClientTypes.SlotTypeValue]? = nil
        if let slotTypeValuesContainer = slotTypeValuesContainer {
            slotTypeValuesDecoded0 = [LexModelsV2ClientTypes.SlotTypeValue]()
            for structure0 in slotTypeValuesContainer {
                if let structure0 = structure0 {
                    slotTypeValuesDecoded0?.append(structure0)
                }
            }
        }
        slotTypeValues = slotTypeValuesDecoded0
        let valueSelectionSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SlotValueSelectionSetting.self, forKey: .valueSelectionSetting)
        valueSelectionSetting = valueSelectionSettingDecoded
        let parentSlotTypeSignatureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentSlotTypeSignature)
        parentSlotTypeSignature = parentSlotTypeSignatureDecoded
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let externalSourceSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ExternalSourceSetting.self, forKey: .externalSourceSetting)
        externalSourceSetting = externalSourceSettingDecoded
        let compositeSlotTypeSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.CompositeSlotTypeSetting.self, forKey: .compositeSlotTypeSetting)
        compositeSlotTypeSetting = compositeSlotTypeSettingDecoded
    }
}

extension DescribeTestExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let testExecutionId = testExecutionId else {
            return nil
        }
        return "/testexecutions/\(testExecutionId.urlPercentEncoding())"
    }
}

public struct DescribeTestExecutionInput: Swift.Equatable {
    /// The execution Id of the test set execution.
    /// This member is required.
    public var testExecutionId: Swift.String?

    public init(
        testExecutionId: Swift.String? = nil
    )
    {
        self.testExecutionId = testExecutionId
    }
}

struct DescribeTestExecutionInputBody: Swift.Equatable {
}

extension DescribeTestExecutionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum DescribeTestExecutionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeTestExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeTestExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiMode = output.apiMode
            self.creationDateTime = output.creationDateTime
            self.failureReasons = output.failureReasons
            self.lastUpdatedDateTime = output.lastUpdatedDateTime
            self.target = output.target
            self.testExecutionId = output.testExecutionId
            self.testExecutionModality = output.testExecutionModality
            self.testExecutionStatus = output.testExecutionStatus
            self.testSetId = output.testSetId
            self.testSetName = output.testSetName
        } else {
            self.apiMode = nil
            self.creationDateTime = nil
            self.failureReasons = nil
            self.lastUpdatedDateTime = nil
            self.target = nil
            self.testExecutionId = nil
            self.testExecutionModality = nil
            self.testExecutionStatus = nil
            self.testSetId = nil
            self.testSetName = nil
        }
    }
}

public struct DescribeTestExecutionOutputResponse: Swift.Equatable {
    /// Indicates whether we use streaming or non-streaming APIs are used for the test set execution. For streaming, StartConversation Amazon Lex Runtime API is used. Whereas for non-streaming, RecognizeUtterance and RecognizeText Amazon Lex Runtime API is used.
    public var apiMode: LexModelsV2ClientTypes.TestExecutionApiMode?
    /// The execution creation date and time for the test set execution.
    public var creationDateTime: ClientRuntime.Date?
    /// Reasons for the failure of the test set execution.
    public var failureReasons: [Swift.String]?
    /// The date and time of the last update for the execution.
    public var lastUpdatedDateTime: ClientRuntime.Date?
    /// The target bot for the test set execution details.
    public var target: LexModelsV2ClientTypes.TestExecutionTarget?
    /// The execution Id for the test set execution.
    public var testExecutionId: Swift.String?
    /// Indicates whether test set is audio or text.
    public var testExecutionModality: LexModelsV2ClientTypes.TestExecutionModality?
    /// The test execution status for the test execution.
    public var testExecutionStatus: LexModelsV2ClientTypes.TestExecutionStatus?
    /// The test set Id for the test set execution.
    public var testSetId: Swift.String?
    /// The test set name of the test set execution.
    public var testSetName: Swift.String?

    public init(
        apiMode: LexModelsV2ClientTypes.TestExecutionApiMode? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        failureReasons: [Swift.String]? = nil,
        lastUpdatedDateTime: ClientRuntime.Date? = nil,
        target: LexModelsV2ClientTypes.TestExecutionTarget? = nil,
        testExecutionId: Swift.String? = nil,
        testExecutionModality: LexModelsV2ClientTypes.TestExecutionModality? = nil,
        testExecutionStatus: LexModelsV2ClientTypes.TestExecutionStatus? = nil,
        testSetId: Swift.String? = nil,
        testSetName: Swift.String? = nil
    )
    {
        self.apiMode = apiMode
        self.creationDateTime = creationDateTime
        self.failureReasons = failureReasons
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.target = target
        self.testExecutionId = testExecutionId
        self.testExecutionModality = testExecutionModality
        self.testExecutionStatus = testExecutionStatus
        self.testSetId = testSetId
        self.testSetName = testSetName
    }
}

struct DescribeTestExecutionOutputResponseBody: Swift.Equatable {
    let testExecutionId: Swift.String?
    let creationDateTime: ClientRuntime.Date?
    let lastUpdatedDateTime: ClientRuntime.Date?
    let testExecutionStatus: LexModelsV2ClientTypes.TestExecutionStatus?
    let testSetId: Swift.String?
    let testSetName: Swift.String?
    let target: LexModelsV2ClientTypes.TestExecutionTarget?
    let apiMode: LexModelsV2ClientTypes.TestExecutionApiMode?
    let testExecutionModality: LexModelsV2ClientTypes.TestExecutionModality?
    let failureReasons: [Swift.String]?
}

extension DescribeTestExecutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiMode
        case creationDateTime
        case failureReasons
        case lastUpdatedDateTime
        case target
        case testExecutionId
        case testExecutionModality
        case testExecutionStatus
        case testSetId
        case testSetName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testExecutionId)
        testExecutionId = testExecutionIdDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let testExecutionStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestExecutionStatus.self, forKey: .testExecutionStatus)
        testExecutionStatus = testExecutionStatusDecoded
        let testSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testSetId)
        testSetId = testSetIdDecoded
        let testSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testSetName)
        testSetName = testSetNameDecoded
        let targetDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestExecutionTarget.self, forKey: .target)
        target = targetDecoded
        let apiModeDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestExecutionApiMode.self, forKey: .apiMode)
        apiMode = apiModeDecoded
        let testExecutionModalityDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestExecutionModality.self, forKey: .testExecutionModality)
        testExecutionModality = testExecutionModalityDecoded
        let failureReasonsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .failureReasons)
        var failureReasonsDecoded0:[Swift.String]? = nil
        if let failureReasonsContainer = failureReasonsContainer {
            failureReasonsDecoded0 = [Swift.String]()
            for string0 in failureReasonsContainer {
                if let string0 = string0 {
                    failureReasonsDecoded0?.append(string0)
                }
            }
        }
        failureReasons = failureReasonsDecoded0
    }
}

extension DescribeTestSetDiscrepancyReportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let testSetDiscrepancyReportId = testSetDiscrepancyReportId else {
            return nil
        }
        return "/testsetdiscrepancy/\(testSetDiscrepancyReportId.urlPercentEncoding())"
    }
}

public struct DescribeTestSetDiscrepancyReportInput: Swift.Equatable {
    /// The unique identifier of the test set discrepancy report.
    /// This member is required.
    public var testSetDiscrepancyReportId: Swift.String?

    public init(
        testSetDiscrepancyReportId: Swift.String? = nil
    )
    {
        self.testSetDiscrepancyReportId = testSetDiscrepancyReportId
    }
}

struct DescribeTestSetDiscrepancyReportInputBody: Swift.Equatable {
}

extension DescribeTestSetDiscrepancyReportInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum DescribeTestSetDiscrepancyReportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeTestSetDiscrepancyReportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeTestSetDiscrepancyReportOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationDateTime = output.creationDateTime
            self.failureReasons = output.failureReasons
            self.lastUpdatedDataTime = output.lastUpdatedDataTime
            self.target = output.target
            self.testSetDiscrepancyRawOutputUrl = output.testSetDiscrepancyRawOutputUrl
            self.testSetDiscrepancyReportId = output.testSetDiscrepancyReportId
            self.testSetDiscrepancyReportStatus = output.testSetDiscrepancyReportStatus
            self.testSetDiscrepancyTopErrors = output.testSetDiscrepancyTopErrors
            self.testSetId = output.testSetId
        } else {
            self.creationDateTime = nil
            self.failureReasons = nil
            self.lastUpdatedDataTime = nil
            self.target = nil
            self.testSetDiscrepancyRawOutputUrl = nil
            self.testSetDiscrepancyReportId = nil
            self.testSetDiscrepancyReportStatus = nil
            self.testSetDiscrepancyTopErrors = nil
            self.testSetId = nil
        }
    }
}

public struct DescribeTestSetDiscrepancyReportOutputResponse: Swift.Equatable {
    /// The time and date of creation for the test set discrepancy report.
    public var creationDateTime: ClientRuntime.Date?
    /// The failure report for the test set discrepancy report generation action.
    public var failureReasons: [Swift.String]?
    /// The date and time of the last update for the test set discrepancy report.
    public var lastUpdatedDataTime: ClientRuntime.Date?
    /// The target bot location for the test set discrepancy report.
    public var target: LexModelsV2ClientTypes.TestSetDiscrepancyReportResourceTarget?
    /// Pre-signed Amazon S3 URL to download the test set discrepancy report.
    public var testSetDiscrepancyRawOutputUrl: Swift.String?
    /// The unique identifier of the test set discrepancy report to describe.
    public var testSetDiscrepancyReportId: Swift.String?
    /// The status for the test set discrepancy report.
    public var testSetDiscrepancyReportStatus: LexModelsV2ClientTypes.TestSetDiscrepancyReportStatus?
    /// The top 200 error results from the test set discrepancy report.
    public var testSetDiscrepancyTopErrors: LexModelsV2ClientTypes.TestSetDiscrepancyErrors?
    /// The test set Id for the test set discrepancy report.
    public var testSetId: Swift.String?

    public init(
        creationDateTime: ClientRuntime.Date? = nil,
        failureReasons: [Swift.String]? = nil,
        lastUpdatedDataTime: ClientRuntime.Date? = nil,
        target: LexModelsV2ClientTypes.TestSetDiscrepancyReportResourceTarget? = nil,
        testSetDiscrepancyRawOutputUrl: Swift.String? = nil,
        testSetDiscrepancyReportId: Swift.String? = nil,
        testSetDiscrepancyReportStatus: LexModelsV2ClientTypes.TestSetDiscrepancyReportStatus? = nil,
        testSetDiscrepancyTopErrors: LexModelsV2ClientTypes.TestSetDiscrepancyErrors? = nil,
        testSetId: Swift.String? = nil
    )
    {
        self.creationDateTime = creationDateTime
        self.failureReasons = failureReasons
        self.lastUpdatedDataTime = lastUpdatedDataTime
        self.target = target
        self.testSetDiscrepancyRawOutputUrl = testSetDiscrepancyRawOutputUrl
        self.testSetDiscrepancyReportId = testSetDiscrepancyReportId
        self.testSetDiscrepancyReportStatus = testSetDiscrepancyReportStatus
        self.testSetDiscrepancyTopErrors = testSetDiscrepancyTopErrors
        self.testSetId = testSetId
    }
}

struct DescribeTestSetDiscrepancyReportOutputResponseBody: Swift.Equatable {
    let testSetDiscrepancyReportId: Swift.String?
    let testSetId: Swift.String?
    let creationDateTime: ClientRuntime.Date?
    let target: LexModelsV2ClientTypes.TestSetDiscrepancyReportResourceTarget?
    let testSetDiscrepancyReportStatus: LexModelsV2ClientTypes.TestSetDiscrepancyReportStatus?
    let lastUpdatedDataTime: ClientRuntime.Date?
    let testSetDiscrepancyTopErrors: LexModelsV2ClientTypes.TestSetDiscrepancyErrors?
    let testSetDiscrepancyRawOutputUrl: Swift.String?
    let failureReasons: [Swift.String]?
}

extension DescribeTestSetDiscrepancyReportOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case failureReasons
        case lastUpdatedDataTime
        case target
        case testSetDiscrepancyRawOutputUrl
        case testSetDiscrepancyReportId
        case testSetDiscrepancyReportStatus
        case testSetDiscrepancyTopErrors
        case testSetId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testSetDiscrepancyReportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testSetDiscrepancyReportId)
        testSetDiscrepancyReportId = testSetDiscrepancyReportIdDecoded
        let testSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testSetId)
        testSetId = testSetIdDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let targetDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestSetDiscrepancyReportResourceTarget.self, forKey: .target)
        target = targetDecoded
        let testSetDiscrepancyReportStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestSetDiscrepancyReportStatus.self, forKey: .testSetDiscrepancyReportStatus)
        testSetDiscrepancyReportStatus = testSetDiscrepancyReportStatusDecoded
        let lastUpdatedDataTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDataTime)
        lastUpdatedDataTime = lastUpdatedDataTimeDecoded
        let testSetDiscrepancyTopErrorsDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestSetDiscrepancyErrors.self, forKey: .testSetDiscrepancyTopErrors)
        testSetDiscrepancyTopErrors = testSetDiscrepancyTopErrorsDecoded
        let testSetDiscrepancyRawOutputUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testSetDiscrepancyRawOutputUrl)
        testSetDiscrepancyRawOutputUrl = testSetDiscrepancyRawOutputUrlDecoded
        let failureReasonsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .failureReasons)
        var failureReasonsDecoded0:[Swift.String]? = nil
        if let failureReasonsContainer = failureReasonsContainer {
            failureReasonsDecoded0 = [Swift.String]()
            for string0 in failureReasonsContainer {
                if let string0 = string0 {
                    failureReasonsDecoded0?.append(string0)
                }
            }
        }
        failureReasons = failureReasonsDecoded0
    }
}

extension DescribeTestSetGenerationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let testSetGenerationId = testSetGenerationId else {
            return nil
        }
        return "/testsetgenerations/\(testSetGenerationId.urlPercentEncoding())"
    }
}

public struct DescribeTestSetGenerationInput: Swift.Equatable {
    /// The unique identifier of the test set generation.
    /// This member is required.
    public var testSetGenerationId: Swift.String?

    public init(
        testSetGenerationId: Swift.String? = nil
    )
    {
        self.testSetGenerationId = testSetGenerationId
    }
}

struct DescribeTestSetGenerationInputBody: Swift.Equatable {
}

extension DescribeTestSetGenerationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum DescribeTestSetGenerationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeTestSetGenerationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeTestSetGenerationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.failureReasons = output.failureReasons
            self.generationDataSource = output.generationDataSource
            self.lastUpdatedDateTime = output.lastUpdatedDateTime
            self.roleArn = output.roleArn
            self.storageLocation = output.storageLocation
            self.testSetGenerationId = output.testSetGenerationId
            self.testSetGenerationStatus = output.testSetGenerationStatus
            self.testSetId = output.testSetId
            self.testSetName = output.testSetName
        } else {
            self.creationDateTime = nil
            self.description = nil
            self.failureReasons = nil
            self.generationDataSource = nil
            self.lastUpdatedDateTime = nil
            self.roleArn = nil
            self.storageLocation = nil
            self.testSetGenerationId = nil
            self.testSetGenerationStatus = nil
            self.testSetId = nil
            self.testSetName = nil
        }
    }
}

public struct DescribeTestSetGenerationOutputResponse: Swift.Equatable {
    /// The creation date and time for the test set generation.
    public var creationDateTime: ClientRuntime.Date?
    /// The test set description for the test set generation.
    public var description: Swift.String?
    /// The reasons the test set generation failed.
    public var failureReasons: [Swift.String]?
    /// The data source of the test set used for the test set generation.
    public var generationDataSource: LexModelsV2ClientTypes.TestSetGenerationDataSource?
    /// The date and time of the last update for the test set generation.
    public var lastUpdatedDateTime: ClientRuntime.Date?
    /// The roleARN of the test set used for the test set generation.
    public var roleArn: Swift.String?
    /// The Amazon S3 storage location for the test set generation.
    public var storageLocation: LexModelsV2ClientTypes.TestSetStorageLocation?
    /// The unique identifier of the test set generation.
    public var testSetGenerationId: Swift.String?
    /// The status for the test set generation.
    public var testSetGenerationStatus: LexModelsV2ClientTypes.TestSetGenerationStatus?
    /// The unique identifier for the test set created for the generated test set.
    public var testSetId: Swift.String?
    /// The test set name for the generated test set.
    public var testSetName: Swift.String?

    public init(
        creationDateTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        failureReasons: [Swift.String]? = nil,
        generationDataSource: LexModelsV2ClientTypes.TestSetGenerationDataSource? = nil,
        lastUpdatedDateTime: ClientRuntime.Date? = nil,
        roleArn: Swift.String? = nil,
        storageLocation: LexModelsV2ClientTypes.TestSetStorageLocation? = nil,
        testSetGenerationId: Swift.String? = nil,
        testSetGenerationStatus: LexModelsV2ClientTypes.TestSetGenerationStatus? = nil,
        testSetId: Swift.String? = nil,
        testSetName: Swift.String? = nil
    )
    {
        self.creationDateTime = creationDateTime
        self.description = description
        self.failureReasons = failureReasons
        self.generationDataSource = generationDataSource
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.roleArn = roleArn
        self.storageLocation = storageLocation
        self.testSetGenerationId = testSetGenerationId
        self.testSetGenerationStatus = testSetGenerationStatus
        self.testSetId = testSetId
        self.testSetName = testSetName
    }
}

struct DescribeTestSetGenerationOutputResponseBody: Swift.Equatable {
    let testSetGenerationId: Swift.String?
    let testSetGenerationStatus: LexModelsV2ClientTypes.TestSetGenerationStatus?
    let failureReasons: [Swift.String]?
    let testSetId: Swift.String?
    let testSetName: Swift.String?
    let description: Swift.String?
    let storageLocation: LexModelsV2ClientTypes.TestSetStorageLocation?
    let generationDataSource: LexModelsV2ClientTypes.TestSetGenerationDataSource?
    let roleArn: Swift.String?
    let creationDateTime: ClientRuntime.Date?
    let lastUpdatedDateTime: ClientRuntime.Date?
}

extension DescribeTestSetGenerationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case description
        case failureReasons
        case generationDataSource
        case lastUpdatedDateTime
        case roleArn
        case storageLocation
        case testSetGenerationId
        case testSetGenerationStatus
        case testSetId
        case testSetName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testSetGenerationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testSetGenerationId)
        testSetGenerationId = testSetGenerationIdDecoded
        let testSetGenerationStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestSetGenerationStatus.self, forKey: .testSetGenerationStatus)
        testSetGenerationStatus = testSetGenerationStatusDecoded
        let failureReasonsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .failureReasons)
        var failureReasonsDecoded0:[Swift.String]? = nil
        if let failureReasonsContainer = failureReasonsContainer {
            failureReasonsDecoded0 = [Swift.String]()
            for string0 in failureReasonsContainer {
                if let string0 = string0 {
                    failureReasonsDecoded0?.append(string0)
                }
            }
        }
        failureReasons = failureReasonsDecoded0
        let testSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testSetId)
        testSetId = testSetIdDecoded
        let testSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testSetName)
        testSetName = testSetNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let storageLocationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestSetStorageLocation.self, forKey: .storageLocation)
        storageLocation = storageLocationDecoded
        let generationDataSourceDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestSetGenerationDataSource.self, forKey: .generationDataSource)
        generationDataSource = generationDataSourceDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension DescribeTestSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let testSetId = testSetId else {
            return nil
        }
        return "/testsets/\(testSetId.urlPercentEncoding())"
    }
}

public struct DescribeTestSetInput: Swift.Equatable {
    /// The test set Id for the test set request.
    /// This member is required.
    public var testSetId: Swift.String?

    public init(
        testSetId: Swift.String? = nil
    )
    {
        self.testSetId = testSetId
    }
}

struct DescribeTestSetInputBody: Swift.Equatable {
}

extension DescribeTestSetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum DescribeTestSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeTestSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeTestSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.lastUpdatedDateTime = output.lastUpdatedDateTime
            self.modality = output.modality
            self.numTurns = output.numTurns
            self.roleArn = output.roleArn
            self.status = output.status
            self.storageLocation = output.storageLocation
            self.testSetId = output.testSetId
            self.testSetName = output.testSetName
        } else {
            self.creationDateTime = nil
            self.description = nil
            self.lastUpdatedDateTime = nil
            self.modality = nil
            self.numTurns = nil
            self.roleArn = nil
            self.status = nil
            self.storageLocation = nil
            self.testSetId = nil
            self.testSetName = nil
        }
    }
}

public struct DescribeTestSetOutputResponse: Swift.Equatable {
    /// The creation date and time for the test set data.
    public var creationDateTime: ClientRuntime.Date?
    /// The description of the test set.
    public var description: Swift.String?
    /// The date and time for the last update of the test set data.
    public var lastUpdatedDateTime: ClientRuntime.Date?
    /// Indicates whether the test set is audio or text data.
    public var modality: LexModelsV2ClientTypes.TestSetModality?
    /// The total number of agent and user turn in the test set.
    public var numTurns: Swift.Int?
    /// The roleARN used for any operation in the test set to access resources in the Amazon Web Services account.
    public var roleArn: Swift.String?
    /// The status of the test set.
    public var status: LexModelsV2ClientTypes.TestSetStatus?
    /// The Amazon S3 storage location for the test set data.
    public var storageLocation: LexModelsV2ClientTypes.TestSetStorageLocation?
    /// The test set Id for the test set response.
    public var testSetId: Swift.String?
    /// The test set name of the test set.
    public var testSetName: Swift.String?

    public init(
        creationDateTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        lastUpdatedDateTime: ClientRuntime.Date? = nil,
        modality: LexModelsV2ClientTypes.TestSetModality? = nil,
        numTurns: Swift.Int? = nil,
        roleArn: Swift.String? = nil,
        status: LexModelsV2ClientTypes.TestSetStatus? = nil,
        storageLocation: LexModelsV2ClientTypes.TestSetStorageLocation? = nil,
        testSetId: Swift.String? = nil,
        testSetName: Swift.String? = nil
    )
    {
        self.creationDateTime = creationDateTime
        self.description = description
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.modality = modality
        self.numTurns = numTurns
        self.roleArn = roleArn
        self.status = status
        self.storageLocation = storageLocation
        self.testSetId = testSetId
        self.testSetName = testSetName
    }
}

struct DescribeTestSetOutputResponseBody: Swift.Equatable {
    let testSetId: Swift.String?
    let testSetName: Swift.String?
    let description: Swift.String?
    let modality: LexModelsV2ClientTypes.TestSetModality?
    let status: LexModelsV2ClientTypes.TestSetStatus?
    let roleArn: Swift.String?
    let numTurns: Swift.Int?
    let storageLocation: LexModelsV2ClientTypes.TestSetStorageLocation?
    let creationDateTime: ClientRuntime.Date?
    let lastUpdatedDateTime: ClientRuntime.Date?
}

extension DescribeTestSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case description
        case lastUpdatedDateTime
        case modality
        case numTurns
        case roleArn
        case status
        case storageLocation
        case testSetId
        case testSetName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testSetId)
        testSetId = testSetIdDecoded
        let testSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testSetName)
        testSetName = testSetNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let modalityDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestSetModality.self, forKey: .modality)
        modality = modalityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestSetStatus.self, forKey: .status)
        status = statusDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let numTurnsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numTurns)
        numTurns = numTurnsDecoded
        let storageLocationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestSetStorageLocation.self, forKey: .storageLocation)
        storageLocation = storageLocationDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension LexModelsV2ClientTypes.DialogAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case slotToElicit
        case suppressNextMessage
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let slotToElicit = self.slotToElicit {
            try encodeContainer.encode(slotToElicit, forKey: .slotToElicit)
        }
        if let suppressNextMessage = self.suppressNextMessage {
            try encodeContainer.encode(suppressNextMessage, forKey: .suppressNextMessage)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.DialogActionType.self, forKey: .type)
        type = typeDecoded
        let slotToElicitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotToElicit)
        slotToElicit = slotToElicitDecoded
        let suppressNextMessageDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .suppressNextMessage)
        suppressNextMessage = suppressNextMessageDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Defines the action that the bot executes at runtime when the conversation reaches this step.
    public struct DialogAction: Swift.Equatable {
        /// If the dialog action is ElicitSlot, defines the slot to elicit from the user.
        public var slotToElicit: Swift.String?
        /// When true the next message for the intent is not used.
        public var suppressNextMessage: Swift.Bool?
        /// The action that the bot should execute.
        /// This member is required.
        public var type: LexModelsV2ClientTypes.DialogActionType?

        public init(
            slotToElicit: Swift.String? = nil,
            suppressNextMessage: Swift.Bool? = nil,
            type: LexModelsV2ClientTypes.DialogActionType? = nil
        )
        {
            self.slotToElicit = slotToElicit
            self.suppressNextMessage = suppressNextMessage
            self.type = type
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum DialogActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case closeintent
        case confirmintent
        case elicitintent
        case elicitslot
        case endconversation
        case evaluateconditional
        case fulfillintent
        case invokedialogcodehook
        case startintent
        case sdkUnknown(Swift.String)

        public static var allCases: [DialogActionType] {
            return [
                .closeintent,
                .confirmintent,
                .elicitintent,
                .elicitslot,
                .endconversation,
                .evaluateconditional,
                .fulfillintent,
                .invokedialogcodehook,
                .startintent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .closeintent: return "CloseIntent"
            case .confirmintent: return "ConfirmIntent"
            case .elicitintent: return "ElicitIntent"
            case .elicitslot: return "ElicitSlot"
            case .endconversation: return "EndConversation"
            case .evaluateconditional: return "EvaluateConditional"
            case .fulfillintent: return "FulfillIntent"
            case .invokedialogcodehook: return "InvokeDialogCodeHook"
            case .startintent: return "StartIntent"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DialogActionType(rawValue: rawValue) ?? DialogActionType.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.DialogCodeHookInvocationSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case active
        case enableCodeHookInvocation
        case invocationLabel
        case postCodeHookSpecification
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let active = self.active {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let enableCodeHookInvocation = self.enableCodeHookInvocation {
            try encodeContainer.encode(enableCodeHookInvocation, forKey: .enableCodeHookInvocation)
        }
        if let invocationLabel = self.invocationLabel {
            try encodeContainer.encode(invocationLabel, forKey: .invocationLabel)
        }
        if let postCodeHookSpecification = self.postCodeHookSpecification {
            try encodeContainer.encode(postCodeHookSpecification, forKey: .postCodeHookSpecification)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableCodeHookInvocationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableCodeHookInvocation)
        enableCodeHookInvocation = enableCodeHookInvocationDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .active)
        active = activeDecoded
        let invocationLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invocationLabel)
        invocationLabel = invocationLabelDecoded
        let postCodeHookSpecificationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.PostDialogCodeHookInvocationSpecification.self, forKey: .postCodeHookSpecification)
        postCodeHookSpecification = postCodeHookSpecificationDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Settings that specify the dialog code hook that is called by Amazon Lex at a step of the conversation.
    public struct DialogCodeHookInvocationSetting: Swift.Equatable {
        /// Determines whether a dialog code hook is used when the intent is activated.
        /// This member is required.
        public var active: Swift.Bool?
        /// Indicates whether a Lambda function should be invoked for the dialog.
        /// This member is required.
        public var enableCodeHookInvocation: Swift.Bool?
        /// A label that indicates the dialog step from which the dialog code hook is happening.
        public var invocationLabel: Swift.String?
        /// Contains the responses and actions that Amazon Lex takes after the Lambda function is complete.
        /// This member is required.
        public var postCodeHookSpecification: LexModelsV2ClientTypes.PostDialogCodeHookInvocationSpecification?

        public init(
            active: Swift.Bool? = nil,
            enableCodeHookInvocation: Swift.Bool? = nil,
            invocationLabel: Swift.String? = nil,
            postCodeHookSpecification: LexModelsV2ClientTypes.PostDialogCodeHookInvocationSpecification? = nil
        )
        {
            self.active = active
            self.enableCodeHookInvocation = enableCodeHookInvocation
            self.invocationLabel = invocationLabel
            self.postCodeHookSpecification = postCodeHookSpecification
        }
    }

}

extension LexModelsV2ClientTypes.DialogCodeHookSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Settings that determine the Lambda function that Amazon Lex uses for processing user responses.
    public struct DialogCodeHookSettings: Swift.Equatable {
        /// Enables the dialog code hook so that it processes user requests.
        /// This member is required.
        public var enabled: Swift.Bool

        public init(
            enabled: Swift.Bool = false
        )
        {
            self.enabled = enabled
        }
    }

}

extension LexModelsV2ClientTypes.DialogState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dialogAction
        case intent
        case sessionAttributes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dialogAction = self.dialogAction {
            try encodeContainer.encode(dialogAction, forKey: .dialogAction)
        }
        if let intent = self.intent {
            try encodeContainer.encode(intent, forKey: .intent)
        }
        if let sessionAttributes = sessionAttributes {
            var sessionAttributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sessionAttributes)
            for (dictKey0, stringMap0) in sessionAttributes {
                try sessionAttributesContainer.encode(stringMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dialogActionDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.DialogAction.self, forKey: .dialogAction)
        dialogAction = dialogActionDecoded
        let intentDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.IntentOverride.self, forKey: .intent)
        intent = intentDecoded
        let sessionAttributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .sessionAttributes)
        var sessionAttributesDecoded0: [Swift.String:Swift.String]? = nil
        if let sessionAttributesContainer = sessionAttributesContainer {
            sessionAttributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in sessionAttributesContainer {
                if let string0 = string0 {
                    sessionAttributesDecoded0?[key0] = string0
                }
            }
        }
        sessionAttributes = sessionAttributesDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// The current state of the conversation with the user.
    public struct DialogState: Swift.Equatable {
        /// Defines the action that the bot executes at runtime when the conversation reaches this step.
        public var dialogAction: LexModelsV2ClientTypes.DialogAction?
        /// Override settings to configure the intent state.
        public var intent: LexModelsV2ClientTypes.IntentOverride?
        /// Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
        public var sessionAttributes: [Swift.String:Swift.String]?

        public init(
            dialogAction: LexModelsV2ClientTypes.DialogAction? = nil,
            intent: LexModelsV2ClientTypes.IntentOverride? = nil,
            sessionAttributes: [Swift.String:Swift.String]? = nil
        )
        {
            self.dialogAction = dialogAction
            self.intent = intent
            self.sessionAttributes = sessionAttributes
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum Effect: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [Effect] {
            return [
                .allow,
                .deny,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allow: return "Allow"
            case .deny: return "Deny"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Effect(rawValue: rawValue) ?? Effect.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.ElicitationCodeHookInvocationSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableCodeHookInvocation
        case invocationLabel
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enableCodeHookInvocation = self.enableCodeHookInvocation {
            try encodeContainer.encode(enableCodeHookInvocation, forKey: .enableCodeHookInvocation)
        }
        if let invocationLabel = self.invocationLabel {
            try encodeContainer.encode(invocationLabel, forKey: .invocationLabel)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableCodeHookInvocationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableCodeHookInvocation)
        enableCodeHookInvocation = enableCodeHookInvocationDecoded
        let invocationLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invocationLabel)
        invocationLabel = invocationLabelDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Settings that specify the dialog code hook that is called by Amazon Lex between eliciting slot values.
    public struct ElicitationCodeHookInvocationSetting: Swift.Equatable {
        /// Indicates whether a Lambda function should be invoked for the dialog.
        /// This member is required.
        public var enableCodeHookInvocation: Swift.Bool?
        /// A label that indicates the dialog step from which the dialog code hook is happening.
        public var invocationLabel: Swift.String?

        public init(
            enableCodeHookInvocation: Swift.Bool? = nil,
            invocationLabel: Swift.String? = nil
        )
        {
            self.enableCodeHookInvocation = enableCodeHookInvocation
            self.invocationLabel = invocationLabel
        }
    }

}

extension LexModelsV2ClientTypes.EncryptionSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedTranscriptsPassword
        case botLocaleExportPassword
        case kmsKeyArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedTranscriptsPassword = self.associatedTranscriptsPassword {
            try encodeContainer.encode(associatedTranscriptsPassword, forKey: .associatedTranscriptsPassword)
        }
        if let botLocaleExportPassword = self.botLocaleExportPassword {
            try encodeContainer.encode(botLocaleExportPassword, forKey: .botLocaleExportPassword)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let botLocaleExportPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botLocaleExportPassword)
        botLocaleExportPassword = botLocaleExportPasswordDecoded
        let associatedTranscriptsPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedTranscriptsPassword)
        associatedTranscriptsPassword = associatedTranscriptsPasswordDecoded
    }
}

extension LexModelsV2ClientTypes.EncryptionSetting: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EncryptionSetting(kmsKeyArn: \(Swift.String(describing: kmsKeyArn)), associatedTranscriptsPassword: \"CONTENT_REDACTED\", botLocaleExportPassword: \"CONTENT_REDACTED\")"}
}

extension LexModelsV2ClientTypes {
    /// The object representing the passwords that were used to encrypt the data related to the bot recommendation, as well as the KMS key ARN used to encrypt the associated metadata.
    public struct EncryptionSetting: Swift.Equatable {
        /// The password used to encrypt the associated transcript file.
        public var associatedTranscriptsPassword: Swift.String?
        /// The password used to encrypt the recommended bot recommendation file.
        public var botLocaleExportPassword: Swift.String?
        /// The KMS key ARN used to encrypt the metadata associated with the bot recommendation.
        public var kmsKeyArn: Swift.String?

        public init(
            associatedTranscriptsPassword: Swift.String? = nil,
            botLocaleExportPassword: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil
        )
        {
            self.associatedTranscriptsPassword = associatedTranscriptsPassword
            self.botLocaleExportPassword = botLocaleExportPassword
            self.kmsKeyArn = kmsKeyArn
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case duplicateInput
        case internalServerFailure
        case resourceAlreadyExists
        case resourceDoesNotExist
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .duplicateInput,
                .internalServerFailure,
                .resourceAlreadyExists,
                .resourceDoesNotExist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .duplicateInput: return "DUPLICATE_INPUT"
            case .internalServerFailure: return "INTERNAL_SERVER_FAILURE"
            case .resourceAlreadyExists: return "RESOURCE_ALREADY_EXISTS"
            case .resourceDoesNotExist: return "RESOURCE_DOES_NOT_EXIST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.ExecutionErrorDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Details about an error in an execution of a test set.
    public struct ExecutionErrorDetails: Swift.Equatable {
        /// The error code for the error.
        /// This member is required.
        public var errorCode: Swift.String?
        /// The message describing the error.
        /// This member is required.
        public var errorMessage: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension LexModelsV2ClientTypes.ExportFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case `operator` = "operator"
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ExportFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let operatorDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ExportFilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Filters the response form the [ListExports](https://docs.aws.amazon.com/lexv2/latest/APIReference/API_ListExports.html) operation
    public struct ExportFilter: Swift.Equatable {
        /// The name of the field to use for filtering.
        /// This member is required.
        public var name: LexModelsV2ClientTypes.ExportFilterName?
        /// The operator to use for the filter. Specify EQ when the ListExports operation should return only resource types that equal the specified value. Specify CO when the ListExports operation should return resource types that contain the specified value.
        /// This member is required.
        public var `operator`: LexModelsV2ClientTypes.ExportFilterOperator?
        /// The values to use to filter the response. The values must be Bot, BotLocale, or CustomVocabulary.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: LexModelsV2ClientTypes.ExportFilterName? = nil,
            `operator`: LexModelsV2ClientTypes.ExportFilterOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum ExportFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case exportresourcetype
        case sdkUnknown(Swift.String)

        public static var allCases: [ExportFilterName] {
            return [
                .exportresourcetype,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .exportresourcetype: return "ExportResourceType"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExportFilterName(rawValue: rawValue) ?? ExportFilterName.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes {
    public enum ExportFilterOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case contains
        case equals
        case sdkUnknown(Swift.String)

        public static var allCases: [ExportFilterOperator] {
            return [
                .contains,
                .equals,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contains: return "CO"
            case .equals: return "EQ"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExportFilterOperator(rawValue: rawValue) ?? ExportFilterOperator.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.ExportResourceSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botExportSpecification
        case botLocaleExportSpecification
        case customVocabularyExportSpecification
        case testSetExportSpecification
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botExportSpecification = self.botExportSpecification {
            try encodeContainer.encode(botExportSpecification, forKey: .botExportSpecification)
        }
        if let botLocaleExportSpecification = self.botLocaleExportSpecification {
            try encodeContainer.encode(botLocaleExportSpecification, forKey: .botLocaleExportSpecification)
        }
        if let customVocabularyExportSpecification = self.customVocabularyExportSpecification {
            try encodeContainer.encode(customVocabularyExportSpecification, forKey: .customVocabularyExportSpecification)
        }
        if let testSetExportSpecification = self.testSetExportSpecification {
            try encodeContainer.encode(testSetExportSpecification, forKey: .testSetExportSpecification)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botExportSpecificationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotExportSpecification.self, forKey: .botExportSpecification)
        botExportSpecification = botExportSpecificationDecoded
        let botLocaleExportSpecificationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotLocaleExportSpecification.self, forKey: .botLocaleExportSpecification)
        botLocaleExportSpecification = botLocaleExportSpecificationDecoded
        let customVocabularyExportSpecificationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.CustomVocabularyExportSpecification.self, forKey: .customVocabularyExportSpecification)
        customVocabularyExportSpecification = customVocabularyExportSpecificationDecoded
        let testSetExportSpecificationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestSetExportSpecification.self, forKey: .testSetExportSpecification)
        testSetExportSpecification = testSetExportSpecificationDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Provides information about the bot or bot locale that you want to export. You can specify the botExportSpecification or the botLocaleExportSpecification, but not both.
    public struct ExportResourceSpecification: Swift.Equatable {
        /// Parameters for exporting a bot.
        public var botExportSpecification: LexModelsV2ClientTypes.BotExportSpecification?
        /// Parameters for exporting a bot locale.
        public var botLocaleExportSpecification: LexModelsV2ClientTypes.BotLocaleExportSpecification?
        /// The parameters required to export a custom vocabulary.
        public var customVocabularyExportSpecification: LexModelsV2ClientTypes.CustomVocabularyExportSpecification?
        /// Specifications for the test set that is exported as a resource.
        public var testSetExportSpecification: LexModelsV2ClientTypes.TestSetExportSpecification?

        public init(
            botExportSpecification: LexModelsV2ClientTypes.BotExportSpecification? = nil,
            botLocaleExportSpecification: LexModelsV2ClientTypes.BotLocaleExportSpecification? = nil,
            customVocabularyExportSpecification: LexModelsV2ClientTypes.CustomVocabularyExportSpecification? = nil,
            testSetExportSpecification: LexModelsV2ClientTypes.TestSetExportSpecification? = nil
        )
        {
            self.botExportSpecification = botExportSpecification
            self.botLocaleExportSpecification = botLocaleExportSpecification
            self.customVocabularyExportSpecification = customVocabularyExportSpecification
            self.testSetExportSpecification = testSetExportSpecification
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum ExportSortAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lastupdateddatetime
        case sdkUnknown(Swift.String)

        public static var allCases: [ExportSortAttribute] {
            return [
                .lastupdateddatetime,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lastupdateddatetime: return "LastUpdatedDateTime"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExportSortAttribute(rawValue: rawValue) ?? ExportSortAttribute.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.ExportSortBy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute
        case order
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = self.attribute {
            try encodeContainer.encode(attribute.rawValue, forKey: .attribute)
        }
        if let order = self.order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ExportSortAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let orderDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SortOrder.self, forKey: .order)
        order = orderDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Provides information about sorting a list of exports.
    public struct ExportSortBy: Swift.Equatable {
        /// The export field to use for sorting.
        /// This member is required.
        public var attribute: LexModelsV2ClientTypes.ExportSortAttribute?
        /// The order to sort the list.
        /// This member is required.
        public var order: LexModelsV2ClientTypes.SortOrder?

        public init(
            attribute: LexModelsV2ClientTypes.ExportSortAttribute? = nil,
            order: LexModelsV2ClientTypes.SortOrder? = nil
        )
        {
            self.attribute = attribute
            self.order = order
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum ExportStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case deleting
        case failed
        case inprogress
        case sdkUnknown(Swift.String)

        public static var allCases: [ExportStatus] {
            return [
                .completed,
                .deleting,
                .failed,
                .inprogress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .deleting: return "Deleting"
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExportStatus(rawValue: rawValue) ?? ExportStatus.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.ExportSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case exportId
        case exportStatus
        case fileFormat
        case lastUpdatedDateTime
        case resourceSpecification
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let exportId = self.exportId {
            try encodeContainer.encode(exportId, forKey: .exportId)
        }
        if let exportStatus = self.exportStatus {
            try encodeContainer.encode(exportStatus.rawValue, forKey: .exportStatus)
        }
        if let fileFormat = self.fileFormat {
            try encodeContainer.encode(fileFormat.rawValue, forKey: .fileFormat)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let resourceSpecification = self.resourceSpecification {
            try encodeContainer.encode(resourceSpecification, forKey: .resourceSpecification)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportId)
        exportId = exportIdDecoded
        let resourceSpecificationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ExportResourceSpecification.self, forKey: .resourceSpecification)
        resourceSpecification = resourceSpecificationDecoded
        let fileFormatDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ImportExportFileFormat.self, forKey: .fileFormat)
        fileFormat = fileFormatDecoded
        let exportStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ExportStatus.self, forKey: .exportStatus)
        exportStatus = exportStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Provides summary information about an export in an export list.
    public struct ExportSummary: Swift.Equatable {
        /// The date and time that the export was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The unique identifier that Amazon Lex assigned to the export.
        public var exportId: Swift.String?
        /// The status of the export. When the status is Completed the export is ready to download.
        public var exportStatus: LexModelsV2ClientTypes.ExportStatus?
        /// The file format used in the export files.
        public var fileFormat: LexModelsV2ClientTypes.ImportExportFileFormat?
        /// The date and time that the export was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// Information about the bot or bot locale that was exported.
        public var resourceSpecification: LexModelsV2ClientTypes.ExportResourceSpecification?

        public init(
            creationDateTime: ClientRuntime.Date? = nil,
            exportId: Swift.String? = nil,
            exportStatus: LexModelsV2ClientTypes.ExportStatus? = nil,
            fileFormat: LexModelsV2ClientTypes.ImportExportFileFormat? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            resourceSpecification: LexModelsV2ClientTypes.ExportResourceSpecification? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.exportId = exportId
            self.exportStatus = exportStatus
            self.fileFormat = fileFormat
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.resourceSpecification = resourceSpecification
        }
    }

}

extension LexModelsV2ClientTypes.ExternalSourceSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grammarSlotTypeSetting
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grammarSlotTypeSetting = self.grammarSlotTypeSetting {
            try encodeContainer.encode(grammarSlotTypeSetting, forKey: .grammarSlotTypeSetting)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grammarSlotTypeSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.GrammarSlotTypeSetting.self, forKey: .grammarSlotTypeSetting)
        grammarSlotTypeSetting = grammarSlotTypeSettingDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Provides information about the external source of the slot type's definition.
    public struct ExternalSourceSetting: Swift.Equatable {
        /// Settings required for a slot type based on a grammar that you provide.
        public var grammarSlotTypeSetting: LexModelsV2ClientTypes.GrammarSlotTypeSetting?

        public init(
            grammarSlotTypeSetting: LexModelsV2ClientTypes.GrammarSlotTypeSetting? = nil
        )
        {
            self.grammarSlotTypeSetting = grammarSlotTypeSetting
        }
    }

}

extension LexModelsV2ClientTypes.FailedCustomVocabularyItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
        case itemId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let itemId = self.itemId {
            try encodeContainer.encode(itemId, forKey: .itemId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .itemId)
        itemId = itemIdDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// The unique failed custom vocabulary item from the custom vocabulary list.
    public struct FailedCustomVocabularyItem: Swift.Equatable {
        /// The unique error code for the failed custom vocabulary item from the custom vocabulary list.
        public var errorCode: LexModelsV2ClientTypes.ErrorCode?
        /// The error message for the failed custom vocabulary item from the custom vocabulary list.
        public var errorMessage: Swift.String?
        /// The unique item identifer for the failed custom vocabulary item from the custom vocabulary list.
        public var itemId: Swift.String?

        public init(
            errorCode: LexModelsV2ClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            itemId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.itemId = itemId
        }
    }

}

extension LexModelsV2ClientTypes.FulfillmentCodeHookSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case active
        case enabled
        case fulfillmentUpdatesSpecification
        case postFulfillmentStatusSpecification
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let active = self.active {
            try encodeContainer.encode(active, forKey: .active)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let fulfillmentUpdatesSpecification = self.fulfillmentUpdatesSpecification {
            try encodeContainer.encode(fulfillmentUpdatesSpecification, forKey: .fulfillmentUpdatesSpecification)
        }
        if let postFulfillmentStatusSpecification = self.postFulfillmentStatusSpecification {
            try encodeContainer.encode(postFulfillmentStatusSpecification, forKey: .postFulfillmentStatusSpecification)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
        let postFulfillmentStatusSpecificationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.PostFulfillmentStatusSpecification.self, forKey: .postFulfillmentStatusSpecification)
        postFulfillmentStatusSpecification = postFulfillmentStatusSpecificationDecoded
        let fulfillmentUpdatesSpecificationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.FulfillmentUpdatesSpecification.self, forKey: .fulfillmentUpdatesSpecification)
        fulfillmentUpdatesSpecification = fulfillmentUpdatesSpecificationDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .active)
        active = activeDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Determines if a Lambda function should be invoked for a specific intent.
    public struct FulfillmentCodeHookSettings: Swift.Equatable {
        /// Determines whether the fulfillment code hook is used. When active is false, the code hook doesn't run.
        public var active: Swift.Bool?
        /// Indicates whether a Lambda function should be invoked to fulfill a specific intent.
        /// This member is required.
        public var enabled: Swift.Bool
        /// Provides settings for update messages sent to the user for long-running Lambda fulfillment functions. Fulfillment updates can be used only with streaming conversations.
        public var fulfillmentUpdatesSpecification: LexModelsV2ClientTypes.FulfillmentUpdatesSpecification?
        /// Provides settings for messages sent to the user for after the Lambda fulfillment function completes. Post-fulfillment messages can be sent for both streaming and non-streaming conversations.
        public var postFulfillmentStatusSpecification: LexModelsV2ClientTypes.PostFulfillmentStatusSpecification?

        public init(
            active: Swift.Bool? = nil,
            enabled: Swift.Bool = false,
            fulfillmentUpdatesSpecification: LexModelsV2ClientTypes.FulfillmentUpdatesSpecification? = nil,
            postFulfillmentStatusSpecification: LexModelsV2ClientTypes.PostFulfillmentStatusSpecification? = nil
        )
        {
            self.active = active
            self.enabled = enabled
            self.fulfillmentUpdatesSpecification = fulfillmentUpdatesSpecification
            self.postFulfillmentStatusSpecification = postFulfillmentStatusSpecification
        }
    }

}

extension LexModelsV2ClientTypes.FulfillmentStartResponseSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowInterrupt
        case delayInSeconds
        case messageGroups
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowInterrupt = self.allowInterrupt {
            try encodeContainer.encode(allowInterrupt, forKey: .allowInterrupt)
        }
        if let delayInSeconds = self.delayInSeconds {
            try encodeContainer.encode(delayInSeconds, forKey: .delayInSeconds)
        }
        if let messageGroups = messageGroups {
            var messageGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .messageGroups)
            for messagegroup0 in messageGroups {
                try messageGroupsContainer.encode(messagegroup0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delayInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .delayInSeconds)
        delayInSeconds = delayInSecondsDecoded
        let messageGroupsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.MessageGroup?].self, forKey: .messageGroups)
        var messageGroupsDecoded0:[LexModelsV2ClientTypes.MessageGroup]? = nil
        if let messageGroupsContainer = messageGroupsContainer {
            messageGroupsDecoded0 = [LexModelsV2ClientTypes.MessageGroup]()
            for structure0 in messageGroupsContainer {
                if let structure0 = structure0 {
                    messageGroupsDecoded0?.append(structure0)
                }
            }
        }
        messageGroups = messageGroupsDecoded0
        let allowInterruptDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowInterrupt)
        allowInterrupt = allowInterruptDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Provides settings for a message that is sent to the user when a fulfillment Lambda function starts running.
    public struct FulfillmentStartResponseSpecification: Swift.Equatable {
        /// Determines whether the user can interrupt the start message while it is playing.
        public var allowInterrupt: Swift.Bool?
        /// The delay between when the Lambda fulfillment function starts running and the start message is played. If the Lambda function returns before the delay is over, the start message isn't played.
        /// This member is required.
        public var delayInSeconds: Swift.Int?
        /// 1 - 5 message groups that contain start messages. Amazon Lex chooses one of the messages to play to the user.
        /// This member is required.
        public var messageGroups: [LexModelsV2ClientTypes.MessageGroup]?

        public init(
            allowInterrupt: Swift.Bool? = nil,
            delayInSeconds: Swift.Int? = nil,
            messageGroups: [LexModelsV2ClientTypes.MessageGroup]? = nil
        )
        {
            self.allowInterrupt = allowInterrupt
            self.delayInSeconds = delayInSeconds
            self.messageGroups = messageGroups
        }
    }

}

extension LexModelsV2ClientTypes.FulfillmentUpdateResponseSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowInterrupt
        case frequencyInSeconds
        case messageGroups
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowInterrupt = self.allowInterrupt {
            try encodeContainer.encode(allowInterrupt, forKey: .allowInterrupt)
        }
        if let frequencyInSeconds = self.frequencyInSeconds {
            try encodeContainer.encode(frequencyInSeconds, forKey: .frequencyInSeconds)
        }
        if let messageGroups = messageGroups {
            var messageGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .messageGroups)
            for messagegroup0 in messageGroups {
                try messageGroupsContainer.encode(messagegroup0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frequencyInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .frequencyInSeconds)
        frequencyInSeconds = frequencyInSecondsDecoded
        let messageGroupsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.MessageGroup?].self, forKey: .messageGroups)
        var messageGroupsDecoded0:[LexModelsV2ClientTypes.MessageGroup]? = nil
        if let messageGroupsContainer = messageGroupsContainer {
            messageGroupsDecoded0 = [LexModelsV2ClientTypes.MessageGroup]()
            for structure0 in messageGroupsContainer {
                if let structure0 = structure0 {
                    messageGroupsDecoded0?.append(structure0)
                }
            }
        }
        messageGroups = messageGroupsDecoded0
        let allowInterruptDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowInterrupt)
        allowInterrupt = allowInterruptDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Provides settings for a message that is sent periodically to the user while a fulfillment Lambda function is running.
    public struct FulfillmentUpdateResponseSpecification: Swift.Equatable {
        /// Determines whether the user can interrupt an update message while it is playing.
        public var allowInterrupt: Swift.Bool?
        /// The frequency that a message is sent to the user. When the period ends, Amazon Lex chooses a message from the message groups and plays it to the user. If the fulfillment Lambda returns before the first period ends, an update message is not played to the user.
        /// This member is required.
        public var frequencyInSeconds: Swift.Int?
        /// 1 - 5 message groups that contain update messages. Amazon Lex chooses one of the messages to play to the user.
        /// This member is required.
        public var messageGroups: [LexModelsV2ClientTypes.MessageGroup]?

        public init(
            allowInterrupt: Swift.Bool? = nil,
            frequencyInSeconds: Swift.Int? = nil,
            messageGroups: [LexModelsV2ClientTypes.MessageGroup]? = nil
        )
        {
            self.allowInterrupt = allowInterrupt
            self.frequencyInSeconds = frequencyInSeconds
            self.messageGroups = messageGroups
        }
    }

}

extension LexModelsV2ClientTypes.FulfillmentUpdatesSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case active
        case startResponse
        case timeoutInSeconds
        case updateResponse
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let active = self.active {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let startResponse = self.startResponse {
            try encodeContainer.encode(startResponse, forKey: .startResponse)
        }
        if let timeoutInSeconds = self.timeoutInSeconds {
            try encodeContainer.encode(timeoutInSeconds, forKey: .timeoutInSeconds)
        }
        if let updateResponse = self.updateResponse {
            try encodeContainer.encode(updateResponse, forKey: .updateResponse)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .active)
        active = activeDecoded
        let startResponseDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.FulfillmentStartResponseSpecification.self, forKey: .startResponse)
        startResponse = startResponseDecoded
        let updateResponseDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.FulfillmentUpdateResponseSpecification.self, forKey: .updateResponse)
        updateResponse = updateResponseDecoded
        let timeoutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInSeconds)
        timeoutInSeconds = timeoutInSecondsDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Provides information for updating the user on the progress of fulfilling an intent.
    public struct FulfillmentUpdatesSpecification: Swift.Equatable {
        /// Determines whether fulfillment updates are sent to the user. When this field is true, updates are sent. If the active field is set to true, the startResponse, updateResponse, and timeoutInSeconds fields are required.
        /// This member is required.
        public var active: Swift.Bool?
        /// Provides configuration information for the message sent to users when the fulfillment Lambda functions starts running.
        public var startResponse: LexModelsV2ClientTypes.FulfillmentStartResponseSpecification?
        /// The length of time that the fulfillment Lambda function should run before it times out.
        public var timeoutInSeconds: Swift.Int?
        /// Provides configuration information for messages sent periodically to the user while the fulfillment Lambda function is running.
        public var updateResponse: LexModelsV2ClientTypes.FulfillmentUpdateResponseSpecification?

        public init(
            active: Swift.Bool? = nil,
            startResponse: LexModelsV2ClientTypes.FulfillmentStartResponseSpecification? = nil,
            timeoutInSeconds: Swift.Int? = nil,
            updateResponse: LexModelsV2ClientTypes.FulfillmentUpdateResponseSpecification? = nil
        )
        {
            self.active = active
            self.startResponse = startResponse
            self.timeoutInSeconds = timeoutInSeconds
            self.updateResponse = updateResponse
        }
    }

}

extension GetTestExecutionArtifactsUrlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let testExecutionId = testExecutionId else {
            return nil
        }
        return "/testexecutions/\(testExecutionId.urlPercentEncoding())/artifacturl"
    }
}

public struct GetTestExecutionArtifactsUrlInput: Swift.Equatable {
    /// The unique identifier of the completed test execution.
    /// This member is required.
    public var testExecutionId: Swift.String?

    public init(
        testExecutionId: Swift.String? = nil
    )
    {
        self.testExecutionId = testExecutionId
    }
}

struct GetTestExecutionArtifactsUrlInputBody: Swift.Equatable {
}

extension GetTestExecutionArtifactsUrlInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum GetTestExecutionArtifactsUrlOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTestExecutionArtifactsUrlOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTestExecutionArtifactsUrlOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.downloadArtifactsUrl = output.downloadArtifactsUrl
            self.testExecutionId = output.testExecutionId
        } else {
            self.downloadArtifactsUrl = nil
            self.testExecutionId = nil
        }
    }
}

public struct GetTestExecutionArtifactsUrlOutputResponse: Swift.Equatable {
    /// The pre-signed Amazon S3 URL to download completed test execution.
    public var downloadArtifactsUrl: Swift.String?
    /// The unique identifier of the completed test execution.
    public var testExecutionId: Swift.String?

    public init(
        downloadArtifactsUrl: Swift.String? = nil,
        testExecutionId: Swift.String? = nil
    )
    {
        self.downloadArtifactsUrl = downloadArtifactsUrl
        self.testExecutionId = testExecutionId
    }
}

struct GetTestExecutionArtifactsUrlOutputResponseBody: Swift.Equatable {
    let testExecutionId: Swift.String?
    let downloadArtifactsUrl: Swift.String?
}

extension GetTestExecutionArtifactsUrlOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case downloadArtifactsUrl
        case testExecutionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testExecutionId)
        testExecutionId = testExecutionIdDecoded
        let downloadArtifactsUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .downloadArtifactsUrl)
        downloadArtifactsUrl = downloadArtifactsUrlDecoded
    }
}

extension LexModelsV2ClientTypes.GrammarSlotTypeSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.GrammarSlotTypeSource.self, forKey: .source)
        source = sourceDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Settings requried for a slot type based on a grammar that you provide.
    public struct GrammarSlotTypeSetting: Swift.Equatable {
        /// The source of the grammar used to create the slot type.
        public var source: LexModelsV2ClientTypes.GrammarSlotTypeSource?

        public init(
            source: LexModelsV2ClientTypes.GrammarSlotTypeSource? = nil
        )
        {
            self.source = source
        }
    }

}

extension LexModelsV2ClientTypes.GrammarSlotTypeSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyArn
        case s3BucketName
        case s3ObjectKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3ObjectKey = self.s3ObjectKey {
            try encodeContainer.encode(s3ObjectKey, forKey: .s3ObjectKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3ObjectKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3ObjectKey)
        s3ObjectKey = s3ObjectKeyDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Describes the Amazon S3 bucket name and location for the grammar that is the source for the slot type.
    public struct GrammarSlotTypeSource: Swift.Equatable {
        /// The KMS key required to decrypt the contents of the grammar, if any.
        public var kmsKeyArn: Swift.String?
        /// The name of the Amazon S3 bucket that contains the grammar source.
        /// This member is required.
        public var s3BucketName: Swift.String?
        /// The path to the grammar in the Amazon S3 bucket.
        /// This member is required.
        public var s3ObjectKey: Swift.String?

        public init(
            kmsKeyArn: Swift.String? = nil,
            s3BucketName: Swift.String? = nil,
            s3ObjectKey: Swift.String? = nil
        )
        {
            self.kmsKeyArn = kmsKeyArn
            self.s3BucketName = s3BucketName
            self.s3ObjectKey = s3ObjectKey
        }
    }

}

extension LexModelsV2ClientTypes.ImageResponseCard: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case buttons
        case imageUrl
        case subtitle
        case title
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let buttons = buttons {
            var buttonsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .buttons)
            for button0 in buttons {
                try buttonsContainer.encode(button0)
            }
        }
        if let imageUrl = self.imageUrl {
            try encodeContainer.encode(imageUrl, forKey: .imageUrl)
        }
        if let subtitle = self.subtitle {
            try encodeContainer.encode(subtitle, forKey: .subtitle)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let subtitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subtitle)
        subtitle = subtitleDecoded
        let imageUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageUrl)
        imageUrl = imageUrlDecoded
        let buttonsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.Button?].self, forKey: .buttons)
        var buttonsDecoded0:[LexModelsV2ClientTypes.Button]? = nil
        if let buttonsContainer = buttonsContainer {
            buttonsDecoded0 = [LexModelsV2ClientTypes.Button]()
            for structure0 in buttonsContainer {
                if let structure0 = structure0 {
                    buttonsDecoded0?.append(structure0)
                }
            }
        }
        buttons = buttonsDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// A card that is shown to the user by a messaging platform. You define the contents of the card, the card is displayed by the platform. When you use a response card, the response from the user is constrained to the text associated with a button on the card.
    public struct ImageResponseCard: Swift.Equatable {
        /// A list of buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button.
        public var buttons: [LexModelsV2ClientTypes.Button]?
        /// The URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
        public var imageUrl: Swift.String?
        /// The subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
        public var subtitle: Swift.String?
        /// The title to display on the response card. The format of the title is determined by the platform displaying the response card.
        /// This member is required.
        public var title: Swift.String?

        public init(
            buttons: [LexModelsV2ClientTypes.Button]? = nil,
            imageUrl: Swift.String? = nil,
            subtitle: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.buttons = buttons
            self.imageUrl = imageUrl
            self.subtitle = subtitle
            self.title = title
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum ImportExportFileFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case lexjson
        case tsv
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportExportFileFormat] {
            return [
                .csv,
                .lexjson,
                .tsv,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .lexjson: return "LexJson"
            case .tsv: return "TSV"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImportExportFileFormat(rawValue: rawValue) ?? ImportExportFileFormat.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.ImportFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case `operator` = "operator"
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ImportFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let operatorDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ImportFilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Filters the response from the [ListImports](https://docs.aws.amazon.com/lexv2/latest/APIReference/API_ListImports.html) operation.
    public struct ImportFilter: Swift.Equatable {
        /// The name of the field to use for filtering.
        /// This member is required.
        public var name: LexModelsV2ClientTypes.ImportFilterName?
        /// The operator to use for the filter. Specify EQ when the ListImports operation should return only resource types that equal the specified value. Specify CO when the ListImports operation should return resource types that contain the specified value.
        /// This member is required.
        public var `operator`: LexModelsV2ClientTypes.ImportFilterOperator?
        /// The values to use to filter the response. The values must be Bot, BotLocale, or CustomVocabulary.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: LexModelsV2ClientTypes.ImportFilterName? = nil,
            `operator`: LexModelsV2ClientTypes.ImportFilterOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum ImportFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case importresourcetype
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportFilterName] {
            return [
                .importresourcetype,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .importresourcetype: return "ImportResourceType"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImportFilterName(rawValue: rawValue) ?? ImportFilterName.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes {
    public enum ImportFilterOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case contains
        case equals
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportFilterOperator] {
            return [
                .contains,
                .equals,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contains: return "CO"
            case .equals: return "EQ"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImportFilterOperator(rawValue: rawValue) ?? ImportFilterOperator.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.ImportResourceSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botImportSpecification
        case botLocaleImportSpecification
        case customVocabularyImportSpecification
        case testSetImportResourceSpecification
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botImportSpecification = self.botImportSpecification {
            try encodeContainer.encode(botImportSpecification, forKey: .botImportSpecification)
        }
        if let botLocaleImportSpecification = self.botLocaleImportSpecification {
            try encodeContainer.encode(botLocaleImportSpecification, forKey: .botLocaleImportSpecification)
        }
        if let customVocabularyImportSpecification = self.customVocabularyImportSpecification {
            try encodeContainer.encode(customVocabularyImportSpecification, forKey: .customVocabularyImportSpecification)
        }
        if let testSetImportResourceSpecification = self.testSetImportResourceSpecification {
            try encodeContainer.encode(testSetImportResourceSpecification, forKey: .testSetImportResourceSpecification)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botImportSpecificationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotImportSpecification.self, forKey: .botImportSpecification)
        botImportSpecification = botImportSpecificationDecoded
        let botLocaleImportSpecificationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotLocaleImportSpecification.self, forKey: .botLocaleImportSpecification)
        botLocaleImportSpecification = botLocaleImportSpecificationDecoded
        let customVocabularyImportSpecificationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.CustomVocabularyImportSpecification.self, forKey: .customVocabularyImportSpecification)
        customVocabularyImportSpecification = customVocabularyImportSpecificationDecoded
        let testSetImportResourceSpecificationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestSetImportResourceSpecification.self, forKey: .testSetImportResourceSpecification)
        testSetImportResourceSpecification = testSetImportResourceSpecificationDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Provides information about the bot or bot locale that you want to import. You can specify the botImportSpecification or the botLocaleImportSpecification, but not both.
    public struct ImportResourceSpecification: Swift.Equatable {
        /// Parameters for importing a bot.
        public var botImportSpecification: LexModelsV2ClientTypes.BotImportSpecification?
        /// Parameters for importing a bot locale.
        public var botLocaleImportSpecification: LexModelsV2ClientTypes.BotLocaleImportSpecification?
        /// Provides the parameters required for importing a custom vocabulary.
        public var customVocabularyImportSpecification: LexModelsV2ClientTypes.CustomVocabularyImportSpecification?
        /// Specifications for the test set that is imported.
        public var testSetImportResourceSpecification: LexModelsV2ClientTypes.TestSetImportResourceSpecification?

        public init(
            botImportSpecification: LexModelsV2ClientTypes.BotImportSpecification? = nil,
            botLocaleImportSpecification: LexModelsV2ClientTypes.BotLocaleImportSpecification? = nil,
            customVocabularyImportSpecification: LexModelsV2ClientTypes.CustomVocabularyImportSpecification? = nil,
            testSetImportResourceSpecification: LexModelsV2ClientTypes.TestSetImportResourceSpecification? = nil
        )
        {
            self.botImportSpecification = botImportSpecification
            self.botLocaleImportSpecification = botLocaleImportSpecification
            self.customVocabularyImportSpecification = customVocabularyImportSpecification
            self.testSetImportResourceSpecification = testSetImportResourceSpecification
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum ImportResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bot
        case botlocale
        case customvocabulary
        case testset
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportResourceType] {
            return [
                .bot,
                .botlocale,
                .customvocabulary,
                .testset,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bot: return "Bot"
            case .botlocale: return "BotLocale"
            case .customvocabulary: return "CustomVocabulary"
            case .testset: return "TestSet"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImportResourceType(rawValue: rawValue) ?? ImportResourceType.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes {
    public enum ImportSortAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lastupdateddatetime
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportSortAttribute] {
            return [
                .lastupdateddatetime,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lastupdateddatetime: return "LastUpdatedDateTime"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImportSortAttribute(rawValue: rawValue) ?? ImportSortAttribute.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.ImportSortBy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute
        case order
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = self.attribute {
            try encodeContainer.encode(attribute.rawValue, forKey: .attribute)
        }
        if let order = self.order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ImportSortAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let orderDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SortOrder.self, forKey: .order)
        order = orderDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Provides information for sorting a list of imports.
    public struct ImportSortBy: Swift.Equatable {
        /// The export field to use for sorting.
        /// This member is required.
        public var attribute: LexModelsV2ClientTypes.ImportSortAttribute?
        /// The order to sort the list.
        /// This member is required.
        public var order: LexModelsV2ClientTypes.SortOrder?

        public init(
            attribute: LexModelsV2ClientTypes.ImportSortAttribute? = nil,
            order: LexModelsV2ClientTypes.SortOrder? = nil
        )
        {
            self.attribute = attribute
            self.order = order
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum ImportStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case deleting
        case failed
        case inprogress
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportStatus] {
            return [
                .completed,
                .deleting,
                .failed,
                .inprogress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .deleting: return "Deleting"
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImportStatus(rawValue: rawValue) ?? ImportStatus.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.ImportSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case importId
        case importStatus
        case importedResourceId
        case importedResourceName
        case importedResourceType
        case lastUpdatedDateTime
        case mergeStrategy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let importId = self.importId {
            try encodeContainer.encode(importId, forKey: .importId)
        }
        if let importStatus = self.importStatus {
            try encodeContainer.encode(importStatus.rawValue, forKey: .importStatus)
        }
        if let importedResourceId = self.importedResourceId {
            try encodeContainer.encode(importedResourceId, forKey: .importedResourceId)
        }
        if let importedResourceName = self.importedResourceName {
            try encodeContainer.encode(importedResourceName, forKey: .importedResourceName)
        }
        if let importedResourceType = self.importedResourceType {
            try encodeContainer.encode(importedResourceType.rawValue, forKey: .importedResourceType)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let mergeStrategy = self.mergeStrategy {
            try encodeContainer.encode(mergeStrategy.rawValue, forKey: .mergeStrategy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importId)
        importId = importIdDecoded
        let importedResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importedResourceId)
        importedResourceId = importedResourceIdDecoded
        let importedResourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importedResourceName)
        importedResourceName = importedResourceNameDecoded
        let importStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ImportStatus.self, forKey: .importStatus)
        importStatus = importStatusDecoded
        let mergeStrategyDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.MergeStrategy.self, forKey: .mergeStrategy)
        mergeStrategy = mergeStrategyDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let importedResourceTypeDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ImportResourceType.self, forKey: .importedResourceType)
        importedResourceType = importedResourceTypeDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Provides summary information about an import in an import list.
    public struct ImportSummary: Swift.Equatable {
        /// The date and time that the import was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The unique identifier that Amazon Lex assigned to the import.
        public var importId: Swift.String?
        /// The status of the resource. When the status is Completed the resource is ready to build.
        public var importStatus: LexModelsV2ClientTypes.ImportStatus?
        /// The unique identifier that Amazon Lex assigned to the imported resource.
        public var importedResourceId: Swift.String?
        /// The name that you gave the imported resource.
        public var importedResourceName: Swift.String?
        /// The type of resource that was imported.
        public var importedResourceType: LexModelsV2ClientTypes.ImportResourceType?
        /// The date and time that the import was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The strategy used to merge existing bot or bot locale definitions with the imported definition.
        public var mergeStrategy: LexModelsV2ClientTypes.MergeStrategy?

        public init(
            creationDateTime: ClientRuntime.Date? = nil,
            importId: Swift.String? = nil,
            importStatus: LexModelsV2ClientTypes.ImportStatus? = nil,
            importedResourceId: Swift.String? = nil,
            importedResourceName: Swift.String? = nil,
            importedResourceType: LexModelsV2ClientTypes.ImportResourceType? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            mergeStrategy: LexModelsV2ClientTypes.MergeStrategy? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.importId = importId
            self.importStatus = importStatus
            self.importedResourceId = importedResourceId
            self.importedResourceName = importedResourceName
            self.importedResourceType = importedResourceType
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.mergeStrategy = mergeStrategy
        }
    }

}

extension LexModelsV2ClientTypes.InitialResponseSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeHook
        case conditional
        case initialResponse
        case nextStep
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeHook = self.codeHook {
            try encodeContainer.encode(codeHook, forKey: .codeHook)
        }
        if let conditional = self.conditional {
            try encodeContainer.encode(conditional, forKey: .conditional)
        }
        if let initialResponse = self.initialResponse {
            try encodeContainer.encode(initialResponse, forKey: .initialResponse)
        }
        if let nextStep = self.nextStep {
            try encodeContainer.encode(nextStep, forKey: .nextStep)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialResponseDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ResponseSpecification.self, forKey: .initialResponse)
        initialResponse = initialResponseDecoded
        let nextStepDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.DialogState.self, forKey: .nextStep)
        nextStep = nextStepDecoded
        let conditionalDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ConditionalSpecification.self, forKey: .conditional)
        conditional = conditionalDecoded
        let codeHookDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.DialogCodeHookInvocationSetting.self, forKey: .codeHook)
        codeHook = codeHookDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Configuration setting for a response sent to the user before Amazon Lex starts eliciting slots.
    public struct InitialResponseSetting: Swift.Equatable {
        /// Settings that specify the dialog code hook that is called by Amazon Lex at a step of the conversation.
        public var codeHook: LexModelsV2ClientTypes.DialogCodeHookInvocationSetting?
        /// Provides a list of conditional branches. Branches are evaluated in the order that they are entered in the list. The first branch with a condition that evaluates to true is executed. The last branch in the list is the default branch. The default branch should not have any condition expression. The default branch is executed if no other branch has a matching condition.
        public var conditional: LexModelsV2ClientTypes.ConditionalSpecification?
        /// Specifies a list of message groups that Amazon Lex uses to respond the user input.
        public var initialResponse: LexModelsV2ClientTypes.ResponseSpecification?
        /// The next step in the conversation.
        public var nextStep: LexModelsV2ClientTypes.DialogState?

        public init(
            codeHook: LexModelsV2ClientTypes.DialogCodeHookInvocationSetting? = nil,
            conditional: LexModelsV2ClientTypes.ConditionalSpecification? = nil,
            initialResponse: LexModelsV2ClientTypes.ResponseSpecification? = nil,
            nextStep: LexModelsV2ClientTypes.DialogState? = nil
        )
        {
            self.codeHook = codeHook
            self.conditional = conditional
            self.initialResponse = initialResponse
            self.nextStep = nextStep
        }
    }

}

extension LexModelsV2ClientTypes.InputContext: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// A context that must be active for an intent to be selected by Amazon Lex.
    public struct InputContext: Swift.Equatable {
        /// The name of the context.
        /// This member is required.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension LexModelsV2ClientTypes.InputSessionStateSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeContexts
        case runtimeHints
        case sessionAttributes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeContexts = activeContexts {
            var activeContextsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .activeContexts)
            for activecontext0 in activeContexts {
                try activeContextsContainer.encode(activecontext0)
            }
        }
        if let runtimeHints = self.runtimeHints {
            try encodeContainer.encode(runtimeHints, forKey: .runtimeHints)
        }
        if let sessionAttributes = sessionAttributes {
            var sessionAttributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sessionAttributes)
            for (dictKey0, stringMap0) in sessionAttributes {
                try sessionAttributesContainer.encode(stringMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionAttributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .sessionAttributes)
        var sessionAttributesDecoded0: [Swift.String:Swift.String]? = nil
        if let sessionAttributesContainer = sessionAttributesContainer {
            sessionAttributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in sessionAttributesContainer {
                if let string0 = string0 {
                    sessionAttributesDecoded0?[key0] = string0
                }
            }
        }
        sessionAttributes = sessionAttributesDecoded0
        let activeContextsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.ActiveContext?].self, forKey: .activeContexts)
        var activeContextsDecoded0:[LexModelsV2ClientTypes.ActiveContext]? = nil
        if let activeContextsContainer = activeContextsContainer {
            activeContextsDecoded0 = [LexModelsV2ClientTypes.ActiveContext]()
            for structure0 in activeContextsContainer {
                if let structure0 = structure0 {
                    activeContextsDecoded0?.append(structure0)
                }
            }
        }
        activeContexts = activeContextsDecoded0
        let runtimeHintsDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.RuntimeHints.self, forKey: .runtimeHints)
        runtimeHints = runtimeHintsDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Specifications for the current state of the dialog between the user and the bot in the test set.
    public struct InputSessionStateSpecification: Swift.Equatable {
        /// Active contexts for the session state.
        public var activeContexts: [LexModelsV2ClientTypes.ActiveContext]?
        /// Runtime hints for the session state.
        public var runtimeHints: LexModelsV2ClientTypes.RuntimeHints?
        /// Session attributes for the session state.
        public var sessionAttributes: [Swift.String:Swift.String]?

        public init(
            activeContexts: [LexModelsV2ClientTypes.ActiveContext]? = nil,
            runtimeHints: LexModelsV2ClientTypes.RuntimeHints? = nil,
            sessionAttributes: [Swift.String:Swift.String]? = nil
        )
        {
            self.activeContexts = activeContexts
            self.runtimeHints = runtimeHints
            self.sessionAttributes = sessionAttributes
        }
    }

}

extension LexModelsV2ClientTypes.IntentClassificationTestResultItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case intentName
        case multiTurnConversation
        case resultCounts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let intentName = self.intentName {
            try encodeContainer.encode(intentName, forKey: .intentName)
        }
        if multiTurnConversation != false {
            try encodeContainer.encode(multiTurnConversation, forKey: .multiTurnConversation)
        }
        if let resultCounts = self.resultCounts {
            try encodeContainer.encode(resultCounts, forKey: .resultCounts)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intentName)
        intentName = intentNameDecoded
        let multiTurnConversationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiTurnConversation) ?? false
        multiTurnConversation = multiTurnConversationDecoded
        let resultCountsDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.IntentClassificationTestResultItemCounts.self, forKey: .resultCounts)
        resultCounts = resultCountsDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Information for an intent that is classified by the test workbench.
    public struct IntentClassificationTestResultItem: Swift.Equatable {
        /// The name of the intent.
        /// This member is required.
        public var intentName: Swift.String?
        /// Indicates whether the conversation involves multiple turns or not.
        /// This member is required.
        public var multiTurnConversation: Swift.Bool
        /// The result of the intent classification test.
        /// This member is required.
        public var resultCounts: LexModelsV2ClientTypes.IntentClassificationTestResultItemCounts?

        public init(
            intentName: Swift.String? = nil,
            multiTurnConversation: Swift.Bool = false,
            resultCounts: LexModelsV2ClientTypes.IntentClassificationTestResultItemCounts? = nil
        )
        {
            self.intentName = intentName
            self.multiTurnConversation = multiTurnConversation
            self.resultCounts = resultCounts
        }
    }

}

extension LexModelsV2ClientTypes.IntentClassificationTestResultItemCounts: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case intentMatchResultCounts
        case speechTranscriptionResultCounts
        case totalResultCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let intentMatchResultCounts = intentMatchResultCounts {
            var intentMatchResultCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .intentMatchResultCounts)
            for (dictKey0, testResultMatchStatusCountMap0) in intentMatchResultCounts {
                try intentMatchResultCountsContainer.encode(testResultMatchStatusCountMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let speechTranscriptionResultCounts = speechTranscriptionResultCounts {
            var speechTranscriptionResultCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .speechTranscriptionResultCounts)
            for (dictKey0, testResultMatchStatusCountMap0) in speechTranscriptionResultCounts {
                try speechTranscriptionResultCountsContainer.encode(testResultMatchStatusCountMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let totalResultCount = self.totalResultCount {
            try encodeContainer.encode(totalResultCount, forKey: .totalResultCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalResultCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalResultCount)
        totalResultCount = totalResultCountDecoded
        let speechTranscriptionResultCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .speechTranscriptionResultCounts)
        var speechTranscriptionResultCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let speechTranscriptionResultCountsContainer = speechTranscriptionResultCountsContainer {
            speechTranscriptionResultCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, count0) in speechTranscriptionResultCountsContainer {
                if let count0 = count0 {
                    speechTranscriptionResultCountsDecoded0?[key0] = count0
                }
            }
        }
        speechTranscriptionResultCounts = speechTranscriptionResultCountsDecoded0
        let intentMatchResultCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .intentMatchResultCounts)
        var intentMatchResultCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let intentMatchResultCountsContainer = intentMatchResultCountsContainer {
            intentMatchResultCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, count0) in intentMatchResultCountsContainer {
                if let count0 = count0 {
                    intentMatchResultCountsDecoded0?[key0] = count0
                }
            }
        }
        intentMatchResultCounts = intentMatchResultCountsDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// The number of items in the intent classification test.
    public struct IntentClassificationTestResultItemCounts: Swift.Equatable {
        /// The number of matched and mismatched results for intent recognition for the intent.
        /// This member is required.
        public var intentMatchResultCounts: [Swift.String:Swift.Int]?
        /// The number of matched, mismatched, and execution error results for speech transcription for the intent.
        public var speechTranscriptionResultCounts: [Swift.String:Swift.Int]?
        /// The total number of results in the intent classification test.
        /// This member is required.
        public var totalResultCount: Swift.Int?

        public init(
            intentMatchResultCounts: [Swift.String:Swift.Int]? = nil,
            speechTranscriptionResultCounts: [Swift.String:Swift.Int]? = nil,
            totalResultCount: Swift.Int? = nil
        )
        {
            self.intentMatchResultCounts = intentMatchResultCounts
            self.speechTranscriptionResultCounts = speechTranscriptionResultCounts
            self.totalResultCount = totalResultCount
        }
    }

}

extension LexModelsV2ClientTypes.IntentClassificationTestResults: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for intentclassificationtestresultitem0 in items {
                try itemsContainer.encode(intentclassificationtestresultitem0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.IntentClassificationTestResultItem?].self, forKey: .items)
        var itemsDecoded0:[LexModelsV2ClientTypes.IntentClassificationTestResultItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [LexModelsV2ClientTypes.IntentClassificationTestResultItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// Information for the results of the intent classification test.
    public struct IntentClassificationTestResults: Swift.Equatable {
        /// A list of the results for the intent classification test.
        /// This member is required.
        public var items: [LexModelsV2ClientTypes.IntentClassificationTestResultItem]?

        public init(
            items: [LexModelsV2ClientTypes.IntentClassificationTestResultItem]? = nil
        )
        {
            self.items = items
        }
    }

}

extension LexModelsV2ClientTypes.IntentClosingSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case active
        case closingResponse
        case conditional
        case nextStep
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let active = self.active {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let closingResponse = self.closingResponse {
            try encodeContainer.encode(closingResponse, forKey: .closingResponse)
        }
        if let conditional = self.conditional {
            try encodeContainer.encode(conditional, forKey: .conditional)
        }
        if let nextStep = self.nextStep {
            try encodeContainer.encode(nextStep, forKey: .nextStep)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let closingResponseDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ResponseSpecification.self, forKey: .closingResponse)
        closingResponse = closingResponseDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .active)
        active = activeDecoded
        let nextStepDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.DialogState.self, forKey: .nextStep)
        nextStep = nextStepDecoded
        let conditionalDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ConditionalSpecification.self, forKey: .conditional)
        conditional = conditionalDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Provides a statement the Amazon Lex conveys to the user when the intent is successfully fulfilled.
    public struct IntentClosingSetting: Swift.Equatable {
        /// Specifies whether an intent's closing response is used. When this field is false, the closing response isn't sent to the user. If the active field isn't specified, the default is true.
        public var active: Swift.Bool?
        /// The response that Amazon Lex sends to the user when the intent is complete.
        public var closingResponse: LexModelsV2ClientTypes.ResponseSpecification?
        /// A list of conditional branches associated with the intent's closing response. These branches are executed when the nextStep attribute is set to EvalutateConditional.
        public var conditional: LexModelsV2ClientTypes.ConditionalSpecification?
        /// Specifies the next step that the bot executes after playing the intent's closing response.
        public var nextStep: LexModelsV2ClientTypes.DialogState?

        public init(
            active: Swift.Bool? = nil,
            closingResponse: LexModelsV2ClientTypes.ResponseSpecification? = nil,
            conditional: LexModelsV2ClientTypes.ConditionalSpecification? = nil,
            nextStep: LexModelsV2ClientTypes.DialogState? = nil
        )
        {
            self.active = active
            self.closingResponse = closingResponse
            self.conditional = conditional
            self.nextStep = nextStep
        }
    }

}

extension LexModelsV2ClientTypes.IntentConfirmationSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case active
        case codeHook
        case confirmationConditional
        case confirmationNextStep
        case confirmationResponse
        case declinationConditional
        case declinationNextStep
        case declinationResponse
        case elicitationCodeHook
        case failureConditional
        case failureNextStep
        case failureResponse
        case promptSpecification
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let active = self.active {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let codeHook = self.codeHook {
            try encodeContainer.encode(codeHook, forKey: .codeHook)
        }
        if let confirmationConditional = self.confirmationConditional {
            try encodeContainer.encode(confirmationConditional, forKey: .confirmationConditional)
        }
        if let confirmationNextStep = self.confirmationNextStep {
            try encodeContainer.encode(confirmationNextStep, forKey: .confirmationNextStep)
        }
        if let confirmationResponse = self.confirmationResponse {
            try encodeContainer.encode(confirmationResponse, forKey: .confirmationResponse)
        }
        if let declinationConditional = self.declinationConditional {
            try encodeContainer.encode(declinationConditional, forKey: .declinationConditional)
        }
        if let declinationNextStep = self.declinationNextStep {
            try encodeContainer.encode(declinationNextStep, forKey: .declinationNextStep)
        }
        if let declinationResponse = self.declinationResponse {
            try encodeContainer.encode(declinationResponse, forKey: .declinationResponse)
        }
        if let elicitationCodeHook = self.elicitationCodeHook {
            try encodeContainer.encode(elicitationCodeHook, forKey: .elicitationCodeHook)
        }
        if let failureConditional = self.failureConditional {
            try encodeContainer.encode(failureConditional, forKey: .failureConditional)
        }
        if let failureNextStep = self.failureNextStep {
            try encodeContainer.encode(failureNextStep, forKey: .failureNextStep)
        }
        if let failureResponse = self.failureResponse {
            try encodeContainer.encode(failureResponse, forKey: .failureResponse)
        }
        if let promptSpecification = self.promptSpecification {
            try encodeContainer.encode(promptSpecification, forKey: .promptSpecification)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let promptSpecificationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.PromptSpecification.self, forKey: .promptSpecification)
        promptSpecification = promptSpecificationDecoded
        let declinationResponseDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ResponseSpecification.self, forKey: .declinationResponse)
        declinationResponse = declinationResponseDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .active)
        active = activeDecoded
        let confirmationResponseDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ResponseSpecification.self, forKey: .confirmationResponse)
        confirmationResponse = confirmationResponseDecoded
        let confirmationNextStepDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.DialogState.self, forKey: .confirmationNextStep)
        confirmationNextStep = confirmationNextStepDecoded
        let confirmationConditionalDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ConditionalSpecification.self, forKey: .confirmationConditional)
        confirmationConditional = confirmationConditionalDecoded
        let declinationNextStepDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.DialogState.self, forKey: .declinationNextStep)
        declinationNextStep = declinationNextStepDecoded
        let declinationConditionalDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ConditionalSpecification.self, forKey: .declinationConditional)
        declinationConditional = declinationConditionalDecoded
        let failureResponseDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ResponseSpecification.self, forKey: .failureResponse)
        failureResponse = failureResponseDecoded
        let failureNextStepDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.DialogState.self, forKey: .failureNextStep)
        failureNextStep = failureNextStepDecoded
        let failureConditionalDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ConditionalSpecification.self, forKey: .failureConditional)
        failureConditional = failureConditionalDecoded
        let codeHookDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.DialogCodeHookInvocationSetting.self, forKey: .codeHook)
        codeHook = codeHookDecoded
        let elicitationCodeHookDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ElicitationCodeHookInvocationSetting.self, forKey: .elicitationCodeHook)
        elicitationCodeHook = elicitationCodeHookDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Provides a prompt for making sure that the user is ready for the intent to be fulfilled.
    public struct IntentConfirmationSetting: Swift.Equatable {
        /// Specifies whether the intent's confirmation is sent to the user. When this field is false, confirmation and declination responses aren't sent. If the active field isn't specified, the default is true.
        public var active: Swift.Bool?
        /// The DialogCodeHookInvocationSetting object associated with intent's confirmation step. The dialog code hook is triggered based on these invocation settings when the confirmation next step or declination next step or failure next step is InvokeDialogCodeHook.
        public var codeHook: LexModelsV2ClientTypes.DialogCodeHookInvocationSetting?
        /// A list of conditional branches to evaluate after the intent is closed.
        public var confirmationConditional: LexModelsV2ClientTypes.ConditionalSpecification?
        /// Specifies the next step that the bot executes when the customer confirms the intent.
        public var confirmationNextStep: LexModelsV2ClientTypes.DialogState?
        /// Specifies a list of message groups that Amazon Lex uses to respond the user input.
        public var confirmationResponse: LexModelsV2ClientTypes.ResponseSpecification?
        /// A list of conditional branches to evaluate after the intent is declined.
        public var declinationConditional: LexModelsV2ClientTypes.ConditionalSpecification?
        /// Specifies the next step that the bot executes when the customer declines the intent.
        public var declinationNextStep: LexModelsV2ClientTypes.DialogState?
        /// When the user answers "no" to the question defined in promptSpecification, Amazon Lex responds with this response to acknowledge that the intent was canceled.
        public var declinationResponse: LexModelsV2ClientTypes.ResponseSpecification?
        /// The DialogCodeHookInvocationSetting used when the code hook is invoked during confirmation prompt retries.
        public var elicitationCodeHook: LexModelsV2ClientTypes.ElicitationCodeHookInvocationSetting?
        /// Provides a list of conditional branches. Branches are evaluated in the order that they are entered in the list. The first branch with a condition that evaluates to true is executed. The last branch in the list is the default branch. The default branch should not have any condition expression. The default branch is executed if no other branch has a matching condition.
        public var failureConditional: LexModelsV2ClientTypes.ConditionalSpecification?
        /// The next step to take in the conversation if the confirmation step fails.
        public var failureNextStep: LexModelsV2ClientTypes.DialogState?
        /// Specifies a list of message groups that Amazon Lex uses to respond the user input.
        public var failureResponse: LexModelsV2ClientTypes.ResponseSpecification?
        /// Prompts the user to confirm the intent. This question should have a yes or no answer. Amazon Lex uses this prompt to ensure that the user acknowledges that the intent is ready for fulfillment. For example, with the OrderPizza intent, you might want to confirm that the order is correct before placing it. For other intents, such as intents that simply respond to user questions, you might not need to ask the user for confirmation before providing the information.
        /// This member is required.
        public var promptSpecification: LexModelsV2ClientTypes.PromptSpecification?

        public init(
            active: Swift.Bool? = nil,
            codeHook: LexModelsV2ClientTypes.DialogCodeHookInvocationSetting? = nil,
            confirmationConditional: LexModelsV2ClientTypes.ConditionalSpecification? = nil,
            confirmationNextStep: LexModelsV2ClientTypes.DialogState? = nil,
            confirmationResponse: LexModelsV2ClientTypes.ResponseSpecification? = nil,
            declinationConditional: LexModelsV2ClientTypes.ConditionalSpecification? = nil,
            declinationNextStep: LexModelsV2ClientTypes.DialogState? = nil,
            declinationResponse: LexModelsV2ClientTypes.ResponseSpecification? = nil,
            elicitationCodeHook: LexModelsV2ClientTypes.ElicitationCodeHookInvocationSetting? = nil,
            failureConditional: LexModelsV2ClientTypes.ConditionalSpecification? = nil,
            failureNextStep: LexModelsV2ClientTypes.DialogState? = nil,
            failureResponse: LexModelsV2ClientTypes.ResponseSpecification? = nil,
            promptSpecification: LexModelsV2ClientTypes.PromptSpecification? = nil
        )
        {
            self.active = active
            self.codeHook = codeHook
            self.confirmationConditional = confirmationConditional
            self.confirmationNextStep = confirmationNextStep
            self.confirmationResponse = confirmationResponse
            self.declinationConditional = declinationConditional
            self.declinationNextStep = declinationNextStep
            self.declinationResponse = declinationResponse
            self.elicitationCodeHook = elicitationCodeHook
            self.failureConditional = failureConditional
            self.failureNextStep = failureNextStep
            self.failureResponse = failureResponse
            self.promptSpecification = promptSpecification
        }
    }

}

extension LexModelsV2ClientTypes.IntentFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case `operator` = "operator"
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.IntentFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let operatorDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.IntentFilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Filters the response from the ListIntents operation.
    public struct IntentFilter: Swift.Equatable {
        /// The name of the field to use for the filter.
        /// This member is required.
        public var name: LexModelsV2ClientTypes.IntentFilterName?
        /// The operator to use for the filter. Specify EQ when the ListIntents operation should return only aliases that equal the specified value. Specify CO when the ListIntents operation should return aliases that contain the specified value.
        /// This member is required.
        public var `operator`: LexModelsV2ClientTypes.IntentFilterOperator?
        /// The value to use for the filter.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: LexModelsV2ClientTypes.IntentFilterName? = nil,
            `operator`: LexModelsV2ClientTypes.IntentFilterOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum IntentFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case intentname
        case sdkUnknown(Swift.String)

        public static var allCases: [IntentFilterName] {
            return [
                .intentname,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .intentname: return "IntentName"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IntentFilterName(rawValue: rawValue) ?? IntentFilterName.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes {
    public enum IntentFilterOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case contains
        case equals
        case sdkUnknown(Swift.String)

        public static var allCases: [IntentFilterOperator] {
            return [
                .contains,
                .equals,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contains: return "CO"
            case .equals: return "EQ"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IntentFilterOperator(rawValue: rawValue) ?? IntentFilterOperator.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.IntentLevelSlotResolutionTestResultItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case intentName
        case multiTurnConversation
        case slotResolutionResults
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let intentName = self.intentName {
            try encodeContainer.encode(intentName, forKey: .intentName)
        }
        if multiTurnConversation != false {
            try encodeContainer.encode(multiTurnConversation, forKey: .multiTurnConversation)
        }
        if let slotResolutionResults = slotResolutionResults {
            var slotResolutionResultsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .slotResolutionResults)
            for slotresolutiontestresultitem0 in slotResolutionResults {
                try slotResolutionResultsContainer.encode(slotresolutiontestresultitem0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intentName)
        intentName = intentNameDecoded
        let multiTurnConversationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiTurnConversation) ?? false
        multiTurnConversation = multiTurnConversationDecoded
        let slotResolutionResultsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.SlotResolutionTestResultItem?].self, forKey: .slotResolutionResults)
        var slotResolutionResultsDecoded0:[LexModelsV2ClientTypes.SlotResolutionTestResultItem]? = nil
        if let slotResolutionResultsContainer = slotResolutionResultsContainer {
            slotResolutionResultsDecoded0 = [LexModelsV2ClientTypes.SlotResolutionTestResultItem]()
            for structure0 in slotResolutionResultsContainer {
                if let structure0 = structure0 {
                    slotResolutionResultsDecoded0?.append(structure0)
                }
            }
        }
        slotResolutionResults = slotResolutionResultsDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// Information about intent-level slot resolution in a test result.
    public struct IntentLevelSlotResolutionTestResultItem: Swift.Equatable {
        /// The name of the intent that was recognized.
        /// This member is required.
        public var intentName: Swift.String?
        /// Indicates whether the conversation involves multiple turns or not.
        /// This member is required.
        public var multiTurnConversation: Swift.Bool
        /// The results for the slot resolution in the test execution result.
        /// This member is required.
        public var slotResolutionResults: [LexModelsV2ClientTypes.SlotResolutionTestResultItem]?

        public init(
            intentName: Swift.String? = nil,
            multiTurnConversation: Swift.Bool = false,
            slotResolutionResults: [LexModelsV2ClientTypes.SlotResolutionTestResultItem]? = nil
        )
        {
            self.intentName = intentName
            self.multiTurnConversation = multiTurnConversation
            self.slotResolutionResults = slotResolutionResults
        }
    }

}

extension LexModelsV2ClientTypes.IntentLevelSlotResolutionTestResults: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for intentlevelslotresolutiontestresultitem0 in items {
                try itemsContainer.encode(intentlevelslotresolutiontestresultitem0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.IntentLevelSlotResolutionTestResultItem?].self, forKey: .items)
        var itemsDecoded0:[LexModelsV2ClientTypes.IntentLevelSlotResolutionTestResultItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [LexModelsV2ClientTypes.IntentLevelSlotResolutionTestResultItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// Indicates the success or failure of slots at the intent level.
    public struct IntentLevelSlotResolutionTestResults: Swift.Equatable {
        /// Indicates the items for the slot level resolution for the intents.
        /// This member is required.
        public var items: [LexModelsV2ClientTypes.IntentLevelSlotResolutionTestResultItem]?

        public init(
            items: [LexModelsV2ClientTypes.IntentLevelSlotResolutionTestResultItem]? = nil
        )
        {
            self.items = items
        }
    }

}

extension LexModelsV2ClientTypes.IntentOverride: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case slots
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let slots = slots {
            var slotsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .slots)
            for (dictKey0, slotValueOverrideMap0) in slots {
                try slotsContainer.encode(slotValueOverrideMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let slotsContainer = try containerValues.decodeIfPresent([Swift.String: LexModelsV2ClientTypes.SlotValueOverride?].self, forKey: .slots)
        var slotsDecoded0: [Swift.String:LexModelsV2ClientTypes.SlotValueOverride]? = nil
        if let slotsContainer = slotsContainer {
            slotsDecoded0 = [Swift.String:LexModelsV2ClientTypes.SlotValueOverride]()
            for (key0, slotvalueoverride0) in slotsContainer {
                if let slotvalueoverride0 = slotvalueoverride0 {
                    slotsDecoded0?[key0] = slotvalueoverride0
                }
            }
        }
        slots = slotsDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// Override settings to configure the intent state.
    public struct IntentOverride: Swift.Equatable {
        /// The name of the intent. Only required when you're switching intents.
        public var name: Swift.String?
        /// A map of all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden.
        public var slots: [Swift.String:LexModelsV2ClientTypes.SlotValueOverride]?

        public init(
            name: Swift.String? = nil,
            slots: [Swift.String:LexModelsV2ClientTypes.SlotValueOverride]? = nil
        )
        {
            self.name = name
            self.slots = slots
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum IntentSortAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case intentname
        case lastupdateddatetime
        case sdkUnknown(Swift.String)

        public static var allCases: [IntentSortAttribute] {
            return [
                .intentname,
                .lastupdateddatetime,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .intentname: return "IntentName"
            case .lastupdateddatetime: return "LastUpdatedDateTime"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IntentSortAttribute(rawValue: rawValue) ?? IntentSortAttribute.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.IntentSortBy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute
        case order
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = self.attribute {
            try encodeContainer.encode(attribute.rawValue, forKey: .attribute)
        }
        if let order = self.order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.IntentSortAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let orderDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SortOrder.self, forKey: .order)
        order = orderDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Specifies attributes for sorting a list of intents.
    public struct IntentSortBy: Swift.Equatable {
        /// The attribute to use to sort the list of intents.
        /// This member is required.
        public var attribute: LexModelsV2ClientTypes.IntentSortAttribute?
        /// The order to sort the list. You can choose ascending or descending.
        /// This member is required.
        public var order: LexModelsV2ClientTypes.SortOrder?

        public init(
            attribute: LexModelsV2ClientTypes.IntentSortAttribute? = nil,
            order: LexModelsV2ClientTypes.SortOrder? = nil
        )
        {
            self.attribute = attribute
            self.order = order
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum IntentState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case fulfilled
        case fulfillmentinprogress
        case inprogress
        case readyforfulfillment
        case waiting
        case sdkUnknown(Swift.String)

        public static var allCases: [IntentState] {
            return [
                .failed,
                .fulfilled,
                .fulfillmentinprogress,
                .inprogress,
                .readyforfulfillment,
                .waiting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .fulfilled: return "Fulfilled"
            case .fulfillmentinprogress: return "FulfillmentInProgress"
            case .inprogress: return "InProgress"
            case .readyforfulfillment: return "ReadyForFulfillment"
            case .waiting: return "Waiting"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IntentState(rawValue: rawValue) ?? IntentState.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.IntentStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case discoveredIntentCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let discoveredIntentCount = self.discoveredIntentCount {
            try encodeContainer.encode(discoveredIntentCount, forKey: .discoveredIntentCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let discoveredIntentCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .discoveredIntentCount)
        discoveredIntentCount = discoveredIntentCountDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// The object that contains the statistical summary of recommended intents associated with the bot recommendation.
    public struct IntentStatistics: Swift.Equatable {
        /// The number of recommended intents associated with the bot recommendation.
        public var discoveredIntentCount: Swift.Int?

        public init(
            discoveredIntentCount: Swift.Int? = nil
        )
        {
            self.discoveredIntentCount = discoveredIntentCount
        }
    }

}

extension LexModelsV2ClientTypes.IntentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case inputContexts
        case intentId
        case intentName
        case lastUpdatedDateTime
        case outputContexts
        case parentIntentSignature
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let inputContexts = inputContexts {
            var inputContextsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputContexts)
            for inputcontext0 in inputContexts {
                try inputContextsContainer.encode(inputcontext0)
            }
        }
        if let intentId = self.intentId {
            try encodeContainer.encode(intentId, forKey: .intentId)
        }
        if let intentName = self.intentName {
            try encodeContainer.encode(intentName, forKey: .intentName)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let outputContexts = outputContexts {
            var outputContextsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputContexts)
            for outputcontext0 in outputContexts {
                try outputContextsContainer.encode(outputcontext0)
            }
        }
        if let parentIntentSignature = self.parentIntentSignature {
            try encodeContainer.encode(parentIntentSignature, forKey: .parentIntentSignature)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intentId)
        intentId = intentIdDecoded
        let intentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intentName)
        intentName = intentNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parentIntentSignatureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentIntentSignature)
        parentIntentSignature = parentIntentSignatureDecoded
        let inputContextsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.InputContext?].self, forKey: .inputContexts)
        var inputContextsDecoded0:[LexModelsV2ClientTypes.InputContext]? = nil
        if let inputContextsContainer = inputContextsContainer {
            inputContextsDecoded0 = [LexModelsV2ClientTypes.InputContext]()
            for structure0 in inputContextsContainer {
                if let structure0 = structure0 {
                    inputContextsDecoded0?.append(structure0)
                }
            }
        }
        inputContexts = inputContextsDecoded0
        let outputContextsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.OutputContext?].self, forKey: .outputContexts)
        var outputContextsDecoded0:[LexModelsV2ClientTypes.OutputContext]? = nil
        if let outputContextsContainer = outputContextsContainer {
            outputContextsDecoded0 = [LexModelsV2ClientTypes.OutputContext]()
            for structure0 in outputContextsContainer {
                if let structure0 = structure0 {
                    outputContextsDecoded0?.append(structure0)
                }
            }
        }
        outputContexts = outputContextsDecoded0
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Summary information about an intent returned by the ListIntents operation.
    public struct IntentSummary: Swift.Equatable {
        /// The description of the intent.
        public var description: Swift.String?
        /// The input contexts that must be active for this intent to be considered for recognition.
        public var inputContexts: [LexModelsV2ClientTypes.InputContext]?
        /// The unique identifier assigned to the intent. Use this ID to get detailed information about the intent with the DescribeIntent operation.
        public var intentId: Swift.String?
        /// The name of the intent.
        public var intentName: Swift.String?
        /// The timestamp of the date and time that the intent was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The output contexts that are activated when this intent is fulfilled.
        public var outputContexts: [LexModelsV2ClientTypes.OutputContext]?
        /// If this intent is derived from a built-in intent, the name of the parent intent.
        public var parentIntentSignature: Swift.String?

        public init(
            description: Swift.String? = nil,
            inputContexts: [LexModelsV2ClientTypes.InputContext]? = nil,
            intentId: Swift.String? = nil,
            intentName: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            outputContexts: [LexModelsV2ClientTypes.OutputContext]? = nil,
            parentIntentSignature: Swift.String? = nil
        )
        {
            self.description = description
            self.inputContexts = inputContexts
            self.intentId = intentId
            self.intentName = intentName
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.outputContexts = outputContexts
            self.parentIntentSignature = parentIntentSignature
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service encountered an unexpected condition. Try your request again.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LexModelsV2ClientTypes.InvokedIntentSample: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case intentName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let intentName = self.intentName {
            try encodeContainer.encode(intentName, forKey: .intentName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intentName)
        intentName = intentNameDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// An object containing the name of an intent that was invoked.
    public struct InvokedIntentSample: Swift.Equatable {
        /// The name of an intent that was invoked.
        public var intentName: Swift.String?

        public init(
            intentName: Swift.String? = nil
        )
        {
            self.intentName = intentName
        }
    }

}

extension LexModelsV2ClientTypes.KendraConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kendraIndex
        case queryFilterString
        case queryFilterStringEnabled
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kendraIndex = self.kendraIndex {
            try encodeContainer.encode(kendraIndex, forKey: .kendraIndex)
        }
        if let queryFilterString = self.queryFilterString {
            try encodeContainer.encode(queryFilterString, forKey: .queryFilterString)
        }
        if queryFilterStringEnabled != false {
            try encodeContainer.encode(queryFilterStringEnabled, forKey: .queryFilterStringEnabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kendraIndexDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kendraIndex)
        kendraIndex = kendraIndexDecoded
        let queryFilterStringEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .queryFilterStringEnabled) ?? false
        queryFilterStringEnabled = queryFilterStringEnabledDecoded
        let queryFilterStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryFilterString)
        queryFilterString = queryFilterStringDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Provides configuration information for the AMAZON.KendraSearchIntent intent. When you use this intent, Amazon Lex searches the specified Amazon Kendra index and returns documents from the index that match the user's utterance.
    public struct KendraConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Amazon Kendra index that you want the AMAZON.KendraSearchIntent intent to search. The index must be in the same account and Region as the Amazon Lex bot.
        /// This member is required.
        public var kendraIndex: Swift.String?
        /// A query filter that Amazon Lex sends to Amazon Kendra to filter the response from a query. The filter is in the format defined by Amazon Kendra. For more information, see [Filtering queries](https://docs.aws.amazon.com/kendra/latest/dg/filtering.html).
        public var queryFilterString: Swift.String?
        /// Determines whether the AMAZON.KendraSearchIntent intent uses a custom query string to query the Amazon Kendra index.
        public var queryFilterStringEnabled: Swift.Bool

        public init(
            kendraIndex: Swift.String? = nil,
            queryFilterString: Swift.String? = nil,
            queryFilterStringEnabled: Swift.Bool = false
        )
        {
            self.kendraIndex = kendraIndex
            self.queryFilterString = queryFilterString
            self.queryFilterStringEnabled = queryFilterStringEnabled
        }
    }

}

extension LexModelsV2ClientTypes.LambdaCodeHook: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeHookInterfaceVersion
        case lambdaARN
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeHookInterfaceVersion = self.codeHookInterfaceVersion {
            try encodeContainer.encode(codeHookInterfaceVersion, forKey: .codeHookInterfaceVersion)
        }
        if let lambdaARN = self.lambdaARN {
            try encodeContainer.encode(lambdaARN, forKey: .lambdaARN)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lambdaARN)
        lambdaARN = lambdaARNDecoded
        let codeHookInterfaceVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeHookInterfaceVersion)
        codeHookInterfaceVersion = codeHookInterfaceVersionDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Specifies a Lambda function that verifies requests to a bot or fulfills the user's request to a bot.
    public struct LambdaCodeHook: Swift.Equatable {
        /// The version of the request-response that you want Amazon Lex to use to invoke your Lambda function.
        /// This member is required.
        public var codeHookInterfaceVersion: Swift.String?
        /// The Amazon Resource Name (ARN) of the Lambda function.
        /// This member is required.
        public var lambdaARN: Swift.String?

        public init(
            codeHookInterfaceVersion: Swift.String? = nil,
            lambdaARN: Swift.String? = nil
        )
        {
            self.codeHookInterfaceVersion = codeHookInterfaceVersion
            self.lambdaARN = lambdaARN
        }
    }

}

extension LexModelsV2ClientTypes.LexTranscriptFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateRangeFilter
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateRangeFilter = self.dateRangeFilter {
            try encodeContainer.encode(dateRangeFilter, forKey: .dateRangeFilter)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateRangeFilterDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.DateRangeFilter.self, forKey: .dateRangeFilter)
        dateRangeFilter = dateRangeFilterDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// The object that contains transcript filter details that are associated with a bot recommendation.
    public struct LexTranscriptFilter: Swift.Equatable {
        /// The object that contains a date range filter that will be applied to the transcript. Specify this object if you want Amazon Lex to only read the files that are within the date range.
        public var dateRangeFilter: LexModelsV2ClientTypes.DateRangeFilter?

        public init(
            dateRangeFilter: LexModelsV2ClientTypes.DateRangeFilter? = nil
        )
        {
            self.dateRangeFilter = dateRangeFilter
        }
    }

}

extension ListAggregatedUtterancesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationDuration
        case botAliasId
        case botVersion
        case filters
        case localeId
        case maxResults
        case nextToken
        case sortBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationDuration = self.aggregationDuration {
            try encodeContainer.encode(aggregationDuration, forKey: .aggregationDuration)
        }
        if let botAliasId = self.botAliasId {
            try encodeContainer.encode(botAliasId, forKey: .botAliasId)
        }
        if let botVersion = self.botVersion {
            try encodeContainer.encode(botVersion, forKey: .botVersion)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for aggregatedutterancesfilter0 in filters {
                try filtersContainer.encode(aggregatedutterancesfilter0)
            }
        }
        if let localeId = self.localeId {
            try encodeContainer.encode(localeId, forKey: .localeId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
    }
}

extension ListAggregatedUtterancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/aggregatedutterances"
    }
}

public struct ListAggregatedUtterancesInput: Swift.Equatable {
    /// The time window for aggregating the utterance information. You can specify a time between one hour and two weeks.
    /// This member is required.
    public var aggregationDuration: LexModelsV2ClientTypes.UtteranceAggregationDuration?
    /// The identifier of the bot alias associated with this request. If you specify the bot alias, you can't specify the bot version.
    public var botAliasId: Swift.String?
    /// The unique identifier of the bot associated with this request.
    /// This member is required.
    public var botId: Swift.String?
    /// The identifier of the bot version associated with this request. If you specify the bot version, you can't specify the bot alias.
    public var botVersion: Swift.String?
    /// Provides the specification of a filter used to limit the utterances in the response to only those that match the filter specification. You can only specify one filter and one string to filter on.
    public var filters: [LexModelsV2ClientTypes.AggregatedUtterancesFilter]?
    /// The identifier of the language and locale where the utterances were collected. For more information, see [Supported languages](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html).
    /// This member is required.
    public var localeId: Swift.String?
    /// The maximum number of utterances to return in each page of results. If there are fewer results than the maximum page size, only the actual number of results are returned. If you don't specify the maxResults parameter, 1,000 results are returned.
    public var maxResults: Swift.Int?
    /// If the response from the ListAggregatedUtterances operation contains more results that specified in the maxResults parameter, a token is returned in the response. Use that token in the nextToken parameter to return the next page of results.
    public var nextToken: Swift.String?
    /// Specifies sorting parameters for the list of utterances. You can sort by the hit count, the missed count, or the number of distinct sessions the utterance appeared in.
    public var sortBy: LexModelsV2ClientTypes.AggregatedUtterancesSortBy?

    public init(
        aggregationDuration: LexModelsV2ClientTypes.UtteranceAggregationDuration? = nil,
        botAliasId: Swift.String? = nil,
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        filters: [LexModelsV2ClientTypes.AggregatedUtterancesFilter]? = nil,
        localeId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: LexModelsV2ClientTypes.AggregatedUtterancesSortBy? = nil
    )
    {
        self.aggregationDuration = aggregationDuration
        self.botAliasId = botAliasId
        self.botId = botId
        self.botVersion = botVersion
        self.filters = filters
        self.localeId = localeId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
    }
}

struct ListAggregatedUtterancesInputBody: Swift.Equatable {
    let botAliasId: Swift.String?
    let botVersion: Swift.String?
    let localeId: Swift.String?
    let aggregationDuration: LexModelsV2ClientTypes.UtteranceAggregationDuration?
    let sortBy: LexModelsV2ClientTypes.AggregatedUtterancesSortBy?
    let filters: [LexModelsV2ClientTypes.AggregatedUtterancesFilter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListAggregatedUtterancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationDuration
        case botAliasId
        case botVersion
        case filters
        case localeId
        case maxResults
        case nextToken
        case sortBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botAliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botAliasId)
        botAliasId = botAliasIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let aggregationDurationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.UtteranceAggregationDuration.self, forKey: .aggregationDuration)
        aggregationDuration = aggregationDurationDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AggregatedUtterancesSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let filtersContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AggregatedUtterancesFilter?].self, forKey: .filters)
        var filtersDecoded0:[LexModelsV2ClientTypes.AggregatedUtterancesFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LexModelsV2ClientTypes.AggregatedUtterancesFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAggregatedUtterancesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAggregatedUtterancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAggregatedUtterancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aggregatedUtterancesSummaries = output.aggregatedUtterancesSummaries
            self.aggregationDuration = output.aggregationDuration
            self.aggregationLastRefreshedDateTime = output.aggregationLastRefreshedDateTime
            self.aggregationWindowEndTime = output.aggregationWindowEndTime
            self.aggregationWindowStartTime = output.aggregationWindowStartTime
            self.botAliasId = output.botAliasId
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.localeId = output.localeId
            self.nextToken = output.nextToken
        } else {
            self.aggregatedUtterancesSummaries = nil
            self.aggregationDuration = nil
            self.aggregationLastRefreshedDateTime = nil
            self.aggregationWindowEndTime = nil
            self.aggregationWindowStartTime = nil
            self.botAliasId = nil
            self.botId = nil
            self.botVersion = nil
            self.localeId = nil
            self.nextToken = nil
        }
    }
}

public struct ListAggregatedUtterancesOutputResponse: Swift.Equatable {
    /// Summaries of the aggregated utterance data. Each response contains information about the number of times that the utterance was seen during the time period, whether it was detected or missed, and when it was seen during the time period.
    public var aggregatedUtterancesSummaries: [LexModelsV2ClientTypes.AggregatedUtterancesSummary]?
    /// The time period used to aggregate the utterance data.
    public var aggregationDuration: LexModelsV2ClientTypes.UtteranceAggregationDuration?
    /// The last date and time that the aggregated data was collected. The time period depends on the length of the aggregation window.
    ///
    /// * Hours - for 1 hour time window, every half hour; otherwise every hour.
    ///
    /// * Days - every 6 hours
    ///
    /// * Weeks - for a one week time window, every 12 hours; otherwise, every day
    public var aggregationLastRefreshedDateTime: ClientRuntime.Date?
    /// The date and time that the aggregation window ends. Only data collected between the start time and the end time are returned in the results.
    public var aggregationWindowEndTime: ClientRuntime.Date?
    /// The date and time that the aggregation window begins. Only data collected after this time is returned in the results.
    public var aggregationWindowStartTime: ClientRuntime.Date?
    /// The identifier of the bot alias that contains the utterances. If you specified the bot version, the bot alias ID isn't returned.
    public var botAliasId: Swift.String?
    /// The identifier of the bot that contains the utterances.
    public var botId: Swift.String?
    /// The identifier of the bot version that contains the utterances. If you specified the bot alias, the bot version isn't returned.
    public var botVersion: Swift.String?
    /// The identifier of the language and locale that the utterances are in.
    public var localeId: Swift.String?
    /// A token that indicates whether there are more results to return in a response to the ListAggregatedUtterances operation. If the nextToken field is present, you send the contents as the nextToken parameter of a ListAggregatedUtterances operation request to get the next page of results.
    public var nextToken: Swift.String?

    public init(
        aggregatedUtterancesSummaries: [LexModelsV2ClientTypes.AggregatedUtterancesSummary]? = nil,
        aggregationDuration: LexModelsV2ClientTypes.UtteranceAggregationDuration? = nil,
        aggregationLastRefreshedDateTime: ClientRuntime.Date? = nil,
        aggregationWindowEndTime: ClientRuntime.Date? = nil,
        aggregationWindowStartTime: ClientRuntime.Date? = nil,
        botAliasId: Swift.String? = nil,
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        localeId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aggregatedUtterancesSummaries = aggregatedUtterancesSummaries
        self.aggregationDuration = aggregationDuration
        self.aggregationLastRefreshedDateTime = aggregationLastRefreshedDateTime
        self.aggregationWindowEndTime = aggregationWindowEndTime
        self.aggregationWindowStartTime = aggregationWindowStartTime
        self.botAliasId = botAliasId
        self.botId = botId
        self.botVersion = botVersion
        self.localeId = localeId
        self.nextToken = nextToken
    }
}

struct ListAggregatedUtterancesOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let botAliasId: Swift.String?
    let botVersion: Swift.String?
    let localeId: Swift.String?
    let aggregationDuration: LexModelsV2ClientTypes.UtteranceAggregationDuration?
    let aggregationWindowStartTime: ClientRuntime.Date?
    let aggregationWindowEndTime: ClientRuntime.Date?
    let aggregationLastRefreshedDateTime: ClientRuntime.Date?
    let aggregatedUtterancesSummaries: [LexModelsV2ClientTypes.AggregatedUtterancesSummary]?
    let nextToken: Swift.String?
}

extension ListAggregatedUtterancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregatedUtterancesSummaries
        case aggregationDuration
        case aggregationLastRefreshedDateTime
        case aggregationWindowEndTime
        case aggregationWindowStartTime
        case botAliasId
        case botId
        case botVersion
        case localeId
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botAliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botAliasId)
        botAliasId = botAliasIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let aggregationDurationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.UtteranceAggregationDuration.self, forKey: .aggregationDuration)
        aggregationDuration = aggregationDurationDecoded
        let aggregationWindowStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .aggregationWindowStartTime)
        aggregationWindowStartTime = aggregationWindowStartTimeDecoded
        let aggregationWindowEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .aggregationWindowEndTime)
        aggregationWindowEndTime = aggregationWindowEndTimeDecoded
        let aggregationLastRefreshedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .aggregationLastRefreshedDateTime)
        aggregationLastRefreshedDateTime = aggregationLastRefreshedDateTimeDecoded
        let aggregatedUtterancesSummariesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AggregatedUtterancesSummary?].self, forKey: .aggregatedUtterancesSummaries)
        var aggregatedUtterancesSummariesDecoded0:[LexModelsV2ClientTypes.AggregatedUtterancesSummary]? = nil
        if let aggregatedUtterancesSummariesContainer = aggregatedUtterancesSummariesContainer {
            aggregatedUtterancesSummariesDecoded0 = [LexModelsV2ClientTypes.AggregatedUtterancesSummary]()
            for structure0 in aggregatedUtterancesSummariesContainer {
                if let structure0 = structure0 {
                    aggregatedUtterancesSummariesDecoded0?.append(structure0)
                }
            }
        }
        aggregatedUtterancesSummaries = aggregatedUtterancesSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListBotAliasesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListBotAliasesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botaliases"
    }
}

public struct ListBotAliasesInput: Swift.Equatable {
    /// The identifier of the bot to list aliases for.
    /// This member is required.
    public var botId: Swift.String?
    /// The maximum number of aliases to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
    public var maxResults: Swift.Int?
    /// If the response from the ListBotAliases operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token in the nextToken parameter to return the next page of results.
    public var nextToken: Swift.String?

    public init(
        botId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.botId = botId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBotAliasesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListBotAliasesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListBotAliasesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListBotAliasesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListBotAliasesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botAliasSummaries = output.botAliasSummaries
            self.botId = output.botId
            self.nextToken = output.nextToken
        } else {
            self.botAliasSummaries = nil
            self.botId = nil
            self.nextToken = nil
        }
    }
}

public struct ListBotAliasesOutputResponse: Swift.Equatable {
    /// Summary information for the bot aliases that meet the filter criteria specified in the request. The length of the list is specified in the maxResults parameter of the request. If there are more aliases available, the nextToken field contains a token to get the next page of results.
    public var botAliasSummaries: [LexModelsV2ClientTypes.BotAliasSummary]?
    /// The identifier of the bot associated with the aliases.
    public var botId: Swift.String?
    /// A token that indicates whether there are more results to return in a response to the ListBotAliases operation. If the nextToken field is present, you send the contents as the nextToken parameter of a ListBotAliases operation request to get the next page of results.
    public var nextToken: Swift.String?

    public init(
        botAliasSummaries: [LexModelsV2ClientTypes.BotAliasSummary]? = nil,
        botId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.botAliasSummaries = botAliasSummaries
        self.botId = botId
        self.nextToken = nextToken
    }
}

struct ListBotAliasesOutputResponseBody: Swift.Equatable {
    let botAliasSummaries: [LexModelsV2ClientTypes.BotAliasSummary]?
    let nextToken: Swift.String?
    let botId: Swift.String?
}

extension ListBotAliasesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botAliasSummaries
        case botId
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botAliasSummariesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.BotAliasSummary?].self, forKey: .botAliasSummaries)
        var botAliasSummariesDecoded0:[LexModelsV2ClientTypes.BotAliasSummary]? = nil
        if let botAliasSummariesContainer = botAliasSummariesContainer {
            botAliasSummariesDecoded0 = [LexModelsV2ClientTypes.BotAliasSummary]()
            for structure0 in botAliasSummariesContainer {
                if let structure0 = structure0 {
                    botAliasSummariesDecoded0?.append(structure0)
                }
            }
        }
        botAliasSummaries = botAliasSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
    }
}

extension ListBotLocalesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case sortBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for botlocalefilter0 in filters {
                try filtersContainer.encode(botlocalefilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
    }
}

extension ListBotLocalesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botVersion = botVersion else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botversions/\(botVersion.urlPercentEncoding())/botlocales"
    }
}

public struct ListBotLocalesInput: Swift.Equatable {
    /// The identifier of the bot to list locales for.
    /// This member is required.
    public var botId: Swift.String?
    /// The version of the bot to list locales for.
    /// This member is required.
    public var botVersion: Swift.String?
    /// Provides the specification for a filter used to limit the response to only those locales that match the filter specification. You can only specify one filter and one value to filter on.
    public var filters: [LexModelsV2ClientTypes.BotLocaleFilter]?
    /// The maximum number of aliases to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
    public var maxResults: Swift.Int?
    /// If the response from the ListBotLocales operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token as the nextToken parameter to return the next page of results.
    public var nextToken: Swift.String?
    /// Specifies sorting parameters for the list of locales. You can sort by locale name in ascending or descending order.
    public var sortBy: LexModelsV2ClientTypes.BotLocaleSortBy?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        filters: [LexModelsV2ClientTypes.BotLocaleFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: LexModelsV2ClientTypes.BotLocaleSortBy? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
    }
}

struct ListBotLocalesInputBody: Swift.Equatable {
    let sortBy: LexModelsV2ClientTypes.BotLocaleSortBy?
    let filters: [LexModelsV2ClientTypes.BotLocaleFilter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListBotLocalesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case sortBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortByDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotLocaleSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let filtersContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.BotLocaleFilter?].self, forKey: .filters)
        var filtersDecoded0:[LexModelsV2ClientTypes.BotLocaleFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LexModelsV2ClientTypes.BotLocaleFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListBotLocalesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListBotLocalesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListBotLocalesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botLocaleSummaries = output.botLocaleSummaries
            self.botVersion = output.botVersion
            self.nextToken = output.nextToken
        } else {
            self.botId = nil
            self.botLocaleSummaries = nil
            self.botVersion = nil
            self.nextToken = nil
        }
    }
}

public struct ListBotLocalesOutputResponse: Swift.Equatable {
    /// The identifier of the bot to list locales for.
    public var botId: Swift.String?
    /// Summary information for the locales that meet the filter criteria specified in the request. The length of the list is specified in the maxResults parameter of the request. If there are more locales available, the nextToken field contains a token to get the next page of results.
    public var botLocaleSummaries: [LexModelsV2ClientTypes.BotLocaleSummary]?
    /// The version of the bot.
    public var botVersion: Swift.String?
    /// A token that indicates whether there are more results to return in a response to the ListBotLocales operation. If the nextToken field is present, you send the contents as the nextToken parameter of a ListBotLocales operation request to get the next page of results.
    public var nextToken: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botLocaleSummaries: [LexModelsV2ClientTypes.BotLocaleSummary]? = nil,
        botVersion: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botLocaleSummaries = botLocaleSummaries
        self.botVersion = botVersion
        self.nextToken = nextToken
    }
}

struct ListBotLocalesOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let botVersion: Swift.String?
    let nextToken: Swift.String?
    let botLocaleSummaries: [LexModelsV2ClientTypes.BotLocaleSummary]?
}

extension ListBotLocalesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botLocaleSummaries
        case botVersion
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let botLocaleSummariesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.BotLocaleSummary?].self, forKey: .botLocaleSummaries)
        var botLocaleSummariesDecoded0:[LexModelsV2ClientTypes.BotLocaleSummary]? = nil
        if let botLocaleSummariesContainer = botLocaleSummariesContainer {
            botLocaleSummariesDecoded0 = [LexModelsV2ClientTypes.BotLocaleSummary]()
            for structure0 in botLocaleSummariesContainer {
                if let structure0 = structure0 {
                    botLocaleSummariesDecoded0?.append(structure0)
                }
            }
        }
        botLocaleSummaries = botLocaleSummariesDecoded0
    }
}

extension ListBotRecommendationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListBotRecommendationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botVersion = botVersion else {
            return nil
        }
        guard let localeId = localeId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botversions/\(botVersion.urlPercentEncoding())/botlocales/\(localeId.urlPercentEncoding())/botrecommendations"
    }
}

public struct ListBotRecommendationsInput: Swift.Equatable {
    /// The unique identifier of the bot that contains the bot recommendation list.
    /// This member is required.
    public var botId: Swift.String?
    /// The version of the bot that contains the bot recommendation list.
    /// This member is required.
    public var botVersion: Swift.String?
    /// The identifier of the language and locale of the bot recommendation list.
    /// This member is required.
    public var localeId: Swift.String?
    /// The maximum number of bot recommendations to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
    public var maxResults: Swift.Int?
    /// If the response from the ListBotRecommendation operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token in the nextToken parameter to return the next page of results.
    public var nextToken: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        localeId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.localeId = localeId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBotRecommendationsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListBotRecommendationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListBotRecommendationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListBotRecommendationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListBotRecommendationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botRecommendationSummaries = output.botRecommendationSummaries
            self.botVersion = output.botVersion
            self.localeId = output.localeId
            self.nextToken = output.nextToken
        } else {
            self.botId = nil
            self.botRecommendationSummaries = nil
            self.botVersion = nil
            self.localeId = nil
            self.nextToken = nil
        }
    }
}

public struct ListBotRecommendationsOutputResponse: Swift.Equatable {
    /// The unique identifier of the bot that contains the bot recommendation list.
    public var botId: Swift.String?
    /// Summary information for the bot recommendations that meet the filter specified in this request. The length of the list is specified in the maxResults parameter of the request. If there are more bot recommendations available, the nextToken field contains a token to get the next page of results.
    public var botRecommendationSummaries: [LexModelsV2ClientTypes.BotRecommendationSummary]?
    /// The version of the bot that contains the bot recommendation list.
    public var botVersion: Swift.String?
    /// The identifier of the language and locale of the bot recommendation list.
    public var localeId: Swift.String?
    /// A token that indicates whether there are more results to return in a response to the ListBotRecommendations operation. If the nextToken field is present, you send the contents as the nextToken parameter of a ListBotRecommendations operation request to get the next page of results.
    public var nextToken: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botRecommendationSummaries: [LexModelsV2ClientTypes.BotRecommendationSummary]? = nil,
        botVersion: Swift.String? = nil,
        localeId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botRecommendationSummaries = botRecommendationSummaries
        self.botVersion = botVersion
        self.localeId = localeId
        self.nextToken = nextToken
    }
}

struct ListBotRecommendationsOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let botVersion: Swift.String?
    let localeId: Swift.String?
    let botRecommendationSummaries: [LexModelsV2ClientTypes.BotRecommendationSummary]?
    let nextToken: Swift.String?
}

extension ListBotRecommendationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botRecommendationSummaries
        case botVersion
        case localeId
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let botRecommendationSummariesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.BotRecommendationSummary?].self, forKey: .botRecommendationSummaries)
        var botRecommendationSummariesDecoded0:[LexModelsV2ClientTypes.BotRecommendationSummary]? = nil
        if let botRecommendationSummariesContainer = botRecommendationSummariesContainer {
            botRecommendationSummariesDecoded0 = [LexModelsV2ClientTypes.BotRecommendationSummary]()
            for structure0 in botRecommendationSummariesContainer {
                if let structure0 = structure0 {
                    botRecommendationSummariesDecoded0?.append(structure0)
                }
            }
        }
        botRecommendationSummaries = botRecommendationSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListBotVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case sortBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
    }
}

extension ListBotVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botversions"
    }
}

public struct ListBotVersionsInput: Swift.Equatable {
    /// The identifier of the bot to list versions for.
    /// This member is required.
    public var botId: Swift.String?
    /// The maximum number of versions to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
    public var maxResults: Swift.Int?
    /// If the response to the ListBotVersion operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token in the nextToken parameter to return the next page of results.
    public var nextToken: Swift.String?
    /// Specifies sorting parameters for the list of versions. You can specify that the list be sorted by version name in either ascending or descending order.
    public var sortBy: LexModelsV2ClientTypes.BotVersionSortBy?

    public init(
        botId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: LexModelsV2ClientTypes.BotVersionSortBy? = nil
    )
    {
        self.botId = botId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
    }
}

struct ListBotVersionsInputBody: Swift.Equatable {
    let sortBy: LexModelsV2ClientTypes.BotVersionSortBy?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListBotVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case sortBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortByDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotVersionSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListBotVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListBotVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListBotVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botVersionSummaries = output.botVersionSummaries
            self.nextToken = output.nextToken
        } else {
            self.botId = nil
            self.botVersionSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListBotVersionsOutputResponse: Swift.Equatable {
    /// The identifier of the bot to list versions for.
    public var botId: Swift.String?
    /// Summary information for the bot versions that meet the filter criteria specified in the request. The length of the list is specified in the maxResults parameter of the request. If there are more versions available, the nextToken field contains a token to get the next page of results.
    public var botVersionSummaries: [LexModelsV2ClientTypes.BotVersionSummary]?
    /// A token that indicates whether there are more results to return in a response to the ListBotVersions operation. If the nextToken field is present, you send the contents as the nextToken parameter of a ListBotAliases operation request to get the next page of results.
    public var nextToken: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botVersionSummaries: [LexModelsV2ClientTypes.BotVersionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botVersionSummaries = botVersionSummaries
        self.nextToken = nextToken
    }
}

struct ListBotVersionsOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let botVersionSummaries: [LexModelsV2ClientTypes.BotVersionSummary]?
    let nextToken: Swift.String?
}

extension ListBotVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botVersionSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionSummariesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.BotVersionSummary?].self, forKey: .botVersionSummaries)
        var botVersionSummariesDecoded0:[LexModelsV2ClientTypes.BotVersionSummary]? = nil
        if let botVersionSummariesContainer = botVersionSummariesContainer {
            botVersionSummariesDecoded0 = [LexModelsV2ClientTypes.BotVersionSummary]()
            for structure0 in botVersionSummariesContainer {
                if let structure0 = structure0 {
                    botVersionSummariesDecoded0?.append(structure0)
                }
            }
        }
        botVersionSummaries = botVersionSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListBotsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case sortBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for botfilter0 in filters {
                try filtersContainer.encode(botfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
    }
}

extension ListBotsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/bots"
    }
}

public struct ListBotsInput: Swift.Equatable {
    /// Provides the specification of a filter used to limit the bots in the response to only those that match the filter specification. You can only specify one filter and one string to filter on.
    public var filters: [LexModelsV2ClientTypes.BotFilter]?
    /// The maximum number of bots to return in each page of results. If there are fewer results than the maximum page size, only the actual number of results are returned.
    public var maxResults: Swift.Int?
    /// If the response from the ListBots operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use the returned token in the nextToken parameter of a ListBots request to return the next page of results. For a complete set of results, call the ListBots operation until the nextToken returned in the response is null.
    public var nextToken: Swift.String?
    /// Specifies sorting parameters for the list of bots. You can specify that the list be sorted by bot name in ascending or descending order.
    public var sortBy: LexModelsV2ClientTypes.BotSortBy?

    public init(
        filters: [LexModelsV2ClientTypes.BotFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: LexModelsV2ClientTypes.BotSortBy? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
    }
}

struct ListBotsInputBody: Swift.Equatable {
    let sortBy: LexModelsV2ClientTypes.BotSortBy?
    let filters: [LexModelsV2ClientTypes.BotFilter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListBotsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case sortBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortByDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let filtersContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.BotFilter?].self, forKey: .filters)
        var filtersDecoded0:[LexModelsV2ClientTypes.BotFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LexModelsV2ClientTypes.BotFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListBotsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListBotsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListBotsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botSummaries = output.botSummaries
            self.nextToken = output.nextToken
        } else {
            self.botSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListBotsOutputResponse: Swift.Equatable {
    /// Summary information for the bots that meet the filter criteria specified in the request. The length of the list is specified in the maxResults parameter of the request. If there are more bots available, the nextToken field contains a token to the next page of results.
    public var botSummaries: [LexModelsV2ClientTypes.BotSummary]?
    /// A token that indicates whether there are more results to return in a response to the ListBots operation. If the nextToken field is present, you send the contents as the nextToken parameter of a ListBots operation request to get the next page of results.
    public var nextToken: Swift.String?

    public init(
        botSummaries: [LexModelsV2ClientTypes.BotSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.botSummaries = botSummaries
        self.nextToken = nextToken
    }
}

struct ListBotsOutputResponseBody: Swift.Equatable {
    let botSummaries: [LexModelsV2ClientTypes.BotSummary]?
    let nextToken: Swift.String?
}

extension ListBotsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botSummariesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.BotSummary?].self, forKey: .botSummaries)
        var botSummariesDecoded0:[LexModelsV2ClientTypes.BotSummary]? = nil
        if let botSummariesContainer = botSummariesContainer {
            botSummariesDecoded0 = [LexModelsV2ClientTypes.BotSummary]()
            for structure0 in botSummariesContainer {
                if let structure0 = structure0 {
                    botSummariesDecoded0?.append(structure0)
                }
            }
        }
        botSummaries = botSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListBuiltInIntentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case sortBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
    }
}

extension ListBuiltInIntentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let localeId = localeId else {
            return nil
        }
        return "/builtins/locales/\(localeId.urlPercentEncoding())/intents"
    }
}

public struct ListBuiltInIntentsInput: Swift.Equatable {
    /// The identifier of the language and locale of the intents to list. The string must match one of the supported locales. For more information, see [Supported languages](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html).
    /// This member is required.
    public var localeId: Swift.String?
    /// The maximum number of built-in intents to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
    public var maxResults: Swift.Int?
    /// If the response from the ListBuiltInIntents operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token in the nextToken parameter to return the next page of results.
    public var nextToken: Swift.String?
    /// Specifies sorting parameters for the list of built-in intents. You can specify that the list be sorted by the built-in intent signature in either ascending or descending order.
    public var sortBy: LexModelsV2ClientTypes.BuiltInIntentSortBy?

    public init(
        localeId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: LexModelsV2ClientTypes.BuiltInIntentSortBy? = nil
    )
    {
        self.localeId = localeId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
    }
}

struct ListBuiltInIntentsInputBody: Swift.Equatable {
    let sortBy: LexModelsV2ClientTypes.BuiltInIntentSortBy?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListBuiltInIntentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case sortBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortByDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BuiltInIntentSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListBuiltInIntentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListBuiltInIntentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListBuiltInIntentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.builtInIntentSummaries = output.builtInIntentSummaries
            self.localeId = output.localeId
            self.nextToken = output.nextToken
        } else {
            self.builtInIntentSummaries = nil
            self.localeId = nil
            self.nextToken = nil
        }
    }
}

public struct ListBuiltInIntentsOutputResponse: Swift.Equatable {
    /// Summary information for the built-in intents that meet the filter criteria specified in the request. The length of the list is specified in the maxResults parameter of the request. If there are more intents available, the nextToken field contains a token to get the next page of results.
    public var builtInIntentSummaries: [LexModelsV2ClientTypes.BuiltInIntentSummary]?
    /// The language and locale of the intents in the list.
    public var localeId: Swift.String?
    /// A token that indicates whether there are more results to return in a response to the ListBuiltInIntents operation. If the nextToken field is present, you send the contents as the nextToken parameter of a ListBotAliases operation request to get the next page of results.
    public var nextToken: Swift.String?

    public init(
        builtInIntentSummaries: [LexModelsV2ClientTypes.BuiltInIntentSummary]? = nil,
        localeId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.builtInIntentSummaries = builtInIntentSummaries
        self.localeId = localeId
        self.nextToken = nextToken
    }
}

struct ListBuiltInIntentsOutputResponseBody: Swift.Equatable {
    let builtInIntentSummaries: [LexModelsV2ClientTypes.BuiltInIntentSummary]?
    let nextToken: Swift.String?
    let localeId: Swift.String?
}

extension ListBuiltInIntentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case builtInIntentSummaries
        case localeId
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let builtInIntentSummariesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.BuiltInIntentSummary?].self, forKey: .builtInIntentSummaries)
        var builtInIntentSummariesDecoded0:[LexModelsV2ClientTypes.BuiltInIntentSummary]? = nil
        if let builtInIntentSummariesContainer = builtInIntentSummariesContainer {
            builtInIntentSummariesDecoded0 = [LexModelsV2ClientTypes.BuiltInIntentSummary]()
            for structure0 in builtInIntentSummariesContainer {
                if let structure0 = structure0 {
                    builtInIntentSummariesDecoded0?.append(structure0)
                }
            }
        }
        builtInIntentSummaries = builtInIntentSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
    }
}

extension ListBuiltInSlotTypesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case sortBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
    }
}

extension ListBuiltInSlotTypesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let localeId = localeId else {
            return nil
        }
        return "/builtins/locales/\(localeId.urlPercentEncoding())/slottypes"
    }
}

public struct ListBuiltInSlotTypesInput: Swift.Equatable {
    /// The identifier of the language and locale of the slot types to list. The string must match one of the supported locales. For more information, see [Supported languages](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html).
    /// This member is required.
    public var localeId: Swift.String?
    /// The maximum number of built-in slot types to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
    public var maxResults: Swift.Int?
    /// If the response from the ListBuiltInSlotTypes operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token in the nextToken parameter to return the next page of results.
    public var nextToken: Swift.String?
    /// Determines the sort order for the response from the ListBuiltInSlotTypes operation. You can choose to sort by the slot type signature in either ascending or descending order.
    public var sortBy: LexModelsV2ClientTypes.BuiltInSlotTypeSortBy?

    public init(
        localeId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: LexModelsV2ClientTypes.BuiltInSlotTypeSortBy? = nil
    )
    {
        self.localeId = localeId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
    }
}

struct ListBuiltInSlotTypesInputBody: Swift.Equatable {
    let sortBy: LexModelsV2ClientTypes.BuiltInSlotTypeSortBy?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListBuiltInSlotTypesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case sortBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortByDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BuiltInSlotTypeSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListBuiltInSlotTypesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListBuiltInSlotTypesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListBuiltInSlotTypesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.builtInSlotTypeSummaries = output.builtInSlotTypeSummaries
            self.localeId = output.localeId
            self.nextToken = output.nextToken
        } else {
            self.builtInSlotTypeSummaries = nil
            self.localeId = nil
            self.nextToken = nil
        }
    }
}

public struct ListBuiltInSlotTypesOutputResponse: Swift.Equatable {
    /// Summary information for the built-in slot types that meet the filter criteria specified in the request. The length of the list is specified in the maxResults parameter of the request. If there are more slot types available, the nextToken field contains a token to get the next page of results.
    public var builtInSlotTypeSummaries: [LexModelsV2ClientTypes.BuiltInSlotTypeSummary]?
    /// The language and locale of the slot types in the list.
    public var localeId: Swift.String?
    /// A token that indicates whether there are more results to return in a response to the ListBuiltInSlotTypes operation. If the nextToken field is present, you send the contents as the nextToken parameter of a LIstBuiltInSlotTypes operation request to get the next page of results.
    public var nextToken: Swift.String?

    public init(
        builtInSlotTypeSummaries: [LexModelsV2ClientTypes.BuiltInSlotTypeSummary]? = nil,
        localeId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.builtInSlotTypeSummaries = builtInSlotTypeSummaries
        self.localeId = localeId
        self.nextToken = nextToken
    }
}

struct ListBuiltInSlotTypesOutputResponseBody: Swift.Equatable {
    let builtInSlotTypeSummaries: [LexModelsV2ClientTypes.BuiltInSlotTypeSummary]?
    let nextToken: Swift.String?
    let localeId: Swift.String?
}

extension ListBuiltInSlotTypesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case builtInSlotTypeSummaries
        case localeId
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let builtInSlotTypeSummariesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.BuiltInSlotTypeSummary?].self, forKey: .builtInSlotTypeSummaries)
        var builtInSlotTypeSummariesDecoded0:[LexModelsV2ClientTypes.BuiltInSlotTypeSummary]? = nil
        if let builtInSlotTypeSummariesContainer = builtInSlotTypeSummariesContainer {
            builtInSlotTypeSummariesDecoded0 = [LexModelsV2ClientTypes.BuiltInSlotTypeSummary]()
            for structure0 in builtInSlotTypeSummariesContainer {
                if let structure0 = structure0 {
                    builtInSlotTypeSummariesDecoded0?.append(structure0)
                }
            }
        }
        builtInSlotTypeSummaries = builtInSlotTypeSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
    }
}

extension ListCustomVocabularyItemsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListCustomVocabularyItemsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botVersion = botVersion else {
            return nil
        }
        guard let localeId = localeId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botversions/\(botVersion.urlPercentEncoding())/botlocales/\(localeId.urlPercentEncoding())/customvocabulary/DEFAULT/list"
    }
}

public struct ListCustomVocabularyItemsInput: Swift.Equatable {
    /// The identifier of the version of the bot associated with this custom vocabulary.
    /// This member is required.
    public var botId: Swift.String?
    /// The bot version of the bot to the list custom vocabulary request.
    /// This member is required.
    public var botVersion: Swift.String?
    /// The identifier of the language and locale where this custom vocabulary is used. The string must match one of the supported locales. For more information, see Supported languages (https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html).
    /// This member is required.
    public var localeId: Swift.String?
    /// The maximum number of items returned by the list operation.
    public var maxResults: Swift.Int?
    /// The nextToken identifier to the list custom vocabulary request.
    public var nextToken: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        localeId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.localeId = localeId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCustomVocabularyItemsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListCustomVocabularyItemsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListCustomVocabularyItemsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListCustomVocabularyItemsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCustomVocabularyItemsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.customVocabularyItems = output.customVocabularyItems
            self.localeId = output.localeId
            self.nextToken = output.nextToken
        } else {
            self.botId = nil
            self.botVersion = nil
            self.customVocabularyItems = nil
            self.localeId = nil
            self.nextToken = nil
        }
    }
}

public struct ListCustomVocabularyItemsOutputResponse: Swift.Equatable {
    /// The identifier of the bot associated with this custom vocabulary.
    public var botId: Swift.String?
    /// The identifier of the version of the bot associated with this custom vocabulary.
    public var botVersion: Swift.String?
    /// The custom vocabulary items from the list custom vocabulary response.
    public var customVocabularyItems: [LexModelsV2ClientTypes.CustomVocabularyItem]?
    /// The identifier of the language and locale where this custom vocabulary is used. The string must match one of the supported locales. For more information, see [ Supported Languages ](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html).
    public var localeId: Swift.String?
    /// The nextToken identifier to the list custom vocabulary response.
    public var nextToken: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        customVocabularyItems: [LexModelsV2ClientTypes.CustomVocabularyItem]? = nil,
        localeId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.customVocabularyItems = customVocabularyItems
        self.localeId = localeId
        self.nextToken = nextToken
    }
}

struct ListCustomVocabularyItemsOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let botVersion: Swift.String?
    let localeId: Swift.String?
    let customVocabularyItems: [LexModelsV2ClientTypes.CustomVocabularyItem]?
    let nextToken: Swift.String?
}

extension ListCustomVocabularyItemsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botVersion
        case customVocabularyItems
        case localeId
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let customVocabularyItemsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.CustomVocabularyItem?].self, forKey: .customVocabularyItems)
        var customVocabularyItemsDecoded0:[LexModelsV2ClientTypes.CustomVocabularyItem]? = nil
        if let customVocabularyItemsContainer = customVocabularyItemsContainer {
            customVocabularyItemsDecoded0 = [LexModelsV2ClientTypes.CustomVocabularyItem]()
            for structure0 in customVocabularyItemsContainer {
                if let structure0 = structure0 {
                    customVocabularyItemsDecoded0?.append(structure0)
                }
            }
        }
        customVocabularyItems = customVocabularyItemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListExportsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botVersion
        case filters
        case localeId
        case maxResults
        case nextToken
        case sortBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botId = self.botId {
            try encodeContainer.encode(botId, forKey: .botId)
        }
        if let botVersion = self.botVersion {
            try encodeContainer.encode(botVersion, forKey: .botVersion)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for exportfilter0 in filters {
                try filtersContainer.encode(exportfilter0)
            }
        }
        if let localeId = self.localeId {
            try encodeContainer.encode(localeId, forKey: .localeId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
    }
}

extension ListExportsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/exports"
    }
}

public struct ListExportsInput: Swift.Equatable {
    /// The unique identifier that Amazon Lex assigned to the bot.
    public var botId: Swift.String?
    /// The version of the bot to list exports for.
    public var botVersion: Swift.String?
    /// Provides the specification of a filter used to limit the exports in the response to only those that match the filter specification. You can only specify one filter and one string to filter on.
    public var filters: [LexModelsV2ClientTypes.ExportFilter]?
    /// Specifies the resources that should be exported. If you don't specify a resource type in the filters parameter, both bot locales and custom vocabularies are exported.
    public var localeId: Swift.String?
    /// The maximum number of exports to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
    public var maxResults: Swift.Int?
    /// If the response from the ListExports operation contains more results that specified in the maxResults parameter, a token is returned in the response. Use the returned token in the nextToken parameter of a ListExports request to return the next page of results. For a complete set of results, call the ListExports operation until the nextToken returned in the response is null.
    public var nextToken: Swift.String?
    /// Determines the field that the list of exports is sorted by. You can sort by the LastUpdatedDateTime field in ascending or descending order.
    public var sortBy: LexModelsV2ClientTypes.ExportSortBy?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        filters: [LexModelsV2ClientTypes.ExportFilter]? = nil,
        localeId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: LexModelsV2ClientTypes.ExportSortBy? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.filters = filters
        self.localeId = localeId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
    }
}

struct ListExportsInputBody: Swift.Equatable {
    let botId: Swift.String?
    let botVersion: Swift.String?
    let sortBy: LexModelsV2ClientTypes.ExportSortBy?
    let filters: [LexModelsV2ClientTypes.ExportFilter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let localeId: Swift.String?
}

extension ListExportsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botVersion
        case filters
        case localeId
        case maxResults
        case nextToken
        case sortBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ExportSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let filtersContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.ExportFilter?].self, forKey: .filters)
        var filtersDecoded0:[LexModelsV2ClientTypes.ExportFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LexModelsV2ClientTypes.ExportFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
    }
}

enum ListExportsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListExportsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListExportsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.exportSummaries = output.exportSummaries
            self.localeId = output.localeId
            self.nextToken = output.nextToken
        } else {
            self.botId = nil
            self.botVersion = nil
            self.exportSummaries = nil
            self.localeId = nil
            self.nextToken = nil
        }
    }
}

public struct ListExportsOutputResponse: Swift.Equatable {
    /// The unique identifier assigned to the bot by Amazon Lex.
    public var botId: Swift.String?
    /// The version of the bot that was exported.
    public var botVersion: Swift.String?
    /// Summary information for the exports that meet the filter criteria specified in the request. The length of the list is specified in the maxResults parameter. If there are more exports available, the nextToken field contains a token to get the next page of results.
    public var exportSummaries: [LexModelsV2ClientTypes.ExportSummary]?
    /// The locale specified in the request.
    public var localeId: Swift.String?
    /// A token that indicates whether there are more results to return in a response to the ListExports operation. If the nextToken field is present, you send the contents as the nextToken parameter of a ListExports operation request to get the next page of results.
    public var nextToken: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        exportSummaries: [LexModelsV2ClientTypes.ExportSummary]? = nil,
        localeId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.exportSummaries = exportSummaries
        self.localeId = localeId
        self.nextToken = nextToken
    }
}

struct ListExportsOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let botVersion: Swift.String?
    let exportSummaries: [LexModelsV2ClientTypes.ExportSummary]?
    let nextToken: Swift.String?
    let localeId: Swift.String?
}

extension ListExportsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botVersion
        case exportSummaries
        case localeId
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let exportSummariesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.ExportSummary?].self, forKey: .exportSummaries)
        var exportSummariesDecoded0:[LexModelsV2ClientTypes.ExportSummary]? = nil
        if let exportSummariesContainer = exportSummariesContainer {
            exportSummariesDecoded0 = [LexModelsV2ClientTypes.ExportSummary]()
            for structure0 in exportSummariesContainer {
                if let structure0 = structure0 {
                    exportSummariesDecoded0?.append(structure0)
                }
            }
        }
        exportSummaries = exportSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
    }
}

extension ListImportsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botVersion
        case filters
        case localeId
        case maxResults
        case nextToken
        case sortBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botId = self.botId {
            try encodeContainer.encode(botId, forKey: .botId)
        }
        if let botVersion = self.botVersion {
            try encodeContainer.encode(botVersion, forKey: .botVersion)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for importfilter0 in filters {
                try filtersContainer.encode(importfilter0)
            }
        }
        if let localeId = self.localeId {
            try encodeContainer.encode(localeId, forKey: .localeId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
    }
}

extension ListImportsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/imports"
    }
}

public struct ListImportsInput: Swift.Equatable {
    /// The unique identifier that Amazon Lex assigned to the bot.
    public var botId: Swift.String?
    /// The version of the bot to list imports for.
    public var botVersion: Swift.String?
    /// Provides the specification of a filter used to limit the bots in the response to only those that match the filter specification. You can only specify one filter and one string to filter on.
    public var filters: [LexModelsV2ClientTypes.ImportFilter]?
    /// Specifies the locale that should be present in the list. If you don't specify a resource type in the filters parameter, the list contains both bot locales and custom vocabularies.
    public var localeId: Swift.String?
    /// The maximum number of imports to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
    public var maxResults: Swift.Int?
    /// If the response from the ListImports operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use the returned token in the nextToken parameter of a ListImports request to return the next page of results. For a complete set of results, call the ListImports operation until the nextToken returned in the response is null.
    public var nextToken: Swift.String?
    /// Determines the field that the list of imports is sorted by. You can sort by the LastUpdatedDateTime field in ascending or descending order.
    public var sortBy: LexModelsV2ClientTypes.ImportSortBy?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        filters: [LexModelsV2ClientTypes.ImportFilter]? = nil,
        localeId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: LexModelsV2ClientTypes.ImportSortBy? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.filters = filters
        self.localeId = localeId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
    }
}

struct ListImportsInputBody: Swift.Equatable {
    let botId: Swift.String?
    let botVersion: Swift.String?
    let sortBy: LexModelsV2ClientTypes.ImportSortBy?
    let filters: [LexModelsV2ClientTypes.ImportFilter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let localeId: Swift.String?
}

extension ListImportsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botVersion
        case filters
        case localeId
        case maxResults
        case nextToken
        case sortBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ImportSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let filtersContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.ImportFilter?].self, forKey: .filters)
        var filtersDecoded0:[LexModelsV2ClientTypes.ImportFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LexModelsV2ClientTypes.ImportFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
    }
}

enum ListImportsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListImportsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListImportsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.importSummaries = output.importSummaries
            self.localeId = output.localeId
            self.nextToken = output.nextToken
        } else {
            self.botId = nil
            self.botVersion = nil
            self.importSummaries = nil
            self.localeId = nil
            self.nextToken = nil
        }
    }
}

public struct ListImportsOutputResponse: Swift.Equatable {
    /// The unique identifier assigned by Amazon Lex to the bot.
    public var botId: Swift.String?
    /// The version of the bot that was imported. It will always be DRAFT.
    public var botVersion: Swift.String?
    /// Summary information for the imports that meet the filter criteria specified in the request. The length of the list is specified in the maxResults parameter. If there are more imports available, the nextToken field contains a token to get the next page of results.
    public var importSummaries: [LexModelsV2ClientTypes.ImportSummary]?
    /// The locale specified in the request.
    public var localeId: Swift.String?
    /// A token that indicates whether there are more results to return in a response to the ListImports operation. If the nextToken field is present, you send the contents as the nextToken parameter of a ListImports operation request to get the next page of results.
    public var nextToken: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        importSummaries: [LexModelsV2ClientTypes.ImportSummary]? = nil,
        localeId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.importSummaries = importSummaries
        self.localeId = localeId
        self.nextToken = nextToken
    }
}

struct ListImportsOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let botVersion: Swift.String?
    let importSummaries: [LexModelsV2ClientTypes.ImportSummary]?
    let nextToken: Swift.String?
    let localeId: Swift.String?
}

extension ListImportsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botVersion
        case importSummaries
        case localeId
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let importSummariesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.ImportSummary?].self, forKey: .importSummaries)
        var importSummariesDecoded0:[LexModelsV2ClientTypes.ImportSummary]? = nil
        if let importSummariesContainer = importSummariesContainer {
            importSummariesDecoded0 = [LexModelsV2ClientTypes.ImportSummary]()
            for structure0 in importSummariesContainer {
                if let structure0 = structure0 {
                    importSummariesDecoded0?.append(structure0)
                }
            }
        }
        importSummaries = importSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
    }
}

extension ListIntentMetricsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case binBy
        case endDateTime
        case filters
        case groupBy
        case maxResults
        case metrics
        case nextToken
        case startDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let binBy = binBy {
            var binByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .binBy)
            for analyticsbinbyspecification0 in binBy {
                try binByContainer.encode(analyticsbinbyspecification0)
            }
        }
        if let endDateTime = self.endDateTime {
            try encodeContainer.encodeTimestamp(endDateTime, format: .epochSeconds, forKey: .endDateTime)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for analyticsintentfilter0 in filters {
                try filtersContainer.encode(analyticsintentfilter0)
            }
        }
        if let groupBy = groupBy {
            var groupByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupBy)
            for analyticsintentgroupbyspecification0 in groupBy {
                try groupByContainer.encode(analyticsintentgroupbyspecification0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let metrics = metrics {
            var metricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metrics)
            for analyticsintentmetric0 in metrics {
                try metricsContainer.encode(analyticsintentmetric0)
            }
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startDateTime = self.startDateTime {
            try encodeContainer.encodeTimestamp(startDateTime, format: .epochSeconds, forKey: .startDateTime)
        }
    }
}

extension ListIntentMetricsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/analytics/intentmetrics"
    }
}

public struct ListIntentMetricsInput: Swift.Equatable {
    /// A list of objects, each of which contains specifications for organizing the results by time.
    public var binBy: [LexModelsV2ClientTypes.AnalyticsBinBySpecification]?
    /// The identifier for the bot for which you want to retrieve intent metrics.
    /// This member is required.
    public var botId: Swift.String?
    /// The date and time that marks the end of the range of time for which you want to see intent metrics.
    /// This member is required.
    public var endDateTime: ClientRuntime.Date?
    /// A list of objects, each of which describes a condition by which you want to filter the results.
    public var filters: [LexModelsV2ClientTypes.AnalyticsIntentFilter]?
    /// A list of objects, each of which specifies how to group the results. You can group by the following criteria:
    ///
    /// * IntentName – The name of the intent.
    ///
    /// * IntentEndState – The final state of the intent. The possible end states are detailed in [Key definitions](https://docs.aws.amazon.com/analytics-key-definitions-intents) in the user guide.
    public var groupBy: [LexModelsV2ClientTypes.AnalyticsIntentGroupBySpecification]?
    /// The maximum number of results to return in each page of results. If there are fewer results than the maximum page size, only the actual number of results are returned.
    public var maxResults: Swift.Int?
    /// A list of objects, each of which contains a metric you want to list, the statistic for the metric you want to return, and the order by which to organize the results.
    /// This member is required.
    public var metrics: [LexModelsV2ClientTypes.AnalyticsIntentMetric]?
    /// If the response from the ListIntentMetrics operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use the returned token in the nextToken parameter of a ListIntentMetrics request to return the next page of results. For a complete set of results, call the ListIntentMetrics operation until the nextToken returned in the response is null.
    public var nextToken: Swift.String?
    /// The timestamp that marks the beginning of the range of time for which you want to see intent metrics.
    /// This member is required.
    public var startDateTime: ClientRuntime.Date?

    public init(
        binBy: [LexModelsV2ClientTypes.AnalyticsBinBySpecification]? = nil,
        botId: Swift.String? = nil,
        endDateTime: ClientRuntime.Date? = nil,
        filters: [LexModelsV2ClientTypes.AnalyticsIntentFilter]? = nil,
        groupBy: [LexModelsV2ClientTypes.AnalyticsIntentGroupBySpecification]? = nil,
        maxResults: Swift.Int? = nil,
        metrics: [LexModelsV2ClientTypes.AnalyticsIntentMetric]? = nil,
        nextToken: Swift.String? = nil,
        startDateTime: ClientRuntime.Date? = nil
    )
    {
        self.binBy = binBy
        self.botId = botId
        self.endDateTime = endDateTime
        self.filters = filters
        self.groupBy = groupBy
        self.maxResults = maxResults
        self.metrics = metrics
        self.nextToken = nextToken
        self.startDateTime = startDateTime
    }
}

struct ListIntentMetricsInputBody: Swift.Equatable {
    let startDateTime: ClientRuntime.Date?
    let endDateTime: ClientRuntime.Date?
    let metrics: [LexModelsV2ClientTypes.AnalyticsIntentMetric]?
    let binBy: [LexModelsV2ClientTypes.AnalyticsBinBySpecification]?
    let groupBy: [LexModelsV2ClientTypes.AnalyticsIntentGroupBySpecification]?
    let filters: [LexModelsV2ClientTypes.AnalyticsIntentFilter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListIntentMetricsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case binBy
        case endDateTime
        case filters
        case groupBy
        case maxResults
        case metrics
        case nextToken
        case startDateTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startDateTime)
        startDateTime = startDateTimeDecoded
        let endDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endDateTime)
        endDateTime = endDateTimeDecoded
        let metricsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AnalyticsIntentMetric?].self, forKey: .metrics)
        var metricsDecoded0:[LexModelsV2ClientTypes.AnalyticsIntentMetric]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [LexModelsV2ClientTypes.AnalyticsIntentMetric]()
            for structure0 in metricsContainer {
                if let structure0 = structure0 {
                    metricsDecoded0?.append(structure0)
                }
            }
        }
        metrics = metricsDecoded0
        let binByContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AnalyticsBinBySpecification?].self, forKey: .binBy)
        var binByDecoded0:[LexModelsV2ClientTypes.AnalyticsBinBySpecification]? = nil
        if let binByContainer = binByContainer {
            binByDecoded0 = [LexModelsV2ClientTypes.AnalyticsBinBySpecification]()
            for structure0 in binByContainer {
                if let structure0 = structure0 {
                    binByDecoded0?.append(structure0)
                }
            }
        }
        binBy = binByDecoded0
        let groupByContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AnalyticsIntentGroupBySpecification?].self, forKey: .groupBy)
        var groupByDecoded0:[LexModelsV2ClientTypes.AnalyticsIntentGroupBySpecification]? = nil
        if let groupByContainer = groupByContainer {
            groupByDecoded0 = [LexModelsV2ClientTypes.AnalyticsIntentGroupBySpecification]()
            for structure0 in groupByContainer {
                if let structure0 = structure0 {
                    groupByDecoded0?.append(structure0)
                }
            }
        }
        groupBy = groupByDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AnalyticsIntentFilter?].self, forKey: .filters)
        var filtersDecoded0:[LexModelsV2ClientTypes.AnalyticsIntentFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LexModelsV2ClientTypes.AnalyticsIntentFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListIntentMetricsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListIntentMetricsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListIntentMetricsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.nextToken = output.nextToken
            self.results = output.results
        } else {
            self.botId = nil
            self.nextToken = nil
            self.results = nil
        }
    }
}

public struct ListIntentMetricsOutputResponse: Swift.Equatable {
    /// The identifier for the bot for which you retrieved intent metrics.
    public var botId: Swift.String?
    /// If the response from the ListIntentMetrics operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use the returned token in the nextToken parameter of a ListIntentMetrics request to return the next page of results. For a complete set of results, call the ListIntentMetrics operation until the nextToken returned in the response is null.
    public var nextToken: Swift.String?
    /// The results for the intent metrics.
    public var results: [LexModelsV2ClientTypes.AnalyticsIntentResult]?

    public init(
        botId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        results: [LexModelsV2ClientTypes.AnalyticsIntentResult]? = nil
    )
    {
        self.botId = botId
        self.nextToken = nextToken
        self.results = results
    }
}

struct ListIntentMetricsOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let results: [LexModelsV2ClientTypes.AnalyticsIntentResult]?
    let nextToken: Swift.String?
}

extension ListIntentMetricsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case nextToken
        case results
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let resultsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AnalyticsIntentResult?].self, forKey: .results)
        var resultsDecoded0:[LexModelsV2ClientTypes.AnalyticsIntentResult]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [LexModelsV2ClientTypes.AnalyticsIntentResult]()
            for structure0 in resultsContainer {
                if let structure0 = structure0 {
                    resultsDecoded0?.append(structure0)
                }
            }
        }
        results = resultsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListIntentPathsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endDateTime
        case filters
        case intentPath
        case startDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endDateTime = self.endDateTime {
            try encodeContainer.encodeTimestamp(endDateTime, format: .epochSeconds, forKey: .endDateTime)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for analyticspathfilter0 in filters {
                try filtersContainer.encode(analyticspathfilter0)
            }
        }
        if let intentPath = self.intentPath {
            try encodeContainer.encode(intentPath, forKey: .intentPath)
        }
        if let startDateTime = self.startDateTime {
            try encodeContainer.encodeTimestamp(startDateTime, format: .epochSeconds, forKey: .startDateTime)
        }
    }
}

extension ListIntentPathsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/analytics/intentpaths"
    }
}

public struct ListIntentPathsInput: Swift.Equatable {
    /// The identifier for the bot for which you want to retrieve intent path metrics.
    /// This member is required.
    public var botId: Swift.String?
    /// The date and time that marks the end of the range of time for which you want to see intent path metrics.
    /// This member is required.
    public var endDateTime: ClientRuntime.Date?
    /// A list of objects, each describes a condition by which you want to filter the results.
    public var filters: [LexModelsV2ClientTypes.AnalyticsPathFilter]?
    /// The intent path for which you want to retrieve metrics. Use a forward slash to separate intents in the path. For example:
    ///
    /// * /BookCar
    ///
    /// * /BookCar/BookHotel
    ///
    /// * /BookHotel/BookCar
    /// This member is required.
    public var intentPath: Swift.String?
    /// The date and time that marks the beginning of the range of time for which you want to see intent path metrics.
    /// This member is required.
    public var startDateTime: ClientRuntime.Date?

    public init(
        botId: Swift.String? = nil,
        endDateTime: ClientRuntime.Date? = nil,
        filters: [LexModelsV2ClientTypes.AnalyticsPathFilter]? = nil,
        intentPath: Swift.String? = nil,
        startDateTime: ClientRuntime.Date? = nil
    )
    {
        self.botId = botId
        self.endDateTime = endDateTime
        self.filters = filters
        self.intentPath = intentPath
        self.startDateTime = startDateTime
    }
}

struct ListIntentPathsInputBody: Swift.Equatable {
    let startDateTime: ClientRuntime.Date?
    let endDateTime: ClientRuntime.Date?
    let intentPath: Swift.String?
    let filters: [LexModelsV2ClientTypes.AnalyticsPathFilter]?
}

extension ListIntentPathsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endDateTime
        case filters
        case intentPath
        case startDateTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startDateTime)
        startDateTime = startDateTimeDecoded
        let endDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endDateTime)
        endDateTime = endDateTimeDecoded
        let intentPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intentPath)
        intentPath = intentPathDecoded
        let filtersContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AnalyticsPathFilter?].self, forKey: .filters)
        var filtersDecoded0:[LexModelsV2ClientTypes.AnalyticsPathFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LexModelsV2ClientTypes.AnalyticsPathFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

enum ListIntentPathsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListIntentPathsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListIntentPathsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nodeSummaries = output.nodeSummaries
        } else {
            self.nodeSummaries = nil
        }
    }
}

public struct ListIntentPathsOutputResponse: Swift.Equatable {
    /// A list of objects, each of which contains information about a node in the intent path for which you requested metrics.
    public var nodeSummaries: [LexModelsV2ClientTypes.AnalyticsIntentNodeSummary]?

    public init(
        nodeSummaries: [LexModelsV2ClientTypes.AnalyticsIntentNodeSummary]? = nil
    )
    {
        self.nodeSummaries = nodeSummaries
    }
}

struct ListIntentPathsOutputResponseBody: Swift.Equatable {
    let nodeSummaries: [LexModelsV2ClientTypes.AnalyticsIntentNodeSummary]?
}

extension ListIntentPathsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nodeSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeSummariesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AnalyticsIntentNodeSummary?].self, forKey: .nodeSummaries)
        var nodeSummariesDecoded0:[LexModelsV2ClientTypes.AnalyticsIntentNodeSummary]? = nil
        if let nodeSummariesContainer = nodeSummariesContainer {
            nodeSummariesDecoded0 = [LexModelsV2ClientTypes.AnalyticsIntentNodeSummary]()
            for structure0 in nodeSummariesContainer {
                if let structure0 = structure0 {
                    nodeSummariesDecoded0?.append(structure0)
                }
            }
        }
        nodeSummaries = nodeSummariesDecoded0
    }
}

extension ListIntentStageMetricsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case binBy
        case endDateTime
        case filters
        case groupBy
        case maxResults
        case metrics
        case nextToken
        case startDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let binBy = binBy {
            var binByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .binBy)
            for analyticsbinbyspecification0 in binBy {
                try binByContainer.encode(analyticsbinbyspecification0)
            }
        }
        if let endDateTime = self.endDateTime {
            try encodeContainer.encodeTimestamp(endDateTime, format: .epochSeconds, forKey: .endDateTime)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for analyticsintentstagefilter0 in filters {
                try filtersContainer.encode(analyticsintentstagefilter0)
            }
        }
        if let groupBy = groupBy {
            var groupByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupBy)
            for analyticsintentstagegroupbyspecification0 in groupBy {
                try groupByContainer.encode(analyticsintentstagegroupbyspecification0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let metrics = metrics {
            var metricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metrics)
            for analyticsintentstagemetric0 in metrics {
                try metricsContainer.encode(analyticsintentstagemetric0)
            }
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startDateTime = self.startDateTime {
            try encodeContainer.encodeTimestamp(startDateTime, format: .epochSeconds, forKey: .startDateTime)
        }
    }
}

extension ListIntentStageMetricsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/analytics/intentstagemetrics"
    }
}

public struct ListIntentStageMetricsInput: Swift.Equatable {
    /// A list of objects, each of which contains specifications for organizing the results by time.
    public var binBy: [LexModelsV2ClientTypes.AnalyticsBinBySpecification]?
    /// The identifier for the bot for which you want to retrieve intent stage metrics.
    /// This member is required.
    public var botId: Swift.String?
    /// The date and time that marks the end of the range of time for which you want to see intent stage metrics.
    /// This member is required.
    public var endDateTime: ClientRuntime.Date?
    /// A list of objects, each of which describes a condition by which you want to filter the results.
    public var filters: [LexModelsV2ClientTypes.AnalyticsIntentStageFilter]?
    /// A list of objects, each of which specifies how to group the results. You can group by the following criteria:
    ///
    /// * IntentStageName – The name of the intent stage.
    ///
    /// * SwitchedToIntent – The intent to which the conversation was switched (if any).
    public var groupBy: [LexModelsV2ClientTypes.AnalyticsIntentStageGroupBySpecification]?
    /// The maximum number of results to return in each page of results. If there are fewer results than the maximum page size, only the actual number of results are returned.
    public var maxResults: Swift.Int?
    /// A list of objects, each of which contains a metric you want to list, the statistic for the metric you want to return, and the method by which to organize the results.
    /// This member is required.
    public var metrics: [LexModelsV2ClientTypes.AnalyticsIntentStageMetric]?
    /// If the response from the ListIntentStageMetrics operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use the returned token in the nextToken parameter of a ListIntentStageMetrics request to return the next page of results. For a complete set of results, call the ListIntentStageMetrics operation until the nextToken returned in the response is null.
    public var nextToken: Swift.String?
    /// The date and time that marks the beginning of the range of time for which you want to see intent stage metrics.
    /// This member is required.
    public var startDateTime: ClientRuntime.Date?

    public init(
        binBy: [LexModelsV2ClientTypes.AnalyticsBinBySpecification]? = nil,
        botId: Swift.String? = nil,
        endDateTime: ClientRuntime.Date? = nil,
        filters: [LexModelsV2ClientTypes.AnalyticsIntentStageFilter]? = nil,
        groupBy: [LexModelsV2ClientTypes.AnalyticsIntentStageGroupBySpecification]? = nil,
        maxResults: Swift.Int? = nil,
        metrics: [LexModelsV2ClientTypes.AnalyticsIntentStageMetric]? = nil,
        nextToken: Swift.String? = nil,
        startDateTime: ClientRuntime.Date? = nil
    )
    {
        self.binBy = binBy
        self.botId = botId
        self.endDateTime = endDateTime
        self.filters = filters
        self.groupBy = groupBy
        self.maxResults = maxResults
        self.metrics = metrics
        self.nextToken = nextToken
        self.startDateTime = startDateTime
    }
}

struct ListIntentStageMetricsInputBody: Swift.Equatable {
    let startDateTime: ClientRuntime.Date?
    let endDateTime: ClientRuntime.Date?
    let metrics: [LexModelsV2ClientTypes.AnalyticsIntentStageMetric]?
    let binBy: [LexModelsV2ClientTypes.AnalyticsBinBySpecification]?
    let groupBy: [LexModelsV2ClientTypes.AnalyticsIntentStageGroupBySpecification]?
    let filters: [LexModelsV2ClientTypes.AnalyticsIntentStageFilter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListIntentStageMetricsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case binBy
        case endDateTime
        case filters
        case groupBy
        case maxResults
        case metrics
        case nextToken
        case startDateTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startDateTime)
        startDateTime = startDateTimeDecoded
        let endDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endDateTime)
        endDateTime = endDateTimeDecoded
        let metricsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AnalyticsIntentStageMetric?].self, forKey: .metrics)
        var metricsDecoded0:[LexModelsV2ClientTypes.AnalyticsIntentStageMetric]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [LexModelsV2ClientTypes.AnalyticsIntentStageMetric]()
            for structure0 in metricsContainer {
                if let structure0 = structure0 {
                    metricsDecoded0?.append(structure0)
                }
            }
        }
        metrics = metricsDecoded0
        let binByContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AnalyticsBinBySpecification?].self, forKey: .binBy)
        var binByDecoded0:[LexModelsV2ClientTypes.AnalyticsBinBySpecification]? = nil
        if let binByContainer = binByContainer {
            binByDecoded0 = [LexModelsV2ClientTypes.AnalyticsBinBySpecification]()
            for structure0 in binByContainer {
                if let structure0 = structure0 {
                    binByDecoded0?.append(structure0)
                }
            }
        }
        binBy = binByDecoded0
        let groupByContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AnalyticsIntentStageGroupBySpecification?].self, forKey: .groupBy)
        var groupByDecoded0:[LexModelsV2ClientTypes.AnalyticsIntentStageGroupBySpecification]? = nil
        if let groupByContainer = groupByContainer {
            groupByDecoded0 = [LexModelsV2ClientTypes.AnalyticsIntentStageGroupBySpecification]()
            for structure0 in groupByContainer {
                if let structure0 = structure0 {
                    groupByDecoded0?.append(structure0)
                }
            }
        }
        groupBy = groupByDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AnalyticsIntentStageFilter?].self, forKey: .filters)
        var filtersDecoded0:[LexModelsV2ClientTypes.AnalyticsIntentStageFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LexModelsV2ClientTypes.AnalyticsIntentStageFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListIntentStageMetricsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListIntentStageMetricsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListIntentStageMetricsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.nextToken = output.nextToken
            self.results = output.results
        } else {
            self.botId = nil
            self.nextToken = nil
            self.results = nil
        }
    }
}

public struct ListIntentStageMetricsOutputResponse: Swift.Equatable {
    /// The identifier for the bot for which you retrieved intent stage metrics.
    public var botId: Swift.String?
    /// If the response from the ListIntentStageMetrics operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use the returned token in the nextToken parameter of a ListIntentStageMetrics request to return the next page of results. For a complete set of results, call the ListIntentStageMetrics operation until the nextToken returned in the response is null.
    public var nextToken: Swift.String?
    /// The results for the intent stage metrics.
    public var results: [LexModelsV2ClientTypes.AnalyticsIntentStageResult]?

    public init(
        botId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        results: [LexModelsV2ClientTypes.AnalyticsIntentStageResult]? = nil
    )
    {
        self.botId = botId
        self.nextToken = nextToken
        self.results = results
    }
}

struct ListIntentStageMetricsOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let results: [LexModelsV2ClientTypes.AnalyticsIntentStageResult]?
    let nextToken: Swift.String?
}

extension ListIntentStageMetricsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case nextToken
        case results
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let resultsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AnalyticsIntentStageResult?].self, forKey: .results)
        var resultsDecoded0:[LexModelsV2ClientTypes.AnalyticsIntentStageResult]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [LexModelsV2ClientTypes.AnalyticsIntentStageResult]()
            for structure0 in resultsContainer {
                if let structure0 = structure0 {
                    resultsDecoded0?.append(structure0)
                }
            }
        }
        results = resultsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListIntentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case sortBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for intentfilter0 in filters {
                try filtersContainer.encode(intentfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
    }
}

extension ListIntentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botVersion = botVersion else {
            return nil
        }
        guard let localeId = localeId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botversions/\(botVersion.urlPercentEncoding())/botlocales/\(localeId.urlPercentEncoding())/intents"
    }
}

public struct ListIntentsInput: Swift.Equatable {
    /// The unique identifier of the bot that contains the intent.
    /// This member is required.
    public var botId: Swift.String?
    /// The version of the bot that contains the intent.
    /// This member is required.
    public var botVersion: Swift.String?
    /// Provides the specification of a filter used to limit the intents in the response to only those that match the filter specification. You can only specify one filter and only one string to filter on.
    public var filters: [LexModelsV2ClientTypes.IntentFilter]?
    /// The identifier of the language and locale of the intents to list. The string must match one of the supported locales. For more information, see [Supported languages](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html).
    /// This member is required.
    public var localeId: Swift.String?
    /// The maximum number of intents to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
    public var maxResults: Swift.Int?
    /// If the response from the ListIntents operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use the returned token in the nextToken parameter of a ListIntents request to return the next page of results. For a complete set of results, call the ListIntents operation until the nextToken returned in the response is null.
    public var nextToken: Swift.String?
    /// Determines the sort order for the response from the ListIntents operation. You can choose to sort by the intent name or last updated date in either ascending or descending order.
    public var sortBy: LexModelsV2ClientTypes.IntentSortBy?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        filters: [LexModelsV2ClientTypes.IntentFilter]? = nil,
        localeId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: LexModelsV2ClientTypes.IntentSortBy? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.filters = filters
        self.localeId = localeId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
    }
}

struct ListIntentsInputBody: Swift.Equatable {
    let sortBy: LexModelsV2ClientTypes.IntentSortBy?
    let filters: [LexModelsV2ClientTypes.IntentFilter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListIntentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case sortBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortByDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.IntentSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let filtersContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.IntentFilter?].self, forKey: .filters)
        var filtersDecoded0:[LexModelsV2ClientTypes.IntentFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LexModelsV2ClientTypes.IntentFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListIntentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListIntentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListIntentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.intentSummaries = output.intentSummaries
            self.localeId = output.localeId
            self.nextToken = output.nextToken
        } else {
            self.botId = nil
            self.botVersion = nil
            self.intentSummaries = nil
            self.localeId = nil
            self.nextToken = nil
        }
    }
}

public struct ListIntentsOutputResponse: Swift.Equatable {
    /// The identifier of the bot that contains the intent.
    public var botId: Swift.String?
    /// The version of the bot that contains the intent.
    public var botVersion: Swift.String?
    /// Summary information for the intents that meet the filter criteria specified in the request. The length of the list is specified in the maxResults parameter of the request. If there are more intents available, the nextToken field contains a token to get the next page of results.
    public var intentSummaries: [LexModelsV2ClientTypes.IntentSummary]?
    /// The language and locale of the intents in the list.
    public var localeId: Swift.String?
    /// A token that indicates whether there are more results to return in a response to the ListIntents operation. If the nextToken field is present, you send the contents as the nextToken parameter of a ListIntents operation request to get the next page of results.
    public var nextToken: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        intentSummaries: [LexModelsV2ClientTypes.IntentSummary]? = nil,
        localeId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.intentSummaries = intentSummaries
        self.localeId = localeId
        self.nextToken = nextToken
    }
}

struct ListIntentsOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let botVersion: Swift.String?
    let localeId: Swift.String?
    let intentSummaries: [LexModelsV2ClientTypes.IntentSummary]?
    let nextToken: Swift.String?
}

extension ListIntentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botVersion
        case intentSummaries
        case localeId
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let intentSummariesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.IntentSummary?].self, forKey: .intentSummaries)
        var intentSummariesDecoded0:[LexModelsV2ClientTypes.IntentSummary]? = nil
        if let intentSummariesContainer = intentSummariesContainer {
            intentSummariesDecoded0 = [LexModelsV2ClientTypes.IntentSummary]()
            for structure0 in intentSummariesContainer {
                if let structure0 = structure0 {
                    intentSummariesDecoded0?.append(structure0)
                }
            }
        }
        intentSummaries = intentSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRecommendedIntentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListRecommendedIntentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botVersion = botVersion else {
            return nil
        }
        guard let localeId = localeId else {
            return nil
        }
        guard let botRecommendationId = botRecommendationId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botversions/\(botVersion.urlPercentEncoding())/botlocales/\(localeId.urlPercentEncoding())/botrecommendations/\(botRecommendationId.urlPercentEncoding())/intents"
    }
}

public struct ListRecommendedIntentsInput: Swift.Equatable {
    /// The unique identifier of the bot associated with the recommended intents.
    /// This member is required.
    public var botId: Swift.String?
    /// The identifier of the bot recommendation that contains the recommended intents.
    /// This member is required.
    public var botRecommendationId: Swift.String?
    /// The version of the bot that contains the recommended intents.
    /// This member is required.
    public var botVersion: Swift.String?
    /// The identifier of the language and locale of the recommended intents.
    /// This member is required.
    public var localeId: Swift.String?
    /// The maximum number of bot recommendations to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
    public var maxResults: Swift.Int?
    /// If the response from the ListRecommendedIntents operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token in the nextToken parameter to return the next page of results.
    public var nextToken: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botRecommendationId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        localeId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botRecommendationId = botRecommendationId
        self.botVersion = botVersion
        self.localeId = localeId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRecommendedIntentsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListRecommendedIntentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

enum ListRecommendedIntentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRecommendedIntentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRecommendedIntentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botRecommendationId = output.botRecommendationId
            self.botVersion = output.botVersion
            self.localeId = output.localeId
            self.nextToken = output.nextToken
            self.summaryList = output.summaryList
        } else {
            self.botId = nil
            self.botRecommendationId = nil
            self.botVersion = nil
            self.localeId = nil
            self.nextToken = nil
            self.summaryList = nil
        }
    }
}

public struct ListRecommendedIntentsOutputResponse: Swift.Equatable {
    /// The unique identifier of the bot associated with the recommended intent.
    public var botId: Swift.String?
    /// The identifier of the bot recommendation that contains the recommended intent.
    public var botRecommendationId: Swift.String?
    /// The version of the bot that contains the intent.
    public var botVersion: Swift.String?
    /// The identifier of the language and locale of the intents to list. The string must match one of the supported locales. For more information, see [Supported languages](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html).
    public var localeId: Swift.String?
    /// A token that indicates whether there are more results to return in a response to the ListRecommendedIntents operation. If the nextToken field is present, you send the contents as the nextToken parameter of a ListRecommendedIntents operation request to get the next page of results.
    public var nextToken: Swift.String?
    /// Summary information for the intents that meet the filter criteria specified in the request. The length of the list is specified in the maxResults parameter of the request. If there are more intents available, the nextToken field contains a token to get the next page of results.
    public var summaryList: [LexModelsV2ClientTypes.RecommendedIntentSummary]?

    public init(
        botId: Swift.String? = nil,
        botRecommendationId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        localeId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        summaryList: [LexModelsV2ClientTypes.RecommendedIntentSummary]? = nil
    )
    {
        self.botId = botId
        self.botRecommendationId = botRecommendationId
        self.botVersion = botVersion
        self.localeId = localeId
        self.nextToken = nextToken
        self.summaryList = summaryList
    }
}

struct ListRecommendedIntentsOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let botVersion: Swift.String?
    let localeId: Swift.String?
    let botRecommendationId: Swift.String?
    let summaryList: [LexModelsV2ClientTypes.RecommendedIntentSummary]?
    let nextToken: Swift.String?
}

extension ListRecommendedIntentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botRecommendationId
        case botVersion
        case localeId
        case nextToken
        case summaryList
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let botRecommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botRecommendationId)
        botRecommendationId = botRecommendationIdDecoded
        let summaryListContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.RecommendedIntentSummary?].self, forKey: .summaryList)
        var summaryListDecoded0:[LexModelsV2ClientTypes.RecommendedIntentSummary]? = nil
        if let summaryListContainer = summaryListContainer {
            summaryListDecoded0 = [LexModelsV2ClientTypes.RecommendedIntentSummary]()
            for structure0 in summaryListContainer {
                if let structure0 = structure0 {
                    summaryListDecoded0?.append(structure0)
                }
            }
        }
        summaryList = summaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSessionAnalyticsDataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endDateTime
        case filters
        case maxResults
        case nextToken
        case sortBy
        case startDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endDateTime = self.endDateTime {
            try encodeContainer.encodeTimestamp(endDateTime, format: .epochSeconds, forKey: .endDateTime)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for analyticssessionfilter0 in filters {
                try filtersContainer.encode(analyticssessionfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
        if let startDateTime = self.startDateTime {
            try encodeContainer.encodeTimestamp(startDateTime, format: .epochSeconds, forKey: .startDateTime)
        }
    }
}

extension ListSessionAnalyticsDataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/analytics/sessions"
    }
}

public struct ListSessionAnalyticsDataInput: Swift.Equatable {
    /// The identifier for the bot for which you want to retrieve session analytics.
    /// This member is required.
    public var botId: Swift.String?
    /// The date and time that marks the end of the range of time for which you want to see session analytics.
    /// This member is required.
    public var endDateTime: ClientRuntime.Date?
    /// A list of objects, each of which describes a condition by which you want to filter the results.
    public var filters: [LexModelsV2ClientTypes.AnalyticsSessionFilter]?
    /// The maximum number of results to return in each page of results. If there are fewer results than the maximum page size, only the actual number of results are returned.
    public var maxResults: Swift.Int?
    /// If the response from the ListSessionAnalyticsData operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use the returned token in the nextToken parameter of a ListSessionAnalyticsData request to return the next page of results. For a complete set of results, call the ListSessionAnalyticsData operation until the nextToken returned in the response is null.
    public var nextToken: Swift.String?
    /// An object specifying the measure and method by which to sort the session analytics data.
    public var sortBy: LexModelsV2ClientTypes.SessionDataSortBy?
    /// The date and time that marks the beginning of the range of time for which you want to see session analytics.
    /// This member is required.
    public var startDateTime: ClientRuntime.Date?

    public init(
        botId: Swift.String? = nil,
        endDateTime: ClientRuntime.Date? = nil,
        filters: [LexModelsV2ClientTypes.AnalyticsSessionFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: LexModelsV2ClientTypes.SessionDataSortBy? = nil,
        startDateTime: ClientRuntime.Date? = nil
    )
    {
        self.botId = botId
        self.endDateTime = endDateTime
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.startDateTime = startDateTime
    }
}

struct ListSessionAnalyticsDataInputBody: Swift.Equatable {
    let startDateTime: ClientRuntime.Date?
    let endDateTime: ClientRuntime.Date?
    let sortBy: LexModelsV2ClientTypes.SessionDataSortBy?
    let filters: [LexModelsV2ClientTypes.AnalyticsSessionFilter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListSessionAnalyticsDataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endDateTime
        case filters
        case maxResults
        case nextToken
        case sortBy
        case startDateTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startDateTime)
        startDateTime = startDateTimeDecoded
        let endDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endDateTime)
        endDateTime = endDateTimeDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SessionDataSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let filtersContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AnalyticsSessionFilter?].self, forKey: .filters)
        var filtersDecoded0:[LexModelsV2ClientTypes.AnalyticsSessionFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LexModelsV2ClientTypes.AnalyticsSessionFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSessionAnalyticsDataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSessionAnalyticsDataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSessionAnalyticsDataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.nextToken = output.nextToken
            self.sessions = output.sessions
        } else {
            self.botId = nil
            self.nextToken = nil
            self.sessions = nil
        }
    }
}

public struct ListSessionAnalyticsDataOutputResponse: Swift.Equatable {
    /// The unique identifier of the bot that the sessions belong to.
    public var botId: Swift.String?
    /// If the response from the ListSessionAnalyticsData operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use the returned token in the nextToken parameter of a ListSessionAnalyticsData request to return the next page of results. For a complete set of results, call the ListSessionAnalyticsData operation until the nextToken returned in the response is null.
    public var nextToken: Swift.String?
    /// A list of objects, each of which contains information about a session with the bot.
    public var sessions: [LexModelsV2ClientTypes.SessionSpecification]?

    public init(
        botId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sessions: [LexModelsV2ClientTypes.SessionSpecification]? = nil
    )
    {
        self.botId = botId
        self.nextToken = nextToken
        self.sessions = sessions
    }
}

struct ListSessionAnalyticsDataOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let nextToken: Swift.String?
    let sessions: [LexModelsV2ClientTypes.SessionSpecification]?
}

extension ListSessionAnalyticsDataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case nextToken
        case sessions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let sessionsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.SessionSpecification?].self, forKey: .sessions)
        var sessionsDecoded0:[LexModelsV2ClientTypes.SessionSpecification]? = nil
        if let sessionsContainer = sessionsContainer {
            sessionsDecoded0 = [LexModelsV2ClientTypes.SessionSpecification]()
            for structure0 in sessionsContainer {
                if let structure0 = structure0 {
                    sessionsDecoded0?.append(structure0)
                }
            }
        }
        sessions = sessionsDecoded0
    }
}

extension ListSessionMetricsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case binBy
        case endDateTime
        case filters
        case groupBy
        case maxResults
        case metrics
        case nextToken
        case startDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let binBy = binBy {
            var binByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .binBy)
            for analyticsbinbyspecification0 in binBy {
                try binByContainer.encode(analyticsbinbyspecification0)
            }
        }
        if let endDateTime = self.endDateTime {
            try encodeContainer.encodeTimestamp(endDateTime, format: .epochSeconds, forKey: .endDateTime)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for analyticssessionfilter0 in filters {
                try filtersContainer.encode(analyticssessionfilter0)
            }
        }
        if let groupBy = groupBy {
            var groupByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupBy)
            for analyticssessiongroupbyspecification0 in groupBy {
                try groupByContainer.encode(analyticssessiongroupbyspecification0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let metrics = metrics {
            var metricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metrics)
            for analyticssessionmetric0 in metrics {
                try metricsContainer.encode(analyticssessionmetric0)
            }
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startDateTime = self.startDateTime {
            try encodeContainer.encodeTimestamp(startDateTime, format: .epochSeconds, forKey: .startDateTime)
        }
    }
}

extension ListSessionMetricsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/analytics/sessionmetrics"
    }
}

public struct ListSessionMetricsInput: Swift.Equatable {
    /// A list of objects, each of which contains specifications for organizing the results by time.
    public var binBy: [LexModelsV2ClientTypes.AnalyticsBinBySpecification]?
    /// The identifier for the bot for which you want to retrieve session metrics.
    /// This member is required.
    public var botId: Swift.String?
    /// The date and time that marks the end of the range of time for which you want to see session metrics.
    /// This member is required.
    public var endDateTime: ClientRuntime.Date?
    /// A list of objects, each of which describes a condition by which you want to filter the results.
    public var filters: [LexModelsV2ClientTypes.AnalyticsSessionFilter]?
    /// A list of objects, each of which specifies how to group the results. You can group by the following criteria:
    ///
    /// * ConversationEndState – The final state of the conversation. The possible end states are detailed in [Key definitions](https://docs.aws.amazon.com/analytics-key-definitions-conversations) in the user guide.
    ///
    /// * LocaleId – The unique identifier of the bot locale.
    public var groupBy: [LexModelsV2ClientTypes.AnalyticsSessionGroupBySpecification]?
    /// The maximum number of results to return in each page of results. If there are fewer results than the maximum page size, only the actual number of results are returned.
    public var maxResults: Swift.Int?
    /// A list of objects, each of which contains a metric you want to list, the statistic for the metric you want to return, and the method by which to organize the results.
    /// This member is required.
    public var metrics: [LexModelsV2ClientTypes.AnalyticsSessionMetric]?
    /// If the response from the ListSessionMetrics operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use the returned token in the nextToken parameter of a ListSessionMetrics request to return the next page of results. For a complete set of results, call the ListSessionMetrics operation until the nextToken returned in the response is null.
    public var nextToken: Swift.String?
    /// The date and time that marks the beginning of the range of time for which you want to see session metrics.
    /// This member is required.
    public var startDateTime: ClientRuntime.Date?

    public init(
        binBy: [LexModelsV2ClientTypes.AnalyticsBinBySpecification]? = nil,
        botId: Swift.String? = nil,
        endDateTime: ClientRuntime.Date? = nil,
        filters: [LexModelsV2ClientTypes.AnalyticsSessionFilter]? = nil,
        groupBy: [LexModelsV2ClientTypes.AnalyticsSessionGroupBySpecification]? = nil,
        maxResults: Swift.Int? = nil,
        metrics: [LexModelsV2ClientTypes.AnalyticsSessionMetric]? = nil,
        nextToken: Swift.String? = nil,
        startDateTime: ClientRuntime.Date? = nil
    )
    {
        self.binBy = binBy
        self.botId = botId
        self.endDateTime = endDateTime
        self.filters = filters
        self.groupBy = groupBy
        self.maxResults = maxResults
        self.metrics = metrics
        self.nextToken = nextToken
        self.startDateTime = startDateTime
    }
}

struct ListSessionMetricsInputBody: Swift.Equatable {
    let startDateTime: ClientRuntime.Date?
    let endDateTime: ClientRuntime.Date?
    let metrics: [LexModelsV2ClientTypes.AnalyticsSessionMetric]?
    let binBy: [LexModelsV2ClientTypes.AnalyticsBinBySpecification]?
    let groupBy: [LexModelsV2ClientTypes.AnalyticsSessionGroupBySpecification]?
    let filters: [LexModelsV2ClientTypes.AnalyticsSessionFilter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListSessionMetricsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case binBy
        case endDateTime
        case filters
        case groupBy
        case maxResults
        case metrics
        case nextToken
        case startDateTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startDateTime)
        startDateTime = startDateTimeDecoded
        let endDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endDateTime)
        endDateTime = endDateTimeDecoded
        let metricsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AnalyticsSessionMetric?].self, forKey: .metrics)
        var metricsDecoded0:[LexModelsV2ClientTypes.AnalyticsSessionMetric]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [LexModelsV2ClientTypes.AnalyticsSessionMetric]()
            for structure0 in metricsContainer {
                if let structure0 = structure0 {
                    metricsDecoded0?.append(structure0)
                }
            }
        }
        metrics = metricsDecoded0
        let binByContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AnalyticsBinBySpecification?].self, forKey: .binBy)
        var binByDecoded0:[LexModelsV2ClientTypes.AnalyticsBinBySpecification]? = nil
        if let binByContainer = binByContainer {
            binByDecoded0 = [LexModelsV2ClientTypes.AnalyticsBinBySpecification]()
            for structure0 in binByContainer {
                if let structure0 = structure0 {
                    binByDecoded0?.append(structure0)
                }
            }
        }
        binBy = binByDecoded0
        let groupByContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AnalyticsSessionGroupBySpecification?].self, forKey: .groupBy)
        var groupByDecoded0:[LexModelsV2ClientTypes.AnalyticsSessionGroupBySpecification]? = nil
        if let groupByContainer = groupByContainer {
            groupByDecoded0 = [LexModelsV2ClientTypes.AnalyticsSessionGroupBySpecification]()
            for structure0 in groupByContainer {
                if let structure0 = structure0 {
                    groupByDecoded0?.append(structure0)
                }
            }
        }
        groupBy = groupByDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AnalyticsSessionFilter?].self, forKey: .filters)
        var filtersDecoded0:[LexModelsV2ClientTypes.AnalyticsSessionFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LexModelsV2ClientTypes.AnalyticsSessionFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSessionMetricsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSessionMetricsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSessionMetricsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.nextToken = output.nextToken
            self.results = output.results
        } else {
            self.botId = nil
            self.nextToken = nil
            self.results = nil
        }
    }
}

public struct ListSessionMetricsOutputResponse: Swift.Equatable {
    /// The identifier for the bot for which you retrieved session metrics.
    public var botId: Swift.String?
    /// If the response from the ListSessionMetrics operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use the returned token in the nextToken parameter of a ListSessionMetrics request to return the next page of results. For a complete set of results, call the ListSessionMetrics operation until the nextToken returned in the response is null.
    public var nextToken: Swift.String?
    /// The results for the session metrics.
    public var results: [LexModelsV2ClientTypes.AnalyticsSessionResult]?

    public init(
        botId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        results: [LexModelsV2ClientTypes.AnalyticsSessionResult]? = nil
    )
    {
        self.botId = botId
        self.nextToken = nextToken
        self.results = results
    }
}

struct ListSessionMetricsOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let results: [LexModelsV2ClientTypes.AnalyticsSessionResult]?
    let nextToken: Swift.String?
}

extension ListSessionMetricsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case nextToken
        case results
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let resultsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AnalyticsSessionResult?].self, forKey: .results)
        var resultsDecoded0:[LexModelsV2ClientTypes.AnalyticsSessionResult]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [LexModelsV2ClientTypes.AnalyticsSessionResult]()
            for structure0 in resultsContainer {
                if let structure0 = structure0 {
                    resultsDecoded0?.append(structure0)
                }
            }
        }
        results = resultsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSlotTypesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case sortBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for slottypefilter0 in filters {
                try filtersContainer.encode(slottypefilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
    }
}

extension ListSlotTypesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botVersion = botVersion else {
            return nil
        }
        guard let localeId = localeId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botversions/\(botVersion.urlPercentEncoding())/botlocales/\(localeId.urlPercentEncoding())/slottypes"
    }
}

public struct ListSlotTypesInput: Swift.Equatable {
    /// The unique identifier of the bot that contains the slot types.
    /// This member is required.
    public var botId: Swift.String?
    /// The version of the bot that contains the slot type.
    /// This member is required.
    public var botVersion: Swift.String?
    /// Provides the specification of a filter used to limit the slot types in the response to only those that match the filter specification. You can only specify one filter and only one string to filter on.
    public var filters: [LexModelsV2ClientTypes.SlotTypeFilter]?
    /// The identifier of the language and locale of the slot types to list. The string must match one of the supported locales. For more information, see [Supported languages](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html).
    /// This member is required.
    public var localeId: Swift.String?
    /// The maximum number of slot types to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
    public var maxResults: Swift.Int?
    /// If the response from the ListSlotTypes operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token in the nextToken parameter to return the next page of results.
    public var nextToken: Swift.String?
    /// Determines the sort order for the response from the ListSlotTypes operation. You can choose to sort by the slot type name or last updated date in either ascending or descending order.
    public var sortBy: LexModelsV2ClientTypes.SlotTypeSortBy?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        filters: [LexModelsV2ClientTypes.SlotTypeFilter]? = nil,
        localeId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: LexModelsV2ClientTypes.SlotTypeSortBy? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.filters = filters
        self.localeId = localeId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
    }
}

struct ListSlotTypesInputBody: Swift.Equatable {
    let sortBy: LexModelsV2ClientTypes.SlotTypeSortBy?
    let filters: [LexModelsV2ClientTypes.SlotTypeFilter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListSlotTypesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case sortBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortByDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SlotTypeSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let filtersContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.SlotTypeFilter?].self, forKey: .filters)
        var filtersDecoded0:[LexModelsV2ClientTypes.SlotTypeFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LexModelsV2ClientTypes.SlotTypeFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSlotTypesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSlotTypesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSlotTypesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.localeId = output.localeId
            self.nextToken = output.nextToken
            self.slotTypeSummaries = output.slotTypeSummaries
        } else {
            self.botId = nil
            self.botVersion = nil
            self.localeId = nil
            self.nextToken = nil
            self.slotTypeSummaries = nil
        }
    }
}

public struct ListSlotTypesOutputResponse: Swift.Equatable {
    /// The identifier of the bot that contains the slot types.
    public var botId: Swift.String?
    /// The version of the bot that contains the slot types.
    public var botVersion: Swift.String?
    /// The language and local of the slot types in the list.
    public var localeId: Swift.String?
    /// A token that indicates whether there are more results to return in a response to the ListSlotTypes operation. If the nextToken field is present, you send the contents as the nextToken parameter of a ListSlotTypes operation request to get the next page of results.
    public var nextToken: Swift.String?
    /// Summary information for the slot types that meet the filter criteria specified in the request. The length of the list is specified in the maxResults parameter of the request. If there are more slot types available, the nextToken field contains a token to get the next page of results.
    public var slotTypeSummaries: [LexModelsV2ClientTypes.SlotTypeSummary]?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        localeId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        slotTypeSummaries: [LexModelsV2ClientTypes.SlotTypeSummary]? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.localeId = localeId
        self.nextToken = nextToken
        self.slotTypeSummaries = slotTypeSummaries
    }
}

struct ListSlotTypesOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let botVersion: Swift.String?
    let localeId: Swift.String?
    let slotTypeSummaries: [LexModelsV2ClientTypes.SlotTypeSummary]?
    let nextToken: Swift.String?
}

extension ListSlotTypesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botVersion
        case localeId
        case nextToken
        case slotTypeSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let slotTypeSummariesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.SlotTypeSummary?].self, forKey: .slotTypeSummaries)
        var slotTypeSummariesDecoded0:[LexModelsV2ClientTypes.SlotTypeSummary]? = nil
        if let slotTypeSummariesContainer = slotTypeSummariesContainer {
            slotTypeSummariesDecoded0 = [LexModelsV2ClientTypes.SlotTypeSummary]()
            for structure0 in slotTypeSummariesContainer {
                if let structure0 = structure0 {
                    slotTypeSummariesDecoded0?.append(structure0)
                }
            }
        }
        slotTypeSummaries = slotTypeSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSlotsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case sortBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for slotfilter0 in filters {
                try filtersContainer.encode(slotfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
    }
}

extension ListSlotsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botVersion = botVersion else {
            return nil
        }
        guard let localeId = localeId else {
            return nil
        }
        guard let intentId = intentId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botversions/\(botVersion.urlPercentEncoding())/botlocales/\(localeId.urlPercentEncoding())/intents/\(intentId.urlPercentEncoding())/slots"
    }
}

public struct ListSlotsInput: Swift.Equatable {
    /// The identifier of the bot that contains the slot.
    /// This member is required.
    public var botId: Swift.String?
    /// The version of the bot that contains the slot.
    /// This member is required.
    public var botVersion: Swift.String?
    /// Provides the specification of a filter used to limit the slots in the response to only those that match the filter specification. You can only specify one filter and only one string to filter on.
    public var filters: [LexModelsV2ClientTypes.SlotFilter]?
    /// The unique identifier of the intent that contains the slot.
    /// This member is required.
    public var intentId: Swift.String?
    /// The identifier of the language and locale of the slots to list. The string must match one of the supported locales. For more information, see [Supported languages](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html).
    /// This member is required.
    public var localeId: Swift.String?
    /// The maximum number of slots to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
    public var maxResults: Swift.Int?
    /// If the response from the ListSlots operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token in the nextToken parameter to return the next page of results.
    public var nextToken: Swift.String?
    /// Determines the sort order for the response from the ListSlots operation. You can choose to sort by the slot name or last updated date in either ascending or descending order.
    public var sortBy: LexModelsV2ClientTypes.SlotSortBy?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        filters: [LexModelsV2ClientTypes.SlotFilter]? = nil,
        intentId: Swift.String? = nil,
        localeId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: LexModelsV2ClientTypes.SlotSortBy? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.filters = filters
        self.intentId = intentId
        self.localeId = localeId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
    }
}

struct ListSlotsInputBody: Swift.Equatable {
    let sortBy: LexModelsV2ClientTypes.SlotSortBy?
    let filters: [LexModelsV2ClientTypes.SlotFilter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListSlotsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case sortBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortByDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SlotSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let filtersContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.SlotFilter?].self, forKey: .filters)
        var filtersDecoded0:[LexModelsV2ClientTypes.SlotFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LexModelsV2ClientTypes.SlotFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSlotsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSlotsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSlotsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.intentId = output.intentId
            self.localeId = output.localeId
            self.nextToken = output.nextToken
            self.slotSummaries = output.slotSummaries
        } else {
            self.botId = nil
            self.botVersion = nil
            self.intentId = nil
            self.localeId = nil
            self.nextToken = nil
            self.slotSummaries = nil
        }
    }
}

public struct ListSlotsOutputResponse: Swift.Equatable {
    /// The identifier of the bot that contains the slots.
    public var botId: Swift.String?
    /// The version of the bot that contains the slots.
    public var botVersion: Swift.String?
    /// The identifier of the intent that contains the slots.
    public var intentId: Swift.String?
    /// The language and locale of the slots in the list.
    public var localeId: Swift.String?
    /// A token that indicates whether there are more results to return in a response to the ListSlots operation. If the nextToken field is present, you send the contents as the nextToken parameter of a ListSlots operation request to get the next page of results.
    public var nextToken: Swift.String?
    /// Summary information for the slots that meet the filter criteria specified in the request. The length of the list is specified in the maxResults parameter of the request. If there are more slots available, the nextToken field contains a token to get the next page of results.
    public var slotSummaries: [LexModelsV2ClientTypes.SlotSummary]?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        intentId: Swift.String? = nil,
        localeId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        slotSummaries: [LexModelsV2ClientTypes.SlotSummary]? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.intentId = intentId
        self.localeId = localeId
        self.nextToken = nextToken
        self.slotSummaries = slotSummaries
    }
}

struct ListSlotsOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let botVersion: Swift.String?
    let localeId: Swift.String?
    let intentId: Swift.String?
    let slotSummaries: [LexModelsV2ClientTypes.SlotSummary]?
    let nextToken: Swift.String?
}

extension ListSlotsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botVersion
        case intentId
        case localeId
        case nextToken
        case slotSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let intentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intentId)
        intentId = intentIdDecoded
        let slotSummariesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.SlotSummary?].self, forKey: .slotSummaries)
        var slotSummariesDecoded0:[LexModelsV2ClientTypes.SlotSummary]? = nil
        if let slotSummariesContainer = slotSummariesContainer {
            slotSummariesDecoded0 = [LexModelsV2ClientTypes.SlotSummary]()
            for structure0 in slotSummariesContainer {
                if let structure0 = structure0 {
                    slotSummariesDecoded0?.append(structure0)
                }
            }
        }
        slotSummaries = slotSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceARN = resourceARN else {
            return nil
        }
        return "/tags/\(resourceARN.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to get a list of tags for.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags associated with a resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListTestExecutionResultItemsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resultFilterBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resultFilterBy = self.resultFilterBy {
            try encodeContainer.encode(resultFilterBy, forKey: .resultFilterBy)
        }
    }
}

extension ListTestExecutionResultItemsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let testExecutionId = testExecutionId else {
            return nil
        }
        return "/testexecutions/\(testExecutionId.urlPercentEncoding())/results"
    }
}

public struct ListTestExecutionResultItemsInput: Swift.Equatable {
    /// The maximum number of test execution result items to return in each page. If there are fewer results than the max page size, only the actual number of results are returned.
    public var maxResults: Swift.Int?
    /// If the response from the ListTestExecutionResultItems operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token in the nextToken parameter to return the next page of results.
    public var nextToken: Swift.String?
    /// The filter for the list of results from the test set execution.
    /// This member is required.
    public var resultFilterBy: LexModelsV2ClientTypes.TestExecutionResultFilterBy?
    /// The unique identifier of the test execution to list the result items.
    /// This member is required.
    public var testExecutionId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resultFilterBy: LexModelsV2ClientTypes.TestExecutionResultFilterBy? = nil,
        testExecutionId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resultFilterBy = resultFilterBy
        self.testExecutionId = testExecutionId
    }
}

struct ListTestExecutionResultItemsInputBody: Swift.Equatable {
    let resultFilterBy: LexModelsV2ClientTypes.TestExecutionResultFilterBy?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListTestExecutionResultItemsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resultFilterBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultFilterByDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestExecutionResultFilterBy.self, forKey: .resultFilterBy)
        resultFilterBy = resultFilterByDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTestExecutionResultItemsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTestExecutionResultItemsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTestExecutionResultItemsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.testExecutionResults = output.testExecutionResults
        } else {
            self.nextToken = nil
            self.testExecutionResults = nil
        }
    }
}

public struct ListTestExecutionResultItemsOutputResponse: Swift.Equatable {
    /// A token that indicates whether there are more results to return in a response to the ListTestExecutionResultItems operation. If the nextToken field is present, you send the contents as the nextToken parameter of a ListTestExecutionResultItems operation request to get the next page of results.
    public var nextToken: Swift.String?
    /// The list of results from the test execution.
    public var testExecutionResults: LexModelsV2ClientTypes.TestExecutionResultItems?

    public init(
        nextToken: Swift.String? = nil,
        testExecutionResults: LexModelsV2ClientTypes.TestExecutionResultItems? = nil
    )
    {
        self.nextToken = nextToken
        self.testExecutionResults = testExecutionResults
    }
}

struct ListTestExecutionResultItemsOutputResponseBody: Swift.Equatable {
    let testExecutionResults: LexModelsV2ClientTypes.TestExecutionResultItems?
    let nextToken: Swift.String?
}

extension ListTestExecutionResultItemsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case testExecutionResults
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testExecutionResultsDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestExecutionResultItems.self, forKey: .testExecutionResults)
        testExecutionResults = testExecutionResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTestExecutionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case sortBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
    }
}

extension ListTestExecutionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/testexecutions"
    }
}

public struct ListTestExecutionsInput: Swift.Equatable {
    /// The maximum number of test executions to return in each page. If there are fewer results than the max page size, only the actual number of results are returned.
    public var maxResults: Swift.Int?
    /// If the response from the ListTestExecutions operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token in the nextToken parameter to return the next page of results.
    public var nextToken: Swift.String?
    /// The sort order of the test set executions.
    public var sortBy: LexModelsV2ClientTypes.TestExecutionSortBy?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: LexModelsV2ClientTypes.TestExecutionSortBy? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
    }
}

struct ListTestExecutionsInputBody: Swift.Equatable {
    let sortBy: LexModelsV2ClientTypes.TestExecutionSortBy?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListTestExecutionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case sortBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortByDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestExecutionSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTestExecutionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTestExecutionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTestExecutionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.testExecutions = output.testExecutions
        } else {
            self.nextToken = nil
            self.testExecutions = nil
        }
    }
}

public struct ListTestExecutionsOutputResponse: Swift.Equatable {
    /// A token that indicates whether there are more results to return in a response to the ListTestExecutions operation. If the nextToken field is present, you send the contents as the nextToken parameter of a ListTestExecutions operation request to get the next page of results.
    public var nextToken: Swift.String?
    /// The list of test executions.
    public var testExecutions: [LexModelsV2ClientTypes.TestExecutionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        testExecutions: [LexModelsV2ClientTypes.TestExecutionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.testExecutions = testExecutions
    }
}

struct ListTestExecutionsOutputResponseBody: Swift.Equatable {
    let testExecutions: [LexModelsV2ClientTypes.TestExecutionSummary]?
    let nextToken: Swift.String?
}

extension ListTestExecutionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case testExecutions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testExecutionsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.TestExecutionSummary?].self, forKey: .testExecutions)
        var testExecutionsDecoded0:[LexModelsV2ClientTypes.TestExecutionSummary]? = nil
        if let testExecutionsContainer = testExecutionsContainer {
            testExecutionsDecoded0 = [LexModelsV2ClientTypes.TestExecutionSummary]()
            for structure0 in testExecutionsContainer {
                if let structure0 = structure0 {
                    testExecutionsDecoded0?.append(structure0)
                }
            }
        }
        testExecutions = testExecutionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTestSetRecordsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListTestSetRecordsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let testSetId = testSetId else {
            return nil
        }
        return "/testsets/\(testSetId.urlPercentEncoding())/records"
    }
}

public struct ListTestSetRecordsInput: Swift.Equatable {
    /// The maximum number of test set records to return in each page. If there are fewer records than the max page size, only the actual number of records are returned.
    public var maxResults: Swift.Int?
    /// If the response from the ListTestSetRecords operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token in the nextToken parameter to return the next page of results.
    public var nextToken: Swift.String?
    /// The identifier of the test set to list its test set records.
    /// This member is required.
    public var testSetId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        testSetId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.testSetId = testSetId
    }
}

struct ListTestSetRecordsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListTestSetRecordsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTestSetRecordsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTestSetRecordsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTestSetRecordsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.testSetRecords = output.testSetRecords
        } else {
            self.nextToken = nil
            self.testSetRecords = nil
        }
    }
}

public struct ListTestSetRecordsOutputResponse: Swift.Equatable {
    /// A token that indicates whether there are more records to return in a response to the ListTestSetRecords operation. If the nextToken field is present, you send the contents as the nextToken parameter of a ListTestSetRecords operation request to get the next page of records.
    public var nextToken: Swift.String?
    /// The list of records from the test set.
    public var testSetRecords: [LexModelsV2ClientTypes.TestSetTurnRecord]?

    public init(
        nextToken: Swift.String? = nil,
        testSetRecords: [LexModelsV2ClientTypes.TestSetTurnRecord]? = nil
    )
    {
        self.nextToken = nextToken
        self.testSetRecords = testSetRecords
    }
}

struct ListTestSetRecordsOutputResponseBody: Swift.Equatable {
    let testSetRecords: [LexModelsV2ClientTypes.TestSetTurnRecord]?
    let nextToken: Swift.String?
}

extension ListTestSetRecordsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case testSetRecords
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testSetRecordsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.TestSetTurnRecord?].self, forKey: .testSetRecords)
        var testSetRecordsDecoded0:[LexModelsV2ClientTypes.TestSetTurnRecord]? = nil
        if let testSetRecordsContainer = testSetRecordsContainer {
            testSetRecordsDecoded0 = [LexModelsV2ClientTypes.TestSetTurnRecord]()
            for structure0 in testSetRecordsContainer {
                if let structure0 = structure0 {
                    testSetRecordsDecoded0?.append(structure0)
                }
            }
        }
        testSetRecords = testSetRecordsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTestSetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case sortBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
    }
}

extension ListTestSetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/testsets"
    }
}

public struct ListTestSetsInput: Swift.Equatable {
    /// The maximum number of test sets to return in each page. If there are fewer results than the max page size, only the actual number of results are returned.
    public var maxResults: Swift.Int?
    /// If the response from the ListTestSets operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token in the nextToken parameter to return the next page of results.
    public var nextToken: Swift.String?
    /// The sort order for the list of test sets.
    public var sortBy: LexModelsV2ClientTypes.TestSetSortBy?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: LexModelsV2ClientTypes.TestSetSortBy? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
    }
}

struct ListTestSetsInputBody: Swift.Equatable {
    let sortBy: LexModelsV2ClientTypes.TestSetSortBy?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListTestSetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case sortBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortByDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestSetSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTestSetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTestSetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTestSetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.testSets = output.testSets
        } else {
            self.nextToken = nil
            self.testSets = nil
        }
    }
}

public struct ListTestSetsOutputResponse: Swift.Equatable {
    /// A token that indicates whether there are more results to return in a response to the ListTestSets operation. If the nextToken field is present, you send the contents as the nextToken parameter of a ListTestSets operation request to get the next page of results.
    public var nextToken: Swift.String?
    /// The selected test sets in a list of test sets.
    public var testSets: [LexModelsV2ClientTypes.TestSetSummary]?

    public init(
        nextToken: Swift.String? = nil,
        testSets: [LexModelsV2ClientTypes.TestSetSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.testSets = testSets
    }
}

struct ListTestSetsOutputResponseBody: Swift.Equatable {
    let testSets: [LexModelsV2ClientTypes.TestSetSummary]?
    let nextToken: Swift.String?
}

extension ListTestSetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case testSets
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testSetsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.TestSetSummary?].self, forKey: .testSets)
        var testSetsDecoded0:[LexModelsV2ClientTypes.TestSetSummary]? = nil
        if let testSetsContainer = testSetsContainer {
            testSetsDecoded0 = [LexModelsV2ClientTypes.TestSetSummary]()
            for structure0 in testSetsContainer {
                if let structure0 = structure0 {
                    testSetsDecoded0?.append(structure0)
                }
            }
        }
        testSets = testSetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListUtteranceAnalyticsDataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endDateTime
        case filters
        case maxResults
        case nextToken
        case sortBy
        case startDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endDateTime = self.endDateTime {
            try encodeContainer.encodeTimestamp(endDateTime, format: .epochSeconds, forKey: .endDateTime)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for analyticsutterancefilter0 in filters {
                try filtersContainer.encode(analyticsutterancefilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
        if let startDateTime = self.startDateTime {
            try encodeContainer.encodeTimestamp(startDateTime, format: .epochSeconds, forKey: .startDateTime)
        }
    }
}

extension ListUtteranceAnalyticsDataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/analytics/utterances"
    }
}

public struct ListUtteranceAnalyticsDataInput: Swift.Equatable {
    /// The identifier for the bot for which you want to retrieve utterance analytics.
    /// This member is required.
    public var botId: Swift.String?
    /// The date and time that marks the end of the range of time for which you want to see utterance analytics.
    /// This member is required.
    public var endDateTime: ClientRuntime.Date?
    /// A list of objects, each of which describes a condition by which you want to filter the results.
    public var filters: [LexModelsV2ClientTypes.AnalyticsUtteranceFilter]?
    /// The maximum number of results to return in each page of results. If there are fewer results than the maximum page size, only the actual number of results are returned.
    public var maxResults: Swift.Int?
    /// If the response from the ListUtteranceAnalyticsData operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use the returned token in the nextToken parameter of a ListUtteranceAnalyticsData request to return the next page of results. For a complete set of results, call the ListUtteranceAnalyticsData operation until the nextToken returned in the response is null.
    public var nextToken: Swift.String?
    /// An object specifying the measure and method by which to sort the utterance analytics data.
    public var sortBy: LexModelsV2ClientTypes.UtteranceDataSortBy?
    /// The date and time that marks the beginning of the range of time for which you want to see utterance analytics.
    /// This member is required.
    public var startDateTime: ClientRuntime.Date?

    public init(
        botId: Swift.String? = nil,
        endDateTime: ClientRuntime.Date? = nil,
        filters: [LexModelsV2ClientTypes.AnalyticsUtteranceFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: LexModelsV2ClientTypes.UtteranceDataSortBy? = nil,
        startDateTime: ClientRuntime.Date? = nil
    )
    {
        self.botId = botId
        self.endDateTime = endDateTime
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.startDateTime = startDateTime
    }
}

struct ListUtteranceAnalyticsDataInputBody: Swift.Equatable {
    let startDateTime: ClientRuntime.Date?
    let endDateTime: ClientRuntime.Date?
    let sortBy: LexModelsV2ClientTypes.UtteranceDataSortBy?
    let filters: [LexModelsV2ClientTypes.AnalyticsUtteranceFilter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListUtteranceAnalyticsDataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endDateTime
        case filters
        case maxResults
        case nextToken
        case sortBy
        case startDateTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startDateTime)
        startDateTime = startDateTimeDecoded
        let endDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endDateTime)
        endDateTime = endDateTimeDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.UtteranceDataSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let filtersContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AnalyticsUtteranceFilter?].self, forKey: .filters)
        var filtersDecoded0:[LexModelsV2ClientTypes.AnalyticsUtteranceFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LexModelsV2ClientTypes.AnalyticsUtteranceFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListUtteranceAnalyticsDataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListUtteranceAnalyticsDataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListUtteranceAnalyticsDataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.nextToken = output.nextToken
            self.utterances = output.utterances
        } else {
            self.botId = nil
            self.nextToken = nil
            self.utterances = nil
        }
    }
}

public struct ListUtteranceAnalyticsDataOutputResponse: Swift.Equatable {
    /// The unique identifier of the bot that the utterances belong to.
    public var botId: Swift.String?
    /// If the response from the ListUtteranceAnalyticsData operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use the returned token in the nextToken parameter of a ListUtteranceAnalyticsData request to return the next page of results. For a complete set of results, call the ListUtteranceAnalyticsData operation until the nextToken returned in the response is null.
    public var nextToken: Swift.String?
    /// A list of objects, each of which contains information about an utterance in a user session with your bot.
    public var utterances: [LexModelsV2ClientTypes.UtteranceSpecification]?

    public init(
        botId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        utterances: [LexModelsV2ClientTypes.UtteranceSpecification]? = nil
    )
    {
        self.botId = botId
        self.nextToken = nextToken
        self.utterances = utterances
    }
}

struct ListUtteranceAnalyticsDataOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let nextToken: Swift.String?
    let utterances: [LexModelsV2ClientTypes.UtteranceSpecification]?
}

extension ListUtteranceAnalyticsDataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case nextToken
        case utterances
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let utterancesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.UtteranceSpecification?].self, forKey: .utterances)
        var utterancesDecoded0:[LexModelsV2ClientTypes.UtteranceSpecification]? = nil
        if let utterancesContainer = utterancesContainer {
            utterancesDecoded0 = [LexModelsV2ClientTypes.UtteranceSpecification]()
            for structure0 in utterancesContainer {
                if let structure0 = structure0 {
                    utterancesDecoded0?.append(structure0)
                }
            }
        }
        utterances = utterancesDecoded0
    }
}

extension ListUtteranceMetricsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case binBy
        case endDateTime
        case filters
        case groupBy
        case maxResults
        case metrics
        case nextToken
        case startDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for analyticsutteranceattribute0 in attributes {
                try attributesContainer.encode(analyticsutteranceattribute0)
            }
        }
        if let binBy = binBy {
            var binByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .binBy)
            for analyticsbinbyspecification0 in binBy {
                try binByContainer.encode(analyticsbinbyspecification0)
            }
        }
        if let endDateTime = self.endDateTime {
            try encodeContainer.encodeTimestamp(endDateTime, format: .epochSeconds, forKey: .endDateTime)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for analyticsutterancefilter0 in filters {
                try filtersContainer.encode(analyticsutterancefilter0)
            }
        }
        if let groupBy = groupBy {
            var groupByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupBy)
            for analyticsutterancegroupbyspecification0 in groupBy {
                try groupByContainer.encode(analyticsutterancegroupbyspecification0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let metrics = metrics {
            var metricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metrics)
            for analyticsutterancemetric0 in metrics {
                try metricsContainer.encode(analyticsutterancemetric0)
            }
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startDateTime = self.startDateTime {
            try encodeContainer.encodeTimestamp(startDateTime, format: .epochSeconds, forKey: .startDateTime)
        }
    }
}

extension ListUtteranceMetricsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/analytics/utterancemetrics"
    }
}

public struct ListUtteranceMetricsInput: Swift.Equatable {
    /// A list containing attributes related to the utterance that you want the response to return. The following attributes are possible:
    ///
    /// * LastUsedIntent – The last used intent at the time of the utterance.
    public var attributes: [LexModelsV2ClientTypes.AnalyticsUtteranceAttribute]?
    /// A list of objects, each of which contains specifications for organizing the results by time.
    public var binBy: [LexModelsV2ClientTypes.AnalyticsBinBySpecification]?
    /// The identifier for the bot for which you want to retrieve utterance metrics.
    /// This member is required.
    public var botId: Swift.String?
    /// The date and time that marks the end of the range of time for which you want to see utterance metrics.
    /// This member is required.
    public var endDateTime: ClientRuntime.Date?
    /// A list of objects, each of which describes a condition by which you want to filter the results.
    public var filters: [LexModelsV2ClientTypes.AnalyticsUtteranceFilter]?
    /// A list of objects, each of which specifies how to group the results. You can group by the following criteria:
    ///
    /// * UtteranceText – The transcription of the utterance.
    ///
    /// * UtteranceState – The state of the utterance. The possible states are detailed in [Key definitions](https://docs.aws.amazon.com/analytics-key-definitions-utterances) in the user guide.
    public var groupBy: [LexModelsV2ClientTypes.AnalyticsUtteranceGroupBySpecification]?
    /// The maximum number of results to return in each page of results. If there are fewer results than the maximum page size, only the actual number of results are returned.
    public var maxResults: Swift.Int?
    /// A list of objects, each of which contains a metric you want to list, the statistic for the metric you want to return, and the method by which to organize the results.
    /// This member is required.
    public var metrics: [LexModelsV2ClientTypes.AnalyticsUtteranceMetric]?
    /// If the response from the ListUtteranceMetrics operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use the returned token in the nextToken parameter of a ListUtteranceMetrics request to return the next page of results. For a complete set of results, call the ListUtteranceMetrics operation until the nextToken returned in the response is null.
    public var nextToken: Swift.String?
    /// The date and time that marks the beginning of the range of time for which you want to see utterance metrics.
    /// This member is required.
    public var startDateTime: ClientRuntime.Date?

    public init(
        attributes: [LexModelsV2ClientTypes.AnalyticsUtteranceAttribute]? = nil,
        binBy: [LexModelsV2ClientTypes.AnalyticsBinBySpecification]? = nil,
        botId: Swift.String? = nil,
        endDateTime: ClientRuntime.Date? = nil,
        filters: [LexModelsV2ClientTypes.AnalyticsUtteranceFilter]? = nil,
        groupBy: [LexModelsV2ClientTypes.AnalyticsUtteranceGroupBySpecification]? = nil,
        maxResults: Swift.Int? = nil,
        metrics: [LexModelsV2ClientTypes.AnalyticsUtteranceMetric]? = nil,
        nextToken: Swift.String? = nil,
        startDateTime: ClientRuntime.Date? = nil
    )
    {
        self.attributes = attributes
        self.binBy = binBy
        self.botId = botId
        self.endDateTime = endDateTime
        self.filters = filters
        self.groupBy = groupBy
        self.maxResults = maxResults
        self.metrics = metrics
        self.nextToken = nextToken
        self.startDateTime = startDateTime
    }
}

struct ListUtteranceMetricsInputBody: Swift.Equatable {
    let startDateTime: ClientRuntime.Date?
    let endDateTime: ClientRuntime.Date?
    let metrics: [LexModelsV2ClientTypes.AnalyticsUtteranceMetric]?
    let binBy: [LexModelsV2ClientTypes.AnalyticsBinBySpecification]?
    let groupBy: [LexModelsV2ClientTypes.AnalyticsUtteranceGroupBySpecification]?
    let attributes: [LexModelsV2ClientTypes.AnalyticsUtteranceAttribute]?
    let filters: [LexModelsV2ClientTypes.AnalyticsUtteranceFilter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListUtteranceMetricsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case binBy
        case endDateTime
        case filters
        case groupBy
        case maxResults
        case metrics
        case nextToken
        case startDateTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startDateTime)
        startDateTime = startDateTimeDecoded
        let endDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endDateTime)
        endDateTime = endDateTimeDecoded
        let metricsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AnalyticsUtteranceMetric?].self, forKey: .metrics)
        var metricsDecoded0:[LexModelsV2ClientTypes.AnalyticsUtteranceMetric]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [LexModelsV2ClientTypes.AnalyticsUtteranceMetric]()
            for structure0 in metricsContainer {
                if let structure0 = structure0 {
                    metricsDecoded0?.append(structure0)
                }
            }
        }
        metrics = metricsDecoded0
        let binByContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AnalyticsBinBySpecification?].self, forKey: .binBy)
        var binByDecoded0:[LexModelsV2ClientTypes.AnalyticsBinBySpecification]? = nil
        if let binByContainer = binByContainer {
            binByDecoded0 = [LexModelsV2ClientTypes.AnalyticsBinBySpecification]()
            for structure0 in binByContainer {
                if let structure0 = structure0 {
                    binByDecoded0?.append(structure0)
                }
            }
        }
        binBy = binByDecoded0
        let groupByContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AnalyticsUtteranceGroupBySpecification?].self, forKey: .groupBy)
        var groupByDecoded0:[LexModelsV2ClientTypes.AnalyticsUtteranceGroupBySpecification]? = nil
        if let groupByContainer = groupByContainer {
            groupByDecoded0 = [LexModelsV2ClientTypes.AnalyticsUtteranceGroupBySpecification]()
            for structure0 in groupByContainer {
                if let structure0 = structure0 {
                    groupByDecoded0?.append(structure0)
                }
            }
        }
        groupBy = groupByDecoded0
        let attributesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AnalyticsUtteranceAttribute?].self, forKey: .attributes)
        var attributesDecoded0:[LexModelsV2ClientTypes.AnalyticsUtteranceAttribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [LexModelsV2ClientTypes.AnalyticsUtteranceAttribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AnalyticsUtteranceFilter?].self, forKey: .filters)
        var filtersDecoded0:[LexModelsV2ClientTypes.AnalyticsUtteranceFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LexModelsV2ClientTypes.AnalyticsUtteranceFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListUtteranceMetricsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListUtteranceMetricsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListUtteranceMetricsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.nextToken = output.nextToken
            self.results = output.results
        } else {
            self.botId = nil
            self.nextToken = nil
            self.results = nil
        }
    }
}

public struct ListUtteranceMetricsOutputResponse: Swift.Equatable {
    /// The identifier for the bot for which you retrieved utterance metrics.
    public var botId: Swift.String?
    /// If the response from the ListUtteranceMetrics operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use the returned token in the nextToken parameter of a ListUtteranceMetrics request to return the next page of results. For a complete set of results, call the ListUtteranceMetrics operation until the nextToken returned in the response is null.
    public var nextToken: Swift.String?
    /// The results for the utterance metrics.
    public var results: [LexModelsV2ClientTypes.AnalyticsUtteranceResult]?

    public init(
        botId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        results: [LexModelsV2ClientTypes.AnalyticsUtteranceResult]? = nil
    )
    {
        self.botId = botId
        self.nextToken = nextToken
        self.results = results
    }
}

struct ListUtteranceMetricsOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let results: [LexModelsV2ClientTypes.AnalyticsUtteranceResult]?
    let nextToken: Swift.String?
}

extension ListUtteranceMetricsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case nextToken
        case results
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let resultsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AnalyticsUtteranceResult?].self, forKey: .results)
        var resultsDecoded0:[LexModelsV2ClientTypes.AnalyticsUtteranceResult]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [LexModelsV2ClientTypes.AnalyticsUtteranceResult]()
            for structure0 in resultsContainer {
                if let structure0 = structure0 {
                    resultsDecoded0?.append(structure0)
                }
            }
        }
        results = resultsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension LexModelsV2ClientTypes {
    public enum MergeStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case append
        case failonconflict
        case overwrite
        case sdkUnknown(Swift.String)

        public static var allCases: [MergeStrategy] {
            return [
                .append,
                .failonconflict,
                .overwrite,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .append: return "Append"
            case .failonconflict: return "FailOnConflict"
            case .overwrite: return "Overwrite"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MergeStrategy(rawValue: rawValue) ?? MergeStrategy.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.Message: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customPayload
        case imageResponseCard
        case plainTextMessage
        case ssmlMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customPayload = self.customPayload {
            try encodeContainer.encode(customPayload, forKey: .customPayload)
        }
        if let imageResponseCard = self.imageResponseCard {
            try encodeContainer.encode(imageResponseCard, forKey: .imageResponseCard)
        }
        if let plainTextMessage = self.plainTextMessage {
            try encodeContainer.encode(plainTextMessage, forKey: .plainTextMessage)
        }
        if let ssmlMessage = self.ssmlMessage {
            try encodeContainer.encode(ssmlMessage, forKey: .ssmlMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let plainTextMessageDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.PlainTextMessage.self, forKey: .plainTextMessage)
        plainTextMessage = plainTextMessageDecoded
        let customPayloadDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.CustomPayload.self, forKey: .customPayload)
        customPayload = customPayloadDecoded
        let ssmlMessageDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SSMLMessage.self, forKey: .ssmlMessage)
        ssmlMessage = ssmlMessageDecoded
        let imageResponseCardDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ImageResponseCard.self, forKey: .imageResponseCard)
        imageResponseCard = imageResponseCardDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// The object that provides message text and its type.
    public struct Message: Swift.Equatable {
        /// A message in a custom format defined by the client application.
        public var customPayload: LexModelsV2ClientTypes.CustomPayload?
        /// A message that defines a response card that the client application can show to the user.
        public var imageResponseCard: LexModelsV2ClientTypes.ImageResponseCard?
        /// A message in plain text format.
        public var plainTextMessage: LexModelsV2ClientTypes.PlainTextMessage?
        /// A message in Speech Synthesis Markup Language (SSML).
        public var ssmlMessage: LexModelsV2ClientTypes.SSMLMessage?

        public init(
            customPayload: LexModelsV2ClientTypes.CustomPayload? = nil,
            imageResponseCard: LexModelsV2ClientTypes.ImageResponseCard? = nil,
            plainTextMessage: LexModelsV2ClientTypes.PlainTextMessage? = nil,
            ssmlMessage: LexModelsV2ClientTypes.SSMLMessage? = nil
        )
        {
            self.customPayload = customPayload
            self.imageResponseCard = imageResponseCard
            self.plainTextMessage = plainTextMessage
            self.ssmlMessage = ssmlMessage
        }
    }

}

extension LexModelsV2ClientTypes.MessageGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case variations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let variations = variations {
            var variationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .variations)
            for message0 in variations {
                try variationsContainer.encode(message0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.Message.self, forKey: .message)
        message = messageDecoded
        let variationsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.Message?].self, forKey: .variations)
        var variationsDecoded0:[LexModelsV2ClientTypes.Message]? = nil
        if let variationsContainer = variationsContainer {
            variationsDecoded0 = [LexModelsV2ClientTypes.Message]()
            for structure0 in variationsContainer {
                if let structure0 = structure0 {
                    variationsDecoded0?.append(structure0)
                }
            }
        }
        variations = variationsDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// Provides one or more messages that Amazon Lex should send to the user.
    public struct MessageGroup: Swift.Equatable {
        /// The primary message that Amazon Lex should send to the user.
        /// This member is required.
        public var message: LexModelsV2ClientTypes.Message?
        /// Message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user.
        public var variations: [LexModelsV2ClientTypes.Message]?

        public init(
            message: LexModelsV2ClientTypes.Message? = nil,
            variations: [LexModelsV2ClientTypes.Message]? = nil
        )
        {
            self.message = message
            self.variations = variations
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum MessageSelectionStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ordered
        case random
        case sdkUnknown(Swift.String)

        public static var allCases: [MessageSelectionStrategy] {
            return [
                .ordered,
                .random,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ordered: return "Ordered"
            case .random: return "Random"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MessageSelectionStrategy(rawValue: rawValue) ?? MessageSelectionStrategy.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.MultipleValuesSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowMultipleValues
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allowMultipleValues != false {
            try encodeContainer.encode(allowMultipleValues, forKey: .allowMultipleValues)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowMultipleValuesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowMultipleValues) ?? false
        allowMultipleValues = allowMultipleValuesDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Indicates whether a slot can return multiple values.
    public struct MultipleValuesSetting: Swift.Equatable {
        /// Indicates whether a slot can return multiple values. When true, the slot may return more than one value in a response. When false, the slot returns only a single value. Multi-value slots are only available in the en-US locale. If you set this value to true in any other locale, Amazon Lex throws a ValidationException. If the allowMutlipleValues is not set, the default value is false.
        public var allowMultipleValues: Swift.Bool

        public init(
            allowMultipleValues: Swift.Bool = false
        )
        {
            self.allowMultipleValues = allowMultipleValues
        }
    }

}

extension LexModelsV2ClientTypes.NewCustomVocabularyItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayAs
        case phrase
        case weight
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayAs = self.displayAs {
            try encodeContainer.encode(displayAs, forKey: .displayAs)
        }
        if let phrase = self.phrase {
            try encodeContainer.encode(phrase, forKey: .phrase)
        }
        if let weight = self.weight {
            try encodeContainer.encode(weight, forKey: .weight)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phraseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phrase)
        phrase = phraseDecoded
        let weightDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .weight)
        weight = weightDecoded
        let displayAsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayAs)
        displayAs = displayAsDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// The new custom vocabulary item from the custom vocabulary list.
    public struct NewCustomVocabularyItem: Swift.Equatable {
        /// The display as value assigned to the new custom vocabulary item from the custom vocabulary list.
        public var displayAs: Swift.String?
        /// The unique phrase for the new custom vocabulary item from the custom vocabulary list.
        /// This member is required.
        public var phrase: Swift.String?
        /// The weight assigned to the new custom vocabulary item from the custom vocabulary list.
        public var weight: Swift.Int?

        public init(
            displayAs: Swift.String? = nil,
            phrase: Swift.String? = nil,
            weight: Swift.Int? = nil
        )
        {
            self.displayAs = displayAs
            self.phrase = phrase
            self.weight = weight
        }
    }

}

extension LexModelsV2ClientTypes.ObfuscationSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case obfuscationSettingType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let obfuscationSettingType = self.obfuscationSettingType {
            try encodeContainer.encode(obfuscationSettingType.rawValue, forKey: .obfuscationSettingType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let obfuscationSettingTypeDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ObfuscationSettingType.self, forKey: .obfuscationSettingType)
        obfuscationSettingType = obfuscationSettingTypeDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Determines whether Amazon Lex obscures slot values in conversation logs.
    public struct ObfuscationSetting: Swift.Equatable {
        /// Value that determines whether Amazon Lex obscures slot values in conversation logs. The default is to obscure the values.
        /// This member is required.
        public var obfuscationSettingType: LexModelsV2ClientTypes.ObfuscationSettingType?

        public init(
            obfuscationSettingType: LexModelsV2ClientTypes.ObfuscationSettingType? = nil
        )
        {
            self.obfuscationSettingType = obfuscationSettingType
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum ObfuscationSettingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case defaultobfuscation
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [ObfuscationSettingType] {
            return [
                .defaultobfuscation,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .defaultobfuscation: return "DefaultObfuscation"
            case .none: return "None"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ObfuscationSettingType(rawValue: rawValue) ?? ObfuscationSettingType.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.OutputContext: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case timeToLiveInSeconds
        case turnsToLive
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let timeToLiveInSeconds = self.timeToLiveInSeconds {
            try encodeContainer.encode(timeToLiveInSeconds, forKey: .timeToLiveInSeconds)
        }
        if let turnsToLive = self.turnsToLive {
            try encodeContainer.encode(turnsToLive, forKey: .turnsToLive)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let timeToLiveInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeToLiveInSeconds)
        timeToLiveInSeconds = timeToLiveInSecondsDecoded
        let turnsToLiveDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .turnsToLive)
        turnsToLive = turnsToLiveDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Describes a session context that is activated when an intent is fulfilled.
    public struct OutputContext: Swift.Equatable {
        /// The name of the output context.
        /// This member is required.
        public var name: Swift.String?
        /// The amount of time, in seconds, that the output context should remain active. The time is figured from the first time the context is sent to the user.
        /// This member is required.
        public var timeToLiveInSeconds: Swift.Int?
        /// The number of conversation turns that the output context should remain active. The number of turns is counted from the first time that the context is sent to the user.
        /// This member is required.
        public var turnsToLive: Swift.Int?

        public init(
            name: Swift.String? = nil,
            timeToLiveInSeconds: Swift.Int? = nil,
            turnsToLive: Swift.Int? = nil
        )
        {
            self.name = name
            self.timeToLiveInSeconds = timeToLiveInSeconds
            self.turnsToLive = turnsToLive
        }
    }

}

extension LexModelsV2ClientTypes.OverallTestResultItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endToEndResultCounts
        case multiTurnConversation
        case speechTranscriptionResultCounts
        case totalResultCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endToEndResultCounts = endToEndResultCounts {
            var endToEndResultCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .endToEndResultCounts)
            for (dictKey0, testResultMatchStatusCountMap0) in endToEndResultCounts {
                try endToEndResultCountsContainer.encode(testResultMatchStatusCountMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if multiTurnConversation != false {
            try encodeContainer.encode(multiTurnConversation, forKey: .multiTurnConversation)
        }
        if let speechTranscriptionResultCounts = speechTranscriptionResultCounts {
            var speechTranscriptionResultCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .speechTranscriptionResultCounts)
            for (dictKey0, testResultMatchStatusCountMap0) in speechTranscriptionResultCounts {
                try speechTranscriptionResultCountsContainer.encode(testResultMatchStatusCountMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let totalResultCount = self.totalResultCount {
            try encodeContainer.encode(totalResultCount, forKey: .totalResultCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let multiTurnConversationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiTurnConversation) ?? false
        multiTurnConversation = multiTurnConversationDecoded
        let totalResultCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalResultCount)
        totalResultCount = totalResultCountDecoded
        let speechTranscriptionResultCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .speechTranscriptionResultCounts)
        var speechTranscriptionResultCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let speechTranscriptionResultCountsContainer = speechTranscriptionResultCountsContainer {
            speechTranscriptionResultCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, count0) in speechTranscriptionResultCountsContainer {
                if let count0 = count0 {
                    speechTranscriptionResultCountsDecoded0?[key0] = count0
                }
            }
        }
        speechTranscriptionResultCounts = speechTranscriptionResultCountsDecoded0
        let endToEndResultCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .endToEndResultCounts)
        var endToEndResultCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let endToEndResultCountsContainer = endToEndResultCountsContainer {
            endToEndResultCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, count0) in endToEndResultCountsContainer {
                if let count0 = count0 {
                    endToEndResultCountsDecoded0?[key0] = count0
                }
            }
        }
        endToEndResultCounts = endToEndResultCountsDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// Information about the overall results for a test execution result.
    public struct OverallTestResultItem: Swift.Equatable {
        /// The number of results that succeeded.
        /// This member is required.
        public var endToEndResultCounts: [Swift.String:Swift.Int]?
        /// Indicates whether the conversation contains multiple turns or not.
        /// This member is required.
        public var multiTurnConversation: Swift.Bool
        /// The number of speech transcription results in the overall test.
        public var speechTranscriptionResultCounts: [Swift.String:Swift.Int]?
        /// The total number of overall results in the result of the test execution.
        /// This member is required.
        public var totalResultCount: Swift.Int?

        public init(
            endToEndResultCounts: [Swift.String:Swift.Int]? = nil,
            multiTurnConversation: Swift.Bool = false,
            speechTranscriptionResultCounts: [Swift.String:Swift.Int]? = nil,
            totalResultCount: Swift.Int? = nil
        )
        {
            self.endToEndResultCounts = endToEndResultCounts
            self.multiTurnConversation = multiTurnConversation
            self.speechTranscriptionResultCounts = speechTranscriptionResultCounts
            self.totalResultCount = totalResultCount
        }
    }

}

extension LexModelsV2ClientTypes.OverallTestResults: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for overalltestresultitem0 in items {
                try itemsContainer.encode(overalltestresultitem0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.OverallTestResultItem?].self, forKey: .items)
        var itemsDecoded0:[LexModelsV2ClientTypes.OverallTestResultItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [LexModelsV2ClientTypes.OverallTestResultItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// Information about the overall test results.
    public struct OverallTestResults: Swift.Equatable {
        /// A list of the overall test results.
        /// This member is required.
        public var items: [LexModelsV2ClientTypes.OverallTestResultItem]?

        public init(
            items: [LexModelsV2ClientTypes.OverallTestResultItem]? = nil
        )
        {
            self.items = items
        }
    }

}

extension LexModelsV2ClientTypes.ParentBotNetwork: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botId = self.botId {
            try encodeContainer.encode(botId, forKey: .botId)
        }
        if let botVersion = self.botVersion {
            try encodeContainer.encode(botVersion, forKey: .botVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// A network of bots.
    public struct ParentBotNetwork: Swift.Equatable {
        /// The identifier of the network of bots assigned by Amazon Lex.
        /// This member is required.
        public var botId: Swift.String?
        /// The version of the network of bots.
        /// This member is required.
        public var botVersion: Swift.String?

        public init(
            botId: Swift.String? = nil,
            botVersion: Swift.String? = nil
        )
        {
            self.botId = botId
            self.botVersion = botVersion
        }
    }

}

extension LexModelsV2ClientTypes.PathFormat: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectPrefixes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectPrefixes = objectPrefixes {
            var objectPrefixesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .objectPrefixes)
            for objectprefix0 in objectPrefixes {
                try objectPrefixesContainer.encode(objectprefix0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectPrefixesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .objectPrefixes)
        var objectPrefixesDecoded0:[Swift.String]? = nil
        if let objectPrefixesContainer = objectPrefixesContainer {
            objectPrefixesDecoded0 = [Swift.String]()
            for string0 in objectPrefixesContainer {
                if let string0 = string0 {
                    objectPrefixesDecoded0?.append(string0)
                }
            }
        }
        objectPrefixes = objectPrefixesDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// The object that contains a path format that will be applied when Amazon Lex reads the transcript file in the bucket you provide. Specify this object if you only want Lex to read a subset of files in your Amazon S3 bucket.
    public struct PathFormat: Swift.Equatable {
        /// A list of Amazon S3 prefixes that points to sub-folders in the Amazon S3 bucket. Specify this list if you only want Lex to read the files under this set of sub-folders.
        public var objectPrefixes: [Swift.String]?

        public init(
            objectPrefixes: [Swift.String]? = nil
        )
        {
            self.objectPrefixes = objectPrefixes
        }
    }

}

extension LexModelsV2ClientTypes.PlainTextMessage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Defines an ASCII text message to send to the user.
    public struct PlainTextMessage: Swift.Equatable {
        /// The message to send to the user.
        /// This member is required.
        public var value: Swift.String?

        public init(
            value: Swift.String? = nil
        )
        {
            self.value = value
        }
    }

}

extension LexModelsV2ClientTypes.PostDialogCodeHookInvocationSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureConditional
        case failureNextStep
        case failureResponse
        case successConditional
        case successNextStep
        case successResponse
        case timeoutConditional
        case timeoutNextStep
        case timeoutResponse
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureConditional = self.failureConditional {
            try encodeContainer.encode(failureConditional, forKey: .failureConditional)
        }
        if let failureNextStep = self.failureNextStep {
            try encodeContainer.encode(failureNextStep, forKey: .failureNextStep)
        }
        if let failureResponse = self.failureResponse {
            try encodeContainer.encode(failureResponse, forKey: .failureResponse)
        }
        if let successConditional = self.successConditional {
            try encodeContainer.encode(successConditional, forKey: .successConditional)
        }
        if let successNextStep = self.successNextStep {
            try encodeContainer.encode(successNextStep, forKey: .successNextStep)
        }
        if let successResponse = self.successResponse {
            try encodeContainer.encode(successResponse, forKey: .successResponse)
        }
        if let timeoutConditional = self.timeoutConditional {
            try encodeContainer.encode(timeoutConditional, forKey: .timeoutConditional)
        }
        if let timeoutNextStep = self.timeoutNextStep {
            try encodeContainer.encode(timeoutNextStep, forKey: .timeoutNextStep)
        }
        if let timeoutResponse = self.timeoutResponse {
            try encodeContainer.encode(timeoutResponse, forKey: .timeoutResponse)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successResponseDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ResponseSpecification.self, forKey: .successResponse)
        successResponse = successResponseDecoded
        let successNextStepDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.DialogState.self, forKey: .successNextStep)
        successNextStep = successNextStepDecoded
        let successConditionalDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ConditionalSpecification.self, forKey: .successConditional)
        successConditional = successConditionalDecoded
        let failureResponseDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ResponseSpecification.self, forKey: .failureResponse)
        failureResponse = failureResponseDecoded
        let failureNextStepDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.DialogState.self, forKey: .failureNextStep)
        failureNextStep = failureNextStepDecoded
        let failureConditionalDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ConditionalSpecification.self, forKey: .failureConditional)
        failureConditional = failureConditionalDecoded
        let timeoutResponseDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ResponseSpecification.self, forKey: .timeoutResponse)
        timeoutResponse = timeoutResponseDecoded
        let timeoutNextStepDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.DialogState.self, forKey: .timeoutNextStep)
        timeoutNextStep = timeoutNextStepDecoded
        let timeoutConditionalDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ConditionalSpecification.self, forKey: .timeoutConditional)
        timeoutConditional = timeoutConditionalDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Specifies next steps to run after the dialog code hook finishes.
    public struct PostDialogCodeHookInvocationSpecification: Swift.Equatable {
        /// A list of conditional branches to evaluate after the dialog code hook throws an exception or returns with the State field of the Intent object set to Failed.
        public var failureConditional: LexModelsV2ClientTypes.ConditionalSpecification?
        /// Specifies the next step the bot runs after the dialog code hook throws an exception or returns with the State field of the Intent object set to Failed.
        public var failureNextStep: LexModelsV2ClientTypes.DialogState?
        /// Specifies a list of message groups that Amazon Lex uses to respond the user input.
        public var failureResponse: LexModelsV2ClientTypes.ResponseSpecification?
        /// A list of conditional branches to evaluate after the dialog code hook finishes successfully.
        public var successConditional: LexModelsV2ClientTypes.ConditionalSpecification?
        /// Specifics the next step the bot runs after the dialog code hook finishes successfully.
        public var successNextStep: LexModelsV2ClientTypes.DialogState?
        /// Specifies a list of message groups that Amazon Lex uses to respond the user input.
        public var successResponse: LexModelsV2ClientTypes.ResponseSpecification?
        /// A list of conditional branches to evaluate if the code hook times out.
        public var timeoutConditional: LexModelsV2ClientTypes.ConditionalSpecification?
        /// Specifies the next step that the bot runs when the code hook times out.
        public var timeoutNextStep: LexModelsV2ClientTypes.DialogState?
        /// Specifies a list of message groups that Amazon Lex uses to respond the user input.
        public var timeoutResponse: LexModelsV2ClientTypes.ResponseSpecification?

        public init(
            failureConditional: LexModelsV2ClientTypes.ConditionalSpecification? = nil,
            failureNextStep: LexModelsV2ClientTypes.DialogState? = nil,
            failureResponse: LexModelsV2ClientTypes.ResponseSpecification? = nil,
            successConditional: LexModelsV2ClientTypes.ConditionalSpecification? = nil,
            successNextStep: LexModelsV2ClientTypes.DialogState? = nil,
            successResponse: LexModelsV2ClientTypes.ResponseSpecification? = nil,
            timeoutConditional: LexModelsV2ClientTypes.ConditionalSpecification? = nil,
            timeoutNextStep: LexModelsV2ClientTypes.DialogState? = nil,
            timeoutResponse: LexModelsV2ClientTypes.ResponseSpecification? = nil
        )
        {
            self.failureConditional = failureConditional
            self.failureNextStep = failureNextStep
            self.failureResponse = failureResponse
            self.successConditional = successConditional
            self.successNextStep = successNextStep
            self.successResponse = successResponse
            self.timeoutConditional = timeoutConditional
            self.timeoutNextStep = timeoutNextStep
            self.timeoutResponse = timeoutResponse
        }
    }

}

extension LexModelsV2ClientTypes.PostFulfillmentStatusSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureConditional
        case failureNextStep
        case failureResponse
        case successConditional
        case successNextStep
        case successResponse
        case timeoutConditional
        case timeoutNextStep
        case timeoutResponse
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureConditional = self.failureConditional {
            try encodeContainer.encode(failureConditional, forKey: .failureConditional)
        }
        if let failureNextStep = self.failureNextStep {
            try encodeContainer.encode(failureNextStep, forKey: .failureNextStep)
        }
        if let failureResponse = self.failureResponse {
            try encodeContainer.encode(failureResponse, forKey: .failureResponse)
        }
        if let successConditional = self.successConditional {
            try encodeContainer.encode(successConditional, forKey: .successConditional)
        }
        if let successNextStep = self.successNextStep {
            try encodeContainer.encode(successNextStep, forKey: .successNextStep)
        }
        if let successResponse = self.successResponse {
            try encodeContainer.encode(successResponse, forKey: .successResponse)
        }
        if let timeoutConditional = self.timeoutConditional {
            try encodeContainer.encode(timeoutConditional, forKey: .timeoutConditional)
        }
        if let timeoutNextStep = self.timeoutNextStep {
            try encodeContainer.encode(timeoutNextStep, forKey: .timeoutNextStep)
        }
        if let timeoutResponse = self.timeoutResponse {
            try encodeContainer.encode(timeoutResponse, forKey: .timeoutResponse)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successResponseDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ResponseSpecification.self, forKey: .successResponse)
        successResponse = successResponseDecoded
        let failureResponseDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ResponseSpecification.self, forKey: .failureResponse)
        failureResponse = failureResponseDecoded
        let timeoutResponseDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ResponseSpecification.self, forKey: .timeoutResponse)
        timeoutResponse = timeoutResponseDecoded
        let successNextStepDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.DialogState.self, forKey: .successNextStep)
        successNextStep = successNextStepDecoded
        let successConditionalDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ConditionalSpecification.self, forKey: .successConditional)
        successConditional = successConditionalDecoded
        let failureNextStepDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.DialogState.self, forKey: .failureNextStep)
        failureNextStep = failureNextStepDecoded
        let failureConditionalDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ConditionalSpecification.self, forKey: .failureConditional)
        failureConditional = failureConditionalDecoded
        let timeoutNextStepDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.DialogState.self, forKey: .timeoutNextStep)
        timeoutNextStep = timeoutNextStepDecoded
        let timeoutConditionalDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ConditionalSpecification.self, forKey: .timeoutConditional)
        timeoutConditional = timeoutConditionalDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Provides a setting that determines whether the post-fulfillment response is sent to the user. For more information, see [https://docs.aws.amazon.com/lexv2/latest/dg/streaming-progress.html#progress-complete](https://docs.aws.amazon.com/lexv2/latest/dg/streaming-progress.html#progress-complete)
    public struct PostFulfillmentStatusSpecification: Swift.Equatable {
        /// A list of conditional branches to evaluate after the fulfillment code hook throws an exception or returns with the State field of the Intent object set to Failed.
        public var failureConditional: LexModelsV2ClientTypes.ConditionalSpecification?
        /// Specifies the next step the bot runs after the fulfillment code hook throws an exception or returns with the State field of the Intent object set to Failed.
        public var failureNextStep: LexModelsV2ClientTypes.DialogState?
        /// Specifies a list of message groups that Amazon Lex uses to respond the user input.
        public var failureResponse: LexModelsV2ClientTypes.ResponseSpecification?
        /// A list of conditional branches to evaluate after the fulfillment code hook finishes successfully.
        public var successConditional: LexModelsV2ClientTypes.ConditionalSpecification?
        /// Specifies the next step in the conversation that Amazon Lex invokes when the fulfillment code hook completes successfully.
        public var successNextStep: LexModelsV2ClientTypes.DialogState?
        /// Specifies a list of message groups that Amazon Lex uses to respond the user input.
        public var successResponse: LexModelsV2ClientTypes.ResponseSpecification?
        /// A list of conditional branches to evaluate if the fulfillment code hook times out.
        public var timeoutConditional: LexModelsV2ClientTypes.ConditionalSpecification?
        /// Specifies the next step that the bot runs when the fulfillment code hook times out.
        public var timeoutNextStep: LexModelsV2ClientTypes.DialogState?
        /// Specifies a list of message groups that Amazon Lex uses to respond the user input.
        public var timeoutResponse: LexModelsV2ClientTypes.ResponseSpecification?

        public init(
            failureConditional: LexModelsV2ClientTypes.ConditionalSpecification? = nil,
            failureNextStep: LexModelsV2ClientTypes.DialogState? = nil,
            failureResponse: LexModelsV2ClientTypes.ResponseSpecification? = nil,
            successConditional: LexModelsV2ClientTypes.ConditionalSpecification? = nil,
            successNextStep: LexModelsV2ClientTypes.DialogState? = nil,
            successResponse: LexModelsV2ClientTypes.ResponseSpecification? = nil,
            timeoutConditional: LexModelsV2ClientTypes.ConditionalSpecification? = nil,
            timeoutNextStep: LexModelsV2ClientTypes.DialogState? = nil,
            timeoutResponse: LexModelsV2ClientTypes.ResponseSpecification? = nil
        )
        {
            self.failureConditional = failureConditional
            self.failureNextStep = failureNextStep
            self.failureResponse = failureResponse
            self.successConditional = successConditional
            self.successNextStep = successNextStep
            self.successResponse = successResponse
            self.timeoutConditional = timeoutConditional
            self.timeoutNextStep = timeoutNextStep
            self.timeoutResponse = timeoutResponse
        }
    }

}

extension PreconditionFailedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PreconditionFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Your request couldn't be completed because one or more request fields aren't valid. Check the fields in your request and try again.
public struct PreconditionFailedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PreconditionFailedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct PreconditionFailedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PreconditionFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LexModelsV2ClientTypes.Principal: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case service
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let service = self.service {
            try encodeContainer.encode(service, forKey: .service)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .service)
        service = serviceDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// The IAM principal that you allowing or denying access to an Amazon Lex action. You must provide a service or an arn, but not both in the same statement. For more information, see [ AWS JSON policy elements: Principal ](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_principal.html).
    public struct Principal: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the principal.
        public var arn: Swift.String?
        /// The name of the Amazon Web Services service that should allowed or denied access to an Amazon Lex action.
        public var service: Swift.String?

        public init(
            arn: Swift.String? = nil,
            service: Swift.String? = nil
        )
        {
            self.arn = arn
            self.service = service
        }
    }

}

extension LexModelsV2ClientTypes {
    /// The attempt name of attempts of a prompt.
    public enum PromptAttempt: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case initial
        case retry1
        case retry2
        case retry3
        case retry4
        case retry5
        case sdkUnknown(Swift.String)

        public static var allCases: [PromptAttempt] {
            return [
                .initial,
                .retry1,
                .retry2,
                .retry3,
                .retry4,
                .retry5,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .initial: return "Initial"
            case .retry1: return "Retry1"
            case .retry2: return "Retry2"
            case .retry3: return "Retry3"
            case .retry4: return "Retry4"
            case .retry5: return "Retry5"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PromptAttempt(rawValue: rawValue) ?? PromptAttempt.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.PromptAttemptSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowInterrupt
        case allowedInputTypes
        case audioAndDTMFInputSpecification
        case textInputSpecification
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowInterrupt = self.allowInterrupt {
            try encodeContainer.encode(allowInterrupt, forKey: .allowInterrupt)
        }
        if let allowedInputTypes = self.allowedInputTypes {
            try encodeContainer.encode(allowedInputTypes, forKey: .allowedInputTypes)
        }
        if let audioAndDTMFInputSpecification = self.audioAndDTMFInputSpecification {
            try encodeContainer.encode(audioAndDTMFInputSpecification, forKey: .audioAndDTMFInputSpecification)
        }
        if let textInputSpecification = self.textInputSpecification {
            try encodeContainer.encode(textInputSpecification, forKey: .textInputSpecification)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowInterruptDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowInterrupt)
        allowInterrupt = allowInterruptDecoded
        let allowedInputTypesDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AllowedInputTypes.self, forKey: .allowedInputTypes)
        allowedInputTypes = allowedInputTypesDecoded
        let audioAndDTMFInputSpecificationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AudioAndDTMFInputSpecification.self, forKey: .audioAndDTMFInputSpecification)
        audioAndDTMFInputSpecification = audioAndDTMFInputSpecificationDecoded
        let textInputSpecificationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TextInputSpecification.self, forKey: .textInputSpecification)
        textInputSpecification = textInputSpecificationDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Specifies the settings on a prompt attempt.
    public struct PromptAttemptSpecification: Swift.Equatable {
        /// Indicates whether the user can interrupt a speech prompt attempt from the bot.
        public var allowInterrupt: Swift.Bool?
        /// Indicates the allowed input types of the prompt attempt.
        /// This member is required.
        public var allowedInputTypes: LexModelsV2ClientTypes.AllowedInputTypes?
        /// Specifies the settings on audio and DTMF input.
        public var audioAndDTMFInputSpecification: LexModelsV2ClientTypes.AudioAndDTMFInputSpecification?
        /// Specifies the settings on text input.
        public var textInputSpecification: LexModelsV2ClientTypes.TextInputSpecification?

        public init(
            allowInterrupt: Swift.Bool? = nil,
            allowedInputTypes: LexModelsV2ClientTypes.AllowedInputTypes? = nil,
            audioAndDTMFInputSpecification: LexModelsV2ClientTypes.AudioAndDTMFInputSpecification? = nil,
            textInputSpecification: LexModelsV2ClientTypes.TextInputSpecification? = nil
        )
        {
            self.allowInterrupt = allowInterrupt
            self.allowedInputTypes = allowedInputTypes
            self.audioAndDTMFInputSpecification = audioAndDTMFInputSpecification
            self.textInputSpecification = textInputSpecification
        }
    }

}

extension LexModelsV2ClientTypes.PromptSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowInterrupt
        case maxRetries
        case messageGroups
        case messageSelectionStrategy
        case promptAttemptsSpecification
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowInterrupt = self.allowInterrupt {
            try encodeContainer.encode(allowInterrupt, forKey: .allowInterrupt)
        }
        if let maxRetries = self.maxRetries {
            try encodeContainer.encode(maxRetries, forKey: .maxRetries)
        }
        if let messageGroups = messageGroups {
            var messageGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .messageGroups)
            for messagegroup0 in messageGroups {
                try messageGroupsContainer.encode(messagegroup0)
            }
        }
        if let messageSelectionStrategy = self.messageSelectionStrategy {
            try encodeContainer.encode(messageSelectionStrategy.rawValue, forKey: .messageSelectionStrategy)
        }
        if let promptAttemptsSpecification = promptAttemptsSpecification {
            var promptAttemptsSpecificationContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .promptAttemptsSpecification)
            for (dictKey0, promptAttemptsSpecificationMap0) in promptAttemptsSpecification {
                try promptAttemptsSpecificationContainer.encode(promptAttemptsSpecificationMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageGroupsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.MessageGroup?].self, forKey: .messageGroups)
        var messageGroupsDecoded0:[LexModelsV2ClientTypes.MessageGroup]? = nil
        if let messageGroupsContainer = messageGroupsContainer {
            messageGroupsDecoded0 = [LexModelsV2ClientTypes.MessageGroup]()
            for structure0 in messageGroupsContainer {
                if let structure0 = structure0 {
                    messageGroupsDecoded0?.append(structure0)
                }
            }
        }
        messageGroups = messageGroupsDecoded0
        let maxRetriesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRetries)
        maxRetries = maxRetriesDecoded
        let allowInterruptDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowInterrupt)
        allowInterrupt = allowInterruptDecoded
        let messageSelectionStrategyDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.MessageSelectionStrategy.self, forKey: .messageSelectionStrategy)
        messageSelectionStrategy = messageSelectionStrategyDecoded
        let promptAttemptsSpecificationContainer = try containerValues.decodeIfPresent([Swift.String: LexModelsV2ClientTypes.PromptAttemptSpecification?].self, forKey: .promptAttemptsSpecification)
        var promptAttemptsSpecificationDecoded0: [Swift.String:LexModelsV2ClientTypes.PromptAttemptSpecification]? = nil
        if let promptAttemptsSpecificationContainer = promptAttemptsSpecificationContainer {
            promptAttemptsSpecificationDecoded0 = [Swift.String:LexModelsV2ClientTypes.PromptAttemptSpecification]()
            for (key0, promptattemptspecification0) in promptAttemptsSpecificationContainer {
                if let promptattemptspecification0 = promptattemptspecification0 {
                    promptAttemptsSpecificationDecoded0?[key0] = promptattemptspecification0
                }
            }
        }
        promptAttemptsSpecification = promptAttemptsSpecificationDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// Specifies a list of message groups that Amazon Lex sends to a user to elicit a response.
    public struct PromptSpecification: Swift.Equatable {
        /// Indicates whether the user can interrupt a speech prompt from the bot.
        public var allowInterrupt: Swift.Bool?
        /// The maximum number of times the bot tries to elicit a response from the user using this prompt.
        /// This member is required.
        public var maxRetries: Swift.Int?
        /// A collection of messages that Amazon Lex can send to the user. Amazon Lex chooses the actual message to send at runtime.
        /// This member is required.
        public var messageGroups: [LexModelsV2ClientTypes.MessageGroup]?
        /// Indicates how a message is selected from a message group among retries.
        public var messageSelectionStrategy: LexModelsV2ClientTypes.MessageSelectionStrategy?
        /// Specifies the advanced settings on each attempt of the prompt.
        public var promptAttemptsSpecification: [Swift.String:LexModelsV2ClientTypes.PromptAttemptSpecification]?

        public init(
            allowInterrupt: Swift.Bool? = nil,
            maxRetries: Swift.Int? = nil,
            messageGroups: [LexModelsV2ClientTypes.MessageGroup]? = nil,
            messageSelectionStrategy: LexModelsV2ClientTypes.MessageSelectionStrategy? = nil,
            promptAttemptsSpecification: [Swift.String:LexModelsV2ClientTypes.PromptAttemptSpecification]? = nil
        )
        {
            self.allowInterrupt = allowInterrupt
            self.maxRetries = maxRetries
            self.messageGroups = messageGroups
            self.messageSelectionStrategy = messageSelectionStrategy
            self.promptAttemptsSpecification = promptAttemptsSpecification
        }
    }

}

extension LexModelsV2ClientTypes.RecommendedIntentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case intentId
        case intentName
        case sampleUtterancesCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let intentId = self.intentId {
            try encodeContainer.encode(intentId, forKey: .intentId)
        }
        if let intentName = self.intentName {
            try encodeContainer.encode(intentName, forKey: .intentName)
        }
        if let sampleUtterancesCount = self.sampleUtterancesCount {
            try encodeContainer.encode(sampleUtterancesCount, forKey: .sampleUtterancesCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intentId)
        intentId = intentIdDecoded
        let intentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intentName)
        intentName = intentNameDecoded
        let sampleUtterancesCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sampleUtterancesCount)
        sampleUtterancesCount = sampleUtterancesCountDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// An object that contains a summary of a recommended intent.
    public struct RecommendedIntentSummary: Swift.Equatable {
        /// The unique identifier of a recommended intent associated with the bot recommendation.
        public var intentId: Swift.String?
        /// The name of a recommended intent associated with the bot recommendation.
        public var intentName: Swift.String?
        /// The count of sample utterances of a recommended intent that is associated with a bot recommendation.
        public var sampleUtterancesCount: Swift.Int?

        public init(
            intentId: Swift.String? = nil,
            intentName: Swift.String? = nil,
            sampleUtterancesCount: Swift.Int? = nil
        )
        {
            self.intentId = intentId
            self.intentName = intentName
            self.sampleUtterancesCount = sampleUtterancesCount
        }
    }

}

extension LexModelsV2ClientTypes.RelativeAggregationDuration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timeDimension
        case timeValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timeDimension = self.timeDimension {
            try encodeContainer.encode(timeDimension.rawValue, forKey: .timeDimension)
        }
        if timeValue != 0 {
            try encodeContainer.encode(timeValue, forKey: .timeValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeDimensionDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TimeDimension.self, forKey: .timeDimension)
        timeDimension = timeDimensionDecoded
        let timeValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeValue) ?? 0
        timeValue = timeValueDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Specifies the time window that utterance statistics are returned for. The time window is always relative to the last time that the that utterances were aggregated. For example, if the ListAggregatedUtterances operation is called at 1600, the time window is set to 1 hour, and the last refresh time was 1530, only utterances made between 1430 and 1530 are returned. You can choose the time window that statistics should be returned for.
    ///
    /// * Hours - You can request utterance statistics for 1, 3, 6, 12, or 24 hour time windows. Statistics are refreshed every half hour for 1 hour time windows, and hourly for the other time windows.
    ///
    /// * Days - You can request utterance statistics for 3 days. Statistics are refreshed every 6 hours.
    ///
    /// * Weeks - You can see statistics for one or two weeks. Statistics are refreshed every 12 hours for one week time windows, and once per day for two week time windows.
    public struct RelativeAggregationDuration: Swift.Equatable {
        /// The type of time period that the timeValue field represents.
        /// This member is required.
        public var timeDimension: LexModelsV2ClientTypes.TimeDimension?
        /// The period of the time window to gather statistics for. The valid value depends on the setting of the timeDimension field.
        ///
        /// * Hours - 1/3/6/12/24
        ///
        /// * Days - 3
        ///
        /// * Weeks - 1/2
        /// This member is required.
        public var timeValue: Swift.Int

        public init(
            timeDimension: LexModelsV2ClientTypes.TimeDimension? = nil,
            timeValue: Swift.Int = 0
        )
        {
            self.timeDimension = timeDimension
            self.timeValue = timeValue
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You asked to describe a resource that doesn't exist. Check the resource that you are requesting and try again.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LexModelsV2ClientTypes.ResponseSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowInterrupt
        case messageGroups
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowInterrupt = self.allowInterrupt {
            try encodeContainer.encode(allowInterrupt, forKey: .allowInterrupt)
        }
        if let messageGroups = messageGroups {
            var messageGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .messageGroups)
            for messagegroup0 in messageGroups {
                try messageGroupsContainer.encode(messagegroup0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageGroupsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.MessageGroup?].self, forKey: .messageGroups)
        var messageGroupsDecoded0:[LexModelsV2ClientTypes.MessageGroup]? = nil
        if let messageGroupsContainer = messageGroupsContainer {
            messageGroupsDecoded0 = [LexModelsV2ClientTypes.MessageGroup]()
            for structure0 in messageGroupsContainer {
                if let structure0 = structure0 {
                    messageGroupsDecoded0?.append(structure0)
                }
            }
        }
        messageGroups = messageGroupsDecoded0
        let allowInterruptDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowInterrupt)
        allowInterrupt = allowInterruptDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Specifies a list of message groups that Amazon Lex uses to respond the user input.
    public struct ResponseSpecification: Swift.Equatable {
        /// Indicates whether the user can interrupt a speech response from Amazon Lex.
        public var allowInterrupt: Swift.Bool?
        /// A collection of responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime.
        /// This member is required.
        public var messageGroups: [LexModelsV2ClientTypes.MessageGroup]?

        public init(
            allowInterrupt: Swift.Bool? = nil,
            messageGroups: [LexModelsV2ClientTypes.MessageGroup]? = nil
        )
        {
            self.allowInterrupt = allowInterrupt
            self.messageGroups = messageGroups
        }
    }

}

extension LexModelsV2ClientTypes.RuntimeHintDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case runtimeHintValues
        case subSlotHints
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let runtimeHintValues = runtimeHintValues {
            var runtimeHintValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .runtimeHintValues)
            for runtimehintvalue0 in runtimeHintValues {
                try runtimeHintValuesContainer.encode(runtimehintvalue0)
            }
        }
        if let subSlotHints = subSlotHints {
            var subSlotHintsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .subSlotHints)
            for (dictKey0, slotHintsSlotMap0) in subSlotHints {
                try subSlotHintsContainer.encode(slotHintsSlotMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runtimeHintValuesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.RuntimeHintValue?].self, forKey: .runtimeHintValues)
        var runtimeHintValuesDecoded0:[LexModelsV2ClientTypes.RuntimeHintValue]? = nil
        if let runtimeHintValuesContainer = runtimeHintValuesContainer {
            runtimeHintValuesDecoded0 = [LexModelsV2ClientTypes.RuntimeHintValue]()
            for structure0 in runtimeHintValuesContainer {
                if let structure0 = structure0 {
                    runtimeHintValuesDecoded0?.append(structure0)
                }
            }
        }
        runtimeHintValues = runtimeHintValuesDecoded0
        let subSlotHintsContainer = try containerValues.decodeIfPresent([Swift.String: LexModelsV2ClientTypes.RuntimeHintDetails?].self, forKey: .subSlotHints)
        var subSlotHintsDecoded0: [Swift.String:LexModelsV2ClientTypes.RuntimeHintDetails]? = nil
        if let subSlotHintsContainer = subSlotHintsContainer {
            subSlotHintsDecoded0 = [Swift.String:LexModelsV2ClientTypes.RuntimeHintDetails]()
            for (key0, runtimehintdetails0) in subSlotHintsContainer {
                if let runtimehintdetails0 = runtimehintdetails0 {
                    subSlotHintsDecoded0?[key0] = runtimehintdetails0
                }
            }
        }
        subSlotHints = subSlotHintsDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// Provides an array of phrases that should be given preference when resolving values for a slot.
    public struct RuntimeHintDetails: Swift.Equatable {
        /// One or more strings that Amazon Lex should look for in the input to the bot. Each phrase is given preference when deciding on slot values.
        public var runtimeHintValues: [LexModelsV2ClientTypes.RuntimeHintValue]?
        /// A map of constituent sub slot names inside a composite slot in the intent and the phrases that should be added for each sub slot. Inside each composite slot hints, this structure provides a mechanism to add granular sub slot phrases. Only sub slot hints are supported for composite slots. The intent name, composite slot name and the constituent sub slot names must exist.
        public var subSlotHints: [Swift.String:LexModelsV2ClientTypes.RuntimeHintDetails]?

        public init(
            runtimeHintValues: [LexModelsV2ClientTypes.RuntimeHintValue]? = nil,
            subSlotHints: [Swift.String:LexModelsV2ClientTypes.RuntimeHintDetails]? = nil
        )
        {
            self.runtimeHintValues = runtimeHintValues
            self.subSlotHints = subSlotHints
        }
    }

}

extension LexModelsV2ClientTypes.RuntimeHintValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phrase
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let phrase = self.phrase {
            try encodeContainer.encode(phrase, forKey: .phrase)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phraseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phrase)
        phrase = phraseDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Provides the phrase that Amazon Lex should look for in the user's input to the bot.
    public struct RuntimeHintValue: Swift.Equatable {
        /// The phrase that Amazon Lex should look for in the user's input to the bot.
        /// This member is required.
        public var phrase: Swift.String?

        public init(
            phrase: Swift.String? = nil
        )
        {
            self.phrase = phrase
        }
    }

}

extension LexModelsV2ClientTypes.RuntimeHints: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case slotHints
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let slotHints = slotHints {
            var slotHintsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .slotHints)
            for (dictKey0, slotHintsIntentMap0) in slotHints {
                var slotHintsIntentMap0Container = slotHintsContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key(stringValue: dictKey0))
                for (dictKey1, slotHintsSlotMap1) in slotHintsIntentMap0 {
                    try slotHintsIntentMap0Container.encode(slotHintsSlotMap1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let slotHintsContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: LexModelsV2ClientTypes.RuntimeHintDetails?]?].self, forKey: .slotHints)
        var slotHintsDecoded0: [Swift.String:[Swift.String:LexModelsV2ClientTypes.RuntimeHintDetails]]? = nil
        if let slotHintsContainer = slotHintsContainer {
            slotHintsDecoded0 = [Swift.String:[Swift.String:LexModelsV2ClientTypes.RuntimeHintDetails]]()
            for (key0, slothintsslotmap0) in slotHintsContainer {
                var slothintsslotmap0Decoded0: [Swift.String: LexModelsV2ClientTypes.RuntimeHintDetails]? = nil
                if let slothintsslotmap0 = slothintsslotmap0 {
                    slothintsslotmap0Decoded0 = [Swift.String: LexModelsV2ClientTypes.RuntimeHintDetails]()
                    for (key1, runtimehintdetails1) in slothintsslotmap0 {
                        if let runtimehintdetails1 = runtimehintdetails1 {
                            slothintsslotmap0Decoded0?[key1] = runtimehintdetails1
                        }
                    }
                }
                slotHintsDecoded0?[key0] = slothintsslotmap0Decoded0
            }
        }
        slotHints = slotHintsDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// You can provide Amazon Lex with hints to the phrases that a customer is likely to use for a slot. When a slot with hints is resolved, the phrases in the runtime hints are preferred in the resolution. You can provide hints for a maximum of 100 intents. You can provide a maximum of 100 slots. Before you can use runtime hints with an existing bot, you must first rebuild the bot. For more information, see [Using runtime hints to improve recognition of slot values](https://docs.aws.amazon.com/lexv2/latest/dg/using-hints.html).
    public struct RuntimeHints: Swift.Equatable {
        /// A list of the slots in the intent that should have runtime hints added, and the phrases that should be added for each slot. The first level of the slotHints map is the name of the intent. The second level is the name of the slot within the intent. For more information, see [Using hints to improve accuracy](https://docs.aws.amazon.com/lexv2/latest/dg/using-hints.html). The intent name and slot name must exist.
        public var slotHints: [Swift.String:[Swift.String:LexModelsV2ClientTypes.RuntimeHintDetails]]?

        public init(
            slotHints: [Swift.String:[Swift.String:LexModelsV2ClientTypes.RuntimeHintDetails]]? = nil
        )
        {
            self.slotHints = slotHints
        }
    }

}

extension LexModelsV2ClientTypes.S3BucketLogDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyArn
        case logPrefix
        case s3BucketArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let logPrefix = self.logPrefix {
            try encodeContainer.encode(logPrefix, forKey: .logPrefix)
        }
        if let s3BucketArn = self.s3BucketArn {
            try encodeContainer.encode(s3BucketArn, forKey: .s3BucketArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let s3BucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketArn)
        s3BucketArn = s3BucketArnDecoded
        let logPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logPrefix)
        logPrefix = logPrefixDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Specifies an Amazon S3 bucket for logging audio conversations
    public struct S3BucketLogDestination: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of an Amazon Web Services Key Management Service (KMS) key for encrypting audio log files stored in an S3 bucket.
        public var kmsKeyArn: Swift.String?
        /// The S3 prefix to assign to audio log files.
        /// This member is required.
        public var logPrefix: Swift.String?
        /// The Amazon Resource Name (ARN) of an Amazon S3 bucket where audio log files are stored.
        /// This member is required.
        public var s3BucketArn: Swift.String?

        public init(
            kmsKeyArn: Swift.String? = nil,
            logPrefix: Swift.String? = nil,
            s3BucketArn: Swift.String? = nil
        )
        {
            self.kmsKeyArn = kmsKeyArn
            self.logPrefix = logPrefix
            self.s3BucketArn = s3BucketArn
        }
    }

}

extension LexModelsV2ClientTypes.S3BucketTranscriptSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyArn
        case pathFormat
        case s3BucketName
        case transcriptFilter
        case transcriptFormat
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let pathFormat = self.pathFormat {
            try encodeContainer.encode(pathFormat, forKey: .pathFormat)
        }
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let transcriptFilter = self.transcriptFilter {
            try encodeContainer.encode(transcriptFilter, forKey: .transcriptFilter)
        }
        if let transcriptFormat = self.transcriptFormat {
            try encodeContainer.encode(transcriptFormat.rawValue, forKey: .transcriptFormat)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let pathFormatDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.PathFormat.self, forKey: .pathFormat)
        pathFormat = pathFormatDecoded
        let transcriptFormatDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TranscriptFormat.self, forKey: .transcriptFormat)
        transcriptFormat = transcriptFormatDecoded
        let transcriptFilterDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TranscriptFilter.self, forKey: .transcriptFilter)
        transcriptFilter = transcriptFilterDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// The object representing the Amazon S3 bucket containing the transcript, as well as the associated metadata.
    public struct S3BucketTranscriptSource: Swift.Equatable {
        /// The ARN of the KMS key that customer use to encrypt their Amazon S3 bucket. Only use this field if your bucket is encrypted using a customer managed KMS key.
        public var kmsKeyArn: Swift.String?
        /// The object that contains a path format that will be applied when Amazon Lex reads the transcript file in the bucket you provide. Specify this object if you only want Lex to read a subset of files in your Amazon S3 bucket.
        public var pathFormat: LexModelsV2ClientTypes.PathFormat?
        /// The name of the bucket containing the transcript and the associated metadata.
        /// This member is required.
        public var s3BucketName: Swift.String?
        /// The object that contains the filter which will be applied when Amazon Lex reads through the Amazon S3 bucket. Specify this object if you want Amazon Lex to read only a subset of the Amazon S3 bucket based on the filter you provide.
        public var transcriptFilter: LexModelsV2ClientTypes.TranscriptFilter?
        /// The format of the transcript content. Currently, Genie only supports the Amazon Lex transcript format.
        /// This member is required.
        public var transcriptFormat: LexModelsV2ClientTypes.TranscriptFormat?

        public init(
            kmsKeyArn: Swift.String? = nil,
            pathFormat: LexModelsV2ClientTypes.PathFormat? = nil,
            s3BucketName: Swift.String? = nil,
            transcriptFilter: LexModelsV2ClientTypes.TranscriptFilter? = nil,
            transcriptFormat: LexModelsV2ClientTypes.TranscriptFormat? = nil
        )
        {
            self.kmsKeyArn = kmsKeyArn
            self.pathFormat = pathFormat
            self.s3BucketName = s3BucketName
            self.transcriptFilter = transcriptFilter
            self.transcriptFormat = transcriptFormat
        }
    }

}

extension LexModelsV2ClientTypes.SSMLMessage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Defines a Speech Synthesis Markup Language (SSML) prompt.
    public struct SSMLMessage: Swift.Equatable {
        /// The SSML text that defines the prompt.
        /// This member is required.
        public var value: Swift.String?

        public init(
            value: Swift.String? = nil
        )
        {
            self.value = value
        }
    }

}

extension LexModelsV2ClientTypes.SampleUtterance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case utterance
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let utterance = self.utterance {
            try encodeContainer.encode(utterance, forKey: .utterance)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let utteranceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .utterance)
        utterance = utteranceDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// A sample utterance that invokes an intent or respond to a slot elicitation prompt.
    public struct SampleUtterance: Swift.Equatable {
        /// The sample utterance that Amazon Lex uses to build its machine-learning model to recognize intents.
        /// This member is required.
        public var utterance: Swift.String?

        public init(
            utterance: Swift.String? = nil
        )
        {
            self.utterance = utterance
        }
    }

}

extension LexModelsV2ClientTypes.SampleValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Defines one of the values for a slot type.
    public struct SampleValue: Swift.Equatable {
        /// The value that can be used for a slot type.
        /// This member is required.
        public var value: Swift.String?

        public init(
            value: Swift.String? = nil
        )
        {
            self.value = value
        }
    }

}

extension SearchAssociatedTranscriptsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextIndex
        case searchOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for associatedtranscriptfilter0 in filters {
                try filtersContainer.encode(associatedtranscriptfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextIndex = self.nextIndex {
            try encodeContainer.encode(nextIndex, forKey: .nextIndex)
        }
        if let searchOrder = self.searchOrder {
            try encodeContainer.encode(searchOrder.rawValue, forKey: .searchOrder)
        }
    }
}

extension SearchAssociatedTranscriptsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botVersion = botVersion else {
            return nil
        }
        guard let localeId = localeId else {
            return nil
        }
        guard let botRecommendationId = botRecommendationId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botversions/\(botVersion.urlPercentEncoding())/botlocales/\(localeId.urlPercentEncoding())/botrecommendations/\(botRecommendationId.urlPercentEncoding())/associatedtranscripts"
    }
}

public struct SearchAssociatedTranscriptsInput: Swift.Equatable {
    /// The unique identifier of the bot associated with the transcripts that you are searching.
    /// This member is required.
    public var botId: Swift.String?
    /// The unique identifier of the bot recommendation associated with the transcripts to search.
    /// This member is required.
    public var botRecommendationId: Swift.String?
    /// The version of the bot containing the transcripts that you are searching.
    /// This member is required.
    public var botVersion: Swift.String?
    /// A list of filter objects.
    /// This member is required.
    public var filters: [LexModelsV2ClientTypes.AssociatedTranscriptFilter]?
    /// The identifier of the language and locale of the transcripts to search. The string must match one of the supported locales. For more information, see [Supported languages](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html)
    /// This member is required.
    public var localeId: Swift.String?
    /// The maximum number of bot recommendations to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
    public var maxResults: Swift.Int?
    /// If the response from the SearchAssociatedTranscriptsRequest operation contains more results than specified in the maxResults parameter, an index is returned in the response. Use that index in the nextIndex parameter to return the next page of results.
    public var nextIndex: Swift.Int?
    /// How SearchResults are ordered. Valid values are Ascending or Descending. The default is Descending.
    public var searchOrder: LexModelsV2ClientTypes.SearchOrder?

    public init(
        botId: Swift.String? = nil,
        botRecommendationId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        filters: [LexModelsV2ClientTypes.AssociatedTranscriptFilter]? = nil,
        localeId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextIndex: Swift.Int? = nil,
        searchOrder: LexModelsV2ClientTypes.SearchOrder? = nil
    )
    {
        self.botId = botId
        self.botRecommendationId = botRecommendationId
        self.botVersion = botVersion
        self.filters = filters
        self.localeId = localeId
        self.maxResults = maxResults
        self.nextIndex = nextIndex
        self.searchOrder = searchOrder
    }
}

struct SearchAssociatedTranscriptsInputBody: Swift.Equatable {
    let searchOrder: LexModelsV2ClientTypes.SearchOrder?
    let filters: [LexModelsV2ClientTypes.AssociatedTranscriptFilter]?
    let maxResults: Swift.Int?
    let nextIndex: Swift.Int?
}

extension SearchAssociatedTranscriptsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextIndex
        case searchOrder
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let searchOrderDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SearchOrder.self, forKey: .searchOrder)
        searchOrder = searchOrderDecoded
        let filtersContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AssociatedTranscriptFilter?].self, forKey: .filters)
        var filtersDecoded0:[LexModelsV2ClientTypes.AssociatedTranscriptFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LexModelsV2ClientTypes.AssociatedTranscriptFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextIndexDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .nextIndex)
        nextIndex = nextIndexDecoded
    }
}

enum SearchAssociatedTranscriptsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SearchAssociatedTranscriptsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchAssociatedTranscriptsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.associatedTranscripts = output.associatedTranscripts
            self.botId = output.botId
            self.botRecommendationId = output.botRecommendationId
            self.botVersion = output.botVersion
            self.localeId = output.localeId
            self.nextIndex = output.nextIndex
            self.totalResults = output.totalResults
        } else {
            self.associatedTranscripts = nil
            self.botId = nil
            self.botRecommendationId = nil
            self.botVersion = nil
            self.localeId = nil
            self.nextIndex = nil
            self.totalResults = nil
        }
    }
}

public struct SearchAssociatedTranscriptsOutputResponse: Swift.Equatable {
    /// The object that contains the associated transcript that meet the criteria you specified.
    public var associatedTranscripts: [LexModelsV2ClientTypes.AssociatedTranscript]?
    /// The unique identifier of the bot associated with the transcripts that you are searching.
    public var botId: Swift.String?
    /// The unique identifier of the bot recommendation associated with the transcripts to search.
    public var botRecommendationId: Swift.String?
    /// The version of the bot containing the transcripts that you are searching.
    public var botVersion: Swift.String?
    /// The identifier of the language and locale of the transcripts to search. The string must match one of the supported locales. For more information, see [Supported languages](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html)
    public var localeId: Swift.String?
    /// A index that indicates whether there are more results to return in a response to the SearchAssociatedTranscripts operation. If the nextIndex field is present, you send the contents as the nextIndex parameter of a SearchAssociatedTranscriptsRequest operation to get the next page of results.
    public var nextIndex: Swift.Int?
    /// The total number of transcripts returned by the search.
    public var totalResults: Swift.Int?

    public init(
        associatedTranscripts: [LexModelsV2ClientTypes.AssociatedTranscript]? = nil,
        botId: Swift.String? = nil,
        botRecommendationId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        localeId: Swift.String? = nil,
        nextIndex: Swift.Int? = nil,
        totalResults: Swift.Int? = nil
    )
    {
        self.associatedTranscripts = associatedTranscripts
        self.botId = botId
        self.botRecommendationId = botRecommendationId
        self.botVersion = botVersion
        self.localeId = localeId
        self.nextIndex = nextIndex
        self.totalResults = totalResults
    }
}

struct SearchAssociatedTranscriptsOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let botVersion: Swift.String?
    let localeId: Swift.String?
    let botRecommendationId: Swift.String?
    let nextIndex: Swift.Int?
    let associatedTranscripts: [LexModelsV2ClientTypes.AssociatedTranscript]?
    let totalResults: Swift.Int?
}

extension SearchAssociatedTranscriptsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedTranscripts
        case botId
        case botRecommendationId
        case botVersion
        case localeId
        case nextIndex
        case totalResults
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let botRecommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botRecommendationId)
        botRecommendationId = botRecommendationIdDecoded
        let nextIndexDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .nextIndex)
        nextIndex = nextIndexDecoded
        let associatedTranscriptsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.AssociatedTranscript?].self, forKey: .associatedTranscripts)
        var associatedTranscriptsDecoded0:[LexModelsV2ClientTypes.AssociatedTranscript]? = nil
        if let associatedTranscriptsContainer = associatedTranscriptsContainer {
            associatedTranscriptsDecoded0 = [LexModelsV2ClientTypes.AssociatedTranscript]()
            for structure0 in associatedTranscriptsContainer {
                if let structure0 = structure0 {
                    associatedTranscriptsDecoded0?.append(structure0)
                }
            }
        }
        associatedTranscripts = associatedTranscriptsDecoded0
        let totalResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalResults)
        totalResults = totalResultsDecoded
    }
}

extension LexModelsV2ClientTypes {
    public enum SearchOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchOrder] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "Ascending"
            case .descending: return "Descending"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SearchOrder(rawValue: rawValue) ?? SearchOrder.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.SentimentAnalysisSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectSentiment
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if detectSentiment != false {
            try encodeContainer.encode(detectSentiment, forKey: .detectSentiment)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectSentimentDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .detectSentiment) ?? false
        detectSentiment = detectSentimentDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Determines whether Amazon Lex will use Amazon Comprehend to detect the sentiment of user utterances.
    public struct SentimentAnalysisSettings: Swift.Equatable {
        /// Sets whether Amazon Lex uses Amazon Comprehend to detect the sentiment of user utterances.
        /// This member is required.
        public var detectSentiment: Swift.Bool

        public init(
            detectSentiment: Swift.Bool = false
        )
        {
            self.detectSentiment = detectSentiment
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have reached a quota for your bot.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LexModelsV2ClientTypes.SessionDataSortBy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case order
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let order = self.order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsSessionSortByName.self, forKey: .name)
        name = nameDecoded
        let orderDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsSortOrder.self, forKey: .order)
        order = orderDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// An object specifying the measure and method by which to sort the session analytics data.
    public struct SessionDataSortBy: Swift.Equatable {
        /// The measure by which to sort the session analytics data.
        ///
        /// * conversationStartTime – The date and time when the conversation began. A conversation is defined as a unique combination of a sessionId and an originatingRequestId.
        ///
        /// * numberOfTurns – The number of turns that the session took.
        ///
        /// * conversationDurationSeconds – The duration of the conversation in seconds.
        /// This member is required.
        public var name: LexModelsV2ClientTypes.AnalyticsSessionSortByName?
        /// Specifies whether to sort the results in ascending or descending order.
        /// This member is required.
        public var order: LexModelsV2ClientTypes.AnalyticsSortOrder?

        public init(
            name: LexModelsV2ClientTypes.AnalyticsSessionSortByName? = nil,
            order: LexModelsV2ClientTypes.AnalyticsSortOrder? = nil
        )
        {
            self.name = name
            self.order = order
        }
    }

}

extension LexModelsV2ClientTypes.SessionSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botAliasId
        case botVersion
        case channel
        case conversationDurationSeconds
        case conversationEndState
        case conversationEndTime
        case conversationStartTime
        case invokedIntentSamples
        case localeId
        case mode
        case numberOfTurns
        case originatingRequestId
        case sessionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botAliasId = self.botAliasId {
            try encodeContainer.encode(botAliasId, forKey: .botAliasId)
        }
        if let botVersion = self.botVersion {
            try encodeContainer.encode(botVersion, forKey: .botVersion)
        }
        if let channel = self.channel {
            try encodeContainer.encode(channel, forKey: .channel)
        }
        if let conversationDurationSeconds = self.conversationDurationSeconds {
            try encodeContainer.encode(conversationDurationSeconds, forKey: .conversationDurationSeconds)
        }
        if let conversationEndState = self.conversationEndState {
            try encodeContainer.encode(conversationEndState.rawValue, forKey: .conversationEndState)
        }
        if let conversationEndTime = self.conversationEndTime {
            try encodeContainer.encodeTimestamp(conversationEndTime, format: .epochSeconds, forKey: .conversationEndTime)
        }
        if let conversationStartTime = self.conversationStartTime {
            try encodeContainer.encodeTimestamp(conversationStartTime, format: .epochSeconds, forKey: .conversationStartTime)
        }
        if let invokedIntentSamples = invokedIntentSamples {
            var invokedIntentSamplesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .invokedIntentSamples)
            for invokedintentsample0 in invokedIntentSamples {
                try invokedIntentSamplesContainer.encode(invokedintentsample0)
            }
        }
        if let localeId = self.localeId {
            try encodeContainer.encode(localeId, forKey: .localeId)
        }
        if let mode = self.mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let numberOfTurns = self.numberOfTurns {
            try encodeContainer.encode(numberOfTurns, forKey: .numberOfTurns)
        }
        if let originatingRequestId = self.originatingRequestId {
            try encodeContainer.encode(originatingRequestId, forKey: .originatingRequestId)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botAliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botAliasId)
        botAliasId = botAliasIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let channelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channel)
        channel = channelDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let conversationStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .conversationStartTime)
        conversationStartTime = conversationStartTimeDecoded
        let conversationEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .conversationEndTime)
        conversationEndTime = conversationEndTimeDecoded
        let conversationDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .conversationDurationSeconds)
        conversationDurationSeconds = conversationDurationSecondsDecoded
        let conversationEndStateDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ConversationEndState.self, forKey: .conversationEndState)
        conversationEndState = conversationEndStateDecoded
        let modeDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsModality.self, forKey: .mode)
        mode = modeDecoded
        let numberOfTurnsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfTurns)
        numberOfTurns = numberOfTurnsDecoded
        let invokedIntentSamplesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.InvokedIntentSample?].self, forKey: .invokedIntentSamples)
        var invokedIntentSamplesDecoded0:[LexModelsV2ClientTypes.InvokedIntentSample]? = nil
        if let invokedIntentSamplesContainer = invokedIntentSamplesContainer {
            invokedIntentSamplesDecoded0 = [LexModelsV2ClientTypes.InvokedIntentSample]()
            for structure0 in invokedIntentSamplesContainer {
                if let structure0 = structure0 {
                    invokedIntentSamplesDecoded0?.append(structure0)
                }
            }
        }
        invokedIntentSamples = invokedIntentSamplesDecoded0
        let originatingRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originatingRequestId)
        originatingRequestId = originatingRequestIdDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// An object containing information about a specific session.
    public struct SessionSpecification: Swift.Equatable {
        /// The identifier of the alias of the bot that the session was held with.
        public var botAliasId: Swift.String?
        /// The version of the bot that the session was held with.
        public var botVersion: Swift.String?
        /// The channel that is integrated with the bot that the session was held with.
        public var channel: Swift.String?
        /// The duration of the conversation in seconds. A conversation is defined as a unique combination of a sessionId and an originatingRequestId.
        public var conversationDurationSeconds: Swift.Int?
        /// The final state of the conversation. A conversation is defined as a unique combination of a sessionId and an originatingRequestId.
        public var conversationEndState: LexModelsV2ClientTypes.ConversationEndState?
        /// The date and time when the conversation ended. A conversation is defined as a unique combination of a sessionId and an originatingRequestId.
        public var conversationEndTime: ClientRuntime.Date?
        /// The date and time when the conversation began. A conversation is defined as a unique combination of a sessionId and an originatingRequestId.
        public var conversationStartTime: ClientRuntime.Date?
        /// A list of objects containing the name of an intent that was invoked.
        public var invokedIntentSamples: [LexModelsV2ClientTypes.InvokedIntentSample]?
        /// The locale of the bot that the session was held with.
        public var localeId: Swift.String?
        /// The mode of the session. The possible values are as follows:
        ///
        /// * Speech – The session was spoken.
        ///
        /// * Text – The session was written.
        ///
        /// * DTMF – The session used a touch-tone keypad (Dual Tone Multi-Frequency).
        ///
        /// * MultiMode – The session used multiple modes.
        public var mode: LexModelsV2ClientTypes.AnalyticsModality?
        /// The number of turns that the session took.
        public var numberOfTurns: Swift.Int?
        /// The identifier of the first request in a session.
        public var originatingRequestId: Swift.String?
        /// The identifier of the session.
        public var sessionId: Swift.String?

        public init(
            botAliasId: Swift.String? = nil,
            botVersion: Swift.String? = nil,
            channel: Swift.String? = nil,
            conversationDurationSeconds: Swift.Int? = nil,
            conversationEndState: LexModelsV2ClientTypes.ConversationEndState? = nil,
            conversationEndTime: ClientRuntime.Date? = nil,
            conversationStartTime: ClientRuntime.Date? = nil,
            invokedIntentSamples: [LexModelsV2ClientTypes.InvokedIntentSample]? = nil,
            localeId: Swift.String? = nil,
            mode: LexModelsV2ClientTypes.AnalyticsModality? = nil,
            numberOfTurns: Swift.Int? = nil,
            originatingRequestId: Swift.String? = nil,
            sessionId: Swift.String? = nil
        )
        {
            self.botAliasId = botAliasId
            self.botVersion = botVersion
            self.channel = channel
            self.conversationDurationSeconds = conversationDurationSeconds
            self.conversationEndState = conversationEndState
            self.conversationEndTime = conversationEndTime
            self.conversationStartTime = conversationStartTime
            self.invokedIntentSamples = invokedIntentSamples
            self.localeId = localeId
            self.mode = mode
            self.numberOfTurns = numberOfTurns
            self.originatingRequestId = originatingRequestId
            self.sessionId = sessionId
        }
    }

}

extension LexModelsV2ClientTypes.SlotCaptureSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case captureConditional
        case captureNextStep
        case captureResponse
        case codeHook
        case elicitationCodeHook
        case failureConditional
        case failureNextStep
        case failureResponse
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let captureConditional = self.captureConditional {
            try encodeContainer.encode(captureConditional, forKey: .captureConditional)
        }
        if let captureNextStep = self.captureNextStep {
            try encodeContainer.encode(captureNextStep, forKey: .captureNextStep)
        }
        if let captureResponse = self.captureResponse {
            try encodeContainer.encode(captureResponse, forKey: .captureResponse)
        }
        if let codeHook = self.codeHook {
            try encodeContainer.encode(codeHook, forKey: .codeHook)
        }
        if let elicitationCodeHook = self.elicitationCodeHook {
            try encodeContainer.encode(elicitationCodeHook, forKey: .elicitationCodeHook)
        }
        if let failureConditional = self.failureConditional {
            try encodeContainer.encode(failureConditional, forKey: .failureConditional)
        }
        if let failureNextStep = self.failureNextStep {
            try encodeContainer.encode(failureNextStep, forKey: .failureNextStep)
        }
        if let failureResponse = self.failureResponse {
            try encodeContainer.encode(failureResponse, forKey: .failureResponse)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let captureResponseDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ResponseSpecification.self, forKey: .captureResponse)
        captureResponse = captureResponseDecoded
        let captureNextStepDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.DialogState.self, forKey: .captureNextStep)
        captureNextStep = captureNextStepDecoded
        let captureConditionalDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ConditionalSpecification.self, forKey: .captureConditional)
        captureConditional = captureConditionalDecoded
        let failureResponseDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ResponseSpecification.self, forKey: .failureResponse)
        failureResponse = failureResponseDecoded
        let failureNextStepDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.DialogState.self, forKey: .failureNextStep)
        failureNextStep = failureNextStepDecoded
        let failureConditionalDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ConditionalSpecification.self, forKey: .failureConditional)
        failureConditional = failureConditionalDecoded
        let codeHookDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.DialogCodeHookInvocationSetting.self, forKey: .codeHook)
        codeHook = codeHookDecoded
        let elicitationCodeHookDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ElicitationCodeHookInvocationSetting.self, forKey: .elicitationCodeHook)
        elicitationCodeHook = elicitationCodeHookDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Settings used when Amazon Lex successfully captures a slot value from a user.
    public struct SlotCaptureSetting: Swift.Equatable {
        /// A list of conditional branches to evaluate after the slot value is captured.
        public var captureConditional: LexModelsV2ClientTypes.ConditionalSpecification?
        /// Specifies the next step that the bot runs when the slot value is captured before the code hook times out.
        public var captureNextStep: LexModelsV2ClientTypes.DialogState?
        /// Specifies a list of message groups that Amazon Lex uses to respond the user input.
        public var captureResponse: LexModelsV2ClientTypes.ResponseSpecification?
        /// Code hook called after Amazon Lex successfully captures a slot value.
        public var codeHook: LexModelsV2ClientTypes.DialogCodeHookInvocationSetting?
        /// Code hook called when Amazon Lex doesn't capture a slot value.
        public var elicitationCodeHook: LexModelsV2ClientTypes.ElicitationCodeHookInvocationSetting?
        /// A list of conditional branches to evaluate when the slot value isn't captured.
        public var failureConditional: LexModelsV2ClientTypes.ConditionalSpecification?
        /// Specifies the next step that the bot runs when the slot value code is not recognized.
        public var failureNextStep: LexModelsV2ClientTypes.DialogState?
        /// Specifies a list of message groups that Amazon Lex uses to respond the user input.
        public var failureResponse: LexModelsV2ClientTypes.ResponseSpecification?

        public init(
            captureConditional: LexModelsV2ClientTypes.ConditionalSpecification? = nil,
            captureNextStep: LexModelsV2ClientTypes.DialogState? = nil,
            captureResponse: LexModelsV2ClientTypes.ResponseSpecification? = nil,
            codeHook: LexModelsV2ClientTypes.DialogCodeHookInvocationSetting? = nil,
            elicitationCodeHook: LexModelsV2ClientTypes.ElicitationCodeHookInvocationSetting? = nil,
            failureConditional: LexModelsV2ClientTypes.ConditionalSpecification? = nil,
            failureNextStep: LexModelsV2ClientTypes.DialogState? = nil,
            failureResponse: LexModelsV2ClientTypes.ResponseSpecification? = nil
        )
        {
            self.captureConditional = captureConditional
            self.captureNextStep = captureNextStep
            self.captureResponse = captureResponse
            self.codeHook = codeHook
            self.elicitationCodeHook = elicitationCodeHook
            self.failureConditional = failureConditional
            self.failureNextStep = failureNextStep
            self.failureResponse = failureResponse
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum SlotConstraint: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `optional`
        case `required`
        case sdkUnknown(Swift.String)

        public static var allCases: [SlotConstraint] {
            return [
                .optional,
                .required,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .optional: return "Optional"
            case .required: return "Required"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SlotConstraint(rawValue: rawValue) ?? SlotConstraint.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.SlotDefaultValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Specifies the default value to use when a user doesn't provide a value for a slot.
    public struct SlotDefaultValue: Swift.Equatable {
        /// The default value to use when a user doesn't provide a value for a slot.
        /// This member is required.
        public var defaultValue: Swift.String?

        public init(
            defaultValue: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
        }
    }

}

extension LexModelsV2ClientTypes.SlotDefaultValueSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValueList
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValueList = defaultValueList {
            var defaultValueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .defaultValueList)
            for slotdefaultvalue0 in defaultValueList {
                try defaultValueListContainer.encode(slotdefaultvalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueListContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.SlotDefaultValue?].self, forKey: .defaultValueList)
        var defaultValueListDecoded0:[LexModelsV2ClientTypes.SlotDefaultValue]? = nil
        if let defaultValueListContainer = defaultValueListContainer {
            defaultValueListDecoded0 = [LexModelsV2ClientTypes.SlotDefaultValue]()
            for structure0 in defaultValueListContainer {
                if let structure0 = structure0 {
                    defaultValueListDecoded0?.append(structure0)
                }
            }
        }
        defaultValueList = defaultValueListDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// Defines a list of values that Amazon Lex should use as the default value for a slot.
    public struct SlotDefaultValueSpecification: Swift.Equatable {
        /// A list of default values. Amazon Lex chooses the default value to use in the order that they are presented in the list.
        /// This member is required.
        public var defaultValueList: [LexModelsV2ClientTypes.SlotDefaultValue]?

        public init(
            defaultValueList: [LexModelsV2ClientTypes.SlotDefaultValue]? = nil
        )
        {
            self.defaultValueList = defaultValueList
        }
    }

}

extension LexModelsV2ClientTypes.SlotFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case `operator` = "operator"
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SlotFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let operatorDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SlotFilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Filters the response from the ListSlots operation.
    public struct SlotFilter: Swift.Equatable {
        /// The name of the field to use for filtering.
        /// This member is required.
        public var name: LexModelsV2ClientTypes.SlotFilterName?
        /// The operator to use for the filter. Specify EQ when the ListSlots operation should return only aliases that equal the specified value. Specify CO when the ListSlots operation should return aliases that contain the specified value.
        /// This member is required.
        public var `operator`: LexModelsV2ClientTypes.SlotFilterOperator?
        /// The value to use to filter the response.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: LexModelsV2ClientTypes.SlotFilterName? = nil,
            `operator`: LexModelsV2ClientTypes.SlotFilterOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum SlotFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case slotname
        case sdkUnknown(Swift.String)

        public static var allCases: [SlotFilterName] {
            return [
                .slotname,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .slotname: return "SlotName"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SlotFilterName(rawValue: rawValue) ?? SlotFilterName.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes {
    public enum SlotFilterOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case contains
        case equals
        case sdkUnknown(Swift.String)

        public static var allCases: [SlotFilterOperator] {
            return [
                .contains,
                .equals,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contains: return "CO"
            case .equals: return "EQ"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SlotFilterOperator(rawValue: rawValue) ?? SlotFilterOperator.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.SlotPriority: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case priority
        case slotId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let slotId = self.slotId {
            try encodeContainer.encode(slotId, forKey: .slotId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let slotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotId)
        slotId = slotIdDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Sets the priority that Amazon Lex should use when eliciting slot values from a user.
    public struct SlotPriority: Swift.Equatable {
        /// The priority that Amazon Lex should apply to the slot.
        /// This member is required.
        public var priority: Swift.Int?
        /// The unique identifier of the slot.
        /// This member is required.
        public var slotId: Swift.String?

        public init(
            priority: Swift.Int? = nil,
            slotId: Swift.String? = nil
        )
        {
            self.priority = priority
            self.slotId = slotId
        }
    }

}

extension LexModelsV2ClientTypes.SlotResolutionTestResultItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resultCounts
        case slotName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resultCounts = self.resultCounts {
            try encodeContainer.encode(resultCounts, forKey: .resultCounts)
        }
        if let slotName = self.slotName {
            try encodeContainer.encode(slotName, forKey: .slotName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let slotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotName)
        slotName = slotNameDecoded
        let resultCountsDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SlotResolutionTestResultItemCounts.self, forKey: .resultCounts)
        resultCounts = resultCountsDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Information about the success and failure rate of slot resolution in the results of a test execution.
    public struct SlotResolutionTestResultItem: Swift.Equatable {
        /// A result for slot resolution in the results of a test execution.
        /// This member is required.
        public var resultCounts: LexModelsV2ClientTypes.SlotResolutionTestResultItemCounts?
        /// The name of the slot.
        /// This member is required.
        public var slotName: Swift.String?

        public init(
            resultCounts: LexModelsV2ClientTypes.SlotResolutionTestResultItemCounts? = nil,
            slotName: Swift.String? = nil
        )
        {
            self.resultCounts = resultCounts
            self.slotName = slotName
        }
    }

}

extension LexModelsV2ClientTypes.SlotResolutionTestResultItemCounts: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case slotMatchResultCounts
        case speechTranscriptionResultCounts
        case totalResultCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let slotMatchResultCounts = slotMatchResultCounts {
            var slotMatchResultCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .slotMatchResultCounts)
            for (dictKey0, testResultMatchStatusCountMap0) in slotMatchResultCounts {
                try slotMatchResultCountsContainer.encode(testResultMatchStatusCountMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let speechTranscriptionResultCounts = speechTranscriptionResultCounts {
            var speechTranscriptionResultCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .speechTranscriptionResultCounts)
            for (dictKey0, testResultMatchStatusCountMap0) in speechTranscriptionResultCounts {
                try speechTranscriptionResultCountsContainer.encode(testResultMatchStatusCountMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let totalResultCount = self.totalResultCount {
            try encodeContainer.encode(totalResultCount, forKey: .totalResultCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalResultCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalResultCount)
        totalResultCount = totalResultCountDecoded
        let speechTranscriptionResultCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .speechTranscriptionResultCounts)
        var speechTranscriptionResultCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let speechTranscriptionResultCountsContainer = speechTranscriptionResultCountsContainer {
            speechTranscriptionResultCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, count0) in speechTranscriptionResultCountsContainer {
                if let count0 = count0 {
                    speechTranscriptionResultCountsDecoded0?[key0] = count0
                }
            }
        }
        speechTranscriptionResultCounts = speechTranscriptionResultCountsDecoded0
        let slotMatchResultCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .slotMatchResultCounts)
        var slotMatchResultCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let slotMatchResultCountsContainer = slotMatchResultCountsContainer {
            slotMatchResultCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, count0) in slotMatchResultCountsContainer {
                if let count0 = count0 {
                    slotMatchResultCountsDecoded0?[key0] = count0
                }
            }
        }
        slotMatchResultCounts = slotMatchResultCountsDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// Information about the counts for a slot resolution in the results of a test execution.
    public struct SlotResolutionTestResultItemCounts: Swift.Equatable {
        /// The number of matched and mismatched results for slot resolution for the slot.
        /// This member is required.
        public var slotMatchResultCounts: [Swift.String:Swift.Int]?
        /// The number of matched, mismatched and execution error results for speech transcription for the slot.
        public var speechTranscriptionResultCounts: [Swift.String:Swift.Int]?
        /// The total number of results.
        /// This member is required.
        public var totalResultCount: Swift.Int?

        public init(
            slotMatchResultCounts: [Swift.String:Swift.Int]? = nil,
            speechTranscriptionResultCounts: [Swift.String:Swift.Int]? = nil,
            totalResultCount: Swift.Int? = nil
        )
        {
            self.slotMatchResultCounts = slotMatchResultCounts
            self.speechTranscriptionResultCounts = speechTranscriptionResultCounts
            self.totalResultCount = totalResultCount
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum SlotShape: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case list
        case scalar
        case sdkUnknown(Swift.String)

        public static var allCases: [SlotShape] {
            return [
                .list,
                .scalar,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .list: return "List"
            case .scalar: return "Scalar"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SlotShape(rawValue: rawValue) ?? SlotShape.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes {
    public enum SlotSortAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lastupdateddatetime
        case slotname
        case sdkUnknown(Swift.String)

        public static var allCases: [SlotSortAttribute] {
            return [
                .lastupdateddatetime,
                .slotname,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lastupdateddatetime: return "LastUpdatedDateTime"
            case .slotname: return "SlotName"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SlotSortAttribute(rawValue: rawValue) ?? SlotSortAttribute.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.SlotSortBy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute
        case order
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = self.attribute {
            try encodeContainer.encode(attribute.rawValue, forKey: .attribute)
        }
        if let order = self.order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SlotSortAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let orderDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SortOrder.self, forKey: .order)
        order = orderDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Specifies attributes for sorting a list of bots.
    public struct SlotSortBy: Swift.Equatable {
        /// The attribute to use to sort the list.
        /// This member is required.
        public var attribute: LexModelsV2ClientTypes.SlotSortAttribute?
        /// The order to sort the list. You can choose ascending or descending.
        /// This member is required.
        public var order: LexModelsV2ClientTypes.SortOrder?

        public init(
            attribute: LexModelsV2ClientTypes.SlotSortAttribute? = nil,
            order: LexModelsV2ClientTypes.SortOrder? = nil
        )
        {
            self.attribute = attribute
            self.order = order
        }
    }

}

extension LexModelsV2ClientTypes.SlotSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case lastUpdatedDateTime
        case slotConstraint
        case slotId
        case slotName
        case slotTypeId
        case valueElicitationPromptSpecification
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let slotConstraint = self.slotConstraint {
            try encodeContainer.encode(slotConstraint.rawValue, forKey: .slotConstraint)
        }
        if let slotId = self.slotId {
            try encodeContainer.encode(slotId, forKey: .slotId)
        }
        if let slotName = self.slotName {
            try encodeContainer.encode(slotName, forKey: .slotName)
        }
        if let slotTypeId = self.slotTypeId {
            try encodeContainer.encode(slotTypeId, forKey: .slotTypeId)
        }
        if let valueElicitationPromptSpecification = self.valueElicitationPromptSpecification {
            try encodeContainer.encode(valueElicitationPromptSpecification, forKey: .valueElicitationPromptSpecification)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let slotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotId)
        slotId = slotIdDecoded
        let slotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotName)
        slotName = slotNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let slotConstraintDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SlotConstraint.self, forKey: .slotConstraint)
        slotConstraint = slotConstraintDecoded
        let slotTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotTypeId)
        slotTypeId = slotTypeIdDecoded
        let valueElicitationPromptSpecificationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.PromptSpecification.self, forKey: .valueElicitationPromptSpecification)
        valueElicitationPromptSpecification = valueElicitationPromptSpecificationDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Summary information about a slot, a value that the bot elicits from the user.
    public struct SlotSummary: Swift.Equatable {
        /// The description of the slot.
        public var description: Swift.String?
        /// The timestamp of the last date and time that the slot was updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// Whether the slot is required or optional. An intent is complete when all required slots are filled.
        public var slotConstraint: LexModelsV2ClientTypes.SlotConstraint?
        /// The unique identifier of the slot.
        public var slotId: Swift.String?
        /// The name given to the slot.
        public var slotName: Swift.String?
        /// The unique identifier for the slot type that defines the values for the slot.
        public var slotTypeId: Swift.String?
        /// Prompts that are sent to the user to elicit a value for the slot.
        public var valueElicitationPromptSpecification: LexModelsV2ClientTypes.PromptSpecification?

        public init(
            description: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            slotConstraint: LexModelsV2ClientTypes.SlotConstraint? = nil,
            slotId: Swift.String? = nil,
            slotName: Swift.String? = nil,
            slotTypeId: Swift.String? = nil,
            valueElicitationPromptSpecification: LexModelsV2ClientTypes.PromptSpecification? = nil
        )
        {
            self.description = description
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.slotConstraint = slotConstraint
            self.slotId = slotId
            self.slotName = slotName
            self.slotTypeId = slotTypeId
            self.valueElicitationPromptSpecification = valueElicitationPromptSpecification
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum SlotTypeCategory: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case composite
        case custom
        case extended
        case externalgrammar
        case sdkUnknown(Swift.String)

        public static var allCases: [SlotTypeCategory] {
            return [
                .composite,
                .custom,
                .extended,
                .externalgrammar,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .composite: return "Composite"
            case .custom: return "Custom"
            case .extended: return "Extended"
            case .externalgrammar: return "ExternalGrammar"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SlotTypeCategory(rawValue: rawValue) ?? SlotTypeCategory.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.SlotTypeFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case `operator` = "operator"
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SlotTypeFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let operatorDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SlotTypeFilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Filters the response from the ListSlotTypes operation.
    public struct SlotTypeFilter: Swift.Equatable {
        /// The name of the field to use for filtering.
        /// This member is required.
        public var name: LexModelsV2ClientTypes.SlotTypeFilterName?
        /// The operator to use for the filter. Specify EQ when the ListSlotTypes operation should return only aliases that equal the specified value. Specify CO when the ListSlotTypes operation should return aliases that contain the specified value.
        /// This member is required.
        public var `operator`: LexModelsV2ClientTypes.SlotTypeFilterOperator?
        /// The value to use to filter the response.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: LexModelsV2ClientTypes.SlotTypeFilterName? = nil,
            `operator`: LexModelsV2ClientTypes.SlotTypeFilterOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum SlotTypeFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case externalsourcetype
        case slottypename
        case sdkUnknown(Swift.String)

        public static var allCases: [SlotTypeFilterName] {
            return [
                .externalsourcetype,
                .slottypename,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .externalsourcetype: return "ExternalSourceType"
            case .slottypename: return "SlotTypeName"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SlotTypeFilterName(rawValue: rawValue) ?? SlotTypeFilterName.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes {
    public enum SlotTypeFilterOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case contains
        case equals
        case sdkUnknown(Swift.String)

        public static var allCases: [SlotTypeFilterOperator] {
            return [
                .contains,
                .equals,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contains: return "CO"
            case .equals: return "EQ"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SlotTypeFilterOperator(rawValue: rawValue) ?? SlotTypeFilterOperator.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes {
    public enum SlotTypeSortAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lastupdateddatetime
        case slottypename
        case sdkUnknown(Swift.String)

        public static var allCases: [SlotTypeSortAttribute] {
            return [
                .lastupdateddatetime,
                .slottypename,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lastupdateddatetime: return "LastUpdatedDateTime"
            case .slottypename: return "SlotTypeName"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SlotTypeSortAttribute(rawValue: rawValue) ?? SlotTypeSortAttribute.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.SlotTypeSortBy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute
        case order
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = self.attribute {
            try encodeContainer.encode(attribute.rawValue, forKey: .attribute)
        }
        if let order = self.order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SlotTypeSortAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let orderDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SortOrder.self, forKey: .order)
        order = orderDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Specifies attributes for sorting a list of slot types.
    public struct SlotTypeSortBy: Swift.Equatable {
        /// The attribute to use to sort the list of slot types.
        /// This member is required.
        public var attribute: LexModelsV2ClientTypes.SlotTypeSortAttribute?
        /// The order to sort the list. You can say ascending or descending.
        /// This member is required.
        public var order: LexModelsV2ClientTypes.SortOrder?

        public init(
            attribute: LexModelsV2ClientTypes.SlotTypeSortAttribute? = nil,
            order: LexModelsV2ClientTypes.SortOrder? = nil
        )
        {
            self.attribute = attribute
            self.order = order
        }
    }

}

extension LexModelsV2ClientTypes.SlotTypeStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case discoveredSlotTypeCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let discoveredSlotTypeCount = self.discoveredSlotTypeCount {
            try encodeContainer.encode(discoveredSlotTypeCount, forKey: .discoveredSlotTypeCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let discoveredSlotTypeCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .discoveredSlotTypeCount)
        discoveredSlotTypeCount = discoveredSlotTypeCountDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// The object that contains the statistical summary of the recommended slot type associated with the bot recommendation.
    public struct SlotTypeStatistics: Swift.Equatable {
        /// The number of recommended slot types associated with the bot recommendation.
        public var discoveredSlotTypeCount: Swift.Int?

        public init(
            discoveredSlotTypeCount: Swift.Int? = nil
        )
        {
            self.discoveredSlotTypeCount = discoveredSlotTypeCount
        }
    }

}

extension LexModelsV2ClientTypes.SlotTypeSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case lastUpdatedDateTime
        case parentSlotTypeSignature
        case slotTypeCategory
        case slotTypeId
        case slotTypeName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let parentSlotTypeSignature = self.parentSlotTypeSignature {
            try encodeContainer.encode(parentSlotTypeSignature, forKey: .parentSlotTypeSignature)
        }
        if let slotTypeCategory = self.slotTypeCategory {
            try encodeContainer.encode(slotTypeCategory.rawValue, forKey: .slotTypeCategory)
        }
        if let slotTypeId = self.slotTypeId {
            try encodeContainer.encode(slotTypeId, forKey: .slotTypeId)
        }
        if let slotTypeName = self.slotTypeName {
            try encodeContainer.encode(slotTypeName, forKey: .slotTypeName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let slotTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotTypeId)
        slotTypeId = slotTypeIdDecoded
        let slotTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotTypeName)
        slotTypeName = slotTypeNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parentSlotTypeSignatureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentSlotTypeSignature)
        parentSlotTypeSignature = parentSlotTypeSignatureDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let slotTypeCategoryDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SlotTypeCategory.self, forKey: .slotTypeCategory)
        slotTypeCategory = slotTypeCategoryDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Provides summary information about a slot type.
    public struct SlotTypeSummary: Swift.Equatable {
        /// The description of the slot type.
        public var description: Swift.String?
        /// A timestamp of the date and time that the slot type was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// If the slot type is derived from a built-on slot type, the name of the parent slot type.
        public var parentSlotTypeSignature: Swift.String?
        /// Indicates the type of the slot type.
        ///
        /// * Custom - A slot type that you created using custom values. For more information, see [Creating custom slot types](https://docs.aws.amazon.com/lexv2/latest/dg/custom-slot-types.html).
        ///
        /// * Extended - A slot type created by extending the AMAZON.AlphaNumeric built-in slot type. For more information, see [AMAZON.AlphaNumeric](https://docs.aws.amazon.com/lexv2/latest/dg/built-in-slot-alphanumerice.html).
        ///
        /// * ExternalGrammar - A slot type using a custom GRXML grammar to define values. For more information, see [Using a custom grammar slot type](https://docs.aws.amazon.com/lexv2/latest/dg/building-grxml.html).
        public var slotTypeCategory: LexModelsV2ClientTypes.SlotTypeCategory?
        /// The unique identifier assigned to the slot type.
        public var slotTypeId: Swift.String?
        /// The name of the slot type.
        public var slotTypeName: Swift.String?

        public init(
            description: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            parentSlotTypeSignature: Swift.String? = nil,
            slotTypeCategory: LexModelsV2ClientTypes.SlotTypeCategory? = nil,
            slotTypeId: Swift.String? = nil,
            slotTypeName: Swift.String? = nil
        )
        {
            self.description = description
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.parentSlotTypeSignature = parentSlotTypeSignature
            self.slotTypeCategory = slotTypeCategory
            self.slotTypeId = slotTypeId
            self.slotTypeName = slotTypeName
        }
    }

}

extension LexModelsV2ClientTypes.SlotTypeValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sampleValue
        case synonyms
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sampleValue = self.sampleValue {
            try encodeContainer.encode(sampleValue, forKey: .sampleValue)
        }
        if let synonyms = synonyms {
            var synonymsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .synonyms)
            for samplevalue0 in synonyms {
                try synonymsContainer.encode(samplevalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sampleValueDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SampleValue.self, forKey: .sampleValue)
        sampleValue = sampleValueDecoded
        let synonymsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.SampleValue?].self, forKey: .synonyms)
        var synonymsDecoded0:[LexModelsV2ClientTypes.SampleValue]? = nil
        if let synonymsContainer = synonymsContainer {
            synonymsDecoded0 = [LexModelsV2ClientTypes.SampleValue]()
            for structure0 in synonymsContainer {
                if let structure0 = structure0 {
                    synonymsDecoded0?.append(structure0)
                }
            }
        }
        synonyms = synonymsDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// Each slot type can have a set of values. Each SlotTypeValue represents a value that the slot type can take.
    public struct SlotTypeValue: Swift.Equatable {
        /// The value of the slot type entry.
        public var sampleValue: LexModelsV2ClientTypes.SampleValue?
        /// Additional values related to the slot type entry.
        public var synonyms: [LexModelsV2ClientTypes.SampleValue]?

        public init(
            sampleValue: LexModelsV2ClientTypes.SampleValue? = nil,
            synonyms: [LexModelsV2ClientTypes.SampleValue]? = nil
        )
        {
            self.sampleValue = sampleValue
            self.synonyms = synonyms
        }
    }

}

extension LexModelsV2ClientTypes.SlotValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interpretedValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let interpretedValue = self.interpretedValue {
            try encodeContainer.encode(interpretedValue, forKey: .interpretedValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let interpretedValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .interpretedValue)
        interpretedValue = interpretedValueDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// The value to set in a slot.
    public struct SlotValue: Swift.Equatable {
        /// The value that Amazon Lex determines for the slot. The actual value depends on the setting of the value selection strategy for the bot. You can choose to use the value entered by the user, or you can have Amazon Lex choose the first value in the resolvedValues list.
        public var interpretedValue: Swift.String?

        public init(
            interpretedValue: Swift.String? = nil
        )
        {
            self.interpretedValue = interpretedValue
        }
    }

}

extension LexModelsV2ClientTypes.SlotValueElicitationSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValueSpecification
        case promptSpecification
        case sampleUtterances
        case slotCaptureSetting
        case slotConstraint
        case waitAndContinueSpecification
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValueSpecification = self.defaultValueSpecification {
            try encodeContainer.encode(defaultValueSpecification, forKey: .defaultValueSpecification)
        }
        if let promptSpecification = self.promptSpecification {
            try encodeContainer.encode(promptSpecification, forKey: .promptSpecification)
        }
        if let sampleUtterances = sampleUtterances {
            var sampleUtterancesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sampleUtterances)
            for sampleutterance0 in sampleUtterances {
                try sampleUtterancesContainer.encode(sampleutterance0)
            }
        }
        if let slotCaptureSetting = self.slotCaptureSetting {
            try encodeContainer.encode(slotCaptureSetting, forKey: .slotCaptureSetting)
        }
        if let slotConstraint = self.slotConstraint {
            try encodeContainer.encode(slotConstraint.rawValue, forKey: .slotConstraint)
        }
        if let waitAndContinueSpecification = self.waitAndContinueSpecification {
            try encodeContainer.encode(waitAndContinueSpecification, forKey: .waitAndContinueSpecification)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueSpecificationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SlotDefaultValueSpecification.self, forKey: .defaultValueSpecification)
        defaultValueSpecification = defaultValueSpecificationDecoded
        let slotConstraintDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SlotConstraint.self, forKey: .slotConstraint)
        slotConstraint = slotConstraintDecoded
        let promptSpecificationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.PromptSpecification.self, forKey: .promptSpecification)
        promptSpecification = promptSpecificationDecoded
        let sampleUtterancesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.SampleUtterance?].self, forKey: .sampleUtterances)
        var sampleUtterancesDecoded0:[LexModelsV2ClientTypes.SampleUtterance]? = nil
        if let sampleUtterancesContainer = sampleUtterancesContainer {
            sampleUtterancesDecoded0 = [LexModelsV2ClientTypes.SampleUtterance]()
            for structure0 in sampleUtterancesContainer {
                if let structure0 = structure0 {
                    sampleUtterancesDecoded0?.append(structure0)
                }
            }
        }
        sampleUtterances = sampleUtterancesDecoded0
        let waitAndContinueSpecificationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.WaitAndContinueSpecification.self, forKey: .waitAndContinueSpecification)
        waitAndContinueSpecification = waitAndContinueSpecificationDecoded
        let slotCaptureSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SlotCaptureSetting.self, forKey: .slotCaptureSetting)
        slotCaptureSetting = slotCaptureSettingDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Specifies the elicitation setting details eliciting a slot.
    public struct SlotValueElicitationSetting: Swift.Equatable {
        /// A list of default values for a slot. Default values are used when Amazon Lex hasn't determined a value for a slot. You can specify default values from context variables, session attributes, and defined values.
        public var defaultValueSpecification: LexModelsV2ClientTypes.SlotDefaultValueSpecification?
        /// The prompt that Amazon Lex uses to elicit the slot value from the user.
        public var promptSpecification: LexModelsV2ClientTypes.PromptSpecification?
        /// If you know a specific pattern that users might respond to an Amazon Lex request for a slot value, you can provide those utterances to improve accuracy. This is optional. In most cases, Amazon Lex is capable of understanding user utterances.
        public var sampleUtterances: [LexModelsV2ClientTypes.SampleUtterance]?
        /// Specifies the settings that Amazon Lex uses when a slot value is successfully entered by a user.
        public var slotCaptureSetting: LexModelsV2ClientTypes.SlotCaptureSetting?
        /// Specifies whether the slot is required or optional.
        /// This member is required.
        public var slotConstraint: LexModelsV2ClientTypes.SlotConstraint?
        /// Specifies the prompts that Amazon Lex uses while a bot is waiting for customer input.
        public var waitAndContinueSpecification: LexModelsV2ClientTypes.WaitAndContinueSpecification?

        public init(
            defaultValueSpecification: LexModelsV2ClientTypes.SlotDefaultValueSpecification? = nil,
            promptSpecification: LexModelsV2ClientTypes.PromptSpecification? = nil,
            sampleUtterances: [LexModelsV2ClientTypes.SampleUtterance]? = nil,
            slotCaptureSetting: LexModelsV2ClientTypes.SlotCaptureSetting? = nil,
            slotConstraint: LexModelsV2ClientTypes.SlotConstraint? = nil,
            waitAndContinueSpecification: LexModelsV2ClientTypes.WaitAndContinueSpecification? = nil
        )
        {
            self.defaultValueSpecification = defaultValueSpecification
            self.promptSpecification = promptSpecification
            self.sampleUtterances = sampleUtterances
            self.slotCaptureSetting = slotCaptureSetting
            self.slotConstraint = slotConstraint
            self.waitAndContinueSpecification = waitAndContinueSpecification
        }
    }

}

extension LexModelsV2ClientTypes.SlotValueOverride: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shape
        case value
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let shape = self.shape {
            try encodeContainer.encode(shape.rawValue, forKey: .shape)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for slotvalueoverride0 in values {
                try valuesContainer.encode(slotvalueoverride0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shapeDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SlotShape.self, forKey: .shape)
        shape = shapeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SlotValue.self, forKey: .value)
        value = valueDecoded
        let valuesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.SlotValueOverride?].self, forKey: .values)
        var valuesDecoded0:[LexModelsV2ClientTypes.SlotValueOverride]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [LexModelsV2ClientTypes.SlotValueOverride]()
            for structure0 in valuesContainer {
                if let structure0 = structure0 {
                    valuesDecoded0?.append(structure0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// The slot values that Amazon Lex uses when it sets slot values in a dialog step.
    public struct SlotValueOverride: Swift.Equatable {
        /// When the shape value is List, it indicates that the values field contains a list of slot values. When the value is Scalar, it indicates that the value field contains a single value.
        public var shape: LexModelsV2ClientTypes.SlotShape?
        /// The current value of the slot.
        public var value: LexModelsV2ClientTypes.SlotValue?
        /// A list of one or more values that the user provided for the slot. For example, for a slot that elicits pizza toppings, the values might be "pepperoni" and "pineapple."
        public var values: [LexModelsV2ClientTypes.SlotValueOverride]?

        public init(
            shape: LexModelsV2ClientTypes.SlotShape? = nil,
            value: LexModelsV2ClientTypes.SlotValue? = nil,
            values: [LexModelsV2ClientTypes.SlotValueOverride]? = nil
        )
        {
            self.shape = shape
            self.value = value
            self.values = values
        }
    }

}

extension LexModelsV2ClientTypes.SlotValueRegexFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pattern
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pattern = self.pattern {
            try encodeContainer.encode(pattern, forKey: .pattern)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pattern)
        pattern = patternDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Provides a regular expression used to validate the value of a slot.
    public struct SlotValueRegexFilter: Swift.Equatable {
        /// A regular expression used to validate the value of a slot. Use a standard regular expression. Amazon Lex supports the following characters in the regular expression:
        ///
        /// * A-Z, a-z
        ///
        /// * 0-9
        ///
        /// * Unicode characters ("\⁠u")
        ///
        ///
        /// Represent Unicode characters with four digits, for example "\⁠u0041" or "\⁠u005A". The following regular expression operators are not supported:
        ///
        /// * Infinite repeaters: *, +, or {x,} with no upper bound.
        ///
        /// * Wild card (.)
        /// This member is required.
        public var pattern: Swift.String?

        public init(
            pattern: Swift.String? = nil
        )
        {
            self.pattern = pattern
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum SlotValueResolutionStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case concatenation
        case originalvalue
        case topresolution
        case sdkUnknown(Swift.String)

        public static var allCases: [SlotValueResolutionStrategy] {
            return [
                .concatenation,
                .originalvalue,
                .topresolution,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .concatenation: return "Concatenation"
            case .originalvalue: return "OriginalValue"
            case .topresolution: return "TopResolution"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SlotValueResolutionStrategy(rawValue: rawValue) ?? SlotValueResolutionStrategy.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.SlotValueSelectionSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedRecognitionSetting
        case regexFilter
        case resolutionStrategy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let advancedRecognitionSetting = self.advancedRecognitionSetting {
            try encodeContainer.encode(advancedRecognitionSetting, forKey: .advancedRecognitionSetting)
        }
        if let regexFilter = self.regexFilter {
            try encodeContainer.encode(regexFilter, forKey: .regexFilter)
        }
        if let resolutionStrategy = self.resolutionStrategy {
            try encodeContainer.encode(resolutionStrategy.rawValue, forKey: .resolutionStrategy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolutionStrategyDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SlotValueResolutionStrategy.self, forKey: .resolutionStrategy)
        resolutionStrategy = resolutionStrategyDecoded
        let regexFilterDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SlotValueRegexFilter.self, forKey: .regexFilter)
        regexFilter = regexFilterDecoded
        let advancedRecognitionSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AdvancedRecognitionSetting.self, forKey: .advancedRecognitionSetting)
        advancedRecognitionSetting = advancedRecognitionSettingDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Contains settings used by Amazon Lex to select a slot value.
    public struct SlotValueSelectionSetting: Swift.Equatable {
        /// Provides settings that enable advanced recognition settings for slot values. You can use this to enable using slot values as a custom vocabulary for recognizing user utterances.
        public var advancedRecognitionSetting: LexModelsV2ClientTypes.AdvancedRecognitionSetting?
        /// A regular expression used to validate the value of a slot.
        public var regexFilter: LexModelsV2ClientTypes.SlotValueRegexFilter?
        /// Determines the slot resolution strategy that Amazon Lex uses to return slot type values. The field can be set to one of the following values:
        ///
        /// * ORIGINAL_VALUE - Returns the value entered by the user, if the user value is similar to the slot value.
        ///
        /// * TOP_RESOLUTION - If there is a resolution list for the slot, return the first value in the resolution list as the slot type value. If there is no resolution list, null is returned.
        ///
        ///
        /// If you don't specify the valueSelectionStrategy, the default is ORIGINAL_VALUE.
        /// This member is required.
        public var resolutionStrategy: LexModelsV2ClientTypes.SlotValueResolutionStrategy?

        public init(
            advancedRecognitionSetting: LexModelsV2ClientTypes.AdvancedRecognitionSetting? = nil,
            regexFilter: LexModelsV2ClientTypes.SlotValueRegexFilter? = nil,
            resolutionStrategy: LexModelsV2ClientTypes.SlotValueResolutionStrategy? = nil
        )
        {
            self.advancedRecognitionSetting = advancedRecognitionSetting
            self.regexFilter = regexFilter
            self.resolutionStrategy = resolutionStrategy
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "Ascending"
            case .descending: return "Descending"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.Specifications: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case slotTypeId
        case valueElicitationSetting
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let slotTypeId = self.slotTypeId {
            try encodeContainer.encode(slotTypeId, forKey: .slotTypeId)
        }
        if let valueElicitationSetting = self.valueElicitationSetting {
            try encodeContainer.encode(valueElicitationSetting, forKey: .valueElicitationSetting)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let slotTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotTypeId)
        slotTypeId = slotTypeIdDecoded
        let valueElicitationSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SubSlotValueElicitationSetting.self, forKey: .valueElicitationSetting)
        valueElicitationSetting = valueElicitationSettingDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Subslot specifications.
    public struct Specifications: Swift.Equatable {
        /// The unique identifier assigned to the slot type.
        /// This member is required.
        public var slotTypeId: Swift.String?
        /// Specifies the elicitation setting details for constituent sub slots of a composite slot.
        /// This member is required.
        public var valueElicitationSetting: LexModelsV2ClientTypes.SubSlotValueElicitationSetting?

        public init(
            slotTypeId: Swift.String? = nil,
            valueElicitationSetting: LexModelsV2ClientTypes.SubSlotValueElicitationSetting? = nil
        )
        {
            self.slotTypeId = slotTypeId
            self.valueElicitationSetting = valueElicitationSetting
        }
    }

}

extension StartBotRecommendationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionSetting
        case transcriptSourceSetting
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionSetting = self.encryptionSetting {
            try encodeContainer.encode(encryptionSetting, forKey: .encryptionSetting)
        }
        if let transcriptSourceSetting = self.transcriptSourceSetting {
            try encodeContainer.encode(transcriptSourceSetting, forKey: .transcriptSourceSetting)
        }
    }
}

extension StartBotRecommendationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botVersion = botVersion else {
            return nil
        }
        guard let localeId = localeId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botversions/\(botVersion.urlPercentEncoding())/botlocales/\(localeId.urlPercentEncoding())/botrecommendations"
    }
}

public struct StartBotRecommendationInput: Swift.Equatable {
    /// The unique identifier of the bot containing the bot recommendation.
    /// This member is required.
    public var botId: Swift.String?
    /// The version of the bot containing the bot recommendation.
    /// This member is required.
    public var botVersion: Swift.String?
    /// The object representing the passwords that will be used to encrypt the data related to the bot recommendation results, as well as the KMS key ARN used to encrypt the associated metadata.
    public var encryptionSetting: LexModelsV2ClientTypes.EncryptionSetting?
    /// The identifier of the language and locale of the bot recommendation to start. The string must match one of the supported locales. For more information, see [Supported languages](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html)
    /// This member is required.
    public var localeId: Swift.String?
    /// The object representing the Amazon S3 bucket containing the transcript, as well as the associated metadata.
    /// This member is required.
    public var transcriptSourceSetting: LexModelsV2ClientTypes.TranscriptSourceSetting?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        encryptionSetting: LexModelsV2ClientTypes.EncryptionSetting? = nil,
        localeId: Swift.String? = nil,
        transcriptSourceSetting: LexModelsV2ClientTypes.TranscriptSourceSetting? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.encryptionSetting = encryptionSetting
        self.localeId = localeId
        self.transcriptSourceSetting = transcriptSourceSetting
    }
}

struct StartBotRecommendationInputBody: Swift.Equatable {
    let transcriptSourceSetting: LexModelsV2ClientTypes.TranscriptSourceSetting?
    let encryptionSetting: LexModelsV2ClientTypes.EncryptionSetting?
}

extension StartBotRecommendationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionSetting
        case transcriptSourceSetting
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transcriptSourceSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TranscriptSourceSetting.self, forKey: .transcriptSourceSetting)
        transcriptSourceSetting = transcriptSourceSettingDecoded
        let encryptionSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.EncryptionSetting.self, forKey: .encryptionSetting)
        encryptionSetting = encryptionSettingDecoded
    }
}

enum StartBotRecommendationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartBotRecommendationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartBotRecommendationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botRecommendationId = output.botRecommendationId
            self.botRecommendationStatus = output.botRecommendationStatus
            self.botVersion = output.botVersion
            self.creationDateTime = output.creationDateTime
            self.encryptionSetting = output.encryptionSetting
            self.localeId = output.localeId
            self.transcriptSourceSetting = output.transcriptSourceSetting
        } else {
            self.botId = nil
            self.botRecommendationId = nil
            self.botRecommendationStatus = nil
            self.botVersion = nil
            self.creationDateTime = nil
            self.encryptionSetting = nil
            self.localeId = nil
            self.transcriptSourceSetting = nil
        }
    }
}

public struct StartBotRecommendationOutputResponse: Swift.Equatable {
    /// The unique identifier of the bot containing the bot recommendation.
    public var botId: Swift.String?
    /// The identifier of the bot recommendation that you have created.
    public var botRecommendationId: Swift.String?
    /// The status of the bot recommendation. If the status is Failed, then the reasons for the failure are listed in the failureReasons field.
    public var botRecommendationStatus: LexModelsV2ClientTypes.BotRecommendationStatus?
    /// The version of the bot containing the bot recommendation.
    public var botVersion: Swift.String?
    /// A timestamp of the date and time that the bot recommendation was created.
    public var creationDateTime: ClientRuntime.Date?
    /// The object representing the passwords that were used to encrypt the data related to the bot recommendation results, as well as the KMS key ARN used to encrypt the associated metadata.
    public var encryptionSetting: LexModelsV2ClientTypes.EncryptionSetting?
    /// The identifier of the language and locale of the bot recommendation to start. The string must match one of the supported locales. For more information, see [Supported languages](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html)
    public var localeId: Swift.String?
    /// The object representing the Amazon S3 bucket containing the transcript, as well as the associated metadata.
    public var transcriptSourceSetting: LexModelsV2ClientTypes.TranscriptSourceSetting?

    public init(
        botId: Swift.String? = nil,
        botRecommendationId: Swift.String? = nil,
        botRecommendationStatus: LexModelsV2ClientTypes.BotRecommendationStatus? = nil,
        botVersion: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        encryptionSetting: LexModelsV2ClientTypes.EncryptionSetting? = nil,
        localeId: Swift.String? = nil,
        transcriptSourceSetting: LexModelsV2ClientTypes.TranscriptSourceSetting? = nil
    )
    {
        self.botId = botId
        self.botRecommendationId = botRecommendationId
        self.botRecommendationStatus = botRecommendationStatus
        self.botVersion = botVersion
        self.creationDateTime = creationDateTime
        self.encryptionSetting = encryptionSetting
        self.localeId = localeId
        self.transcriptSourceSetting = transcriptSourceSetting
    }
}

struct StartBotRecommendationOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let botVersion: Swift.String?
    let localeId: Swift.String?
    let botRecommendationStatus: LexModelsV2ClientTypes.BotRecommendationStatus?
    let botRecommendationId: Swift.String?
    let creationDateTime: ClientRuntime.Date?
    let transcriptSourceSetting: LexModelsV2ClientTypes.TranscriptSourceSetting?
    let encryptionSetting: LexModelsV2ClientTypes.EncryptionSetting?
}

extension StartBotRecommendationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botRecommendationId
        case botRecommendationStatus
        case botVersion
        case creationDateTime
        case encryptionSetting
        case localeId
        case transcriptSourceSetting
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let botRecommendationStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotRecommendationStatus.self, forKey: .botRecommendationStatus)
        botRecommendationStatus = botRecommendationStatusDecoded
        let botRecommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botRecommendationId)
        botRecommendationId = botRecommendationIdDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let transcriptSourceSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TranscriptSourceSetting.self, forKey: .transcriptSourceSetting)
        transcriptSourceSetting = transcriptSourceSettingDecoded
        let encryptionSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.EncryptionSetting.self, forKey: .encryptionSetting)
        encryptionSetting = encryptionSettingDecoded
    }
}

extension StartImportInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartImportInput(importId: \(Swift.String(describing: importId)), mergeStrategy: \(Swift.String(describing: mergeStrategy)), resourceSpecification: \(Swift.String(describing: resourceSpecification)), filePassword: \"CONTENT_REDACTED\")"}
}

extension StartImportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filePassword
        case importId
        case mergeStrategy
        case resourceSpecification
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filePassword = self.filePassword {
            try encodeContainer.encode(filePassword, forKey: .filePassword)
        }
        if let importId = self.importId {
            try encodeContainer.encode(importId, forKey: .importId)
        }
        if let mergeStrategy = self.mergeStrategy {
            try encodeContainer.encode(mergeStrategy.rawValue, forKey: .mergeStrategy)
        }
        if let resourceSpecification = self.resourceSpecification {
            try encodeContainer.encode(resourceSpecification, forKey: .resourceSpecification)
        }
    }
}

extension StartImportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/imports"
    }
}

public struct StartImportInput: Swift.Equatable {
    /// The password used to encrypt the zip archive that contains the resource definition. You should always encrypt the zip archive to protect it during transit between your site and Amazon Lex.
    public var filePassword: Swift.String?
    /// The unique identifier for the import. It is included in the response from the [CreateUploadUrl](https://docs.aws.amazon.com/lexv2/latest/APIReference/API_CreateUploadUrl.html) operation.
    /// This member is required.
    public var importId: Swift.String?
    /// The strategy to use when there is a name conflict between the imported resource and an existing resource. When the merge strategy is FailOnConflict existing resources are not overwritten and the import fails.
    /// This member is required.
    public var mergeStrategy: LexModelsV2ClientTypes.MergeStrategy?
    /// Parameters for creating the bot, bot locale or custom vocabulary.
    /// This member is required.
    public var resourceSpecification: LexModelsV2ClientTypes.ImportResourceSpecification?

    public init(
        filePassword: Swift.String? = nil,
        importId: Swift.String? = nil,
        mergeStrategy: LexModelsV2ClientTypes.MergeStrategy? = nil,
        resourceSpecification: LexModelsV2ClientTypes.ImportResourceSpecification? = nil
    )
    {
        self.filePassword = filePassword
        self.importId = importId
        self.mergeStrategy = mergeStrategy
        self.resourceSpecification = resourceSpecification
    }
}

struct StartImportInputBody: Swift.Equatable {
    let importId: Swift.String?
    let resourceSpecification: LexModelsV2ClientTypes.ImportResourceSpecification?
    let mergeStrategy: LexModelsV2ClientTypes.MergeStrategy?
    let filePassword: Swift.String?
}

extension StartImportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filePassword
        case importId
        case mergeStrategy
        case resourceSpecification
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importId)
        importId = importIdDecoded
        let resourceSpecificationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ImportResourceSpecification.self, forKey: .resourceSpecification)
        resourceSpecification = resourceSpecificationDecoded
        let mergeStrategyDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.MergeStrategy.self, forKey: .mergeStrategy)
        mergeStrategy = mergeStrategyDecoded
        let filePasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePassword)
        filePassword = filePasswordDecoded
    }
}

enum StartImportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartImportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartImportOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationDateTime = output.creationDateTime
            self.importId = output.importId
            self.importStatus = output.importStatus
            self.mergeStrategy = output.mergeStrategy
            self.resourceSpecification = output.resourceSpecification
        } else {
            self.creationDateTime = nil
            self.importId = nil
            self.importStatus = nil
            self.mergeStrategy = nil
            self.resourceSpecification = nil
        }
    }
}

public struct StartImportOutputResponse: Swift.Equatable {
    /// The date and time that the import request was created.
    public var creationDateTime: ClientRuntime.Date?
    /// A unique identifier for the import.
    public var importId: Swift.String?
    /// The current status of the import. When the status is Complete the bot, bot alias, or custom vocabulary is ready to use.
    public var importStatus: LexModelsV2ClientTypes.ImportStatus?
    /// The strategy used when there was a name conflict between the imported resource and an existing resource. When the merge strategy is FailOnConflict existing resources are not overwritten and the import fails.
    public var mergeStrategy: LexModelsV2ClientTypes.MergeStrategy?
    /// The parameters used when importing the resource.
    public var resourceSpecification: LexModelsV2ClientTypes.ImportResourceSpecification?

    public init(
        creationDateTime: ClientRuntime.Date? = nil,
        importId: Swift.String? = nil,
        importStatus: LexModelsV2ClientTypes.ImportStatus? = nil,
        mergeStrategy: LexModelsV2ClientTypes.MergeStrategy? = nil,
        resourceSpecification: LexModelsV2ClientTypes.ImportResourceSpecification? = nil
    )
    {
        self.creationDateTime = creationDateTime
        self.importId = importId
        self.importStatus = importStatus
        self.mergeStrategy = mergeStrategy
        self.resourceSpecification = resourceSpecification
    }
}

struct StartImportOutputResponseBody: Swift.Equatable {
    let importId: Swift.String?
    let resourceSpecification: LexModelsV2ClientTypes.ImportResourceSpecification?
    let mergeStrategy: LexModelsV2ClientTypes.MergeStrategy?
    let importStatus: LexModelsV2ClientTypes.ImportStatus?
    let creationDateTime: ClientRuntime.Date?
}

extension StartImportOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case importId
        case importStatus
        case mergeStrategy
        case resourceSpecification
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importId)
        importId = importIdDecoded
        let resourceSpecificationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ImportResourceSpecification.self, forKey: .resourceSpecification)
        resourceSpecification = resourceSpecificationDecoded
        let mergeStrategyDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.MergeStrategy.self, forKey: .mergeStrategy)
        mergeStrategy = mergeStrategyDecoded
        let importStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ImportStatus.self, forKey: .importStatus)
        importStatus = importStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
    }
}

extension StartTestExecutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiMode
        case target
        case testExecutionModality
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiMode = self.apiMode {
            try encodeContainer.encode(apiMode.rawValue, forKey: .apiMode)
        }
        if let target = self.target {
            try encodeContainer.encode(target, forKey: .target)
        }
        if let testExecutionModality = self.testExecutionModality {
            try encodeContainer.encode(testExecutionModality.rawValue, forKey: .testExecutionModality)
        }
    }
}

extension StartTestExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let testSetId = testSetId else {
            return nil
        }
        return "/testsets/\(testSetId.urlPercentEncoding())/testexecutions"
    }
}

public struct StartTestExecutionInput: Swift.Equatable {
    /// Indicates whether we use streaming or non-streaming APIs for the test set execution. For streaming, StartConversation Runtime API is used. Whereas, for non-streaming, RecognizeUtterance and RecognizeText Amazon Lex Runtime API are used.
    /// This member is required.
    public var apiMode: LexModelsV2ClientTypes.TestExecutionApiMode?
    /// The target bot for the test set execution.
    /// This member is required.
    public var target: LexModelsV2ClientTypes.TestExecutionTarget?
    /// Indicates whether audio or text is used.
    public var testExecutionModality: LexModelsV2ClientTypes.TestExecutionModality?
    /// The test set Id for the test set execution.
    /// This member is required.
    public var testSetId: Swift.String?

    public init(
        apiMode: LexModelsV2ClientTypes.TestExecutionApiMode? = nil,
        target: LexModelsV2ClientTypes.TestExecutionTarget? = nil,
        testExecutionModality: LexModelsV2ClientTypes.TestExecutionModality? = nil,
        testSetId: Swift.String? = nil
    )
    {
        self.apiMode = apiMode
        self.target = target
        self.testExecutionModality = testExecutionModality
        self.testSetId = testSetId
    }
}

struct StartTestExecutionInputBody: Swift.Equatable {
    let target: LexModelsV2ClientTypes.TestExecutionTarget?
    let apiMode: LexModelsV2ClientTypes.TestExecutionApiMode?
    let testExecutionModality: LexModelsV2ClientTypes.TestExecutionModality?
}

extension StartTestExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiMode
        case target
        case testExecutionModality
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestExecutionTarget.self, forKey: .target)
        target = targetDecoded
        let apiModeDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestExecutionApiMode.self, forKey: .apiMode)
        apiMode = apiModeDecoded
        let testExecutionModalityDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestExecutionModality.self, forKey: .testExecutionModality)
        testExecutionModality = testExecutionModalityDecoded
    }
}

enum StartTestExecutionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartTestExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartTestExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiMode = output.apiMode
            self.creationDateTime = output.creationDateTime
            self.target = output.target
            self.testExecutionId = output.testExecutionId
            self.testExecutionModality = output.testExecutionModality
            self.testSetId = output.testSetId
        } else {
            self.apiMode = nil
            self.creationDateTime = nil
            self.target = nil
            self.testExecutionId = nil
            self.testExecutionModality = nil
            self.testSetId = nil
        }
    }
}

public struct StartTestExecutionOutputResponse: Swift.Equatable {
    /// Indicates whether we use streaming or non-streaming APIs for the test set execution. For streaming, StartConversation Amazon Lex Runtime API is used. Whereas for non-streaming, RecognizeUtterance and RecognizeText Amazon Lex Runtime API are used.
    public var apiMode: LexModelsV2ClientTypes.TestExecutionApiMode?
    /// The creation date and time for the test set execution.
    public var creationDateTime: ClientRuntime.Date?
    /// The target bot for the test set execution.
    public var target: LexModelsV2ClientTypes.TestExecutionTarget?
    /// The unique identifier of the test set execution.
    public var testExecutionId: Swift.String?
    /// Indicates whether audio or text is used.
    public var testExecutionModality: LexModelsV2ClientTypes.TestExecutionModality?
    /// The test set Id for the test set execution.
    public var testSetId: Swift.String?

    public init(
        apiMode: LexModelsV2ClientTypes.TestExecutionApiMode? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        target: LexModelsV2ClientTypes.TestExecutionTarget? = nil,
        testExecutionId: Swift.String? = nil,
        testExecutionModality: LexModelsV2ClientTypes.TestExecutionModality? = nil,
        testSetId: Swift.String? = nil
    )
    {
        self.apiMode = apiMode
        self.creationDateTime = creationDateTime
        self.target = target
        self.testExecutionId = testExecutionId
        self.testExecutionModality = testExecutionModality
        self.testSetId = testSetId
    }
}

struct StartTestExecutionOutputResponseBody: Swift.Equatable {
    let testExecutionId: Swift.String?
    let creationDateTime: ClientRuntime.Date?
    let testSetId: Swift.String?
    let target: LexModelsV2ClientTypes.TestExecutionTarget?
    let apiMode: LexModelsV2ClientTypes.TestExecutionApiMode?
    let testExecutionModality: LexModelsV2ClientTypes.TestExecutionModality?
}

extension StartTestExecutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiMode
        case creationDateTime
        case target
        case testExecutionId
        case testExecutionModality
        case testSetId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testExecutionId)
        testExecutionId = testExecutionIdDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let testSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testSetId)
        testSetId = testSetIdDecoded
        let targetDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestExecutionTarget.self, forKey: .target)
        target = targetDecoded
        let apiModeDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestExecutionApiMode.self, forKey: .apiMode)
        apiMode = apiModeDecoded
        let testExecutionModalityDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestExecutionModality.self, forKey: .testExecutionModality)
        testExecutionModality = testExecutionModalityDecoded
    }
}

extension StartTestSetGenerationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case generationDataSource
        case roleArn
        case storageLocation
        case testSetName
        case testSetTags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let generationDataSource = self.generationDataSource {
            try encodeContainer.encode(generationDataSource, forKey: .generationDataSource)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let storageLocation = self.storageLocation {
            try encodeContainer.encode(storageLocation, forKey: .storageLocation)
        }
        if let testSetName = self.testSetName {
            try encodeContainer.encode(testSetName, forKey: .testSetName)
        }
        if let testSetTags = testSetTags {
            var testSetTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .testSetTags)
            for (dictKey0, tagMap0) in testSetTags {
                try testSetTagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension StartTestSetGenerationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/testsetgenerations"
    }
}

public struct StartTestSetGenerationInput: Swift.Equatable {
    /// The test set description for the test set generation request.
    public var description: Swift.String?
    /// The data source for the test set generation.
    /// This member is required.
    public var generationDataSource: LexModelsV2ClientTypes.TestSetGenerationDataSource?
    /// The roleARN used for any operation in the test set to access resources in the Amazon Web Services account.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The Amazon S3 storage location for the test set generation.
    /// This member is required.
    public var storageLocation: LexModelsV2ClientTypes.TestSetStorageLocation?
    /// The test set name for the test set generation request.
    /// This member is required.
    public var testSetName: Swift.String?
    /// A list of tags to add to the test set. You can only add tags when you import/generate a new test set. You can't use the UpdateTestSet operation to update tags. To update tags, use the TagResource operation.
    public var testSetTags: [Swift.String:Swift.String]?

    public init(
        description: Swift.String? = nil,
        generationDataSource: LexModelsV2ClientTypes.TestSetGenerationDataSource? = nil,
        roleArn: Swift.String? = nil,
        storageLocation: LexModelsV2ClientTypes.TestSetStorageLocation? = nil,
        testSetName: Swift.String? = nil,
        testSetTags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.generationDataSource = generationDataSource
        self.roleArn = roleArn
        self.storageLocation = storageLocation
        self.testSetName = testSetName
        self.testSetTags = testSetTags
    }
}

struct StartTestSetGenerationInputBody: Swift.Equatable {
    let testSetName: Swift.String?
    let description: Swift.String?
    let storageLocation: LexModelsV2ClientTypes.TestSetStorageLocation?
    let generationDataSource: LexModelsV2ClientTypes.TestSetGenerationDataSource?
    let roleArn: Swift.String?
    let testSetTags: [Swift.String:Swift.String]?
}

extension StartTestSetGenerationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case generationDataSource
        case roleArn
        case storageLocation
        case testSetName
        case testSetTags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testSetName)
        testSetName = testSetNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let storageLocationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestSetStorageLocation.self, forKey: .storageLocation)
        storageLocation = storageLocationDecoded
        let generationDataSourceDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestSetGenerationDataSource.self, forKey: .generationDataSource)
        generationDataSource = generationDataSourceDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let testSetTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .testSetTags)
        var testSetTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let testSetTagsContainer = testSetTagsContainer {
            testSetTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in testSetTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    testSetTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        testSetTags = testSetTagsDecoded0
    }
}

enum StartTestSetGenerationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartTestSetGenerationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartTestSetGenerationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.generationDataSource = output.generationDataSource
            self.roleArn = output.roleArn
            self.storageLocation = output.storageLocation
            self.testSetGenerationId = output.testSetGenerationId
            self.testSetGenerationStatus = output.testSetGenerationStatus
            self.testSetName = output.testSetName
            self.testSetTags = output.testSetTags
        } else {
            self.creationDateTime = nil
            self.description = nil
            self.generationDataSource = nil
            self.roleArn = nil
            self.storageLocation = nil
            self.testSetGenerationId = nil
            self.testSetGenerationStatus = nil
            self.testSetName = nil
            self.testSetTags = nil
        }
    }
}

public struct StartTestSetGenerationOutputResponse: Swift.Equatable {
    /// The creation date and time for the test set generation.
    public var creationDateTime: ClientRuntime.Date?
    /// The description used for the test set generation.
    public var description: Swift.String?
    /// The data source for the test set generation.
    public var generationDataSource: LexModelsV2ClientTypes.TestSetGenerationDataSource?
    /// The roleARN used for any operation in the test set to access resources in the Amazon Web Services account.
    public var roleArn: Swift.String?
    /// The Amazon S3 storage location for the test set generation.
    public var storageLocation: LexModelsV2ClientTypes.TestSetStorageLocation?
    /// The unique identifier of the test set generation to describe.
    public var testSetGenerationId: Swift.String?
    /// The status for the test set generation.
    public var testSetGenerationStatus: LexModelsV2ClientTypes.TestSetGenerationStatus?
    /// The test set name used for the test set generation.
    public var testSetName: Swift.String?
    /// A list of tags that was used for the test set that is being generated.
    public var testSetTags: [Swift.String:Swift.String]?

    public init(
        creationDateTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        generationDataSource: LexModelsV2ClientTypes.TestSetGenerationDataSource? = nil,
        roleArn: Swift.String? = nil,
        storageLocation: LexModelsV2ClientTypes.TestSetStorageLocation? = nil,
        testSetGenerationId: Swift.String? = nil,
        testSetGenerationStatus: LexModelsV2ClientTypes.TestSetGenerationStatus? = nil,
        testSetName: Swift.String? = nil,
        testSetTags: [Swift.String:Swift.String]? = nil
    )
    {
        self.creationDateTime = creationDateTime
        self.description = description
        self.generationDataSource = generationDataSource
        self.roleArn = roleArn
        self.storageLocation = storageLocation
        self.testSetGenerationId = testSetGenerationId
        self.testSetGenerationStatus = testSetGenerationStatus
        self.testSetName = testSetName
        self.testSetTags = testSetTags
    }
}

struct StartTestSetGenerationOutputResponseBody: Swift.Equatable {
    let testSetGenerationId: Swift.String?
    let creationDateTime: ClientRuntime.Date?
    let testSetGenerationStatus: LexModelsV2ClientTypes.TestSetGenerationStatus?
    let testSetName: Swift.String?
    let description: Swift.String?
    let storageLocation: LexModelsV2ClientTypes.TestSetStorageLocation?
    let generationDataSource: LexModelsV2ClientTypes.TestSetGenerationDataSource?
    let roleArn: Swift.String?
    let testSetTags: [Swift.String:Swift.String]?
}

extension StartTestSetGenerationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case description
        case generationDataSource
        case roleArn
        case storageLocation
        case testSetGenerationId
        case testSetGenerationStatus
        case testSetName
        case testSetTags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testSetGenerationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testSetGenerationId)
        testSetGenerationId = testSetGenerationIdDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let testSetGenerationStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestSetGenerationStatus.self, forKey: .testSetGenerationStatus)
        testSetGenerationStatus = testSetGenerationStatusDecoded
        let testSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testSetName)
        testSetName = testSetNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let storageLocationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestSetStorageLocation.self, forKey: .storageLocation)
        storageLocation = storageLocationDecoded
        let generationDataSourceDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestSetGenerationDataSource.self, forKey: .generationDataSource)
        generationDataSource = generationDataSourceDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let testSetTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .testSetTags)
        var testSetTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let testSetTagsContainer = testSetTagsContainer {
            testSetTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in testSetTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    testSetTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        testSetTags = testSetTagsDecoded0
    }
}

extension LexModelsV2ClientTypes.StillWaitingResponseSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowInterrupt
        case frequencyInSeconds
        case messageGroups
        case timeoutInSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowInterrupt = self.allowInterrupt {
            try encodeContainer.encode(allowInterrupt, forKey: .allowInterrupt)
        }
        if let frequencyInSeconds = self.frequencyInSeconds {
            try encodeContainer.encode(frequencyInSeconds, forKey: .frequencyInSeconds)
        }
        if let messageGroups = messageGroups {
            var messageGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .messageGroups)
            for messagegroup0 in messageGroups {
                try messageGroupsContainer.encode(messagegroup0)
            }
        }
        if let timeoutInSeconds = self.timeoutInSeconds {
            try encodeContainer.encode(timeoutInSeconds, forKey: .timeoutInSeconds)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageGroupsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.MessageGroup?].self, forKey: .messageGroups)
        var messageGroupsDecoded0:[LexModelsV2ClientTypes.MessageGroup]? = nil
        if let messageGroupsContainer = messageGroupsContainer {
            messageGroupsDecoded0 = [LexModelsV2ClientTypes.MessageGroup]()
            for structure0 in messageGroupsContainer {
                if let structure0 = structure0 {
                    messageGroupsDecoded0?.append(structure0)
                }
            }
        }
        messageGroups = messageGroupsDecoded0
        let frequencyInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .frequencyInSeconds)
        frequencyInSeconds = frequencyInSecondsDecoded
        let timeoutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInSeconds)
        timeoutInSeconds = timeoutInSecondsDecoded
        let allowInterruptDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowInterrupt)
        allowInterrupt = allowInterruptDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Defines the messages that Amazon Lex sends to a user to remind them that the bot is waiting for a response.
    public struct StillWaitingResponseSpecification: Swift.Equatable {
        /// Indicates that the user can interrupt the response by speaking while the message is being played.
        public var allowInterrupt: Swift.Bool?
        /// How often a message should be sent to the user. Minimum of 1 second, maximum of 5 minutes.
        /// This member is required.
        public var frequencyInSeconds: Swift.Int?
        /// One or more message groups, each containing one or more messages, that define the prompts that Amazon Lex sends to the user.
        /// This member is required.
        public var messageGroups: [LexModelsV2ClientTypes.MessageGroup]?
        /// If Amazon Lex waits longer than this length of time for a response, it will stop sending messages.
        /// This member is required.
        public var timeoutInSeconds: Swift.Int?

        public init(
            allowInterrupt: Swift.Bool? = nil,
            frequencyInSeconds: Swift.Int? = nil,
            messageGroups: [LexModelsV2ClientTypes.MessageGroup]? = nil,
            timeoutInSeconds: Swift.Int? = nil
        )
        {
            self.allowInterrupt = allowInterrupt
            self.frequencyInSeconds = frequencyInSeconds
            self.messageGroups = messageGroups
            self.timeoutInSeconds = timeoutInSeconds
        }
    }

}

extension StopBotRecommendationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botVersion = botVersion else {
            return nil
        }
        guard let localeId = localeId else {
            return nil
        }
        guard let botRecommendationId = botRecommendationId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botversions/\(botVersion.urlPercentEncoding())/botlocales/\(localeId.urlPercentEncoding())/botrecommendations/\(botRecommendationId.urlPercentEncoding())/stopbotrecommendation"
    }
}

public struct StopBotRecommendationInput: Swift.Equatable {
    /// The unique identifier of the bot containing the bot recommendation to be stopped.
    /// This member is required.
    public var botId: Swift.String?
    /// The unique identifier of the bot recommendation to be stopped.
    /// This member is required.
    public var botRecommendationId: Swift.String?
    /// The version of the bot containing the bot recommendation.
    /// This member is required.
    public var botVersion: Swift.String?
    /// The identifier of the language and locale of the bot recommendation to stop. The string must match one of the supported locales. For more information, see [Supported languages](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html)
    /// This member is required.
    public var localeId: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botRecommendationId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        localeId: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botRecommendationId = botRecommendationId
        self.botVersion = botVersion
        self.localeId = localeId
    }
}

struct StopBotRecommendationInputBody: Swift.Equatable {
}

extension StopBotRecommendationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum StopBotRecommendationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopBotRecommendationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StopBotRecommendationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botRecommendationId = output.botRecommendationId
            self.botRecommendationStatus = output.botRecommendationStatus
            self.botVersion = output.botVersion
            self.localeId = output.localeId
        } else {
            self.botId = nil
            self.botRecommendationId = nil
            self.botRecommendationStatus = nil
            self.botVersion = nil
            self.localeId = nil
        }
    }
}

public struct StopBotRecommendationOutputResponse: Swift.Equatable {
    /// The unique identifier of the bot containing the bot recommendation that is being stopped.
    public var botId: Swift.String?
    /// The unique identifier of the bot recommendation that is being stopped.
    public var botRecommendationId: Swift.String?
    /// The status of the bot recommendation. If the status is Failed, then the reasons for the failure are listed in the failureReasons field.
    public var botRecommendationStatus: LexModelsV2ClientTypes.BotRecommendationStatus?
    /// The version of the bot containing the recommendation that is being stopped.
    public var botVersion: Swift.String?
    /// The identifier of the language and locale of the bot response to stop. The string must match one of the supported locales. For more information, see [Supported languages](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html)
    public var localeId: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botRecommendationId: Swift.String? = nil,
        botRecommendationStatus: LexModelsV2ClientTypes.BotRecommendationStatus? = nil,
        botVersion: Swift.String? = nil,
        localeId: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botRecommendationId = botRecommendationId
        self.botRecommendationStatus = botRecommendationStatus
        self.botVersion = botVersion
        self.localeId = localeId
    }
}

struct StopBotRecommendationOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let botVersion: Swift.String?
    let localeId: Swift.String?
    let botRecommendationStatus: LexModelsV2ClientTypes.BotRecommendationStatus?
    let botRecommendationId: Swift.String?
}

extension StopBotRecommendationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botRecommendationId
        case botRecommendationStatus
        case botVersion
        case localeId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let botRecommendationStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotRecommendationStatus.self, forKey: .botRecommendationStatus)
        botRecommendationStatus = botRecommendationStatusDecoded
        let botRecommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botRecommendationId)
        botRecommendationId = botRecommendationIdDecoded
    }
}

extension LexModelsV2ClientTypes.SubSlotSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expression
        case slotSpecifications
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let slotSpecifications = slotSpecifications {
            var slotSpecificationsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .slotSpecifications)
            for (dictKey0, subSlotSpecificationMap0) in slotSpecifications {
                try slotSpecificationsContainer.encode(subSlotSpecificationMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let slotSpecificationsContainer = try containerValues.decodeIfPresent([Swift.String: LexModelsV2ClientTypes.Specifications?].self, forKey: .slotSpecifications)
        var slotSpecificationsDecoded0: [Swift.String:LexModelsV2ClientTypes.Specifications]? = nil
        if let slotSpecificationsContainer = slotSpecificationsContainer {
            slotSpecificationsDecoded0 = [Swift.String:LexModelsV2ClientTypes.Specifications]()
            for (key0, specifications0) in slotSpecificationsContainer {
                if let specifications0 = specifications0 {
                    slotSpecificationsDecoded0?[key0] = specifications0
                }
            }
        }
        slotSpecifications = slotSpecificationsDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// Specifications for the constituent sub slots and the expression for the composite slot.
    public struct SubSlotSetting: Swift.Equatable {
        /// The expression text for defining the constituent sub slots in the composite slot using logical AND and OR operators.
        public var expression: Swift.String?
        /// Specifications for the constituent sub slots of a composite slot.
        public var slotSpecifications: [Swift.String:LexModelsV2ClientTypes.Specifications]?

        public init(
            expression: Swift.String? = nil,
            slotSpecifications: [Swift.String:LexModelsV2ClientTypes.Specifications]? = nil
        )
        {
            self.expression = expression
            self.slotSpecifications = slotSpecifications
        }
    }

}

extension LexModelsV2ClientTypes.SubSlotTypeComposition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case slotTypeId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let slotTypeId = self.slotTypeId {
            try encodeContainer.encode(slotTypeId, forKey: .slotTypeId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let slotTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotTypeId)
        slotTypeId = slotTypeIdDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Subslot type composition.
    public struct SubSlotTypeComposition: Swift.Equatable {
        /// Name of a constituent sub slot inside a composite slot.
        /// This member is required.
        public var name: Swift.String?
        /// The unique identifier assigned to a slot type. This refers to either a built-in slot type or the unique slotTypeId of a custom slot type.
        /// This member is required.
        public var slotTypeId: Swift.String?

        public init(
            name: Swift.String? = nil,
            slotTypeId: Swift.String? = nil
        )
        {
            self.name = name
            self.slotTypeId = slotTypeId
        }
    }

}

extension LexModelsV2ClientTypes.SubSlotValueElicitationSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValueSpecification
        case promptSpecification
        case sampleUtterances
        case waitAndContinueSpecification
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValueSpecification = self.defaultValueSpecification {
            try encodeContainer.encode(defaultValueSpecification, forKey: .defaultValueSpecification)
        }
        if let promptSpecification = self.promptSpecification {
            try encodeContainer.encode(promptSpecification, forKey: .promptSpecification)
        }
        if let sampleUtterances = sampleUtterances {
            var sampleUtterancesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sampleUtterances)
            for sampleutterance0 in sampleUtterances {
                try sampleUtterancesContainer.encode(sampleutterance0)
            }
        }
        if let waitAndContinueSpecification = self.waitAndContinueSpecification {
            try encodeContainer.encode(waitAndContinueSpecification, forKey: .waitAndContinueSpecification)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueSpecificationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SlotDefaultValueSpecification.self, forKey: .defaultValueSpecification)
        defaultValueSpecification = defaultValueSpecificationDecoded
        let promptSpecificationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.PromptSpecification.self, forKey: .promptSpecification)
        promptSpecification = promptSpecificationDecoded
        let sampleUtterancesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.SampleUtterance?].self, forKey: .sampleUtterances)
        var sampleUtterancesDecoded0:[LexModelsV2ClientTypes.SampleUtterance]? = nil
        if let sampleUtterancesContainer = sampleUtterancesContainer {
            sampleUtterancesDecoded0 = [LexModelsV2ClientTypes.SampleUtterance]()
            for structure0 in sampleUtterancesContainer {
                if let structure0 = structure0 {
                    sampleUtterancesDecoded0?.append(structure0)
                }
            }
        }
        sampleUtterances = sampleUtterancesDecoded0
        let waitAndContinueSpecificationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.WaitAndContinueSpecification.self, forKey: .waitAndContinueSpecification)
        waitAndContinueSpecification = waitAndContinueSpecificationDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Subslot elicitation settings. DefaultValueSpecification is a list of default values for a constituent sub slot in a composite slot. Default values are used when Amazon Lex hasn't determined a value for a slot. You can specify default values from context variables, session attributes, and defined values. This is similar to DefaultValueSpecification for slots. PromptSpecification is the prompt that Amazon Lex uses to elicit the sub slot value from the user. This is similar to PromptSpecification for slots.
    public struct SubSlotValueElicitationSetting: Swift.Equatable {
        /// Defines a list of values that Amazon Lex should use as the default value for a slot.
        public var defaultValueSpecification: LexModelsV2ClientTypes.SlotDefaultValueSpecification?
        /// Specifies a list of message groups that Amazon Lex sends to a user to elicit a response.
        /// This member is required.
        public var promptSpecification: LexModelsV2ClientTypes.PromptSpecification?
        /// If you know a specific pattern that users might respond to an Amazon Lex request for a sub slot value, you can provide those utterances to improve accuracy. This is optional. In most cases Amazon Lex is capable of understanding user utterances. This is similar to SampleUtterances for slots.
        public var sampleUtterances: [LexModelsV2ClientTypes.SampleUtterance]?
        /// Specifies the prompts that Amazon Lex uses while a bot is waiting for customer input.
        public var waitAndContinueSpecification: LexModelsV2ClientTypes.WaitAndContinueSpecification?

        public init(
            defaultValueSpecification: LexModelsV2ClientTypes.SlotDefaultValueSpecification? = nil,
            promptSpecification: LexModelsV2ClientTypes.PromptSpecification? = nil,
            sampleUtterances: [LexModelsV2ClientTypes.SampleUtterance]? = nil,
            waitAndContinueSpecification: LexModelsV2ClientTypes.WaitAndContinueSpecification? = nil
        )
        {
            self.defaultValueSpecification = defaultValueSpecification
            self.promptSpecification = promptSpecification
            self.sampleUtterances = sampleUtterances
            self.waitAndContinueSpecification = waitAndContinueSpecification
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceARN = resourceARN else {
            return nil
        }
        return "/tags/\(resourceARN.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the bot, bot alias, or bot channel to tag.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of tag keys to add to the resource. If a tag key already exists, the existing value is replaced with the new value.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() { }
}

extension LexModelsV2ClientTypes {
    public enum TestExecutionApiMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case nonstreaming
        case streaming
        case sdkUnknown(Swift.String)

        public static var allCases: [TestExecutionApiMode] {
            return [
                .nonstreaming,
                .streaming,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .nonstreaming: return "NonStreaming"
            case .streaming: return "Streaming"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TestExecutionApiMode(rawValue: rawValue) ?? TestExecutionApiMode.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes {
    public enum TestExecutionModality: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case audio
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [TestExecutionModality] {
            return [
                .audio,
                .text,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .audio: return "Audio"
            case .text: return "Text"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TestExecutionModality(rawValue: rawValue) ?? TestExecutionModality.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.TestExecutionResultFilterBy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conversationLevelTestResultsFilterBy
        case resultTypeFilter
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conversationLevelTestResultsFilterBy = self.conversationLevelTestResultsFilterBy {
            try encodeContainer.encode(conversationLevelTestResultsFilterBy, forKey: .conversationLevelTestResultsFilterBy)
        }
        if let resultTypeFilter = self.resultTypeFilter {
            try encodeContainer.encode(resultTypeFilter.rawValue, forKey: .resultTypeFilter)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultTypeFilterDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestResultTypeFilter.self, forKey: .resultTypeFilter)
        resultTypeFilter = resultTypeFilterDecoded
        let conversationLevelTestResultsFilterByDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ConversationLevelTestResultsFilterBy.self, forKey: .conversationLevelTestResultsFilterBy)
        conversationLevelTestResultsFilterBy = conversationLevelTestResultsFilterByDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Contains information about the method by which to filter the results of the test execution.
    public struct TestExecutionResultFilterBy: Swift.Equatable {
        /// Contains information about the method for filtering Conversation level test results.
        public var conversationLevelTestResultsFilterBy: LexModelsV2ClientTypes.ConversationLevelTestResultsFilterBy?
        /// Specifies which results to filter. See [Test result details">Test results details](https://docs.aws.amazon.com/lexv2/latest/dg/test-results-details-test-set.html) for details about different types of results.
        /// This member is required.
        public var resultTypeFilter: LexModelsV2ClientTypes.TestResultTypeFilter?

        public init(
            conversationLevelTestResultsFilterBy: LexModelsV2ClientTypes.ConversationLevelTestResultsFilterBy? = nil,
            resultTypeFilter: LexModelsV2ClientTypes.TestResultTypeFilter? = nil
        )
        {
            self.conversationLevelTestResultsFilterBy = conversationLevelTestResultsFilterBy
            self.resultTypeFilter = resultTypeFilter
        }
    }

}

extension LexModelsV2ClientTypes.TestExecutionResultItems: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conversationLevelTestResults
        case intentClassificationTestResults
        case intentLevelSlotResolutionTestResults
        case overallTestResults
        case utteranceLevelTestResults
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conversationLevelTestResults = self.conversationLevelTestResults {
            try encodeContainer.encode(conversationLevelTestResults, forKey: .conversationLevelTestResults)
        }
        if let intentClassificationTestResults = self.intentClassificationTestResults {
            try encodeContainer.encode(intentClassificationTestResults, forKey: .intentClassificationTestResults)
        }
        if let intentLevelSlotResolutionTestResults = self.intentLevelSlotResolutionTestResults {
            try encodeContainer.encode(intentLevelSlotResolutionTestResults, forKey: .intentLevelSlotResolutionTestResults)
        }
        if let overallTestResults = self.overallTestResults {
            try encodeContainer.encode(overallTestResults, forKey: .overallTestResults)
        }
        if let utteranceLevelTestResults = self.utteranceLevelTestResults {
            try encodeContainer.encode(utteranceLevelTestResults, forKey: .utteranceLevelTestResults)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let overallTestResultsDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.OverallTestResults.self, forKey: .overallTestResults)
        overallTestResults = overallTestResultsDecoded
        let conversationLevelTestResultsDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ConversationLevelTestResults.self, forKey: .conversationLevelTestResults)
        conversationLevelTestResults = conversationLevelTestResultsDecoded
        let intentClassificationTestResultsDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.IntentClassificationTestResults.self, forKey: .intentClassificationTestResults)
        intentClassificationTestResults = intentClassificationTestResultsDecoded
        let intentLevelSlotResolutionTestResultsDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.IntentLevelSlotResolutionTestResults.self, forKey: .intentLevelSlotResolutionTestResults)
        intentLevelSlotResolutionTestResults = intentLevelSlotResolutionTestResultsDecoded
        let utteranceLevelTestResultsDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.UtteranceLevelTestResults.self, forKey: .utteranceLevelTestResults)
        utteranceLevelTestResults = utteranceLevelTestResultsDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Contains the results of the test execution, grouped by type of results. See [Test result details">Test results details](https://docs.aws.amazon.com/lexv2/latest/dg/test-results-details-test-set.html) for details about different types of results.
    public struct TestExecutionResultItems: Swift.Equatable {
        /// Results related to conversations in the test set, including metrics about success and failure of conversations and intent and slot failures.
        public var conversationLevelTestResults: LexModelsV2ClientTypes.ConversationLevelTestResults?
        /// Intent recognition results aggregated by intent name. The aggregated results contain success and failure rates of intent recognition, speech transcriptions, and end-to-end conversations.
        public var intentClassificationTestResults: LexModelsV2ClientTypes.IntentClassificationTestResults?
        /// Slot resolution results aggregated by intent and slot name. The aggregated results contain success and failure rates of slot resolution, speech transcriptions, and end-to-end conversations
        public var intentLevelSlotResolutionTestResults: LexModelsV2ClientTypes.IntentLevelSlotResolutionTestResults?
        /// Overall results for the test execution, including the breakdown of conversations and single-input utterances.
        public var overallTestResults: LexModelsV2ClientTypes.OverallTestResults?
        /// Results related to utterances in the test set.
        public var utteranceLevelTestResults: LexModelsV2ClientTypes.UtteranceLevelTestResults?

        public init(
            conversationLevelTestResults: LexModelsV2ClientTypes.ConversationLevelTestResults? = nil,
            intentClassificationTestResults: LexModelsV2ClientTypes.IntentClassificationTestResults? = nil,
            intentLevelSlotResolutionTestResults: LexModelsV2ClientTypes.IntentLevelSlotResolutionTestResults? = nil,
            overallTestResults: LexModelsV2ClientTypes.OverallTestResults? = nil,
            utteranceLevelTestResults: LexModelsV2ClientTypes.UtteranceLevelTestResults? = nil
        )
        {
            self.conversationLevelTestResults = conversationLevelTestResults
            self.intentClassificationTestResults = intentClassificationTestResults
            self.intentLevelSlotResolutionTestResults = intentLevelSlotResolutionTestResults
            self.overallTestResults = overallTestResults
            self.utteranceLevelTestResults = utteranceLevelTestResults
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum TestExecutionSortAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creationdatetime
        case testsetname
        case sdkUnknown(Swift.String)

        public static var allCases: [TestExecutionSortAttribute] {
            return [
                .creationdatetime,
                .testsetname,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creationdatetime: return "CreationDateTime"
            case .testsetname: return "TestSetName"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TestExecutionSortAttribute(rawValue: rawValue) ?? TestExecutionSortAttribute.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.TestExecutionSortBy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute
        case order
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = self.attribute {
            try encodeContainer.encode(attribute.rawValue, forKey: .attribute)
        }
        if let order = self.order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestExecutionSortAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let orderDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SortOrder.self, forKey: .order)
        order = orderDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Contains information about the method by which to sort the instances of test executions you have carried out.
    public struct TestExecutionSortBy: Swift.Equatable {
        /// Specifies whether to sort the test set executions by the date and time at which the test sets were created.
        /// This member is required.
        public var attribute: LexModelsV2ClientTypes.TestExecutionSortAttribute?
        /// Specifies whether to sort in ascending or descending order.
        /// This member is required.
        public var order: LexModelsV2ClientTypes.SortOrder?

        public init(
            attribute: LexModelsV2ClientTypes.TestExecutionSortAttribute? = nil,
            order: LexModelsV2ClientTypes.SortOrder? = nil
        )
        {
            self.attribute = attribute
            self.order = order
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum TestExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case inprogress
        case pending
        case stopped
        case stopping
        case waiting
        case sdkUnknown(Swift.String)

        public static var allCases: [TestExecutionStatus] {
            return [
                .completed,
                .failed,
                .inprogress,
                .pending,
                .stopped,
                .stopping,
                .waiting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .pending: return "Pending"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case .waiting: return "Waiting"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TestExecutionStatus(rawValue: rawValue) ?? TestExecutionStatus.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.TestExecutionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiMode
        case creationDateTime
        case lastUpdatedDateTime
        case target
        case testExecutionId
        case testExecutionModality
        case testExecutionStatus
        case testSetId
        case testSetName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiMode = self.apiMode {
            try encodeContainer.encode(apiMode.rawValue, forKey: .apiMode)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let target = self.target {
            try encodeContainer.encode(target, forKey: .target)
        }
        if let testExecutionId = self.testExecutionId {
            try encodeContainer.encode(testExecutionId, forKey: .testExecutionId)
        }
        if let testExecutionModality = self.testExecutionModality {
            try encodeContainer.encode(testExecutionModality.rawValue, forKey: .testExecutionModality)
        }
        if let testExecutionStatus = self.testExecutionStatus {
            try encodeContainer.encode(testExecutionStatus.rawValue, forKey: .testExecutionStatus)
        }
        if let testSetId = self.testSetId {
            try encodeContainer.encode(testSetId, forKey: .testSetId)
        }
        if let testSetName = self.testSetName {
            try encodeContainer.encode(testSetName, forKey: .testSetName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testExecutionId)
        testExecutionId = testExecutionIdDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let testExecutionStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestExecutionStatus.self, forKey: .testExecutionStatus)
        testExecutionStatus = testExecutionStatusDecoded
        let testSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testSetId)
        testSetId = testSetIdDecoded
        let testSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testSetName)
        testSetName = testSetNameDecoded
        let targetDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestExecutionTarget.self, forKey: .target)
        target = targetDecoded
        let apiModeDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestExecutionApiMode.self, forKey: .apiMode)
        apiMode = apiModeDecoded
        let testExecutionModalityDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestExecutionModality.self, forKey: .testExecutionModality)
        testExecutionModality = testExecutionModalityDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Summarizes metadata about the test execution.
    public struct TestExecutionSummary: Swift.Equatable {
        /// Specifies whether the API mode for the test execution is streaming or non-streaming.
        public var apiMode: LexModelsV2ClientTypes.TestExecutionApiMode?
        /// The date and time at which the test execution was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The date and time at which the test execution was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// Contains information about the bot used for the test execution..
        public var target: LexModelsV2ClientTypes.TestExecutionTarget?
        /// The unique identifier of the test execution.
        public var testExecutionId: Swift.String?
        /// Specifies whether the data used for the test execution is written or spoken.
        public var testExecutionModality: LexModelsV2ClientTypes.TestExecutionModality?
        /// The current status of the test execution.
        public var testExecutionStatus: LexModelsV2ClientTypes.TestExecutionStatus?
        /// The unique identifier of the test set used in the test execution.
        public var testSetId: Swift.String?
        /// The name of the test set used in the test execution.
        public var testSetName: Swift.String?

        public init(
            apiMode: LexModelsV2ClientTypes.TestExecutionApiMode? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            target: LexModelsV2ClientTypes.TestExecutionTarget? = nil,
            testExecutionId: Swift.String? = nil,
            testExecutionModality: LexModelsV2ClientTypes.TestExecutionModality? = nil,
            testExecutionStatus: LexModelsV2ClientTypes.TestExecutionStatus? = nil,
            testSetId: Swift.String? = nil,
            testSetName: Swift.String? = nil
        )
        {
            self.apiMode = apiMode
            self.creationDateTime = creationDateTime
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.target = target
            self.testExecutionId = testExecutionId
            self.testExecutionModality = testExecutionModality
            self.testExecutionStatus = testExecutionStatus
            self.testSetId = testSetId
            self.testSetName = testSetName
        }
    }

}

extension LexModelsV2ClientTypes.TestExecutionTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botAliasTarget
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botAliasTarget = self.botAliasTarget {
            try encodeContainer.encode(botAliasTarget, forKey: .botAliasTarget)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botAliasTargetDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotAliasTestExecutionTarget.self, forKey: .botAliasTarget)
        botAliasTarget = botAliasTargetDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Contains information about the bot used for the test execution.
    public struct TestExecutionTarget: Swift.Equatable {
        /// Contains information about the bot alias used for the test execution.
        public var botAliasTarget: LexModelsV2ClientTypes.BotAliasTestExecutionTarget?

        public init(
            botAliasTarget: LexModelsV2ClientTypes.BotAliasTestExecutionTarget? = nil
        )
        {
            self.botAliasTarget = botAliasTarget
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum TestResultMatchStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case executionerror
        case matched
        case mismatched
        case sdkUnknown(Swift.String)

        public static var allCases: [TestResultMatchStatus] {
            return [
                .executionerror,
                .matched,
                .mismatched,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .executionerror: return "ExecutionError"
            case .matched: return "Matched"
            case .mismatched: return "Mismatched"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TestResultMatchStatus(rawValue: rawValue) ?? TestResultMatchStatus.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes {
    public enum TestResultTypeFilter: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case conversationleveltestresults
        case intentclassificationtestresults
        case overalltestresults
        case slotresolutiontestresults
        case utterancelevelresults
        case sdkUnknown(Swift.String)

        public static var allCases: [TestResultTypeFilter] {
            return [
                .conversationleveltestresults,
                .intentclassificationtestresults,
                .overalltestresults,
                .slotresolutiontestresults,
                .utterancelevelresults,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .conversationleveltestresults: return "ConversationLevelTestResults"
            case .intentclassificationtestresults: return "IntentClassificationTestResults"
            case .overalltestresults: return "OverallTestResults"
            case .slotresolutiontestresults: return "SlotResolutionTestResults"
            case .utterancelevelresults: return "UtteranceLevelResults"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TestResultTypeFilter(rawValue: rawValue) ?? TestResultTypeFilter.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.TestSetDiscrepancyErrors: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case intentDiscrepancies
        case slotDiscrepancies
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let intentDiscrepancies = intentDiscrepancies {
            var intentDiscrepanciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .intentDiscrepancies)
            for testsetintentdiscrepancyitem0 in intentDiscrepancies {
                try intentDiscrepanciesContainer.encode(testsetintentdiscrepancyitem0)
            }
        }
        if let slotDiscrepancies = slotDiscrepancies {
            var slotDiscrepanciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .slotDiscrepancies)
            for testsetslotdiscrepancyitem0 in slotDiscrepancies {
                try slotDiscrepanciesContainer.encode(testsetslotdiscrepancyitem0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intentDiscrepanciesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.TestSetIntentDiscrepancyItem?].self, forKey: .intentDiscrepancies)
        var intentDiscrepanciesDecoded0:[LexModelsV2ClientTypes.TestSetIntentDiscrepancyItem]? = nil
        if let intentDiscrepanciesContainer = intentDiscrepanciesContainer {
            intentDiscrepanciesDecoded0 = [LexModelsV2ClientTypes.TestSetIntentDiscrepancyItem]()
            for structure0 in intentDiscrepanciesContainer {
                if let structure0 = structure0 {
                    intentDiscrepanciesDecoded0?.append(structure0)
                }
            }
        }
        intentDiscrepancies = intentDiscrepanciesDecoded0
        let slotDiscrepanciesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.TestSetSlotDiscrepancyItem?].self, forKey: .slotDiscrepancies)
        var slotDiscrepanciesDecoded0:[LexModelsV2ClientTypes.TestSetSlotDiscrepancyItem]? = nil
        if let slotDiscrepanciesContainer = slotDiscrepanciesContainer {
            slotDiscrepanciesDecoded0 = [LexModelsV2ClientTypes.TestSetSlotDiscrepancyItem]()
            for structure0 in slotDiscrepanciesContainer {
                if let structure0 = structure0 {
                    slotDiscrepanciesDecoded0?.append(structure0)
                }
            }
        }
        slotDiscrepancies = slotDiscrepanciesDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// Contains details about the errors in the test set discrepancy report
    public struct TestSetDiscrepancyErrors: Swift.Equatable {
        /// Contains information about discrepancies found for intents between the test set and the bot.
        /// This member is required.
        public var intentDiscrepancies: [LexModelsV2ClientTypes.TestSetIntentDiscrepancyItem]?
        /// Contains information about discrepancies found for slots between the test set and the bot.
        /// This member is required.
        public var slotDiscrepancies: [LexModelsV2ClientTypes.TestSetSlotDiscrepancyItem]?

        public init(
            intentDiscrepancies: [LexModelsV2ClientTypes.TestSetIntentDiscrepancyItem]? = nil,
            slotDiscrepancies: [LexModelsV2ClientTypes.TestSetSlotDiscrepancyItem]? = nil
        )
        {
            self.intentDiscrepancies = intentDiscrepancies
            self.slotDiscrepancies = slotDiscrepancies
        }
    }

}

extension LexModelsV2ClientTypes.TestSetDiscrepancyReportBotAliasTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botAliasId
        case botId
        case localeId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botAliasId = self.botAliasId {
            try encodeContainer.encode(botAliasId, forKey: .botAliasId)
        }
        if let botId = self.botId {
            try encodeContainer.encode(botId, forKey: .botId)
        }
        if let localeId = self.localeId {
            try encodeContainer.encode(localeId, forKey: .localeId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botAliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botAliasId)
        botAliasId = botAliasIdDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Contains information about the bot alias used for the test set discrepancy report.
    public struct TestSetDiscrepancyReportBotAliasTarget: Swift.Equatable {
        /// The unique identifier for the bot associated with the bot alias.
        /// This member is required.
        public var botAliasId: Swift.String?
        /// The unique identifier for the bot alias.
        /// This member is required.
        public var botId: Swift.String?
        /// The unique identifier of the locale associated with the bot alias.
        /// This member is required.
        public var localeId: Swift.String?

        public init(
            botAliasId: Swift.String? = nil,
            botId: Swift.String? = nil,
            localeId: Swift.String? = nil
        )
        {
            self.botAliasId = botAliasId
            self.botId = botId
            self.localeId = localeId
        }
    }

}

extension LexModelsV2ClientTypes.TestSetDiscrepancyReportResourceTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botAliasTarget
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botAliasTarget = self.botAliasTarget {
            try encodeContainer.encode(botAliasTarget, forKey: .botAliasTarget)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botAliasTargetDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestSetDiscrepancyReportBotAliasTarget.self, forKey: .botAliasTarget)
        botAliasTarget = botAliasTargetDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Contains information about the resource used for the test set discrepancy report.
    public struct TestSetDiscrepancyReportResourceTarget: Swift.Equatable {
        /// Contains information about the bot alias used as the resource for the test set discrepancy report.
        public var botAliasTarget: LexModelsV2ClientTypes.TestSetDiscrepancyReportBotAliasTarget?

        public init(
            botAliasTarget: LexModelsV2ClientTypes.TestSetDiscrepancyReportBotAliasTarget? = nil
        )
        {
            self.botAliasTarget = botAliasTarget
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum TestSetDiscrepancyReportStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case inprogress
        case sdkUnknown(Swift.String)

        public static var allCases: [TestSetDiscrepancyReportStatus] {
            return [
                .completed,
                .failed,
                .inprogress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TestSetDiscrepancyReportStatus(rawValue: rawValue) ?? TestSetDiscrepancyReportStatus.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.TestSetExportSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case testSetId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let testSetId = self.testSetId {
            try encodeContainer.encode(testSetId, forKey: .testSetId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testSetId)
        testSetId = testSetIdDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Contains information about the test set that is exported.
    public struct TestSetExportSpecification: Swift.Equatable {
        /// The unique identifier of the test set.
        /// This member is required.
        public var testSetId: Swift.String?

        public init(
            testSetId: Swift.String? = nil
        )
        {
            self.testSetId = testSetId
        }
    }

}

extension LexModelsV2ClientTypes.TestSetGenerationDataSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conversationLogsDataSource
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conversationLogsDataSource = self.conversationLogsDataSource {
            try encodeContainer.encode(conversationLogsDataSource, forKey: .conversationLogsDataSource)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conversationLogsDataSourceDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ConversationLogsDataSource.self, forKey: .conversationLogsDataSource)
        conversationLogsDataSource = conversationLogsDataSourceDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Contains information about the data source from which the test set is generated.
    public struct TestSetGenerationDataSource: Swift.Equatable {
        /// Contains information about the bot from which the conversation logs are sourced.
        public var conversationLogsDataSource: LexModelsV2ClientTypes.ConversationLogsDataSource?

        public init(
            conversationLogsDataSource: LexModelsV2ClientTypes.ConversationLogsDataSource? = nil
        )
        {
            self.conversationLogsDataSource = conversationLogsDataSource
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum TestSetGenerationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case generating
        case pending
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [TestSetGenerationStatus] {
            return [
                .failed,
                .generating,
                .pending,
                .ready,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .generating: return "Generating"
            case .pending: return "Pending"
            case .ready: return "Ready"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TestSetGenerationStatus(rawValue: rawValue) ?? TestSetGenerationStatus.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.TestSetImportInputLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3BucketName
        case s3Path
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3Path = self.s3Path {
            try encodeContainer.encode(s3Path, forKey: .s3Path)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3PathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Path)
        s3Path = s3PathDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Contains information about the Amazon S3 location from which the test set is imported.
    public struct TestSetImportInputLocation: Swift.Equatable {
        /// The name of the Amazon S3 bucket.
        /// This member is required.
        public var s3BucketName: Swift.String?
        /// The path inside the Amazon S3 bucket pointing to the test-set CSV file.
        /// This member is required.
        public var s3Path: Swift.String?

        public init(
            s3BucketName: Swift.String? = nil,
            s3Path: Swift.String? = nil
        )
        {
            self.s3BucketName = s3BucketName
            self.s3Path = s3Path
        }
    }

}

extension LexModelsV2ClientTypes.TestSetImportResourceSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case importInputLocation
        case modality
        case roleArn
        case storageLocation
        case testSetName
        case testSetTags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let importInputLocation = self.importInputLocation {
            try encodeContainer.encode(importInputLocation, forKey: .importInputLocation)
        }
        if let modality = self.modality {
            try encodeContainer.encode(modality.rawValue, forKey: .modality)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let storageLocation = self.storageLocation {
            try encodeContainer.encode(storageLocation, forKey: .storageLocation)
        }
        if let testSetName = self.testSetName {
            try encodeContainer.encode(testSetName, forKey: .testSetName)
        }
        if let testSetTags = testSetTags {
            var testSetTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .testSetTags)
            for (dictKey0, tagMap0) in testSetTags {
                try testSetTagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testSetName)
        testSetName = testSetNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let storageLocationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestSetStorageLocation.self, forKey: .storageLocation)
        storageLocation = storageLocationDecoded
        let importInputLocationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestSetImportInputLocation.self, forKey: .importInputLocation)
        importInputLocation = importInputLocationDecoded
        let modalityDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestSetModality.self, forKey: .modality)
        modality = modalityDecoded
        let testSetTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .testSetTags)
        var testSetTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let testSetTagsContainer = testSetTagsContainer {
            testSetTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in testSetTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    testSetTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        testSetTags = testSetTagsDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// Contains information about the test set that is imported.
    public struct TestSetImportResourceSpecification: Swift.Equatable {
        /// The description of the test set.
        public var description: Swift.String?
        /// Contains information about the input location from where test-set should be imported.
        /// This member is required.
        public var importInputLocation: LexModelsV2ClientTypes.TestSetImportInputLocation?
        /// Specifies whether the test-set being imported contains written or spoken data.
        /// This member is required.
        public var modality: LexModelsV2ClientTypes.TestSetModality?
        /// The Amazon Resource Name (ARN) of an IAM role that has permission to access the test set.
        /// This member is required.
        public var roleArn: Swift.String?
        /// Contains information about the location that Amazon Lex uses to store the test-set.
        /// This member is required.
        public var storageLocation: LexModelsV2ClientTypes.TestSetStorageLocation?
        /// The name of the test set.
        /// This member is required.
        public var testSetName: Swift.String?
        /// A list of tags to add to the test set. You can only add tags when you import/generate a new test set. You can't use the UpdateTestSet operation to update tags. To update tags, use the TagResource operation.
        public var testSetTags: [Swift.String:Swift.String]?

        public init(
            description: Swift.String? = nil,
            importInputLocation: LexModelsV2ClientTypes.TestSetImportInputLocation? = nil,
            modality: LexModelsV2ClientTypes.TestSetModality? = nil,
            roleArn: Swift.String? = nil,
            storageLocation: LexModelsV2ClientTypes.TestSetStorageLocation? = nil,
            testSetName: Swift.String? = nil,
            testSetTags: [Swift.String:Swift.String]? = nil
        )
        {
            self.description = description
            self.importInputLocation = importInputLocation
            self.modality = modality
            self.roleArn = roleArn
            self.storageLocation = storageLocation
            self.testSetName = testSetName
            self.testSetTags = testSetTags
        }
    }

}

extension LexModelsV2ClientTypes.TestSetIntentDiscrepancyItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorMessage
        case intentName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let intentName = self.intentName {
            try encodeContainer.encode(intentName, forKey: .intentName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intentName)
        intentName = intentNameDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Contains information about discrepancy in an intent information between the test set and the bot.
    public struct TestSetIntentDiscrepancyItem: Swift.Equatable {
        /// The error message for a discrepancy for an intent between the test set and the bot.
        /// This member is required.
        public var errorMessage: Swift.String?
        /// The name of the intent in the discrepancy report.
        /// This member is required.
        public var intentName: Swift.String?

        public init(
            errorMessage: Swift.String? = nil,
            intentName: Swift.String? = nil
        )
        {
            self.errorMessage = errorMessage
            self.intentName = intentName
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum TestSetModality: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case audio
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [TestSetModality] {
            return [
                .audio,
                .text,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .audio: return "Audio"
            case .text: return "Text"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TestSetModality(rawValue: rawValue) ?? TestSetModality.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.TestSetSlotDiscrepancyItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorMessage
        case intentName
        case slotName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let intentName = self.intentName {
            try encodeContainer.encode(intentName, forKey: .intentName)
        }
        if let slotName = self.slotName {
            try encodeContainer.encode(slotName, forKey: .slotName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intentName)
        intentName = intentNameDecoded
        let slotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotName)
        slotName = slotNameDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Contains information about discrepancy in a slot information between the test set and the bot.
    public struct TestSetSlotDiscrepancyItem: Swift.Equatable {
        /// The error message for a discrepancy for an intent between the test set and the bot.
        /// This member is required.
        public var errorMessage: Swift.String?
        /// The name of the intent associated with the slot in the discrepancy report.
        /// This member is required.
        public var intentName: Swift.String?
        /// The name of the slot in the discrepancy report.
        /// This member is required.
        public var slotName: Swift.String?

        public init(
            errorMessage: Swift.String? = nil,
            intentName: Swift.String? = nil,
            slotName: Swift.String? = nil
        )
        {
            self.errorMessage = errorMessage
            self.intentName = intentName
            self.slotName = slotName
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum TestSetSortAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lastupdateddatetime
        case testsetname
        case sdkUnknown(Swift.String)

        public static var allCases: [TestSetSortAttribute] {
            return [
                .lastupdateddatetime,
                .testsetname,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lastupdateddatetime: return "LastUpdatedDateTime"
            case .testsetname: return "TestSetName"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TestSetSortAttribute(rawValue: rawValue) ?? TestSetSortAttribute.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.TestSetSortBy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute
        case order
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = self.attribute {
            try encodeContainer.encode(attribute.rawValue, forKey: .attribute)
        }
        if let order = self.order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestSetSortAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let orderDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SortOrder.self, forKey: .order)
        order = orderDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Contains information about the methods by which to sort the test set.
    public struct TestSetSortBy: Swift.Equatable {
        /// Specifies whether to sort the test sets by name or by the time they were last updated.
        /// This member is required.
        public var attribute: LexModelsV2ClientTypes.TestSetSortAttribute?
        /// Specifies whether to sort in ascending or descending order.
        /// This member is required.
        public var order: LexModelsV2ClientTypes.SortOrder?

        public init(
            attribute: LexModelsV2ClientTypes.TestSetSortAttribute? = nil,
            order: LexModelsV2ClientTypes.SortOrder? = nil
        )
        {
            self.attribute = attribute
            self.order = order
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum TestSetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleting
        case importing
        case pendingannotation
        case ready
        case validationerror
        case sdkUnknown(Swift.String)

        public static var allCases: [TestSetStatus] {
            return [
                .deleting,
                .importing,
                .pendingannotation,
                .ready,
                .validationerror,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleting: return "Deleting"
            case .importing: return "Importing"
            case .pendingannotation: return "PendingAnnotation"
            case .ready: return "Ready"
            case .validationerror: return "ValidationError"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TestSetStatus(rawValue: rawValue) ?? TestSetStatus.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.TestSetStorageLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyArn
        case s3BucketName
        case s3Path
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3Path = self.s3Path {
            try encodeContainer.encode(s3Path, forKey: .s3Path)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3PathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Path)
        s3Path = s3PathDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Contains information about the location in which the test set is stored.
    public struct TestSetStorageLocation: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of an Amazon Web Services Key Management Service (KMS) key for encrypting the test set.
        public var kmsKeyArn: Swift.String?
        /// The name of the Amazon S3 bucket in which the test set is stored.
        /// This member is required.
        public var s3BucketName: Swift.String?
        /// The path inside the Amazon S3 bucket where the test set is stored.
        /// This member is required.
        public var s3Path: Swift.String?

        public init(
            kmsKeyArn: Swift.String? = nil,
            s3BucketName: Swift.String? = nil,
            s3Path: Swift.String? = nil
        )
        {
            self.kmsKeyArn = kmsKeyArn
            self.s3BucketName = s3BucketName
            self.s3Path = s3Path
        }
    }

}

extension LexModelsV2ClientTypes.TestSetSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case description
        case lastUpdatedDateTime
        case modality
        case numTurns
        case roleArn
        case status
        case storageLocation
        case testSetId
        case testSetName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let modality = self.modality {
            try encodeContainer.encode(modality.rawValue, forKey: .modality)
        }
        if let numTurns = self.numTurns {
            try encodeContainer.encode(numTurns, forKey: .numTurns)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let storageLocation = self.storageLocation {
            try encodeContainer.encode(storageLocation, forKey: .storageLocation)
        }
        if let testSetId = self.testSetId {
            try encodeContainer.encode(testSetId, forKey: .testSetId)
        }
        if let testSetName = self.testSetName {
            try encodeContainer.encode(testSetName, forKey: .testSetName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testSetId)
        testSetId = testSetIdDecoded
        let testSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testSetName)
        testSetName = testSetNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let modalityDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestSetModality.self, forKey: .modality)
        modality = modalityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestSetStatus.self, forKey: .status)
        status = statusDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let numTurnsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numTurns)
        numTurns = numTurnsDecoded
        let storageLocationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestSetStorageLocation.self, forKey: .storageLocation)
        storageLocation = storageLocationDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Contains summary information about the test set.
    public struct TestSetSummary: Swift.Equatable {
        /// The date and time at which the test set was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The description of the test set.
        public var description: Swift.String?
        /// The date and time at which the test set was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// Specifies whether the test set contains written or spoken data.
        public var modality: LexModelsV2ClientTypes.TestSetModality?
        /// The number of turns in the test set.
        public var numTurns: Swift.Int?
        /// The Amazon Resource Name (ARN) of an IAM role that has permission to access the test set.
        public var roleArn: Swift.String?
        /// The status of the test set.
        public var status: LexModelsV2ClientTypes.TestSetStatus?
        /// Contains information about the location at which the test set is stored.
        public var storageLocation: LexModelsV2ClientTypes.TestSetStorageLocation?
        /// The unique identifier of the test set.
        public var testSetId: Swift.String?
        /// The name of the test set.
        public var testSetName: Swift.String?

        public init(
            creationDateTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            modality: LexModelsV2ClientTypes.TestSetModality? = nil,
            numTurns: Swift.Int? = nil,
            roleArn: Swift.String? = nil,
            status: LexModelsV2ClientTypes.TestSetStatus? = nil,
            storageLocation: LexModelsV2ClientTypes.TestSetStorageLocation? = nil,
            testSetId: Swift.String? = nil,
            testSetName: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.description = description
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.modality = modality
            self.numTurns = numTurns
            self.roleArn = roleArn
            self.status = status
            self.storageLocation = storageLocation
            self.testSetId = testSetId
            self.testSetName = testSetName
        }
    }

}

extension LexModelsV2ClientTypes.TestSetTurnRecord: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conversationId
        case recordNumber
        case turnNumber
        case turnSpecification
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conversationId = self.conversationId {
            try encodeContainer.encode(conversationId, forKey: .conversationId)
        }
        if let recordNumber = self.recordNumber {
            try encodeContainer.encode(recordNumber, forKey: .recordNumber)
        }
        if let turnNumber = self.turnNumber {
            try encodeContainer.encode(turnNumber, forKey: .turnNumber)
        }
        if let turnSpecification = self.turnSpecification {
            try encodeContainer.encode(turnSpecification, forKey: .turnSpecification)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recordNumber)
        recordNumber = recordNumberDecoded
        let conversationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conversationId)
        conversationId = conversationIdDecoded
        let turnNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .turnNumber)
        turnNumber = turnNumberDecoded
        let turnSpecificationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TurnSpecification.self, forKey: .turnSpecification)
        turnSpecification = turnSpecificationDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Contains information about a turn in a test set.
    public struct TestSetTurnRecord: Swift.Equatable {
        /// The unique identifier for the conversation associated with the turn.
        public var conversationId: Swift.String?
        /// The record number associated with the turn.
        /// This member is required.
        public var recordNumber: Swift.Int?
        /// The number of turns that has elapsed up to that turn.
        public var turnNumber: Swift.Int?
        /// Contains information about the agent or user turn depending upon type of turn.
        /// This member is required.
        public var turnSpecification: LexModelsV2ClientTypes.TurnSpecification?

        public init(
            conversationId: Swift.String? = nil,
            recordNumber: Swift.Int? = nil,
            turnNumber: Swift.Int? = nil,
            turnSpecification: LexModelsV2ClientTypes.TurnSpecification? = nil
        )
        {
            self.conversationId = conversationId
            self.recordNumber = recordNumber
            self.turnNumber = turnNumber
            self.turnSpecification = turnSpecification
        }
    }

}

extension LexModelsV2ClientTypes.TestSetTurnResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agent
        case user
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agent = self.agent {
            try encodeContainer.encode(agent, forKey: .agent)
        }
        if let user = self.user {
            try encodeContainer.encode(user, forKey: .user)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AgentTurnResult.self, forKey: .agent)
        agent = agentDecoded
        let userDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.UserTurnResult.self, forKey: .user)
        user = userDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Contains information about the results of the analysis of a turn in the test set.
    public struct TestSetTurnResult: Swift.Equatable {
        /// Contains information about the agent messages in the turn.
        public var agent: LexModelsV2ClientTypes.AgentTurnResult?
        /// Contains information about the user messages in the turn.
        public var user: LexModelsV2ClientTypes.UserTurnResult?

        public init(
            agent: LexModelsV2ClientTypes.AgentTurnResult? = nil,
            user: LexModelsV2ClientTypes.UserTurnResult? = nil
        )
        {
            self.agent = agent
            self.user = user
        }
    }

}

extension LexModelsV2ClientTypes.TextInputSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case startTimeoutMs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let startTimeoutMs = self.startTimeoutMs {
            try encodeContainer.encode(startTimeoutMs, forKey: .startTimeoutMs)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeoutMsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startTimeoutMs)
        startTimeoutMs = startTimeoutMsDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Specifies the text input specifications.
    public struct TextInputSpecification: Swift.Equatable {
        /// Time for which a bot waits before re-prompting a customer for text input.
        /// This member is required.
        public var startTimeoutMs: Swift.Int?

        public init(
            startTimeoutMs: Swift.Int? = nil
        )
        {
            self.startTimeoutMs = startTimeoutMs
        }
    }

}

extension LexModelsV2ClientTypes.TextLogDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatch
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatch = self.cloudWatch {
            try encodeContainer.encode(cloudWatch, forKey: .cloudWatch)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.CloudWatchLogGroupLogDestination.self, forKey: .cloudWatch)
        cloudWatch = cloudWatchDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Defines the Amazon CloudWatch Logs destination log group for conversation text logs.
    public struct TextLogDestination: Swift.Equatable {
        /// Defines the Amazon CloudWatch Logs log group where text and metadata logs are delivered.
        /// This member is required.
        public var cloudWatch: LexModelsV2ClientTypes.CloudWatchLogGroupLogDestination?

        public init(
            cloudWatch: LexModelsV2ClientTypes.CloudWatchLogGroupLogDestination? = nil
        )
        {
            self.cloudWatch = cloudWatch
        }
    }

}

extension LexModelsV2ClientTypes.TextLogSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination
        case enabled
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TextLogDestination.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Defines settings to enable text conversation logs.
    public struct TextLogSetting: Swift.Equatable {
        /// Defines the Amazon CloudWatch Logs destination log group for conversation text logs.
        /// This member is required.
        public var destination: LexModelsV2ClientTypes.TextLogDestination?
        /// Determines whether conversation logs should be stored for an alias.
        /// This member is required.
        public var enabled: Swift.Bool

        public init(
            destination: LexModelsV2ClientTypes.TextLogDestination? = nil,
            enabled: Swift.Bool = false
        )
        {
            self.destination = destination
            self.enabled = enabled
        }
    }

}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = 0
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Your request rate is too high. Reduce the frequency of requests.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The number of seconds after which the user can invoke the API again.
        public internal(set) var retryAfterSeconds: Swift.Int = 0
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LexModelsV2ClientTypes {
    public enum TimeDimension: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case days
        case hours
        case weeks
        case sdkUnknown(Swift.String)

        public static var allCases: [TimeDimension] {
            return [
                .days,
                .hours,
                .weeks,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .days: return "Days"
            case .hours: return "Hours"
            case .weeks: return "Weeks"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TimeDimension(rawValue: rawValue) ?? TimeDimension.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.TranscriptFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lexTranscriptFilter
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lexTranscriptFilter = self.lexTranscriptFilter {
            try encodeContainer.encode(lexTranscriptFilter, forKey: .lexTranscriptFilter)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lexTranscriptFilterDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.LexTranscriptFilter.self, forKey: .lexTranscriptFilter)
        lexTranscriptFilter = lexTranscriptFilterDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// The object representing the filter that Amazon Lex will use to select the appropriate transcript.
    public struct TranscriptFilter: Swift.Equatable {
        /// The object representing the filter that Amazon Lex will use to select the appropriate transcript when the transcript format is the Amazon Lex format.
        public var lexTranscriptFilter: LexModelsV2ClientTypes.LexTranscriptFilter?

        public init(
            lexTranscriptFilter: LexModelsV2ClientTypes.LexTranscriptFilter? = nil
        )
        {
            self.lexTranscriptFilter = lexTranscriptFilter
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum TranscriptFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lex
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscriptFormat] {
            return [
                .lex,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lex: return "Lex"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscriptFormat(rawValue: rawValue) ?? TranscriptFormat.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.TranscriptSourceSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3BucketTranscriptSource
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3BucketTranscriptSource = self.s3BucketTranscriptSource {
            try encodeContainer.encode(s3BucketTranscriptSource, forKey: .s3BucketTranscriptSource)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketTranscriptSourceDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.S3BucketTranscriptSource.self, forKey: .s3BucketTranscriptSource)
        s3BucketTranscriptSource = s3BucketTranscriptSourceDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Indicates the setting of the location where the transcript is stored.
    public struct TranscriptSourceSetting: Swift.Equatable {
        /// Indicates the setting of the Amazon S3 bucket where the transcript is stored.
        public var s3BucketTranscriptSource: LexModelsV2ClientTypes.S3BucketTranscriptSource?

        public init(
            s3BucketTranscriptSource: LexModelsV2ClientTypes.S3BucketTranscriptSource? = nil
        )
        {
            self.s3BucketTranscriptSource = s3BucketTranscriptSource
        }
    }

}

extension LexModelsV2ClientTypes.TurnSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentTurn
        case userTurn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentTurn = self.agentTurn {
            try encodeContainer.encode(agentTurn, forKey: .agentTurn)
        }
        if let userTurn = self.userTurn {
            try encodeContainer.encode(userTurn, forKey: .userTurn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentTurnDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AgentTurnSpecification.self, forKey: .agentTurn)
        agentTurn = agentTurnDecoded
        let userTurnDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.UserTurnSpecification.self, forKey: .userTurn)
        userTurn = userTurnDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Contains information about the messages in the turn.
    public struct TurnSpecification: Swift.Equatable {
        /// Contains information about the agent messages in the turn.
        public var agentTurn: LexModelsV2ClientTypes.AgentTurnSpecification?
        /// Contains information about the user messages in the turn.
        public var userTurn: LexModelsV2ClientTypes.UserTurnSpecification?

        public init(
            agentTurn: LexModelsV2ClientTypes.AgentTurnSpecification? = nil,
            userTurn: LexModelsV2ClientTypes.UserTurnSpecification? = nil
        )
        {
            self.agentTurn = agentTurn
            self.userTurn = userTurn
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceARN = resourceARN else {
            return nil
        }
        return "/tags/\(resourceARN.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to remove the tags from.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of tag keys to remove from the resource. If a tag key does not exist on the resource, it is ignored.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() { }
}

extension UpdateBotAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botAliasLocaleSettings
        case botAliasName
        case botVersion
        case conversationLogSettings
        case description
        case sentimentAnalysisSettings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botAliasLocaleSettings = botAliasLocaleSettings {
            var botAliasLocaleSettingsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .botAliasLocaleSettings)
            for (dictKey0, botAliasLocaleSettingsMap0) in botAliasLocaleSettings {
                try botAliasLocaleSettingsContainer.encode(botAliasLocaleSettingsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let botAliasName = self.botAliasName {
            try encodeContainer.encode(botAliasName, forKey: .botAliasName)
        }
        if let botVersion = self.botVersion {
            try encodeContainer.encode(botVersion, forKey: .botVersion)
        }
        if let conversationLogSettings = self.conversationLogSettings {
            try encodeContainer.encode(conversationLogSettings, forKey: .conversationLogSettings)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let sentimentAnalysisSettings = self.sentimentAnalysisSettings {
            try encodeContainer.encode(sentimentAnalysisSettings, forKey: .sentimentAnalysisSettings)
        }
    }
}

extension UpdateBotAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botAliasId = botAliasId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botaliases/\(botAliasId.urlPercentEncoding())"
    }
}

public struct UpdateBotAliasInput: Swift.Equatable {
    /// The unique identifier of the bot alias.
    /// This member is required.
    public var botAliasId: Swift.String?
    /// The new Lambda functions to use in each locale for the bot alias.
    public var botAliasLocaleSettings: [Swift.String:LexModelsV2ClientTypes.BotAliasLocaleSettings]?
    /// The new name to assign to the bot alias.
    /// This member is required.
    public var botAliasName: Swift.String?
    /// The identifier of the bot with the updated alias.
    /// This member is required.
    public var botId: Swift.String?
    /// The new bot version to assign to the bot alias.
    public var botVersion: Swift.String?
    /// The new settings for storing conversation logs in Amazon CloudWatch Logs and Amazon S3 buckets.
    public var conversationLogSettings: LexModelsV2ClientTypes.ConversationLogSettings?
    /// The new description to assign to the bot alias.
    public var description: Swift.String?
    /// Determines whether Amazon Lex will use Amazon Comprehend to detect the sentiment of user utterances.
    public var sentimentAnalysisSettings: LexModelsV2ClientTypes.SentimentAnalysisSettings?

    public init(
        botAliasId: Swift.String? = nil,
        botAliasLocaleSettings: [Swift.String:LexModelsV2ClientTypes.BotAliasLocaleSettings]? = nil,
        botAliasName: Swift.String? = nil,
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        conversationLogSettings: LexModelsV2ClientTypes.ConversationLogSettings? = nil,
        description: Swift.String? = nil,
        sentimentAnalysisSettings: LexModelsV2ClientTypes.SentimentAnalysisSettings? = nil
    )
    {
        self.botAliasId = botAliasId
        self.botAliasLocaleSettings = botAliasLocaleSettings
        self.botAliasName = botAliasName
        self.botId = botId
        self.botVersion = botVersion
        self.conversationLogSettings = conversationLogSettings
        self.description = description
        self.sentimentAnalysisSettings = sentimentAnalysisSettings
    }
}

struct UpdateBotAliasInputBody: Swift.Equatable {
    let botAliasName: Swift.String?
    let description: Swift.String?
    let botVersion: Swift.String?
    let botAliasLocaleSettings: [Swift.String:LexModelsV2ClientTypes.BotAliasLocaleSettings]?
    let conversationLogSettings: LexModelsV2ClientTypes.ConversationLogSettings?
    let sentimentAnalysisSettings: LexModelsV2ClientTypes.SentimentAnalysisSettings?
}

extension UpdateBotAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botAliasLocaleSettings
        case botAliasName
        case botVersion
        case conversationLogSettings
        case description
        case sentimentAnalysisSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botAliasNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botAliasName)
        botAliasName = botAliasNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let botAliasLocaleSettingsContainer = try containerValues.decodeIfPresent([Swift.String: LexModelsV2ClientTypes.BotAliasLocaleSettings?].self, forKey: .botAliasLocaleSettings)
        var botAliasLocaleSettingsDecoded0: [Swift.String:LexModelsV2ClientTypes.BotAliasLocaleSettings]? = nil
        if let botAliasLocaleSettingsContainer = botAliasLocaleSettingsContainer {
            botAliasLocaleSettingsDecoded0 = [Swift.String:LexModelsV2ClientTypes.BotAliasLocaleSettings]()
            for (key0, botaliaslocalesettings0) in botAliasLocaleSettingsContainer {
                if let botaliaslocalesettings0 = botaliaslocalesettings0 {
                    botAliasLocaleSettingsDecoded0?[key0] = botaliaslocalesettings0
                }
            }
        }
        botAliasLocaleSettings = botAliasLocaleSettingsDecoded0
        let conversationLogSettingsDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ConversationLogSettings.self, forKey: .conversationLogSettings)
        conversationLogSettings = conversationLogSettingsDecoded
        let sentimentAnalysisSettingsDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SentimentAnalysisSettings.self, forKey: .sentimentAnalysisSettings)
        sentimentAnalysisSettings = sentimentAnalysisSettingsDecoded
    }
}

enum UpdateBotAliasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateBotAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateBotAliasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botAliasId = output.botAliasId
            self.botAliasLocaleSettings = output.botAliasLocaleSettings
            self.botAliasName = output.botAliasName
            self.botAliasStatus = output.botAliasStatus
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.conversationLogSettings = output.conversationLogSettings
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.lastUpdatedDateTime = output.lastUpdatedDateTime
            self.sentimentAnalysisSettings = output.sentimentAnalysisSettings
        } else {
            self.botAliasId = nil
            self.botAliasLocaleSettings = nil
            self.botAliasName = nil
            self.botAliasStatus = nil
            self.botId = nil
            self.botVersion = nil
            self.conversationLogSettings = nil
            self.creationDateTime = nil
            self.description = nil
            self.lastUpdatedDateTime = nil
            self.sentimentAnalysisSettings = nil
        }
    }
}

public struct UpdateBotAliasOutputResponse: Swift.Equatable {
    /// The identifier of the updated bot alias.
    public var botAliasId: Swift.String?
    /// The updated Lambda functions to use in each locale for the bot alias.
    public var botAliasLocaleSettings: [Swift.String:LexModelsV2ClientTypes.BotAliasLocaleSettings]?
    /// The updated name of the bot alias.
    public var botAliasName: Swift.String?
    /// The current status of the bot alias. When the status is Available the alias is ready for use.
    public var botAliasStatus: LexModelsV2ClientTypes.BotAliasStatus?
    /// The identifier of the bot with the updated alias.
    public var botId: Swift.String?
    /// The updated version of the bot that the alias points to.
    public var botVersion: Swift.String?
    /// The updated settings for storing conversation logs in Amazon CloudWatch Logs and Amazon S3 buckets.
    public var conversationLogSettings: LexModelsV2ClientTypes.ConversationLogSettings?
    /// A timestamp of the date and time that the bot was created.
    public var creationDateTime: ClientRuntime.Date?
    /// The updated description of the bot alias.
    public var description: Swift.String?
    /// A timestamp of the date and time that the bot was last updated.
    public var lastUpdatedDateTime: ClientRuntime.Date?
    /// Determines whether Amazon Lex will use Amazon Comprehend to detect the sentiment of user utterances.
    public var sentimentAnalysisSettings: LexModelsV2ClientTypes.SentimentAnalysisSettings?

    public init(
        botAliasId: Swift.String? = nil,
        botAliasLocaleSettings: [Swift.String:LexModelsV2ClientTypes.BotAliasLocaleSettings]? = nil,
        botAliasName: Swift.String? = nil,
        botAliasStatus: LexModelsV2ClientTypes.BotAliasStatus? = nil,
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        conversationLogSettings: LexModelsV2ClientTypes.ConversationLogSettings? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        lastUpdatedDateTime: ClientRuntime.Date? = nil,
        sentimentAnalysisSettings: LexModelsV2ClientTypes.SentimentAnalysisSettings? = nil
    )
    {
        self.botAliasId = botAliasId
        self.botAliasLocaleSettings = botAliasLocaleSettings
        self.botAliasName = botAliasName
        self.botAliasStatus = botAliasStatus
        self.botId = botId
        self.botVersion = botVersion
        self.conversationLogSettings = conversationLogSettings
        self.creationDateTime = creationDateTime
        self.description = description
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.sentimentAnalysisSettings = sentimentAnalysisSettings
    }
}

struct UpdateBotAliasOutputResponseBody: Swift.Equatable {
    let botAliasId: Swift.String?
    let botAliasName: Swift.String?
    let description: Swift.String?
    let botVersion: Swift.String?
    let botAliasLocaleSettings: [Swift.String:LexModelsV2ClientTypes.BotAliasLocaleSettings]?
    let conversationLogSettings: LexModelsV2ClientTypes.ConversationLogSettings?
    let sentimentAnalysisSettings: LexModelsV2ClientTypes.SentimentAnalysisSettings?
    let botAliasStatus: LexModelsV2ClientTypes.BotAliasStatus?
    let botId: Swift.String?
    let creationDateTime: ClientRuntime.Date?
    let lastUpdatedDateTime: ClientRuntime.Date?
}

extension UpdateBotAliasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botAliasId
        case botAliasLocaleSettings
        case botAliasName
        case botAliasStatus
        case botId
        case botVersion
        case conversationLogSettings
        case creationDateTime
        case description
        case lastUpdatedDateTime
        case sentimentAnalysisSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botAliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botAliasId)
        botAliasId = botAliasIdDecoded
        let botAliasNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botAliasName)
        botAliasName = botAliasNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let botAliasLocaleSettingsContainer = try containerValues.decodeIfPresent([Swift.String: LexModelsV2ClientTypes.BotAliasLocaleSettings?].self, forKey: .botAliasLocaleSettings)
        var botAliasLocaleSettingsDecoded0: [Swift.String:LexModelsV2ClientTypes.BotAliasLocaleSettings]? = nil
        if let botAliasLocaleSettingsContainer = botAliasLocaleSettingsContainer {
            botAliasLocaleSettingsDecoded0 = [Swift.String:LexModelsV2ClientTypes.BotAliasLocaleSettings]()
            for (key0, botaliaslocalesettings0) in botAliasLocaleSettingsContainer {
                if let botaliaslocalesettings0 = botaliaslocalesettings0 {
                    botAliasLocaleSettingsDecoded0?[key0] = botaliaslocalesettings0
                }
            }
        }
        botAliasLocaleSettings = botAliasLocaleSettingsDecoded0
        let conversationLogSettingsDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ConversationLogSettings.self, forKey: .conversationLogSettings)
        conversationLogSettings = conversationLogSettingsDecoded
        let sentimentAnalysisSettingsDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SentimentAnalysisSettings.self, forKey: .sentimentAnalysisSettings)
        sentimentAnalysisSettings = sentimentAnalysisSettingsDecoded
        let botAliasStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotAliasStatus.self, forKey: .botAliasStatus)
        botAliasStatus = botAliasStatusDecoded
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension UpdateBotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botMembers
        case botName
        case botType
        case dataPrivacy
        case description
        case idleSessionTTLInSeconds
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botMembers = botMembers {
            var botMembersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .botMembers)
            for botmember0 in botMembers {
                try botMembersContainer.encode(botmember0)
            }
        }
        if let botName = self.botName {
            try encodeContainer.encode(botName, forKey: .botName)
        }
        if let botType = self.botType {
            try encodeContainer.encode(botType.rawValue, forKey: .botType)
        }
        if let dataPrivacy = self.dataPrivacy {
            try encodeContainer.encode(dataPrivacy, forKey: .dataPrivacy)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let idleSessionTTLInSeconds = self.idleSessionTTLInSeconds {
            try encodeContainer.encode(idleSessionTTLInSeconds, forKey: .idleSessionTTLInSeconds)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

extension UpdateBotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())"
    }
}

public struct UpdateBotInput: Swift.Equatable {
    /// The unique identifier of the bot to update. This identifier is returned by the [CreateBot](https://docs.aws.amazon.com/lexv2/latest/APIReference/API_CreateBot.html) operation.
    /// This member is required.
    public var botId: Swift.String?
    /// The list of bot members in the network associated with the update action.
    public var botMembers: [LexModelsV2ClientTypes.BotMember]?
    /// The new name of the bot. The name must be unique in the account that creates the bot.
    /// This member is required.
    public var botName: Swift.String?
    /// The type of the bot to be updated.
    public var botType: LexModelsV2ClientTypes.BotType?
    /// Provides information on additional privacy protections Amazon Lex should use with the bot's data.
    /// This member is required.
    public var dataPrivacy: LexModelsV2ClientTypes.DataPrivacy?
    /// A description of the bot.
    public var description: Swift.String?
    /// The time, in seconds, that Amazon Lex should keep information about a user's conversation with the bot. A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Lex deletes any data provided before the timeout. You can specify between 60 (1 minute) and 86,400 (24 hours) seconds.
    /// This member is required.
    public var idleSessionTTLInSeconds: Swift.Int?
    /// The Amazon Resource Name (ARN) of an IAM role that has permissions to access the bot.
    /// This member is required.
    public var roleArn: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botMembers: [LexModelsV2ClientTypes.BotMember]? = nil,
        botName: Swift.String? = nil,
        botType: LexModelsV2ClientTypes.BotType? = nil,
        dataPrivacy: LexModelsV2ClientTypes.DataPrivacy? = nil,
        description: Swift.String? = nil,
        idleSessionTTLInSeconds: Swift.Int? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botMembers = botMembers
        self.botName = botName
        self.botType = botType
        self.dataPrivacy = dataPrivacy
        self.description = description
        self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
        self.roleArn = roleArn
    }
}

struct UpdateBotInputBody: Swift.Equatable {
    let botName: Swift.String?
    let description: Swift.String?
    let roleArn: Swift.String?
    let dataPrivacy: LexModelsV2ClientTypes.DataPrivacy?
    let idleSessionTTLInSeconds: Swift.Int?
    let botType: LexModelsV2ClientTypes.BotType?
    let botMembers: [LexModelsV2ClientTypes.BotMember]?
}

extension UpdateBotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botMembers
        case botName
        case botType
        case dataPrivacy
        case description
        case idleSessionTTLInSeconds
        case roleArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botName)
        botName = botNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let dataPrivacyDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.DataPrivacy.self, forKey: .dataPrivacy)
        dataPrivacy = dataPrivacyDecoded
        let idleSessionTTLInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleSessionTTLInSeconds)
        idleSessionTTLInSeconds = idleSessionTTLInSecondsDecoded
        let botTypeDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotType.self, forKey: .botType)
        botType = botTypeDecoded
        let botMembersContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.BotMember?].self, forKey: .botMembers)
        var botMembersDecoded0:[LexModelsV2ClientTypes.BotMember]? = nil
        if let botMembersContainer = botMembersContainer {
            botMembersDecoded0 = [LexModelsV2ClientTypes.BotMember]()
            for structure0 in botMembersContainer {
                if let structure0 = structure0 {
                    botMembersDecoded0?.append(structure0)
                }
            }
        }
        botMembers = botMembersDecoded0
    }
}

extension UpdateBotLocaleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case nluIntentConfidenceThreshold
        case voiceSettings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let nluIntentConfidenceThreshold = self.nluIntentConfidenceThreshold {
            try encodeContainer.encode(nluIntentConfidenceThreshold, forKey: .nluIntentConfidenceThreshold)
        }
        if let voiceSettings = self.voiceSettings {
            try encodeContainer.encode(voiceSettings, forKey: .voiceSettings)
        }
    }
}

extension UpdateBotLocaleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botVersion = botVersion else {
            return nil
        }
        guard let localeId = localeId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botversions/\(botVersion.urlPercentEncoding())/botlocales/\(localeId.urlPercentEncoding())"
    }
}

public struct UpdateBotLocaleInput: Swift.Equatable {
    /// The unique identifier of the bot that contains the locale.
    /// This member is required.
    public var botId: Swift.String?
    /// The version of the bot that contains the locale to be updated. The version can only be the DRAFT version.
    /// This member is required.
    public var botVersion: Swift.String?
    /// The new description of the locale.
    public var description: Swift.String?
    /// The identifier of the language and locale to update. The string must match one of the supported locales. For more information, see [Supported languages](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html).
    /// This member is required.
    public var localeId: Swift.String?
    /// The new confidence threshold where Amazon Lex inserts the AMAZON.FallbackIntent and AMAZON.KendraSearchIntent intents in the list of possible intents for an utterance.
    /// This member is required.
    public var nluIntentConfidenceThreshold: Swift.Double?
    /// The new Amazon Polly voice Amazon Lex should use for voice interaction with the user.
    public var voiceSettings: LexModelsV2ClientTypes.VoiceSettings?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        description: Swift.String? = nil,
        localeId: Swift.String? = nil,
        nluIntentConfidenceThreshold: Swift.Double? = nil,
        voiceSettings: LexModelsV2ClientTypes.VoiceSettings? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.description = description
        self.localeId = localeId
        self.nluIntentConfidenceThreshold = nluIntentConfidenceThreshold
        self.voiceSettings = voiceSettings
    }
}

struct UpdateBotLocaleInputBody: Swift.Equatable {
    let description: Swift.String?
    let nluIntentConfidenceThreshold: Swift.Double?
    let voiceSettings: LexModelsV2ClientTypes.VoiceSettings?
}

extension UpdateBotLocaleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case nluIntentConfidenceThreshold
        case voiceSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nluIntentConfidenceThresholdDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .nluIntentConfidenceThreshold)
        nluIntentConfidenceThreshold = nluIntentConfidenceThresholdDecoded
        let voiceSettingsDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.VoiceSettings.self, forKey: .voiceSettings)
        voiceSettings = voiceSettingsDecoded
    }
}

enum UpdateBotLocaleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateBotLocaleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateBotLocaleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botLocaleStatus = output.botLocaleStatus
            self.botVersion = output.botVersion
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.failureReasons = output.failureReasons
            self.lastUpdatedDateTime = output.lastUpdatedDateTime
            self.localeId = output.localeId
            self.localeName = output.localeName
            self.nluIntentConfidenceThreshold = output.nluIntentConfidenceThreshold
            self.recommendedActions = output.recommendedActions
            self.voiceSettings = output.voiceSettings
        } else {
            self.botId = nil
            self.botLocaleStatus = nil
            self.botVersion = nil
            self.creationDateTime = nil
            self.description = nil
            self.failureReasons = nil
            self.lastUpdatedDateTime = nil
            self.localeId = nil
            self.localeName = nil
            self.nluIntentConfidenceThreshold = nil
            self.recommendedActions = nil
            self.voiceSettings = nil
        }
    }
}

public struct UpdateBotLocaleOutputResponse: Swift.Equatable {
    /// The identifier of the bot that contains the updated locale.
    public var botId: Swift.String?
    /// The current status of the locale. When the bot status is Built the locale is ready for use.
    public var botLocaleStatus: LexModelsV2ClientTypes.BotLocaleStatus?
    /// The version of the bot that contains the updated locale.
    public var botVersion: Swift.String?
    /// A timestamp of the date and time that the locale was created.
    public var creationDateTime: ClientRuntime.Date?
    /// The updated description of the locale.
    public var description: Swift.String?
    /// If the botLocaleStatus is Failed, the failureReasons field lists the errors that occurred while building the bot.
    public var failureReasons: [Swift.String]?
    /// A timestamp of the date and time that the locale was last updated.
    public var lastUpdatedDateTime: ClientRuntime.Date?
    /// The language and locale of the updated bot locale.
    public var localeId: Swift.String?
    /// The updated locale name for the locale.
    public var localeName: Swift.String?
    /// The updated confidence threshold for inserting the AMAZON.FallbackIntent and AMAZON.KendraSearchIntent intents in the list of possible intents for an utterance.
    public var nluIntentConfidenceThreshold: Swift.Double?
    /// Recommended actions to take to resolve an error in the failureReasons field.
    public var recommendedActions: [Swift.String]?
    /// The updated Amazon Polly voice to use for voice interaction with the user.
    public var voiceSettings: LexModelsV2ClientTypes.VoiceSettings?

    public init(
        botId: Swift.String? = nil,
        botLocaleStatus: LexModelsV2ClientTypes.BotLocaleStatus? = nil,
        botVersion: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        failureReasons: [Swift.String]? = nil,
        lastUpdatedDateTime: ClientRuntime.Date? = nil,
        localeId: Swift.String? = nil,
        localeName: Swift.String? = nil,
        nluIntentConfidenceThreshold: Swift.Double? = nil,
        recommendedActions: [Swift.String]? = nil,
        voiceSettings: LexModelsV2ClientTypes.VoiceSettings? = nil
    )
    {
        self.botId = botId
        self.botLocaleStatus = botLocaleStatus
        self.botVersion = botVersion
        self.creationDateTime = creationDateTime
        self.description = description
        self.failureReasons = failureReasons
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.localeId = localeId
        self.localeName = localeName
        self.nluIntentConfidenceThreshold = nluIntentConfidenceThreshold
        self.recommendedActions = recommendedActions
        self.voiceSettings = voiceSettings
    }
}

struct UpdateBotLocaleOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let botVersion: Swift.String?
    let localeId: Swift.String?
    let localeName: Swift.String?
    let description: Swift.String?
    let nluIntentConfidenceThreshold: Swift.Double?
    let voiceSettings: LexModelsV2ClientTypes.VoiceSettings?
    let botLocaleStatus: LexModelsV2ClientTypes.BotLocaleStatus?
    let failureReasons: [Swift.String]?
    let creationDateTime: ClientRuntime.Date?
    let lastUpdatedDateTime: ClientRuntime.Date?
    let recommendedActions: [Swift.String]?
}

extension UpdateBotLocaleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botLocaleStatus
        case botVersion
        case creationDateTime
        case description
        case failureReasons
        case lastUpdatedDateTime
        case localeId
        case localeName
        case nluIntentConfidenceThreshold
        case recommendedActions
        case voiceSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let localeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeName)
        localeName = localeNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nluIntentConfidenceThresholdDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .nluIntentConfidenceThreshold)
        nluIntentConfidenceThreshold = nluIntentConfidenceThresholdDecoded
        let voiceSettingsDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.VoiceSettings.self, forKey: .voiceSettings)
        voiceSettings = voiceSettingsDecoded
        let botLocaleStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotLocaleStatus.self, forKey: .botLocaleStatus)
        botLocaleStatus = botLocaleStatusDecoded
        let failureReasonsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .failureReasons)
        var failureReasonsDecoded0:[Swift.String]? = nil
        if let failureReasonsContainer = failureReasonsContainer {
            failureReasonsDecoded0 = [Swift.String]()
            for string0 in failureReasonsContainer {
                if let string0 = string0 {
                    failureReasonsDecoded0?.append(string0)
                }
            }
        }
        failureReasons = failureReasonsDecoded0
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let recommendedActionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .recommendedActions)
        var recommendedActionsDecoded0:[Swift.String]? = nil
        if let recommendedActionsContainer = recommendedActionsContainer {
            recommendedActionsDecoded0 = [Swift.String]()
            for string0 in recommendedActionsContainer {
                if let string0 = string0 {
                    recommendedActionsDecoded0?.append(string0)
                }
            }
        }
        recommendedActions = recommendedActionsDecoded0
    }
}

enum UpdateBotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateBotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateBotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botMembers = output.botMembers
            self.botName = output.botName
            self.botStatus = output.botStatus
            self.botType = output.botType
            self.creationDateTime = output.creationDateTime
            self.dataPrivacy = output.dataPrivacy
            self.description = output.description
            self.idleSessionTTLInSeconds = output.idleSessionTTLInSeconds
            self.lastUpdatedDateTime = output.lastUpdatedDateTime
            self.roleArn = output.roleArn
        } else {
            self.botId = nil
            self.botMembers = nil
            self.botName = nil
            self.botStatus = nil
            self.botType = nil
            self.creationDateTime = nil
            self.dataPrivacy = nil
            self.description = nil
            self.idleSessionTTLInSeconds = nil
            self.lastUpdatedDateTime = nil
            self.roleArn = nil
        }
    }
}

public struct UpdateBotOutputResponse: Swift.Equatable {
    /// The unique identifier of the bot that was updated.
    public var botId: Swift.String?
    /// The list of bot members in the network that was updated.
    public var botMembers: [LexModelsV2ClientTypes.BotMember]?
    /// The name of the bot after the update.
    public var botName: Swift.String?
    /// Shows the current status of the bot. The bot is first in the Creating status. Once the bot is read for use, it changes to the Available status. After the bot is created, you can use the DRAFT version of the bot.
    public var botStatus: LexModelsV2ClientTypes.BotStatus?
    /// The type of the bot that was updated.
    public var botType: LexModelsV2ClientTypes.BotType?
    /// A timestamp of the date and time that the bot was created.
    public var creationDateTime: ClientRuntime.Date?
    /// The data privacy settings for the bot after the update.
    public var dataPrivacy: LexModelsV2ClientTypes.DataPrivacy?
    /// The description of the bot after the update.
    public var description: Swift.String?
    /// The session timeout, in seconds, for the bot after the update.
    public var idleSessionTTLInSeconds: Swift.Int?
    /// A timestamp of the date and time that the bot was last updated.
    public var lastUpdatedDateTime: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the IAM role used by the bot after the update.
    public var roleArn: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botMembers: [LexModelsV2ClientTypes.BotMember]? = nil,
        botName: Swift.String? = nil,
        botStatus: LexModelsV2ClientTypes.BotStatus? = nil,
        botType: LexModelsV2ClientTypes.BotType? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        dataPrivacy: LexModelsV2ClientTypes.DataPrivacy? = nil,
        description: Swift.String? = nil,
        idleSessionTTLInSeconds: Swift.Int? = nil,
        lastUpdatedDateTime: ClientRuntime.Date? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botMembers = botMembers
        self.botName = botName
        self.botStatus = botStatus
        self.botType = botType
        self.creationDateTime = creationDateTime
        self.dataPrivacy = dataPrivacy
        self.description = description
        self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.roleArn = roleArn
    }
}

struct UpdateBotOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let botName: Swift.String?
    let description: Swift.String?
    let roleArn: Swift.String?
    let dataPrivacy: LexModelsV2ClientTypes.DataPrivacy?
    let idleSessionTTLInSeconds: Swift.Int?
    let botStatus: LexModelsV2ClientTypes.BotStatus?
    let creationDateTime: ClientRuntime.Date?
    let lastUpdatedDateTime: ClientRuntime.Date?
    let botType: LexModelsV2ClientTypes.BotType?
    let botMembers: [LexModelsV2ClientTypes.BotMember]?
}

extension UpdateBotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botMembers
        case botName
        case botStatus
        case botType
        case creationDateTime
        case dataPrivacy
        case description
        case idleSessionTTLInSeconds
        case lastUpdatedDateTime
        case roleArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botName)
        botName = botNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let dataPrivacyDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.DataPrivacy.self, forKey: .dataPrivacy)
        dataPrivacy = dataPrivacyDecoded
        let idleSessionTTLInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleSessionTTLInSeconds)
        idleSessionTTLInSeconds = idleSessionTTLInSecondsDecoded
        let botStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotStatus.self, forKey: .botStatus)
        botStatus = botStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let botTypeDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotType.self, forKey: .botType)
        botType = botTypeDecoded
        let botMembersContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.BotMember?].self, forKey: .botMembers)
        var botMembersDecoded0:[LexModelsV2ClientTypes.BotMember]? = nil
        if let botMembersContainer = botMembersContainer {
            botMembersDecoded0 = [LexModelsV2ClientTypes.BotMember]()
            for structure0 in botMembersContainer {
                if let structure0 = structure0 {
                    botMembersDecoded0?.append(structure0)
                }
            }
        }
        botMembers = botMembersDecoded0
    }
}

extension UpdateBotRecommendationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionSetting
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionSetting = self.encryptionSetting {
            try encodeContainer.encode(encryptionSetting, forKey: .encryptionSetting)
        }
    }
}

extension UpdateBotRecommendationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botVersion = botVersion else {
            return nil
        }
        guard let localeId = localeId else {
            return nil
        }
        guard let botRecommendationId = botRecommendationId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botversions/\(botVersion.urlPercentEncoding())/botlocales/\(localeId.urlPercentEncoding())/botrecommendations/\(botRecommendationId.urlPercentEncoding())"
    }
}

public struct UpdateBotRecommendationInput: Swift.Equatable {
    /// The unique identifier of the bot containing the bot recommendation to be updated.
    /// This member is required.
    public var botId: Swift.String?
    /// The unique identifier of the bot recommendation to be updated.
    /// This member is required.
    public var botRecommendationId: Swift.String?
    /// The version of the bot containing the bot recommendation to be updated.
    /// This member is required.
    public var botVersion: Swift.String?
    /// The object representing the passwords that will be used to encrypt the data related to the bot recommendation results, as well as the KMS key ARN used to encrypt the associated metadata.
    /// This member is required.
    public var encryptionSetting: LexModelsV2ClientTypes.EncryptionSetting?
    /// The identifier of the language and locale of the bot recommendation to update. The string must match one of the supported locales. For more information, see [Supported languages](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html)
    /// This member is required.
    public var localeId: Swift.String?

    public init(
        botId: Swift.String? = nil,
        botRecommendationId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        encryptionSetting: LexModelsV2ClientTypes.EncryptionSetting? = nil,
        localeId: Swift.String? = nil
    )
    {
        self.botId = botId
        self.botRecommendationId = botRecommendationId
        self.botVersion = botVersion
        self.encryptionSetting = encryptionSetting
        self.localeId = localeId
    }
}

struct UpdateBotRecommendationInputBody: Swift.Equatable {
    let encryptionSetting: LexModelsV2ClientTypes.EncryptionSetting?
}

extension UpdateBotRecommendationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionSetting
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.EncryptionSetting.self, forKey: .encryptionSetting)
        encryptionSetting = encryptionSettingDecoded
    }
}

enum UpdateBotRecommendationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateBotRecommendationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateBotRecommendationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botRecommendationId = output.botRecommendationId
            self.botRecommendationStatus = output.botRecommendationStatus
            self.botVersion = output.botVersion
            self.creationDateTime = output.creationDateTime
            self.encryptionSetting = output.encryptionSetting
            self.lastUpdatedDateTime = output.lastUpdatedDateTime
            self.localeId = output.localeId
            self.transcriptSourceSetting = output.transcriptSourceSetting
        } else {
            self.botId = nil
            self.botRecommendationId = nil
            self.botRecommendationStatus = nil
            self.botVersion = nil
            self.creationDateTime = nil
            self.encryptionSetting = nil
            self.lastUpdatedDateTime = nil
            self.localeId = nil
            self.transcriptSourceSetting = nil
        }
    }
}

public struct UpdateBotRecommendationOutputResponse: Swift.Equatable {
    /// The unique identifier of the bot containing the bot recommendation that has been updated.
    public var botId: Swift.String?
    /// The unique identifier of the bot recommendation to be updated.
    public var botRecommendationId: Swift.String?
    /// The status of the bot recommendation. If the status is Failed, then the reasons for the failure are listed in the failureReasons field.
    public var botRecommendationStatus: LexModelsV2ClientTypes.BotRecommendationStatus?
    /// The version of the bot containing the bot recommendation that has been updated.
    public var botVersion: Swift.String?
    /// A timestamp of the date and time that the bot recommendation was created.
    public var creationDateTime: ClientRuntime.Date?
    /// The object representing the passwords that were used to encrypt the data related to the bot recommendation results, as well as the KMS key ARN used to encrypt the associated metadata.
    public var encryptionSetting: LexModelsV2ClientTypes.EncryptionSetting?
    /// A timestamp of the date and time that the bot recommendation was last updated.
    public var lastUpdatedDateTime: ClientRuntime.Date?
    /// The identifier of the language and locale of the bot recommendation to update. The string must match one of the supported locales. For more information, see [Supported languages](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html)
    public var localeId: Swift.String?
    /// The object representing the Amazon S3 bucket containing the transcript, as well as the associated metadata.
    public var transcriptSourceSetting: LexModelsV2ClientTypes.TranscriptSourceSetting?

    public init(
        botId: Swift.String? = nil,
        botRecommendationId: Swift.String? = nil,
        botRecommendationStatus: LexModelsV2ClientTypes.BotRecommendationStatus? = nil,
        botVersion: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        encryptionSetting: LexModelsV2ClientTypes.EncryptionSetting? = nil,
        lastUpdatedDateTime: ClientRuntime.Date? = nil,
        localeId: Swift.String? = nil,
        transcriptSourceSetting: LexModelsV2ClientTypes.TranscriptSourceSetting? = nil
    )
    {
        self.botId = botId
        self.botRecommendationId = botRecommendationId
        self.botRecommendationStatus = botRecommendationStatus
        self.botVersion = botVersion
        self.creationDateTime = creationDateTime
        self.encryptionSetting = encryptionSetting
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.localeId = localeId
        self.transcriptSourceSetting = transcriptSourceSetting
    }
}

struct UpdateBotRecommendationOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let botVersion: Swift.String?
    let localeId: Swift.String?
    let botRecommendationStatus: LexModelsV2ClientTypes.BotRecommendationStatus?
    let botRecommendationId: Swift.String?
    let creationDateTime: ClientRuntime.Date?
    let lastUpdatedDateTime: ClientRuntime.Date?
    let transcriptSourceSetting: LexModelsV2ClientTypes.TranscriptSourceSetting?
    let encryptionSetting: LexModelsV2ClientTypes.EncryptionSetting?
}

extension UpdateBotRecommendationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botRecommendationId
        case botRecommendationStatus
        case botVersion
        case creationDateTime
        case encryptionSetting
        case lastUpdatedDateTime
        case localeId
        case transcriptSourceSetting
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let botRecommendationStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.BotRecommendationStatus.self, forKey: .botRecommendationStatus)
        botRecommendationStatus = botRecommendationStatusDecoded
        let botRecommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botRecommendationId)
        botRecommendationId = botRecommendationIdDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let transcriptSourceSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TranscriptSourceSetting.self, forKey: .transcriptSourceSetting)
        transcriptSourceSetting = transcriptSourceSettingDecoded
        let encryptionSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.EncryptionSetting.self, forKey: .encryptionSetting)
        encryptionSetting = encryptionSettingDecoded
    }
}

extension UpdateExportInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateExportInput(exportId: \(Swift.String(describing: exportId)), filePassword: \"CONTENT_REDACTED\")"}
}

extension UpdateExportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filePassword
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filePassword = self.filePassword {
            try encodeContainer.encode(filePassword, forKey: .filePassword)
        }
    }
}

extension UpdateExportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let exportId = exportId else {
            return nil
        }
        return "/exports/\(exportId.urlPercentEncoding())"
    }
}

public struct UpdateExportInput: Swift.Equatable {
    /// The unique identifier Amazon Lex assigned to the export.
    /// This member is required.
    public var exportId: Swift.String?
    /// The new password to use to encrypt the export zip archive.
    public var filePassword: Swift.String?

    public init(
        exportId: Swift.String? = nil,
        filePassword: Swift.String? = nil
    )
    {
        self.exportId = exportId
        self.filePassword = filePassword
    }
}

struct UpdateExportInputBody: Swift.Equatable {
    let filePassword: Swift.String?
}

extension UpdateExportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filePassword
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filePasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePassword)
        filePassword = filePasswordDecoded
    }
}

enum UpdateExportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateExportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateExportOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationDateTime = output.creationDateTime
            self.exportId = output.exportId
            self.exportStatus = output.exportStatus
            self.fileFormat = output.fileFormat
            self.lastUpdatedDateTime = output.lastUpdatedDateTime
            self.resourceSpecification = output.resourceSpecification
        } else {
            self.creationDateTime = nil
            self.exportId = nil
            self.exportStatus = nil
            self.fileFormat = nil
            self.lastUpdatedDateTime = nil
            self.resourceSpecification = nil
        }
    }
}

public struct UpdateExportOutputResponse: Swift.Equatable {
    /// The date and time that the export was created.
    public var creationDateTime: ClientRuntime.Date?
    /// The unique identifier Amazon Lex assigned to the export.
    public var exportId: Swift.String?
    /// The status of the export. When the status is Completed the export archive is available for download.
    public var exportStatus: LexModelsV2ClientTypes.ExportStatus?
    /// The file format used for the files that define the resource. The TSV format is required to export a custom vocabulary only; otherwise use LexJson format.
    public var fileFormat: LexModelsV2ClientTypes.ImportExportFileFormat?
    /// The date and time that the export was last updated.
    public var lastUpdatedDateTime: ClientRuntime.Date?
    /// A description of the type of resource that was exported, either a bot or a bot locale.
    public var resourceSpecification: LexModelsV2ClientTypes.ExportResourceSpecification?

    public init(
        creationDateTime: ClientRuntime.Date? = nil,
        exportId: Swift.String? = nil,
        exportStatus: LexModelsV2ClientTypes.ExportStatus? = nil,
        fileFormat: LexModelsV2ClientTypes.ImportExportFileFormat? = nil,
        lastUpdatedDateTime: ClientRuntime.Date? = nil,
        resourceSpecification: LexModelsV2ClientTypes.ExportResourceSpecification? = nil
    )
    {
        self.creationDateTime = creationDateTime
        self.exportId = exportId
        self.exportStatus = exportStatus
        self.fileFormat = fileFormat
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.resourceSpecification = resourceSpecification
    }
}

struct UpdateExportOutputResponseBody: Swift.Equatable {
    let exportId: Swift.String?
    let resourceSpecification: LexModelsV2ClientTypes.ExportResourceSpecification?
    let fileFormat: LexModelsV2ClientTypes.ImportExportFileFormat?
    let exportStatus: LexModelsV2ClientTypes.ExportStatus?
    let creationDateTime: ClientRuntime.Date?
    let lastUpdatedDateTime: ClientRuntime.Date?
}

extension UpdateExportOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case exportId
        case exportStatus
        case fileFormat
        case lastUpdatedDateTime
        case resourceSpecification
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportId)
        exportId = exportIdDecoded
        let resourceSpecificationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ExportResourceSpecification.self, forKey: .resourceSpecification)
        resourceSpecification = resourceSpecificationDecoded
        let fileFormatDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ImportExportFileFormat.self, forKey: .fileFormat)
        fileFormat = fileFormatDecoded
        let exportStatusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ExportStatus.self, forKey: .exportStatus)
        exportStatus = exportStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension UpdateIntentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case dialogCodeHook
        case fulfillmentCodeHook
        case initialResponseSetting
        case inputContexts
        case intentClosingSetting
        case intentConfirmationSetting
        case intentName
        case kendraConfiguration
        case outputContexts
        case parentIntentSignature
        case sampleUtterances
        case slotPriorities
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dialogCodeHook = self.dialogCodeHook {
            try encodeContainer.encode(dialogCodeHook, forKey: .dialogCodeHook)
        }
        if let fulfillmentCodeHook = self.fulfillmentCodeHook {
            try encodeContainer.encode(fulfillmentCodeHook, forKey: .fulfillmentCodeHook)
        }
        if let initialResponseSetting = self.initialResponseSetting {
            try encodeContainer.encode(initialResponseSetting, forKey: .initialResponseSetting)
        }
        if let inputContexts = inputContexts {
            var inputContextsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputContexts)
            for inputcontext0 in inputContexts {
                try inputContextsContainer.encode(inputcontext0)
            }
        }
        if let intentClosingSetting = self.intentClosingSetting {
            try encodeContainer.encode(intentClosingSetting, forKey: .intentClosingSetting)
        }
        if let intentConfirmationSetting = self.intentConfirmationSetting {
            try encodeContainer.encode(intentConfirmationSetting, forKey: .intentConfirmationSetting)
        }
        if let intentName = self.intentName {
            try encodeContainer.encode(intentName, forKey: .intentName)
        }
        if let kendraConfiguration = self.kendraConfiguration {
            try encodeContainer.encode(kendraConfiguration, forKey: .kendraConfiguration)
        }
        if let outputContexts = outputContexts {
            var outputContextsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputContexts)
            for outputcontext0 in outputContexts {
                try outputContextsContainer.encode(outputcontext0)
            }
        }
        if let parentIntentSignature = self.parentIntentSignature {
            try encodeContainer.encode(parentIntentSignature, forKey: .parentIntentSignature)
        }
        if let sampleUtterances = sampleUtterances {
            var sampleUtterancesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sampleUtterances)
            for sampleutterance0 in sampleUtterances {
                try sampleUtterancesContainer.encode(sampleutterance0)
            }
        }
        if let slotPriorities = slotPriorities {
            var slotPrioritiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .slotPriorities)
            for slotpriority0 in slotPriorities {
                try slotPrioritiesContainer.encode(slotpriority0)
            }
        }
    }
}

extension UpdateIntentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botVersion = botVersion else {
            return nil
        }
        guard let localeId = localeId else {
            return nil
        }
        guard let intentId = intentId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botversions/\(botVersion.urlPercentEncoding())/botlocales/\(localeId.urlPercentEncoding())/intents/\(intentId.urlPercentEncoding())"
    }
}

public struct UpdateIntentInput: Swift.Equatable {
    /// The identifier of the bot that contains the intent.
    /// This member is required.
    public var botId: Swift.String?
    /// The version of the bot that contains the intent. Must be DRAFT.
    /// This member is required.
    public var botVersion: Swift.String?
    /// The new description of the intent.
    public var description: Swift.String?
    /// The new Lambda function to use between each turn of the conversation with the bot.
    public var dialogCodeHook: LexModelsV2ClientTypes.DialogCodeHookSettings?
    /// The new Lambda function to call when all of the intents required slots are provided and the intent is ready for fulfillment.
    public var fulfillmentCodeHook: LexModelsV2ClientTypes.FulfillmentCodeHookSettings?
    /// Configuration settings for a response sent to the user before Amazon Lex starts eliciting slots.
    public var initialResponseSetting: LexModelsV2ClientTypes.InitialResponseSetting?
    /// A new list of contexts that must be active in order for Amazon Lex to consider the intent.
    public var inputContexts: [LexModelsV2ClientTypes.InputContext]?
    /// The new response that Amazon Lex sends the user when the intent is closed.
    public var intentClosingSetting: LexModelsV2ClientTypes.IntentClosingSetting?
    /// New prompts that Amazon Lex sends to the user to confirm the completion of an intent.
    public var intentConfirmationSetting: LexModelsV2ClientTypes.IntentConfirmationSetting?
    /// The unique identifier of the intent to update.
    /// This member is required.
    public var intentId: Swift.String?
    /// The new name for the intent.
    /// This member is required.
    public var intentName: Swift.String?
    /// New configuration settings for connecting to an Amazon Kendra index.
    public var kendraConfiguration: LexModelsV2ClientTypes.KendraConfiguration?
    /// The identifier of the language and locale where this intent is used. The string must match one of the supported locales. For more information, see [Supported languages](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html).
    /// This member is required.
    public var localeId: Swift.String?
    /// A new list of contexts that Amazon Lex activates when the intent is fulfilled.
    public var outputContexts: [LexModelsV2ClientTypes.OutputContext]?
    /// The signature of the new built-in intent to use as the parent of this intent.
    public var parentIntentSignature: Swift.String?
    /// New utterances used to invoke the intent.
    public var sampleUtterances: [LexModelsV2ClientTypes.SampleUtterance]?
    /// A new list of slots and their priorities that are contained by the intent.
    public var slotPriorities: [LexModelsV2ClientTypes.SlotPriority]?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        description: Swift.String? = nil,
        dialogCodeHook: LexModelsV2ClientTypes.DialogCodeHookSettings? = nil,
        fulfillmentCodeHook: LexModelsV2ClientTypes.FulfillmentCodeHookSettings? = nil,
        initialResponseSetting: LexModelsV2ClientTypes.InitialResponseSetting? = nil,
        inputContexts: [LexModelsV2ClientTypes.InputContext]? = nil,
        intentClosingSetting: LexModelsV2ClientTypes.IntentClosingSetting? = nil,
        intentConfirmationSetting: LexModelsV2ClientTypes.IntentConfirmationSetting? = nil,
        intentId: Swift.String? = nil,
        intentName: Swift.String? = nil,
        kendraConfiguration: LexModelsV2ClientTypes.KendraConfiguration? = nil,
        localeId: Swift.String? = nil,
        outputContexts: [LexModelsV2ClientTypes.OutputContext]? = nil,
        parentIntentSignature: Swift.String? = nil,
        sampleUtterances: [LexModelsV2ClientTypes.SampleUtterance]? = nil,
        slotPriorities: [LexModelsV2ClientTypes.SlotPriority]? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.description = description
        self.dialogCodeHook = dialogCodeHook
        self.fulfillmentCodeHook = fulfillmentCodeHook
        self.initialResponseSetting = initialResponseSetting
        self.inputContexts = inputContexts
        self.intentClosingSetting = intentClosingSetting
        self.intentConfirmationSetting = intentConfirmationSetting
        self.intentId = intentId
        self.intentName = intentName
        self.kendraConfiguration = kendraConfiguration
        self.localeId = localeId
        self.outputContexts = outputContexts
        self.parentIntentSignature = parentIntentSignature
        self.sampleUtterances = sampleUtterances
        self.slotPriorities = slotPriorities
    }
}

struct UpdateIntentInputBody: Swift.Equatable {
    let intentName: Swift.String?
    let description: Swift.String?
    let parentIntentSignature: Swift.String?
    let sampleUtterances: [LexModelsV2ClientTypes.SampleUtterance]?
    let dialogCodeHook: LexModelsV2ClientTypes.DialogCodeHookSettings?
    let fulfillmentCodeHook: LexModelsV2ClientTypes.FulfillmentCodeHookSettings?
    let slotPriorities: [LexModelsV2ClientTypes.SlotPriority]?
    let intentConfirmationSetting: LexModelsV2ClientTypes.IntentConfirmationSetting?
    let intentClosingSetting: LexModelsV2ClientTypes.IntentClosingSetting?
    let inputContexts: [LexModelsV2ClientTypes.InputContext]?
    let outputContexts: [LexModelsV2ClientTypes.OutputContext]?
    let kendraConfiguration: LexModelsV2ClientTypes.KendraConfiguration?
    let initialResponseSetting: LexModelsV2ClientTypes.InitialResponseSetting?
}

extension UpdateIntentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case dialogCodeHook
        case fulfillmentCodeHook
        case initialResponseSetting
        case inputContexts
        case intentClosingSetting
        case intentConfirmationSetting
        case intentName
        case kendraConfiguration
        case outputContexts
        case parentIntentSignature
        case sampleUtterances
        case slotPriorities
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intentName)
        intentName = intentNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parentIntentSignatureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentIntentSignature)
        parentIntentSignature = parentIntentSignatureDecoded
        let sampleUtterancesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.SampleUtterance?].self, forKey: .sampleUtterances)
        var sampleUtterancesDecoded0:[LexModelsV2ClientTypes.SampleUtterance]? = nil
        if let sampleUtterancesContainer = sampleUtterancesContainer {
            sampleUtterancesDecoded0 = [LexModelsV2ClientTypes.SampleUtterance]()
            for structure0 in sampleUtterancesContainer {
                if let structure0 = structure0 {
                    sampleUtterancesDecoded0?.append(structure0)
                }
            }
        }
        sampleUtterances = sampleUtterancesDecoded0
        let dialogCodeHookDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.DialogCodeHookSettings.self, forKey: .dialogCodeHook)
        dialogCodeHook = dialogCodeHookDecoded
        let fulfillmentCodeHookDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.FulfillmentCodeHookSettings.self, forKey: .fulfillmentCodeHook)
        fulfillmentCodeHook = fulfillmentCodeHookDecoded
        let slotPrioritiesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.SlotPriority?].self, forKey: .slotPriorities)
        var slotPrioritiesDecoded0:[LexModelsV2ClientTypes.SlotPriority]? = nil
        if let slotPrioritiesContainer = slotPrioritiesContainer {
            slotPrioritiesDecoded0 = [LexModelsV2ClientTypes.SlotPriority]()
            for structure0 in slotPrioritiesContainer {
                if let structure0 = structure0 {
                    slotPrioritiesDecoded0?.append(structure0)
                }
            }
        }
        slotPriorities = slotPrioritiesDecoded0
        let intentConfirmationSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.IntentConfirmationSetting.self, forKey: .intentConfirmationSetting)
        intentConfirmationSetting = intentConfirmationSettingDecoded
        let intentClosingSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.IntentClosingSetting.self, forKey: .intentClosingSetting)
        intentClosingSetting = intentClosingSettingDecoded
        let inputContextsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.InputContext?].self, forKey: .inputContexts)
        var inputContextsDecoded0:[LexModelsV2ClientTypes.InputContext]? = nil
        if let inputContextsContainer = inputContextsContainer {
            inputContextsDecoded0 = [LexModelsV2ClientTypes.InputContext]()
            for structure0 in inputContextsContainer {
                if let structure0 = structure0 {
                    inputContextsDecoded0?.append(structure0)
                }
            }
        }
        inputContexts = inputContextsDecoded0
        let outputContextsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.OutputContext?].self, forKey: .outputContexts)
        var outputContextsDecoded0:[LexModelsV2ClientTypes.OutputContext]? = nil
        if let outputContextsContainer = outputContextsContainer {
            outputContextsDecoded0 = [LexModelsV2ClientTypes.OutputContext]()
            for structure0 in outputContextsContainer {
                if let structure0 = structure0 {
                    outputContextsDecoded0?.append(structure0)
                }
            }
        }
        outputContexts = outputContextsDecoded0
        let kendraConfigurationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.KendraConfiguration.self, forKey: .kendraConfiguration)
        kendraConfiguration = kendraConfigurationDecoded
        let initialResponseSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.InitialResponseSetting.self, forKey: .initialResponseSetting)
        initialResponseSetting = initialResponseSettingDecoded
    }
}

enum UpdateIntentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateIntentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateIntentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.dialogCodeHook = output.dialogCodeHook
            self.fulfillmentCodeHook = output.fulfillmentCodeHook
            self.initialResponseSetting = output.initialResponseSetting
            self.inputContexts = output.inputContexts
            self.intentClosingSetting = output.intentClosingSetting
            self.intentConfirmationSetting = output.intentConfirmationSetting
            self.intentId = output.intentId
            self.intentName = output.intentName
            self.kendraConfiguration = output.kendraConfiguration
            self.lastUpdatedDateTime = output.lastUpdatedDateTime
            self.localeId = output.localeId
            self.outputContexts = output.outputContexts
            self.parentIntentSignature = output.parentIntentSignature
            self.sampleUtterances = output.sampleUtterances
            self.slotPriorities = output.slotPriorities
        } else {
            self.botId = nil
            self.botVersion = nil
            self.creationDateTime = nil
            self.description = nil
            self.dialogCodeHook = nil
            self.fulfillmentCodeHook = nil
            self.initialResponseSetting = nil
            self.inputContexts = nil
            self.intentClosingSetting = nil
            self.intentConfirmationSetting = nil
            self.intentId = nil
            self.intentName = nil
            self.kendraConfiguration = nil
            self.lastUpdatedDateTime = nil
            self.localeId = nil
            self.outputContexts = nil
            self.parentIntentSignature = nil
            self.sampleUtterances = nil
            self.slotPriorities = nil
        }
    }
}

public struct UpdateIntentOutputResponse: Swift.Equatable {
    /// The identifier of the bot that contains the intent.
    public var botId: Swift.String?
    /// The version of the bot that contains the intent. Will always be DRAFT.
    public var botVersion: Swift.String?
    /// A timestamp of when the intent was created.
    public var creationDateTime: ClientRuntime.Date?
    /// The updated description of the intent.
    public var description: Swift.String?
    /// The updated Lambda function called during each turn of the conversation with the user.
    public var dialogCodeHook: LexModelsV2ClientTypes.DialogCodeHookSettings?
    /// The updated Lambda function called when the intent is ready for fulfillment.
    public var fulfillmentCodeHook: LexModelsV2ClientTypes.FulfillmentCodeHookSettings?
    /// Configuration settings for a response sent to the user before Amazon Lex starts eliciting slots.
    public var initialResponseSetting: LexModelsV2ClientTypes.InitialResponseSetting?
    /// The updated list of contexts that must be active for the intent to be considered by Amazon Lex.
    public var inputContexts: [LexModelsV2ClientTypes.InputContext]?
    /// The updated response that Amazon Lex sends the user when the intent is closed.
    public var intentClosingSetting: LexModelsV2ClientTypes.IntentClosingSetting?
    /// The updated prompts that Amazon Lex sends to the user to confirm the completion of an intent.
    public var intentConfirmationSetting: LexModelsV2ClientTypes.IntentConfirmationSetting?
    /// The identifier of the intent that was updated.
    public var intentId: Swift.String?
    /// The updated name of the intent.
    public var intentName: Swift.String?
    /// The updated configuration for connecting to an Amazon Kendra index with the AMAZON.KendraSearchIntent intent.
    public var kendraConfiguration: LexModelsV2ClientTypes.KendraConfiguration?
    /// A timestamp of the last time that the intent was modified.
    public var lastUpdatedDateTime: ClientRuntime.Date?
    /// The updated language and locale of the intent.
    public var localeId: Swift.String?
    /// The updated list of contexts that Amazon Lex activates when the intent is fulfilled.
    public var outputContexts: [LexModelsV2ClientTypes.OutputContext]?
    /// The updated built-in intent that is the parent of this intent.
    public var parentIntentSignature: Swift.String?
    /// The updated list of sample utterances for the intent.
    public var sampleUtterances: [LexModelsV2ClientTypes.SampleUtterance]?
    /// The updated list of slots and their priorities that are elicited from the user for the intent.
    public var slotPriorities: [LexModelsV2ClientTypes.SlotPriority]?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        dialogCodeHook: LexModelsV2ClientTypes.DialogCodeHookSettings? = nil,
        fulfillmentCodeHook: LexModelsV2ClientTypes.FulfillmentCodeHookSettings? = nil,
        initialResponseSetting: LexModelsV2ClientTypes.InitialResponseSetting? = nil,
        inputContexts: [LexModelsV2ClientTypes.InputContext]? = nil,
        intentClosingSetting: LexModelsV2ClientTypes.IntentClosingSetting? = nil,
        intentConfirmationSetting: LexModelsV2ClientTypes.IntentConfirmationSetting? = nil,
        intentId: Swift.String? = nil,
        intentName: Swift.String? = nil,
        kendraConfiguration: LexModelsV2ClientTypes.KendraConfiguration? = nil,
        lastUpdatedDateTime: ClientRuntime.Date? = nil,
        localeId: Swift.String? = nil,
        outputContexts: [LexModelsV2ClientTypes.OutputContext]? = nil,
        parentIntentSignature: Swift.String? = nil,
        sampleUtterances: [LexModelsV2ClientTypes.SampleUtterance]? = nil,
        slotPriorities: [LexModelsV2ClientTypes.SlotPriority]? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.creationDateTime = creationDateTime
        self.description = description
        self.dialogCodeHook = dialogCodeHook
        self.fulfillmentCodeHook = fulfillmentCodeHook
        self.initialResponseSetting = initialResponseSetting
        self.inputContexts = inputContexts
        self.intentClosingSetting = intentClosingSetting
        self.intentConfirmationSetting = intentConfirmationSetting
        self.intentId = intentId
        self.intentName = intentName
        self.kendraConfiguration = kendraConfiguration
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.localeId = localeId
        self.outputContexts = outputContexts
        self.parentIntentSignature = parentIntentSignature
        self.sampleUtterances = sampleUtterances
        self.slotPriorities = slotPriorities
    }
}

struct UpdateIntentOutputResponseBody: Swift.Equatable {
    let intentId: Swift.String?
    let intentName: Swift.String?
    let description: Swift.String?
    let parentIntentSignature: Swift.String?
    let sampleUtterances: [LexModelsV2ClientTypes.SampleUtterance]?
    let dialogCodeHook: LexModelsV2ClientTypes.DialogCodeHookSettings?
    let fulfillmentCodeHook: LexModelsV2ClientTypes.FulfillmentCodeHookSettings?
    let slotPriorities: [LexModelsV2ClientTypes.SlotPriority]?
    let intentConfirmationSetting: LexModelsV2ClientTypes.IntentConfirmationSetting?
    let intentClosingSetting: LexModelsV2ClientTypes.IntentClosingSetting?
    let inputContexts: [LexModelsV2ClientTypes.InputContext]?
    let outputContexts: [LexModelsV2ClientTypes.OutputContext]?
    let kendraConfiguration: LexModelsV2ClientTypes.KendraConfiguration?
    let botId: Swift.String?
    let botVersion: Swift.String?
    let localeId: Swift.String?
    let creationDateTime: ClientRuntime.Date?
    let lastUpdatedDateTime: ClientRuntime.Date?
    let initialResponseSetting: LexModelsV2ClientTypes.InitialResponseSetting?
}

extension UpdateIntentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botVersion
        case creationDateTime
        case description
        case dialogCodeHook
        case fulfillmentCodeHook
        case initialResponseSetting
        case inputContexts
        case intentClosingSetting
        case intentConfirmationSetting
        case intentId
        case intentName
        case kendraConfiguration
        case lastUpdatedDateTime
        case localeId
        case outputContexts
        case parentIntentSignature
        case sampleUtterances
        case slotPriorities
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intentId)
        intentId = intentIdDecoded
        let intentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intentName)
        intentName = intentNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parentIntentSignatureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentIntentSignature)
        parentIntentSignature = parentIntentSignatureDecoded
        let sampleUtterancesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.SampleUtterance?].self, forKey: .sampleUtterances)
        var sampleUtterancesDecoded0:[LexModelsV2ClientTypes.SampleUtterance]? = nil
        if let sampleUtterancesContainer = sampleUtterancesContainer {
            sampleUtterancesDecoded0 = [LexModelsV2ClientTypes.SampleUtterance]()
            for structure0 in sampleUtterancesContainer {
                if let structure0 = structure0 {
                    sampleUtterancesDecoded0?.append(structure0)
                }
            }
        }
        sampleUtterances = sampleUtterancesDecoded0
        let dialogCodeHookDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.DialogCodeHookSettings.self, forKey: .dialogCodeHook)
        dialogCodeHook = dialogCodeHookDecoded
        let fulfillmentCodeHookDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.FulfillmentCodeHookSettings.self, forKey: .fulfillmentCodeHook)
        fulfillmentCodeHook = fulfillmentCodeHookDecoded
        let slotPrioritiesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.SlotPriority?].self, forKey: .slotPriorities)
        var slotPrioritiesDecoded0:[LexModelsV2ClientTypes.SlotPriority]? = nil
        if let slotPrioritiesContainer = slotPrioritiesContainer {
            slotPrioritiesDecoded0 = [LexModelsV2ClientTypes.SlotPriority]()
            for structure0 in slotPrioritiesContainer {
                if let structure0 = structure0 {
                    slotPrioritiesDecoded0?.append(structure0)
                }
            }
        }
        slotPriorities = slotPrioritiesDecoded0
        let intentConfirmationSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.IntentConfirmationSetting.self, forKey: .intentConfirmationSetting)
        intentConfirmationSetting = intentConfirmationSettingDecoded
        let intentClosingSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.IntentClosingSetting.self, forKey: .intentClosingSetting)
        intentClosingSetting = intentClosingSettingDecoded
        let inputContextsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.InputContext?].self, forKey: .inputContexts)
        var inputContextsDecoded0:[LexModelsV2ClientTypes.InputContext]? = nil
        if let inputContextsContainer = inputContextsContainer {
            inputContextsDecoded0 = [LexModelsV2ClientTypes.InputContext]()
            for structure0 in inputContextsContainer {
                if let structure0 = structure0 {
                    inputContextsDecoded0?.append(structure0)
                }
            }
        }
        inputContexts = inputContextsDecoded0
        let outputContextsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.OutputContext?].self, forKey: .outputContexts)
        var outputContextsDecoded0:[LexModelsV2ClientTypes.OutputContext]? = nil
        if let outputContextsContainer = outputContextsContainer {
            outputContextsDecoded0 = [LexModelsV2ClientTypes.OutputContext]()
            for structure0 in outputContextsContainer {
                if let structure0 = structure0 {
                    outputContextsDecoded0?.append(structure0)
                }
            }
        }
        outputContexts = outputContextsDecoded0
        let kendraConfigurationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.KendraConfiguration.self, forKey: .kendraConfiguration)
        kendraConfiguration = kendraConfigurationDecoded
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let initialResponseSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.InitialResponseSetting.self, forKey: .initialResponseSetting)
        initialResponseSetting = initialResponseSettingDecoded
    }
}

extension UpdateResourcePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

extension UpdateResourcePolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let expectedRevisionId = expectedRevisionId {
                let expectedRevisionIdQueryItem = ClientRuntime.URLQueryItem(name: "expectedRevisionId".urlPercentEncoding(), value: Swift.String(expectedRevisionId).urlPercentEncoding())
                items.append(expectedRevisionIdQueryItem)
            }
            return items
        }
    }
}

extension UpdateResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/policy/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UpdateResourcePolicyInput: Swift.Equatable {
    /// The identifier of the revision of the policy to update. If this revision ID doesn't match the current revision ID, Amazon Lex throws an exception. If you don't specify a revision, Amazon Lex overwrites the contents of the policy with the new values.
    public var expectedRevisionId: Swift.String?
    /// A resource policy to add to the resource. The policy is a JSON structure that contains one or more statements that define the policy. The policy must follow the IAM syntax. For more information about the contents of a JSON policy document, see [ IAM JSON policy reference ](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies.html). If the policy isn't valid, Amazon Lex returns a validation exception.
    /// This member is required.
    public var policy: Swift.String?
    /// The Amazon Resource Name (ARN) of the bot or bot alias that the resource policy is attached to.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        expectedRevisionId: Swift.String? = nil,
        policy: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.expectedRevisionId = expectedRevisionId
        self.policy = policy
        self.resourceArn = resourceArn
    }
}

struct UpdateResourcePolicyInputBody: Swift.Equatable {
    let policy: Swift.String?
}

extension UpdateResourcePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum UpdateResourcePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateResourcePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateResourcePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceArn = output.resourceArn
            self.revisionId = output.revisionId
        } else {
            self.resourceArn = nil
            self.revisionId = nil
        }
    }
}

public struct UpdateResourcePolicyOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the bot or bot alias that the resource policy is attached to.
    public var resourceArn: Swift.String?
    /// The current revision of the resource policy. Use the revision ID to make sure that you are updating the most current version of a resource policy when you add a policy statement to a resource, delete a resource, or update a resource.
    public var revisionId: Swift.String?

    public init(
        resourceArn: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
        self.revisionId = revisionId
    }
}

struct UpdateResourcePolicyOutputResponseBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let revisionId: Swift.String?
}

extension UpdateResourcePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case revisionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension UpdateSlotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case multipleValuesSetting
        case obfuscationSetting
        case slotName
        case slotTypeId
        case subSlotSetting
        case valueElicitationSetting
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let multipleValuesSetting = self.multipleValuesSetting {
            try encodeContainer.encode(multipleValuesSetting, forKey: .multipleValuesSetting)
        }
        if let obfuscationSetting = self.obfuscationSetting {
            try encodeContainer.encode(obfuscationSetting, forKey: .obfuscationSetting)
        }
        if let slotName = self.slotName {
            try encodeContainer.encode(slotName, forKey: .slotName)
        }
        if let slotTypeId = self.slotTypeId {
            try encodeContainer.encode(slotTypeId, forKey: .slotTypeId)
        }
        if let subSlotSetting = self.subSlotSetting {
            try encodeContainer.encode(subSlotSetting, forKey: .subSlotSetting)
        }
        if let valueElicitationSetting = self.valueElicitationSetting {
            try encodeContainer.encode(valueElicitationSetting, forKey: .valueElicitationSetting)
        }
    }
}

extension UpdateSlotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botVersion = botVersion else {
            return nil
        }
        guard let localeId = localeId else {
            return nil
        }
        guard let intentId = intentId else {
            return nil
        }
        guard let slotId = slotId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botversions/\(botVersion.urlPercentEncoding())/botlocales/\(localeId.urlPercentEncoding())/intents/\(intentId.urlPercentEncoding())/slots/\(slotId.urlPercentEncoding())"
    }
}

public struct UpdateSlotInput: Swift.Equatable {
    /// The unique identifier of the bot that contains the slot.
    /// This member is required.
    public var botId: Swift.String?
    /// The version of the bot that contains the slot. Must always be DRAFT.
    /// This member is required.
    public var botVersion: Swift.String?
    /// The new description for the slot.
    public var description: Swift.String?
    /// The identifier of the intent that contains the slot.
    /// This member is required.
    public var intentId: Swift.String?
    /// The identifier of the language and locale that contains the slot. The string must match one of the supported locales. For more information, see [Supported languages](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html).
    /// This member is required.
    public var localeId: Swift.String?
    /// Determines whether the slot accepts multiple values in one response. Multiple value slots are only available in the en-US locale. If you set this value to true in any other locale, Amazon Lex throws a ValidationException. If the multipleValuesSetting is not set, the default value is false.
    public var multipleValuesSetting: LexModelsV2ClientTypes.MultipleValuesSetting?
    /// New settings that determine how slot values are formatted in Amazon CloudWatch logs.
    public var obfuscationSetting: LexModelsV2ClientTypes.ObfuscationSetting?
    /// The unique identifier for the slot to update.
    /// This member is required.
    public var slotId: Swift.String?
    /// The new name for the slot.
    /// This member is required.
    public var slotName: Swift.String?
    /// The unique identifier of the new slot type to associate with this slot.
    public var slotTypeId: Swift.String?
    /// Specifications for the constituent sub slots and the expression for the composite slot.
    public var subSlotSetting: LexModelsV2ClientTypes.SubSlotSetting?
    /// A new set of prompts that Amazon Lex sends to the user to elicit a response the provides a value for the slot.
    /// This member is required.
    public var valueElicitationSetting: LexModelsV2ClientTypes.SlotValueElicitationSetting?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        description: Swift.String? = nil,
        intentId: Swift.String? = nil,
        localeId: Swift.String? = nil,
        multipleValuesSetting: LexModelsV2ClientTypes.MultipleValuesSetting? = nil,
        obfuscationSetting: LexModelsV2ClientTypes.ObfuscationSetting? = nil,
        slotId: Swift.String? = nil,
        slotName: Swift.String? = nil,
        slotTypeId: Swift.String? = nil,
        subSlotSetting: LexModelsV2ClientTypes.SubSlotSetting? = nil,
        valueElicitationSetting: LexModelsV2ClientTypes.SlotValueElicitationSetting? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.description = description
        self.intentId = intentId
        self.localeId = localeId
        self.multipleValuesSetting = multipleValuesSetting
        self.obfuscationSetting = obfuscationSetting
        self.slotId = slotId
        self.slotName = slotName
        self.slotTypeId = slotTypeId
        self.subSlotSetting = subSlotSetting
        self.valueElicitationSetting = valueElicitationSetting
    }
}

struct UpdateSlotInputBody: Swift.Equatable {
    let slotName: Swift.String?
    let description: Swift.String?
    let slotTypeId: Swift.String?
    let valueElicitationSetting: LexModelsV2ClientTypes.SlotValueElicitationSetting?
    let obfuscationSetting: LexModelsV2ClientTypes.ObfuscationSetting?
    let multipleValuesSetting: LexModelsV2ClientTypes.MultipleValuesSetting?
    let subSlotSetting: LexModelsV2ClientTypes.SubSlotSetting?
}

extension UpdateSlotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case multipleValuesSetting
        case obfuscationSetting
        case slotName
        case slotTypeId
        case subSlotSetting
        case valueElicitationSetting
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let slotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotName)
        slotName = slotNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let slotTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotTypeId)
        slotTypeId = slotTypeIdDecoded
        let valueElicitationSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SlotValueElicitationSetting.self, forKey: .valueElicitationSetting)
        valueElicitationSetting = valueElicitationSettingDecoded
        let obfuscationSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ObfuscationSetting.self, forKey: .obfuscationSetting)
        obfuscationSetting = obfuscationSettingDecoded
        let multipleValuesSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.MultipleValuesSetting.self, forKey: .multipleValuesSetting)
        multipleValuesSetting = multipleValuesSettingDecoded
        let subSlotSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SubSlotSetting.self, forKey: .subSlotSetting)
        subSlotSetting = subSlotSettingDecoded
    }
}

enum UpdateSlotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSlotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSlotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.intentId = output.intentId
            self.lastUpdatedDateTime = output.lastUpdatedDateTime
            self.localeId = output.localeId
            self.multipleValuesSetting = output.multipleValuesSetting
            self.obfuscationSetting = output.obfuscationSetting
            self.slotId = output.slotId
            self.slotName = output.slotName
            self.slotTypeId = output.slotTypeId
            self.subSlotSetting = output.subSlotSetting
            self.valueElicitationSetting = output.valueElicitationSetting
        } else {
            self.botId = nil
            self.botVersion = nil
            self.creationDateTime = nil
            self.description = nil
            self.intentId = nil
            self.lastUpdatedDateTime = nil
            self.localeId = nil
            self.multipleValuesSetting = nil
            self.obfuscationSetting = nil
            self.slotId = nil
            self.slotName = nil
            self.slotTypeId = nil
            self.subSlotSetting = nil
            self.valueElicitationSetting = nil
        }
    }
}

public struct UpdateSlotOutputResponse: Swift.Equatable {
    /// The identifier of the bot that contains the slot.
    public var botId: Swift.String?
    /// The version of the bot that contains the slot. Will always be DRAFT.
    public var botVersion: Swift.String?
    /// The timestamp of the date and time that the slot was created.
    public var creationDateTime: ClientRuntime.Date?
    /// The updated description of the bot.
    public var description: Swift.String?
    /// The intent that contains the slot.
    public var intentId: Swift.String?
    /// The timestamp of the date and time that the slot was last updated.
    public var lastUpdatedDateTime: ClientRuntime.Date?
    /// The locale that contains the slot.
    public var localeId: Swift.String?
    /// Indicates whether the slot accepts multiple values in one response.
    public var multipleValuesSetting: LexModelsV2ClientTypes.MultipleValuesSetting?
    /// The updated setting that determines whether the slot value is obfuscated in the Amazon CloudWatch logs.
    public var obfuscationSetting: LexModelsV2ClientTypes.ObfuscationSetting?
    /// The unique identifier of the slot that was updated.
    public var slotId: Swift.String?
    /// The updated name of the slot.
    public var slotName: Swift.String?
    /// The updated identifier of the slot type that provides values for the slot.
    public var slotTypeId: Swift.String?
    /// Specifications for the constituent sub slots and the expression for the composite slot.
    public var subSlotSetting: LexModelsV2ClientTypes.SubSlotSetting?
    /// The updated prompts that Amazon Lex sends to the user to elicit a response that provides a value for the slot.
    public var valueElicitationSetting: LexModelsV2ClientTypes.SlotValueElicitationSetting?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        intentId: Swift.String? = nil,
        lastUpdatedDateTime: ClientRuntime.Date? = nil,
        localeId: Swift.String? = nil,
        multipleValuesSetting: LexModelsV2ClientTypes.MultipleValuesSetting? = nil,
        obfuscationSetting: LexModelsV2ClientTypes.ObfuscationSetting? = nil,
        slotId: Swift.String? = nil,
        slotName: Swift.String? = nil,
        slotTypeId: Swift.String? = nil,
        subSlotSetting: LexModelsV2ClientTypes.SubSlotSetting? = nil,
        valueElicitationSetting: LexModelsV2ClientTypes.SlotValueElicitationSetting? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.creationDateTime = creationDateTime
        self.description = description
        self.intentId = intentId
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.localeId = localeId
        self.multipleValuesSetting = multipleValuesSetting
        self.obfuscationSetting = obfuscationSetting
        self.slotId = slotId
        self.slotName = slotName
        self.slotTypeId = slotTypeId
        self.subSlotSetting = subSlotSetting
        self.valueElicitationSetting = valueElicitationSetting
    }
}

struct UpdateSlotOutputResponseBody: Swift.Equatable {
    let slotId: Swift.String?
    let slotName: Swift.String?
    let description: Swift.String?
    let slotTypeId: Swift.String?
    let valueElicitationSetting: LexModelsV2ClientTypes.SlotValueElicitationSetting?
    let obfuscationSetting: LexModelsV2ClientTypes.ObfuscationSetting?
    let botId: Swift.String?
    let botVersion: Swift.String?
    let localeId: Swift.String?
    let intentId: Swift.String?
    let creationDateTime: ClientRuntime.Date?
    let lastUpdatedDateTime: ClientRuntime.Date?
    let multipleValuesSetting: LexModelsV2ClientTypes.MultipleValuesSetting?
    let subSlotSetting: LexModelsV2ClientTypes.SubSlotSetting?
}

extension UpdateSlotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botVersion
        case creationDateTime
        case description
        case intentId
        case lastUpdatedDateTime
        case localeId
        case multipleValuesSetting
        case obfuscationSetting
        case slotId
        case slotName
        case slotTypeId
        case subSlotSetting
        case valueElicitationSetting
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let slotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotId)
        slotId = slotIdDecoded
        let slotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotName)
        slotName = slotNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let slotTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotTypeId)
        slotTypeId = slotTypeIdDecoded
        let valueElicitationSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SlotValueElicitationSetting.self, forKey: .valueElicitationSetting)
        valueElicitationSetting = valueElicitationSettingDecoded
        let obfuscationSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ObfuscationSetting.self, forKey: .obfuscationSetting)
        obfuscationSetting = obfuscationSettingDecoded
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let intentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intentId)
        intentId = intentIdDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let multipleValuesSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.MultipleValuesSetting.self, forKey: .multipleValuesSetting)
        multipleValuesSetting = multipleValuesSettingDecoded
        let subSlotSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SubSlotSetting.self, forKey: .subSlotSetting)
        subSlotSetting = subSlotSettingDecoded
    }
}

extension UpdateSlotTypeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compositeSlotTypeSetting
        case description
        case externalSourceSetting
        case parentSlotTypeSignature
        case slotTypeName
        case slotTypeValues
        case valueSelectionSetting
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compositeSlotTypeSetting = self.compositeSlotTypeSetting {
            try encodeContainer.encode(compositeSlotTypeSetting, forKey: .compositeSlotTypeSetting)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let externalSourceSetting = self.externalSourceSetting {
            try encodeContainer.encode(externalSourceSetting, forKey: .externalSourceSetting)
        }
        if let parentSlotTypeSignature = self.parentSlotTypeSignature {
            try encodeContainer.encode(parentSlotTypeSignature, forKey: .parentSlotTypeSignature)
        }
        if let slotTypeName = self.slotTypeName {
            try encodeContainer.encode(slotTypeName, forKey: .slotTypeName)
        }
        if let slotTypeValues = slotTypeValues {
            var slotTypeValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .slotTypeValues)
            for slottypevalue0 in slotTypeValues {
                try slotTypeValuesContainer.encode(slottypevalue0)
            }
        }
        if let valueSelectionSetting = self.valueSelectionSetting {
            try encodeContainer.encode(valueSelectionSetting, forKey: .valueSelectionSetting)
        }
    }
}

extension UpdateSlotTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botVersion = botVersion else {
            return nil
        }
        guard let localeId = localeId else {
            return nil
        }
        guard let slotTypeId = slotTypeId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botversions/\(botVersion.urlPercentEncoding())/botlocales/\(localeId.urlPercentEncoding())/slottypes/\(slotTypeId.urlPercentEncoding())"
    }
}

public struct UpdateSlotTypeInput: Swift.Equatable {
    /// The identifier of the bot that contains the slot type.
    /// This member is required.
    public var botId: Swift.String?
    /// The version of the bot that contains the slot type. Must be DRAFT.
    /// This member is required.
    public var botVersion: Swift.String?
    /// Specifications for a composite slot type.
    public var compositeSlotTypeSetting: LexModelsV2ClientTypes.CompositeSlotTypeSetting?
    /// The new description of the slot type.
    public var description: Swift.String?
    /// Provides information about the external source of the slot type's definition.
    public var externalSourceSetting: LexModelsV2ClientTypes.ExternalSourceSetting?
    /// The identifier of the language and locale that contains the slot type. The string must match one of the supported locales. For more information, see [Supported languages](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html).
    /// This member is required.
    public var localeId: Swift.String?
    /// The new built-in slot type that should be used as the parent of this slot type.
    public var parentSlotTypeSignature: Swift.String?
    /// The unique identifier of the slot type to update.
    /// This member is required.
    public var slotTypeId: Swift.String?
    /// The new name of the slot type.
    /// This member is required.
    public var slotTypeName: Swift.String?
    /// A new list of values and their optional synonyms that define the values that the slot type can take.
    public var slotTypeValues: [LexModelsV2ClientTypes.SlotTypeValue]?
    /// The strategy that Amazon Lex should use when deciding on a value from the list of slot type values.
    public var valueSelectionSetting: LexModelsV2ClientTypes.SlotValueSelectionSetting?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        compositeSlotTypeSetting: LexModelsV2ClientTypes.CompositeSlotTypeSetting? = nil,
        description: Swift.String? = nil,
        externalSourceSetting: LexModelsV2ClientTypes.ExternalSourceSetting? = nil,
        localeId: Swift.String? = nil,
        parentSlotTypeSignature: Swift.String? = nil,
        slotTypeId: Swift.String? = nil,
        slotTypeName: Swift.String? = nil,
        slotTypeValues: [LexModelsV2ClientTypes.SlotTypeValue]? = nil,
        valueSelectionSetting: LexModelsV2ClientTypes.SlotValueSelectionSetting? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.compositeSlotTypeSetting = compositeSlotTypeSetting
        self.description = description
        self.externalSourceSetting = externalSourceSetting
        self.localeId = localeId
        self.parentSlotTypeSignature = parentSlotTypeSignature
        self.slotTypeId = slotTypeId
        self.slotTypeName = slotTypeName
        self.slotTypeValues = slotTypeValues
        self.valueSelectionSetting = valueSelectionSetting
    }
}

struct UpdateSlotTypeInputBody: Swift.Equatable {
    let slotTypeName: Swift.String?
    let description: Swift.String?
    let slotTypeValues: [LexModelsV2ClientTypes.SlotTypeValue]?
    let valueSelectionSetting: LexModelsV2ClientTypes.SlotValueSelectionSetting?
    let parentSlotTypeSignature: Swift.String?
    let externalSourceSetting: LexModelsV2ClientTypes.ExternalSourceSetting?
    let compositeSlotTypeSetting: LexModelsV2ClientTypes.CompositeSlotTypeSetting?
}

extension UpdateSlotTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compositeSlotTypeSetting
        case description
        case externalSourceSetting
        case parentSlotTypeSignature
        case slotTypeName
        case slotTypeValues
        case valueSelectionSetting
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let slotTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotTypeName)
        slotTypeName = slotTypeNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let slotTypeValuesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.SlotTypeValue?].self, forKey: .slotTypeValues)
        var slotTypeValuesDecoded0:[LexModelsV2ClientTypes.SlotTypeValue]? = nil
        if let slotTypeValuesContainer = slotTypeValuesContainer {
            slotTypeValuesDecoded0 = [LexModelsV2ClientTypes.SlotTypeValue]()
            for structure0 in slotTypeValuesContainer {
                if let structure0 = structure0 {
                    slotTypeValuesDecoded0?.append(structure0)
                }
            }
        }
        slotTypeValues = slotTypeValuesDecoded0
        let valueSelectionSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SlotValueSelectionSetting.self, forKey: .valueSelectionSetting)
        valueSelectionSetting = valueSelectionSettingDecoded
        let parentSlotTypeSignatureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentSlotTypeSignature)
        parentSlotTypeSignature = parentSlotTypeSignatureDecoded
        let externalSourceSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ExternalSourceSetting.self, forKey: .externalSourceSetting)
        externalSourceSetting = externalSourceSettingDecoded
        let compositeSlotTypeSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.CompositeSlotTypeSetting.self, forKey: .compositeSlotTypeSetting)
        compositeSlotTypeSetting = compositeSlotTypeSettingDecoded
    }
}

enum UpdateSlotTypeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSlotTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSlotTypeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.compositeSlotTypeSetting = output.compositeSlotTypeSetting
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.externalSourceSetting = output.externalSourceSetting
            self.lastUpdatedDateTime = output.lastUpdatedDateTime
            self.localeId = output.localeId
            self.parentSlotTypeSignature = output.parentSlotTypeSignature
            self.slotTypeId = output.slotTypeId
            self.slotTypeName = output.slotTypeName
            self.slotTypeValues = output.slotTypeValues
            self.valueSelectionSetting = output.valueSelectionSetting
        } else {
            self.botId = nil
            self.botVersion = nil
            self.compositeSlotTypeSetting = nil
            self.creationDateTime = nil
            self.description = nil
            self.externalSourceSetting = nil
            self.lastUpdatedDateTime = nil
            self.localeId = nil
            self.parentSlotTypeSignature = nil
            self.slotTypeId = nil
            self.slotTypeName = nil
            self.slotTypeValues = nil
            self.valueSelectionSetting = nil
        }
    }
}

public struct UpdateSlotTypeOutputResponse: Swift.Equatable {
    /// The identifier of the bot that contains the slot type.
    public var botId: Swift.String?
    /// The version of the bot that contains the slot type. This is always DRAFT.
    public var botVersion: Swift.String?
    /// Specifications for a composite slot type.
    public var compositeSlotTypeSetting: LexModelsV2ClientTypes.CompositeSlotTypeSetting?
    /// The timestamp of the date and time that the slot type was created.
    public var creationDateTime: ClientRuntime.Date?
    /// The updated description of the slot type.
    public var description: Swift.String?
    /// Provides information about the external source of the slot type's definition.
    public var externalSourceSetting: LexModelsV2ClientTypes.ExternalSourceSetting?
    /// A timestamp of the date and time that the slot type was last updated.
    public var lastUpdatedDateTime: ClientRuntime.Date?
    /// The language and locale of the updated slot type.
    public var localeId: Swift.String?
    /// The updated signature of the built-in slot type that is the parent of this slot type.
    public var parentSlotTypeSignature: Swift.String?
    /// The unique identifier of the updated slot type.
    public var slotTypeId: Swift.String?
    /// The updated name of the slot type.
    public var slotTypeName: Swift.String?
    /// The updated values that the slot type provides.
    public var slotTypeValues: [LexModelsV2ClientTypes.SlotTypeValue]?
    /// The updated strategy that Amazon Lex uses to determine which value to select from the slot type.
    public var valueSelectionSetting: LexModelsV2ClientTypes.SlotValueSelectionSetting?

    public init(
        botId: Swift.String? = nil,
        botVersion: Swift.String? = nil,
        compositeSlotTypeSetting: LexModelsV2ClientTypes.CompositeSlotTypeSetting? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        externalSourceSetting: LexModelsV2ClientTypes.ExternalSourceSetting? = nil,
        lastUpdatedDateTime: ClientRuntime.Date? = nil,
        localeId: Swift.String? = nil,
        parentSlotTypeSignature: Swift.String? = nil,
        slotTypeId: Swift.String? = nil,
        slotTypeName: Swift.String? = nil,
        slotTypeValues: [LexModelsV2ClientTypes.SlotTypeValue]? = nil,
        valueSelectionSetting: LexModelsV2ClientTypes.SlotValueSelectionSetting? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.compositeSlotTypeSetting = compositeSlotTypeSetting
        self.creationDateTime = creationDateTime
        self.description = description
        self.externalSourceSetting = externalSourceSetting
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.localeId = localeId
        self.parentSlotTypeSignature = parentSlotTypeSignature
        self.slotTypeId = slotTypeId
        self.slotTypeName = slotTypeName
        self.slotTypeValues = slotTypeValues
        self.valueSelectionSetting = valueSelectionSetting
    }
}

struct UpdateSlotTypeOutputResponseBody: Swift.Equatable {
    let slotTypeId: Swift.String?
    let slotTypeName: Swift.String?
    let description: Swift.String?
    let slotTypeValues: [LexModelsV2ClientTypes.SlotTypeValue]?
    let valueSelectionSetting: LexModelsV2ClientTypes.SlotValueSelectionSetting?
    let parentSlotTypeSignature: Swift.String?
    let botId: Swift.String?
    let botVersion: Swift.String?
    let localeId: Swift.String?
    let creationDateTime: ClientRuntime.Date?
    let lastUpdatedDateTime: ClientRuntime.Date?
    let externalSourceSetting: LexModelsV2ClientTypes.ExternalSourceSetting?
    let compositeSlotTypeSetting: LexModelsV2ClientTypes.CompositeSlotTypeSetting?
}

extension UpdateSlotTypeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId
        case botVersion
        case compositeSlotTypeSetting
        case creationDateTime
        case description
        case externalSourceSetting
        case lastUpdatedDateTime
        case localeId
        case parentSlotTypeSignature
        case slotTypeId
        case slotTypeName
        case slotTypeValues
        case valueSelectionSetting
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let slotTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotTypeId)
        slotTypeId = slotTypeIdDecoded
        let slotTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotTypeName)
        slotTypeName = slotTypeNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let slotTypeValuesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.SlotTypeValue?].self, forKey: .slotTypeValues)
        var slotTypeValuesDecoded0:[LexModelsV2ClientTypes.SlotTypeValue]? = nil
        if let slotTypeValuesContainer = slotTypeValuesContainer {
            slotTypeValuesDecoded0 = [LexModelsV2ClientTypes.SlotTypeValue]()
            for structure0 in slotTypeValuesContainer {
                if let structure0 = structure0 {
                    slotTypeValuesDecoded0?.append(structure0)
                }
            }
        }
        slotTypeValues = slotTypeValuesDecoded0
        let valueSelectionSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.SlotValueSelectionSetting.self, forKey: .valueSelectionSetting)
        valueSelectionSetting = valueSelectionSettingDecoded
        let parentSlotTypeSignatureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentSlotTypeSignature)
        parentSlotTypeSignature = parentSlotTypeSignatureDecoded
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let externalSourceSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ExternalSourceSetting.self, forKey: .externalSourceSetting)
        externalSourceSetting = externalSourceSettingDecoded
        let compositeSlotTypeSettingDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.CompositeSlotTypeSetting.self, forKey: .compositeSlotTypeSetting)
        compositeSlotTypeSetting = compositeSlotTypeSettingDecoded
    }
}

extension UpdateTestSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case testSetName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let testSetName = self.testSetName {
            try encodeContainer.encode(testSetName, forKey: .testSetName)
        }
    }
}

extension UpdateTestSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let testSetId = testSetId else {
            return nil
        }
        return "/testsets/\(testSetId.urlPercentEncoding())"
    }
}

public struct UpdateTestSetInput: Swift.Equatable {
    /// The new test set description.
    public var description: Swift.String?
    /// The test set Id for which update test operation to be performed.
    /// This member is required.
    public var testSetId: Swift.String?
    /// The new test set name.
    /// This member is required.
    public var testSetName: Swift.String?

    public init(
        description: Swift.String? = nil,
        testSetId: Swift.String? = nil,
        testSetName: Swift.String? = nil
    )
    {
        self.description = description
        self.testSetId = testSetId
        self.testSetName = testSetName
    }
}

struct UpdateTestSetInputBody: Swift.Equatable {
    let testSetName: Swift.String?
    let description: Swift.String?
}

extension UpdateTestSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case testSetName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testSetName)
        testSetName = testSetNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

enum UpdateTestSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateTestSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateTestSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.lastUpdatedDateTime = output.lastUpdatedDateTime
            self.modality = output.modality
            self.numTurns = output.numTurns
            self.roleArn = output.roleArn
            self.status = output.status
            self.storageLocation = output.storageLocation
            self.testSetId = output.testSetId
            self.testSetName = output.testSetName
        } else {
            self.creationDateTime = nil
            self.description = nil
            self.lastUpdatedDateTime = nil
            self.modality = nil
            self.numTurns = nil
            self.roleArn = nil
            self.status = nil
            self.storageLocation = nil
            self.testSetId = nil
            self.testSetName = nil
        }
    }
}

public struct UpdateTestSetOutputResponse: Swift.Equatable {
    /// The creation date and time for the updated test set.
    public var creationDateTime: ClientRuntime.Date?
    /// The test set description for the updated test set.
    public var description: Swift.String?
    /// The date and time of the last update for the updated test set.
    public var lastUpdatedDateTime: ClientRuntime.Date?
    /// Indicates whether audio or text is used for the updated test set.
    public var modality: LexModelsV2ClientTypes.TestSetModality?
    /// The number of conversation turns from the updated test set.
    public var numTurns: Swift.Int?
    /// The roleARN used for any operation in the test set to access resources in the Amazon Web Services account.
    public var roleArn: Swift.String?
    /// The status for the updated test set.
    public var status: LexModelsV2ClientTypes.TestSetStatus?
    /// The Amazon S3 storage location for the updated test set.
    public var storageLocation: LexModelsV2ClientTypes.TestSetStorageLocation?
    /// The test set Id for which update test operation to be performed.
    public var testSetId: Swift.String?
    /// The test set name for the updated test set.
    public var testSetName: Swift.String?

    public init(
        creationDateTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        lastUpdatedDateTime: ClientRuntime.Date? = nil,
        modality: LexModelsV2ClientTypes.TestSetModality? = nil,
        numTurns: Swift.Int? = nil,
        roleArn: Swift.String? = nil,
        status: LexModelsV2ClientTypes.TestSetStatus? = nil,
        storageLocation: LexModelsV2ClientTypes.TestSetStorageLocation? = nil,
        testSetId: Swift.String? = nil,
        testSetName: Swift.String? = nil
    )
    {
        self.creationDateTime = creationDateTime
        self.description = description
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.modality = modality
        self.numTurns = numTurns
        self.roleArn = roleArn
        self.status = status
        self.storageLocation = storageLocation
        self.testSetId = testSetId
        self.testSetName = testSetName
    }
}

struct UpdateTestSetOutputResponseBody: Swift.Equatable {
    let testSetId: Swift.String?
    let testSetName: Swift.String?
    let description: Swift.String?
    let modality: LexModelsV2ClientTypes.TestSetModality?
    let status: LexModelsV2ClientTypes.TestSetStatus?
    let roleArn: Swift.String?
    let numTurns: Swift.Int?
    let storageLocation: LexModelsV2ClientTypes.TestSetStorageLocation?
    let creationDateTime: ClientRuntime.Date?
    let lastUpdatedDateTime: ClientRuntime.Date?
}

extension UpdateTestSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case description
        case lastUpdatedDateTime
        case modality
        case numTurns
        case roleArn
        case status
        case storageLocation
        case testSetId
        case testSetName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testSetId)
        testSetId = testSetIdDecoded
        let testSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testSetName)
        testSetName = testSetNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let modalityDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestSetModality.self, forKey: .modality)
        modality = modalityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestSetStatus.self, forKey: .status)
        status = statusDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let numTurnsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numTurns)
        numTurns = numTurnsDecoded
        let storageLocationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestSetStorageLocation.self, forKey: .storageLocation)
        storageLocation = storageLocationDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension LexModelsV2ClientTypes.UserTurnInputSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestAttributes
        case sessionState
        case utteranceInput
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let requestAttributes = requestAttributes {
            var requestAttributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestAttributes)
            for (dictKey0, stringMap0) in requestAttributes {
                try requestAttributesContainer.encode(stringMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let sessionState = self.sessionState {
            try encodeContainer.encode(sessionState, forKey: .sessionState)
        }
        if let utteranceInput = self.utteranceInput {
            try encodeContainer.encode(utteranceInput, forKey: .utteranceInput)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let utteranceInputDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.UtteranceInputSpecification.self, forKey: .utteranceInput)
        utteranceInput = utteranceInputDecoded
        let requestAttributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestAttributes)
        var requestAttributesDecoded0: [Swift.String:Swift.String]? = nil
        if let requestAttributesContainer = requestAttributesContainer {
            requestAttributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestAttributesContainer {
                if let string0 = string0 {
                    requestAttributesDecoded0?[key0] = string0
                }
            }
        }
        requestAttributes = requestAttributesDecoded0
        let sessionStateDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.InputSessionStateSpecification.self, forKey: .sessionState)
        sessionState = sessionStateDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Contains information about the user messages in the turn in the input.
    public struct UserTurnInputSpecification: Swift.Equatable {
        /// Request attributes of the user turn.
        public var requestAttributes: [Swift.String:Swift.String]?
        /// Contains information about the session state in the input.
        public var sessionState: LexModelsV2ClientTypes.InputSessionStateSpecification?
        /// The utterance input in the user turn.
        /// This member is required.
        public var utteranceInput: LexModelsV2ClientTypes.UtteranceInputSpecification?

        public init(
            requestAttributes: [Swift.String:Swift.String]? = nil,
            sessionState: LexModelsV2ClientTypes.InputSessionStateSpecification? = nil,
            utteranceInput: LexModelsV2ClientTypes.UtteranceInputSpecification? = nil
        )
        {
            self.requestAttributes = requestAttributes
            self.sessionState = sessionState
            self.utteranceInput = utteranceInput
        }
    }

}

extension LexModelsV2ClientTypes.UserTurnIntentOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case slots
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let slots = slots {
            var slotsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .slots)
            for (dictKey0, userTurnSlotOutputMap0) in slots {
                try slotsContainer.encode(userTurnSlotOutputMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let slotsContainer = try containerValues.decodeIfPresent([Swift.String: LexModelsV2ClientTypes.UserTurnSlotOutput?].self, forKey: .slots)
        var slotsDecoded0: [Swift.String:LexModelsV2ClientTypes.UserTurnSlotOutput]? = nil
        if let slotsContainer = slotsContainer {
            slotsDecoded0 = [Swift.String:LexModelsV2ClientTypes.UserTurnSlotOutput]()
            for (key0, userturnslotoutput0) in slotsContainer {
                if let userturnslotoutput0 = userturnslotoutput0 {
                    slotsDecoded0?[key0] = userturnslotoutput0
                }
            }
        }
        slots = slotsDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// Contains information about the intent that is output for the turn by the test execution.
    public struct UserTurnIntentOutput: Swift.Equatable {
        /// The name of the intent.
        /// This member is required.
        public var name: Swift.String?
        /// The slots associated with the intent.
        public var slots: [Swift.String:LexModelsV2ClientTypes.UserTurnSlotOutput]?

        public init(
            name: Swift.String? = nil,
            slots: [Swift.String:LexModelsV2ClientTypes.UserTurnSlotOutput]? = nil
        )
        {
            self.name = name
            self.slots = slots
        }
    }

}

extension LexModelsV2ClientTypes.UserTurnOutputSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeContexts
        case intent
        case transcript
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeContexts = activeContexts {
            var activeContextsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .activeContexts)
            for activecontext0 in activeContexts {
                try activeContextsContainer.encode(activecontext0)
            }
        }
        if let intent = self.intent {
            try encodeContainer.encode(intent, forKey: .intent)
        }
        if let transcript = self.transcript {
            try encodeContainer.encode(transcript, forKey: .transcript)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intentDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.UserTurnIntentOutput.self, forKey: .intent)
        intent = intentDecoded
        let activeContextsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.ActiveContext?].self, forKey: .activeContexts)
        var activeContextsDecoded0:[LexModelsV2ClientTypes.ActiveContext]? = nil
        if let activeContextsContainer = activeContextsContainer {
            activeContextsDecoded0 = [LexModelsV2ClientTypes.ActiveContext]()
            for structure0 in activeContextsContainer {
                if let structure0 = structure0 {
                    activeContextsDecoded0?.append(structure0)
                }
            }
        }
        activeContexts = activeContextsDecoded0
        let transcriptDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transcript)
        transcript = transcriptDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Contains results that are output for the user turn by the test execution.
    public struct UserTurnOutputSpecification: Swift.Equatable {
        /// The contexts that are active in the turn.
        public var activeContexts: [LexModelsV2ClientTypes.ActiveContext]?
        /// Contains information about the intent.
        /// This member is required.
        public var intent: LexModelsV2ClientTypes.UserTurnIntentOutput?
        /// The transcript that is output for the user turn by the test execution.
        public var transcript: Swift.String?

        public init(
            activeContexts: [LexModelsV2ClientTypes.ActiveContext]? = nil,
            intent: LexModelsV2ClientTypes.UserTurnIntentOutput? = nil,
            transcript: Swift.String? = nil
        )
        {
            self.activeContexts = activeContexts
            self.intent = intent
            self.transcript = transcript
        }
    }

}

extension LexModelsV2ClientTypes.UserTurnResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actualOutput
        case conversationLevelResult
        case endToEndResult
        case errorDetails
        case expectedOutput
        case input
        case intentMatchResult
        case slotMatchResult
        case speechTranscriptionResult
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actualOutput = self.actualOutput {
            try encodeContainer.encode(actualOutput, forKey: .actualOutput)
        }
        if let conversationLevelResult = self.conversationLevelResult {
            try encodeContainer.encode(conversationLevelResult, forKey: .conversationLevelResult)
        }
        if let endToEndResult = self.endToEndResult {
            try encodeContainer.encode(endToEndResult.rawValue, forKey: .endToEndResult)
        }
        if let errorDetails = self.errorDetails {
            try encodeContainer.encode(errorDetails, forKey: .errorDetails)
        }
        if let expectedOutput = self.expectedOutput {
            try encodeContainer.encode(expectedOutput, forKey: .expectedOutput)
        }
        if let input = self.input {
            try encodeContainer.encode(input, forKey: .input)
        }
        if let intentMatchResult = self.intentMatchResult {
            try encodeContainer.encode(intentMatchResult.rawValue, forKey: .intentMatchResult)
        }
        if let slotMatchResult = self.slotMatchResult {
            try encodeContainer.encode(slotMatchResult.rawValue, forKey: .slotMatchResult)
        }
        if let speechTranscriptionResult = self.speechTranscriptionResult {
            try encodeContainer.encode(speechTranscriptionResult.rawValue, forKey: .speechTranscriptionResult)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.UserTurnInputSpecification.self, forKey: .input)
        input = inputDecoded
        let expectedOutputDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.UserTurnOutputSpecification.self, forKey: .expectedOutput)
        expectedOutput = expectedOutputDecoded
        let actualOutputDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.UserTurnOutputSpecification.self, forKey: .actualOutput)
        actualOutput = actualOutputDecoded
        let errorDetailsDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ExecutionErrorDetails.self, forKey: .errorDetails)
        errorDetails = errorDetailsDecoded
        let endToEndResultDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestResultMatchStatus.self, forKey: .endToEndResult)
        endToEndResult = endToEndResultDecoded
        let intentMatchResultDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestResultMatchStatus.self, forKey: .intentMatchResult)
        intentMatchResult = intentMatchResultDecoded
        let slotMatchResultDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestResultMatchStatus.self, forKey: .slotMatchResult)
        slotMatchResult = slotMatchResultDecoded
        let speechTranscriptionResultDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestResultMatchStatus.self, forKey: .speechTranscriptionResult)
        speechTranscriptionResult = speechTranscriptionResultDecoded
        let conversationLevelResultDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ConversationLevelResultDetail.self, forKey: .conversationLevelResult)
        conversationLevelResult = conversationLevelResultDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Contains the results for the user turn by the test execution.
    public struct UserTurnResult: Swift.Equatable {
        /// Contains information about the actual output for the user turn.
        public var actualOutput: LexModelsV2ClientTypes.UserTurnOutputSpecification?
        /// Contains information about the results related to the conversation associated with the user turn.
        public var conversationLevelResult: LexModelsV2ClientTypes.ConversationLevelResultDetail?
        /// Specifies whether the expected and actual outputs match or not, or if there is an error in execution.
        public var endToEndResult: LexModelsV2ClientTypes.TestResultMatchStatus?
        /// Details about an error in an execution of a test set.
        public var errorDetails: LexModelsV2ClientTypes.ExecutionErrorDetails?
        /// Contains information about the expected output for the user turn.
        /// This member is required.
        public var expectedOutput: LexModelsV2ClientTypes.UserTurnOutputSpecification?
        /// Contains information about the user messages in the turn in the input.
        /// This member is required.
        public var input: LexModelsV2ClientTypes.UserTurnInputSpecification?
        /// Specifies whether the expected and actual intents match or not.
        public var intentMatchResult: LexModelsV2ClientTypes.TestResultMatchStatus?
        /// Specifies whether the expected and actual slots match or not.
        public var slotMatchResult: LexModelsV2ClientTypes.TestResultMatchStatus?
        /// Specifies whether the expected and actual speech transcriptions match or not, or if there is an error in execution.
        public var speechTranscriptionResult: LexModelsV2ClientTypes.TestResultMatchStatus?

        public init(
            actualOutput: LexModelsV2ClientTypes.UserTurnOutputSpecification? = nil,
            conversationLevelResult: LexModelsV2ClientTypes.ConversationLevelResultDetail? = nil,
            endToEndResult: LexModelsV2ClientTypes.TestResultMatchStatus? = nil,
            errorDetails: LexModelsV2ClientTypes.ExecutionErrorDetails? = nil,
            expectedOutput: LexModelsV2ClientTypes.UserTurnOutputSpecification? = nil,
            input: LexModelsV2ClientTypes.UserTurnInputSpecification? = nil,
            intentMatchResult: LexModelsV2ClientTypes.TestResultMatchStatus? = nil,
            slotMatchResult: LexModelsV2ClientTypes.TestResultMatchStatus? = nil,
            speechTranscriptionResult: LexModelsV2ClientTypes.TestResultMatchStatus? = nil
        )
        {
            self.actualOutput = actualOutput
            self.conversationLevelResult = conversationLevelResult
            self.endToEndResult = endToEndResult
            self.errorDetails = errorDetails
            self.expectedOutput = expectedOutput
            self.input = input
            self.intentMatchResult = intentMatchResult
            self.slotMatchResult = slotMatchResult
            self.speechTranscriptionResult = speechTranscriptionResult
        }
    }

}

extension LexModelsV2ClientTypes.UserTurnSlotOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subSlots
        case value
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subSlots = subSlots {
            var subSlotsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .subSlots)
            for (dictKey0, userTurnSlotOutputMap0) in subSlots {
                try subSlotsContainer.encode(userTurnSlotOutputMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for userturnslotoutput0 in values {
                try valuesContainer.encode(userturnslotoutput0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let valuesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.UserTurnSlotOutput?].self, forKey: .values)
        var valuesDecoded0:[LexModelsV2ClientTypes.UserTurnSlotOutput]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [LexModelsV2ClientTypes.UserTurnSlotOutput]()
            for structure0 in valuesContainer {
                if let structure0 = structure0 {
                    valuesDecoded0?.append(structure0)
                }
            }
        }
        values = valuesDecoded0
        let subSlotsContainer = try containerValues.decodeIfPresent([Swift.String: LexModelsV2ClientTypes.UserTurnSlotOutput?].self, forKey: .subSlots)
        var subSlotsDecoded0: [Swift.String:LexModelsV2ClientTypes.UserTurnSlotOutput]? = nil
        if let subSlotsContainer = subSlotsContainer {
            subSlotsDecoded0 = [Swift.String:LexModelsV2ClientTypes.UserTurnSlotOutput]()
            for (key0, userturnslotoutput0) in subSlotsContainer {
                if let userturnslotoutput0 = userturnslotoutput0 {
                    subSlotsDecoded0?[key0] = userturnslotoutput0
                }
            }
        }
        subSlots = subSlotsDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// Contains information about a slot output by the test set execution.
    public struct UserTurnSlotOutput: Swift.Equatable {
        /// A list of items mapping the name of the subslots to information about those subslots.
        public var subSlots: [Swift.String:LexModelsV2ClientTypes.UserTurnSlotOutput]?
        /// The value output by the slot recognition.
        public var value: Swift.String?
        /// Values that are output by the slot recognition.
        public var values: [LexModelsV2ClientTypes.UserTurnSlotOutput]?

        public init(
            subSlots: [Swift.String:LexModelsV2ClientTypes.UserTurnSlotOutput]? = nil,
            value: Swift.String? = nil,
            values: [LexModelsV2ClientTypes.UserTurnSlotOutput]? = nil
        )
        {
            self.subSlots = subSlots
            self.value = value
            self.values = values
        }
    }

}

extension LexModelsV2ClientTypes.UserTurnSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expected
        case input
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expected = self.expected {
            try encodeContainer.encode(expected, forKey: .expected)
        }
        if let input = self.input {
            try encodeContainer.encode(input, forKey: .input)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.UserTurnInputSpecification.self, forKey: .input)
        input = inputDecoded
        let expectedDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.UserTurnOutputSpecification.self, forKey: .expected)
        expected = expectedDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Contains information about the expected and input values for the user turn.
    public struct UserTurnSpecification: Swift.Equatable {
        /// Contains results about the expected output for the user turn.
        /// This member is required.
        public var expected: LexModelsV2ClientTypes.UserTurnOutputSpecification?
        /// Contains information about the user messages in the turn in the input.
        /// This member is required.
        public var input: LexModelsV2ClientTypes.UserTurnInputSpecification?

        public init(
            expected: LexModelsV2ClientTypes.UserTurnOutputSpecification? = nil,
            input: LexModelsV2ClientTypes.UserTurnInputSpecification? = nil
        )
        {
            self.expected = expected
            self.input = input
        }
    }

}

extension LexModelsV2ClientTypes.UtteranceAggregationDuration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case relativeAggregationDuration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let relativeAggregationDuration = self.relativeAggregationDuration {
            try encodeContainer.encode(relativeAggregationDuration, forKey: .relativeAggregationDuration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let relativeAggregationDurationDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.RelativeAggregationDuration.self, forKey: .relativeAggregationDuration)
        relativeAggregationDuration = relativeAggregationDurationDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Provides parameters for setting the time window and duration for aggregating utterance data.
    public struct UtteranceAggregationDuration: Swift.Equatable {
        /// The desired time window for aggregating utterances.
        /// This member is required.
        public var relativeAggregationDuration: LexModelsV2ClientTypes.RelativeAggregationDuration?

        public init(
            relativeAggregationDuration: LexModelsV2ClientTypes.RelativeAggregationDuration? = nil
        )
        {
            self.relativeAggregationDuration = relativeAggregationDuration
        }
    }

}

extension LexModelsV2ClientTypes.UtteranceAudioInputSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioFileS3Location
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audioFileS3Location = self.audioFileS3Location {
            try encodeContainer.encode(audioFileS3Location, forKey: .audioFileS3Location)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioFileS3LocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .audioFileS3Location)
        audioFileS3Location = audioFileS3LocationDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Contains information about the audio for an utterance.
    public struct UtteranceAudioInputSpecification: Swift.Equatable {
        /// Amazon S3 file pointing to the audio.
        /// This member is required.
        public var audioFileS3Location: Swift.String?

        public init(
            audioFileS3Location: Swift.String? = nil
        )
        {
            self.audioFileS3Location = audioFileS3Location
        }
    }

}

extension LexModelsV2ClientTypes.UtteranceBotResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case contentType
        case imageResponseCard
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType.rawValue, forKey: .contentType)
        }
        if let imageResponseCard = self.imageResponseCard {
            try encodeContainer.encode(imageResponseCard, forKey: .imageResponseCard)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.UtteranceContentType.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let imageResponseCardDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ImageResponseCard.self, forKey: .imageResponseCard)
        imageResponseCard = imageResponseCardDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// An object that contains a response to the utterance from the bot.
    public struct UtteranceBotResponse: Swift.Equatable {
        /// The text of the response to the utterance from the bot.
        public var content: Swift.String?
        /// The type of the response. The following values are possible:
        ///
        /// * PlainText – A plain text string.
        ///
        /// * CustomPayload – A response string that you can customize to include data or metadata for your application.
        ///
        /// * SSML – A string that includes Speech Synthesis Markup Language to customize the audio response.
        ///
        /// * ImageResponseCard – An image with buttons that the customer can select. See [ImageResponseCard](https://docs.aws.amazon.com/lexv2/latest/APIReference/API_runtime_ImageResponseCard.html) for more information.
        public var contentType: LexModelsV2ClientTypes.UtteranceContentType?
        /// A card that is shown to the user by a messaging platform. You define the contents of the card, the card is displayed by the platform. When you use a response card, the response from the user is constrained to the text associated with a button on the card.
        public var imageResponseCard: LexModelsV2ClientTypes.ImageResponseCard?

        public init(
            content: Swift.String? = nil,
            contentType: LexModelsV2ClientTypes.UtteranceContentType? = nil,
            imageResponseCard: LexModelsV2ClientTypes.ImageResponseCard? = nil
        )
        {
            self.content = content
            self.contentType = contentType
            self.imageResponseCard = imageResponseCard
        }
    }

}

extension LexModelsV2ClientTypes {
    public enum UtteranceContentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custompayload
        case imageresponsecard
        case plaintext
        case ssml
        case sdkUnknown(Swift.String)

        public static var allCases: [UtteranceContentType] {
            return [
                .custompayload,
                .imageresponsecard,
                .plaintext,
                .ssml,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custompayload: return "CustomPayload"
            case .imageresponsecard: return "ImageResponseCard"
            case .plaintext: return "PlainText"
            case .ssml: return "SSML"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UtteranceContentType(rawValue: rawValue) ?? UtteranceContentType.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.UtteranceDataSortBy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case order
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let order = self.order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsUtteranceSortByName.self, forKey: .name)
        name = nameDecoded
        let orderDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsSortOrder.self, forKey: .order)
        order = orderDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// An object specifying the measure and method by which to sort the utterance data.
    public struct UtteranceDataSortBy: Swift.Equatable {
        /// The measure by which to sort the utterance analytics data.
        ///
        /// * Count – The number of utterances.
        ///
        /// * UtteranceTimestamp – The date and time of the utterance.
        /// This member is required.
        public var name: LexModelsV2ClientTypes.AnalyticsUtteranceSortByName?
        /// Specifies whether to sort the results in ascending or descending order.
        /// This member is required.
        public var order: LexModelsV2ClientTypes.AnalyticsSortOrder?

        public init(
            name: LexModelsV2ClientTypes.AnalyticsUtteranceSortByName? = nil,
            order: LexModelsV2ClientTypes.AnalyticsSortOrder? = nil
        )
        {
            self.name = name
            self.order = order
        }
    }

}

extension LexModelsV2ClientTypes.UtteranceInputSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioInput
        case textInput
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audioInput = self.audioInput {
            try encodeContainer.encode(audioInput, forKey: .audioInput)
        }
        if let textInput = self.textInput {
            try encodeContainer.encode(textInput, forKey: .textInput)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textInputDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .textInput)
        textInput = textInputDecoded
        let audioInputDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.UtteranceAudioInputSpecification.self, forKey: .audioInput)
        audioInput = audioInputDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Contains information about input of an utterance.
    public struct UtteranceInputSpecification: Swift.Equatable {
        /// Contains information about the audio input for an utterance.
        public var audioInput: LexModelsV2ClientTypes.UtteranceAudioInputSpecification?
        /// A text input transcription of the utterance. It is only applicable for test-sets containing text data.
        public var textInput: Swift.String?

        public init(
            audioInput: LexModelsV2ClientTypes.UtteranceAudioInputSpecification? = nil,
            textInput: Swift.String? = nil
        )
        {
            self.audioInput = audioInput
            self.textInput = textInput
        }
    }

}

extension LexModelsV2ClientTypes.UtteranceLevelTestResultItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conversationId
        case recordNumber
        case turnResult
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conversationId = self.conversationId {
            try encodeContainer.encode(conversationId, forKey: .conversationId)
        }
        if let recordNumber = self.recordNumber {
            try encodeContainer.encode(recordNumber, forKey: .recordNumber)
        }
        if let turnResult = self.turnResult {
            try encodeContainer.encode(turnResult, forKey: .turnResult)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recordNumber)
        recordNumber = recordNumberDecoded
        let conversationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conversationId)
        conversationId = conversationIdDecoded
        let turnResultDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.TestSetTurnResult.self, forKey: .turnResult)
        turnResult = turnResultDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Contains information about multiple utterances in the results of a test set execution.
    public struct UtteranceLevelTestResultItem: Swift.Equatable {
        /// The unique identifier for the conversation associated with the result.
        public var conversationId: Swift.String?
        /// The record number of the result.
        /// This member is required.
        public var recordNumber: Swift.Int?
        /// Contains information about the turn associated with the result.
        /// This member is required.
        public var turnResult: LexModelsV2ClientTypes.TestSetTurnResult?

        public init(
            conversationId: Swift.String? = nil,
            recordNumber: Swift.Int? = nil,
            turnResult: LexModelsV2ClientTypes.TestSetTurnResult? = nil
        )
        {
            self.conversationId = conversationId
            self.recordNumber = recordNumber
            self.turnResult = turnResult
        }
    }

}

extension LexModelsV2ClientTypes.UtteranceLevelTestResults: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for utteranceleveltestresultitem0 in items {
                try itemsContainer.encode(utteranceleveltestresultitem0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.UtteranceLevelTestResultItem?].self, forKey: .items)
        var itemsDecoded0:[LexModelsV2ClientTypes.UtteranceLevelTestResultItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [LexModelsV2ClientTypes.UtteranceLevelTestResultItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// Contains information about the utterances in the results of the test set execution.
    public struct UtteranceLevelTestResults: Swift.Equatable {
        /// Contains information about an utterance in the results of the test set execution.
        /// This member is required.
        public var items: [LexModelsV2ClientTypes.UtteranceLevelTestResultItem]?

        public init(
            items: [LexModelsV2ClientTypes.UtteranceLevelTestResultItem]? = nil
        )
        {
            self.items = items
        }
    }

}

extension LexModelsV2ClientTypes.UtteranceSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedIntentName
        case associatedSlotName
        case audioVoiceDurationMillis
        case botAliasId
        case botResponseAudioVoiceId
        case botResponses
        case botVersion
        case channel
        case conversationEndTime
        case conversationStartTime
        case dialogActionType
        case inputType
        case intentState
        case localeId
        case mode
        case outputType
        case sessionId
        case slotsFilledInSession
        case utterance
        case utteranceRequestId
        case utteranceTimestamp
        case utteranceUnderstood
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedIntentName = self.associatedIntentName {
            try encodeContainer.encode(associatedIntentName, forKey: .associatedIntentName)
        }
        if let associatedSlotName = self.associatedSlotName {
            try encodeContainer.encode(associatedSlotName, forKey: .associatedSlotName)
        }
        if let audioVoiceDurationMillis = self.audioVoiceDurationMillis {
            try encodeContainer.encode(audioVoiceDurationMillis, forKey: .audioVoiceDurationMillis)
        }
        if let botAliasId = self.botAliasId {
            try encodeContainer.encode(botAliasId, forKey: .botAliasId)
        }
        if let botResponseAudioVoiceId = self.botResponseAudioVoiceId {
            try encodeContainer.encode(botResponseAudioVoiceId, forKey: .botResponseAudioVoiceId)
        }
        if let botResponses = botResponses {
            var botResponsesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .botResponses)
            for utterancebotresponse0 in botResponses {
                try botResponsesContainer.encode(utterancebotresponse0)
            }
        }
        if let botVersion = self.botVersion {
            try encodeContainer.encode(botVersion, forKey: .botVersion)
        }
        if let channel = self.channel {
            try encodeContainer.encode(channel, forKey: .channel)
        }
        if let conversationEndTime = self.conversationEndTime {
            try encodeContainer.encodeTimestamp(conversationEndTime, format: .epochSeconds, forKey: .conversationEndTime)
        }
        if let conversationStartTime = self.conversationStartTime {
            try encodeContainer.encodeTimestamp(conversationStartTime, format: .epochSeconds, forKey: .conversationStartTime)
        }
        if let dialogActionType = self.dialogActionType {
            try encodeContainer.encode(dialogActionType, forKey: .dialogActionType)
        }
        if let inputType = self.inputType {
            try encodeContainer.encode(inputType, forKey: .inputType)
        }
        if let intentState = self.intentState {
            try encodeContainer.encode(intentState.rawValue, forKey: .intentState)
        }
        if let localeId = self.localeId {
            try encodeContainer.encode(localeId, forKey: .localeId)
        }
        if let mode = self.mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let outputType = self.outputType {
            try encodeContainer.encode(outputType, forKey: .outputType)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let slotsFilledInSession = self.slotsFilledInSession {
            try encodeContainer.encode(slotsFilledInSession, forKey: .slotsFilledInSession)
        }
        if let utterance = self.utterance {
            try encodeContainer.encode(utterance, forKey: .utterance)
        }
        if let utteranceRequestId = self.utteranceRequestId {
            try encodeContainer.encode(utteranceRequestId, forKey: .utteranceRequestId)
        }
        if let utteranceTimestamp = self.utteranceTimestamp {
            try encodeContainer.encodeTimestamp(utteranceTimestamp, format: .epochSeconds, forKey: .utteranceTimestamp)
        }
        if utteranceUnderstood != false {
            try encodeContainer.encode(utteranceUnderstood, forKey: .utteranceUnderstood)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botAliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botAliasId)
        botAliasId = botAliasIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let channelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channel)
        channel = channelDecoded
        let modeDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.AnalyticsModality.self, forKey: .mode)
        mode = modeDecoded
        let conversationStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .conversationStartTime)
        conversationStartTime = conversationStartTimeDecoded
        let conversationEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .conversationEndTime)
        conversationEndTime = conversationEndTimeDecoded
        let utteranceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .utterance)
        utterance = utteranceDecoded
        let utteranceTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .utteranceTimestamp)
        utteranceTimestamp = utteranceTimestampDecoded
        let audioVoiceDurationMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .audioVoiceDurationMillis)
        audioVoiceDurationMillis = audioVoiceDurationMillisDecoded
        let utteranceUnderstoodDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .utteranceUnderstood) ?? false
        utteranceUnderstood = utteranceUnderstoodDecoded
        let inputTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputType)
        inputType = inputTypeDecoded
        let outputTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputType)
        outputType = outputTypeDecoded
        let associatedIntentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedIntentName)
        associatedIntentName = associatedIntentNameDecoded
        let associatedSlotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedSlotName)
        associatedSlotName = associatedSlotNameDecoded
        let intentStateDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.IntentState.self, forKey: .intentState)
        intentState = intentStateDecoded
        let dialogActionTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dialogActionType)
        dialogActionType = dialogActionTypeDecoded
        let botResponseAudioVoiceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botResponseAudioVoiceId)
        botResponseAudioVoiceId = botResponseAudioVoiceIdDecoded
        let slotsFilledInSessionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotsFilledInSession)
        slotsFilledInSession = slotsFilledInSessionDecoded
        let utteranceRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .utteranceRequestId)
        utteranceRequestId = utteranceRequestIdDecoded
        let botResponsesContainer = try containerValues.decodeIfPresent([LexModelsV2ClientTypes.UtteranceBotResponse?].self, forKey: .botResponses)
        var botResponsesDecoded0:[LexModelsV2ClientTypes.UtteranceBotResponse]? = nil
        if let botResponsesContainer = botResponsesContainer {
            botResponsesDecoded0 = [LexModelsV2ClientTypes.UtteranceBotResponse]()
            for structure0 in botResponsesContainer {
                if let structure0 = structure0 {
                    botResponsesDecoded0?.append(structure0)
                }
            }
        }
        botResponses = botResponsesDecoded0
    }
}

extension LexModelsV2ClientTypes {
    /// An object containing information about a specific utterance.
    public struct UtteranceSpecification: Swift.Equatable {
        /// The name of the intent that the utterance is associated to.
        public var associatedIntentName: Swift.String?
        /// The name of the slot that the utterance is associated to.
        public var associatedSlotName: Swift.String?
        /// The duration in milliseconds of the audio associated with the utterance.
        public var audioVoiceDurationMillis: Swift.Int?
        /// The identifier of the alias of the bot that the utterance was made to.
        public var botAliasId: Swift.String?
        /// The identifier for the audio of the bot response.
        public var botResponseAudioVoiceId: Swift.String?
        /// A list of objects containing information about the bot response to the utterance.
        public var botResponses: [LexModelsV2ClientTypes.UtteranceBotResponse]?
        /// The version of the bot that the utterance was made to.
        public var botVersion: Swift.String?
        /// The channel that is integrated with the bot that the utterance was made to.
        public var channel: Swift.String?
        /// The date and time when the conversation in which the utterance took place ended. A conversation is defined as a unique combination of a sessionId and an originatingRequestId.
        public var conversationEndTime: ClientRuntime.Date?
        /// The date and time when the conversation in which the utterance took place began. A conversation is defined as a unique combination of a sessionId and an originatingRequestId.
        public var conversationStartTime: ClientRuntime.Date?
        /// The type of dialog action that the utterance is associated to. See the type field in [DialogAction](https://docs.aws.amazon.com/lexv2/latest/APIReference/API_runtime_DialogAction.html) for more information.
        public var dialogActionType: Swift.String?
        /// The input type of the utterance. The possible values are as follows:
        ///
        /// * PCM format: audio data must be in little-endian byte order.
        ///
        /// * audio/l16; rate=16000; channels=1
        ///
        /// * audio/x-l16; sample-rate=16000; channel-count=1
        ///
        /// * audio/lpcm; sample-rate=8000; sample-size-bits=16; channel-count=1; is-big-endian=false
        ///
        ///
        ///
        ///
        /// * Opus format
        ///
        /// * audio/x-cbr-opus-with-preamble;preamble-size=0;bit-rate=256000;frame-size-milliseconds=4
        ///
        ///
        ///
        ///
        /// * Text format
        ///
        /// * text/plain; charset=utf-8
        public var inputType: Swift.String?
        /// The state of the intent that the utterance is associated to.
        public var intentState: LexModelsV2ClientTypes.IntentState?
        /// The locale of the bot that the utterance was made to.
        public var localeId: Swift.String?
        /// The mode of the session. The possible values are as follows:
        ///
        /// * Speech – The session consisted of spoken dialogue.
        ///
        /// * Text – The session consisted of written dialogue.
        ///
        /// * DTMF – The session consisted of touch-tone keypad (Dual Tone Multi-Frequency) key presses.
        ///
        /// * MultiMode – The session consisted of multiple modes.
        public var mode: LexModelsV2ClientTypes.AnalyticsModality?
        /// The output type of the utterance. The possible values are as follows:
        ///
        /// * audio/mpeg
        ///
        /// * audio/ogg
        ///
        /// * audio/pcm (16 KHz)
        ///
        /// * audio/ (defaults to mpeg)
        ///
        /// * text/plain; charset=utf-8
        public var outputType: Swift.String?
        /// The identifier of the session that the utterance was made in.
        public var sessionId: Swift.String?
        /// The slots that have been filled in the session by the time of the utterance.
        public var slotsFilledInSession: Swift.String?
        /// The text of the utterance.
        public var utterance: Swift.String?
        /// The identifier of the request associated with the utterance.
        public var utteranceRequestId: Swift.String?
        /// The date and time when the utterance took place.
        public var utteranceTimestamp: ClientRuntime.Date?
        /// Specifies whether the bot understood the utterance or not.
        public var utteranceUnderstood: Swift.Bool

        public init(
            associatedIntentName: Swift.String? = nil,
            associatedSlotName: Swift.String? = nil,
            audioVoiceDurationMillis: Swift.Int? = nil,
            botAliasId: Swift.String? = nil,
            botResponseAudioVoiceId: Swift.String? = nil,
            botResponses: [LexModelsV2ClientTypes.UtteranceBotResponse]? = nil,
            botVersion: Swift.String? = nil,
            channel: Swift.String? = nil,
            conversationEndTime: ClientRuntime.Date? = nil,
            conversationStartTime: ClientRuntime.Date? = nil,
            dialogActionType: Swift.String? = nil,
            inputType: Swift.String? = nil,
            intentState: LexModelsV2ClientTypes.IntentState? = nil,
            localeId: Swift.String? = nil,
            mode: LexModelsV2ClientTypes.AnalyticsModality? = nil,
            outputType: Swift.String? = nil,
            sessionId: Swift.String? = nil,
            slotsFilledInSession: Swift.String? = nil,
            utterance: Swift.String? = nil,
            utteranceRequestId: Swift.String? = nil,
            utteranceTimestamp: ClientRuntime.Date? = nil,
            utteranceUnderstood: Swift.Bool = false
        )
        {
            self.associatedIntentName = associatedIntentName
            self.associatedSlotName = associatedSlotName
            self.audioVoiceDurationMillis = audioVoiceDurationMillis
            self.botAliasId = botAliasId
            self.botResponseAudioVoiceId = botResponseAudioVoiceId
            self.botResponses = botResponses
            self.botVersion = botVersion
            self.channel = channel
            self.conversationEndTime = conversationEndTime
            self.conversationStartTime = conversationStartTime
            self.dialogActionType = dialogActionType
            self.inputType = inputType
            self.intentState = intentState
            self.localeId = localeId
            self.mode = mode
            self.outputType = outputType
            self.sessionId = sessionId
            self.slotsFilledInSession = slotsFilledInSession
            self.utterance = utterance
            self.utteranceRequestId = utteranceRequestId
            self.utteranceTimestamp = utteranceTimestamp
            self.utteranceUnderstood = utteranceUnderstood
        }
    }

}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// One of the input parameters in your request isn't valid. Check the parameters and try your request again.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LexModelsV2ClientTypes {
    public enum VoiceEngine: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case neural
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [VoiceEngine] {
            return [
                .neural,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .neural: return "neural"
            case .standard: return "standard"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VoiceEngine(rawValue: rawValue) ?? VoiceEngine.sdkUnknown(rawValue)
        }
    }
}

extension LexModelsV2ClientTypes.VoiceSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engine
        case voiceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engine = self.engine {
            try encodeContainer.encode(engine.rawValue, forKey: .engine)
        }
        if let voiceId = self.voiceId {
            try encodeContainer.encode(voiceId, forKey: .voiceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceId)
        voiceId = voiceIdDecoded
        let engineDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.VoiceEngine.self, forKey: .engine)
        engine = engineDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Defines settings for using an Amazon Polly voice to communicate with a user.
    public struct VoiceSettings: Swift.Equatable {
        /// Indicates the type of Amazon Polly voice that Amazon Lex should use for voice interaction with the user. For more information, see the [engine] parameter of the SynthesizeSpeech operation(https://docs.aws.amazon.com/polly/latest/dg/API_SynthesizeSpeech.html#polly-SynthesizeSpeech-request-Engine) in the Amazon Polly developer guide. If you do not specify a value, the default is standard.
        public var engine: LexModelsV2ClientTypes.VoiceEngine?
        /// The identifier of the Amazon Polly voice to use.
        /// This member is required.
        public var voiceId: Swift.String?

        public init(
            engine: LexModelsV2ClientTypes.VoiceEngine? = nil,
            voiceId: Swift.String? = nil
        )
        {
            self.engine = engine
            self.voiceId = voiceId
        }
    }

}

extension LexModelsV2ClientTypes.WaitAndContinueSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case active
        case continueResponse
        case stillWaitingResponse
        case waitingResponse
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let active = self.active {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let continueResponse = self.continueResponse {
            try encodeContainer.encode(continueResponse, forKey: .continueResponse)
        }
        if let stillWaitingResponse = self.stillWaitingResponse {
            try encodeContainer.encode(stillWaitingResponse, forKey: .stillWaitingResponse)
        }
        if let waitingResponse = self.waitingResponse {
            try encodeContainer.encode(waitingResponse, forKey: .waitingResponse)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let waitingResponseDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ResponseSpecification.self, forKey: .waitingResponse)
        waitingResponse = waitingResponseDecoded
        let continueResponseDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ResponseSpecification.self, forKey: .continueResponse)
        continueResponse = continueResponseDecoded
        let stillWaitingResponseDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.StillWaitingResponseSpecification.self, forKey: .stillWaitingResponse)
        stillWaitingResponse = stillWaitingResponseDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .active)
        active = activeDecoded
    }
}

extension LexModelsV2ClientTypes {
    /// Specifies the prompts that Amazon Lex uses while a bot is waiting for customer input.
    public struct WaitAndContinueSpecification: Swift.Equatable {
        /// Specifies whether the bot will wait for a user to respond. When this field is false, wait and continue responses for a slot aren't used. If the active field isn't specified, the default is true.
        public var active: Swift.Bool?
        /// The response that Amazon Lex sends to indicate that the bot is ready to continue the conversation.
        /// This member is required.
        public var continueResponse: LexModelsV2ClientTypes.ResponseSpecification?
        /// A response that Amazon Lex sends periodically to the user to indicate that the bot is still waiting for input from the user.
        public var stillWaitingResponse: LexModelsV2ClientTypes.StillWaitingResponseSpecification?
        /// The response that Amazon Lex sends to indicate that the bot is waiting for the conversation to continue.
        /// This member is required.
        public var waitingResponse: LexModelsV2ClientTypes.ResponseSpecification?

        public init(
            active: Swift.Bool? = nil,
            continueResponse: LexModelsV2ClientTypes.ResponseSpecification? = nil,
            stillWaitingResponse: LexModelsV2ClientTypes.StillWaitingResponseSpecification? = nil,
            waitingResponse: LexModelsV2ClientTypes.ResponseSpecification? = nil
        )
        {
            self.active = active
            self.continueResponse = continueResponse
            self.stillWaitingResponse = stillWaitingResponse
            self.waitingResponse = waitingResponse
        }
    }

}
