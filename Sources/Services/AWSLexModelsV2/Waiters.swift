// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension LexModelsV2ClientProtocol {

    static func botAvailableWaiterConfig() throws -> WaiterConfiguration<DescribeBotInput, DescribeBotOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeBotInput, DescribeBotOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeBotInput, result: Result<DescribeBotOutputResponse, Error>) -> Bool in
                // JMESPath expression: "botStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Available"
                guard case .success(let output) = result else { return false }
                let botStatus = output.botStatus
                return JMESUtils.compare(botStatus, ==, "Available")
            }),
            .init(state: .failure, matcher: { (input: DescribeBotInput, result: Result<DescribeBotOutputResponse, Error>) -> Bool in
                // JMESPath expression: "botStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Deleting"
                guard case .success(let output) = result else { return false }
                let botStatus = output.botStatus
                return JMESUtils.compare(botStatus, ==, "Deleting")
            }),
            .init(state: .failure, matcher: { (input: DescribeBotInput, result: Result<DescribeBotOutputResponse, Error>) -> Bool in
                // JMESPath expression: "botStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Failed"
                guard case .success(let output) = result else { return false }
                let botStatus = output.botStatus
                return JMESUtils.compare(botStatus, ==, "Failed")
            }),
            .init(state: .failure, matcher: { (input: DescribeBotInput, result: Result<DescribeBotOutputResponse, Error>) -> Bool in
                // JMESPath expression: "botStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Inactive"
                guard case .success(let output) = result else { return false }
                let botStatus = output.botStatus
                return JMESUtils.compare(botStatus, ==, "Inactive")
            }),
        ]
        return try WaiterConfiguration<DescribeBotInput, DescribeBotOutputResponse>(acceptors: acceptors, minDelay: 10.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the BotAvailable event on the describeBot operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeBotInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilBotAvailable(options: WaiterOptions, input: DescribeBotInput) async throws -> WaiterOutcome<DescribeBotOutputResponse> {
        let waiter = Waiter(config: try Self.botAvailableWaiterConfig(), operation: self.describeBot(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func botAliasAvailableWaiterConfig() throws -> WaiterConfiguration<DescribeBotAliasInput, DescribeBotAliasOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeBotAliasInput, DescribeBotAliasOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeBotAliasInput, result: Result<DescribeBotAliasOutputResponse, Error>) -> Bool in
                // JMESPath expression: "botAliasStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Available"
                guard case .success(let output) = result else { return false }
                let botAliasStatus = output.botAliasStatus
                return JMESUtils.compare(botAliasStatus, ==, "Available")
            }),
            .init(state: .failure, matcher: { (input: DescribeBotAliasInput, result: Result<DescribeBotAliasOutputResponse, Error>) -> Bool in
                // JMESPath expression: "botAliasStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Failed"
                guard case .success(let output) = result else { return false }
                let botAliasStatus = output.botAliasStatus
                return JMESUtils.compare(botAliasStatus, ==, "Failed")
            }),
            .init(state: .failure, matcher: { (input: DescribeBotAliasInput, result: Result<DescribeBotAliasOutputResponse, Error>) -> Bool in
                // JMESPath expression: "botAliasStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Deleting"
                guard case .success(let output) = result else { return false }
                let botAliasStatus = output.botAliasStatus
                return JMESUtils.compare(botAliasStatus, ==, "Deleting")
            }),
        ]
        return try WaiterConfiguration<DescribeBotAliasInput, DescribeBotAliasOutputResponse>(acceptors: acceptors, minDelay: 10.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the BotAliasAvailable event on the describeBotAlias operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeBotAliasInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilBotAliasAvailable(options: WaiterOptions, input: DescribeBotAliasInput) async throws -> WaiterOutcome<DescribeBotAliasOutputResponse> {
        let waiter = Waiter(config: try Self.botAliasAvailableWaiterConfig(), operation: self.describeBotAlias(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func botLocaleBuiltWaiterConfig() throws -> WaiterConfiguration<DescribeBotLocaleInput, DescribeBotLocaleOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeBotLocaleInput, DescribeBotLocaleOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeBotLocaleInput, result: Result<DescribeBotLocaleOutputResponse, Error>) -> Bool in
                // JMESPath expression: "botLocaleStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Built"
                guard case .success(let output) = result else { return false }
                let botLocaleStatus = output.botLocaleStatus
                return JMESUtils.compare(botLocaleStatus, ==, "Built")
            }),
            .init(state: .failure, matcher: { (input: DescribeBotLocaleInput, result: Result<DescribeBotLocaleOutputResponse, Error>) -> Bool in
                // JMESPath expression: "botLocaleStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Deleting"
                guard case .success(let output) = result else { return false }
                let botLocaleStatus = output.botLocaleStatus
                return JMESUtils.compare(botLocaleStatus, ==, "Deleting")
            }),
            .init(state: .failure, matcher: { (input: DescribeBotLocaleInput, result: Result<DescribeBotLocaleOutputResponse, Error>) -> Bool in
                // JMESPath expression: "botLocaleStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Failed"
                guard case .success(let output) = result else { return false }
                let botLocaleStatus = output.botLocaleStatus
                return JMESUtils.compare(botLocaleStatus, ==, "Failed")
            }),
            .init(state: .failure, matcher: { (input: DescribeBotLocaleInput, result: Result<DescribeBotLocaleOutputResponse, Error>) -> Bool in
                // JMESPath expression: "botLocaleStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "NotBuilt"
                guard case .success(let output) = result else { return false }
                let botLocaleStatus = output.botLocaleStatus
                return JMESUtils.compare(botLocaleStatus, ==, "NotBuilt")
            }),
        ]
        return try WaiterConfiguration<DescribeBotLocaleInput, DescribeBotLocaleOutputResponse>(acceptors: acceptors, minDelay: 10.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the BotLocaleBuilt event on the describeBotLocale operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeBotLocaleInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilBotLocaleBuilt(options: WaiterOptions, input: DescribeBotLocaleInput) async throws -> WaiterOutcome<DescribeBotLocaleOutputResponse> {
        let waiter = Waiter(config: try Self.botLocaleBuiltWaiterConfig(), operation: self.describeBotLocale(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func botLocaleCreatedWaiterConfig() throws -> WaiterConfiguration<DescribeBotLocaleInput, DescribeBotLocaleOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeBotLocaleInput, DescribeBotLocaleOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeBotLocaleInput, result: Result<DescribeBotLocaleOutputResponse, Error>) -> Bool in
                // JMESPath expression: "botLocaleStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Built"
                guard case .success(let output) = result else { return false }
                let botLocaleStatus = output.botLocaleStatus
                return JMESUtils.compare(botLocaleStatus, ==, "Built")
            }),
            .init(state: .success, matcher: { (input: DescribeBotLocaleInput, result: Result<DescribeBotLocaleOutputResponse, Error>) -> Bool in
                // JMESPath expression: "botLocaleStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "ReadyExpressTesting"
                guard case .success(let output) = result else { return false }
                let botLocaleStatus = output.botLocaleStatus
                return JMESUtils.compare(botLocaleStatus, ==, "ReadyExpressTesting")
            }),
            .init(state: .success, matcher: { (input: DescribeBotLocaleInput, result: Result<DescribeBotLocaleOutputResponse, Error>) -> Bool in
                // JMESPath expression: "botLocaleStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "NotBuilt"
                guard case .success(let output) = result else { return false }
                let botLocaleStatus = output.botLocaleStatus
                return JMESUtils.compare(botLocaleStatus, ==, "NotBuilt")
            }),
            .init(state: .failure, matcher: { (input: DescribeBotLocaleInput, result: Result<DescribeBotLocaleOutputResponse, Error>) -> Bool in
                // JMESPath expression: "botLocaleStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Deleting"
                guard case .success(let output) = result else { return false }
                let botLocaleStatus = output.botLocaleStatus
                return JMESUtils.compare(botLocaleStatus, ==, "Deleting")
            }),
            .init(state: .failure, matcher: { (input: DescribeBotLocaleInput, result: Result<DescribeBotLocaleOutputResponse, Error>) -> Bool in
                // JMESPath expression: "botLocaleStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Failed"
                guard case .success(let output) = result else { return false }
                let botLocaleStatus = output.botLocaleStatus
                return JMESUtils.compare(botLocaleStatus, ==, "Failed")
            }),
        ]
        return try WaiterConfiguration<DescribeBotLocaleInput, DescribeBotLocaleOutputResponse>(acceptors: acceptors, minDelay: 10.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the BotLocaleCreated event on the describeBotLocale operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeBotLocaleInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilBotLocaleCreated(options: WaiterOptions, input: DescribeBotLocaleInput) async throws -> WaiterOutcome<DescribeBotLocaleOutputResponse> {
        let waiter = Waiter(config: try Self.botLocaleCreatedWaiterConfig(), operation: self.describeBotLocale(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func botLocaleExpressTestingAvailableWaiterConfig() throws -> WaiterConfiguration<DescribeBotLocaleInput, DescribeBotLocaleOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeBotLocaleInput, DescribeBotLocaleOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeBotLocaleInput, result: Result<DescribeBotLocaleOutputResponse, Error>) -> Bool in
                // JMESPath expression: "botLocaleStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Built"
                guard case .success(let output) = result else { return false }
                let botLocaleStatus = output.botLocaleStatus
                return JMESUtils.compare(botLocaleStatus, ==, "Built")
            }),
            .init(state: .success, matcher: { (input: DescribeBotLocaleInput, result: Result<DescribeBotLocaleOutputResponse, Error>) -> Bool in
                // JMESPath expression: "botLocaleStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "ReadyExpressTesting"
                guard case .success(let output) = result else { return false }
                let botLocaleStatus = output.botLocaleStatus
                return JMESUtils.compare(botLocaleStatus, ==, "ReadyExpressTesting")
            }),
            .init(state: .failure, matcher: { (input: DescribeBotLocaleInput, result: Result<DescribeBotLocaleOutputResponse, Error>) -> Bool in
                // JMESPath expression: "botLocaleStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Deleting"
                guard case .success(let output) = result else { return false }
                let botLocaleStatus = output.botLocaleStatus
                return JMESUtils.compare(botLocaleStatus, ==, "Deleting")
            }),
            .init(state: .failure, matcher: { (input: DescribeBotLocaleInput, result: Result<DescribeBotLocaleOutputResponse, Error>) -> Bool in
                // JMESPath expression: "botLocaleStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Failed"
                guard case .success(let output) = result else { return false }
                let botLocaleStatus = output.botLocaleStatus
                return JMESUtils.compare(botLocaleStatus, ==, "Failed")
            }),
            .init(state: .failure, matcher: { (input: DescribeBotLocaleInput, result: Result<DescribeBotLocaleOutputResponse, Error>) -> Bool in
                // JMESPath expression: "botLocaleStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "NotBuilt"
                guard case .success(let output) = result else { return false }
                let botLocaleStatus = output.botLocaleStatus
                return JMESUtils.compare(botLocaleStatus, ==, "NotBuilt")
            }),
        ]
        return try WaiterConfiguration<DescribeBotLocaleInput, DescribeBotLocaleOutputResponse>(acceptors: acceptors, minDelay: 10.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the BotLocaleExpressTestingAvailable event on the describeBotLocale operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeBotLocaleInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilBotLocaleExpressTestingAvailable(options: WaiterOptions, input: DescribeBotLocaleInput) async throws -> WaiterOutcome<DescribeBotLocaleOutputResponse> {
        let waiter = Waiter(config: try Self.botLocaleExpressTestingAvailableWaiterConfig(), operation: self.describeBotLocale(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func botVersionAvailableWaiterConfig() throws -> WaiterConfiguration<DescribeBotVersionInput, DescribeBotVersionOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeBotVersionInput, DescribeBotVersionOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeBotVersionInput, result: Result<DescribeBotVersionOutputResponse, Error>) -> Bool in
                // JMESPath expression: "botStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Available"
                guard case .success(let output) = result else { return false }
                let botStatus = output.botStatus
                return JMESUtils.compare(botStatus, ==, "Available")
            }),
            .init(state: .failure, matcher: { (input: DescribeBotVersionInput, result: Result<DescribeBotVersionOutputResponse, Error>) -> Bool in
                // JMESPath expression: "botStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Deleting"
                guard case .success(let output) = result else { return false }
                let botStatus = output.botStatus
                return JMESUtils.compare(botStatus, ==, "Deleting")
            }),
            .init(state: .failure, matcher: { (input: DescribeBotVersionInput, result: Result<DescribeBotVersionOutputResponse, Error>) -> Bool in
                // JMESPath expression: "botStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Failed"
                guard case .success(let output) = result else { return false }
                let botStatus = output.botStatus
                return JMESUtils.compare(botStatus, ==, "Failed")
            }),
            .init(state: .retry, matcher: { (input: DescribeBotVersionInput, result: Result<DescribeBotVersionOutputResponse, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? WaiterTypedError)?.waiterErrorType == "ResourceNotFoundException"
            }),
        ]
        return try WaiterConfiguration<DescribeBotVersionInput, DescribeBotVersionOutputResponse>(acceptors: acceptors, minDelay: 10.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the BotVersionAvailable event on the describeBotVersion operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeBotVersionInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilBotVersionAvailable(options: WaiterOptions, input: DescribeBotVersionInput) async throws -> WaiterOutcome<DescribeBotVersionOutputResponse> {
        let waiter = Waiter(config: try Self.botVersionAvailableWaiterConfig(), operation: self.describeBotVersion(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func botExportCompletedWaiterConfig() throws -> WaiterConfiguration<DescribeExportInput, DescribeExportOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeExportInput, DescribeExportOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeExportInput, result: Result<DescribeExportOutputResponse, Error>) -> Bool in
                // JMESPath expression: "exportStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Completed"
                guard case .success(let output) = result else { return false }
                let exportStatus = output.exportStatus
                return JMESUtils.compare(exportStatus, ==, "Completed")
            }),
            .init(state: .failure, matcher: { (input: DescribeExportInput, result: Result<DescribeExportOutputResponse, Error>) -> Bool in
                // JMESPath expression: "exportStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Deleting"
                guard case .success(let output) = result else { return false }
                let exportStatus = output.exportStatus
                return JMESUtils.compare(exportStatus, ==, "Deleting")
            }),
            .init(state: .failure, matcher: { (input: DescribeExportInput, result: Result<DescribeExportOutputResponse, Error>) -> Bool in
                // JMESPath expression: "exportStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Failed"
                guard case .success(let output) = result else { return false }
                let exportStatus = output.exportStatus
                return JMESUtils.compare(exportStatus, ==, "Failed")
            }),
        ]
        return try WaiterConfiguration<DescribeExportInput, DescribeExportOutputResponse>(acceptors: acceptors, minDelay: 10.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the BotExportCompleted event on the describeExport operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeExportInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilBotExportCompleted(options: WaiterOptions, input: DescribeExportInput) async throws -> WaiterOutcome<DescribeExportOutputResponse> {
        let waiter = Waiter(config: try Self.botExportCompletedWaiterConfig(), operation: self.describeExport(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func botImportCompletedWaiterConfig() throws -> WaiterConfiguration<DescribeImportInput, DescribeImportOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeImportInput, DescribeImportOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeImportInput, result: Result<DescribeImportOutputResponse, Error>) -> Bool in
                // JMESPath expression: "importStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Completed"
                guard case .success(let output) = result else { return false }
                let importStatus = output.importStatus
                return JMESUtils.compare(importStatus, ==, "Completed")
            }),
            .init(state: .failure, matcher: { (input: DescribeImportInput, result: Result<DescribeImportOutputResponse, Error>) -> Bool in
                // JMESPath expression: "importStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Deleting"
                guard case .success(let output) = result else { return false }
                let importStatus = output.importStatus
                return JMESUtils.compare(importStatus, ==, "Deleting")
            }),
            .init(state: .failure, matcher: { (input: DescribeImportInput, result: Result<DescribeImportOutputResponse, Error>) -> Bool in
                // JMESPath expression: "importStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Failed"
                guard case .success(let output) = result else { return false }
                let importStatus = output.importStatus
                return JMESUtils.compare(importStatus, ==, "Failed")
            }),
        ]
        return try WaiterConfiguration<DescribeImportInput, DescribeImportOutputResponse>(acceptors: acceptors, minDelay: 10.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the BotImportCompleted event on the describeImport operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeImportInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilBotImportCompleted(options: WaiterOptions, input: DescribeImportInput) async throws -> WaiterOutcome<DescribeImportOutputResponse> {
        let waiter = Waiter(config: try Self.botImportCompletedWaiterConfig(), operation: self.describeImport(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }
}
