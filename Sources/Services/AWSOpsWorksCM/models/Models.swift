// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension OpsWorksCMClientTypes.AccountAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maximum = "Maximum"
        case name = "Name"
        case used = "Used"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maximum = self.maximum {
            try encodeContainer.encode(maximum, forKey: .maximum)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let used = self.used {
            try encodeContainer.encode(used, forKey: .used)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let maximumDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximum)
        maximum = maximumDecoded
        let usedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .used)
        used = usedDecoded
    }
}

extension OpsWorksCMClientTypes {
    /// Stores account attributes.
    public struct AccountAttribute: Swift.Equatable {
        /// The maximum allowed value.
        public var maximum: Swift.Int?
        /// The attribute name. The following are supported attribute names.
        ///
        /// * ServerLimit: The number of current servers/maximum number of servers allowed. By default, you can have a maximum of 10 servers.
        ///
        /// * ManualBackupLimit: The number of current manual backups/maximum number of backups allowed. By default, you can have a maximum of 50 manual backups saved.
        public var name: Swift.String?
        /// The current usage, such as the current number of servers that are associated with the account.
        public var used: Swift.Int?

        public init(
            maximum: Swift.Int? = nil,
            name: Swift.String? = nil,
            used: Swift.Int? = nil
        )
        {
            self.maximum = maximum
            self.name = name
            self.used = used
        }
    }

}

extension AssociateNodeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineAttributes = "EngineAttributes"
        case nodeName = "NodeName"
        case serverName = "ServerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engineAttributes = engineAttributes {
            var engineAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .engineAttributes)
            for engineattribute0 in engineAttributes {
                try engineAttributesContainer.encode(engineattribute0)
            }
        }
        if let nodeName = self.nodeName {
            try encodeContainer.encode(nodeName, forKey: .nodeName)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }
}

extension AssociateNodeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateNodeInput: Swift.Equatable {
    /// Engine attributes used for associating the node. Attributes accepted in a AssociateNode request for Chef
    ///
    /// * CHEF_ORGANIZATION: The Chef organization with which the node is associated. By default only one organization named default can exist.
    ///
    /// * CHEF_NODE_PUBLIC_KEY: A PEM-formatted public key. This key is required for the chef-client agent to access the Chef API.
    ///
    ///
    /// Attributes accepted in a AssociateNode request for Puppet
    ///
    /// * PUPPET_NODE_CSR: A PEM-formatted certificate-signing request (CSR) that is created by the node.
    /// This member is required.
    public var engineAttributes: [OpsWorksCMClientTypes.EngineAttribute]?
    /// The name of the node.
    /// This member is required.
    public var nodeName: Swift.String?
    /// The name of the server with which to associate the node.
    /// This member is required.
    public var serverName: Swift.String?

    public init(
        engineAttributes: [OpsWorksCMClientTypes.EngineAttribute]? = nil,
        nodeName: Swift.String? = nil,
        serverName: Swift.String? = nil
    )
    {
        self.engineAttributes = engineAttributes
        self.nodeName = nodeName
        self.serverName = serverName
    }
}

struct AssociateNodeInputBody: Swift.Equatable {
    let serverName: Swift.String?
    let nodeName: Swift.String?
    let engineAttributes: [OpsWorksCMClientTypes.EngineAttribute]?
}

extension AssociateNodeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineAttributes = "EngineAttributes"
        case nodeName = "NodeName"
        case serverName = "ServerName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let nodeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeName)
        nodeName = nodeNameDecoded
        let engineAttributesContainer = try containerValues.decodeIfPresent([OpsWorksCMClientTypes.EngineAttribute?].self, forKey: .engineAttributes)
        var engineAttributesDecoded0:[OpsWorksCMClientTypes.EngineAttribute]? = nil
        if let engineAttributesContainer = engineAttributesContainer {
            engineAttributesDecoded0 = [OpsWorksCMClientTypes.EngineAttribute]()
            for structure0 in engineAttributesContainer {
                if let structure0 = structure0 {
                    engineAttributesDecoded0?.append(structure0)
                }
            }
        }
        engineAttributes = engineAttributesDecoded0
    }
}

extension AssociateNodeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateNodeOutputBody = try responseDecoder.decode(responseBody: data)
            self.nodeAssociationStatusToken = output.nodeAssociationStatusToken
        } else {
            self.nodeAssociationStatusToken = nil
        }
    }
}

public struct AssociateNodeOutput: Swift.Equatable {
    /// Contains a token which can be passed to the DescribeNodeAssociationStatus API call to get the status of the association request.
    public var nodeAssociationStatusToken: Swift.String?

    public init(
        nodeAssociationStatusToken: Swift.String? = nil
    )
    {
        self.nodeAssociationStatusToken = nodeAssociationStatusToken
    }
}

struct AssociateNodeOutputBody: Swift.Equatable {
    let nodeAssociationStatusToken: Swift.String?
}

extension AssociateNodeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nodeAssociationStatusToken = "NodeAssociationStatusToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeAssociationStatusTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeAssociationStatusToken)
        nodeAssociationStatusToken = nodeAssociationStatusTokenDecoded
    }
}

enum AssociateNodeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidStateException": return try await InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OpsWorksCMClientTypes.Backup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupArn = "BackupArn"
        case backupId = "BackupId"
        case backupType = "BackupType"
        case createdAt = "CreatedAt"
        case description = "Description"
        case engine = "Engine"
        case engineModel = "EngineModel"
        case engineVersion = "EngineVersion"
        case instanceProfileArn = "InstanceProfileArn"
        case instanceType = "InstanceType"
        case keyPair = "KeyPair"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case s3DataSize = "S3DataSize"
        case s3DataUrl = "S3DataUrl"
        case s3LogUrl = "S3LogUrl"
        case securityGroupIds = "SecurityGroupIds"
        case serverName = "ServerName"
        case serviceRoleArn = "ServiceRoleArn"
        case status = "Status"
        case statusDescription = "StatusDescription"
        case subnetIds = "SubnetIds"
        case toolsVersion = "ToolsVersion"
        case userArn = "UserArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupArn = self.backupArn {
            try encodeContainer.encode(backupArn, forKey: .backupArn)
        }
        if let backupId = self.backupId {
            try encodeContainer.encode(backupId, forKey: .backupId)
        }
        if let backupType = self.backupType {
            try encodeContainer.encode(backupType.rawValue, forKey: .backupType)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let engine = self.engine {
            try encodeContainer.encode(engine, forKey: .engine)
        }
        if let engineModel = self.engineModel {
            try encodeContainer.encode(engineModel, forKey: .engineModel)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let instanceProfileArn = self.instanceProfileArn {
            try encodeContainer.encode(instanceProfileArn, forKey: .instanceProfileArn)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let keyPair = self.keyPair {
            try encodeContainer.encode(keyPair, forKey: .keyPair)
        }
        if let preferredBackupWindow = self.preferredBackupWindow {
            try encodeContainer.encode(preferredBackupWindow, forKey: .preferredBackupWindow)
        }
        if let preferredMaintenanceWindow = self.preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if let s3DataSize = self.s3DataSize {
            try encodeContainer.encode(s3DataSize, forKey: .s3DataSize)
        }
        if let s3DataUrl = self.s3DataUrl {
            try encodeContainer.encode(s3DataUrl, forKey: .s3DataUrl)
        }
        if let s3LogUrl = self.s3LogUrl {
            try encodeContainer.encode(s3LogUrl, forKey: .s3LogUrl)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for string0 in securityGroupIds {
                try securityGroupIdsContainer.encode(string0)
            }
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let serviceRoleArn = self.serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDescription = self.statusDescription {
            try encodeContainer.encode(statusDescription, forKey: .statusDescription)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for string0 in subnetIds {
                try subnetIdsContainer.encode(string0)
            }
        }
        if let toolsVersion = self.toolsVersion {
            try encodeContainer.encode(toolsVersion, forKey: .toolsVersion)
        }
        if let userArn = self.userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupArn)
        backupArn = backupArnDecoded
        let backupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupId)
        backupId = backupIdDecoded
        let backupTypeDecoded = try containerValues.decodeIfPresent(OpsWorksCMClientTypes.BackupType.self, forKey: .backupType)
        backupType = backupTypeDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineModel)
        engineModel = engineModelDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let instanceProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileArn)
        instanceProfileArn = instanceProfileArnDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let keyPairDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyPair)
        keyPair = keyPairDecoded
        let preferredBackupWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredBackupWindow)
        preferredBackupWindow = preferredBackupWindowDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let s3DataSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .s3DataSize)
        s3DataSize = s3DataSizeDecoded
        let s3DataUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3DataUrl)
        s3DataUrl = s3DataUrlDecoded
        let s3LogUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3LogUrl)
        s3LogUrl = s3LogUrlDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OpsWorksCMClientTypes.BackupStatus.self, forKey: .status)
        status = statusDecoded
        let statusDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDescription)
        statusDescription = statusDescriptionDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let toolsVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .toolsVersion)
        toolsVersion = toolsVersionDecoded
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
    }
}

extension OpsWorksCMClientTypes {
    /// Describes a single backup.
    public struct Backup: Swift.Equatable {
        /// The ARN of the backup.
        public var backupArn: Swift.String?
        /// The generated ID of the backup. Example: myServerName-yyyyMMddHHmmssSSS
        public var backupId: Swift.String?
        /// The backup type. Valid values are automated or manual.
        public var backupType: OpsWorksCMClientTypes.BackupType?
        /// The time stamp when the backup was created in the database. Example: 2016-07-29T13:38:47.520Z
        public var createdAt: ClientRuntime.Date?
        /// A user-provided description for a manual backup. This field is empty for automated backups.
        public var description: Swift.String?
        /// The engine type that is obtained from the server when the backup is created.
        public var engine: Swift.String?
        /// The engine model that is obtained from the server when the backup is created.
        public var engineModel: Swift.String?
        /// The engine version that is obtained from the server when the backup is created.
        public var engineVersion: Swift.String?
        /// The EC2 instance profile ARN that is obtained from the server when the backup is created. Because this value is stored, you are not required to provide the InstanceProfileArn again if you restore a backup.
        public var instanceProfileArn: Swift.String?
        /// The instance type that is obtained from the server when the backup is created.
        public var instanceType: Swift.String?
        /// The key pair that is obtained from the server when the backup is created.
        public var keyPair: Swift.String?
        /// The preferred backup period that is obtained from the server when the backup is created.
        public var preferredBackupWindow: Swift.String?
        /// The preferred maintenance period that is obtained from the server when the backup is created.
        public var preferredMaintenanceWindow: Swift.String?
        /// This field is deprecated and is no longer used.
        @available(*, deprecated)
        public var s3DataSize: Swift.Int?
        /// This field is deprecated and is no longer used.
        @available(*, deprecated)
        public var s3DataUrl: Swift.String?
        /// The Amazon S3 URL of the backup's log file.
        public var s3LogUrl: Swift.String?
        /// The security group IDs that are obtained from the server when the backup is created.
        public var securityGroupIds: [Swift.String]?
        /// The name of the server from which the backup was made.
        public var serverName: Swift.String?
        /// The service role ARN that is obtained from the server when the backup is created.
        public var serviceRoleArn: Swift.String?
        /// The status of a backup while in progress.
        public var status: OpsWorksCMClientTypes.BackupStatus?
        /// An informational message about backup status.
        public var statusDescription: Swift.String?
        /// The subnet IDs that are obtained from the server when the backup is created.
        public var subnetIds: [Swift.String]?
        /// The version of AWS OpsWorks CM-specific tools that is obtained from the server when the backup is created.
        public var toolsVersion: Swift.String?
        /// The IAM user ARN of the requester for manual backups. This field is empty for automated backups.
        public var userArn: Swift.String?

        public init(
            backupArn: Swift.String? = nil,
            backupId: Swift.String? = nil,
            backupType: OpsWorksCMClientTypes.BackupType? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            engine: Swift.String? = nil,
            engineModel: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            instanceProfileArn: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            keyPair: Swift.String? = nil,
            preferredBackupWindow: Swift.String? = nil,
            preferredMaintenanceWindow: Swift.String? = nil,
            s3DataSize: Swift.Int? = nil,
            s3DataUrl: Swift.String? = nil,
            s3LogUrl: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            serverName: Swift.String? = nil,
            serviceRoleArn: Swift.String? = nil,
            status: OpsWorksCMClientTypes.BackupStatus? = nil,
            statusDescription: Swift.String? = nil,
            subnetIds: [Swift.String]? = nil,
            toolsVersion: Swift.String? = nil,
            userArn: Swift.String? = nil
        )
        {
            self.backupArn = backupArn
            self.backupId = backupId
            self.backupType = backupType
            self.createdAt = createdAt
            self.description = description
            self.engine = engine
            self.engineModel = engineModel
            self.engineVersion = engineVersion
            self.instanceProfileArn = instanceProfileArn
            self.instanceType = instanceType
            self.keyPair = keyPair
            self.preferredBackupWindow = preferredBackupWindow
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.s3DataSize = s3DataSize
            self.s3DataUrl = s3DataUrl
            self.s3LogUrl = s3LogUrl
            self.securityGroupIds = securityGroupIds
            self.serverName = serverName
            self.serviceRoleArn = serviceRoleArn
            self.status = status
            self.statusDescription = statusDescription
            self.subnetIds = subnetIds
            self.toolsVersion = toolsVersion
            self.userArn = userArn
        }
    }

}

extension OpsWorksCMClientTypes {
    public enum BackupStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleting
        case failed
        case inProgress
        case ok
        case sdkUnknown(Swift.String)

        public static var allCases: [BackupStatus] {
            return [
                .deleting,
                .failed,
                .inProgress,
                .ok,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .ok: return "OK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BackupStatus(rawValue: rawValue) ?? BackupStatus.sdkUnknown(rawValue)
        }
    }
}

extension OpsWorksCMClientTypes {
    public enum BackupType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case automated
        case manual
        case sdkUnknown(Swift.String)

        public static var allCases: [BackupType] {
            return [
                .automated,
                .manual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .automated: return "AUTOMATED"
            case .manual: return "MANUAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BackupType(rawValue: rawValue) ?? BackupType.sdkUnknown(rawValue)
        }
    }
}

extension CreateBackupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case serverName = "ServerName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateBackupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateBackupInput: Swift.Equatable {
    /// A user-defined description of the backup.
    public var description: Swift.String?
    /// The name of the server that you want to back up.
    /// This member is required.
    public var serverName: Swift.String?
    /// A map that contains tag keys and tag values to attach to an AWS OpsWorks-CM server backup.
    ///
    /// * The key cannot be empty.
    ///
    /// * The key can be a maximum of 127 characters, and can contain only Unicode letters, numbers, or separators, or the following special characters: + - = . _ : /
    ///
    /// * The value can be a maximum 255 characters, and contain only Unicode letters, numbers, or separators, or the following special characters: + - = . _ : /
    ///
    /// * Leading and trailing white spaces are trimmed from both the key and value.
    ///
    /// * A maximum of 50 user-applied tags is allowed for tag-supported AWS OpsWorks-CM resources.
    public var tags: [OpsWorksCMClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        serverName: Swift.String? = nil,
        tags: [OpsWorksCMClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.serverName = serverName
        self.tags = tags
    }
}

struct CreateBackupInputBody: Swift.Equatable {
    let serverName: Swift.String?
    let description: Swift.String?
    let tags: [OpsWorksCMClientTypes.Tag]?
}

extension CreateBackupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case serverName = "ServerName"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([OpsWorksCMClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[OpsWorksCMClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [OpsWorksCMClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateBackupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateBackupOutputBody = try responseDecoder.decode(responseBody: data)
            self.backup = output.backup
        } else {
            self.backup = nil
        }
    }
}

public struct CreateBackupOutput: Swift.Equatable {
    /// Backup created by request.
    public var backup: OpsWorksCMClientTypes.Backup?

    public init(
        backup: OpsWorksCMClientTypes.Backup? = nil
    )
    {
        self.backup = backup
    }
}

struct CreateBackupOutputBody: Swift.Equatable {
    let backup: OpsWorksCMClientTypes.Backup?
}

extension CreateBackupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backup = "Backup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupDecoded = try containerValues.decodeIfPresent(OpsWorksCMClientTypes.Backup.self, forKey: .backup)
        backup = backupDecoded
    }
}

enum CreateBackupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidStateException": return try await InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateServerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateServerInput(associatePublicIpAddress: \(Swift.String(describing: associatePublicIpAddress)), backupId: \(Swift.String(describing: backupId)), backupRetentionCount: \(Swift.String(describing: backupRetentionCount)), customCertificate: \(Swift.String(describing: customCertificate)), customDomain: \(Swift.String(describing: customDomain)), disableAutomatedBackup: \(Swift.String(describing: disableAutomatedBackup)), engine: \(Swift.String(describing: engine)), engineAttributes: \(Swift.String(describing: engineAttributes)), engineModel: \(Swift.String(describing: engineModel)), engineVersion: \(Swift.String(describing: engineVersion)), instanceProfileArn: \(Swift.String(describing: instanceProfileArn)), instanceType: \(Swift.String(describing: instanceType)), keyPair: \(Swift.String(describing: keyPair)), preferredBackupWindow: \(Swift.String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(Swift.String(describing: preferredMaintenanceWindow)), securityGroupIds: \(Swift.String(describing: securityGroupIds)), serverName: \(Swift.String(describing: serverName)), serviceRoleArn: \(Swift.String(describing: serviceRoleArn)), subnetIds: \(Swift.String(describing: subnetIds)), tags: \(Swift.String(describing: tags)), customPrivateKey: \"CONTENT_REDACTED\")"}
}

extension CreateServerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatePublicIpAddress = "AssociatePublicIpAddress"
        case backupId = "BackupId"
        case backupRetentionCount = "BackupRetentionCount"
        case customCertificate = "CustomCertificate"
        case customDomain = "CustomDomain"
        case customPrivateKey = "CustomPrivateKey"
        case disableAutomatedBackup = "DisableAutomatedBackup"
        case engine = "Engine"
        case engineAttributes = "EngineAttributes"
        case engineModel = "EngineModel"
        case engineVersion = "EngineVersion"
        case instanceProfileArn = "InstanceProfileArn"
        case instanceType = "InstanceType"
        case keyPair = "KeyPair"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case securityGroupIds = "SecurityGroupIds"
        case serverName = "ServerName"
        case serviceRoleArn = "ServiceRoleArn"
        case subnetIds = "SubnetIds"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatePublicIpAddress = self.associatePublicIpAddress {
            try encodeContainer.encode(associatePublicIpAddress, forKey: .associatePublicIpAddress)
        }
        if let backupId = self.backupId {
            try encodeContainer.encode(backupId, forKey: .backupId)
        }
        if let backupRetentionCount = self.backupRetentionCount {
            try encodeContainer.encode(backupRetentionCount, forKey: .backupRetentionCount)
        }
        if let customCertificate = self.customCertificate {
            try encodeContainer.encode(customCertificate, forKey: .customCertificate)
        }
        if let customDomain = self.customDomain {
            try encodeContainer.encode(customDomain, forKey: .customDomain)
        }
        if let customPrivateKey = self.customPrivateKey {
            try encodeContainer.encode(customPrivateKey, forKey: .customPrivateKey)
        }
        if let disableAutomatedBackup = self.disableAutomatedBackup {
            try encodeContainer.encode(disableAutomatedBackup, forKey: .disableAutomatedBackup)
        }
        if let engine = self.engine {
            try encodeContainer.encode(engine, forKey: .engine)
        }
        if let engineAttributes = engineAttributes {
            var engineAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .engineAttributes)
            for engineattribute0 in engineAttributes {
                try engineAttributesContainer.encode(engineattribute0)
            }
        }
        if let engineModel = self.engineModel {
            try encodeContainer.encode(engineModel, forKey: .engineModel)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let instanceProfileArn = self.instanceProfileArn {
            try encodeContainer.encode(instanceProfileArn, forKey: .instanceProfileArn)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let keyPair = self.keyPair {
            try encodeContainer.encode(keyPair, forKey: .keyPair)
        }
        if let preferredBackupWindow = self.preferredBackupWindow {
            try encodeContainer.encode(preferredBackupWindow, forKey: .preferredBackupWindow)
        }
        if let preferredMaintenanceWindow = self.preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for string0 in securityGroupIds {
                try securityGroupIdsContainer.encode(string0)
            }
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let serviceRoleArn = self.serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for string0 in subnetIds {
                try subnetIdsContainer.encode(string0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateServerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateServerInput: Swift.Equatable {
    /// Associate a public IP address with a server that you are launching. Valid values are true or false. The default value is true.
    public var associatePublicIpAddress: Swift.Bool?
    /// If you specify this field, AWS OpsWorks CM creates the server by using the backup represented by BackupId.
    public var backupId: Swift.String?
    /// The number of automated backups that you want to keep. Whenever a new backup is created, AWS OpsWorks CM deletes the oldest backups if this number is exceeded. The default value is 1.
    public var backupRetentionCount: Swift.Int?
    /// A PEM-formatted HTTPS certificate. The value can be be a single, self-signed certificate, or a certificate chain. If you specify a custom certificate, you must also specify values for CustomDomain and CustomPrivateKey. The following are requirements for the CustomCertificate value:
    ///
    /// * You can provide either a self-signed, custom certificate, or the full certificate chain.
    ///
    /// * The certificate must be a valid X509 certificate, or a certificate chain in PEM format.
    ///
    /// * The certificate must be valid at the time of upload. A certificate can't be used before its validity period begins (the certificate's NotBefore date), or after it expires (the certificate's NotAfter date).
    ///
    /// * The certificateâ€™s common name or subject alternative names (SANs), if present, must match the value of CustomDomain.
    ///
    /// * The certificate must match the value of CustomPrivateKey.
    public var customCertificate: Swift.String?
    /// An optional public endpoint of a server, such as https://aws.my-company.com. To access the server, create a CNAME DNS record in your preferred DNS service that points the custom domain to the endpoint that is generated when the server is created (the value of the CreateServer Endpoint attribute). You cannot access the server by using the generated Endpoint value if the server is using a custom domain. If you specify a custom domain, you must also specify values for CustomCertificate and CustomPrivateKey.
    public var customDomain: Swift.String?
    /// A private key in PEM format for connecting to the server by using HTTPS. The private key must not be encrypted; it cannot be protected by a password or passphrase. If you specify a custom private key, you must also specify values for CustomDomain and CustomCertificate.
    public var customPrivateKey: Swift.String?
    /// Enable or disable scheduled backups. Valid values are true or false. The default value is true.
    public var disableAutomatedBackup: Swift.Bool?
    /// The configuration management engine to use. Valid values include ChefAutomate and Puppet.
    /// This member is required.
    public var engine: Swift.String?
    /// Optional engine attributes on a specified server. Attributes accepted in a Chef createServer request:
    ///
    /// * CHEF_AUTOMATE_PIVOTAL_KEY: A base64-encoded RSA public key. The corresponding private key is required to access the Chef API. When no CHEF_AUTOMATE_PIVOTAL_KEY is set, a private key is generated and returned in the response.
    ///
    /// * CHEF_AUTOMATE_ADMIN_PASSWORD: The password for the administrative user in the Chef Automate web-based dashboard. The password length is a minimum of eight characters, and a maximum of 32. The password can contain letters, numbers, and special characters (!/@#$%^&+=_). The password must contain at least one lower case letter, one upper case letter, one number, and one special character. When no CHEF_AUTOMATE_ADMIN_PASSWORD is set, one is generated and returned in the response.
    ///
    ///
    /// Attributes accepted in a Puppet createServer request:
    ///
    /// * PUPPET_ADMIN_PASSWORD: To work with the Puppet Enterprise console, a password must use ASCII characters.
    ///
    /// * PUPPET_R10K_REMOTE: The r10k remote is the URL of your control repository (for example, ssh://git@your.git-repo.com:user/control-repo.git). Specifying an r10k remote opens TCP port 8170.
    ///
    /// * PUPPET_R10K_PRIVATE_KEY: If you are using a private Git repository, add PUPPET_R10K_PRIVATE_KEY to specify a PEM-encoded private SSH key.
    public var engineAttributes: [OpsWorksCMClientTypes.EngineAttribute]?
    /// The engine model of the server. Valid values in this release include Monolithic for Puppet and Single for Chef.
    public var engineModel: Swift.String?
    /// The major release version of the engine that you want to use. For a Chef server, the valid value for EngineVersion is currently 2. For a Puppet server, valid values are 2019 or 2017.
    public var engineVersion: Swift.String?
    /// The ARN of the instance profile that your Amazon EC2 instances use. Although the AWS OpsWorks console typically creates the instance profile for you, if you are using API commands instead, run the service-role-creation.yaml AWS CloudFormation template, located at https://s3.amazonaws.com/opsworks-cm-us-east-1-prod-default-assets/misc/opsworks-cm-roles.yaml. This template creates a CloudFormation stack that includes the instance profile you need.
    /// This member is required.
    public var instanceProfileArn: Swift.String?
    /// The Amazon EC2 instance type to use. For example, m5.large.
    /// This member is required.
    public var instanceType: Swift.String?
    /// The Amazon EC2 key pair to set for the instance. This parameter is optional; if desired, you may specify this parameter to connect to your instances by using SSH.
    public var keyPair: Swift.String?
    /// The start time for a one-hour period during which AWS OpsWorks CM backs up application-level data on your server if automated backups are enabled. Valid values must be specified in one of the following formats:
    ///
    /// * HH:MM for daily backups
    ///
    /// * DDD:HH:MM for weekly backups
    ///
    ///
    /// MM must be specified as 00. The specified time is in coordinated universal time (UTC). The default value is a random, daily start time. Example: 08:00, which represents a daily start time of 08:00 UTC. Example: Mon:08:00, which represents a start time of every Monday at 08:00 UTC. (8:00 a.m.)
    public var preferredBackupWindow: Swift.String?
    /// The start time for a one-hour period each week during which AWS OpsWorks CM performs maintenance on the instance. Valid values must be specified in the following format: DDD:HH:MM. MM must be specified as 00. The specified time is in coordinated universal time (UTC). The default value is a random one-hour period on Tuesday, Wednesday, or Friday. See TimeWindowDefinition for more information. Example: Mon:08:00, which represents a start time of every Monday at 08:00 UTC. (8:00 a.m.)
    public var preferredMaintenanceWindow: Swift.String?
    /// A list of security group IDs to attach to the Amazon EC2 instance. If you add this parameter, the specified security groups must be within the VPC that is specified by SubnetIds. If you do not specify this parameter, AWS OpsWorks CM creates one new security group that uses TCP ports 22 and 443, open to 0.0.0.0/0 (everyone).
    public var securityGroupIds: [Swift.String]?
    /// The name of the server. The server name must be unique within your AWS account, within each region. Server names must start with a letter; then letters, numbers, or hyphens (-) are allowed, up to a maximum of 40 characters.
    /// This member is required.
    public var serverName: Swift.String?
    /// The service role that the AWS OpsWorks CM service backend uses to work with your account. Although the AWS OpsWorks management console typically creates the service role for you, if you are using the AWS CLI or API commands, run the service-role-creation.yaml AWS CloudFormation template, located at https://s3.amazonaws.com/opsworks-cm-us-east-1-prod-default-assets/misc/opsworks-cm-roles.yaml. This template creates a CloudFormation stack that includes the service role and instance profile that you need.
    /// This member is required.
    public var serviceRoleArn: Swift.String?
    /// The IDs of subnets in which to launch the server EC2 instance. Amazon EC2-Classic customers: This field is required. All servers must run within a VPC. The VPC must have "Auto Assign Public IP" enabled. EC2-VPC customers: This field is optional. If you do not specify subnet IDs, your EC2 instances are created in a default subnet that is selected by Amazon EC2. If you specify subnet IDs, the VPC must have "Auto Assign Public IP" enabled. For more information about supported Amazon EC2 platforms, see [Supported Platforms](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-supported-platforms.html).
    public var subnetIds: [Swift.String]?
    /// A map that contains tag keys and tag values to attach to an AWS OpsWorks for Chef Automate or AWS OpsWorks for Puppet Enterprise server.
    ///
    /// * The key cannot be empty.
    ///
    /// * The key can be a maximum of 127 characters, and can contain only Unicode letters, numbers, or separators, or the following special characters: + - = . _ : / @
    ///
    /// * The value can be a maximum 255 characters, and contain only Unicode letters, numbers, or separators, or the following special characters: + - = . _ : / @
    ///
    /// * Leading and trailing white spaces are trimmed from both the key and value.
    ///
    /// * A maximum of 50 user-applied tags is allowed for any AWS OpsWorks-CM server.
    public var tags: [OpsWorksCMClientTypes.Tag]?

    public init(
        associatePublicIpAddress: Swift.Bool? = nil,
        backupId: Swift.String? = nil,
        backupRetentionCount: Swift.Int? = nil,
        customCertificate: Swift.String? = nil,
        customDomain: Swift.String? = nil,
        customPrivateKey: Swift.String? = nil,
        disableAutomatedBackup: Swift.Bool? = nil,
        engine: Swift.String? = nil,
        engineAttributes: [OpsWorksCMClientTypes.EngineAttribute]? = nil,
        engineModel: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        instanceProfileArn: Swift.String? = nil,
        instanceType: Swift.String? = nil,
        keyPair: Swift.String? = nil,
        preferredBackupWindow: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        serverName: Swift.String? = nil,
        serviceRoleArn: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [OpsWorksCMClientTypes.Tag]? = nil
    )
    {
        self.associatePublicIpAddress = associatePublicIpAddress
        self.backupId = backupId
        self.backupRetentionCount = backupRetentionCount
        self.customCertificate = customCertificate
        self.customDomain = customDomain
        self.customPrivateKey = customPrivateKey
        self.disableAutomatedBackup = disableAutomatedBackup
        self.engine = engine
        self.engineAttributes = engineAttributes
        self.engineModel = engineModel
        self.engineVersion = engineVersion
        self.instanceProfileArn = instanceProfileArn
        self.instanceType = instanceType
        self.keyPair = keyPair
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.securityGroupIds = securityGroupIds
        self.serverName = serverName
        self.serviceRoleArn = serviceRoleArn
        self.subnetIds = subnetIds
        self.tags = tags
    }
}

struct CreateServerInputBody: Swift.Equatable {
    let associatePublicIpAddress: Swift.Bool?
    let customDomain: Swift.String?
    let customCertificate: Swift.String?
    let customPrivateKey: Swift.String?
    let disableAutomatedBackup: Swift.Bool?
    let engine: Swift.String?
    let engineModel: Swift.String?
    let engineVersion: Swift.String?
    let engineAttributes: [OpsWorksCMClientTypes.EngineAttribute]?
    let backupRetentionCount: Swift.Int?
    let serverName: Swift.String?
    let instanceProfileArn: Swift.String?
    let instanceType: Swift.String?
    let keyPair: Swift.String?
    let preferredMaintenanceWindow: Swift.String?
    let preferredBackupWindow: Swift.String?
    let securityGroupIds: [Swift.String]?
    let serviceRoleArn: Swift.String?
    let subnetIds: [Swift.String]?
    let tags: [OpsWorksCMClientTypes.Tag]?
    let backupId: Swift.String?
}

extension CreateServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatePublicIpAddress = "AssociatePublicIpAddress"
        case backupId = "BackupId"
        case backupRetentionCount = "BackupRetentionCount"
        case customCertificate = "CustomCertificate"
        case customDomain = "CustomDomain"
        case customPrivateKey = "CustomPrivateKey"
        case disableAutomatedBackup = "DisableAutomatedBackup"
        case engine = "Engine"
        case engineAttributes = "EngineAttributes"
        case engineModel = "EngineModel"
        case engineVersion = "EngineVersion"
        case instanceProfileArn = "InstanceProfileArn"
        case instanceType = "InstanceType"
        case keyPair = "KeyPair"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case securityGroupIds = "SecurityGroupIds"
        case serverName = "ServerName"
        case serviceRoleArn = "ServiceRoleArn"
        case subnetIds = "SubnetIds"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associatePublicIpAddressDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associatePublicIpAddress)
        associatePublicIpAddress = associatePublicIpAddressDecoded
        let customDomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDomain)
        customDomain = customDomainDecoded
        let customCertificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customCertificate)
        customCertificate = customCertificateDecoded
        let customPrivateKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customPrivateKey)
        customPrivateKey = customPrivateKeyDecoded
        let disableAutomatedBackupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableAutomatedBackup)
        disableAutomatedBackup = disableAutomatedBackupDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineModel)
        engineModel = engineModelDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let engineAttributesContainer = try containerValues.decodeIfPresent([OpsWorksCMClientTypes.EngineAttribute?].self, forKey: .engineAttributes)
        var engineAttributesDecoded0:[OpsWorksCMClientTypes.EngineAttribute]? = nil
        if let engineAttributesContainer = engineAttributesContainer {
            engineAttributesDecoded0 = [OpsWorksCMClientTypes.EngineAttribute]()
            for structure0 in engineAttributesContainer {
                if let structure0 = structure0 {
                    engineAttributesDecoded0?.append(structure0)
                }
            }
        }
        engineAttributes = engineAttributesDecoded0
        let backupRetentionCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupRetentionCount)
        backupRetentionCount = backupRetentionCountDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let instanceProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileArn)
        instanceProfileArn = instanceProfileArnDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let keyPairDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyPair)
        keyPair = keyPairDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let preferredBackupWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredBackupWindow)
        preferredBackupWindow = preferredBackupWindowDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([OpsWorksCMClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[OpsWorksCMClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [OpsWorksCMClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let backupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupId)
        backupId = backupIdDecoded
    }
}

extension CreateServerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateServerOutputBody = try responseDecoder.decode(responseBody: data)
            self.server = output.server
        } else {
            self.server = nil
        }
    }
}

public struct CreateServerOutput: Swift.Equatable {
    /// The server that is created by the request.
    public var server: OpsWorksCMClientTypes.Server?

    public init(
        server: OpsWorksCMClientTypes.Server? = nil
    )
    {
        self.server = server
    }
}

struct CreateServerOutputBody: Swift.Equatable {
    let server: OpsWorksCMClientTypes.Server?
}

extension CreateServerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case server = "Server"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverDecoded = try containerValues.decodeIfPresent(OpsWorksCMClientTypes.Server.self, forKey: .server)
        server = serverDecoded
    }
}

enum CreateServerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteBackupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupId = "BackupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupId = self.backupId {
            try encodeContainer.encode(backupId, forKey: .backupId)
        }
    }
}

extension DeleteBackupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteBackupInput: Swift.Equatable {
    /// The ID of the backup to delete. Run the DescribeBackups command to get a list of backup IDs. Backup IDs are in the format ServerName-yyyyMMddHHmmssSSS.
    /// This member is required.
    public var backupId: Swift.String?

    public init(
        backupId: Swift.String? = nil
    )
    {
        self.backupId = backupId
    }
}

struct DeleteBackupInputBody: Swift.Equatable {
    let backupId: Swift.String?
}

extension DeleteBackupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupId = "BackupId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupId)
        backupId = backupIdDecoded
    }
}

extension DeleteBackupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteBackupOutput: Swift.Equatable {

    public init() { }
}

enum DeleteBackupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidStateException": return try await InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteServerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverName = "ServerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }
}

extension DeleteServerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteServerInput: Swift.Equatable {
    /// The ID of the server to delete.
    /// This member is required.
    public var serverName: Swift.String?

    public init(
        serverName: Swift.String? = nil
    )
    {
        self.serverName = serverName
    }
}

struct DeleteServerInputBody: Swift.Equatable {
    let serverName: Swift.String?
}

extension DeleteServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverName = "ServerName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
    }
}

extension DeleteServerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteServerOutput: Swift.Equatable {

    public init() { }
}

enum DeleteServerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidStateException": return try await InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAccountAttributesInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DescribeAccountAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAccountAttributesInput: Swift.Equatable {

    public init() { }
}

struct DescribeAccountAttributesInputBody: Swift.Equatable {
}

extension DescribeAccountAttributesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAccountAttributesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAccountAttributesOutputBody = try responseDecoder.decode(responseBody: data)
            self.attributes = output.attributes
        } else {
            self.attributes = nil
        }
    }
}

public struct DescribeAccountAttributesOutput: Swift.Equatable {
    /// The attributes that are currently set for the account.
    public var attributes: [OpsWorksCMClientTypes.AccountAttribute]?

    public init(
        attributes: [OpsWorksCMClientTypes.AccountAttribute]? = nil
    )
    {
        self.attributes = attributes
    }
}

struct DescribeAccountAttributesOutputBody: Swift.Equatable {
    let attributes: [OpsWorksCMClientTypes.AccountAttribute]?
}

extension DescribeAccountAttributesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([OpsWorksCMClientTypes.AccountAttribute?].self, forKey: .attributes)
        var attributesDecoded0:[OpsWorksCMClientTypes.AccountAttribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [OpsWorksCMClientTypes.AccountAttribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

enum DescribeAccountAttributesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeBackupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupId = "BackupId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverName = "ServerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupId = self.backupId {
            try encodeContainer.encode(backupId, forKey: .backupId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }
}

extension DescribeBackupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeBackupsInput: Swift.Equatable {
    /// Describes a single backup.
    public var backupId: Swift.String?
    /// This is not currently implemented for DescribeBackups requests.
    public var maxResults: Swift.Int?
    /// This is not currently implemented for DescribeBackups requests.
    public var nextToken: Swift.String?
    /// Returns backups for the server with the specified ServerName.
    public var serverName: Swift.String?

    public init(
        backupId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serverName: Swift.String? = nil
    )
    {
        self.backupId = backupId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serverName = serverName
    }
}

struct DescribeBackupsInputBody: Swift.Equatable {
    let backupId: Swift.String?
    let serverName: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeBackupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupId = "BackupId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverName = "ServerName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupId)
        backupId = backupIdDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeBackupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeBackupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.backups = output.backups
            self.nextToken = output.nextToken
        } else {
            self.backups = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeBackupsOutput: Swift.Equatable {
    /// Contains the response to a DescribeBackups request.
    public var backups: [OpsWorksCMClientTypes.Backup]?
    /// This is not currently implemented for DescribeBackups requests.
    public var nextToken: Swift.String?

    public init(
        backups: [OpsWorksCMClientTypes.Backup]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backups = backups
        self.nextToken = nextToken
    }
}

struct DescribeBackupsOutputBody: Swift.Equatable {
    let backups: [OpsWorksCMClientTypes.Backup]?
    let nextToken: Swift.String?
}

extension DescribeBackupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backups = "Backups"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupsContainer = try containerValues.decodeIfPresent([OpsWorksCMClientTypes.Backup?].self, forKey: .backups)
        var backupsDecoded0:[OpsWorksCMClientTypes.Backup]? = nil
        if let backupsContainer = backupsContainer {
            backupsDecoded0 = [OpsWorksCMClientTypes.Backup]()
            for structure0 in backupsContainer {
                if let structure0 = structure0 {
                    backupsDecoded0?.append(structure0)
                }
            }
        }
        backups = backupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeBackupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeEventsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverName = "ServerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }
}

extension DescribeEventsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEventsInput: Swift.Equatable {
    /// To receive a paginated response, use this parameter to specify the maximum number of results to be returned with a single call. If the number of available results exceeds this maximum, the response includes a NextToken value that you can assign to the NextToken request parameter to get the next set of results.
    public var maxResults: Swift.Int?
    /// NextToken is a string that is returned in some command responses. It indicates that not all entries have been returned, and that you must run at least one more request to get remaining items. To get remaining results, call DescribeEvents again, and assign the token from the previous results as the value of the nextToken parameter. If there are no more results, the response object's nextToken parameter value is null. Setting a nextToken value that was not returned in your previous results causes an InvalidNextTokenException to occur.
    public var nextToken: Swift.String?
    /// The name of the server for which you want to view events.
    /// This member is required.
    public var serverName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serverName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serverName = serverName
    }
}

struct DescribeEventsInputBody: Swift.Equatable {
    let serverName: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeEventsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverName = "ServerName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeEventsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeEventsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.serverEvents = output.serverEvents
        } else {
            self.nextToken = nil
            self.serverEvents = nil
        }
    }
}

public struct DescribeEventsOutput: Swift.Equatable {
    /// NextToken is a string that is returned in some command responses. It indicates that not all entries have been returned, and that you must run at least one more request to get remaining items. To get remaining results, call DescribeEvents again, and assign the token from the previous results as the value of the nextToken parameter. If there are no more results, the response object's nextToken parameter value is null. Setting a nextToken value that was not returned in your previous results causes an InvalidNextTokenException to occur.
    public var nextToken: Swift.String?
    /// Contains the response to a DescribeEvents request.
    public var serverEvents: [OpsWorksCMClientTypes.ServerEvent]?

    public init(
        nextToken: Swift.String? = nil,
        serverEvents: [OpsWorksCMClientTypes.ServerEvent]? = nil
    )
    {
        self.nextToken = nextToken
        self.serverEvents = serverEvents
    }
}

struct DescribeEventsOutputBody: Swift.Equatable {
    let serverEvents: [OpsWorksCMClientTypes.ServerEvent]?
    let nextToken: Swift.String?
}

extension DescribeEventsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case serverEvents = "ServerEvents"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverEventsContainer = try containerValues.decodeIfPresent([OpsWorksCMClientTypes.ServerEvent?].self, forKey: .serverEvents)
        var serverEventsDecoded0:[OpsWorksCMClientTypes.ServerEvent]? = nil
        if let serverEventsContainer = serverEventsContainer {
            serverEventsDecoded0 = [OpsWorksCMClientTypes.ServerEvent]()
            for structure0 in serverEventsContainer {
                if let structure0 = structure0 {
                    serverEventsDecoded0?.append(structure0)
                }
            }
        }
        serverEvents = serverEventsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeEventsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeNodeAssociationStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nodeAssociationStatusToken = "NodeAssociationStatusToken"
        case serverName = "ServerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nodeAssociationStatusToken = self.nodeAssociationStatusToken {
            try encodeContainer.encode(nodeAssociationStatusToken, forKey: .nodeAssociationStatusToken)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }
}

extension DescribeNodeAssociationStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeNodeAssociationStatusInput: Swift.Equatable {
    /// The token returned in either the AssociateNodeResponse or the DisassociateNodeResponse.
    /// This member is required.
    public var nodeAssociationStatusToken: Swift.String?
    /// The name of the server from which to disassociate the node.
    /// This member is required.
    public var serverName: Swift.String?

    public init(
        nodeAssociationStatusToken: Swift.String? = nil,
        serverName: Swift.String? = nil
    )
    {
        self.nodeAssociationStatusToken = nodeAssociationStatusToken
        self.serverName = serverName
    }
}

struct DescribeNodeAssociationStatusInputBody: Swift.Equatable {
    let nodeAssociationStatusToken: Swift.String?
    let serverName: Swift.String?
}

extension DescribeNodeAssociationStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nodeAssociationStatusToken = "NodeAssociationStatusToken"
        case serverName = "ServerName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeAssociationStatusTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeAssociationStatusToken)
        nodeAssociationStatusToken = nodeAssociationStatusTokenDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
    }
}

extension DescribeNodeAssociationStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeNodeAssociationStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.engineAttributes = output.engineAttributes
            self.nodeAssociationStatus = output.nodeAssociationStatus
        } else {
            self.engineAttributes = nil
            self.nodeAssociationStatus = nil
        }
    }
}

public struct DescribeNodeAssociationStatusOutput: Swift.Equatable {
    /// Attributes specific to the node association. In Puppet, the attibute PUPPET_NODE_CERT contains the signed certificate (the result of the CSR).
    public var engineAttributes: [OpsWorksCMClientTypes.EngineAttribute]?
    /// The status of the association or disassociation request. Possible values:
    ///
    /// * SUCCESS: The association or disassociation succeeded.
    ///
    /// * FAILED: The association or disassociation failed.
    ///
    /// * IN_PROGRESS: The association or disassociation is still in progress.
    public var nodeAssociationStatus: OpsWorksCMClientTypes.NodeAssociationStatus?

    public init(
        engineAttributes: [OpsWorksCMClientTypes.EngineAttribute]? = nil,
        nodeAssociationStatus: OpsWorksCMClientTypes.NodeAssociationStatus? = nil
    )
    {
        self.engineAttributes = engineAttributes
        self.nodeAssociationStatus = nodeAssociationStatus
    }
}

struct DescribeNodeAssociationStatusOutputBody: Swift.Equatable {
    let nodeAssociationStatus: OpsWorksCMClientTypes.NodeAssociationStatus?
    let engineAttributes: [OpsWorksCMClientTypes.EngineAttribute]?
}

extension DescribeNodeAssociationStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineAttributes = "EngineAttributes"
        case nodeAssociationStatus = "NodeAssociationStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeAssociationStatusDecoded = try containerValues.decodeIfPresent(OpsWorksCMClientTypes.NodeAssociationStatus.self, forKey: .nodeAssociationStatus)
        nodeAssociationStatus = nodeAssociationStatusDecoded
        let engineAttributesContainer = try containerValues.decodeIfPresent([OpsWorksCMClientTypes.EngineAttribute?].self, forKey: .engineAttributes)
        var engineAttributesDecoded0:[OpsWorksCMClientTypes.EngineAttribute]? = nil
        if let engineAttributesContainer = engineAttributesContainer {
            engineAttributesDecoded0 = [OpsWorksCMClientTypes.EngineAttribute]()
            for structure0 in engineAttributesContainer {
                if let structure0 = structure0 {
                    engineAttributesDecoded0?.append(structure0)
                }
            }
        }
        engineAttributes = engineAttributesDecoded0
    }
}

enum DescribeNodeAssociationStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeServersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverName = "ServerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }
}

extension DescribeServersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeServersInput: Swift.Equatable {
    /// This is not currently implemented for DescribeServers requests.
    public var maxResults: Swift.Int?
    /// This is not currently implemented for DescribeServers requests.
    public var nextToken: Swift.String?
    /// Describes the server with the specified ServerName.
    public var serverName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serverName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serverName = serverName
    }
}

struct DescribeServersInputBody: Swift.Equatable {
    let serverName: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeServersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverName = "ServerName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeServersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeServersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.servers = output.servers
        } else {
            self.nextToken = nil
            self.servers = nil
        }
    }
}

public struct DescribeServersOutput: Swift.Equatable {
    /// This is not currently implemented for DescribeServers requests.
    public var nextToken: Swift.String?
    /// Contains the response to a DescribeServers request. For Chef Automate servers: If DescribeServersResponse$Servers$EngineAttributes includes CHEF_MAJOR_UPGRADE_AVAILABLE, you can upgrade the Chef Automate server to Chef Automate 2. To be eligible for upgrade, a server running Chef Automate 1 must have had at least one successful maintenance run after November 1, 2019. For Puppet servers: DescribeServersResponse$Servers$EngineAttributes contains the following two responses:
    ///
    /// * PUPPET_API_CA_CERT, the PEM-encoded CA certificate that is used by the Puppet API over TCP port number 8140. The CA certificate is also used to sign node certificates.
    ///
    /// * PUPPET_API_CRL, a certificate revocation list. The certificate revocation list is for internal maintenance purposes only. For more information about the Puppet certificate revocation list, see [Man Page: puppet certificate_revocation_list](https://puppet.com/docs/puppet/5.5/man/certificate_revocation_list.html) in the Puppet documentation.
    public var servers: [OpsWorksCMClientTypes.Server]?

    public init(
        nextToken: Swift.String? = nil,
        servers: [OpsWorksCMClientTypes.Server]? = nil
    )
    {
        self.nextToken = nextToken
        self.servers = servers
    }
}

struct DescribeServersOutputBody: Swift.Equatable {
    let servers: [OpsWorksCMClientTypes.Server]?
    let nextToken: Swift.String?
}

extension DescribeServersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case servers = "Servers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serversContainer = try containerValues.decodeIfPresent([OpsWorksCMClientTypes.Server?].self, forKey: .servers)
        var serversDecoded0:[OpsWorksCMClientTypes.Server]? = nil
        if let serversContainer = serversContainer {
            serversDecoded0 = [OpsWorksCMClientTypes.Server]()
            for structure0 in serversContainer {
                if let structure0 = structure0 {
                    serversDecoded0?.append(structure0)
                }
            }
        }
        servers = serversDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeServersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateNodeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineAttributes = "EngineAttributes"
        case nodeName = "NodeName"
        case serverName = "ServerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engineAttributes = engineAttributes {
            var engineAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .engineAttributes)
            for engineattribute0 in engineAttributes {
                try engineAttributesContainer.encode(engineattribute0)
            }
        }
        if let nodeName = self.nodeName {
            try encodeContainer.encode(nodeName, forKey: .nodeName)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }
}

extension DisassociateNodeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateNodeInput: Swift.Equatable {
    /// Engine attributes that are used for disassociating the node. No attributes are required for Puppet. Attributes required in a DisassociateNode request for Chef
    ///
    /// * CHEF_ORGANIZATION: The Chef organization with which the node was associated. By default only one organization named default can exist.
    public var engineAttributes: [OpsWorksCMClientTypes.EngineAttribute]?
    /// The name of the client node.
    /// This member is required.
    public var nodeName: Swift.String?
    /// The name of the server from which to disassociate the node.
    /// This member is required.
    public var serverName: Swift.String?

    public init(
        engineAttributes: [OpsWorksCMClientTypes.EngineAttribute]? = nil,
        nodeName: Swift.String? = nil,
        serverName: Swift.String? = nil
    )
    {
        self.engineAttributes = engineAttributes
        self.nodeName = nodeName
        self.serverName = serverName
    }
}

struct DisassociateNodeInputBody: Swift.Equatable {
    let serverName: Swift.String?
    let nodeName: Swift.String?
    let engineAttributes: [OpsWorksCMClientTypes.EngineAttribute]?
}

extension DisassociateNodeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineAttributes = "EngineAttributes"
        case nodeName = "NodeName"
        case serverName = "ServerName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let nodeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeName)
        nodeName = nodeNameDecoded
        let engineAttributesContainer = try containerValues.decodeIfPresent([OpsWorksCMClientTypes.EngineAttribute?].self, forKey: .engineAttributes)
        var engineAttributesDecoded0:[OpsWorksCMClientTypes.EngineAttribute]? = nil
        if let engineAttributesContainer = engineAttributesContainer {
            engineAttributesDecoded0 = [OpsWorksCMClientTypes.EngineAttribute]()
            for structure0 in engineAttributesContainer {
                if let structure0 = structure0 {
                    engineAttributesDecoded0?.append(structure0)
                }
            }
        }
        engineAttributes = engineAttributesDecoded0
    }
}

extension DisassociateNodeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisassociateNodeOutputBody = try responseDecoder.decode(responseBody: data)
            self.nodeAssociationStatusToken = output.nodeAssociationStatusToken
        } else {
            self.nodeAssociationStatusToken = nil
        }
    }
}

public struct DisassociateNodeOutput: Swift.Equatable {
    /// Contains a token which can be passed to the DescribeNodeAssociationStatus API call to get the status of the disassociation request.
    public var nodeAssociationStatusToken: Swift.String?

    public init(
        nodeAssociationStatusToken: Swift.String? = nil
    )
    {
        self.nodeAssociationStatusToken = nodeAssociationStatusToken
    }
}

struct DisassociateNodeOutputBody: Swift.Equatable {
    let nodeAssociationStatusToken: Swift.String?
}

extension DisassociateNodeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nodeAssociationStatusToken = "NodeAssociationStatusToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeAssociationStatusTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeAssociationStatusToken)
        nodeAssociationStatusToken = nodeAssociationStatusTokenDecoded
    }
}

enum DisassociateNodeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidStateException": return try await InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OpsWorksCMClientTypes.EngineAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension OpsWorksCMClientTypes.EngineAttribute: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EngineAttribute(name: \(Swift.String(describing: name)), value: \"CONTENT_REDACTED\")"}
}

extension OpsWorksCMClientTypes {
    /// A name and value pair that is specific to the engine of the server.
    public struct EngineAttribute: Swift.Equatable {
        /// The name of the engine attribute.
        public var name: Swift.String?
        /// The value of the engine attribute.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension ExportServerEngineAttributeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportAttributeName = "ExportAttributeName"
        case inputAttributes = "InputAttributes"
        case serverName = "ServerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exportAttributeName = self.exportAttributeName {
            try encodeContainer.encode(exportAttributeName, forKey: .exportAttributeName)
        }
        if let inputAttributes = inputAttributes {
            var inputAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputAttributes)
            for engineattribute0 in inputAttributes {
                try inputAttributesContainer.encode(engineattribute0)
            }
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }
}

extension ExportServerEngineAttributeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ExportServerEngineAttributeInput: Swift.Equatable {
    /// The name of the export attribute. Currently, the supported export attribute is Userdata. This exports a user data script that includes parameters and values provided in the InputAttributes list.
    /// This member is required.
    public var exportAttributeName: Swift.String?
    /// The list of engine attributes. The list type is EngineAttribute. An EngineAttribute list item is a pair that includes an attribute name and its value. For the Userdata ExportAttributeName, the following are supported engine attribute names.
    ///
    /// * RunList In Chef, a list of roles or recipes that are run in the specified order. In Puppet, this parameter is ignored.
    ///
    /// * OrganizationName In Chef, an organization name. AWS OpsWorks for Chef Automate always creates the organization default. In Puppet, this parameter is ignored.
    ///
    /// * NodeEnvironment In Chef, a node environment (for example, development, staging, or one-box). In Puppet, this parameter is ignored.
    ///
    /// * NodeClientVersion In Chef, the version of the Chef engine (three numbers separated by dots, such as 13.8.5). If this attribute is empty, OpsWorks for Chef Automate uses the most current version. In Puppet, this parameter is ignored.
    public var inputAttributes: [OpsWorksCMClientTypes.EngineAttribute]?
    /// The name of the server from which you are exporting the attribute.
    /// This member is required.
    public var serverName: Swift.String?

    public init(
        exportAttributeName: Swift.String? = nil,
        inputAttributes: [OpsWorksCMClientTypes.EngineAttribute]? = nil,
        serverName: Swift.String? = nil
    )
    {
        self.exportAttributeName = exportAttributeName
        self.inputAttributes = inputAttributes
        self.serverName = serverName
    }
}

struct ExportServerEngineAttributeInputBody: Swift.Equatable {
    let exportAttributeName: Swift.String?
    let serverName: Swift.String?
    let inputAttributes: [OpsWorksCMClientTypes.EngineAttribute]?
}

extension ExportServerEngineAttributeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportAttributeName = "ExportAttributeName"
        case inputAttributes = "InputAttributes"
        case serverName = "ServerName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportAttributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportAttributeName)
        exportAttributeName = exportAttributeNameDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let inputAttributesContainer = try containerValues.decodeIfPresent([OpsWorksCMClientTypes.EngineAttribute?].self, forKey: .inputAttributes)
        var inputAttributesDecoded0:[OpsWorksCMClientTypes.EngineAttribute]? = nil
        if let inputAttributesContainer = inputAttributesContainer {
            inputAttributesDecoded0 = [OpsWorksCMClientTypes.EngineAttribute]()
            for structure0 in inputAttributesContainer {
                if let structure0 = structure0 {
                    inputAttributesDecoded0?.append(structure0)
                }
            }
        }
        inputAttributes = inputAttributesDecoded0
    }
}

extension ExportServerEngineAttributeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExportServerEngineAttributeOutputBody = try responseDecoder.decode(responseBody: data)
            self.engineAttribute = output.engineAttribute
            self.serverName = output.serverName
        } else {
            self.engineAttribute = nil
            self.serverName = nil
        }
    }
}

public struct ExportServerEngineAttributeOutput: Swift.Equatable {
    /// The requested engine attribute pair with attribute name and value.
    public var engineAttribute: OpsWorksCMClientTypes.EngineAttribute?
    /// The server name used in the request.
    public var serverName: Swift.String?

    public init(
        engineAttribute: OpsWorksCMClientTypes.EngineAttribute? = nil,
        serverName: Swift.String? = nil
    )
    {
        self.engineAttribute = engineAttribute
        self.serverName = serverName
    }
}

struct ExportServerEngineAttributeOutputBody: Swift.Equatable {
    let engineAttribute: OpsWorksCMClientTypes.EngineAttribute?
    let serverName: Swift.String?
}

extension ExportServerEngineAttributeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineAttribute = "EngineAttribute"
        case serverName = "ServerName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineAttributeDecoded = try containerValues.decodeIfPresent(OpsWorksCMClientTypes.EngineAttribute.self, forKey: .engineAttribute)
        engineAttribute = engineAttributeDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
    }
}

enum ExportServerEngineAttributeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidStateException": return try await InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InvalidNextTokenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This occurs when the provided nextToken is not valid.
public struct InvalidNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error or informational message that can contain more detail about a nextToken failure.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNextTokenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidStateException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource is in a state that does not allow you to perform a specified action.
public struct InvalidStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error or informational message that provides more detail if a resource is in a state that is not valid for performing a specified action.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidStateException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidStateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The limit of servers or backups has been reached.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error or informational message that the maximum allowed number of servers or backups has been exceeded.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// To receive a paginated response, use this parameter to specify the maximum number of results to be returned with a single call. If the number of available results exceeds this maximum, the response includes a NextToken value that you can assign to the NextToken request parameter to get the next set of results.
    public var maxResults: Swift.Int?
    /// NextToken is a string that is returned in some command responses. It indicates that not all entries have been returned, and that you must run at least one more request to get remaining items. To get remaining results, call ListTagsForResource again, and assign the token from the previous results as the value of the nextToken parameter. If there are no more results, the response object's nextToken parameter value is null. Setting a nextToken value that was not returned in your previous results causes an InvalidNextTokenException to occur.
    public var nextToken: Swift.String?
    /// The Amazon Resource Number (ARN) of an AWS OpsWorks for Chef Automate or AWS OpsWorks for Puppet Enterprise server for which you want to show applied tags. For example, arn:aws:opsworks-cm:us-west-2:123456789012:server/test-owcm-server/EXAMPLE-66b0-4196-8274-d1a2bEXAMPLE.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A token that you can use as the value of NextToken in subsequent calls to the API to show more results.
    public var nextToken: Swift.String?
    /// Tags that have been applied to the resource.
    public var tags: [OpsWorksCMClientTypes.Tag]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [OpsWorksCMClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [OpsWorksCMClientTypes.Tag]?
    let nextToken: Swift.String?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([OpsWorksCMClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[OpsWorksCMClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [OpsWorksCMClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OpsWorksCMClientTypes {
    public enum MaintenanceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [MaintenanceStatus] {
            return [
                .failed,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MaintenanceStatus(rawValue: rawValue) ?? MaintenanceStatus.sdkUnknown(rawValue)
        }
    }
}

extension OpsWorksCMClientTypes {
    /// The status of the association or disassociation request. Possible values:
    ///
    /// * SUCCESS: The association or disassociation succeeded.
    ///
    /// * FAILED: The association or disassociation failed.
    ///
    /// * IN_PROGRESS: The association or disassociation is still in progress.
    public enum NodeAssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [NodeAssociationStatus] {
            return [
                .failed,
                .inProgress,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NodeAssociationStatus(rawValue: rawValue) ?? NodeAssociationStatus.sdkUnknown(rawValue)
        }
    }
}

extension ResourceAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested resource cannot be created because it already exists.
public struct ResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error or informational message in response to a CreateServer request that a resource cannot be created because it already exists.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested resource does not exist, or access was denied.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error or informational message that can contain more detail about problems locating or accessing a resource.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RestoreServerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupId = "BackupId"
        case instanceType = "InstanceType"
        case keyPair = "KeyPair"
        case serverName = "ServerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupId = self.backupId {
            try encodeContainer.encode(backupId, forKey: .backupId)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let keyPair = self.keyPair {
            try encodeContainer.encode(keyPair, forKey: .keyPair)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }
}

extension RestoreServerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RestoreServerInput: Swift.Equatable {
    /// The ID of the backup that you want to use to restore a server.
    /// This member is required.
    public var backupId: Swift.String?
    /// The type of instance to restore. Valid values must be specified in the following format: ^([cm][34]|t2).* For example, m5.large. Valid values are m5.large, r5.xlarge, and r5.2xlarge. If you do not specify this parameter, RestoreServer uses the instance type from the specified backup.
    public var instanceType: Swift.String?
    /// The name of the key pair to set on the new EC2 instance. This can be helpful if the administrator no longer has the SSH key.
    public var keyPair: Swift.String?
    /// The name of the server that you want to restore.
    /// This member is required.
    public var serverName: Swift.String?

    public init(
        backupId: Swift.String? = nil,
        instanceType: Swift.String? = nil,
        keyPair: Swift.String? = nil,
        serverName: Swift.String? = nil
    )
    {
        self.backupId = backupId
        self.instanceType = instanceType
        self.keyPair = keyPair
        self.serverName = serverName
    }
}

struct RestoreServerInputBody: Swift.Equatable {
    let backupId: Swift.String?
    let serverName: Swift.String?
    let instanceType: Swift.String?
    let keyPair: Swift.String?
}

extension RestoreServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupId = "BackupId"
        case instanceType = "InstanceType"
        case keyPair = "KeyPair"
        case serverName = "ServerName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupId)
        backupId = backupIdDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let keyPairDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyPair)
        keyPair = keyPairDecoded
    }
}

extension RestoreServerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RestoreServerOutputBody = try responseDecoder.decode(responseBody: data)
            self.server = output.server
        } else {
            self.server = nil
        }
    }
}

public struct RestoreServerOutput: Swift.Equatable {
    /// Describes a configuration management server.
    public var server: OpsWorksCMClientTypes.Server?

    public init(
        server: OpsWorksCMClientTypes.Server? = nil
    )
    {
        self.server = server
    }
}

struct RestoreServerOutputBody: Swift.Equatable {
    let server: OpsWorksCMClientTypes.Server?
}

extension RestoreServerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case server = "Server"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverDecoded = try containerValues.decodeIfPresent(OpsWorksCMClientTypes.Server.self, forKey: .server)
        server = serverDecoded
    }
}

enum RestoreServerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidStateException": return try await InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OpsWorksCMClientTypes.Server: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatePublicIpAddress = "AssociatePublicIpAddress"
        case backupRetentionCount = "BackupRetentionCount"
        case cloudFormationStackArn = "CloudFormationStackArn"
        case createdAt = "CreatedAt"
        case customDomain = "CustomDomain"
        case disableAutomatedBackup = "DisableAutomatedBackup"
        case endpoint = "Endpoint"
        case engine = "Engine"
        case engineAttributes = "EngineAttributes"
        case engineModel = "EngineModel"
        case engineVersion = "EngineVersion"
        case instanceProfileArn = "InstanceProfileArn"
        case instanceType = "InstanceType"
        case keyPair = "KeyPair"
        case maintenanceStatus = "MaintenanceStatus"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case securityGroupIds = "SecurityGroupIds"
        case serverArn = "ServerArn"
        case serverName = "ServerName"
        case serviceRoleArn = "ServiceRoleArn"
        case status = "Status"
        case statusReason = "StatusReason"
        case subnetIds = "SubnetIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatePublicIpAddress = self.associatePublicIpAddress {
            try encodeContainer.encode(associatePublicIpAddress, forKey: .associatePublicIpAddress)
        }
        if let backupRetentionCount = self.backupRetentionCount {
            try encodeContainer.encode(backupRetentionCount, forKey: .backupRetentionCount)
        }
        if let cloudFormationStackArn = self.cloudFormationStackArn {
            try encodeContainer.encode(cloudFormationStackArn, forKey: .cloudFormationStackArn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let customDomain = self.customDomain {
            try encodeContainer.encode(customDomain, forKey: .customDomain)
        }
        if let disableAutomatedBackup = self.disableAutomatedBackup {
            try encodeContainer.encode(disableAutomatedBackup, forKey: .disableAutomatedBackup)
        }
        if let endpoint = self.endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let engine = self.engine {
            try encodeContainer.encode(engine, forKey: .engine)
        }
        if let engineAttributes = engineAttributes {
            var engineAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .engineAttributes)
            for engineattribute0 in engineAttributes {
                try engineAttributesContainer.encode(engineattribute0)
            }
        }
        if let engineModel = self.engineModel {
            try encodeContainer.encode(engineModel, forKey: .engineModel)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let instanceProfileArn = self.instanceProfileArn {
            try encodeContainer.encode(instanceProfileArn, forKey: .instanceProfileArn)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let keyPair = self.keyPair {
            try encodeContainer.encode(keyPair, forKey: .keyPair)
        }
        if let maintenanceStatus = self.maintenanceStatus {
            try encodeContainer.encode(maintenanceStatus.rawValue, forKey: .maintenanceStatus)
        }
        if let preferredBackupWindow = self.preferredBackupWindow {
            try encodeContainer.encode(preferredBackupWindow, forKey: .preferredBackupWindow)
        }
        if let preferredMaintenanceWindow = self.preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for string0 in securityGroupIds {
                try securityGroupIdsContainer.encode(string0)
            }
        }
        if let serverArn = self.serverArn {
            try encodeContainer.encode(serverArn, forKey: .serverArn)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let serviceRoleArn = self.serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for string0 in subnetIds {
                try subnetIdsContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associatePublicIpAddressDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associatePublicIpAddress)
        associatePublicIpAddress = associatePublicIpAddressDecoded
        let backupRetentionCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupRetentionCount)
        backupRetentionCount = backupRetentionCountDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let cloudFormationStackArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudFormationStackArn)
        cloudFormationStackArn = cloudFormationStackArnDecoded
        let customDomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDomain)
        customDomain = customDomainDecoded
        let disableAutomatedBackupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableAutomatedBackup)
        disableAutomatedBackup = disableAutomatedBackupDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineModel)
        engineModel = engineModelDecoded
        let engineAttributesContainer = try containerValues.decodeIfPresent([OpsWorksCMClientTypes.EngineAttribute?].self, forKey: .engineAttributes)
        var engineAttributesDecoded0:[OpsWorksCMClientTypes.EngineAttribute]? = nil
        if let engineAttributesContainer = engineAttributesContainer {
            engineAttributesDecoded0 = [OpsWorksCMClientTypes.EngineAttribute]()
            for structure0 in engineAttributesContainer {
                if let structure0 = structure0 {
                    engineAttributesDecoded0?.append(structure0)
                }
            }
        }
        engineAttributes = engineAttributesDecoded0
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let instanceProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileArn)
        instanceProfileArn = instanceProfileArnDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let keyPairDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyPair)
        keyPair = keyPairDecoded
        let maintenanceStatusDecoded = try containerValues.decodeIfPresent(OpsWorksCMClientTypes.MaintenanceStatus.self, forKey: .maintenanceStatus)
        maintenanceStatus = maintenanceStatusDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let preferredBackupWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredBackupWindow)
        preferredBackupWindow = preferredBackupWindowDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OpsWorksCMClientTypes.ServerStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let serverArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverArn)
        serverArn = serverArnDecoded
    }
}

extension OpsWorksCMClientTypes {
    /// Describes a configuration management server.
    public struct Server: Swift.Equatable {
        /// Associate a public IP address with a server that you are launching.
        public var associatePublicIpAddress: Swift.Bool?
        /// The number of automated backups to keep.
        public var backupRetentionCount: Swift.Int?
        /// The ARN of the CloudFormation stack that was used to create the server.
        public var cloudFormationStackArn: Swift.String?
        /// Time stamp of server creation. Example 2016-07-29T13:38:47.520Z
        public var createdAt: ClientRuntime.Date?
        /// An optional public endpoint of a server, such as https://aws.my-company.com. You cannot access the server by using the Endpoint value if the server has a CustomDomain specified.
        public var customDomain: Swift.String?
        /// Disables automated backups. The number of stored backups is dependent on the value of PreferredBackupCount.
        public var disableAutomatedBackup: Swift.Bool?
        /// A DNS name that can be used to access the engine. Example: myserver-asdfghjkl.us-east-1.opsworks.io. You cannot access the server by using the Endpoint value if the server has a CustomDomain specified.
        public var endpoint: Swift.String?
        /// The engine type of the server. Valid values in this release include ChefAutomate and Puppet.
        public var engine: Swift.String?
        /// The response of a createServer() request returns the master credential to access the server in EngineAttributes. These credentials are not stored by AWS OpsWorks CM; they are returned only as part of the result of createServer(). Attributes returned in a createServer response for Chef
        ///
        /// * CHEF_AUTOMATE_PIVOTAL_KEY: A base64-encoded RSA private key that is generated by AWS OpsWorks for Chef Automate. This private key is required to access the Chef API.
        ///
        /// * CHEF_STARTER_KIT: A base64-encoded ZIP file. The ZIP file contains a Chef starter kit, which includes a README, a configuration file, and the required RSA private key. Save this file, unzip it, and then change to the directory where you've unzipped the file contents. From this directory, you can run Knife commands.
        ///
        ///
        /// Attributes returned in a createServer response for Puppet
        ///
        /// * PUPPET_STARTER_KIT: A base64-encoded ZIP file. The ZIP file contains a Puppet starter kit, including a README and a required private key. Save this file, unzip it, and then change to the directory where you've unzipped the file contents.
        ///
        /// * PUPPET_ADMIN_PASSWORD: An administrator password that you can use to sign in to the Puppet Enterprise console after the server is online.
        public var engineAttributes: [OpsWorksCMClientTypes.EngineAttribute]?
        /// The engine model of the server. Valid values in this release include Monolithic for Puppet and Single for Chef.
        public var engineModel: Swift.String?
        /// The engine version of the server. For a Chef server, the valid value for EngineVersion is currently 2. For a Puppet server, specify either 2019 or 2017.
        public var engineVersion: Swift.String?
        /// The instance profile ARN of the server.
        public var instanceProfileArn: Swift.String?
        /// The instance type for the server, as specified in the CloudFormation stack. This might not be the same instance type that is shown in the EC2 console.
        public var instanceType: Swift.String?
        /// The key pair associated with the server.
        public var keyPair: Swift.String?
        /// The status of the most recent server maintenance run. Shows SUCCESS or FAILED.
        public var maintenanceStatus: OpsWorksCMClientTypes.MaintenanceStatus?
        /// The preferred backup period specified for the server.
        public var preferredBackupWindow: Swift.String?
        /// The preferred maintenance period specified for the server.
        public var preferredMaintenanceWindow: Swift.String?
        /// The security group IDs for the server, as specified in the CloudFormation stack. These might not be the same security groups that are shown in the EC2 console.
        public var securityGroupIds: [Swift.String]?
        /// The ARN of the server.
        public var serverArn: Swift.String?
        /// The name of the server.
        public var serverName: Swift.String?
        /// The service role ARN used to create the server.
        public var serviceRoleArn: Swift.String?
        /// The server's status. This field displays the states of actions in progress, such as creating, running, or backing up the server, as well as the server's health state.
        public var status: OpsWorksCMClientTypes.ServerStatus?
        /// Depending on the server status, this field has either a human-readable message (such as a create or backup error), or an escaped block of JSON (used for health check results).
        public var statusReason: Swift.String?
        /// The subnet IDs specified in a CreateServer request.
        public var subnetIds: [Swift.String]?

        public init(
            associatePublicIpAddress: Swift.Bool? = nil,
            backupRetentionCount: Swift.Int? = nil,
            cloudFormationStackArn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            customDomain: Swift.String? = nil,
            disableAutomatedBackup: Swift.Bool? = nil,
            endpoint: Swift.String? = nil,
            engine: Swift.String? = nil,
            engineAttributes: [OpsWorksCMClientTypes.EngineAttribute]? = nil,
            engineModel: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            instanceProfileArn: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            keyPair: Swift.String? = nil,
            maintenanceStatus: OpsWorksCMClientTypes.MaintenanceStatus? = nil,
            preferredBackupWindow: Swift.String? = nil,
            preferredMaintenanceWindow: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            serverArn: Swift.String? = nil,
            serverName: Swift.String? = nil,
            serviceRoleArn: Swift.String? = nil,
            status: OpsWorksCMClientTypes.ServerStatus? = nil,
            statusReason: Swift.String? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.associatePublicIpAddress = associatePublicIpAddress
            self.backupRetentionCount = backupRetentionCount
            self.cloudFormationStackArn = cloudFormationStackArn
            self.createdAt = createdAt
            self.customDomain = customDomain
            self.disableAutomatedBackup = disableAutomatedBackup
            self.endpoint = endpoint
            self.engine = engine
            self.engineAttributes = engineAttributes
            self.engineModel = engineModel
            self.engineVersion = engineVersion
            self.instanceProfileArn = instanceProfileArn
            self.instanceType = instanceType
            self.keyPair = keyPair
            self.maintenanceStatus = maintenanceStatus
            self.preferredBackupWindow = preferredBackupWindow
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.securityGroupIds = securityGroupIds
            self.serverArn = serverArn
            self.serverName = serverName
            self.serviceRoleArn = serviceRoleArn
            self.status = status
            self.statusReason = statusReason
            self.subnetIds = subnetIds
        }
    }

}

extension OpsWorksCMClientTypes.ServerEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case logUrl = "LogUrl"
        case message = "Message"
        case serverName = "ServerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let logUrl = self.logUrl {
            try encodeContainer.encode(logUrl, forKey: .logUrl)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let logUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logUrl)
        logUrl = logUrlDecoded
    }
}

extension OpsWorksCMClientTypes {
    /// An event that is related to the server, such as the start of maintenance or backup.
    public struct ServerEvent: Swift.Equatable {
        /// The time when the event occurred.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon S3 URL of the event's log file.
        public var logUrl: Swift.String?
        /// A human-readable informational or status message.
        public var message: Swift.String?
        /// The name of the server on or for which the event occurred.
        public var serverName: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            logUrl: Swift.String? = nil,
            message: Swift.String? = nil,
            serverName: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.logUrl = logUrl
            self.message = message
            self.serverName = serverName
        }
    }

}

extension OpsWorksCMClientTypes {
    public enum ServerStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case backingUp
        case connectionLost
        case creating
        case deleting
        case failed
        case healthy
        case modifying
        case restoring
        case running
        case setup
        case terminated
        case underMaintenance
        case unhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [ServerStatus] {
            return [
                .backingUp,
                .connectionLost,
                .creating,
                .deleting,
                .failed,
                .healthy,
                .modifying,
                .restoring,
                .running,
                .setup,
                .terminated,
                .underMaintenance,
                .unhealthy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .backingUp: return "BACKING_UP"
            case .connectionLost: return "CONNECTION_LOST"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .healthy: return "HEALTHY"
            case .modifying: return "MODIFYING"
            case .restoring: return "RESTORING"
            case .running: return "RUNNING"
            case .setup: return "SETUP"
            case .terminated: return "TERMINATED"
            case .underMaintenance: return "UNDER_MAINTENANCE"
            case .unhealthy: return "UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServerStatus(rawValue: rawValue) ?? ServerStatus.sdkUnknown(rawValue)
        }
    }
}

extension StartMaintenanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineAttributes = "EngineAttributes"
        case serverName = "ServerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engineAttributes = engineAttributes {
            var engineAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .engineAttributes)
            for engineattribute0 in engineAttributes {
                try engineAttributesContainer.encode(engineattribute0)
            }
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }
}

extension StartMaintenanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartMaintenanceInput: Swift.Equatable {
    /// Engine attributes that are specific to the server on which you want to run maintenance. Attributes accepted in a StartMaintenance request for Chef
    ///
    /// * CHEF_MAJOR_UPGRADE: If a Chef Automate server is eligible for upgrade to Chef Automate 2, add this engine attribute to a StartMaintenance request and set the value to true to upgrade the server to Chef Automate 2. For more information, see [Upgrade an AWS OpsWorks for Chef Automate Server to Chef Automate 2](https://docs.aws.amazon.com/opsworks/latest/userguide/opscm-a2upgrade.html).
    public var engineAttributes: [OpsWorksCMClientTypes.EngineAttribute]?
    /// The name of the server on which to run maintenance.
    /// This member is required.
    public var serverName: Swift.String?

    public init(
        engineAttributes: [OpsWorksCMClientTypes.EngineAttribute]? = nil,
        serverName: Swift.String? = nil
    )
    {
        self.engineAttributes = engineAttributes
        self.serverName = serverName
    }
}

struct StartMaintenanceInputBody: Swift.Equatable {
    let serverName: Swift.String?
    let engineAttributes: [OpsWorksCMClientTypes.EngineAttribute]?
}

extension StartMaintenanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineAttributes = "EngineAttributes"
        case serverName = "ServerName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let engineAttributesContainer = try containerValues.decodeIfPresent([OpsWorksCMClientTypes.EngineAttribute?].self, forKey: .engineAttributes)
        var engineAttributesDecoded0:[OpsWorksCMClientTypes.EngineAttribute]? = nil
        if let engineAttributesContainer = engineAttributesContainer {
            engineAttributesDecoded0 = [OpsWorksCMClientTypes.EngineAttribute]()
            for structure0 in engineAttributesContainer {
                if let structure0 = structure0 {
                    engineAttributesDecoded0?.append(structure0)
                }
            }
        }
        engineAttributes = engineAttributesDecoded0
    }
}

extension StartMaintenanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartMaintenanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.server = output.server
        } else {
            self.server = nil
        }
    }
}

public struct StartMaintenanceOutput: Swift.Equatable {
    /// Contains the response to a StartMaintenance request.
    public var server: OpsWorksCMClientTypes.Server?

    public init(
        server: OpsWorksCMClientTypes.Server? = nil
    )
    {
        self.server = server
    }
}

struct StartMaintenanceOutputBody: Swift.Equatable {
    let server: OpsWorksCMClientTypes.Server?
}

extension StartMaintenanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case server = "Server"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverDecoded = try containerValues.decodeIfPresent(OpsWorksCMClientTypes.Server.self, forKey: .server)
        server = serverDecoded
    }
}

enum StartMaintenanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidStateException": return try await InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OpsWorksCMClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension OpsWorksCMClientTypes {
    /// A map that contains tag keys and tag values to attach to an AWS OpsWorks for Chef Automate or AWS OpsWorks for Puppet Enterprise server. Leading and trailing white spaces are trimmed from both the key and value. A maximum of 50 user-applied tags is allowed for tag-supported AWS OpsWorks-CM resources.
    public struct Tag: Swift.Equatable {
        /// A tag key, such as Stage or Name. A tag key cannot be empty. The key can be a maximum of 127 characters, and can contain only Unicode letters, numbers, or separators, or the following special characters: + - = . _ : /
        /// This member is required.
        public var key: Swift.String?
        /// An optional tag value, such as Production or test-owcm-server. The value can be a maximum of 255 characters, and contain only Unicode letters, numbers, or separators, or the following special characters: + - = . _ : /
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Number (ARN) of a resource to which you want to apply tags. For example, arn:aws:opsworks-cm:us-west-2:123456789012:server/test-owcm-server/EXAMPLE-66b0-4196-8274-d1a2bEXAMPLE.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A map that contains tag keys and tag values to attach to AWS OpsWorks-CM servers or backups.
    ///
    /// * The key cannot be empty.
    ///
    /// * The key can be a maximum of 127 characters, and can contain only Unicode letters, numbers, or separators, or the following special characters: + - = . _ : /
    ///
    /// * The value can be a maximum 255 characters, and contain only Unicode letters, numbers, or separators, or the following special characters: + - = . _ : /
    ///
    /// * Leading and trailing white spaces are trimmed from both the key and value.
    ///
    /// * A maximum of 50 user-applied tags is allowed for any AWS OpsWorks-CM server or backup.
    /// This member is required.
    public var tags: [OpsWorksCMClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [OpsWorksCMClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [OpsWorksCMClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([OpsWorksCMClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[OpsWorksCMClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [OpsWorksCMClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidStateException": return try await InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Number (ARN) of a resource from which you want to remove tags. For example, arn:aws:opsworks-cm:us-west-2:123456789012:server/test-owcm-server/EXAMPLE-66b0-4196-8274-d1a2bEXAMPLE.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of tags that you want to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidStateException": return try await InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateServerEngineAttributesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case attributeValue = "AttributeValue"
        case serverName = "ServerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = self.attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let attributeValue = self.attributeValue {
            try encodeContainer.encode(attributeValue, forKey: .attributeValue)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }
}

extension UpdateServerEngineAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateServerEngineAttributesInput: Swift.Equatable {
    /// The name of the engine attribute to update.
    /// This member is required.
    public var attributeName: Swift.String?
    /// The value to set for the attribute.
    public var attributeValue: Swift.String?
    /// The name of the server to update.
    /// This member is required.
    public var serverName: Swift.String?

    public init(
        attributeName: Swift.String? = nil,
        attributeValue: Swift.String? = nil,
        serverName: Swift.String? = nil
    )
    {
        self.attributeName = attributeName
        self.attributeValue = attributeValue
        self.serverName = serverName
    }
}

struct UpdateServerEngineAttributesInputBody: Swift.Equatable {
    let serverName: Swift.String?
    let attributeName: Swift.String?
    let attributeValue: Swift.String?
}

extension UpdateServerEngineAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case attributeValue = "AttributeValue"
        case serverName = "ServerName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let attributeValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeValue)
        attributeValue = attributeValueDecoded
    }
}

extension UpdateServerEngineAttributesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateServerEngineAttributesOutputBody = try responseDecoder.decode(responseBody: data)
            self.server = output.server
        } else {
            self.server = nil
        }
    }
}

public struct UpdateServerEngineAttributesOutput: Swift.Equatable {
    /// Contains the response to an UpdateServerEngineAttributes request.
    public var server: OpsWorksCMClientTypes.Server?

    public init(
        server: OpsWorksCMClientTypes.Server? = nil
    )
    {
        self.server = server
    }
}

struct UpdateServerEngineAttributesOutputBody: Swift.Equatable {
    let server: OpsWorksCMClientTypes.Server?
}

extension UpdateServerEngineAttributesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case server = "Server"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverDecoded = try containerValues.decodeIfPresent(OpsWorksCMClientTypes.Server.self, forKey: .server)
        server = serverDecoded
    }
}

enum UpdateServerEngineAttributesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidStateException": return try await InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateServerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupRetentionCount = "BackupRetentionCount"
        case disableAutomatedBackup = "DisableAutomatedBackup"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case serverName = "ServerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupRetentionCount = self.backupRetentionCount {
            try encodeContainer.encode(backupRetentionCount, forKey: .backupRetentionCount)
        }
        if let disableAutomatedBackup = self.disableAutomatedBackup {
            try encodeContainer.encode(disableAutomatedBackup, forKey: .disableAutomatedBackup)
        }
        if let preferredBackupWindow = self.preferredBackupWindow {
            try encodeContainer.encode(preferredBackupWindow, forKey: .preferredBackupWindow)
        }
        if let preferredMaintenanceWindow = self.preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }
}

extension UpdateServerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateServerInput: Swift.Equatable {
    /// Sets the number of automated backups that you want to keep.
    public var backupRetentionCount: Swift.Int?
    /// Setting DisableAutomatedBackup to true disables automated or scheduled backups. Automated backups are enabled by default.
    public var disableAutomatedBackup: Swift.Bool?
    /// DDD:HH:MM (weekly start time) or HH:MM (daily start time). Time windows always use coordinated universal time (UTC). Valid strings for day of week (DDD) are: Mon, Tue, Wed, Thr, Fri, Sat, or Sun.
    public var preferredBackupWindow: Swift.String?
    /// DDD:HH:MM (weekly start time) or HH:MM (daily start time). Time windows always use coordinated universal time (UTC). Valid strings for day of week (DDD) are: Mon, Tue, Wed, Thr, Fri, Sat, or Sun.
    public var preferredMaintenanceWindow: Swift.String?
    /// The name of the server to update.
    /// This member is required.
    public var serverName: Swift.String?

    public init(
        backupRetentionCount: Swift.Int? = nil,
        disableAutomatedBackup: Swift.Bool? = nil,
        preferredBackupWindow: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        serverName: Swift.String? = nil
    )
    {
        self.backupRetentionCount = backupRetentionCount
        self.disableAutomatedBackup = disableAutomatedBackup
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.serverName = serverName
    }
}

struct UpdateServerInputBody: Swift.Equatable {
    let disableAutomatedBackup: Swift.Bool?
    let backupRetentionCount: Swift.Int?
    let serverName: Swift.String?
    let preferredMaintenanceWindow: Swift.String?
    let preferredBackupWindow: Swift.String?
}

extension UpdateServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupRetentionCount = "BackupRetentionCount"
        case disableAutomatedBackup = "DisableAutomatedBackup"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case serverName = "ServerName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let disableAutomatedBackupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableAutomatedBackup)
        disableAutomatedBackup = disableAutomatedBackupDecoded
        let backupRetentionCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupRetentionCount)
        backupRetentionCount = backupRetentionCountDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let preferredBackupWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredBackupWindow)
        preferredBackupWindow = preferredBackupWindowDecoded
    }
}

extension UpdateServerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateServerOutputBody = try responseDecoder.decode(responseBody: data)
            self.server = output.server
        } else {
            self.server = nil
        }
    }
}

public struct UpdateServerOutput: Swift.Equatable {
    /// Contains the response to a UpdateServer request.
    public var server: OpsWorksCMClientTypes.Server?

    public init(
        server: OpsWorksCMClientTypes.Server? = nil
    )
    {
        self.server = server
    }
}

struct UpdateServerOutputBody: Swift.Equatable {
    let server: OpsWorksCMClientTypes.Server?
}

extension UpdateServerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case server = "Server"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverDecoded = try containerValues.decodeIfPresent(OpsWorksCMClientTypes.Server.self, forKey: .server)
        server = serverDecoded
    }
}

enum UpdateServerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidStateException": return try await InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// One or more of the provided request parameters are not valid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error or informational message that can contain more detail about a validation failure.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
