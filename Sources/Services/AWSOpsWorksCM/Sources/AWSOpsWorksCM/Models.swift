//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError

extension OpsWorksCMClientTypes {
    /// Stores account attributes.
    public struct AccountAttribute {
        /// The maximum allowed value.
        public var maximum: Swift.Int?
        /// The attribute name. The following are supported attribute names.
        ///
        /// * ServerLimit: The number of current servers/maximum number of servers allowed. By default, you can have a maximum of 10 servers.
        ///
        /// * ManualBackupLimit: The number of current manual backups/maximum number of backups allowed. By default, you can have a maximum of 50 manual backups saved.
        public var name: Swift.String?
        /// The current usage, such as the current number of servers that are associated with the account.
        public var used: Swift.Int?

        public init(
            maximum: Swift.Int? = nil,
            name: Swift.String? = nil,
            used: Swift.Int? = nil
        )
        {
            self.maximum = maximum
            self.name = name
            self.used = used
        }
    }

}

/// The resource is in a state that does not allow you to perform a specified action.
public struct InvalidStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error or informational message that provides more detail if a resource is in a state that is not valid for performing a specified action.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidStateException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The requested resource does not exist, or access was denied.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error or informational message that can contain more detail about problems locating or accessing a resource.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// One or more of the provided request parameters are not valid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error or informational message that can contain more detail about a validation failure.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension OpsWorksCMClientTypes {
    /// A name and value pair that is specific to the engine of the server.
    public struct EngineAttribute {
        /// The name of the engine attribute.
        public var name: Swift.String?
        /// The value of the engine attribute.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension OpsWorksCMClientTypes.EngineAttribute: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EngineAttribute(name: \(Swift.String(describing: name)), value: \"CONTENT_REDACTED\")"}
}

public struct AssociateNodeInput {
    /// Engine attributes used for associating the node. Attributes accepted in a AssociateNode request for Chef
    ///
    /// * CHEF_ORGANIZATION: The Chef organization with which the node is associated. By default only one organization named default can exist.
    ///
    /// * CHEF_NODE_PUBLIC_KEY: A PEM-formatted public key. This key is required for the chef-client agent to access the Chef API.
    ///
    ///
    /// Attributes accepted in a AssociateNode request for Puppet
    ///
    /// * PUPPET_NODE_CSR: A PEM-formatted certificate-signing request (CSR) that is created by the node.
    /// This member is required.
    public var engineAttributes: [OpsWorksCMClientTypes.EngineAttribute]?
    /// The name of the node.
    /// This member is required.
    public var nodeName: Swift.String?
    /// The name of the server with which to associate the node.
    /// This member is required.
    public var serverName: Swift.String?

    public init(
        engineAttributes: [OpsWorksCMClientTypes.EngineAttribute]? = nil,
        nodeName: Swift.String? = nil,
        serverName: Swift.String? = nil
    )
    {
        self.engineAttributes = engineAttributes
        self.nodeName = nodeName
        self.serverName = serverName
    }
}

public struct AssociateNodeOutput {
    /// Contains a token which can be passed to the DescribeNodeAssociationStatus API call to get the status of the association request.
    public var nodeAssociationStatusToken: Swift.String?

    public init(
        nodeAssociationStatusToken: Swift.String? = nil
    )
    {
        self.nodeAssociationStatusToken = nodeAssociationStatusToken
    }
}

extension OpsWorksCMClientTypes {

    public enum BackupType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case automated
        case manual
        case sdkUnknown(Swift.String)

        public static var allCases: [BackupType] {
            return [
                .automated,
                .manual
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .automated: return "AUTOMATED"
            case .manual: return "MANUAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpsWorksCMClientTypes {

    public enum BackupStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deleting
        case failed
        case inProgress
        case ok
        case sdkUnknown(Swift.String)

        public static var allCases: [BackupStatus] {
            return [
                .deleting,
                .failed,
                .inProgress,
                .ok
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .ok: return "OK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpsWorksCMClientTypes {
    /// Describes a single backup.
    public struct Backup {
        /// The ARN of the backup.
        public var backupArn: Swift.String?
        /// The generated ID of the backup. Example: myServerName-yyyyMMddHHmmssSSS
        public var backupId: Swift.String?
        /// The backup type. Valid values are automated or manual.
        public var backupType: OpsWorksCMClientTypes.BackupType?
        /// The time stamp when the backup was created in the database. Example: 2016-07-29T13:38:47.520Z
        public var createdAt: Foundation.Date?
        /// A user-provided description for a manual backup. This field is empty for automated backups.
        public var description: Swift.String?
        /// The engine type that is obtained from the server when the backup is created.
        public var engine: Swift.String?
        /// The engine model that is obtained from the server when the backup is created.
        public var engineModel: Swift.String?
        /// The engine version that is obtained from the server when the backup is created.
        public var engineVersion: Swift.String?
        /// The EC2 instance profile ARN that is obtained from the server when the backup is created. Because this value is stored, you are not required to provide the InstanceProfileArn again if you restore a backup.
        public var instanceProfileArn: Swift.String?
        /// The instance type that is obtained from the server when the backup is created.
        public var instanceType: Swift.String?
        /// The key pair that is obtained from the server when the backup is created.
        public var keyPair: Swift.String?
        /// The preferred backup period that is obtained from the server when the backup is created.
        public var preferredBackupWindow: Swift.String?
        /// The preferred maintenance period that is obtained from the server when the backup is created.
        public var preferredMaintenanceWindow: Swift.String?
        /// This field is deprecated and is no longer used.
        @available(*, deprecated)
        public var s3DataSize: Swift.Int?
        /// This field is deprecated and is no longer used.
        @available(*, deprecated)
        public var s3DataUrl: Swift.String?
        /// The Amazon S3 URL of the backup's log file.
        public var s3LogUrl: Swift.String?
        /// The security group IDs that are obtained from the server when the backup is created.
        public var securityGroupIds: [Swift.String]?
        /// The name of the server from which the backup was made.
        public var serverName: Swift.String?
        /// The service role ARN that is obtained from the server when the backup is created.
        public var serviceRoleArn: Swift.String?
        /// The status of a backup while in progress.
        public var status: OpsWorksCMClientTypes.BackupStatus?
        /// An informational message about backup status.
        public var statusDescription: Swift.String?
        /// The subnet IDs that are obtained from the server when the backup is created.
        public var subnetIds: [Swift.String]?
        /// The version of AWS OpsWorks CM-specific tools that is obtained from the server when the backup is created.
        public var toolsVersion: Swift.String?
        /// The IAM user ARN of the requester for manual backups. This field is empty for automated backups.
        public var userArn: Swift.String?

        public init(
            backupArn: Swift.String? = nil,
            backupId: Swift.String? = nil,
            backupType: OpsWorksCMClientTypes.BackupType? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            engine: Swift.String? = nil,
            engineModel: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            instanceProfileArn: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            keyPair: Swift.String? = nil,
            preferredBackupWindow: Swift.String? = nil,
            preferredMaintenanceWindow: Swift.String? = nil,
            s3DataSize: Swift.Int? = nil,
            s3DataUrl: Swift.String? = nil,
            s3LogUrl: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            serverName: Swift.String? = nil,
            serviceRoleArn: Swift.String? = nil,
            status: OpsWorksCMClientTypes.BackupStatus? = nil,
            statusDescription: Swift.String? = nil,
            subnetIds: [Swift.String]? = nil,
            toolsVersion: Swift.String? = nil,
            userArn: Swift.String? = nil
        )
        {
            self.backupArn = backupArn
            self.backupId = backupId
            self.backupType = backupType
            self.createdAt = createdAt
            self.description = description
            self.engine = engine
            self.engineModel = engineModel
            self.engineVersion = engineVersion
            self.instanceProfileArn = instanceProfileArn
            self.instanceType = instanceType
            self.keyPair = keyPair
            self.preferredBackupWindow = preferredBackupWindow
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.s3DataSize = s3DataSize
            self.s3DataUrl = s3DataUrl
            self.s3LogUrl = s3LogUrl
            self.securityGroupIds = securityGroupIds
            self.serverName = serverName
            self.serviceRoleArn = serviceRoleArn
            self.status = status
            self.statusDescription = statusDescription
            self.subnetIds = subnetIds
            self.toolsVersion = toolsVersion
            self.userArn = userArn
        }
    }

}

/// The limit of servers or backups has been reached.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error or informational message that the maximum allowed number of servers or backups has been exceeded.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension OpsWorksCMClientTypes {
    /// A map that contains tag keys and tag values to attach to an AWS OpsWorks for Chef Automate or AWS OpsWorks for Puppet Enterprise server. Leading and trailing white spaces are trimmed from both the key and value. A maximum of 50 user-applied tags is allowed for tag-supported AWS OpsWorks-CM resources.
    public struct Tag {
        /// A tag key, such as Stage or Name. A tag key cannot be empty. The key can be a maximum of 127 characters, and can contain only Unicode letters, numbers, or separators, or the following special characters: + - = . _ : /
        /// This member is required.
        public var key: Swift.String?
        /// An optional tag value, such as Production or test-owcm-server. The value can be a maximum of 255 characters, and contain only Unicode letters, numbers, or separators, or the following special characters: + - = . _ : /
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct CreateBackupInput {
    /// A user-defined description of the backup.
    public var description: Swift.String?
    /// The name of the server that you want to back up.
    /// This member is required.
    public var serverName: Swift.String?
    /// A map that contains tag keys and tag values to attach to an AWS OpsWorks-CM server backup.
    ///
    /// * The key cannot be empty.
    ///
    /// * The key can be a maximum of 127 characters, and can contain only Unicode letters, numbers, or separators, or the following special characters: + - = . _ : /
    ///
    /// * The value can be a maximum 255 characters, and contain only Unicode letters, numbers, or separators, or the following special characters: + - = . _ : /
    ///
    /// * Leading and trailing white spaces are trimmed from both the key and value.
    ///
    /// * A maximum of 50 user-applied tags is allowed for tag-supported AWS OpsWorks-CM resources.
    public var tags: [OpsWorksCMClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        serverName: Swift.String? = nil,
        tags: [OpsWorksCMClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.serverName = serverName
        self.tags = tags
    }
}

public struct CreateBackupOutput {
    /// Backup created by request.
    public var backup: OpsWorksCMClientTypes.Backup?

    public init(
        backup: OpsWorksCMClientTypes.Backup? = nil
    )
    {
        self.backup = backup
    }
}

/// The requested resource cannot be created because it already exists.
public struct ResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error or informational message in response to a CreateServer request that a resource cannot be created because it already exists.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateServerInput {
    /// Associate a public IP address with a server that you are launching. Valid values are true or false. The default value is true.
    public var associatePublicIpAddress: Swift.Bool?
    /// If you specify this field, AWS OpsWorks CM creates the server by using the backup represented by BackupId.
    public var backupId: Swift.String?
    /// The number of automated backups that you want to keep. Whenever a new backup is created, AWS OpsWorks CM deletes the oldest backups if this number is exceeded. The default value is 1.
    public var backupRetentionCount: Swift.Int?
    /// A PEM-formatted HTTPS certificate. The value can be be a single, self-signed certificate, or a certificate chain. If you specify a custom certificate, you must also specify values for CustomDomain and CustomPrivateKey. The following are requirements for the CustomCertificate value:
    ///
    /// * You can provide either a self-signed, custom certificate, or the full certificate chain.
    ///
    /// * The certificate must be a valid X509 certificate, or a certificate chain in PEM format.
    ///
    /// * The certificate must be valid at the time of upload. A certificate can't be used before its validity period begins (the certificate's NotBefore date), or after it expires (the certificate's NotAfter date).
    ///
    /// * The certificate’s common name or subject alternative names (SANs), if present, must match the value of CustomDomain.
    ///
    /// * The certificate must match the value of CustomPrivateKey.
    public var customCertificate: Swift.String?
    /// An optional public endpoint of a server, such as https://aws.my-company.com. To access the server, create a CNAME DNS record in your preferred DNS service that points the custom domain to the endpoint that is generated when the server is created (the value of the CreateServer Endpoint attribute). You cannot access the server by using the generated Endpoint value if the server is using a custom domain. If you specify a custom domain, you must also specify values for CustomCertificate and CustomPrivateKey.
    public var customDomain: Swift.String?
    /// A private key in PEM format for connecting to the server by using HTTPS. The private key must not be encrypted; it cannot be protected by a password or passphrase. If you specify a custom private key, you must also specify values for CustomDomain and CustomCertificate.
    public var customPrivateKey: Swift.String?
    /// Enable or disable scheduled backups. Valid values are true or false. The default value is true.
    public var disableAutomatedBackup: Swift.Bool?
    /// The configuration management engine to use. Valid values include ChefAutomate and Puppet.
    /// This member is required.
    public var engine: Swift.String?
    /// Optional engine attributes on a specified server. Attributes accepted in a Chef createServer request:
    ///
    /// * CHEF_AUTOMATE_PIVOTAL_KEY: A base64-encoded RSA public key. The corresponding private key is required to access the Chef API. When no CHEF_AUTOMATE_PIVOTAL_KEY is set, a private key is generated and returned in the response.
    ///
    /// * CHEF_AUTOMATE_ADMIN_PASSWORD: The password for the administrative user in the Chef Automate web-based dashboard. The password length is a minimum of eight characters, and a maximum of 32. The password can contain letters, numbers, and special characters (!/@#$%^&+=_). The password must contain at least one lower case letter, one upper case letter, one number, and one special character. When no CHEF_AUTOMATE_ADMIN_PASSWORD is set, one is generated and returned in the response.
    ///
    ///
    /// Attributes accepted in a Puppet createServer request:
    ///
    /// * PUPPET_ADMIN_PASSWORD: To work with the Puppet Enterprise console, a password must use ASCII characters.
    ///
    /// * PUPPET_R10K_REMOTE: The r10k remote is the URL of your control repository (for example, ssh://git@your.git-repo.com:user/control-repo.git). Specifying an r10k remote opens TCP port 8170.
    ///
    /// * PUPPET_R10K_PRIVATE_KEY: If you are using a private Git repository, add PUPPET_R10K_PRIVATE_KEY to specify a PEM-encoded private SSH key.
    public var engineAttributes: [OpsWorksCMClientTypes.EngineAttribute]?
    /// The engine model of the server. Valid values in this release include Monolithic for Puppet and Single for Chef.
    public var engineModel: Swift.String?
    /// The major release version of the engine that you want to use. For a Chef server, the valid value for EngineVersion is currently 2. For a Puppet server, valid values are 2019 or 2017.
    public var engineVersion: Swift.String?
    /// The ARN of the instance profile that your Amazon EC2 instances use. Although the AWS OpsWorks console typically creates the instance profile for you, if you are using API commands instead, run the service-role-creation.yaml AWS CloudFormation template, located at https://s3.amazonaws.com/opsworks-cm-us-east-1-prod-default-assets/misc/opsworks-cm-roles.yaml. This template creates a CloudFormation stack that includes the instance profile you need.
    /// This member is required.
    public var instanceProfileArn: Swift.String?
    /// The Amazon EC2 instance type to use. For example, m5.large.
    /// This member is required.
    public var instanceType: Swift.String?
    /// The Amazon EC2 key pair to set for the instance. This parameter is optional; if desired, you may specify this parameter to connect to your instances by using SSH.
    public var keyPair: Swift.String?
    /// The start time for a one-hour period during which AWS OpsWorks CM backs up application-level data on your server if automated backups are enabled. Valid values must be specified in one of the following formats:
    ///
    /// * HH:MM for daily backups
    ///
    /// * DDD:HH:MM for weekly backups
    ///
    ///
    /// MM must be specified as 00. The specified time is in coordinated universal time (UTC). The default value is a random, daily start time. Example: 08:00, which represents a daily start time of 08:00 UTC. Example: Mon:08:00, which represents a start time of every Monday at 08:00 UTC. (8:00 a.m.)
    public var preferredBackupWindow: Swift.String?
    /// The start time for a one-hour period each week during which AWS OpsWorks CM performs maintenance on the instance. Valid values must be specified in the following format: DDD:HH:MM. MM must be specified as 00. The specified time is in coordinated universal time (UTC). The default value is a random one-hour period on Tuesday, Wednesday, or Friday. See TimeWindowDefinition for more information. Example: Mon:08:00, which represents a start time of every Monday at 08:00 UTC. (8:00 a.m.)
    public var preferredMaintenanceWindow: Swift.String?
    /// A list of security group IDs to attach to the Amazon EC2 instance. If you add this parameter, the specified security groups must be within the VPC that is specified by SubnetIds. If you do not specify this parameter, AWS OpsWorks CM creates one new security group that uses TCP ports 22 and 443, open to 0.0.0.0/0 (everyone).
    public var securityGroupIds: [Swift.String]?
    /// The name of the server. The server name must be unique within your AWS account, within each region. Server names must start with a letter; then letters, numbers, or hyphens (-) are allowed, up to a maximum of 40 characters.
    /// This member is required.
    public var serverName: Swift.String?
    /// The service role that the AWS OpsWorks CM service backend uses to work with your account. Although the AWS OpsWorks management console typically creates the service role for you, if you are using the AWS CLI or API commands, run the service-role-creation.yaml AWS CloudFormation template, located at https://s3.amazonaws.com/opsworks-cm-us-east-1-prod-default-assets/misc/opsworks-cm-roles.yaml. This template creates a CloudFormation stack that includes the service role and instance profile that you need.
    /// This member is required.
    public var serviceRoleArn: Swift.String?
    /// The IDs of subnets in which to launch the server EC2 instance. Amazon EC2-Classic customers: This field is required. All servers must run within a VPC. The VPC must have "Auto Assign Public IP" enabled. EC2-VPC customers: This field is optional. If you do not specify subnet IDs, your EC2 instances are created in a default subnet that is selected by Amazon EC2. If you specify subnet IDs, the VPC must have "Auto Assign Public IP" enabled. For more information about supported Amazon EC2 platforms, see [Supported Platforms](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-supported-platforms.html).
    public var subnetIds: [Swift.String]?
    /// A map that contains tag keys and tag values to attach to an AWS OpsWorks for Chef Automate or AWS OpsWorks for Puppet Enterprise server.
    ///
    /// * The key cannot be empty.
    ///
    /// * The key can be a maximum of 127 characters, and can contain only Unicode letters, numbers, or separators, or the following special characters: + - = . _ : / @
    ///
    /// * The value can be a maximum 255 characters, and contain only Unicode letters, numbers, or separators, or the following special characters: + - = . _ : / @
    ///
    /// * Leading and trailing white spaces are trimmed from both the key and value.
    ///
    /// * A maximum of 50 user-applied tags is allowed for any AWS OpsWorks-CM server.
    public var tags: [OpsWorksCMClientTypes.Tag]?

    public init(
        associatePublicIpAddress: Swift.Bool? = nil,
        backupId: Swift.String? = nil,
        backupRetentionCount: Swift.Int? = nil,
        customCertificate: Swift.String? = nil,
        customDomain: Swift.String? = nil,
        customPrivateKey: Swift.String? = nil,
        disableAutomatedBackup: Swift.Bool? = nil,
        engine: Swift.String? = nil,
        engineAttributes: [OpsWorksCMClientTypes.EngineAttribute]? = nil,
        engineModel: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        instanceProfileArn: Swift.String? = nil,
        instanceType: Swift.String? = nil,
        keyPair: Swift.String? = nil,
        preferredBackupWindow: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        serverName: Swift.String? = nil,
        serviceRoleArn: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [OpsWorksCMClientTypes.Tag]? = nil
    )
    {
        self.associatePublicIpAddress = associatePublicIpAddress
        self.backupId = backupId
        self.backupRetentionCount = backupRetentionCount
        self.customCertificate = customCertificate
        self.customDomain = customDomain
        self.customPrivateKey = customPrivateKey
        self.disableAutomatedBackup = disableAutomatedBackup
        self.engine = engine
        self.engineAttributes = engineAttributes
        self.engineModel = engineModel
        self.engineVersion = engineVersion
        self.instanceProfileArn = instanceProfileArn
        self.instanceType = instanceType
        self.keyPair = keyPair
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.securityGroupIds = securityGroupIds
        self.serverName = serverName
        self.serviceRoleArn = serviceRoleArn
        self.subnetIds = subnetIds
        self.tags = tags
    }
}

extension CreateServerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateServerInput(associatePublicIpAddress: \(Swift.String(describing: associatePublicIpAddress)), backupId: \(Swift.String(describing: backupId)), backupRetentionCount: \(Swift.String(describing: backupRetentionCount)), customCertificate: \(Swift.String(describing: customCertificate)), customDomain: \(Swift.String(describing: customDomain)), disableAutomatedBackup: \(Swift.String(describing: disableAutomatedBackup)), engine: \(Swift.String(describing: engine)), engineAttributes: \(Swift.String(describing: engineAttributes)), engineModel: \(Swift.String(describing: engineModel)), engineVersion: \(Swift.String(describing: engineVersion)), instanceProfileArn: \(Swift.String(describing: instanceProfileArn)), instanceType: \(Swift.String(describing: instanceType)), keyPair: \(Swift.String(describing: keyPair)), preferredBackupWindow: \(Swift.String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(Swift.String(describing: preferredMaintenanceWindow)), securityGroupIds: \(Swift.String(describing: securityGroupIds)), serverName: \(Swift.String(describing: serverName)), serviceRoleArn: \(Swift.String(describing: serviceRoleArn)), subnetIds: \(Swift.String(describing: subnetIds)), tags: \(Swift.String(describing: tags)), customPrivateKey: \"CONTENT_REDACTED\")"}
}

extension OpsWorksCMClientTypes {

    public enum MaintenanceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [MaintenanceStatus] {
            return [
                .failed,
                .success
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpsWorksCMClientTypes {

    public enum ServerStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case backingUp
        case connectionLost
        case creating
        case deleting
        case failed
        case healthy
        case modifying
        case restoring
        case running
        case setup
        case terminated
        case underMaintenance
        case unhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [ServerStatus] {
            return [
                .backingUp,
                .connectionLost,
                .creating,
                .deleting,
                .failed,
                .healthy,
                .modifying,
                .restoring,
                .running,
                .setup,
                .terminated,
                .underMaintenance,
                .unhealthy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .backingUp: return "BACKING_UP"
            case .connectionLost: return "CONNECTION_LOST"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .healthy: return "HEALTHY"
            case .modifying: return "MODIFYING"
            case .restoring: return "RESTORING"
            case .running: return "RUNNING"
            case .setup: return "SETUP"
            case .terminated: return "TERMINATED"
            case .underMaintenance: return "UNDER_MAINTENANCE"
            case .unhealthy: return "UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpsWorksCMClientTypes {
    /// Describes a configuration management server.
    public struct Server {
        /// Associate a public IP address with a server that you are launching.
        public var associatePublicIpAddress: Swift.Bool?
        /// The number of automated backups to keep.
        public var backupRetentionCount: Swift.Int?
        /// The ARN of the CloudFormation stack that was used to create the server.
        public var cloudFormationStackArn: Swift.String?
        /// Time stamp of server creation. Example 2016-07-29T13:38:47.520Z
        public var createdAt: Foundation.Date?
        /// An optional public endpoint of a server, such as https://aws.my-company.com. You cannot access the server by using the Endpoint value if the server has a CustomDomain specified.
        public var customDomain: Swift.String?
        /// Disables automated backups. The number of stored backups is dependent on the value of PreferredBackupCount.
        public var disableAutomatedBackup: Swift.Bool?
        /// A DNS name that can be used to access the engine. Example: myserver-asdfghjkl.us-east-1.opsworks.io. You cannot access the server by using the Endpoint value if the server has a CustomDomain specified.
        public var endpoint: Swift.String?
        /// The engine type of the server. Valid values in this release include ChefAutomate and Puppet.
        public var engine: Swift.String?
        /// The response of a createServer() request returns the master credential to access the server in EngineAttributes. These credentials are not stored by AWS OpsWorks CM; they are returned only as part of the result of createServer(). Attributes returned in a createServer response for Chef
        ///
        /// * CHEF_AUTOMATE_PIVOTAL_KEY: A base64-encoded RSA private key that is generated by AWS OpsWorks for Chef Automate. This private key is required to access the Chef API.
        ///
        /// * CHEF_STARTER_KIT: A base64-encoded ZIP file. The ZIP file contains a Chef starter kit, which includes a README, a configuration file, and the required RSA private key. Save this file, unzip it, and then change to the directory where you've unzipped the file contents. From this directory, you can run Knife commands.
        ///
        ///
        /// Attributes returned in a createServer response for Puppet
        ///
        /// * PUPPET_STARTER_KIT: A base64-encoded ZIP file. The ZIP file contains a Puppet starter kit, including a README and a required private key. Save this file, unzip it, and then change to the directory where you've unzipped the file contents.
        ///
        /// * PUPPET_ADMIN_PASSWORD: An administrator password that you can use to sign in to the Puppet Enterprise console after the server is online.
        public var engineAttributes: [OpsWorksCMClientTypes.EngineAttribute]?
        /// The engine model of the server. Valid values in this release include Monolithic for Puppet and Single for Chef.
        public var engineModel: Swift.String?
        /// The engine version of the server. For a Chef server, the valid value for EngineVersion is currently 2. For a Puppet server, specify either 2019 or 2017.
        public var engineVersion: Swift.String?
        /// The instance profile ARN of the server.
        public var instanceProfileArn: Swift.String?
        /// The instance type for the server, as specified in the CloudFormation stack. This might not be the same instance type that is shown in the EC2 console.
        public var instanceType: Swift.String?
        /// The key pair associated with the server.
        public var keyPair: Swift.String?
        /// The status of the most recent server maintenance run. Shows SUCCESS or FAILED.
        public var maintenanceStatus: OpsWorksCMClientTypes.MaintenanceStatus?
        /// The preferred backup period specified for the server.
        public var preferredBackupWindow: Swift.String?
        /// The preferred maintenance period specified for the server.
        public var preferredMaintenanceWindow: Swift.String?
        /// The security group IDs for the server, as specified in the CloudFormation stack. These might not be the same security groups that are shown in the EC2 console.
        public var securityGroupIds: [Swift.String]?
        /// The ARN of the server.
        public var serverArn: Swift.String?
        /// The name of the server.
        public var serverName: Swift.String?
        /// The service role ARN used to create the server.
        public var serviceRoleArn: Swift.String?
        /// The server's status. This field displays the states of actions in progress, such as creating, running, or backing up the server, as well as the server's health state.
        public var status: OpsWorksCMClientTypes.ServerStatus?
        /// Depending on the server status, this field has either a human-readable message (such as a create or backup error), or an escaped block of JSON (used for health check results).
        public var statusReason: Swift.String?
        /// The subnet IDs specified in a CreateServer request.
        public var subnetIds: [Swift.String]?

        public init(
            associatePublicIpAddress: Swift.Bool? = nil,
            backupRetentionCount: Swift.Int? = nil,
            cloudFormationStackArn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            customDomain: Swift.String? = nil,
            disableAutomatedBackup: Swift.Bool? = nil,
            endpoint: Swift.String? = nil,
            engine: Swift.String? = nil,
            engineAttributes: [OpsWorksCMClientTypes.EngineAttribute]? = nil,
            engineModel: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            instanceProfileArn: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            keyPair: Swift.String? = nil,
            maintenanceStatus: OpsWorksCMClientTypes.MaintenanceStatus? = nil,
            preferredBackupWindow: Swift.String? = nil,
            preferredMaintenanceWindow: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            serverArn: Swift.String? = nil,
            serverName: Swift.String? = nil,
            serviceRoleArn: Swift.String? = nil,
            status: OpsWorksCMClientTypes.ServerStatus? = nil,
            statusReason: Swift.String? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.associatePublicIpAddress = associatePublicIpAddress
            self.backupRetentionCount = backupRetentionCount
            self.cloudFormationStackArn = cloudFormationStackArn
            self.createdAt = createdAt
            self.customDomain = customDomain
            self.disableAutomatedBackup = disableAutomatedBackup
            self.endpoint = endpoint
            self.engine = engine
            self.engineAttributes = engineAttributes
            self.engineModel = engineModel
            self.engineVersion = engineVersion
            self.instanceProfileArn = instanceProfileArn
            self.instanceType = instanceType
            self.keyPair = keyPair
            self.maintenanceStatus = maintenanceStatus
            self.preferredBackupWindow = preferredBackupWindow
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.securityGroupIds = securityGroupIds
            self.serverArn = serverArn
            self.serverName = serverName
            self.serviceRoleArn = serviceRoleArn
            self.status = status
            self.statusReason = statusReason
            self.subnetIds = subnetIds
        }
    }

}

public struct CreateServerOutput {
    /// The server that is created by the request.
    public var server: OpsWorksCMClientTypes.Server?

    public init(
        server: OpsWorksCMClientTypes.Server? = nil
    )
    {
        self.server = server
    }
}

public struct DeleteBackupInput {
    /// The ID of the backup to delete. Run the DescribeBackups command to get a list of backup IDs. Backup IDs are in the format ServerName-yyyyMMddHHmmssSSS.
    /// This member is required.
    public var backupId: Swift.String?

    public init(
        backupId: Swift.String? = nil
    )
    {
        self.backupId = backupId
    }
}

public struct DeleteBackupOutput {

    public init() { }
}

public struct DeleteServerInput {
    /// The ID of the server to delete.
    /// This member is required.
    public var serverName: Swift.String?

    public init(
        serverName: Swift.String? = nil
    )
    {
        self.serverName = serverName
    }
}

public struct DeleteServerOutput {

    public init() { }
}

public struct DescribeAccountAttributesInput {

    public init() { }
}

public struct DescribeAccountAttributesOutput {
    /// The attributes that are currently set for the account.
    public var attributes: [OpsWorksCMClientTypes.AccountAttribute]?

    public init(
        attributes: [OpsWorksCMClientTypes.AccountAttribute]? = nil
    )
    {
        self.attributes = attributes
    }
}

/// This occurs when the provided nextToken is not valid.
public struct InvalidNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error or informational message that can contain more detail about a nextToken failure.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNextTokenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DescribeBackupsInput {
    /// Describes a single backup.
    public var backupId: Swift.String?
    /// This is not currently implemented for DescribeBackups requests.
    public var maxResults: Swift.Int?
    /// This is not currently implemented for DescribeBackups requests.
    public var nextToken: Swift.String?
    /// Returns backups for the server with the specified ServerName.
    public var serverName: Swift.String?

    public init(
        backupId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serverName: Swift.String? = nil
    )
    {
        self.backupId = backupId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serverName = serverName
    }
}

public struct DescribeBackupsOutput {
    /// Contains the response to a DescribeBackups request.
    public var backups: [OpsWorksCMClientTypes.Backup]?
    /// This is not currently implemented for DescribeBackups requests.
    public var nextToken: Swift.String?

    public init(
        backups: [OpsWorksCMClientTypes.Backup]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backups = backups
        self.nextToken = nextToken
    }
}

public struct DescribeEventsInput {
    /// To receive a paginated response, use this parameter to specify the maximum number of results to be returned with a single call. If the number of available results exceeds this maximum, the response includes a NextToken value that you can assign to the NextToken request parameter to get the next set of results.
    public var maxResults: Swift.Int?
    /// NextToken is a string that is returned in some command responses. It indicates that not all entries have been returned, and that you must run at least one more request to get remaining items. To get remaining results, call DescribeEvents again, and assign the token from the previous results as the value of the nextToken parameter. If there are no more results, the response object's nextToken parameter value is null. Setting a nextToken value that was not returned in your previous results causes an InvalidNextTokenException to occur.
    public var nextToken: Swift.String?
    /// The name of the server for which you want to view events.
    /// This member is required.
    public var serverName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serverName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serverName = serverName
    }
}

extension OpsWorksCMClientTypes {
    /// An event that is related to the server, such as the start of maintenance or backup.
    public struct ServerEvent {
        /// The time when the event occurred.
        public var createdAt: Foundation.Date?
        /// The Amazon S3 URL of the event's log file.
        public var logUrl: Swift.String?
        /// A human-readable informational or status message.
        public var message: Swift.String?
        /// The name of the server on or for which the event occurred.
        public var serverName: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            logUrl: Swift.String? = nil,
            message: Swift.String? = nil,
            serverName: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.logUrl = logUrl
            self.message = message
            self.serverName = serverName
        }
    }

}

public struct DescribeEventsOutput {
    /// NextToken is a string that is returned in some command responses. It indicates that not all entries have been returned, and that you must run at least one more request to get remaining items. To get remaining results, call DescribeEvents again, and assign the token from the previous results as the value of the nextToken parameter. If there are no more results, the response object's nextToken parameter value is null. Setting a nextToken value that was not returned in your previous results causes an InvalidNextTokenException to occur.
    public var nextToken: Swift.String?
    /// Contains the response to a DescribeEvents request.
    public var serverEvents: [OpsWorksCMClientTypes.ServerEvent]?

    public init(
        nextToken: Swift.String? = nil,
        serverEvents: [OpsWorksCMClientTypes.ServerEvent]? = nil
    )
    {
        self.nextToken = nextToken
        self.serverEvents = serverEvents
    }
}

public struct DescribeNodeAssociationStatusInput {
    /// The token returned in either the AssociateNodeResponse or the DisassociateNodeResponse.
    /// This member is required.
    public var nodeAssociationStatusToken: Swift.String?
    /// The name of the server from which to disassociate the node.
    /// This member is required.
    public var serverName: Swift.String?

    public init(
        nodeAssociationStatusToken: Swift.String? = nil,
        serverName: Swift.String? = nil
    )
    {
        self.nodeAssociationStatusToken = nodeAssociationStatusToken
        self.serverName = serverName
    }
}

extension OpsWorksCMClientTypes {

    /// The status of the association or disassociation request. Possible values:
    ///
    /// * SUCCESS: The association or disassociation succeeded.
    ///
    /// * FAILED: The association or disassociation failed.
    ///
    /// * IN_PROGRESS: The association or disassociation is still in progress.
    public enum NodeAssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inProgress
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [NodeAssociationStatus] {
            return [
                .failed,
                .inProgress,
                .success
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeNodeAssociationStatusOutput {
    /// Attributes specific to the node association. In Puppet, the attibute PUPPET_NODE_CERT contains the signed certificate (the result of the CSR).
    public var engineAttributes: [OpsWorksCMClientTypes.EngineAttribute]?
    /// The status of the association or disassociation request. Possible values:
    ///
    /// * SUCCESS: The association or disassociation succeeded.
    ///
    /// * FAILED: The association or disassociation failed.
    ///
    /// * IN_PROGRESS: The association or disassociation is still in progress.
    public var nodeAssociationStatus: OpsWorksCMClientTypes.NodeAssociationStatus?

    public init(
        engineAttributes: [OpsWorksCMClientTypes.EngineAttribute]? = nil,
        nodeAssociationStatus: OpsWorksCMClientTypes.NodeAssociationStatus? = nil
    )
    {
        self.engineAttributes = engineAttributes
        self.nodeAssociationStatus = nodeAssociationStatus
    }
}

public struct DescribeServersInput {
    /// This is not currently implemented for DescribeServers requests.
    public var maxResults: Swift.Int?
    /// This is not currently implemented for DescribeServers requests.
    public var nextToken: Swift.String?
    /// Describes the server with the specified ServerName.
    public var serverName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serverName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serverName = serverName
    }
}

public struct DescribeServersOutput {
    /// This is not currently implemented for DescribeServers requests.
    public var nextToken: Swift.String?
    /// Contains the response to a DescribeServers request. For Chef Automate servers: If DescribeServersResponse$Servers$EngineAttributes includes CHEF_MAJOR_UPGRADE_AVAILABLE, you can upgrade the Chef Automate server to Chef Automate 2. To be eligible for upgrade, a server running Chef Automate 1 must have had at least one successful maintenance run after November 1, 2019. For Puppet servers: DescribeServersResponse$Servers$EngineAttributes contains the following two responses:
    ///
    /// * PUPPET_API_CA_CERT, the PEM-encoded CA certificate that is used by the Puppet API over TCP port number 8140. The CA certificate is also used to sign node certificates.
    ///
    /// * PUPPET_API_CRL, a certificate revocation list. The certificate revocation list is for internal maintenance purposes only. For more information about the Puppet certificate revocation list, see [Man Page: puppet certificate_revocation_list](https://puppet.com/docs/puppet/5.5/man/certificate_revocation_list.html) in the Puppet documentation.
    public var servers: [OpsWorksCMClientTypes.Server]?

    public init(
        nextToken: Swift.String? = nil,
        servers: [OpsWorksCMClientTypes.Server]? = nil
    )
    {
        self.nextToken = nextToken
        self.servers = servers
    }
}

public struct DisassociateNodeInput {
    /// Engine attributes that are used for disassociating the node. No attributes are required for Puppet. Attributes required in a DisassociateNode request for Chef
    ///
    /// * CHEF_ORGANIZATION: The Chef organization with which the node was associated. By default only one organization named default can exist.
    public var engineAttributes: [OpsWorksCMClientTypes.EngineAttribute]?
    /// The name of the client node.
    /// This member is required.
    public var nodeName: Swift.String?
    /// The name of the server from which to disassociate the node.
    /// This member is required.
    public var serverName: Swift.String?

    public init(
        engineAttributes: [OpsWorksCMClientTypes.EngineAttribute]? = nil,
        nodeName: Swift.String? = nil,
        serverName: Swift.String? = nil
    )
    {
        self.engineAttributes = engineAttributes
        self.nodeName = nodeName
        self.serverName = serverName
    }
}

public struct DisassociateNodeOutput {
    /// Contains a token which can be passed to the DescribeNodeAssociationStatus API call to get the status of the disassociation request.
    public var nodeAssociationStatusToken: Swift.String?

    public init(
        nodeAssociationStatusToken: Swift.String? = nil
    )
    {
        self.nodeAssociationStatusToken = nodeAssociationStatusToken
    }
}

public struct ExportServerEngineAttributeInput {
    /// The name of the export attribute. Currently, the supported export attribute is Userdata. This exports a user data script that includes parameters and values provided in the InputAttributes list.
    /// This member is required.
    public var exportAttributeName: Swift.String?
    /// The list of engine attributes. The list type is EngineAttribute. An EngineAttribute list item is a pair that includes an attribute name and its value. For the Userdata ExportAttributeName, the following are supported engine attribute names.
    ///
    /// * RunList In Chef, a list of roles or recipes that are run in the specified order. In Puppet, this parameter is ignored.
    ///
    /// * OrganizationName In Chef, an organization name. AWS OpsWorks for Chef Automate always creates the organization default. In Puppet, this parameter is ignored.
    ///
    /// * NodeEnvironment In Chef, a node environment (for example, development, staging, or one-box). In Puppet, this parameter is ignored.
    ///
    /// * NodeClientVersion In Chef, the version of the Chef engine (three numbers separated by dots, such as 13.8.5). If this attribute is empty, OpsWorks for Chef Automate uses the most current version. In Puppet, this parameter is ignored.
    public var inputAttributes: [OpsWorksCMClientTypes.EngineAttribute]?
    /// The name of the server from which you are exporting the attribute.
    /// This member is required.
    public var serverName: Swift.String?

    public init(
        exportAttributeName: Swift.String? = nil,
        inputAttributes: [OpsWorksCMClientTypes.EngineAttribute]? = nil,
        serverName: Swift.String? = nil
    )
    {
        self.exportAttributeName = exportAttributeName
        self.inputAttributes = inputAttributes
        self.serverName = serverName
    }
}

public struct ExportServerEngineAttributeOutput {
    /// The requested engine attribute pair with attribute name and value.
    public var engineAttribute: OpsWorksCMClientTypes.EngineAttribute?
    /// The server name used in the request.
    public var serverName: Swift.String?

    public init(
        engineAttribute: OpsWorksCMClientTypes.EngineAttribute? = nil,
        serverName: Swift.String? = nil
    )
    {
        self.engineAttribute = engineAttribute
        self.serverName = serverName
    }
}

public struct ListTagsForResourceInput {
    /// To receive a paginated response, use this parameter to specify the maximum number of results to be returned with a single call. If the number of available results exceeds this maximum, the response includes a NextToken value that you can assign to the NextToken request parameter to get the next set of results.
    public var maxResults: Swift.Int?
    /// NextToken is a string that is returned in some command responses. It indicates that not all entries have been returned, and that you must run at least one more request to get remaining items. To get remaining results, call ListTagsForResource again, and assign the token from the previous results as the value of the nextToken parameter. If there are no more results, the response object's nextToken parameter value is null. Setting a nextToken value that was not returned in your previous results causes an InvalidNextTokenException to occur.
    public var nextToken: Swift.String?
    /// The Amazon Resource Number (ARN) of an AWS OpsWorks for Chef Automate or AWS OpsWorks for Puppet Enterprise server for which you want to show applied tags. For example, arn:aws:opsworks-cm:us-west-2:123456789012:server/test-owcm-server/EXAMPLE-66b0-4196-8274-d1a2bEXAMPLE.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// A token that you can use as the value of NextToken in subsequent calls to the API to show more results.
    public var nextToken: Swift.String?
    /// Tags that have been applied to the resource.
    public var tags: [OpsWorksCMClientTypes.Tag]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [OpsWorksCMClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

public struct RestoreServerInput {
    /// The ID of the backup that you want to use to restore a server.
    /// This member is required.
    public var backupId: Swift.String?
    /// The type of instance to restore. Valid values must be specified in the following format: ^([cm][34]|t2).* For example, m5.large. Valid values are m5.large, r5.xlarge, and r5.2xlarge. If you do not specify this parameter, RestoreServer uses the instance type from the specified backup.
    public var instanceType: Swift.String?
    /// The name of the key pair to set on the new EC2 instance. This can be helpful if the administrator no longer has the SSH key.
    public var keyPair: Swift.String?
    /// The name of the server that you want to restore.
    /// This member is required.
    public var serverName: Swift.String?

    public init(
        backupId: Swift.String? = nil,
        instanceType: Swift.String? = nil,
        keyPair: Swift.String? = nil,
        serverName: Swift.String? = nil
    )
    {
        self.backupId = backupId
        self.instanceType = instanceType
        self.keyPair = keyPair
        self.serverName = serverName
    }
}

public struct RestoreServerOutput {
    /// Describes a configuration management server.
    public var server: OpsWorksCMClientTypes.Server?

    public init(
        server: OpsWorksCMClientTypes.Server? = nil
    )
    {
        self.server = server
    }
}

public struct StartMaintenanceInput {
    /// Engine attributes that are specific to the server on which you want to run maintenance. Attributes accepted in a StartMaintenance request for Chef
    ///
    /// * CHEF_MAJOR_UPGRADE: If a Chef Automate server is eligible for upgrade to Chef Automate 2, add this engine attribute to a StartMaintenance request and set the value to true to upgrade the server to Chef Automate 2. For more information, see [Upgrade an AWS OpsWorks for Chef Automate Server to Chef Automate 2](https://docs.aws.amazon.com/opsworks/latest/userguide/opscm-a2upgrade.html).
    public var engineAttributes: [OpsWorksCMClientTypes.EngineAttribute]?
    /// The name of the server on which to run maintenance.
    /// This member is required.
    public var serverName: Swift.String?

    public init(
        engineAttributes: [OpsWorksCMClientTypes.EngineAttribute]? = nil,
        serverName: Swift.String? = nil
    )
    {
        self.engineAttributes = engineAttributes
        self.serverName = serverName
    }
}

public struct StartMaintenanceOutput {
    /// Contains the response to a StartMaintenance request.
    public var server: OpsWorksCMClientTypes.Server?

    public init(
        server: OpsWorksCMClientTypes.Server? = nil
    )
    {
        self.server = server
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Number (ARN) of a resource to which you want to apply tags. For example, arn:aws:opsworks-cm:us-west-2:123456789012:server/test-owcm-server/EXAMPLE-66b0-4196-8274-d1a2bEXAMPLE.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A map that contains tag keys and tag values to attach to AWS OpsWorks-CM servers or backups.
    ///
    /// * The key cannot be empty.
    ///
    /// * The key can be a maximum of 127 characters, and can contain only Unicode letters, numbers, or separators, or the following special characters: + - = . _ : /
    ///
    /// * The value can be a maximum 255 characters, and contain only Unicode letters, numbers, or separators, or the following special characters: + - = . _ : /
    ///
    /// * Leading and trailing white spaces are trimmed from both the key and value.
    ///
    /// * A maximum of 50 user-applied tags is allowed for any AWS OpsWorks-CM server or backup.
    /// This member is required.
    public var tags: [OpsWorksCMClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [OpsWorksCMClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The Amazon Resource Number (ARN) of a resource from which you want to remove tags. For example, arn:aws:opsworks-cm:us-west-2:123456789012:server/test-owcm-server/EXAMPLE-66b0-4196-8274-d1a2bEXAMPLE.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of tags that you want to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

public struct UpdateServerInput {
    /// Sets the number of automated backups that you want to keep.
    public var backupRetentionCount: Swift.Int?
    /// Setting DisableAutomatedBackup to true disables automated or scheduled backups. Automated backups are enabled by default.
    public var disableAutomatedBackup: Swift.Bool?
    /// DDD:HH:MM (weekly start time) or HH:MM (daily start time). Time windows always use coordinated universal time (UTC). Valid strings for day of week (DDD) are: Mon, Tue, Wed, Thr, Fri, Sat, or Sun.
    public var preferredBackupWindow: Swift.String?
    /// DDD:HH:MM (weekly start time) or HH:MM (daily start time). Time windows always use coordinated universal time (UTC). Valid strings for day of week (DDD) are: Mon, Tue, Wed, Thr, Fri, Sat, or Sun.
    public var preferredMaintenanceWindow: Swift.String?
    /// The name of the server to update.
    /// This member is required.
    public var serverName: Swift.String?

    public init(
        backupRetentionCount: Swift.Int? = nil,
        disableAutomatedBackup: Swift.Bool? = nil,
        preferredBackupWindow: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        serverName: Swift.String? = nil
    )
    {
        self.backupRetentionCount = backupRetentionCount
        self.disableAutomatedBackup = disableAutomatedBackup
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.serverName = serverName
    }
}

public struct UpdateServerOutput {
    /// Contains the response to a UpdateServer request.
    public var server: OpsWorksCMClientTypes.Server?

    public init(
        server: OpsWorksCMClientTypes.Server? = nil
    )
    {
        self.server = server
    }
}

public struct UpdateServerEngineAttributesInput {
    /// The name of the engine attribute to update.
    /// This member is required.
    public var attributeName: Swift.String?
    /// The value to set for the attribute.
    public var attributeValue: Swift.String?
    /// The name of the server to update.
    /// This member is required.
    public var serverName: Swift.String?

    public init(
        attributeName: Swift.String? = nil,
        attributeValue: Swift.String? = nil,
        serverName: Swift.String? = nil
    )
    {
        self.attributeName = attributeName
        self.attributeValue = attributeValue
        self.serverName = serverName
    }
}

public struct UpdateServerEngineAttributesOutput {
    /// Contains the response to an UpdateServerEngineAttributes request.
    public var server: OpsWorksCMClientTypes.Server?

    public init(
        server: OpsWorksCMClientTypes.Server? = nil
    )
    {
        self.server = server
    }
}

extension AssociateNodeInput {

    static func urlPathProvider(_ value: AssociateNodeInput) -> Swift.String? {
        return "/"
    }
}

extension CreateBackupInput {

    static func urlPathProvider(_ value: CreateBackupInput) -> Swift.String? {
        return "/"
    }
}

extension CreateServerInput {

    static func urlPathProvider(_ value: CreateServerInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteBackupInput {

    static func urlPathProvider(_ value: DeleteBackupInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteServerInput {

    static func urlPathProvider(_ value: DeleteServerInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAccountAttributesInput {

    static func urlPathProvider(_ value: DescribeAccountAttributesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeBackupsInput {

    static func urlPathProvider(_ value: DescribeBackupsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeEventsInput {

    static func urlPathProvider(_ value: DescribeEventsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeNodeAssociationStatusInput {

    static func urlPathProvider(_ value: DescribeNodeAssociationStatusInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeServersInput {

    static func urlPathProvider(_ value: DescribeServersInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateNodeInput {

    static func urlPathProvider(_ value: DisassociateNodeInput) -> Swift.String? {
        return "/"
    }
}

extension ExportServerEngineAttributeInput {

    static func urlPathProvider(_ value: ExportServerEngineAttributeInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension RestoreServerInput {

    static func urlPathProvider(_ value: RestoreServerInput) -> Swift.String? {
        return "/"
    }
}

extension StartMaintenanceInput {

    static func urlPathProvider(_ value: StartMaintenanceInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateServerInput {

    static func urlPathProvider(_ value: UpdateServerInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateServerEngineAttributesInput {

    static func urlPathProvider(_ value: UpdateServerEngineAttributesInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateNodeInput {

    static func write(value: AssociateNodeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EngineAttributes"].writeList(value.engineAttributes, memberWritingClosure: OpsWorksCMClientTypes.EngineAttribute.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NodeName"].write(value.nodeName)
        try writer["ServerName"].write(value.serverName)
    }
}

extension CreateBackupInput {

    static func write(value: CreateBackupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["ServerName"].write(value.serverName)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: OpsWorksCMClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateServerInput {

    static func write(value: CreateServerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssociatePublicIpAddress"].write(value.associatePublicIpAddress)
        try writer["BackupId"].write(value.backupId)
        try writer["BackupRetentionCount"].write(value.backupRetentionCount)
        try writer["CustomCertificate"].write(value.customCertificate)
        try writer["CustomDomain"].write(value.customDomain)
        try writer["CustomPrivateKey"].write(value.customPrivateKey)
        try writer["DisableAutomatedBackup"].write(value.disableAutomatedBackup)
        try writer["Engine"].write(value.engine)
        try writer["EngineAttributes"].writeList(value.engineAttributes, memberWritingClosure: OpsWorksCMClientTypes.EngineAttribute.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EngineModel"].write(value.engineModel)
        try writer["EngineVersion"].write(value.engineVersion)
        try writer["InstanceProfileArn"].write(value.instanceProfileArn)
        try writer["InstanceType"].write(value.instanceType)
        try writer["KeyPair"].write(value.keyPair)
        try writer["PreferredBackupWindow"].write(value.preferredBackupWindow)
        try writer["PreferredMaintenanceWindow"].write(value.preferredMaintenanceWindow)
        try writer["SecurityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ServerName"].write(value.serverName)
        try writer["ServiceRoleArn"].write(value.serviceRoleArn)
        try writer["SubnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: OpsWorksCMClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteBackupInput {

    static func write(value: DeleteBackupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackupId"].write(value.backupId)
    }
}

extension DeleteServerInput {

    static func write(value: DeleteServerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ServerName"].write(value.serverName)
    }
}

extension DescribeAccountAttributesInput {

    static func write(value: DescribeAccountAttributesInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DescribeBackupsInput {

    static func write(value: DescribeBackupsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackupId"].write(value.backupId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ServerName"].write(value.serverName)
    }
}

extension DescribeEventsInput {

    static func write(value: DescribeEventsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ServerName"].write(value.serverName)
    }
}

extension DescribeNodeAssociationStatusInput {

    static func write(value: DescribeNodeAssociationStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NodeAssociationStatusToken"].write(value.nodeAssociationStatusToken)
        try writer["ServerName"].write(value.serverName)
    }
}

extension DescribeServersInput {

    static func write(value: DescribeServersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ServerName"].write(value.serverName)
    }
}

extension DisassociateNodeInput {

    static func write(value: DisassociateNodeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EngineAttributes"].writeList(value.engineAttributes, memberWritingClosure: OpsWorksCMClientTypes.EngineAttribute.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NodeName"].write(value.nodeName)
        try writer["ServerName"].write(value.serverName)
    }
}

extension ExportServerEngineAttributeInput {

    static func write(value: ExportServerEngineAttributeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExportAttributeName"].write(value.exportAttributeName)
        try writer["InputAttributes"].writeList(value.inputAttributes, memberWritingClosure: OpsWorksCMClientTypes.EngineAttribute.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ServerName"].write(value.serverName)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension RestoreServerInput {

    static func write(value: RestoreServerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackupId"].write(value.backupId)
        try writer["InstanceType"].write(value.instanceType)
        try writer["KeyPair"].write(value.keyPair)
        try writer["ServerName"].write(value.serverName)
    }
}

extension StartMaintenanceInput {

    static func write(value: StartMaintenanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EngineAttributes"].writeList(value.engineAttributes, memberWritingClosure: OpsWorksCMClientTypes.EngineAttribute.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ServerName"].write(value.serverName)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: OpsWorksCMClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateServerInput {

    static func write(value: UpdateServerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackupRetentionCount"].write(value.backupRetentionCount)
        try writer["DisableAutomatedBackup"].write(value.disableAutomatedBackup)
        try writer["PreferredBackupWindow"].write(value.preferredBackupWindow)
        try writer["PreferredMaintenanceWindow"].write(value.preferredMaintenanceWindow)
        try writer["ServerName"].write(value.serverName)
    }
}

extension UpdateServerEngineAttributesInput {

    static func write(value: UpdateServerEngineAttributesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributeName"].write(value.attributeName)
        try writer["AttributeValue"].write(value.attributeValue)
        try writer["ServerName"].write(value.serverName)
    }
}

extension AssociateNodeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateNodeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateNodeOutput()
        value.nodeAssociationStatusToken = try reader["NodeAssociationStatusToken"].readIfPresent()
        return value
    }
}

extension CreateBackupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateBackupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateBackupOutput()
        value.backup = try reader["Backup"].readIfPresent(with: OpsWorksCMClientTypes.Backup.read(from:))
        return value
    }
}

extension CreateServerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateServerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateServerOutput()
        value.server = try reader["Server"].readIfPresent(with: OpsWorksCMClientTypes.Server.read(from:))
        return value
    }
}

extension DeleteBackupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteBackupOutput {
        return DeleteBackupOutput()
    }
}

extension DeleteServerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteServerOutput {
        return DeleteServerOutput()
    }
}

extension DescribeAccountAttributesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAccountAttributesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAccountAttributesOutput()
        value.attributes = try reader["Attributes"].readListIfPresent(memberReadingClosure: OpsWorksCMClientTypes.AccountAttribute.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeBackupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeBackupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeBackupsOutput()
        value.backups = try reader["Backups"].readListIfPresent(memberReadingClosure: OpsWorksCMClientTypes.Backup.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeEventsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeEventsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeEventsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.serverEvents = try reader["ServerEvents"].readListIfPresent(memberReadingClosure: OpsWorksCMClientTypes.ServerEvent.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeNodeAssociationStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeNodeAssociationStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeNodeAssociationStatusOutput()
        value.engineAttributes = try reader["EngineAttributes"].readListIfPresent(memberReadingClosure: OpsWorksCMClientTypes.EngineAttribute.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nodeAssociationStatus = try reader["NodeAssociationStatus"].readIfPresent()
        return value
    }
}

extension DescribeServersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeServersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeServersOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.servers = try reader["Servers"].readListIfPresent(memberReadingClosure: OpsWorksCMClientTypes.Server.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DisassociateNodeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateNodeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociateNodeOutput()
        value.nodeAssociationStatusToken = try reader["NodeAssociationStatusToken"].readIfPresent()
        return value
    }
}

extension ExportServerEngineAttributeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ExportServerEngineAttributeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ExportServerEngineAttributeOutput()
        value.engineAttribute = try reader["EngineAttribute"].readIfPresent(with: OpsWorksCMClientTypes.EngineAttribute.read(from:))
        value.serverName = try reader["ServerName"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: OpsWorksCMClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension RestoreServerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RestoreServerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RestoreServerOutput()
        value.server = try reader["Server"].readIfPresent(with: OpsWorksCMClientTypes.Server.read(from:))
        return value
    }
}

extension StartMaintenanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartMaintenanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartMaintenanceOutput()
        value.server = try reader["Server"].readIfPresent(with: OpsWorksCMClientTypes.Server.read(from:))
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateServerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateServerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateServerOutput()
        value.server = try reader["Server"].readIfPresent(with: OpsWorksCMClientTypes.Server.read(from:))
        return value
    }
}

extension UpdateServerEngineAttributesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateServerEngineAttributesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateServerEngineAttributesOutput()
        value.server = try reader["Server"].readIfPresent(with: OpsWorksCMClientTypes.Server.read(from:))
        return value
    }
}

enum AssociateNodeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidStateException": return try InvalidStateException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateBackupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidStateException": return try InvalidStateException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateServerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteBackupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidStateException": return try InvalidStateException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteServerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidStateException": return try InvalidStateException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAccountAttributesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeBackupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeEventsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeNodeAssociationStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeServersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateNodeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidStateException": return try InvalidStateException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ExportServerEngineAttributeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidStateException": return try InvalidStateException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RestoreServerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidStateException": return try InvalidStateException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartMaintenanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidStateException": return try InvalidStateException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidStateException": return try InvalidStateException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidStateException": return try InvalidStateException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateServerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidStateException": return try InvalidStateException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateServerEngineAttributesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidStateException": return try InvalidStateException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidStateException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidStateException {
        let reader = baseError.errorBodyReader
        var value = InvalidStateException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = ResourceAlreadyExistsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidNextTokenException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidNextTokenException {
        let reader = baseError.errorBodyReader
        var value = InvalidNextTokenException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OpsWorksCMClientTypes.Backup {

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksCMClientTypes.Backup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksCMClientTypes.Backup()
        value.backupArn = try reader["BackupArn"].readIfPresent()
        value.backupId = try reader["BackupId"].readIfPresent()
        value.backupType = try reader["BackupType"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.engine = try reader["Engine"].readIfPresent()
        value.engineModel = try reader["EngineModel"].readIfPresent()
        value.engineVersion = try reader["EngineVersion"].readIfPresent()
        value.instanceProfileArn = try reader["InstanceProfileArn"].readIfPresent()
        value.instanceType = try reader["InstanceType"].readIfPresent()
        value.keyPair = try reader["KeyPair"].readIfPresent()
        value.preferredBackupWindow = try reader["PreferredBackupWindow"].readIfPresent()
        value.preferredMaintenanceWindow = try reader["PreferredMaintenanceWindow"].readIfPresent()
        value.s3DataSize = try reader["S3DataSize"].readIfPresent()
        value.s3DataUrl = try reader["S3DataUrl"].readIfPresent()
        value.s3LogUrl = try reader["S3LogUrl"].readIfPresent()
        value.securityGroupIds = try reader["SecurityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.serverName = try reader["ServerName"].readIfPresent()
        value.serviceRoleArn = try reader["ServiceRoleArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusDescription = try reader["StatusDescription"].readIfPresent()
        value.subnetIds = try reader["SubnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.toolsVersion = try reader["ToolsVersion"].readIfPresent()
        value.userArn = try reader["UserArn"].readIfPresent()
        return value
    }
}

extension OpsWorksCMClientTypes.Server {

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksCMClientTypes.Server {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksCMClientTypes.Server()
        value.associatePublicIpAddress = try reader["AssociatePublicIpAddress"].readIfPresent()
        value.backupRetentionCount = try reader["BackupRetentionCount"].readIfPresent()
        value.serverName = try reader["ServerName"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.cloudFormationStackArn = try reader["CloudFormationStackArn"].readIfPresent()
        value.customDomain = try reader["CustomDomain"].readIfPresent()
        value.disableAutomatedBackup = try reader["DisableAutomatedBackup"].readIfPresent()
        value.endpoint = try reader["Endpoint"].readIfPresent()
        value.engine = try reader["Engine"].readIfPresent()
        value.engineModel = try reader["EngineModel"].readIfPresent()
        value.engineAttributes = try reader["EngineAttributes"].readListIfPresent(memberReadingClosure: OpsWorksCMClientTypes.EngineAttribute.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.engineVersion = try reader["EngineVersion"].readIfPresent()
        value.instanceProfileArn = try reader["InstanceProfileArn"].readIfPresent()
        value.instanceType = try reader["InstanceType"].readIfPresent()
        value.keyPair = try reader["KeyPair"].readIfPresent()
        value.maintenanceStatus = try reader["MaintenanceStatus"].readIfPresent()
        value.preferredMaintenanceWindow = try reader["PreferredMaintenanceWindow"].readIfPresent()
        value.preferredBackupWindow = try reader["PreferredBackupWindow"].readIfPresent()
        value.securityGroupIds = try reader["SecurityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.serviceRoleArn = try reader["ServiceRoleArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusReason = try reader["StatusReason"].readIfPresent()
        value.subnetIds = try reader["SubnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.serverArn = try reader["ServerArn"].readIfPresent()
        return value
    }
}

extension OpsWorksCMClientTypes.EngineAttribute {

    static func write(value: OpsWorksCMClientTypes.EngineAttribute?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksCMClientTypes.EngineAttribute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksCMClientTypes.EngineAttribute()
        value.name = try reader["Name"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension OpsWorksCMClientTypes.AccountAttribute {

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksCMClientTypes.AccountAttribute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksCMClientTypes.AccountAttribute()
        value.name = try reader["Name"].readIfPresent()
        value.maximum = try reader["Maximum"].readIfPresent()
        value.used = try reader["Used"].readIfPresent()
        return value
    }
}

extension OpsWorksCMClientTypes.ServerEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksCMClientTypes.ServerEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksCMClientTypes.ServerEvent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.serverName = try reader["ServerName"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        value.logUrl = try reader["LogUrl"].readIfPresent()
        return value
    }
}

extension OpsWorksCMClientTypes.Tag {

    static func write(value: OpsWorksCMClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksCMClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksCMClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

public enum OpsWorksCMClientTypes {}
