//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class ClientRuntime.Indirect
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// This exception is thrown when a request is denied per access permissions
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// This exception is thrown when there is a conflict performing an operation
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// This exception is thrown if there was an unexpected error during processing of request
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// This exception is thrown when a resource referenced by the operation does not exist
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// This exception is thrown when a request is made beyond the service quota
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// This exception is thrown when the number of requests exceeds the limit
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Stores information about a field passed inside a request that resulted in an exception.
    public struct ValidationExceptionField: Swift.Sendable {
        /// A message describing why this field failed validation.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        ) {
            self.message = message
            self.name = name
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case idempotentParameterMismatchException
        case resourceConflict
        case rootEventInOtherSession
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .idempotentParameterMismatchException,
                .resourceConflict,
                .rootEventInOtherSession
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CannotParse"
            case .fieldValidationFailed: return "FieldValidationFailed"
            case .idempotentParameterMismatchException: return "IdempotentParameterMismatchException"
            case .resourceConflict: return "ResourceConflict"
            case .rootEventInOtherSession: return "EventInOtherSession"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The input fails to satisfy the constraints specified by the service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var fieldList: [BedrockAgentCoreControlClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// This member is required.
        public internal(set) var reason: BedrockAgentCoreControlClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [BedrockAgentCoreControlClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: BedrockAgentCoreControlClientTypes.ValidationExceptionReason? = nil
    ) {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

public struct CreateAgentRuntimeEndpointInput: Swift.Sendable {
    /// The unique identifier of the AgentCore Runtime to create an endpoint for.
    /// This member is required.
    public var agentRuntimeId: Swift.String?
    /// The version of the AgentCore Runtime to use for the endpoint.
    public var agentRuntimeVersion: Swift.String?
    /// A unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// The description of the AgentCore Runtime endpoint.
    public var description: Swift.String?
    /// The name of the AgentCore Runtime endpoint.
    /// This member is required.
    public var name: Swift.String?
    /// A map of tag keys and values to assign to the agent runtime endpoint. Tags enable you to categorize your resources in different ways, for example, by purpose, owner, or environment.
    public var tags: [Swift.String: Swift.String]?

    public init(
        agentRuntimeId: Swift.String? = nil,
        agentRuntimeVersion: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.agentRuntimeId = agentRuntimeId
        self.agentRuntimeVersion = agentRuntimeVersion
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.tags = tags
    }
}

extension CreateAgentRuntimeEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAgentRuntimeEndpointInput(agentRuntimeId: \(Swift.String(describing: agentRuntimeId)), agentRuntimeVersion: \(Swift.String(describing: agentRuntimeVersion)), clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), tags: \(Swift.String(describing: tags)), name: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentCoreControlClientTypes {

    public enum AgentRuntimeEndpointStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createFailed
        case creating
        case deleting
        case ready
        case updateFailed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [AgentRuntimeEndpointStatus] {
            return [
                .createFailed,
                .creating,
                .deleting,
                .ready,
                .updateFailed,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .ready: return "READY"
            case .updateFailed: return "UPDATE_FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateAgentRuntimeEndpointOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the AgentCore Runtime.
    /// This member is required.
    public var agentRuntimeArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the AgentCore Runtime endpoint.
    /// This member is required.
    public var agentRuntimeEndpointArn: Swift.String?
    /// The timestamp when the AgentCore Runtime endpoint was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The current status of the AgentCore Runtime endpoint.
    /// This member is required.
    public var status: BedrockAgentCoreControlClientTypes.AgentRuntimeEndpointStatus?
    /// The target version of the AgentCore Runtime for the endpoint.
    /// This member is required.
    public var targetVersion: Swift.String?

    public init(
        agentRuntimeArn: Swift.String? = nil,
        agentRuntimeEndpointArn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        status: BedrockAgentCoreControlClientTypes.AgentRuntimeEndpointStatus? = nil,
        targetVersion: Swift.String? = nil
    ) {
        self.agentRuntimeArn = agentRuntimeArn
        self.agentRuntimeEndpointArn = agentRuntimeEndpointArn
        self.createdAt = createdAt
        self.status = status
        self.targetVersion = targetVersion
    }
}

public struct DeleteAgentRuntimeEndpointInput: Swift.Sendable {
    /// The unique identifier of the AgentCore Runtime associated with the endpoint.
    /// This member is required.
    public var agentRuntimeId: Swift.String?
    /// A unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// The name of the AgentCore Runtime endpoint to delete.
    /// This member is required.
    public var endpointName: Swift.String?

    public init(
        agentRuntimeId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        endpointName: Swift.String? = nil
    ) {
        self.agentRuntimeId = agentRuntimeId
        self.clientToken = clientToken
        self.endpointName = endpointName
    }
}

extension DeleteAgentRuntimeEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAgentRuntimeEndpointInput(agentRuntimeId: \(Swift.String(describing: agentRuntimeId)), clientToken: \(Swift.String(describing: clientToken)), endpointName: \"CONTENT_REDACTED\")"}
}

public struct DeleteAgentRuntimeEndpointOutput: Swift.Sendable {
    /// The current status of the AgentCore Runtime endpoint deletion.
    /// This member is required.
    public var status: BedrockAgentCoreControlClientTypes.AgentRuntimeEndpointStatus?

    public init(
        status: BedrockAgentCoreControlClientTypes.AgentRuntimeEndpointStatus? = nil
    ) {
        self.status = status
    }
}

public struct GetAgentRuntimeEndpointInput: Swift.Sendable {
    /// The unique identifier of the AgentCore Runtime associated with the endpoint.
    /// This member is required.
    public var agentRuntimeId: Swift.String?
    /// The name of the AgentCore Runtime endpoint to retrieve.
    /// This member is required.
    public var endpointName: Swift.String?

    public init(
        agentRuntimeId: Swift.String? = nil,
        endpointName: Swift.String? = nil
    ) {
        self.agentRuntimeId = agentRuntimeId
        self.endpointName = endpointName
    }
}

extension GetAgentRuntimeEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAgentRuntimeEndpointInput(agentRuntimeId: \(Swift.String(describing: agentRuntimeId)), endpointName: \"CONTENT_REDACTED\")"}
}

public struct GetAgentRuntimeEndpointOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the AgentCore Runtime.
    /// This member is required.
    public var agentRuntimeArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the AgentCore Runtime endpoint.
    /// This member is required.
    public var agentRuntimeEndpointArn: Swift.String?
    /// The timestamp when the AgentCore Runtime endpoint was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The description of the AgentCore Runtime endpoint.
    public var description: Swift.String?
    /// The reason for failure if the AgentCore Runtime endpoint is in a failed state.
    public var failureReason: Swift.String?
    /// The unique identifier of the AgentCore Runtime endpoint.
    /// This member is required.
    public var id: Swift.String?
    /// The timestamp when the AgentCore Runtime endpoint was last updated.
    /// This member is required.
    public var lastUpdatedAt: Foundation.Date?
    /// The currently deployed version of the AgentCore Runtime on the endpoint.
    public var liveVersion: Swift.String?
    /// The name of the AgentCore Runtime endpoint.
    /// This member is required.
    public var name: Swift.String?
    /// The current status of the AgentCore Runtime endpoint.
    /// This member is required.
    public var status: BedrockAgentCoreControlClientTypes.AgentRuntimeEndpointStatus?
    /// The target version of the AgentCore Runtime for the endpoint.
    public var targetVersion: Swift.String?

    public init(
        agentRuntimeArn: Swift.String? = nil,
        agentRuntimeEndpointArn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        failureReason: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        liveVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        status: BedrockAgentCoreControlClientTypes.AgentRuntimeEndpointStatus? = nil,
        targetVersion: Swift.String? = nil
    ) {
        self.agentRuntimeArn = agentRuntimeArn
        self.agentRuntimeEndpointArn = agentRuntimeEndpointArn
        self.createdAt = createdAt
        self.description = description
        self.failureReason = failureReason
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.liveVersion = liveVersion
        self.name = name
        self.status = status
        self.targetVersion = targetVersion
    }
}

extension GetAgentRuntimeEndpointOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAgentRuntimeEndpointOutput(agentRuntimeArn: \(Swift.String(describing: agentRuntimeArn)), agentRuntimeEndpointArn: \(Swift.String(describing: agentRuntimeEndpointArn)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), failureReason: \(Swift.String(describing: failureReason)), id: \(Swift.String(describing: id)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), liveVersion: \(Swift.String(describing: liveVersion)), status: \(Swift.String(describing: status)), targetVersion: \(Swift.String(describing: targetVersion)), name: \"CONTENT_REDACTED\")"}
}

public struct ListAgentRuntimeEndpointsInput: Swift.Sendable {
    /// The unique identifier of the AgentCore Runtime to list endpoints for.
    /// This member is required.
    public var agentRuntimeId: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        agentRuntimeId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.agentRuntimeId = agentRuntimeId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Contains information about an agent runtime endpoint. An endpoint provides a way to connect to and interact with an agent runtime.
    public struct AgentRuntimeEndpoint: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the agent runtime associated with the endpoint.
        /// This member is required.
        public var agentRuntimeArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the agent runtime endpoint.
        /// This member is required.
        public var agentRuntimeEndpointArn: Swift.String?
        /// The timestamp when the agent runtime endpoint was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The description of the agent runtime endpoint.
        public var description: Swift.String?
        /// The unique identifier of the agent runtime endpoint.
        /// This member is required.
        public var id: Swift.String?
        /// The timestamp when the agent runtime endpoint was last updated.
        /// This member is required.
        public var lastUpdatedAt: Foundation.Date?
        /// The live version of the agent runtime endpoint. This is the version that is currently serving requests.
        public var liveVersion: Swift.String?
        /// The name of the agent runtime endpoint.
        /// This member is required.
        public var name: Swift.String?
        /// The current status of the agent runtime endpoint.
        /// This member is required.
        public var status: BedrockAgentCoreControlClientTypes.AgentRuntimeEndpointStatus?
        /// The target version of the agent runtime endpoint. This is the version that the endpoint is being updated to.
        public var targetVersion: Swift.String?

        public init(
            agentRuntimeArn: Swift.String? = nil,
            agentRuntimeEndpointArn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            liveVersion: Swift.String? = nil,
            name: Swift.String? = nil,
            status: BedrockAgentCoreControlClientTypes.AgentRuntimeEndpointStatus? = nil,
            targetVersion: Swift.String? = nil
        ) {
            self.agentRuntimeArn = agentRuntimeArn
            self.agentRuntimeEndpointArn = agentRuntimeEndpointArn
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.liveVersion = liveVersion
            self.name = name
            self.status = status
            self.targetVersion = targetVersion
        }
    }
}

extension BedrockAgentCoreControlClientTypes.AgentRuntimeEndpoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AgentRuntimeEndpoint(agentRuntimeArn: \(Swift.String(describing: agentRuntimeArn)), agentRuntimeEndpointArn: \(Swift.String(describing: agentRuntimeEndpointArn)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), liveVersion: \(Swift.String(describing: liveVersion)), status: \(Swift.String(describing: status)), targetVersion: \(Swift.String(describing: targetVersion)), name: \"CONTENT_REDACTED\")"}
}

public struct ListAgentRuntimeEndpointsOutput: Swift.Sendable {
    /// A token to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The list of AgentCore Runtime endpoints.
    /// This member is required.
    public var runtimeEndpoints: [BedrockAgentCoreControlClientTypes.AgentRuntimeEndpoint]?

    public init(
        nextToken: Swift.String? = nil,
        runtimeEndpoints: [BedrockAgentCoreControlClientTypes.AgentRuntimeEndpoint]? = nil
    ) {
        self.nextToken = nextToken
        self.runtimeEndpoints = runtimeEndpoints
    }
}

public struct UpdateAgentRuntimeEndpointInput: Swift.Sendable {
    /// The unique identifier of the AgentCore Runtime associated with the endpoint.
    /// This member is required.
    public var agentRuntimeId: Swift.String?
    /// The updated version of the AgentCore Runtime for the endpoint.
    public var agentRuntimeVersion: Swift.String?
    /// A unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// The updated description of the AgentCore Runtime endpoint.
    public var description: Swift.String?
    /// The name of the AgentCore Runtime endpoint to update.
    /// This member is required.
    public var endpointName: Swift.String?

    public init(
        agentRuntimeId: Swift.String? = nil,
        agentRuntimeVersion: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        endpointName: Swift.String? = nil
    ) {
        self.agentRuntimeId = agentRuntimeId
        self.agentRuntimeVersion = agentRuntimeVersion
        self.clientToken = clientToken
        self.description = description
        self.endpointName = endpointName
    }
}

extension UpdateAgentRuntimeEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAgentRuntimeEndpointInput(agentRuntimeId: \(Swift.String(describing: agentRuntimeId)), agentRuntimeVersion: \(Swift.String(describing: agentRuntimeVersion)), clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), endpointName: \"CONTENT_REDACTED\")"}
}

public struct UpdateAgentRuntimeEndpointOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the AgentCore Runtime.
    /// This member is required.
    public var agentRuntimeArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the AgentCore Runtime endpoint.
    /// This member is required.
    public var agentRuntimeEndpointArn: Swift.String?
    /// The timestamp when the AgentCore Runtime endpoint was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The timestamp when the AgentCore Runtime endpoint was last updated.
    /// This member is required.
    public var lastUpdatedAt: Foundation.Date?
    /// The currently deployed version of the AgentCore Runtime on the endpoint.
    public var liveVersion: Swift.String?
    /// The current status of the updated AgentCore Runtime endpoint.
    /// This member is required.
    public var status: BedrockAgentCoreControlClientTypes.AgentRuntimeEndpointStatus?
    /// The target version of the AgentCore Runtime for the endpoint.
    public var targetVersion: Swift.String?

    public init(
        agentRuntimeArn: Swift.String? = nil,
        agentRuntimeEndpointArn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        liveVersion: Swift.String? = nil,
        status: BedrockAgentCoreControlClientTypes.AgentRuntimeEndpointStatus? = nil,
        targetVersion: Swift.String? = nil
    ) {
        self.agentRuntimeArn = agentRuntimeArn
        self.agentRuntimeEndpointArn = agentRuntimeEndpointArn
        self.createdAt = createdAt
        self.lastUpdatedAt = lastUpdatedAt
        self.liveVersion = liveVersion
        self.status = status
        self.targetVersion = targetVersion
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Representation of a container configuration.
    public struct ContainerConfiguration: Swift.Sendable {
        /// The ECR URI of the container.
        /// This member is required.
        public var containerUri: Swift.String?

        public init(
            containerUri: Swift.String? = nil
        ) {
            self.containerUri = containerUri
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// The artifact of the agent.
    public enum AgentRuntimeArtifact: Swift.Sendable {
        /// The container configuration for the agent artifact.
        case containerconfiguration(BedrockAgentCoreControlClientTypes.ContainerConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Configuration for inbound JWT-based authorization, specifying how incoming requests should be authenticated.
    public struct CustomJWTAuthorizerConfiguration: Swift.Sendable {
        /// Represents individual audience values that are validated in the incoming JWT token validation process.
        public var allowedAudience: [Swift.String]?
        /// Represents individual client IDs that are validated in the incoming JWT token validation process.
        public var allowedClients: [Swift.String]?
        /// This URL is used to fetch OpenID Connect configuration or authorization server metadata for validating incoming tokens.
        /// This member is required.
        public var discoveryUrl: Swift.String?

        public init(
            allowedAudience: [Swift.String]? = nil,
            allowedClients: [Swift.String]? = nil,
            discoveryUrl: Swift.String? = nil
        ) {
            self.allowedAudience = allowedAudience
            self.allowedClients = allowedClients
            self.discoveryUrl = discoveryUrl
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Represents inbound authorization configuration options used to authenticate incoming requests.
    public enum AuthorizerConfiguration: Swift.Sendable {
        /// The inbound JWT-based authorization, specifying how incoming requests should be authenticated.
        case customjwtauthorizer(BedrockAgentCoreControlClientTypes.CustomJWTAuthorizerConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentCoreControlClientTypes {

    public enum NetworkMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `public`
        case vpc
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkMode] {
            return [
                .public,
                .vpc
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .public: return "PUBLIC"
            case .vpc: return "VPC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// VpcConfig for the Agent.
    public struct VpcConfig: Swift.Sendable {
        /// The security groups associated with the VPC configuration.
        /// This member is required.
        public var securityGroups: [Swift.String]?
        /// The subnets associated with the VPC configuration.
        /// This member is required.
        public var subnets: [Swift.String]?

        public init(
            securityGroups: [Swift.String]? = nil,
            subnets: [Swift.String]? = nil
        ) {
            self.securityGroups = securityGroups
            self.subnets = subnets
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// SecurityConfig for the Agent.
    public struct NetworkConfiguration: Swift.Sendable {
        /// The network mode for the AgentCore Runtime.
        /// This member is required.
        public var networkMode: BedrockAgentCoreControlClientTypes.NetworkMode?
        /// The network mode configuration for the AgentCore Runtime.
        public var networkModeConfig: BedrockAgentCoreControlClientTypes.VpcConfig?

        public init(
            networkMode: BedrockAgentCoreControlClientTypes.NetworkMode? = nil,
            networkModeConfig: BedrockAgentCoreControlClientTypes.VpcConfig? = nil
        ) {
            self.networkMode = networkMode
            self.networkModeConfig = networkModeConfig
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    public enum ServerProtocol: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case http
        case mcp
        case sdkUnknown(Swift.String)

        public static var allCases: [ServerProtocol] {
            return [
                .http,
                .mcp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .http: return "HTTP"
            case .mcp: return "MCP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// The protocol configuration for an agent runtime. This structure defines how the agent runtime communicates with clients.
    public struct ProtocolConfiguration: Swift.Sendable {
        /// The server protocol for the agent runtime. This field specifies which protocol the agent runtime uses to communicate with clients.
        /// This member is required.
        public var serverProtocol: BedrockAgentCoreControlClientTypes.ServerProtocol?

        public init(
            serverProtocol: BedrockAgentCoreControlClientTypes.ServerProtocol? = nil
        ) {
            self.serverProtocol = serverProtocol
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Configuration for HTTP request headers that will be passed through to the runtime.
    public enum RequestHeaderConfiguration: Swift.Sendable {
        /// A list of HTTP request headers that are allowed to be passed through to the runtime.
        case requestheaderallowlist([Swift.String])
        case sdkUnknown(Swift.String)
    }
}

public struct CreateAgentRuntimeInput: Swift.Sendable {
    /// The artifact of the AgentCore Runtime.
    /// This member is required.
    public var agentRuntimeArtifact: BedrockAgentCoreControlClientTypes.AgentRuntimeArtifact?
    /// The name of the AgentCore Runtime.
    /// This member is required.
    public var agentRuntimeName: Swift.String?
    /// The authorizer configuration for the AgentCore Runtime.
    public var authorizerConfiguration: BedrockAgentCoreControlClientTypes.AuthorizerConfiguration?
    /// A unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// The description of the AgentCore Runtime.
    public var description: Swift.String?
    /// Environment variables to set in the AgentCore Runtime environment.
    public var environmentVariables: [Swift.String: Swift.String]?
    /// The network configuration for the AgentCore Runtime.
    /// This member is required.
    public var networkConfiguration: BedrockAgentCoreControlClientTypes.NetworkConfiguration?
    /// The protocol configuration for an agent runtime. This structure defines how the agent runtime communicates with clients.
    public var protocolConfiguration: BedrockAgentCoreControlClientTypes.ProtocolConfiguration?
    /// Configuration for HTTP request headers that will be passed through to the runtime.
    public var requestHeaderConfiguration: BedrockAgentCoreControlClientTypes.RequestHeaderConfiguration?
    /// The IAM role ARN that provides permissions for the AgentCore Runtime.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A map of tag keys and values to assign to the agent runtime. Tags enable you to categorize your resources in different ways, for example, by purpose, owner, or environment.
    public var tags: [Swift.String: Swift.String]?

    public init(
        agentRuntimeArtifact: BedrockAgentCoreControlClientTypes.AgentRuntimeArtifact? = nil,
        agentRuntimeName: Swift.String? = nil,
        authorizerConfiguration: BedrockAgentCoreControlClientTypes.AuthorizerConfiguration? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentVariables: [Swift.String: Swift.String]? = nil,
        networkConfiguration: BedrockAgentCoreControlClientTypes.NetworkConfiguration? = nil,
        protocolConfiguration: BedrockAgentCoreControlClientTypes.ProtocolConfiguration? = nil,
        requestHeaderConfiguration: BedrockAgentCoreControlClientTypes.RequestHeaderConfiguration? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.agentRuntimeArtifact = agentRuntimeArtifact
        self.agentRuntimeName = agentRuntimeName
        self.authorizerConfiguration = authorizerConfiguration
        self.clientToken = clientToken
        self.description = description
        self.environmentVariables = environmentVariables
        self.networkConfiguration = networkConfiguration
        self.protocolConfiguration = protocolConfiguration
        self.requestHeaderConfiguration = requestHeaderConfiguration
        self.roleArn = roleArn
        self.tags = tags
    }
}

extension CreateAgentRuntimeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAgentRuntimeInput(agentRuntimeArtifact: \(Swift.String(describing: agentRuntimeArtifact)), agentRuntimeName: \(Swift.String(describing: agentRuntimeName)), authorizerConfiguration: \(Swift.String(describing: authorizerConfiguration)), clientToken: \(Swift.String(describing: clientToken)), networkConfiguration: \(Swift.String(describing: networkConfiguration)), protocolConfiguration: \(Swift.String(describing: protocolConfiguration)), requestHeaderConfiguration: \(Swift.String(describing: requestHeaderConfiguration)), roleArn: \(Swift.String(describing: roleArn)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\", environmentVariables: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentCoreControlClientTypes {

    public enum AgentRuntimeStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createFailed
        case creating
        case deleting
        case ready
        case updateFailed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [AgentRuntimeStatus] {
            return [
                .createFailed,
                .creating,
                .deleting,
                .ready,
                .updateFailed,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .ready: return "READY"
            case .updateFailed: return "UPDATE_FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// The information about the workload identity.
    public struct WorkloadIdentityDetails: Swift.Sendable {
        /// The ARN associated with the workload identity.
        /// This member is required.
        public var workloadIdentityArn: Swift.String?

        public init(
            workloadIdentityArn: Swift.String? = nil
        ) {
            self.workloadIdentityArn = workloadIdentityArn
        }
    }
}

public struct CreateAgentRuntimeOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the AgentCore Runtime.
    /// This member is required.
    public var agentRuntimeArn: Swift.String?
    /// The unique identifier of the AgentCore Runtime.
    /// This member is required.
    public var agentRuntimeId: Swift.String?
    /// The version of the AgentCore Runtime.
    /// This member is required.
    public var agentRuntimeVersion: Swift.String?
    /// The timestamp when the AgentCore Runtime was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The current status of the AgentCore Runtime.
    /// This member is required.
    public var status: BedrockAgentCoreControlClientTypes.AgentRuntimeStatus?
    /// The workload identity details for the AgentCore Runtime.
    public var workloadIdentityDetails: BedrockAgentCoreControlClientTypes.WorkloadIdentityDetails?

    public init(
        agentRuntimeArn: Swift.String? = nil,
        agentRuntimeId: Swift.String? = nil,
        agentRuntimeVersion: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        status: BedrockAgentCoreControlClientTypes.AgentRuntimeStatus? = nil,
        workloadIdentityDetails: BedrockAgentCoreControlClientTypes.WorkloadIdentityDetails? = nil
    ) {
        self.agentRuntimeArn = agentRuntimeArn
        self.agentRuntimeId = agentRuntimeId
        self.agentRuntimeVersion = agentRuntimeVersion
        self.createdAt = createdAt
        self.status = status
        self.workloadIdentityDetails = workloadIdentityDetails
    }
}

public struct DeleteAgentRuntimeInput: Swift.Sendable {
    /// The unique identifier of the AgentCore Runtime to delete.
    /// This member is required.
    public var agentRuntimeId: Swift.String?

    public init(
        agentRuntimeId: Swift.String? = nil
    ) {
        self.agentRuntimeId = agentRuntimeId
    }
}

public struct DeleteAgentRuntimeOutput: Swift.Sendable {
    /// The current status of the AgentCore Runtime deletion.
    /// This member is required.
    public var status: BedrockAgentCoreControlClientTypes.AgentRuntimeStatus?

    public init(
        status: BedrockAgentCoreControlClientTypes.AgentRuntimeStatus? = nil
    ) {
        self.status = status
    }
}

public struct GetAgentRuntimeInput: Swift.Sendable {
    /// The unique identifier of the AgentCore Runtime to retrieve.
    /// This member is required.
    public var agentRuntimeId: Swift.String?
    /// The version of the AgentCore Runtime to retrieve.
    public var agentRuntimeVersion: Swift.String?

    public init(
        agentRuntimeId: Swift.String? = nil,
        agentRuntimeVersion: Swift.String? = nil
    ) {
        self.agentRuntimeId = agentRuntimeId
        self.agentRuntimeVersion = agentRuntimeVersion
    }
}

public struct GetAgentRuntimeOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the AgentCore Runtime.
    /// This member is required.
    public var agentRuntimeArn: Swift.String?
    /// The artifact of the AgentCore Runtime.
    public var agentRuntimeArtifact: BedrockAgentCoreControlClientTypes.AgentRuntimeArtifact?
    /// The unique identifier of the AgentCore Runtime.
    /// This member is required.
    public var agentRuntimeId: Swift.String?
    /// The name of the AgentCore Runtime.
    /// This member is required.
    public var agentRuntimeName: Swift.String?
    /// The version of the AgentCore Runtime.
    /// This member is required.
    public var agentRuntimeVersion: Swift.String?
    /// The authorizer configuration for the AgentCore Runtime.
    public var authorizerConfiguration: BedrockAgentCoreControlClientTypes.AuthorizerConfiguration?
    /// The timestamp when the AgentCore Runtime was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The description of the AgentCore Runtime.
    public var description: Swift.String?
    /// Environment variables set in the AgentCore Runtime environment.
    public var environmentVariables: [Swift.String: Swift.String]?
    /// The timestamp when the AgentCore Runtime was last updated.
    /// This member is required.
    public var lastUpdatedAt: Foundation.Date?
    /// The network configuration for the AgentCore Runtime.
    /// This member is required.
    public var networkConfiguration: BedrockAgentCoreControlClientTypes.NetworkConfiguration?
    /// The protocol configuration for an agent runtime. This structure defines how the agent runtime communicates with clients.
    public var protocolConfiguration: BedrockAgentCoreControlClientTypes.ProtocolConfiguration?
    /// Configuration for HTTP request headers that will be passed through to the runtime.
    public var requestHeaderConfiguration: BedrockAgentCoreControlClientTypes.RequestHeaderConfiguration?
    /// The IAM role ARN that provides permissions for the AgentCore Runtime.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The current status of the AgentCore Runtime.
    /// This member is required.
    public var status: BedrockAgentCoreControlClientTypes.AgentRuntimeStatus?
    /// The workload identity details for the AgentCore Runtime.
    public var workloadIdentityDetails: BedrockAgentCoreControlClientTypes.WorkloadIdentityDetails?

    public init(
        agentRuntimeArn: Swift.String? = nil,
        agentRuntimeArtifact: BedrockAgentCoreControlClientTypes.AgentRuntimeArtifact? = nil,
        agentRuntimeId: Swift.String? = nil,
        agentRuntimeName: Swift.String? = nil,
        agentRuntimeVersion: Swift.String? = nil,
        authorizerConfiguration: BedrockAgentCoreControlClientTypes.AuthorizerConfiguration? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        environmentVariables: [Swift.String: Swift.String]? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        networkConfiguration: BedrockAgentCoreControlClientTypes.NetworkConfiguration? = nil,
        protocolConfiguration: BedrockAgentCoreControlClientTypes.ProtocolConfiguration? = nil,
        requestHeaderConfiguration: BedrockAgentCoreControlClientTypes.RequestHeaderConfiguration? = nil,
        roleArn: Swift.String? = nil,
        status: BedrockAgentCoreControlClientTypes.AgentRuntimeStatus? = nil,
        workloadIdentityDetails: BedrockAgentCoreControlClientTypes.WorkloadIdentityDetails? = nil
    ) {
        self.agentRuntimeArn = agentRuntimeArn
        self.agentRuntimeArtifact = agentRuntimeArtifact
        self.agentRuntimeId = agentRuntimeId
        self.agentRuntimeName = agentRuntimeName
        self.agentRuntimeVersion = agentRuntimeVersion
        self.authorizerConfiguration = authorizerConfiguration
        self.createdAt = createdAt
        self.description = description
        self.environmentVariables = environmentVariables
        self.lastUpdatedAt = lastUpdatedAt
        self.networkConfiguration = networkConfiguration
        self.protocolConfiguration = protocolConfiguration
        self.requestHeaderConfiguration = requestHeaderConfiguration
        self.roleArn = roleArn
        self.status = status
        self.workloadIdentityDetails = workloadIdentityDetails
    }
}

extension GetAgentRuntimeOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAgentRuntimeOutput(agentRuntimeArn: \(Swift.String(describing: agentRuntimeArn)), agentRuntimeArtifact: \(Swift.String(describing: agentRuntimeArtifact)), agentRuntimeId: \(Swift.String(describing: agentRuntimeId)), agentRuntimeName: \(Swift.String(describing: agentRuntimeName)), agentRuntimeVersion: \(Swift.String(describing: agentRuntimeVersion)), authorizerConfiguration: \(Swift.String(describing: authorizerConfiguration)), createdAt: \(Swift.String(describing: createdAt)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), networkConfiguration: \(Swift.String(describing: networkConfiguration)), protocolConfiguration: \(Swift.String(describing: protocolConfiguration)), requestHeaderConfiguration: \(Swift.String(describing: requestHeaderConfiguration)), roleArn: \(Swift.String(describing: roleArn)), status: \(Swift.String(describing: status)), workloadIdentityDetails: \(Swift.String(describing: workloadIdentityDetails)), description: \"CONTENT_REDACTED\", environmentVariables: \"CONTENT_REDACTED\")"}
}

public struct ListAgentRuntimesInput: Swift.Sendable {
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Contains information about an agent runtime. An agent runtime is the execution environment for a Amazon Bedrock Agent.
    public struct AgentRuntime: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the agent runtime.
        /// This member is required.
        public var agentRuntimeArn: Swift.String?
        /// The unique identifier of the agent runtime.
        /// This member is required.
        public var agentRuntimeId: Swift.String?
        /// The name of the agent runtime.
        /// This member is required.
        public var agentRuntimeName: Swift.String?
        /// The version of the agent runtime.
        /// This member is required.
        public var agentRuntimeVersion: Swift.String?
        /// The description of the agent runtime.
        /// This member is required.
        public var description: Swift.String?
        /// The timestamp when the agent runtime was last updated.
        /// This member is required.
        public var lastUpdatedAt: Foundation.Date?
        /// The current status of the agent runtime.
        /// This member is required.
        public var status: BedrockAgentCoreControlClientTypes.AgentRuntimeStatus?

        public init(
            agentRuntimeArn: Swift.String? = nil,
            agentRuntimeId: Swift.String? = nil,
            agentRuntimeName: Swift.String? = nil,
            agentRuntimeVersion: Swift.String? = nil,
            description: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            status: BedrockAgentCoreControlClientTypes.AgentRuntimeStatus? = nil
        ) {
            self.agentRuntimeArn = agentRuntimeArn
            self.agentRuntimeId = agentRuntimeId
            self.agentRuntimeName = agentRuntimeName
            self.agentRuntimeVersion = agentRuntimeVersion
            self.description = description
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
        }
    }
}

extension BedrockAgentCoreControlClientTypes.AgentRuntime: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AgentRuntime(agentRuntimeArn: \(Swift.String(describing: agentRuntimeArn)), agentRuntimeId: \(Swift.String(describing: agentRuntimeId)), agentRuntimeName: \(Swift.String(describing: agentRuntimeName)), agentRuntimeVersion: \(Swift.String(describing: agentRuntimeVersion)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\")"}
}

public struct ListAgentRuntimesOutput: Swift.Sendable {
    /// The list of AgentCore Runtime resources.
    /// This member is required.
    public var agentRuntimes: [BedrockAgentCoreControlClientTypes.AgentRuntime]?
    /// A token to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        agentRuntimes: [BedrockAgentCoreControlClientTypes.AgentRuntime]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.agentRuntimes = agentRuntimes
        self.nextToken = nextToken
    }
}

public struct ListAgentRuntimeVersionsInput: Swift.Sendable {
    /// The unique identifier of the AgentCore Runtime to list versions for.
    /// This member is required.
    public var agentRuntimeId: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        agentRuntimeId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.agentRuntimeId = agentRuntimeId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAgentRuntimeVersionsOutput: Swift.Sendable {
    /// The list of AgentCore Runtime versions.
    /// This member is required.
    public var agentRuntimes: [BedrockAgentCoreControlClientTypes.AgentRuntime]?
    /// A token to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        agentRuntimes: [BedrockAgentCoreControlClientTypes.AgentRuntime]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.agentRuntimes = agentRuntimes
        self.nextToken = nextToken
    }
}

public struct UpdateAgentRuntimeInput: Swift.Sendable {
    /// The updated artifact of the AgentCore Runtime.
    /// This member is required.
    public var agentRuntimeArtifact: BedrockAgentCoreControlClientTypes.AgentRuntimeArtifact?
    /// The unique identifier of the AgentCore Runtime to update.
    /// This member is required.
    public var agentRuntimeId: Swift.String?
    /// The updated authorizer configuration for the AgentCore Runtime.
    public var authorizerConfiguration: BedrockAgentCoreControlClientTypes.AuthorizerConfiguration?
    /// A unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// The updated description of the AgentCore Runtime.
    public var description: Swift.String?
    /// Updated environment variables to set in the AgentCore Runtime environment.
    public var environmentVariables: [Swift.String: Swift.String]?
    /// The updated network configuration for the AgentCore Runtime.
    /// This member is required.
    public var networkConfiguration: BedrockAgentCoreControlClientTypes.NetworkConfiguration?
    /// The protocol configuration for an agent runtime. This structure defines how the agent runtime communicates with clients.
    public var protocolConfiguration: BedrockAgentCoreControlClientTypes.ProtocolConfiguration?
    /// The updated configuration for HTTP request headers that will be passed through to the runtime.
    public var requestHeaderConfiguration: BedrockAgentCoreControlClientTypes.RequestHeaderConfiguration?
    /// The updated IAM role ARN that provides permissions for the AgentCore Runtime.
    /// This member is required.
    public var roleArn: Swift.String?

    public init(
        agentRuntimeArtifact: BedrockAgentCoreControlClientTypes.AgentRuntimeArtifact? = nil,
        agentRuntimeId: Swift.String? = nil,
        authorizerConfiguration: BedrockAgentCoreControlClientTypes.AuthorizerConfiguration? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentVariables: [Swift.String: Swift.String]? = nil,
        networkConfiguration: BedrockAgentCoreControlClientTypes.NetworkConfiguration? = nil,
        protocolConfiguration: BedrockAgentCoreControlClientTypes.ProtocolConfiguration? = nil,
        requestHeaderConfiguration: BedrockAgentCoreControlClientTypes.RequestHeaderConfiguration? = nil,
        roleArn: Swift.String? = nil
    ) {
        self.agentRuntimeArtifact = agentRuntimeArtifact
        self.agentRuntimeId = agentRuntimeId
        self.authorizerConfiguration = authorizerConfiguration
        self.clientToken = clientToken
        self.description = description
        self.environmentVariables = environmentVariables
        self.networkConfiguration = networkConfiguration
        self.protocolConfiguration = protocolConfiguration
        self.requestHeaderConfiguration = requestHeaderConfiguration
        self.roleArn = roleArn
    }
}

extension UpdateAgentRuntimeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAgentRuntimeInput(agentRuntimeArtifact: \(Swift.String(describing: agentRuntimeArtifact)), agentRuntimeId: \(Swift.String(describing: agentRuntimeId)), authorizerConfiguration: \(Swift.String(describing: authorizerConfiguration)), clientToken: \(Swift.String(describing: clientToken)), networkConfiguration: \(Swift.String(describing: networkConfiguration)), protocolConfiguration: \(Swift.String(describing: protocolConfiguration)), requestHeaderConfiguration: \(Swift.String(describing: requestHeaderConfiguration)), roleArn: \(Swift.String(describing: roleArn)), description: \"CONTENT_REDACTED\", environmentVariables: \"CONTENT_REDACTED\")"}
}

public struct UpdateAgentRuntimeOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the updated AgentCore Runtime.
    /// This member is required.
    public var agentRuntimeArn: Swift.String?
    /// The unique identifier of the updated AgentCore Runtime.
    /// This member is required.
    public var agentRuntimeId: Swift.String?
    /// The version of the updated AgentCore Runtime.
    /// This member is required.
    public var agentRuntimeVersion: Swift.String?
    /// The timestamp when the AgentCore Runtime was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The timestamp when the AgentCore Runtime was last updated.
    /// This member is required.
    public var lastUpdatedAt: Foundation.Date?
    /// The current status of the updated AgentCore Runtime.
    /// This member is required.
    public var status: BedrockAgentCoreControlClientTypes.AgentRuntimeStatus?
    /// The workload identity details for the updated AgentCore Runtime.
    public var workloadIdentityDetails: BedrockAgentCoreControlClientTypes.WorkloadIdentityDetails?

    public init(
        agentRuntimeArn: Swift.String? = nil,
        agentRuntimeId: Swift.String? = nil,
        agentRuntimeVersion: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        status: BedrockAgentCoreControlClientTypes.AgentRuntimeStatus? = nil,
        workloadIdentityDetails: BedrockAgentCoreControlClientTypes.WorkloadIdentityDetails? = nil
    ) {
        self.agentRuntimeArn = agentRuntimeArn
        self.agentRuntimeId = agentRuntimeId
        self.agentRuntimeVersion = agentRuntimeVersion
        self.createdAt = createdAt
        self.lastUpdatedAt = lastUpdatedAt
        self.status = status
        self.workloadIdentityDetails = workloadIdentityDetails
    }
}

/// Exception thrown when decryption of a secret fails.
public struct DecryptionFailure: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DecryptionFailure" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// Exception thrown when encryption of a secret fails.
public struct EncryptionFailure: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EncryptionFailure" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// Exception thrown when a resource limit is exceeded.
public struct ResourceLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// This exception is thrown when the JWT bearer token is invalid or not found for OAuth bearer token based access
public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct CreateApiKeyCredentialProviderInput: Swift.Sendable {
    /// The API key to use for authentication. This value is encrypted and stored securely.
    /// This member is required.
    public var apiKey: Swift.String?
    /// The name of the API key credential provider. The name must be unique within your account.
    /// This member is required.
    public var name: Swift.String?

    public init(
        apiKey: Swift.String? = nil,
        name: Swift.String? = nil
    ) {
        self.apiKey = apiKey
        self.name = name
    }
}

extension CreateApiKeyCredentialProviderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateApiKeyCredentialProviderInput(name: \(Swift.String(describing: name)), apiKey: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentCoreControlClientTypes {

    /// Contains information about a secret in AWS Secrets Manager.
    public struct Secret: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the secret in AWS Secrets Manager.
        /// This member is required.
        public var secretArn: Swift.String?

        public init(
            secretArn: Swift.String? = nil
        ) {
            self.secretArn = secretArn
        }
    }
}

public struct CreateApiKeyCredentialProviderOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the secret containing the API key.
    /// This member is required.
    public var apiKeySecretArn: BedrockAgentCoreControlClientTypes.Secret?
    /// The Amazon Resource Name (ARN) of the created API key credential provider.
    /// This member is required.
    public var credentialProviderArn: Swift.String?
    /// The name of the created API key credential provider.
    /// This member is required.
    public var name: Swift.String?

    public init(
        apiKeySecretArn: BedrockAgentCoreControlClientTypes.Secret? = nil,
        credentialProviderArn: Swift.String? = nil,
        name: Swift.String? = nil
    ) {
        self.apiKeySecretArn = apiKeySecretArn
        self.credentialProviderArn = credentialProviderArn
        self.name = name
    }
}

public struct DeleteApiKeyCredentialProviderInput: Swift.Sendable {
    /// The name of the API key credential provider to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    ) {
        self.name = name
    }
}

public struct DeleteApiKeyCredentialProviderOutput: Swift.Sendable {

    public init() { }
}

public struct GetApiKeyCredentialProviderInput: Swift.Sendable {
    /// The name of the API key credential provider to retrieve.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    ) {
        self.name = name
    }
}

public struct GetApiKeyCredentialProviderOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the API key secret in AWS Secrets Manager.
    /// This member is required.
    public var apiKeySecretArn: BedrockAgentCoreControlClientTypes.Secret?
    /// The timestamp when the API key credential provider was created.
    /// This member is required.
    public var createdTime: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the API key credential provider.
    /// This member is required.
    public var credentialProviderArn: Swift.String?
    /// The timestamp when the API key credential provider was last updated.
    /// This member is required.
    public var lastUpdatedTime: Foundation.Date?
    /// The name of the API key credential provider.
    /// This member is required.
    public var name: Swift.String?

    public init(
        apiKeySecretArn: BedrockAgentCoreControlClientTypes.Secret? = nil,
        createdTime: Foundation.Date? = nil,
        credentialProviderArn: Swift.String? = nil,
        lastUpdatedTime: Foundation.Date? = nil,
        name: Swift.String? = nil
    ) {
        self.apiKeySecretArn = apiKeySecretArn
        self.createdTime = createdTime
        self.credentialProviderArn = credentialProviderArn
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
    }
}

public struct ListApiKeyCredentialProvidersInput: Swift.Sendable {
    /// Maximum number of results to return.
    public var maxResults: Swift.Int?
    /// Pagination token.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Contains information about an API key credential provider.
    public struct ApiKeyCredentialProviderItem: Swift.Sendable {
        /// The timestamp when the API key credential provider was created.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the API key credential provider.
        /// This member is required.
        public var credentialProviderArn: Swift.String?
        /// The timestamp when the API key credential provider was last updated.
        /// This member is required.
        public var lastUpdatedTime: Foundation.Date?
        /// The name of the API key credential provider.
        /// This member is required.
        public var name: Swift.String?

        public init(
            createdTime: Foundation.Date? = nil,
            credentialProviderArn: Swift.String? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            name: Swift.String? = nil
        ) {
            self.createdTime = createdTime
            self.credentialProviderArn = credentialProviderArn
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }
    }
}

public struct ListApiKeyCredentialProvidersOutput: Swift.Sendable {
    /// The list of API key credential providers.
    /// This member is required.
    public var credentialProviders: [BedrockAgentCoreControlClientTypes.ApiKeyCredentialProviderItem]?
    /// Pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        credentialProviders: [BedrockAgentCoreControlClientTypes.ApiKeyCredentialProviderItem]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.credentialProviders = credentialProviders
        self.nextToken = nextToken
    }
}

public struct UpdateApiKeyCredentialProviderInput: Swift.Sendable {
    /// The new API key to use for authentication. This value replaces the existing API key and is encrypted and stored securely.
    /// This member is required.
    public var apiKey: Swift.String?
    /// The name of the API key credential provider to update.
    /// This member is required.
    public var name: Swift.String?

    public init(
        apiKey: Swift.String? = nil,
        name: Swift.String? = nil
    ) {
        self.apiKey = apiKey
        self.name = name
    }
}

extension UpdateApiKeyCredentialProviderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateApiKeyCredentialProviderInput(name: \(Swift.String(describing: name)), apiKey: \"CONTENT_REDACTED\")"}
}

public struct UpdateApiKeyCredentialProviderOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the API key secret in AWS Secrets Manager.
    /// This member is required.
    public var apiKeySecretArn: BedrockAgentCoreControlClientTypes.Secret?
    /// The timestamp when the API key credential provider was created.
    /// This member is required.
    public var createdTime: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the API key credential provider.
    /// This member is required.
    public var credentialProviderArn: Swift.String?
    /// The timestamp when the API key credential provider was last updated.
    /// This member is required.
    public var lastUpdatedTime: Foundation.Date?
    /// The name of the API key credential provider.
    /// This member is required.
    public var name: Swift.String?

    public init(
        apiKeySecretArn: BedrockAgentCoreControlClientTypes.Secret? = nil,
        createdTime: Foundation.Date? = nil,
        credentialProviderArn: Swift.String? = nil,
        lastUpdatedTime: Foundation.Date? = nil,
        name: Swift.String? = nil
    ) {
        self.apiKeySecretArn = apiKeySecretArn
        self.createdTime = createdTime
        self.credentialProviderArn = credentialProviderArn
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
    }
}

extension BedrockAgentCoreControlClientTypes {

    public enum BrowserNetworkMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `public`
        case vpc
        case sdkUnknown(Swift.String)

        public static var allCases: [BrowserNetworkMode] {
            return [
                .public,
                .vpc
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .public: return "PUBLIC"
            case .vpc: return "VPC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// The network configuration for a browser. This structure defines how the browser connects to the network.
    public struct BrowserNetworkConfiguration: Swift.Sendable {
        /// The network mode for the browser. This field specifies how the browser connects to the network.
        /// This member is required.
        public var networkMode: BedrockAgentCoreControlClientTypes.BrowserNetworkMode?
        /// VpcConfig for the Agent.
        public var vpcConfig: BedrockAgentCoreControlClientTypes.VpcConfig?

        public init(
            networkMode: BedrockAgentCoreControlClientTypes.BrowserNetworkMode? = .`public`,
            vpcConfig: BedrockAgentCoreControlClientTypes.VpcConfig? = nil
        ) {
            self.networkMode = networkMode
            self.vpcConfig = vpcConfig
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// The Amazon S3 location for storing data. This structure defines where in Amazon S3 data is stored.
    public struct S3Location: Swift.Sendable {
        /// The name of the Amazon S3 bucket. This bucket contains the stored data.
        /// This member is required.
        public var bucket: Swift.String?
        /// The prefix for objects in the Amazon S3 bucket. This prefix is added to the object keys to organize the data.
        /// This member is required.
        public var `prefix`: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            `prefix`: Swift.String? = nil
        ) {
            self.bucket = bucket
            self.`prefix` = `prefix`
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// The recording configuration for a browser. This structure defines how browser sessions are recorded.
    public struct RecordingConfig: Swift.Sendable {
        /// Indicates whether recording is enabled for the browser. When set to true, browser sessions are recorded.
        public var enabled: Swift.Bool
        /// The Amazon S3 location where browser recordings are stored. This location contains the recorded browser sessions.
        public var s3Location: BedrockAgentCoreControlClientTypes.S3Location?

        public init(
            enabled: Swift.Bool = false,
            s3Location: BedrockAgentCoreControlClientTypes.S3Location? = nil
        ) {
            self.enabled = enabled
            self.s3Location = s3Location
        }
    }
}

public struct CreateBrowserInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure that the operation completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request but does not return an error.
    public var clientToken: Swift.String?
    /// The description of the browser.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role that provides permissions for the browser to access Amazon Web Services services.
    public var executionRoleArn: Swift.String?
    /// The name of the browser. The name must be unique within your account.
    /// This member is required.
    public var name: Swift.String?
    /// The network configuration for the browser. This configuration specifies the network mode for the browser.
    /// This member is required.
    public var networkConfiguration: BedrockAgentCoreControlClientTypes.BrowserNetworkConfiguration?
    /// The recording configuration for the browser. When enabled, browser sessions are recorded and stored in the specified Amazon S3 location.
    public var recording: BedrockAgentCoreControlClientTypes.RecordingConfig?
    /// A map of tag keys and values to assign to the browser. Tags enable you to categorize your resources in different ways, for example, by purpose, owner, or environment.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        executionRoleArn: Swift.String? = nil,
        name: Swift.String? = nil,
        networkConfiguration: BedrockAgentCoreControlClientTypes.BrowserNetworkConfiguration? = nil,
        recording: BedrockAgentCoreControlClientTypes.RecordingConfig? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.clientToken = clientToken
        self.description = description
        self.executionRoleArn = executionRoleArn
        self.name = name
        self.networkConfiguration = networkConfiguration
        self.recording = recording
        self.tags = tags
    }
}

extension CreateBrowserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBrowserInput(clientToken: \(Swift.String(describing: clientToken)), executionRoleArn: \(Swift.String(describing: executionRoleArn)), name: \(Swift.String(describing: name)), networkConfiguration: \(Swift.String(describing: networkConfiguration)), recording: \(Swift.String(describing: recording)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentCoreControlClientTypes {

    public enum BrowserStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createFailed
        case creating
        case deleted
        case deleteFailed
        case deleting
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [BrowserStatus] {
            return [
                .createFailed,
                .creating,
                .deleted,
                .deleteFailed,
                .deleting,
                .ready
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleting: return "DELETING"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateBrowserOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the created browser.
    /// This member is required.
    public var browserArn: Swift.String?
    /// The unique identifier of the created browser.
    /// This member is required.
    public var browserId: Swift.String?
    /// The timestamp when the browser was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The current status of the browser.
    /// This member is required.
    public var status: BedrockAgentCoreControlClientTypes.BrowserStatus?

    public init(
        browserArn: Swift.String? = nil,
        browserId: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        status: BedrockAgentCoreControlClientTypes.BrowserStatus? = nil
    ) {
        self.browserArn = browserArn
        self.browserId = browserId
        self.createdAt = createdAt
        self.status = status
    }
}

public struct DeleteBrowserInput: Swift.Sendable {
    /// The unique identifier of the browser to delete.
    /// This member is required.
    public var browserId: Swift.String?
    /// A unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?

    public init(
        browserId: Swift.String? = nil,
        clientToken: Swift.String? = nil
    ) {
        self.browserId = browserId
        self.clientToken = clientToken
    }
}

public struct DeleteBrowserOutput: Swift.Sendable {
    /// The unique identifier of the deleted browser.
    /// This member is required.
    public var browserId: Swift.String?
    /// The timestamp when the browser was last updated.
    /// This member is required.
    public var lastUpdatedAt: Foundation.Date?
    /// The current status of the browser deletion.
    /// This member is required.
    public var status: BedrockAgentCoreControlClientTypes.BrowserStatus?

    public init(
        browserId: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        status: BedrockAgentCoreControlClientTypes.BrowserStatus? = nil
    ) {
        self.browserId = browserId
        self.lastUpdatedAt = lastUpdatedAt
        self.status = status
    }
}

public struct GetBrowserInput: Swift.Sendable {
    /// The unique identifier of the browser to retrieve.
    /// This member is required.
    public var browserId: Swift.String?

    public init(
        browserId: Swift.String? = nil
    ) {
        self.browserId = browserId
    }
}

public struct GetBrowserOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the browser.
    /// This member is required.
    public var browserArn: Swift.String?
    /// The unique identifier of the browser.
    /// This member is required.
    public var browserId: Swift.String?
    /// The timestamp when the browser was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The description of the browser.
    public var description: Swift.String?
    /// The IAM role ARN that provides permissions for the browser.
    public var executionRoleArn: Swift.String?
    /// The reason for failure if the browser is in a failed state.
    public var failureReason: Swift.String?
    /// The timestamp when the browser was last updated.
    /// This member is required.
    public var lastUpdatedAt: Foundation.Date?
    /// The name of the browser.
    /// This member is required.
    public var name: Swift.String?
    /// The network configuration for a browser. This structure defines how the browser connects to the network.
    /// This member is required.
    public var networkConfiguration: BedrockAgentCoreControlClientTypes.BrowserNetworkConfiguration?
    /// The recording configuration for a browser. This structure defines how browser sessions are recorded.
    public var recording: BedrockAgentCoreControlClientTypes.RecordingConfig?
    /// The current status of the browser.
    /// This member is required.
    public var status: BedrockAgentCoreControlClientTypes.BrowserStatus?

    public init(
        browserArn: Swift.String? = nil,
        browserId: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        executionRoleArn: Swift.String? = nil,
        failureReason: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        networkConfiguration: BedrockAgentCoreControlClientTypes.BrowserNetworkConfiguration? = nil,
        recording: BedrockAgentCoreControlClientTypes.RecordingConfig? = nil,
        status: BedrockAgentCoreControlClientTypes.BrowserStatus? = nil
    ) {
        self.browserArn = browserArn
        self.browserId = browserId
        self.createdAt = createdAt
        self.description = description
        self.executionRoleArn = executionRoleArn
        self.failureReason = failureReason
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.networkConfiguration = networkConfiguration
        self.recording = recording
        self.status = status
    }
}

extension GetBrowserOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBrowserOutput(browserArn: \(Swift.String(describing: browserArn)), browserId: \(Swift.String(describing: browserId)), createdAt: \(Swift.String(describing: createdAt)), executionRoleArn: \(Swift.String(describing: executionRoleArn)), failureReason: \(Swift.String(describing: failureReason)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), name: \(Swift.String(describing: name)), networkConfiguration: \(Swift.String(describing: networkConfiguration)), recording: \(Swift.String(describing: recording)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentCoreControlClientTypes {

    public enum ResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case custom
        case system
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .custom,
                .system
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .custom: return "CUSTOM"
            case .system: return "SYSTEM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListBrowsersInput: Swift.Sendable {
    /// The maximum number of results to return in a single call. The default value is 10. The maximum value is 50.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The type of browsers to list. If not specified, all browser types are returned.
    public var type: BedrockAgentCoreControlClientTypes.ResourceType?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        type: BedrockAgentCoreControlClientTypes.ResourceType? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.type = type
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Contains summary information about a browser. A browser enables Amazon Bedrock Agent to interact with web content.
    public struct BrowserSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the browser.
        /// This member is required.
        public var browserArn: Swift.String?
        /// The unique identifier of the browser.
        /// This member is required.
        public var browserId: Swift.String?
        /// The timestamp when the browser was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The description of the browser.
        public var description: Swift.String?
        /// The timestamp when the browser was last updated.
        public var lastUpdatedAt: Foundation.Date?
        /// The name of the browser.
        public var name: Swift.String?
        /// The current status of the browser.
        /// This member is required.
        public var status: BedrockAgentCoreControlClientTypes.BrowserStatus?

        public init(
            browserArn: Swift.String? = nil,
            browserId: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            status: BedrockAgentCoreControlClientTypes.BrowserStatus? = nil
        ) {
            self.browserArn = browserArn
            self.browserId = browserId
            self.createdAt = createdAt
            self.description = description
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.status = status
        }
    }
}

extension BedrockAgentCoreControlClientTypes.BrowserSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BrowserSummary(browserArn: \(Swift.String(describing: browserArn)), browserId: \(Swift.String(describing: browserId)), createdAt: \(Swift.String(describing: createdAt)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\")"}
}

public struct ListBrowsersOutput: Swift.Sendable {
    /// The list of browser summaries.
    /// This member is required.
    public var browserSummaries: [BedrockAgentCoreControlClientTypes.BrowserSummary]?
    /// A token to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        browserSummaries: [BedrockAgentCoreControlClientTypes.BrowserSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.browserSummaries = browserSummaries
        self.nextToken = nextToken
    }
}

extension BedrockAgentCoreControlClientTypes {

    public enum CodeInterpreterNetworkMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `public`
        case sandbox
        case vpc
        case sdkUnknown(Swift.String)

        public static var allCases: [CodeInterpreterNetworkMode] {
            return [
                .public,
                .sandbox,
                .vpc
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .public: return "PUBLIC"
            case .sandbox: return "SANDBOX"
            case .vpc: return "VPC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// The network configuration for a code interpreter. This structure defines how the code interpreter connects to the network.
    public struct CodeInterpreterNetworkConfiguration: Swift.Sendable {
        /// The network mode for the code interpreter. This field specifies how the code interpreter connects to the network.
        /// This member is required.
        public var networkMode: BedrockAgentCoreControlClientTypes.CodeInterpreterNetworkMode?
        /// VpcConfig for the Agent.
        public var vpcConfig: BedrockAgentCoreControlClientTypes.VpcConfig?

        public init(
            networkMode: BedrockAgentCoreControlClientTypes.CodeInterpreterNetworkMode? = .sandbox,
            vpcConfig: BedrockAgentCoreControlClientTypes.VpcConfig? = nil
        ) {
            self.networkMode = networkMode
            self.vpcConfig = vpcConfig
        }
    }
}

public struct CreateCodeInterpreterInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure that the operation completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request but does not return an error.
    public var clientToken: Swift.String?
    /// The description of the code interpreter.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role that provides permissions for the code interpreter to access Amazon Web Services services.
    public var executionRoleArn: Swift.String?
    /// The name of the code interpreter. The name must be unique within your account.
    /// This member is required.
    public var name: Swift.String?
    /// The network configuration for the code interpreter. This configuration specifies the network mode for the code interpreter.
    /// This member is required.
    public var networkConfiguration: BedrockAgentCoreControlClientTypes.CodeInterpreterNetworkConfiguration?
    /// A map of tag keys and values to assign to the code interpreter. Tags enable you to categorize your resources in different ways, for example, by purpose, owner, or environment.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        executionRoleArn: Swift.String? = nil,
        name: Swift.String? = nil,
        networkConfiguration: BedrockAgentCoreControlClientTypes.CodeInterpreterNetworkConfiguration? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.clientToken = clientToken
        self.description = description
        self.executionRoleArn = executionRoleArn
        self.name = name
        self.networkConfiguration = networkConfiguration
        self.tags = tags
    }
}

extension CreateCodeInterpreterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCodeInterpreterInput(clientToken: \(Swift.String(describing: clientToken)), executionRoleArn: \(Swift.String(describing: executionRoleArn)), name: \(Swift.String(describing: name)), networkConfiguration: \(Swift.String(describing: networkConfiguration)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentCoreControlClientTypes {

    public enum CodeInterpreterStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createFailed
        case creating
        case deleted
        case deleteFailed
        case deleting
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [CodeInterpreterStatus] {
            return [
                .createFailed,
                .creating,
                .deleted,
                .deleteFailed,
                .deleting,
                .ready
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleting: return "DELETING"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateCodeInterpreterOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the created code interpreter.
    /// This member is required.
    public var codeInterpreterArn: Swift.String?
    /// The unique identifier of the created code interpreter.
    /// This member is required.
    public var codeInterpreterId: Swift.String?
    /// The timestamp when the code interpreter was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The current status of the code interpreter.
    /// This member is required.
    public var status: BedrockAgentCoreControlClientTypes.CodeInterpreterStatus?

    public init(
        codeInterpreterArn: Swift.String? = nil,
        codeInterpreterId: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        status: BedrockAgentCoreControlClientTypes.CodeInterpreterStatus? = nil
    ) {
        self.codeInterpreterArn = codeInterpreterArn
        self.codeInterpreterId = codeInterpreterId
        self.createdAt = createdAt
        self.status = status
    }
}

public struct DeleteCodeInterpreterInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// The unique identifier of the code interpreter to delete.
    /// This member is required.
    public var codeInterpreterId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        codeInterpreterId: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.codeInterpreterId = codeInterpreterId
    }
}

public struct DeleteCodeInterpreterOutput: Swift.Sendable {
    /// The unique identifier of the deleted code interpreter.
    /// This member is required.
    public var codeInterpreterId: Swift.String?
    /// The timestamp when the code interpreter was last updated.
    /// This member is required.
    public var lastUpdatedAt: Foundation.Date?
    /// The current status of the code interpreter deletion.
    /// This member is required.
    public var status: BedrockAgentCoreControlClientTypes.CodeInterpreterStatus?

    public init(
        codeInterpreterId: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        status: BedrockAgentCoreControlClientTypes.CodeInterpreterStatus? = nil
    ) {
        self.codeInterpreterId = codeInterpreterId
        self.lastUpdatedAt = lastUpdatedAt
        self.status = status
    }
}

public struct GetCodeInterpreterInput: Swift.Sendable {
    /// The unique identifier of the code interpreter to retrieve.
    /// This member is required.
    public var codeInterpreterId: Swift.String?

    public init(
        codeInterpreterId: Swift.String? = nil
    ) {
        self.codeInterpreterId = codeInterpreterId
    }
}

public struct GetCodeInterpreterOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the code interpreter.
    /// This member is required.
    public var codeInterpreterArn: Swift.String?
    /// The unique identifier of the code interpreter.
    /// This member is required.
    public var codeInterpreterId: Swift.String?
    /// The timestamp when the code interpreter was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The description of the code interpreter.
    public var description: Swift.String?
    /// The IAM role ARN that provides permissions for the code interpreter.
    public var executionRoleArn: Swift.String?
    /// The reason for failure if the code interpreter is in a failed state.
    public var failureReason: Swift.String?
    /// The timestamp when the code interpreter was last updated.
    /// This member is required.
    public var lastUpdatedAt: Foundation.Date?
    /// The name of the code interpreter.
    /// This member is required.
    public var name: Swift.String?
    /// The network configuration for a code interpreter. This structure defines how the code interpreter connects to the network.
    /// This member is required.
    public var networkConfiguration: BedrockAgentCoreControlClientTypes.CodeInterpreterNetworkConfiguration?
    /// The current status of the code interpreter.
    /// This member is required.
    public var status: BedrockAgentCoreControlClientTypes.CodeInterpreterStatus?

    public init(
        codeInterpreterArn: Swift.String? = nil,
        codeInterpreterId: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        executionRoleArn: Swift.String? = nil,
        failureReason: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        networkConfiguration: BedrockAgentCoreControlClientTypes.CodeInterpreterNetworkConfiguration? = nil,
        status: BedrockAgentCoreControlClientTypes.CodeInterpreterStatus? = nil
    ) {
        self.codeInterpreterArn = codeInterpreterArn
        self.codeInterpreterId = codeInterpreterId
        self.createdAt = createdAt
        self.description = description
        self.executionRoleArn = executionRoleArn
        self.failureReason = failureReason
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.networkConfiguration = networkConfiguration
        self.status = status
    }
}

extension GetCodeInterpreterOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCodeInterpreterOutput(codeInterpreterArn: \(Swift.String(describing: codeInterpreterArn)), codeInterpreterId: \(Swift.String(describing: codeInterpreterId)), createdAt: \(Swift.String(describing: createdAt)), executionRoleArn: \(Swift.String(describing: executionRoleArn)), failureReason: \(Swift.String(describing: failureReason)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), name: \(Swift.String(describing: name)), networkConfiguration: \(Swift.String(describing: networkConfiguration)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\")"}
}

public struct ListCodeInterpretersInput: Swift.Sendable {
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The type of code interpreters to list.
    public var type: BedrockAgentCoreControlClientTypes.ResourceType?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        type: BedrockAgentCoreControlClientTypes.ResourceType? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.type = type
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Contains summary information about a code interpreter. A code interpreter enables Amazon Bedrock Agent to execute code.
    public struct CodeInterpreterSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the code interpreter.
        /// This member is required.
        public var codeInterpreterArn: Swift.String?
        /// The unique identifier of the code interpreter.
        /// This member is required.
        public var codeInterpreterId: Swift.String?
        /// The timestamp when the code interpreter was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The description of the code interpreter.
        public var description: Swift.String?
        /// The timestamp when the code interpreter was last updated.
        public var lastUpdatedAt: Foundation.Date?
        /// The name of the code interpreter.
        public var name: Swift.String?
        /// The current status of the code interpreter.
        /// This member is required.
        public var status: BedrockAgentCoreControlClientTypes.CodeInterpreterStatus?

        public init(
            codeInterpreterArn: Swift.String? = nil,
            codeInterpreterId: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            status: BedrockAgentCoreControlClientTypes.CodeInterpreterStatus? = nil
        ) {
            self.codeInterpreterArn = codeInterpreterArn
            self.codeInterpreterId = codeInterpreterId
            self.createdAt = createdAt
            self.description = description
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.status = status
        }
    }
}

extension BedrockAgentCoreControlClientTypes.CodeInterpreterSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CodeInterpreterSummary(codeInterpreterArn: \(Swift.String(describing: codeInterpreterArn)), codeInterpreterId: \(Swift.String(describing: codeInterpreterId)), createdAt: \(Swift.String(describing: createdAt)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\")"}
}

public struct ListCodeInterpretersOutput: Swift.Sendable {
    /// The list of code interpreter summaries.
    /// This member is required.
    public var codeInterpreterSummaries: [BedrockAgentCoreControlClientTypes.CodeInterpreterSummary]?
    /// A token to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        codeInterpreterSummaries: [BedrockAgentCoreControlClientTypes.CodeInterpreterSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.codeInterpreterSummaries = codeInterpreterSummaries
        self.nextToken = nextToken
    }
}

extension BedrockAgentCoreControlClientTypes {

    public enum AuthorizerType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case customJwt
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthorizerType] {
            return [
                .customJwt
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .customJwt: return "CUSTOM_JWT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    public enum ExceptionLevel: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case debug
        case sdkUnknown(Swift.String)

        public static var allCases: [ExceptionLevel] {
            return [
                .debug
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .debug: return "DEBUG"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    public enum SearchType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case semantic
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchType] {
            return [
                .semantic
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .semantic: return "SEMANTIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// The configuration for a Model Context Protocol (MCP) gateway. This structure defines how the gateway implements the MCP protocol.
    public struct MCPGatewayConfiguration: Swift.Sendable {
        /// The instructions for using the Model Context Protocol gateway. These instructions provide guidance on how to interact with the gateway.
        public var instructions: Swift.String?
        /// The search type for the Model Context Protocol gateway. This field specifies how the gateway handles search operations.
        public var searchType: BedrockAgentCoreControlClientTypes.SearchType?
        /// The supported versions of the Model Context Protocol. This field specifies which versions of the protocol the gateway can use.
        public var supportedVersions: [Swift.String]?

        public init(
            instructions: Swift.String? = nil,
            searchType: BedrockAgentCoreControlClientTypes.SearchType? = nil,
            supportedVersions: [Swift.String]? = nil
        ) {
            self.instructions = instructions
            self.searchType = searchType
            self.supportedVersions = supportedVersions
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// The configuration for a gateway protocol. This structure defines how the gateway communicates with external services.
    public enum GatewayProtocolConfiguration: Swift.Sendable {
        /// The configuration for the Model Context Protocol (MCP). This protocol enables communication between Amazon Bedrock Agent and external tools.
        case mcp(BedrockAgentCoreControlClientTypes.MCPGatewayConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentCoreControlClientTypes {

    public enum GatewayProtocolType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case mcp
        case sdkUnknown(Swift.String)

        public static var allCases: [GatewayProtocolType] {
            return [
                .mcp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .mcp: return "MCP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateGatewayInput: Swift.Sendable {
    /// The authorizer configuration for the gateway.
    /// This member is required.
    public var authorizerConfiguration: BedrockAgentCoreControlClientTypes.AuthorizerConfiguration?
    /// The type of authorizer to use for the gateway.
    /// This member is required.
    public var authorizerType: BedrockAgentCoreControlClientTypes.AuthorizerType?
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, the service ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// The description of the gateway.
    public var description: Swift.String?
    /// The level of detail in error messages returned when invoking the gateway.
    ///
    /// * If the value is DEBUG, granular exception messages are returned to help a user debug the gateway.
    ///
    /// * If the value is omitted, a generic error message is returned to the end user.
    public var exceptionLevel: BedrockAgentCoreControlClientTypes.ExceptionLevel?
    /// The Amazon Resource Name (ARN) of the KMS key used to encrypt data associated with the gateway.
    public var kmsKeyArn: Swift.String?
    /// The name of the gateway. The name must be unique within your account.
    /// This member is required.
    public var name: Swift.String?
    /// The configuration settings for the protocol specified in the protocolType parameter.
    public var protocolConfiguration: BedrockAgentCoreControlClientTypes.GatewayProtocolConfiguration?
    /// The protocol type for the gateway.
    /// This member is required.
    public var protocolType: BedrockAgentCoreControlClientTypes.GatewayProtocolType?
    /// The Amazon Resource Name (ARN) of the IAM role that provides permissions for the gateway to access Amazon Web Services services.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A map of key-value pairs to associate with the gateway as metadata tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        authorizerConfiguration: BedrockAgentCoreControlClientTypes.AuthorizerConfiguration? = nil,
        authorizerType: BedrockAgentCoreControlClientTypes.AuthorizerType? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        exceptionLevel: BedrockAgentCoreControlClientTypes.ExceptionLevel? = nil,
        kmsKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        protocolConfiguration: BedrockAgentCoreControlClientTypes.GatewayProtocolConfiguration? = nil,
        protocolType: BedrockAgentCoreControlClientTypes.GatewayProtocolType? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.authorizerConfiguration = authorizerConfiguration
        self.authorizerType = authorizerType
        self.clientToken = clientToken
        self.description = description
        self.exceptionLevel = exceptionLevel
        self.kmsKeyArn = kmsKeyArn
        self.name = name
        self.protocolConfiguration = protocolConfiguration
        self.protocolType = protocolType
        self.roleArn = roleArn
        self.tags = tags
    }
}

extension CreateGatewayInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGatewayInput(authorizerConfiguration: \(Swift.String(describing: authorizerConfiguration)), authorizerType: \(Swift.String(describing: authorizerType)), clientToken: \(Swift.String(describing: clientToken)), exceptionLevel: \(Swift.String(describing: exceptionLevel)), kmsKeyArn: \(Swift.String(describing: kmsKeyArn)), protocolConfiguration: \(Swift.String(describing: protocolConfiguration)), protocolType: \(Swift.String(describing: protocolType)), roleArn: \(Swift.String(describing: roleArn)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentCoreControlClientTypes {

    public enum GatewayStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creating
        case deleting
        case failed
        case ready
        case updateUnsuccessful
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [GatewayStatus] {
            return [
                .creating,
                .deleting,
                .failed,
                .ready,
                .updateUnsuccessful,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .ready: return "READY"
            case .updateUnsuccessful: return "UPDATE_UNSUCCESSFUL"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateGatewayOutput: Swift.Sendable {
    /// The authorizer configuration for the created gateway.
    public var authorizerConfiguration: BedrockAgentCoreControlClientTypes.AuthorizerConfiguration?
    /// The type of authorizer used by the gateway.
    /// This member is required.
    public var authorizerType: BedrockAgentCoreControlClientTypes.AuthorizerType?
    /// The timestamp when the gateway was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The description of the gateway.
    public var description: Swift.String?
    /// The level of detail in error messages returned when invoking the gateway.
    ///
    /// * If the value is DEBUG, granular exception messages are returned to help a user debug the gateway.
    ///
    /// * If the value is omitted, a generic error message is returned to the end user.
    public var exceptionLevel: BedrockAgentCoreControlClientTypes.ExceptionLevel?
    /// The Amazon Resource Name (ARN) of the created gateway.
    /// This member is required.
    public var gatewayArn: Swift.String?
    /// The unique identifier of the created gateway.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// The URL endpoint for the created gateway.
    public var gatewayUrl: Swift.String?
    /// The Amazon Resource Name (ARN) of the KMS key used to encrypt data associated with the gateway.
    public var kmsKeyArn: Swift.String?
    /// The name of the gateway.
    /// This member is required.
    public var name: Swift.String?
    /// The configuration settings for the protocol used by the gateway.
    public var protocolConfiguration: BedrockAgentCoreControlClientTypes.GatewayProtocolConfiguration?
    /// The protocol type of the gateway.
    /// This member is required.
    public var protocolType: BedrockAgentCoreControlClientTypes.GatewayProtocolType?
    /// The Amazon Resource Name (ARN) of the IAM role associated with the gateway.
    public var roleArn: Swift.String?
    /// The current status of the gateway.
    /// This member is required.
    public var status: BedrockAgentCoreControlClientTypes.GatewayStatus?
    /// The reasons for the current status of the gateway.
    public var statusReasons: [Swift.String]?
    /// The timestamp when the gateway was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// The workload identity details for the created gateway.
    public var workloadIdentityDetails: BedrockAgentCoreControlClientTypes.WorkloadIdentityDetails?

    public init(
        authorizerConfiguration: BedrockAgentCoreControlClientTypes.AuthorizerConfiguration? = nil,
        authorizerType: BedrockAgentCoreControlClientTypes.AuthorizerType? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        exceptionLevel: BedrockAgentCoreControlClientTypes.ExceptionLevel? = nil,
        gatewayArn: Swift.String? = nil,
        gatewayId: Swift.String? = nil,
        gatewayUrl: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        protocolConfiguration: BedrockAgentCoreControlClientTypes.GatewayProtocolConfiguration? = nil,
        protocolType: BedrockAgentCoreControlClientTypes.GatewayProtocolType? = nil,
        roleArn: Swift.String? = nil,
        status: BedrockAgentCoreControlClientTypes.GatewayStatus? = nil,
        statusReasons: [Swift.String]? = nil,
        updatedAt: Foundation.Date? = nil,
        workloadIdentityDetails: BedrockAgentCoreControlClientTypes.WorkloadIdentityDetails? = nil
    ) {
        self.authorizerConfiguration = authorizerConfiguration
        self.authorizerType = authorizerType
        self.createdAt = createdAt
        self.description = description
        self.exceptionLevel = exceptionLevel
        self.gatewayArn = gatewayArn
        self.gatewayId = gatewayId
        self.gatewayUrl = gatewayUrl
        self.kmsKeyArn = kmsKeyArn
        self.name = name
        self.protocolConfiguration = protocolConfiguration
        self.protocolType = protocolType
        self.roleArn = roleArn
        self.status = status
        self.statusReasons = statusReasons
        self.updatedAt = updatedAt
        self.workloadIdentityDetails = workloadIdentityDetails
    }
}

extension CreateGatewayOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGatewayOutput(authorizerConfiguration: \(Swift.String(describing: authorizerConfiguration)), authorizerType: \(Swift.String(describing: authorizerType)), createdAt: \(Swift.String(describing: createdAt)), exceptionLevel: \(Swift.String(describing: exceptionLevel)), gatewayArn: \(Swift.String(describing: gatewayArn)), gatewayId: \(Swift.String(describing: gatewayId)), gatewayUrl: \(Swift.String(describing: gatewayUrl)), kmsKeyArn: \(Swift.String(describing: kmsKeyArn)), protocolConfiguration: \(Swift.String(describing: protocolConfiguration)), protocolType: \(Swift.String(describing: protocolType)), roleArn: \(Swift.String(describing: roleArn)), status: \(Swift.String(describing: status)), statusReasons: \(Swift.String(describing: statusReasons)), updatedAt: \(Swift.String(describing: updatedAt)), workloadIdentityDetails: \(Swift.String(describing: workloadIdentityDetails)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct DeleteGatewayInput: Swift.Sendable {
    /// The identifier of the gateway to delete.
    /// This member is required.
    public var gatewayIdentifier: Swift.String?

    public init(
        gatewayIdentifier: Swift.String? = nil
    ) {
        self.gatewayIdentifier = gatewayIdentifier
    }
}

public struct DeleteGatewayOutput: Swift.Sendable {
    /// The unique identifier of the deleted gateway.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// The current status of the gateway deletion.
    /// This member is required.
    public var status: BedrockAgentCoreControlClientTypes.GatewayStatus?
    /// The reasons for the current status of the gateway deletion.
    public var statusReasons: [Swift.String]?

    public init(
        gatewayId: Swift.String? = nil,
        status: BedrockAgentCoreControlClientTypes.GatewayStatus? = nil,
        statusReasons: [Swift.String]? = nil
    ) {
        self.gatewayId = gatewayId
        self.status = status
        self.statusReasons = statusReasons
    }
}

public struct GetGatewayInput: Swift.Sendable {
    /// The identifier of the gateway to retrieve.
    /// This member is required.
    public var gatewayIdentifier: Swift.String?

    public init(
        gatewayIdentifier: Swift.String? = nil
    ) {
        self.gatewayIdentifier = gatewayIdentifier
    }
}

public struct GetGatewayOutput: Swift.Sendable {
    /// The authorizer configuration for the gateway.
    public var authorizerConfiguration: BedrockAgentCoreControlClientTypes.AuthorizerConfiguration?
    /// Authorizer type for the gateway.
    /// This member is required.
    public var authorizerType: BedrockAgentCoreControlClientTypes.AuthorizerType?
    /// The timestamp when the gateway was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The description of the gateway.
    public var description: Swift.String?
    /// The level of detail in error messages returned when invoking the gateway.
    ///
    /// * If the value is DEBUG, granular exception messages are returned to help a user debug the gateway.
    ///
    /// * If the value is omitted, a generic error message is returned to the end user.
    public var exceptionLevel: BedrockAgentCoreControlClientTypes.ExceptionLevel?
    /// The Amazon Resource Name (ARN) of the gateway.
    /// This member is required.
    public var gatewayArn: Swift.String?
    /// The unique identifier of the gateway.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// An endpoint for invoking gateway.
    public var gatewayUrl: Swift.String?
    /// The Amazon Resource Name (ARN) of the KMS key used to encrypt the gateway.
    public var kmsKeyArn: Swift.String?
    /// The name of the gateway.
    /// This member is required.
    public var name: Swift.String?
    /// The configuration for a gateway protocol. This structure defines how the gateway communicates with external services.
    public var protocolConfiguration: BedrockAgentCoreControlClientTypes.GatewayProtocolConfiguration?
    /// Protocol applied to a gateway.
    /// This member is required.
    public var protocolType: BedrockAgentCoreControlClientTypes.GatewayProtocolType?
    /// The IAM role ARN that provides permissions for the gateway.
    public var roleArn: Swift.String?
    /// The current status of the gateway.
    /// This member is required.
    public var status: BedrockAgentCoreControlClientTypes.GatewayStatus?
    /// The reasons for the current status of the gateway.
    public var statusReasons: [Swift.String]?
    /// The timestamp when the gateway was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// The workload identity details for the gateway.
    public var workloadIdentityDetails: BedrockAgentCoreControlClientTypes.WorkloadIdentityDetails?

    public init(
        authorizerConfiguration: BedrockAgentCoreControlClientTypes.AuthorizerConfiguration? = nil,
        authorizerType: BedrockAgentCoreControlClientTypes.AuthorizerType? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        exceptionLevel: BedrockAgentCoreControlClientTypes.ExceptionLevel? = nil,
        gatewayArn: Swift.String? = nil,
        gatewayId: Swift.String? = nil,
        gatewayUrl: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        protocolConfiguration: BedrockAgentCoreControlClientTypes.GatewayProtocolConfiguration? = nil,
        protocolType: BedrockAgentCoreControlClientTypes.GatewayProtocolType? = nil,
        roleArn: Swift.String? = nil,
        status: BedrockAgentCoreControlClientTypes.GatewayStatus? = nil,
        statusReasons: [Swift.String]? = nil,
        updatedAt: Foundation.Date? = nil,
        workloadIdentityDetails: BedrockAgentCoreControlClientTypes.WorkloadIdentityDetails? = nil
    ) {
        self.authorizerConfiguration = authorizerConfiguration
        self.authorizerType = authorizerType
        self.createdAt = createdAt
        self.description = description
        self.exceptionLevel = exceptionLevel
        self.gatewayArn = gatewayArn
        self.gatewayId = gatewayId
        self.gatewayUrl = gatewayUrl
        self.kmsKeyArn = kmsKeyArn
        self.name = name
        self.protocolConfiguration = protocolConfiguration
        self.protocolType = protocolType
        self.roleArn = roleArn
        self.status = status
        self.statusReasons = statusReasons
        self.updatedAt = updatedAt
        self.workloadIdentityDetails = workloadIdentityDetails
    }
}

extension GetGatewayOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetGatewayOutput(authorizerConfiguration: \(Swift.String(describing: authorizerConfiguration)), authorizerType: \(Swift.String(describing: authorizerType)), createdAt: \(Swift.String(describing: createdAt)), exceptionLevel: \(Swift.String(describing: exceptionLevel)), gatewayArn: \(Swift.String(describing: gatewayArn)), gatewayId: \(Swift.String(describing: gatewayId)), gatewayUrl: \(Swift.String(describing: gatewayUrl)), kmsKeyArn: \(Swift.String(describing: kmsKeyArn)), protocolConfiguration: \(Swift.String(describing: protocolConfiguration)), protocolType: \(Swift.String(describing: protocolType)), roleArn: \(Swift.String(describing: roleArn)), status: \(Swift.String(describing: status)), statusReasons: \(Swift.String(describing: statusReasons)), updatedAt: \(Swift.String(describing: updatedAt)), workloadIdentityDetails: \(Swift.String(describing: workloadIdentityDetails)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct ListGatewaysInput: Swift.Sendable {
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Contains summary information about a gateway.
    public struct GatewaySummary: Swift.Sendable {
        /// The type of authorizer used by the gateway.
        /// This member is required.
        public var authorizerType: BedrockAgentCoreControlClientTypes.AuthorizerType?
        /// The timestamp when the gateway was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The description of the gateway.
        public var description: Swift.String?
        /// The unique identifier of the gateway.
        /// This member is required.
        public var gatewayId: Swift.String?
        /// The name of the gateway.
        /// This member is required.
        public var name: Swift.String?
        /// The protocol type used by the gateway.
        /// This member is required.
        public var protocolType: BedrockAgentCoreControlClientTypes.GatewayProtocolType?
        /// The current status of the gateway.
        /// This member is required.
        public var status: BedrockAgentCoreControlClientTypes.GatewayStatus?
        /// The timestamp when the gateway was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            authorizerType: BedrockAgentCoreControlClientTypes.AuthorizerType? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            gatewayId: Swift.String? = nil,
            name: Swift.String? = nil,
            protocolType: BedrockAgentCoreControlClientTypes.GatewayProtocolType? = nil,
            status: BedrockAgentCoreControlClientTypes.GatewayStatus? = nil,
            updatedAt: Foundation.Date? = nil
        ) {
            self.authorizerType = authorizerType
            self.createdAt = createdAt
            self.description = description
            self.gatewayId = gatewayId
            self.name = name
            self.protocolType = protocolType
            self.status = status
            self.updatedAt = updatedAt
        }
    }
}

extension BedrockAgentCoreControlClientTypes.GatewaySummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GatewaySummary(authorizerType: \(Swift.String(describing: authorizerType)), createdAt: \(Swift.String(describing: createdAt)), gatewayId: \(Swift.String(describing: gatewayId)), protocolType: \(Swift.String(describing: protocolType)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct ListGatewaysOutput: Swift.Sendable {
    /// The list of gateway summaries.
    /// This member is required.
    public var items: [BedrockAgentCoreControlClientTypes.GatewaySummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        items: [BedrockAgentCoreControlClientTypes.GatewaySummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct UpdateGatewayInput: Swift.Sendable {
    /// The updated authorizer configuration for the gateway.
    /// This member is required.
    public var authorizerConfiguration: BedrockAgentCoreControlClientTypes.AuthorizerConfiguration?
    /// The updated authorizer type for the gateway.
    /// This member is required.
    public var authorizerType: BedrockAgentCoreControlClientTypes.AuthorizerType?
    /// The updated description for the gateway.
    public var description: Swift.String?
    /// The level of detail in error messages returned when invoking the gateway.
    ///
    /// * If the value is DEBUG, granular exception messages are returned to help a user debug the gateway.
    ///
    /// * If the value is omitted, a generic error message is returned to the end user.
    public var exceptionLevel: BedrockAgentCoreControlClientTypes.ExceptionLevel?
    /// The identifier of the gateway to update.
    /// This member is required.
    public var gatewayIdentifier: Swift.String?
    /// The updated ARN of the KMS key used to encrypt the gateway.
    public var kmsKeyArn: Swift.String?
    /// The name of the gateway. This name must be the same as the one when the gateway was created.
    /// This member is required.
    public var name: Swift.String?
    /// The configuration for a gateway protocol. This structure defines how the gateway communicates with external services.
    public var protocolConfiguration: BedrockAgentCoreControlClientTypes.GatewayProtocolConfiguration?
    /// The updated protocol type for the gateway.
    /// This member is required.
    public var protocolType: BedrockAgentCoreControlClientTypes.GatewayProtocolType?
    /// The updated IAM role ARN that provides permissions for the gateway.
    /// This member is required.
    public var roleArn: Swift.String?

    public init(
        authorizerConfiguration: BedrockAgentCoreControlClientTypes.AuthorizerConfiguration? = nil,
        authorizerType: BedrockAgentCoreControlClientTypes.AuthorizerType? = nil,
        description: Swift.String? = nil,
        exceptionLevel: BedrockAgentCoreControlClientTypes.ExceptionLevel? = nil,
        gatewayIdentifier: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        protocolConfiguration: BedrockAgentCoreControlClientTypes.GatewayProtocolConfiguration? = nil,
        protocolType: BedrockAgentCoreControlClientTypes.GatewayProtocolType? = nil,
        roleArn: Swift.String? = nil
    ) {
        self.authorizerConfiguration = authorizerConfiguration
        self.authorizerType = authorizerType
        self.description = description
        self.exceptionLevel = exceptionLevel
        self.gatewayIdentifier = gatewayIdentifier
        self.kmsKeyArn = kmsKeyArn
        self.name = name
        self.protocolConfiguration = protocolConfiguration
        self.protocolType = protocolType
        self.roleArn = roleArn
    }
}

extension UpdateGatewayInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGatewayInput(authorizerConfiguration: \(Swift.String(describing: authorizerConfiguration)), authorizerType: \(Swift.String(describing: authorizerType)), exceptionLevel: \(Swift.String(describing: exceptionLevel)), gatewayIdentifier: \(Swift.String(describing: gatewayIdentifier)), kmsKeyArn: \(Swift.String(describing: kmsKeyArn)), protocolConfiguration: \(Swift.String(describing: protocolConfiguration)), protocolType: \(Swift.String(describing: protocolType)), roleArn: \(Swift.String(describing: roleArn)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct UpdateGatewayOutput: Swift.Sendable {
    /// The updated authorizer configuration for the gateway.
    public var authorizerConfiguration: BedrockAgentCoreControlClientTypes.AuthorizerConfiguration?
    /// The updated authorizer type for the gateway.
    /// This member is required.
    public var authorizerType: BedrockAgentCoreControlClientTypes.AuthorizerType?
    /// The timestamp when the gateway was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The updated description of the gateway.
    public var description: Swift.String?
    /// The level of detail in error messages returned when invoking the gateway.
    ///
    /// * If the value is DEBUG, granular exception messages are returned to help a user debug the gateway.
    ///
    /// * If the value is omitted, a generic error message is returned to the end user.
    public var exceptionLevel: BedrockAgentCoreControlClientTypes.ExceptionLevel?
    /// The Amazon Resource Name (ARN) of the updated gateway.
    /// This member is required.
    public var gatewayArn: Swift.String?
    /// The unique identifier of the updated gateway.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// An endpoint for invoking the updated gateway.
    public var gatewayUrl: Swift.String?
    /// The updated ARN of the KMS key used to encrypt the gateway.
    public var kmsKeyArn: Swift.String?
    /// The name of the gateway.
    /// This member is required.
    public var name: Swift.String?
    /// The configuration for a gateway protocol. This structure defines how the gateway communicates with external services.
    public var protocolConfiguration: BedrockAgentCoreControlClientTypes.GatewayProtocolConfiguration?
    /// The updated protocol type for the gateway.
    /// This member is required.
    public var protocolType: BedrockAgentCoreControlClientTypes.GatewayProtocolType?
    /// The updated IAM role ARN that provides permissions for the gateway.
    public var roleArn: Swift.String?
    /// The current status of the updated gateway.
    /// This member is required.
    public var status: BedrockAgentCoreControlClientTypes.GatewayStatus?
    /// The reasons for the current status of the updated gateway.
    public var statusReasons: [Swift.String]?
    /// The timestamp when the gateway was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// The workload identity details for the updated gateway.
    public var workloadIdentityDetails: BedrockAgentCoreControlClientTypes.WorkloadIdentityDetails?

    public init(
        authorizerConfiguration: BedrockAgentCoreControlClientTypes.AuthorizerConfiguration? = nil,
        authorizerType: BedrockAgentCoreControlClientTypes.AuthorizerType? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        exceptionLevel: BedrockAgentCoreControlClientTypes.ExceptionLevel? = nil,
        gatewayArn: Swift.String? = nil,
        gatewayId: Swift.String? = nil,
        gatewayUrl: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        protocolConfiguration: BedrockAgentCoreControlClientTypes.GatewayProtocolConfiguration? = nil,
        protocolType: BedrockAgentCoreControlClientTypes.GatewayProtocolType? = nil,
        roleArn: Swift.String? = nil,
        status: BedrockAgentCoreControlClientTypes.GatewayStatus? = nil,
        statusReasons: [Swift.String]? = nil,
        updatedAt: Foundation.Date? = nil,
        workloadIdentityDetails: BedrockAgentCoreControlClientTypes.WorkloadIdentityDetails? = nil
    ) {
        self.authorizerConfiguration = authorizerConfiguration
        self.authorizerType = authorizerType
        self.createdAt = createdAt
        self.description = description
        self.exceptionLevel = exceptionLevel
        self.gatewayArn = gatewayArn
        self.gatewayId = gatewayId
        self.gatewayUrl = gatewayUrl
        self.kmsKeyArn = kmsKeyArn
        self.name = name
        self.protocolConfiguration = protocolConfiguration
        self.protocolType = protocolType
        self.roleArn = roleArn
        self.status = status
        self.statusReasons = statusReasons
        self.updatedAt = updatedAt
        self.workloadIdentityDetails = workloadIdentityDetails
    }
}

extension UpdateGatewayOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGatewayOutput(authorizerConfiguration: \(Swift.String(describing: authorizerConfiguration)), authorizerType: \(Swift.String(describing: authorizerType)), createdAt: \(Swift.String(describing: createdAt)), exceptionLevel: \(Swift.String(describing: exceptionLevel)), gatewayArn: \(Swift.String(describing: gatewayArn)), gatewayId: \(Swift.String(describing: gatewayId)), gatewayUrl: \(Swift.String(describing: gatewayUrl)), kmsKeyArn: \(Swift.String(describing: kmsKeyArn)), protocolConfiguration: \(Swift.String(describing: protocolConfiguration)), protocolType: \(Swift.String(describing: protocolType)), roleArn: \(Swift.String(describing: roleArn)), status: \(Swift.String(describing: status)), statusReasons: \(Swift.String(describing: statusReasons)), updatedAt: \(Swift.String(describing: updatedAt)), workloadIdentityDetails: \(Swift.String(describing: workloadIdentityDetails)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentCoreControlClientTypes {

    public enum ApiKeyCredentialLocation: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case header
        case queryParameter
        case sdkUnknown(Swift.String)

        public static var allCases: [ApiKeyCredentialLocation] {
            return [
                .header,
                .queryParameter
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .header: return "HEADER"
            case .queryParameter: return "QUERY_PARAMETER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// An API key credential provider for gateway authentication. This structure contains the configuration for authenticating with the target endpoint using an API key.
    public struct GatewayApiKeyCredentialProvider: Swift.Sendable {
        /// The location of the API key credential. This field specifies where in the request the API key should be placed.
        public var credentialLocation: BedrockAgentCoreControlClientTypes.ApiKeyCredentialLocation?
        /// The name of the credential parameter for the API key. This parameter name is used when sending the API key to the target endpoint.
        public var credentialParameterName: Swift.String?
        /// The prefix for the API key credential. This prefix is added to the API key when sending it to the target endpoint.
        public var credentialPrefix: Swift.String?
        /// The Amazon Resource Name (ARN) of the API key credential provider. This ARN identifies the provider in Amazon Web Services.
        /// This member is required.
        public var providerArn: Swift.String?

        public init(
            credentialLocation: BedrockAgentCoreControlClientTypes.ApiKeyCredentialLocation? = nil,
            credentialParameterName: Swift.String? = nil,
            credentialPrefix: Swift.String? = nil,
            providerArn: Swift.String? = nil
        ) {
            self.credentialLocation = credentialLocation
            self.credentialParameterName = credentialParameterName
            self.credentialPrefix = credentialPrefix
            self.providerArn = providerArn
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// An OAuth credential provider for gateway authentication. This structure contains the configuration for authenticating with the target endpoint using OAuth.
    public struct OAuthCredentialProvider: Swift.Sendable {
        /// The custom parameters for the OAuth credential provider. These parameters provide additional configuration for the OAuth authentication process.
        public var customParameters: [Swift.String: Swift.String]?
        /// The Amazon Resource Name (ARN) of the OAuth credential provider. This ARN identifies the provider in Amazon Web Services.
        /// This member is required.
        public var providerArn: Swift.String?
        /// The OAuth scopes for the credential provider. These scopes define the level of access requested from the OAuth provider.
        /// This member is required.
        public var scopes: [Swift.String]?

        public init(
            customParameters: [Swift.String: Swift.String]? = nil,
            providerArn: Swift.String? = nil,
            scopes: [Swift.String]? = nil
        ) {
            self.customParameters = customParameters
            self.providerArn = providerArn
            self.scopes = scopes
        }
    }
}

extension BedrockAgentCoreControlClientTypes.OAuthCredentialProvider: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OAuthCredentialProvider(providerArn: \(Swift.String(describing: providerArn)), scopes: \(Swift.String(describing: scopes)), customParameters: [keys: \(Swift.String(describing: customParameters?.keys)), values: \"CONTENT_REDACTED\"])"}
}

extension BedrockAgentCoreControlClientTypes {

    /// A credential provider for gateway authentication. This structure contains the configuration for authenticating with the target endpoint.
    public enum CredentialProvider: Swift.Sendable {
        /// The OAuth credential provider. This provider uses OAuth authentication to access the target endpoint.
        case oauthcredentialprovider(BedrockAgentCoreControlClientTypes.OAuthCredentialProvider)
        /// The API key credential provider. This provider uses an API key to authenticate with the target endpoint.
        case apikeycredentialprovider(BedrockAgentCoreControlClientTypes.GatewayApiKeyCredentialProvider)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentCoreControlClientTypes {

    public enum CredentialProviderType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case apiKey
        case gatewayIamRole
        case oauth
        case sdkUnknown(Swift.String)

        public static var allCases: [CredentialProviderType] {
            return [
                .apiKey,
                .gatewayIamRole,
                .oauth
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .apiKey: return "API_KEY"
            case .gatewayIamRole: return "GATEWAY_IAM_ROLE"
            case .oauth: return "OAUTH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// The configuration for a credential provider. This structure defines how the gateway authenticates with the target endpoint.
    public struct CredentialProviderConfiguration: Swift.Sendable {
        /// The credential provider. This field contains the specific configuration for the credential provider type.
        public var credentialProvider: BedrockAgentCoreControlClientTypes.CredentialProvider?
        /// The type of credential provider. This field specifies which authentication method the gateway uses.
        /// This member is required.
        public var credentialProviderType: BedrockAgentCoreControlClientTypes.CredentialProviderType?

        public init(
            credentialProvider: BedrockAgentCoreControlClientTypes.CredentialProvider? = nil,
            credentialProviderType: BedrockAgentCoreControlClientTypes.CredentialProviderType? = nil
        ) {
            self.credentialProvider = credentialProvider
            self.credentialProviderType = credentialProviderType
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    public enum SchemaType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case array
        case boolean
        case integer
        case number
        case object
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [SchemaType] {
            return [
                .array,
                .boolean,
                .integer,
                .number,
                .object,
                .string
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .array: return "array"
            case .boolean: return "boolean"
            case .integer: return "integer"
            case .number: return "number"
            case .object: return "object"
            case .string: return "string"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// The Amazon S3 configuration for a gateway. This structure defines how the gateway accesses files in Amazon S3.
    public struct S3Configuration: Swift.Sendable {
        /// The account ID of the Amazon S3 bucket owner. This ID is used for cross-account access to the bucket.
        public var bucketOwnerAccountId: Swift.String?
        /// The URI of the Amazon S3 object. This URI specifies the location of the object in Amazon S3.
        public var uri: Swift.String?

        public init(
            bucketOwnerAccountId: Swift.String? = nil,
            uri: Swift.String? = nil
        ) {
            self.bucketOwnerAccountId = bucketOwnerAccountId
            self.uri = uri
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Configuration for API schema.
    public enum ApiSchemaConfiguration: Swift.Sendable {
        /// The Amazon S3 configuration for a gateway. This structure defines how the gateway accesses files in Amazon S3.
        case s3(BedrockAgentCoreControlClientTypes.S3Configuration)
        /// The inline payload containing the API schema definition.
        case inlinepayload(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentCoreControlClientTypes {

    public enum TargetStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creating
        case deleting
        case failed
        case ready
        case updateUnsuccessful
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetStatus] {
            return [
                .creating,
                .deleting,
                .failed,
                .ready,
                .updateUnsuccessful,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .ready: return "READY"
            case .updateUnsuccessful: return "UPDATE_UNSUCCESSFUL"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DeleteGatewayTargetInput: Swift.Sendable {
    /// The unique identifier of the gateway associated with the target.
    /// This member is required.
    public var gatewayIdentifier: Swift.String?
    /// The unique identifier of the gateway target to delete.
    /// This member is required.
    public var targetId: Swift.String?

    public init(
        gatewayIdentifier: Swift.String? = nil,
        targetId: Swift.String? = nil
    ) {
        self.gatewayIdentifier = gatewayIdentifier
        self.targetId = targetId
    }
}

public struct DeleteGatewayTargetOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the gateway.
    /// This member is required.
    public var gatewayArn: Swift.String?
    /// The current status of the gateway target deletion.
    /// This member is required.
    public var status: BedrockAgentCoreControlClientTypes.TargetStatus?
    /// The reasons for the current status of the gateway target deletion.
    public var statusReasons: [Swift.String]?
    /// The unique identifier of the deleted gateway target.
    /// This member is required.
    public var targetId: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil,
        status: BedrockAgentCoreControlClientTypes.TargetStatus? = nil,
        statusReasons: [Swift.String]? = nil,
        targetId: Swift.String? = nil
    ) {
        self.gatewayArn = gatewayArn
        self.status = status
        self.statusReasons = statusReasons
        self.targetId = targetId
    }
}

public struct GetGatewayTargetInput: Swift.Sendable {
    /// The identifier of the gateway that contains the target.
    /// This member is required.
    public var gatewayIdentifier: Swift.String?
    /// The unique identifier of the target to retrieve.
    /// This member is required.
    public var targetId: Swift.String?

    public init(
        gatewayIdentifier: Swift.String? = nil,
        targetId: Swift.String? = nil
    ) {
        self.gatewayIdentifier = gatewayIdentifier
        self.targetId = targetId
    }
}

public struct ListGatewayTargetsInput: Swift.Sendable {
    /// The identifier of the gateway to list targets for.
    /// This member is required.
    public var gatewayIdentifier: Swift.String?
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        gatewayIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.gatewayIdentifier = gatewayIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Contains summary information about a gateway target. A target represents an endpoint that the gateway can connect to.
    public struct TargetSummary: Swift.Sendable {
        /// The timestamp when the target was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The description of the target.
        public var description: Swift.String?
        /// The name of the target.
        /// This member is required.
        public var name: Swift.String?
        /// The current status of the target.
        /// This member is required.
        public var status: BedrockAgentCoreControlClientTypes.TargetStatus?
        /// The unique identifier of the target.
        /// This member is required.
        public var targetId: Swift.String?
        /// The timestamp when the target was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            status: BedrockAgentCoreControlClientTypes.TargetStatus? = nil,
            targetId: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil
        ) {
            self.createdAt = createdAt
            self.description = description
            self.name = name
            self.status = status
            self.targetId = targetId
            self.updatedAt = updatedAt
        }
    }
}

extension BedrockAgentCoreControlClientTypes.TargetSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TargetSummary(createdAt: \(Swift.String(describing: createdAt)), status: \(Swift.String(describing: status)), targetId: \(Swift.String(describing: targetId)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct ListGatewayTargetsOutput: Swift.Sendable {
    /// The list of gateway target summaries.
    /// This member is required.
    public var items: [BedrockAgentCoreControlClientTypes.TargetSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        items: [BedrockAgentCoreControlClientTypes.TargetSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct GetTokenVaultInput: Swift.Sendable {
    /// The unique identifier of the token vault to retrieve.
    public var tokenVaultId: Swift.String?

    public init(
        tokenVaultId: Swift.String? = nil
    ) {
        self.tokenVaultId = tokenVaultId
    }
}

extension BedrockAgentCoreControlClientTypes {

    public enum KeyType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case customermanagedkey
        case servicemanagedkey
        case sdkUnknown(Swift.String)

        public static var allCases: [KeyType] {
            return [
                .customermanagedkey,
                .servicemanagedkey
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .customermanagedkey: return "CustomerManagedKey"
            case .servicemanagedkey: return "ServiceManagedKey"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Contains the KMS configuration for a resource.
    public struct KmsConfiguration: Swift.Sendable {
        /// The type of KMS key (CustomerManagedKey or ServiceManagedKey).
        /// This member is required.
        public var keyType: BedrockAgentCoreControlClientTypes.KeyType?
        /// The Amazon Resource Name (ARN) of the KMS key.
        public var kmsKeyArn: Swift.String?

        public init(
            keyType: BedrockAgentCoreControlClientTypes.KeyType? = nil,
            kmsKeyArn: Swift.String? = nil
        ) {
            self.keyType = keyType
            self.kmsKeyArn = kmsKeyArn
        }
    }
}

public struct GetTokenVaultOutput: Swift.Sendable {
    /// The KMS configuration for the token vault.
    /// This member is required.
    public var kmsConfiguration: BedrockAgentCoreControlClientTypes.KmsConfiguration?
    /// The timestamp when the token vault was last modified.
    /// This member is required.
    public var lastModifiedDate: Foundation.Date?
    /// The ID of the token vault.
    /// This member is required.
    public var tokenVaultId: Swift.String?

    public init(
        kmsConfiguration: BedrockAgentCoreControlClientTypes.KmsConfiguration? = nil,
        lastModifiedDate: Foundation.Date? = nil,
        tokenVaultId: Swift.String? = nil
    ) {
        self.kmsConfiguration = kmsConfiguration
        self.lastModifiedDate = lastModifiedDate
        self.tokenVaultId = tokenVaultId
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource for which you want to list tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    ) {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The tags associated with the resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.tags = tags
    }
}

/// An internal error occurred.
public struct ServiceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// API rate limit has been exceeded.
public struct ThrottledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottledException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Input for semantic override consolidation configuration in a memory strategy.
    public struct SemanticOverrideConsolidationConfigurationInput: Swift.Sendable {
        /// The text to append to the prompt for semantic consolidation.
        /// This member is required.
        public var appendToPrompt: Swift.String?
        /// The model ID to use for semantic consolidation.
        /// This member is required.
        public var modelId: Swift.String?

        public init(
            appendToPrompt: Swift.String? = nil,
            modelId: Swift.String? = nil
        ) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }
    }
}

extension BedrockAgentCoreControlClientTypes.SemanticOverrideConsolidationConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SemanticOverrideConsolidationConfigurationInput(modelId: \(Swift.String(describing: modelId)), appendToPrompt: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentCoreControlClientTypes {

    /// Input for semantic override extraction configuration in a memory strategy.
    public struct SemanticOverrideExtractionConfigurationInput: Swift.Sendable {
        /// The text to append to the prompt for semantic extraction.
        /// This member is required.
        public var appendToPrompt: Swift.String?
        /// The model ID to use for semantic extraction.
        /// This member is required.
        public var modelId: Swift.String?

        public init(
            appendToPrompt: Swift.String? = nil,
            modelId: Swift.String? = nil
        ) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }
    }
}

extension BedrockAgentCoreControlClientTypes.SemanticOverrideExtractionConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SemanticOverrideExtractionConfigurationInput(modelId: \(Swift.String(describing: modelId)), appendToPrompt: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentCoreControlClientTypes {

    /// Input for semantic override configuration in a memory strategy.
    public struct SemanticOverrideConfigurationInput: Swift.Sendable {
        /// The consolidation configuration for a semantic override.
        public var consolidation: BedrockAgentCoreControlClientTypes.SemanticOverrideConsolidationConfigurationInput?
        /// The extraction configuration for a semantic override.
        public var extraction: BedrockAgentCoreControlClientTypes.SemanticOverrideExtractionConfigurationInput?

        public init(
            consolidation: BedrockAgentCoreControlClientTypes.SemanticOverrideConsolidationConfigurationInput? = nil,
            extraction: BedrockAgentCoreControlClientTypes.SemanticOverrideExtractionConfigurationInput? = nil
        ) {
            self.consolidation = consolidation
            self.extraction = extraction
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Input for summary override consolidation configuration in a memory strategy.
    public struct SummaryOverrideConsolidationConfigurationInput: Swift.Sendable {
        /// The text to append to the prompt for summary consolidation.
        /// This member is required.
        public var appendToPrompt: Swift.String?
        /// The model ID to use for summary consolidation.
        /// This member is required.
        public var modelId: Swift.String?

        public init(
            appendToPrompt: Swift.String? = nil,
            modelId: Swift.String? = nil
        ) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }
    }
}

extension BedrockAgentCoreControlClientTypes.SummaryOverrideConsolidationConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SummaryOverrideConsolidationConfigurationInput(modelId: \(Swift.String(describing: modelId)), appendToPrompt: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentCoreControlClientTypes {

    /// Input for summary override configuration in a memory strategy.
    public struct SummaryOverrideConfigurationInput: Swift.Sendable {
        /// The consolidation configuration for a summary override.
        public var consolidation: BedrockAgentCoreControlClientTypes.SummaryOverrideConsolidationConfigurationInput?

        public init(
            consolidation: BedrockAgentCoreControlClientTypes.SummaryOverrideConsolidationConfigurationInput? = nil
        ) {
            self.consolidation = consolidation
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Input for user preference override consolidation configuration in a memory strategy.
    public struct UserPreferenceOverrideConsolidationConfigurationInput: Swift.Sendable {
        /// The text to append to the prompt for user preference consolidation.
        /// This member is required.
        public var appendToPrompt: Swift.String?
        /// The model ID to use for user preference consolidation.
        /// This member is required.
        public var modelId: Swift.String?

        public init(
            appendToPrompt: Swift.String? = nil,
            modelId: Swift.String? = nil
        ) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }
    }
}

extension BedrockAgentCoreControlClientTypes.UserPreferenceOverrideConsolidationConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserPreferenceOverrideConsolidationConfigurationInput(modelId: \(Swift.String(describing: modelId)), appendToPrompt: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentCoreControlClientTypes {

    /// Input for user preference override extraction configuration in a memory strategy.
    public struct UserPreferenceOverrideExtractionConfigurationInput: Swift.Sendable {
        /// The text to append to the prompt for user preference extraction.
        /// This member is required.
        public var appendToPrompt: Swift.String?
        /// The model ID to use for user preference extraction.
        /// This member is required.
        public var modelId: Swift.String?

        public init(
            appendToPrompt: Swift.String? = nil,
            modelId: Swift.String? = nil
        ) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }
    }
}

extension BedrockAgentCoreControlClientTypes.UserPreferenceOverrideExtractionConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserPreferenceOverrideExtractionConfigurationInput(modelId: \(Swift.String(describing: modelId)), appendToPrompt: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentCoreControlClientTypes {

    /// Input for user preference override configuration in a memory strategy.
    public struct UserPreferenceOverrideConfigurationInput: Swift.Sendable {
        /// The consolidation configuration for a user preference override.
        public var consolidation: BedrockAgentCoreControlClientTypes.UserPreferenceOverrideConsolidationConfigurationInput?
        /// The extraction configuration for a user preference override.
        public var extraction: BedrockAgentCoreControlClientTypes.UserPreferenceOverrideExtractionConfigurationInput?

        public init(
            consolidation: BedrockAgentCoreControlClientTypes.UserPreferenceOverrideConsolidationConfigurationInput? = nil,
            extraction: BedrockAgentCoreControlClientTypes.UserPreferenceOverrideExtractionConfigurationInput? = nil
        ) {
            self.consolidation = consolidation
            self.extraction = extraction
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Input for custom configuration of a memory strategy.
    public enum CustomConfigurationInput: Swift.Sendable {
        /// The semantic override configuration for a custom memory strategy.
        case semanticoverride(BedrockAgentCoreControlClientTypes.SemanticOverrideConfigurationInput)
        /// The summary override configuration for a custom memory strategy.
        case summaryoverride(BedrockAgentCoreControlClientTypes.SummaryOverrideConfigurationInput)
        /// The user preference override configuration for a custom memory strategy.
        case userpreferenceoverride(BedrockAgentCoreControlClientTypes.UserPreferenceOverrideConfigurationInput)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Input for creating a custom memory strategy.
    public struct CustomMemoryStrategyInput: Swift.Sendable {
        /// The configuration for the custom memory strategy.
        public var configuration: BedrockAgentCoreControlClientTypes.CustomConfigurationInput?
        /// The description of the custom memory strategy.
        public var description: Swift.String?
        /// The name of the custom memory strategy.
        /// This member is required.
        public var name: Swift.String?
        /// The namespaces associated with the custom memory strategy.
        public var namespaces: [Swift.String]?

        public init(
            configuration: BedrockAgentCoreControlClientTypes.CustomConfigurationInput? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            namespaces: [Swift.String]? = nil
        ) {
            self.configuration = configuration
            self.description = description
            self.name = name
            self.namespaces = namespaces
        }
    }
}

extension BedrockAgentCoreControlClientTypes.CustomMemoryStrategyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomMemoryStrategyInput(configuration: \(Swift.String(describing: configuration)), name: \(Swift.String(describing: name)), namespaces: \(Swift.String(describing: namespaces)), description: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentCoreControlClientTypes {

    /// Input for creating a semantic memory strategy.
    public struct SemanticMemoryStrategyInput: Swift.Sendable {
        /// The description of the semantic memory strategy.
        public var description: Swift.String?
        /// The name of the semantic memory strategy.
        /// This member is required.
        public var name: Swift.String?
        /// The namespaces associated with the semantic memory strategy.
        public var namespaces: [Swift.String]?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            namespaces: [Swift.String]? = nil
        ) {
            self.description = description
            self.name = name
            self.namespaces = namespaces
        }
    }
}

extension BedrockAgentCoreControlClientTypes.SemanticMemoryStrategyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SemanticMemoryStrategyInput(name: \(Swift.String(describing: name)), namespaces: \(Swift.String(describing: namespaces)), description: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentCoreControlClientTypes {

    /// Input for creating a summary memory strategy.
    public struct SummaryMemoryStrategyInput: Swift.Sendable {
        /// The description of the summary memory strategy.
        public var description: Swift.String?
        /// The name of the summary memory strategy.
        /// This member is required.
        public var name: Swift.String?
        /// The namespaces associated with the summary memory strategy.
        public var namespaces: [Swift.String]?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            namespaces: [Swift.String]? = nil
        ) {
            self.description = description
            self.name = name
            self.namespaces = namespaces
        }
    }
}

extension BedrockAgentCoreControlClientTypes.SummaryMemoryStrategyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SummaryMemoryStrategyInput(name: \(Swift.String(describing: name)), namespaces: \(Swift.String(describing: namespaces)), description: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentCoreControlClientTypes {

    /// Input for creating a user preference memory strategy.
    public struct UserPreferenceMemoryStrategyInput: Swift.Sendable {
        /// The description of the user preference memory strategy.
        public var description: Swift.String?
        /// The name of the user preference memory strategy.
        /// This member is required.
        public var name: Swift.String?
        /// The namespaces associated with the user preference memory strategy.
        public var namespaces: [Swift.String]?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            namespaces: [Swift.String]? = nil
        ) {
            self.description = description
            self.name = name
            self.namespaces = namespaces
        }
    }
}

extension BedrockAgentCoreControlClientTypes.UserPreferenceMemoryStrategyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserPreferenceMemoryStrategyInput(name: \(Swift.String(describing: name)), namespaces: \(Swift.String(describing: namespaces)), description: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentCoreControlClientTypes {

    /// Contains input information for creating a memory strategy.
    public enum MemoryStrategyInput: Swift.Sendable {
        /// Input for creating a semantic memory strategy.
        case semanticmemorystrategy(BedrockAgentCoreControlClientTypes.SemanticMemoryStrategyInput)
        /// Input for creating a summary memory strategy.
        case summarymemorystrategy(BedrockAgentCoreControlClientTypes.SummaryMemoryStrategyInput)
        /// Input for creating a user preference memory strategy.
        case userpreferencememorystrategy(BedrockAgentCoreControlClientTypes.UserPreferenceMemoryStrategyInput)
        /// Input for creating a custom memory strategy.
        case custommemorystrategy(BedrockAgentCoreControlClientTypes.CustomMemoryStrategyInput)
        case sdkUnknown(Swift.String)
    }
}

public struct CreateMemoryInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure that the operation completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request but does not return an error.
    public var clientToken: Swift.String?
    /// The description of the memory.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the KMS key used to encrypt the memory data.
    public var encryptionKeyArn: Swift.String?
    /// The duration after which memory events expire. Specified as an ISO 8601 duration.
    /// This member is required.
    public var eventExpiryDuration: Swift.Int?
    /// The Amazon Resource Name (ARN) of the IAM role that provides permissions for the memory to access Amazon Web Services services.
    public var memoryExecutionRoleArn: Swift.String?
    /// The memory strategies to use for this memory. Strategies define how information is extracted, processed, and consolidated.
    public var memoryStrategies: [BedrockAgentCoreControlClientTypes.MemoryStrategyInput]?
    /// The name of the memory. The name must be unique within your account.
    /// This member is required.
    public var name: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        encryptionKeyArn: Swift.String? = nil,
        eventExpiryDuration: Swift.Int? = nil,
        memoryExecutionRoleArn: Swift.String? = nil,
        memoryStrategies: [BedrockAgentCoreControlClientTypes.MemoryStrategyInput]? = nil,
        name: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.description = description
        self.encryptionKeyArn = encryptionKeyArn
        self.eventExpiryDuration = eventExpiryDuration
        self.memoryExecutionRoleArn = memoryExecutionRoleArn
        self.memoryStrategies = memoryStrategies
        self.name = name
    }
}

extension CreateMemoryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMemoryInput(clientToken: \(Swift.String(describing: clientToken)), encryptionKeyArn: \(Swift.String(describing: encryptionKeyArn)), eventExpiryDuration: \(Swift.String(describing: eventExpiryDuration)), memoryExecutionRoleArn: \(Swift.String(describing: memoryExecutionRoleArn)), memoryStrategies: \(Swift.String(describing: memoryStrategies)), name: \(Swift.String(describing: name)), description: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentCoreControlClientTypes {

    public enum MemoryStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [MemoryStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .failed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Contains semantic consolidation override configuration.
    public struct SemanticConsolidationOverride: Swift.Sendable {
        /// The text to append to the prompt for semantic consolidation.
        /// This member is required.
        public var appendToPrompt: Swift.String?
        /// The model ID to use for semantic consolidation.
        /// This member is required.
        public var modelId: Swift.String?

        public init(
            appendToPrompt: Swift.String? = nil,
            modelId: Swift.String? = nil
        ) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }
    }
}

extension BedrockAgentCoreControlClientTypes.SemanticConsolidationOverride: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SemanticConsolidationOverride(modelId: \(Swift.String(describing: modelId)), appendToPrompt: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentCoreControlClientTypes {

    /// Contains summary consolidation override configuration.
    public struct SummaryConsolidationOverride: Swift.Sendable {
        /// The text to append to the prompt for summary consolidation.
        /// This member is required.
        public var appendToPrompt: Swift.String?
        /// The model ID to use for summary consolidation.
        /// This member is required.
        public var modelId: Swift.String?

        public init(
            appendToPrompt: Swift.String? = nil,
            modelId: Swift.String? = nil
        ) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }
    }
}

extension BedrockAgentCoreControlClientTypes.SummaryConsolidationOverride: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SummaryConsolidationOverride(modelId: \(Swift.String(describing: modelId)), appendToPrompt: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentCoreControlClientTypes {

    /// Contains user preference consolidation override configuration.
    public struct UserPreferenceConsolidationOverride: Swift.Sendable {
        /// The text to append to the prompt for user preference consolidation.
        /// This member is required.
        public var appendToPrompt: Swift.String?
        /// The model ID to use for user preference consolidation.
        /// This member is required.
        public var modelId: Swift.String?

        public init(
            appendToPrompt: Swift.String? = nil,
            modelId: Swift.String? = nil
        ) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }
    }
}

extension BedrockAgentCoreControlClientTypes.UserPreferenceConsolidationOverride: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserPreferenceConsolidationOverride(modelId: \(Swift.String(describing: modelId)), appendToPrompt: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentCoreControlClientTypes {

    /// Contains custom consolidation configuration information.
    public enum CustomConsolidationConfiguration: Swift.Sendable {
        /// The semantic consolidation override configuration.
        case semanticconsolidationoverride(BedrockAgentCoreControlClientTypes.SemanticConsolidationOverride)
        /// The summary consolidation override configuration.
        case summaryconsolidationoverride(BedrockAgentCoreControlClientTypes.SummaryConsolidationOverride)
        /// The user preference consolidation override configuration.
        case userpreferenceconsolidationoverride(BedrockAgentCoreControlClientTypes.UserPreferenceConsolidationOverride)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Contains consolidation configuration information for a memory strategy.
    public enum ConsolidationConfiguration: Swift.Sendable {
        /// The custom consolidation configuration.
        case customconsolidationconfiguration(BedrockAgentCoreControlClientTypes.CustomConsolidationConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Contains semantic extraction override configuration.
    public struct SemanticExtractionOverride: Swift.Sendable {
        /// The text to append to the prompt for semantic extraction.
        /// This member is required.
        public var appendToPrompt: Swift.String?
        /// The model ID to use for semantic extraction.
        /// This member is required.
        public var modelId: Swift.String?

        public init(
            appendToPrompt: Swift.String? = nil,
            modelId: Swift.String? = nil
        ) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }
    }
}

extension BedrockAgentCoreControlClientTypes.SemanticExtractionOverride: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SemanticExtractionOverride(modelId: \(Swift.String(describing: modelId)), appendToPrompt: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentCoreControlClientTypes {

    /// Contains user preference extraction override configuration.
    public struct UserPreferenceExtractionOverride: Swift.Sendable {
        /// The text to append to the prompt for user preference extraction.
        /// This member is required.
        public var appendToPrompt: Swift.String?
        /// The model ID to use for user preference extraction.
        /// This member is required.
        public var modelId: Swift.String?

        public init(
            appendToPrompt: Swift.String? = nil,
            modelId: Swift.String? = nil
        ) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }
    }
}

extension BedrockAgentCoreControlClientTypes.UserPreferenceExtractionOverride: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserPreferenceExtractionOverride(modelId: \(Swift.String(describing: modelId)), appendToPrompt: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentCoreControlClientTypes {

    /// Contains custom extraction configuration information.
    public enum CustomExtractionConfiguration: Swift.Sendable {
        /// The semantic extraction override configuration.
        case semanticextractionoverride(BedrockAgentCoreControlClientTypes.SemanticExtractionOverride)
        /// The user preference extraction override configuration.
        case userpreferenceextractionoverride(BedrockAgentCoreControlClientTypes.UserPreferenceExtractionOverride)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Contains extraction configuration information for a memory strategy.
    public enum ExtractionConfiguration: Swift.Sendable {
        /// The custom extraction configuration.
        case customextractionconfiguration(BedrockAgentCoreControlClientTypes.CustomExtractionConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentCoreControlClientTypes {

    public enum OverrideType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case semanticOverride
        case summaryOverride
        case userPreferenceOverride
        case sdkUnknown(Swift.String)

        public static var allCases: [OverrideType] {
            return [
                .semanticOverride,
                .summaryOverride,
                .userPreferenceOverride
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .semanticOverride: return "SEMANTIC_OVERRIDE"
            case .summaryOverride: return "SUMMARY_OVERRIDE"
            case .userPreferenceOverride: return "USER_PREFERENCE_OVERRIDE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Contains configuration information for a memory strategy.
    public struct StrategyConfiguration: Swift.Sendable {
        /// The consolidation configuration for the memory strategy.
        public var consolidation: BedrockAgentCoreControlClientTypes.ConsolidationConfiguration?
        /// The extraction configuration for the memory strategy.
        public var extraction: BedrockAgentCoreControlClientTypes.ExtractionConfiguration?
        /// The type of override for the strategy configuration.
        public var type: BedrockAgentCoreControlClientTypes.OverrideType?

        public init(
            consolidation: BedrockAgentCoreControlClientTypes.ConsolidationConfiguration? = nil,
            extraction: BedrockAgentCoreControlClientTypes.ExtractionConfiguration? = nil,
            type: BedrockAgentCoreControlClientTypes.OverrideType? = nil
        ) {
            self.consolidation = consolidation
            self.extraction = extraction
            self.type = type
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    public enum MemoryStrategyStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [MemoryStrategyStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .failed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    public enum MemoryStrategyType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case custom
        case semantic
        case summarization
        case userPreference
        case sdkUnknown(Swift.String)

        public static var allCases: [MemoryStrategyType] {
            return [
                .custom,
                .semantic,
                .summarization,
                .userPreference
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .custom: return "CUSTOM"
            case .semantic: return "SEMANTIC"
            case .summarization: return "SUMMARIZATION"
            case .userPreference: return "USER_PREFERENCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Contains information about a memory strategy.
    public struct MemoryStrategy: Swift.Sendable {
        /// The configuration of the memory strategy.
        public var configuration: BedrockAgentCoreControlClientTypes.StrategyConfiguration?
        /// The timestamp when the memory strategy was created.
        public var createdAt: Foundation.Date?
        /// The description of the memory strategy.
        public var description: Swift.String?
        /// The name of the memory strategy.
        /// This member is required.
        public var name: Swift.String?
        /// The namespaces associated with the memory strategy.
        /// This member is required.
        public var namespaces: [Swift.String]?
        /// The current status of the memory strategy.
        public var status: BedrockAgentCoreControlClientTypes.MemoryStrategyStatus?
        /// The unique identifier of the memory strategy.
        /// This member is required.
        public var strategyId: Swift.String?
        /// The type of the memory strategy.
        /// This member is required.
        public var type: BedrockAgentCoreControlClientTypes.MemoryStrategyType?
        /// The timestamp when the memory strategy was last updated.
        public var updatedAt: Foundation.Date?

        public init(
            configuration: BedrockAgentCoreControlClientTypes.StrategyConfiguration? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            namespaces: [Swift.String]? = nil,
            status: BedrockAgentCoreControlClientTypes.MemoryStrategyStatus? = nil,
            strategyId: Swift.String? = nil,
            type: BedrockAgentCoreControlClientTypes.MemoryStrategyType? = nil,
            updatedAt: Foundation.Date? = nil
        ) {
            self.configuration = configuration
            self.createdAt = createdAt
            self.description = description
            self.name = name
            self.namespaces = namespaces
            self.status = status
            self.strategyId = strategyId
            self.type = type
            self.updatedAt = updatedAt
        }
    }
}

extension BedrockAgentCoreControlClientTypes.MemoryStrategy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MemoryStrategy(configuration: \(Swift.String(describing: configuration)), createdAt: \(Swift.String(describing: createdAt)), name: \(Swift.String(describing: name)), namespaces: \(Swift.String(describing: namespaces)), status: \(Swift.String(describing: status)), strategyId: \(Swift.String(describing: strategyId)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentCoreControlClientTypes {

    /// Contains information about a memory resource.
    public struct Memory: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the memory.
        /// This member is required.
        public var arn: Swift.String?
        /// The timestamp when the memory was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The description of the memory.
        public var description: Swift.String?
        /// The ARN of the KMS key used to encrypt the memory.
        public var encryptionKeyArn: Swift.String?
        /// The number of days after which memory events will expire.
        /// This member is required.
        public var eventExpiryDuration: Swift.Int?
        /// The reason for failure if the memory is in a failed state.
        public var failureReason: Swift.String?
        /// The unique identifier of the memory.
        /// This member is required.
        public var id: Swift.String?
        /// The ARN of the IAM role that provides permissions for the memory.
        public var memoryExecutionRoleArn: Swift.String?
        /// The name of the memory.
        /// This member is required.
        public var name: Swift.String?
        /// The current status of the memory.
        /// This member is required.
        public var status: BedrockAgentCoreControlClientTypes.MemoryStatus?
        /// The list of memory strategies associated with this memory.
        public var strategies: [BedrockAgentCoreControlClientTypes.MemoryStrategy]?
        /// The timestamp when the memory was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            encryptionKeyArn: Swift.String? = nil,
            eventExpiryDuration: Swift.Int? = nil,
            failureReason: Swift.String? = nil,
            id: Swift.String? = nil,
            memoryExecutionRoleArn: Swift.String? = nil,
            name: Swift.String? = nil,
            status: BedrockAgentCoreControlClientTypes.MemoryStatus? = nil,
            strategies: [BedrockAgentCoreControlClientTypes.MemoryStrategy]? = nil,
            updatedAt: Foundation.Date? = nil
        ) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.encryptionKeyArn = encryptionKeyArn
            self.eventExpiryDuration = eventExpiryDuration
            self.failureReason = failureReason
            self.id = id
            self.memoryExecutionRoleArn = memoryExecutionRoleArn
            self.name = name
            self.status = status
            self.strategies = strategies
            self.updatedAt = updatedAt
        }
    }
}

extension BedrockAgentCoreControlClientTypes.Memory: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Memory(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), encryptionKeyArn: \(Swift.String(describing: encryptionKeyArn)), eventExpiryDuration: \(Swift.String(describing: eventExpiryDuration)), failureReason: \(Swift.String(describing: failureReason)), id: \(Swift.String(describing: id)), memoryExecutionRoleArn: \(Swift.String(describing: memoryExecutionRoleArn)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), strategies: \(Swift.String(describing: strategies)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\")"}
}

public struct CreateMemoryOutput: Swift.Sendable {
    /// The details of the created memory, including its ID, ARN, name, description, and configuration settings.
    public var memory: BedrockAgentCoreControlClientTypes.Memory?

    public init(
        memory: BedrockAgentCoreControlClientTypes.Memory? = nil
    ) {
        self.memory = memory
    }
}

public struct DeleteMemoryInput: Swift.Sendable {
    /// A client token is used for keeping track of idempotent requests. It can contain a session id which can be around 250 chars, combined with a unique AWS identifier.
    public var clientToken: Swift.String?
    /// The unique identifier of the memory to delete.
    /// This member is required.
    public var memoryId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        memoryId: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.memoryId = memoryId
    }
}

public struct DeleteMemoryOutput: Swift.Sendable {
    /// The unique identifier of the deleted AgentCore Memory resource.
    /// This member is required.
    public var memoryId: Swift.String?
    /// The current status of the AgentCore Memory resource deletion.
    public var status: BedrockAgentCoreControlClientTypes.MemoryStatus?

    public init(
        memoryId: Swift.String? = nil,
        status: BedrockAgentCoreControlClientTypes.MemoryStatus? = nil
    ) {
        self.memoryId = memoryId
        self.status = status
    }
}

public struct GetMemoryInput: Swift.Sendable {
    /// The unique identifier of the memory to retrieve.
    /// This member is required.
    public var memoryId: Swift.String?

    public init(
        memoryId: Swift.String? = nil
    ) {
        self.memoryId = memoryId
    }
}

public struct GetMemoryOutput: Swift.Sendable {
    /// The retrieved AgentCore Memory resource details.
    /// This member is required.
    public var memory: BedrockAgentCoreControlClientTypes.Memory?

    public init(
        memory: BedrockAgentCoreControlClientTypes.Memory? = nil
    ) {
        self.memory = memory
    }
}

public struct ListMemoriesInput: Swift.Sendable {
    /// The maximum number of results to return in a single call. The default value is 10. The maximum value is 50.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Contains summary information about a memory resource.
    public struct MemorySummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the memory.
        public var arn: Swift.String?
        /// The timestamp when the memory was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The unique identifier of the memory.
        public var id: Swift.String?
        /// The current status of the memory.
        public var status: BedrockAgentCoreControlClientTypes.MemoryStatus?
        /// The timestamp when the memory was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            id: Swift.String? = nil,
            status: BedrockAgentCoreControlClientTypes.MemoryStatus? = nil,
            updatedAt: Foundation.Date? = nil
        ) {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.status = status
            self.updatedAt = updatedAt
        }
    }
}

public struct ListMemoriesOutput: Swift.Sendable {
    /// The list of AgentCore Memory resource summaries.
    /// This member is required.
    public var memories: [BedrockAgentCoreControlClientTypes.MemorySummary]?
    /// A token to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        memories: [BedrockAgentCoreControlClientTypes.MemorySummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.memories = memories
        self.nextToken = nextToken
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Input for deleting a memory strategy.
    public struct DeleteMemoryStrategyInput: Swift.Sendable {
        /// The unique identifier of the memory strategy to delete.
        /// This member is required.
        public var memoryStrategyId: Swift.String?

        public init(
            memoryStrategyId: Swift.String? = nil
        ) {
            self.memoryStrategyId = memoryStrategyId
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Input for a custom consolidation configuration.
    public enum CustomConsolidationConfigurationInput: Swift.Sendable {
        /// The semantic consolidation override configuration input.
        case semanticconsolidationoverride(BedrockAgentCoreControlClientTypes.SemanticOverrideConsolidationConfigurationInput)
        /// The summary consolidation override configuration input.
        case summaryconsolidationoverride(BedrockAgentCoreControlClientTypes.SummaryOverrideConsolidationConfigurationInput)
        /// The user preference consolidation override configuration input.
        case userpreferenceconsolidationoverride(BedrockAgentCoreControlClientTypes.UserPreferenceOverrideConsolidationConfigurationInput)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Contains information for modifying a consolidation configuration.
    public enum ModifyConsolidationConfiguration: Swift.Sendable {
        /// The updated custom consolidation configuration.
        case customconsolidationconfiguration(BedrockAgentCoreControlClientTypes.CustomConsolidationConfigurationInput)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Input for a custom extraction configuration.
    public enum CustomExtractionConfigurationInput: Swift.Sendable {
        /// The semantic extraction override configuration input.
        case semanticextractionoverride(BedrockAgentCoreControlClientTypes.SemanticOverrideExtractionConfigurationInput)
        /// The user preference extraction override configuration input.
        case userpreferenceextractionoverride(BedrockAgentCoreControlClientTypes.UserPreferenceOverrideExtractionConfigurationInput)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Contains information for modifying an extraction configuration.
    public enum ModifyExtractionConfiguration: Swift.Sendable {
        /// The updated custom extraction configuration.
        case customextractionconfiguration(BedrockAgentCoreControlClientTypes.CustomExtractionConfigurationInput)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Contains information for modifying a strategy configuration.
    public struct ModifyStrategyConfiguration: Swift.Sendable {
        /// The updated consolidation configuration.
        public var consolidation: BedrockAgentCoreControlClientTypes.ModifyConsolidationConfiguration?
        /// The updated extraction configuration.
        public var extraction: BedrockAgentCoreControlClientTypes.ModifyExtractionConfiguration?

        public init(
            consolidation: BedrockAgentCoreControlClientTypes.ModifyConsolidationConfiguration? = nil,
            extraction: BedrockAgentCoreControlClientTypes.ModifyExtractionConfiguration? = nil
        ) {
            self.consolidation = consolidation
            self.extraction = extraction
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Input for modifying a memory strategy.
    public struct ModifyMemoryStrategyInput: Swift.Sendable {
        /// The updated configuration for the memory strategy.
        public var configuration: BedrockAgentCoreControlClientTypes.ModifyStrategyConfiguration?
        /// The updated description of the memory strategy.
        public var description: Swift.String?
        /// The unique identifier of the memory strategy to modify.
        /// This member is required.
        public var memoryStrategyId: Swift.String?
        /// The updated namespaces for the memory strategy.
        public var namespaces: [Swift.String]?

        public init(
            configuration: BedrockAgentCoreControlClientTypes.ModifyStrategyConfiguration? = nil,
            description: Swift.String? = nil,
            memoryStrategyId: Swift.String? = nil,
            namespaces: [Swift.String]? = nil
        ) {
            self.configuration = configuration
            self.description = description
            self.memoryStrategyId = memoryStrategyId
            self.namespaces = namespaces
        }
    }
}

extension BedrockAgentCoreControlClientTypes.ModifyMemoryStrategyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyMemoryStrategyInput(configuration: \(Swift.String(describing: configuration)), memoryStrategyId: \(Swift.String(describing: memoryStrategyId)), namespaces: \(Swift.String(describing: namespaces)), description: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentCoreControlClientTypes {

    /// Contains information for modifying memory strategies.
    public struct ModifyMemoryStrategies: Swift.Sendable {
        /// The list of memory strategies to add.
        public var addMemoryStrategies: [BedrockAgentCoreControlClientTypes.MemoryStrategyInput]?
        /// The list of memory strategies to delete.
        public var deleteMemoryStrategies: [BedrockAgentCoreControlClientTypes.DeleteMemoryStrategyInput]?
        /// The list of memory strategies to modify.
        public var modifyMemoryStrategies: [BedrockAgentCoreControlClientTypes.ModifyMemoryStrategyInput]?

        public init(
            addMemoryStrategies: [BedrockAgentCoreControlClientTypes.MemoryStrategyInput]? = nil,
            deleteMemoryStrategies: [BedrockAgentCoreControlClientTypes.DeleteMemoryStrategyInput]? = nil,
            modifyMemoryStrategies: [BedrockAgentCoreControlClientTypes.ModifyMemoryStrategyInput]? = nil
        ) {
            self.addMemoryStrategies = addMemoryStrategies
            self.deleteMemoryStrategies = deleteMemoryStrategies
            self.modifyMemoryStrategies = modifyMemoryStrategies
        }
    }
}

public struct UpdateMemoryInput: Swift.Sendable {
    /// A client token is used for keeping track of idempotent requests. It can contain a session id which can be around 250 chars, combined with a unique AWS identifier.
    public var clientToken: Swift.String?
    /// The updated description of the AgentCore Memory resource.
    public var description: Swift.String?
    /// The number of days after which memory events will expire, between 7 and 365 days.
    public var eventExpiryDuration: Swift.Int?
    /// The ARN of the IAM role that provides permissions for the AgentCore Memory resource.
    public var memoryExecutionRoleArn: Swift.String?
    /// The unique identifier of the memory to update.
    /// This member is required.
    public var memoryId: Swift.String?
    /// The memory strategies to add, modify, or delete.
    public var memoryStrategies: BedrockAgentCoreControlClientTypes.ModifyMemoryStrategies?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        eventExpiryDuration: Swift.Int? = nil,
        memoryExecutionRoleArn: Swift.String? = nil,
        memoryId: Swift.String? = nil,
        memoryStrategies: BedrockAgentCoreControlClientTypes.ModifyMemoryStrategies? = nil
    ) {
        self.clientToken = clientToken
        self.description = description
        self.eventExpiryDuration = eventExpiryDuration
        self.memoryExecutionRoleArn = memoryExecutionRoleArn
        self.memoryId = memoryId
        self.memoryStrategies = memoryStrategies
    }
}

extension UpdateMemoryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateMemoryInput(clientToken: \(Swift.String(describing: clientToken)), eventExpiryDuration: \(Swift.String(describing: eventExpiryDuration)), memoryExecutionRoleArn: \(Swift.String(describing: memoryExecutionRoleArn)), memoryId: \(Swift.String(describing: memoryId)), memoryStrategies: \(Swift.String(describing: memoryStrategies)), description: \"CONTENT_REDACTED\")"}
}

public struct UpdateMemoryOutput: Swift.Sendable {
    /// The updated AgentCore Memory resource details.
    public var memory: BedrockAgentCoreControlClientTypes.Memory?

    public init(
        memory: BedrockAgentCoreControlClientTypes.Memory? = nil
    ) {
        self.memory = memory
    }
}

extension BedrockAgentCoreControlClientTypes {

    public enum CredentialProviderVendorType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case customoauth2
        case githuboauth2
        case googleoauth2
        case microsoftoauth2
        case salesforceoauth2
        case slackoauth2
        case sdkUnknown(Swift.String)

        public static var allCases: [CredentialProviderVendorType] {
            return [
                .customoauth2,
                .githuboauth2,
                .googleoauth2,
                .microsoftoauth2,
                .salesforceoauth2,
                .slackoauth2
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .customoauth2: return "CustomOauth2"
            case .githuboauth2: return "GithubOauth2"
            case .googleoauth2: return "GoogleOauth2"
            case .microsoftoauth2: return "MicrosoftOauth2"
            case .salesforceoauth2: return "SalesforceOauth2"
            case .slackoauth2: return "SlackOauth2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Contains the authorization server metadata for an OAuth2 provider.
    public struct Oauth2AuthorizationServerMetadata: Swift.Sendable {
        /// The authorization endpoint URL for the OAuth2 authorization server.
        /// This member is required.
        public var authorizationEndpoint: Swift.String?
        /// The issuer URL for the OAuth2 authorization server.
        /// This member is required.
        public var issuer: Swift.String?
        /// The supported response types for the OAuth2 authorization server.
        public var responseTypes: [Swift.String]?
        /// The token endpoint URL for the OAuth2 authorization server.
        /// This member is required.
        public var tokenEndpoint: Swift.String?

        public init(
            authorizationEndpoint: Swift.String? = nil,
            issuer: Swift.String? = nil,
            responseTypes: [Swift.String]? = nil,
            tokenEndpoint: Swift.String? = nil
        ) {
            self.authorizationEndpoint = authorizationEndpoint
            self.issuer = issuer
            self.responseTypes = responseTypes
            self.tokenEndpoint = tokenEndpoint
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Contains the discovery information for an OAuth2 provider.
    public enum Oauth2Discovery: Swift.Sendable {
        /// The discovery URL for the OAuth2 provider.
        case discoveryurl(Swift.String)
        /// The authorization server metadata for the OAuth2 provider.
        case authorizationservermetadata(BedrockAgentCoreControlClientTypes.Oauth2AuthorizationServerMetadata)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Input configuration for a custom OAuth2 provider.
    public struct CustomOauth2ProviderConfigInput: Swift.Sendable {
        /// The client ID for the custom OAuth2 provider.
        /// This member is required.
        public var clientId: Swift.String?
        /// The client secret for the custom OAuth2 provider.
        /// This member is required.
        public var clientSecret: Swift.String?
        /// The OAuth2 discovery information for the custom provider.
        /// This member is required.
        public var oauthDiscovery: BedrockAgentCoreControlClientTypes.Oauth2Discovery?

        public init(
            clientId: Swift.String? = nil,
            clientSecret: Swift.String? = nil,
            oauthDiscovery: BedrockAgentCoreControlClientTypes.Oauth2Discovery? = nil
        ) {
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.oauthDiscovery = oauthDiscovery
        }
    }
}

extension BedrockAgentCoreControlClientTypes.CustomOauth2ProviderConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomOauth2ProviderConfigInput(clientId: \(Swift.String(describing: clientId)), oauthDiscovery: \(Swift.String(describing: oauthDiscovery)), clientSecret: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentCoreControlClientTypes {

    /// Input configuration for a GitHub OAuth2 provider.
    public struct GithubOauth2ProviderConfigInput: Swift.Sendable {
        /// The client ID for the GitHub OAuth2 provider.
        /// This member is required.
        public var clientId: Swift.String?
        /// The client secret for the GitHub OAuth2 provider.
        /// This member is required.
        public var clientSecret: Swift.String?

        public init(
            clientId: Swift.String? = nil,
            clientSecret: Swift.String? = nil
        ) {
            self.clientId = clientId
            self.clientSecret = clientSecret
        }
    }
}

extension BedrockAgentCoreControlClientTypes.GithubOauth2ProviderConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GithubOauth2ProviderConfigInput(clientId: \(Swift.String(describing: clientId)), clientSecret: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentCoreControlClientTypes {

    /// Input configuration for a Google OAuth2 provider.
    public struct GoogleOauth2ProviderConfigInput: Swift.Sendable {
        /// The client ID for the Google OAuth2 provider.
        /// This member is required.
        public var clientId: Swift.String?
        /// The client secret for the Google OAuth2 provider.
        /// This member is required.
        public var clientSecret: Swift.String?

        public init(
            clientId: Swift.String? = nil,
            clientSecret: Swift.String? = nil
        ) {
            self.clientId = clientId
            self.clientSecret = clientSecret
        }
    }
}

extension BedrockAgentCoreControlClientTypes.GoogleOauth2ProviderConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GoogleOauth2ProviderConfigInput(clientId: \(Swift.String(describing: clientId)), clientSecret: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentCoreControlClientTypes {

    /// Input configuration for a Microsoft OAuth2 provider.
    public struct MicrosoftOauth2ProviderConfigInput: Swift.Sendable {
        /// The client ID for the Microsoft OAuth2 provider.
        /// This member is required.
        public var clientId: Swift.String?
        /// The client secret for the Microsoft OAuth2 provider.
        /// This member is required.
        public var clientSecret: Swift.String?

        public init(
            clientId: Swift.String? = nil,
            clientSecret: Swift.String? = nil
        ) {
            self.clientId = clientId
            self.clientSecret = clientSecret
        }
    }
}

extension BedrockAgentCoreControlClientTypes.MicrosoftOauth2ProviderConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MicrosoftOauth2ProviderConfigInput(clientId: \(Swift.String(describing: clientId)), clientSecret: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentCoreControlClientTypes {

    /// Input configuration for a Salesforce OAuth2 provider.
    public struct SalesforceOauth2ProviderConfigInput: Swift.Sendable {
        /// The client ID for the Salesforce OAuth2 provider.
        /// This member is required.
        public var clientId: Swift.String?
        /// The client secret for the Salesforce OAuth2 provider.
        /// This member is required.
        public var clientSecret: Swift.String?

        public init(
            clientId: Swift.String? = nil,
            clientSecret: Swift.String? = nil
        ) {
            self.clientId = clientId
            self.clientSecret = clientSecret
        }
    }
}

extension BedrockAgentCoreControlClientTypes.SalesforceOauth2ProviderConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SalesforceOauth2ProviderConfigInput(clientId: \(Swift.String(describing: clientId)), clientSecret: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentCoreControlClientTypes {

    /// Input configuration for a Slack OAuth2 provider.
    public struct SlackOauth2ProviderConfigInput: Swift.Sendable {
        /// The client ID for the Slack OAuth2 provider.
        /// This member is required.
        public var clientId: Swift.String?
        /// The client secret for the Slack OAuth2 provider.
        /// This member is required.
        public var clientSecret: Swift.String?

        public init(
            clientId: Swift.String? = nil,
            clientSecret: Swift.String? = nil
        ) {
            self.clientId = clientId
            self.clientSecret = clientSecret
        }
    }
}

extension BedrockAgentCoreControlClientTypes.SlackOauth2ProviderConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SlackOauth2ProviderConfigInput(clientId: \(Swift.String(describing: clientId)), clientSecret: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentCoreControlClientTypes {

    /// Contains the input configuration for an OAuth2 provider.
    public enum Oauth2ProviderConfigInput: Swift.Sendable {
        /// The configuration for a custom OAuth2 provider.
        case customoauth2providerconfig(BedrockAgentCoreControlClientTypes.CustomOauth2ProviderConfigInput)
        /// The configuration for a Google OAuth2 provider.
        case googleoauth2providerconfig(BedrockAgentCoreControlClientTypes.GoogleOauth2ProviderConfigInput)
        /// The configuration for a GitHub OAuth2 provider.
        case githuboauth2providerconfig(BedrockAgentCoreControlClientTypes.GithubOauth2ProviderConfigInput)
        /// The configuration for a Slack OAuth2 provider.
        case slackoauth2providerconfig(BedrockAgentCoreControlClientTypes.SlackOauth2ProviderConfigInput)
        /// The configuration for a Salesforce OAuth2 provider.
        case salesforceoauth2providerconfig(BedrockAgentCoreControlClientTypes.SalesforceOauth2ProviderConfigInput)
        /// The configuration for a Microsoft OAuth2 provider.
        case microsoftoauth2providerconfig(BedrockAgentCoreControlClientTypes.MicrosoftOauth2ProviderConfigInput)
        case sdkUnknown(Swift.String)
    }
}

public struct CreateOauth2CredentialProviderInput: Swift.Sendable {
    /// The vendor of the OAuth2 credential provider. This specifies which OAuth2 implementation to use.
    /// This member is required.
    public var credentialProviderVendor: BedrockAgentCoreControlClientTypes.CredentialProviderVendorType?
    /// The name of the OAuth2 credential provider. The name must be unique within your account.
    /// This member is required.
    public var name: Swift.String?
    /// The configuration settings for the OAuth2 provider, including client ID, client secret, and other vendor-specific settings.
    /// This member is required.
    public var oauth2ProviderConfigInput: BedrockAgentCoreControlClientTypes.Oauth2ProviderConfigInput?

    public init(
        credentialProviderVendor: BedrockAgentCoreControlClientTypes.CredentialProviderVendorType? = nil,
        name: Swift.String? = nil,
        oauth2ProviderConfigInput: BedrockAgentCoreControlClientTypes.Oauth2ProviderConfigInput? = nil
    ) {
        self.credentialProviderVendor = credentialProviderVendor
        self.name = name
        self.oauth2ProviderConfigInput = oauth2ProviderConfigInput
    }
}

public struct CreateOauth2CredentialProviderOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the client secret in AWS Secrets Manager.
    /// This member is required.
    public var clientSecretArn: BedrockAgentCoreControlClientTypes.Secret?
    /// The Amazon Resource Name (ARN) of the OAuth2 credential provider.
    /// This member is required.
    public var credentialProviderArn: Swift.String?
    /// The name of the OAuth2 credential provider.
    /// This member is required.
    public var name: Swift.String?

    public init(
        clientSecretArn: BedrockAgentCoreControlClientTypes.Secret? = nil,
        credentialProviderArn: Swift.String? = nil,
        name: Swift.String? = nil
    ) {
        self.clientSecretArn = clientSecretArn
        self.credentialProviderArn = credentialProviderArn
        self.name = name
    }
}

public struct DeleteOauth2CredentialProviderInput: Swift.Sendable {
    /// The name of the OAuth2 credential provider to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    ) {
        self.name = name
    }
}

public struct DeleteOauth2CredentialProviderOutput: Swift.Sendable {

    public init() { }
}

public struct GetOauth2CredentialProviderInput: Swift.Sendable {
    /// The name of the OAuth2 credential provider to retrieve.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    ) {
        self.name = name
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Output configuration for a custom OAuth2 provider.
    public struct CustomOauth2ProviderConfigOutput: Swift.Sendable {
        /// The OAuth2 discovery information for the custom provider.
        /// This member is required.
        public var oauthDiscovery: BedrockAgentCoreControlClientTypes.Oauth2Discovery?

        public init(
            oauthDiscovery: BedrockAgentCoreControlClientTypes.Oauth2Discovery? = nil
        ) {
            self.oauthDiscovery = oauthDiscovery
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Output configuration for a GitHub OAuth2 provider.
    public struct GithubOauth2ProviderConfigOutput: Swift.Sendable {
        /// The OAuth2 discovery information for the GitHub provider.
        /// This member is required.
        public var oauthDiscovery: BedrockAgentCoreControlClientTypes.Oauth2Discovery?

        public init(
            oauthDiscovery: BedrockAgentCoreControlClientTypes.Oauth2Discovery? = nil
        ) {
            self.oauthDiscovery = oauthDiscovery
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Output configuration for a Google OAuth2 provider.
    public struct GoogleOauth2ProviderConfigOutput: Swift.Sendable {
        /// The OAuth2 discovery information for the Google provider.
        /// This member is required.
        public var oauthDiscovery: BedrockAgentCoreControlClientTypes.Oauth2Discovery?

        public init(
            oauthDiscovery: BedrockAgentCoreControlClientTypes.Oauth2Discovery? = nil
        ) {
            self.oauthDiscovery = oauthDiscovery
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Output configuration for a Microsoft OAuth2 provider.
    public struct MicrosoftOauth2ProviderConfigOutput: Swift.Sendable {
        /// The OAuth2 discovery information for the Microsoft provider.
        /// This member is required.
        public var oauthDiscovery: BedrockAgentCoreControlClientTypes.Oauth2Discovery?

        public init(
            oauthDiscovery: BedrockAgentCoreControlClientTypes.Oauth2Discovery? = nil
        ) {
            self.oauthDiscovery = oauthDiscovery
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Output configuration for a Salesforce OAuth2 provider.
    public struct SalesforceOauth2ProviderConfigOutput: Swift.Sendable {
        /// The OAuth2 discovery information for the Salesforce provider.
        /// This member is required.
        public var oauthDiscovery: BedrockAgentCoreControlClientTypes.Oauth2Discovery?

        public init(
            oauthDiscovery: BedrockAgentCoreControlClientTypes.Oauth2Discovery? = nil
        ) {
            self.oauthDiscovery = oauthDiscovery
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Output configuration for a Slack OAuth2 provider.
    public struct SlackOauth2ProviderConfigOutput: Swift.Sendable {
        /// The OAuth2 discovery information for the Slack provider.
        /// This member is required.
        public var oauthDiscovery: BedrockAgentCoreControlClientTypes.Oauth2Discovery?

        public init(
            oauthDiscovery: BedrockAgentCoreControlClientTypes.Oauth2Discovery? = nil
        ) {
            self.oauthDiscovery = oauthDiscovery
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Contains the output configuration for an OAuth2 provider.
    public enum Oauth2ProviderConfigOutput: Swift.Sendable {
        /// The output configuration for a custom OAuth2 provider.
        case customoauth2providerconfig(BedrockAgentCoreControlClientTypes.CustomOauth2ProviderConfigOutput)
        /// The output configuration for a Google OAuth2 provider.
        case googleoauth2providerconfig(BedrockAgentCoreControlClientTypes.GoogleOauth2ProviderConfigOutput)
        /// The output configuration for a GitHub OAuth2 provider.
        case githuboauth2providerconfig(BedrockAgentCoreControlClientTypes.GithubOauth2ProviderConfigOutput)
        /// The output configuration for a Slack OAuth2 provider.
        case slackoauth2providerconfig(BedrockAgentCoreControlClientTypes.SlackOauth2ProviderConfigOutput)
        /// The output configuration for a Salesforce OAuth2 provider.
        case salesforceoauth2providerconfig(BedrockAgentCoreControlClientTypes.SalesforceOauth2ProviderConfigOutput)
        /// The output configuration for a Microsoft OAuth2 provider.
        case microsoftoauth2providerconfig(BedrockAgentCoreControlClientTypes.MicrosoftOauth2ProviderConfigOutput)
        case sdkUnknown(Swift.String)
    }
}

public struct GetOauth2CredentialProviderOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the client secret in AWS Secrets Manager.
    /// This member is required.
    public var clientSecretArn: BedrockAgentCoreControlClientTypes.Secret?
    /// The timestamp when the OAuth2 credential provider was created.
    /// This member is required.
    public var createdTime: Foundation.Date?
    /// ARN of the credential provider requested.
    /// This member is required.
    public var credentialProviderArn: Swift.String?
    /// The vendor of the OAuth2 credential provider.
    /// This member is required.
    public var credentialProviderVendor: BedrockAgentCoreControlClientTypes.CredentialProviderVendorType?
    /// The timestamp when the OAuth2 credential provider was last updated.
    /// This member is required.
    public var lastUpdatedTime: Foundation.Date?
    /// The name of the OAuth2 credential provider.
    /// This member is required.
    public var name: Swift.String?
    /// The configuration output for the OAuth2 provider.
    /// This member is required.
    public var oauth2ProviderConfigOutput: BedrockAgentCoreControlClientTypes.Oauth2ProviderConfigOutput?

    public init(
        clientSecretArn: BedrockAgentCoreControlClientTypes.Secret? = nil,
        createdTime: Foundation.Date? = nil,
        credentialProviderArn: Swift.String? = nil,
        credentialProviderVendor: BedrockAgentCoreControlClientTypes.CredentialProviderVendorType? = nil,
        lastUpdatedTime: Foundation.Date? = nil,
        name: Swift.String? = nil,
        oauth2ProviderConfigOutput: BedrockAgentCoreControlClientTypes.Oauth2ProviderConfigOutput? = nil
    ) {
        self.clientSecretArn = clientSecretArn
        self.createdTime = createdTime
        self.credentialProviderArn = credentialProviderArn
        self.credentialProviderVendor = credentialProviderVendor
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.oauth2ProviderConfigOutput = oauth2ProviderConfigOutput
    }
}

public struct ListOauth2CredentialProvidersInput: Swift.Sendable {
    /// Maximum number of results to return.
    public var maxResults: Swift.Int?
    /// Pagination token.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Contains information about an OAuth2 credential provider.
    public struct Oauth2CredentialProviderItem: Swift.Sendable {
        /// The timestamp when the OAuth2 credential provider was created.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the OAuth2 credential provider.
        /// This member is required.
        public var credentialProviderArn: Swift.String?
        /// The vendor of the OAuth2 credential provider.
        /// This member is required.
        public var credentialProviderVendor: BedrockAgentCoreControlClientTypes.CredentialProviderVendorType?
        /// The timestamp when the OAuth2 credential provider was last updated.
        /// This member is required.
        public var lastUpdatedTime: Foundation.Date?
        /// The name of the OAuth2 credential provider.
        /// This member is required.
        public var name: Swift.String?

        public init(
            createdTime: Foundation.Date? = nil,
            credentialProviderArn: Swift.String? = nil,
            credentialProviderVendor: BedrockAgentCoreControlClientTypes.CredentialProviderVendorType? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            name: Swift.String? = nil
        ) {
            self.createdTime = createdTime
            self.credentialProviderArn = credentialProviderArn
            self.credentialProviderVendor = credentialProviderVendor
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }
    }
}

public struct ListOauth2CredentialProvidersOutput: Swift.Sendable {
    /// The list of OAuth2 credential providers.
    /// This member is required.
    public var credentialProviders: [BedrockAgentCoreControlClientTypes.Oauth2CredentialProviderItem]?
    /// Pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        credentialProviders: [BedrockAgentCoreControlClientTypes.Oauth2CredentialProviderItem]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.credentialProviders = credentialProviders
        self.nextToken = nextToken
    }
}

public struct UpdateOauth2CredentialProviderInput: Swift.Sendable {
    /// The vendor of the OAuth2 credential provider.
    /// This member is required.
    public var credentialProviderVendor: BedrockAgentCoreControlClientTypes.CredentialProviderVendorType?
    /// The name of the OAuth2 credential provider to update.
    /// This member is required.
    public var name: Swift.String?
    /// The configuration input for the OAuth2 provider.
    /// This member is required.
    public var oauth2ProviderConfigInput: BedrockAgentCoreControlClientTypes.Oauth2ProviderConfigInput?

    public init(
        credentialProviderVendor: BedrockAgentCoreControlClientTypes.CredentialProviderVendorType? = nil,
        name: Swift.String? = nil,
        oauth2ProviderConfigInput: BedrockAgentCoreControlClientTypes.Oauth2ProviderConfigInput? = nil
    ) {
        self.credentialProviderVendor = credentialProviderVendor
        self.name = name
        self.oauth2ProviderConfigInput = oauth2ProviderConfigInput
    }
}

public struct UpdateOauth2CredentialProviderOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the client secret in AWS Secrets Manager.
    /// This member is required.
    public var clientSecretArn: BedrockAgentCoreControlClientTypes.Secret?
    /// The timestamp when the OAuth2 credential provider was created.
    /// This member is required.
    public var createdTime: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the OAuth2 credential provider.
    /// This member is required.
    public var credentialProviderArn: Swift.String?
    /// The vendor of the OAuth2 credential provider.
    /// This member is required.
    public var credentialProviderVendor: BedrockAgentCoreControlClientTypes.CredentialProviderVendorType?
    /// The timestamp when the OAuth2 credential provider was last updated.
    /// This member is required.
    public var lastUpdatedTime: Foundation.Date?
    /// The name of the OAuth2 credential provider.
    /// This member is required.
    public var name: Swift.String?
    /// The configuration output for the OAuth2 provider.
    /// This member is required.
    public var oauth2ProviderConfigOutput: BedrockAgentCoreControlClientTypes.Oauth2ProviderConfigOutput?

    public init(
        clientSecretArn: BedrockAgentCoreControlClientTypes.Secret? = nil,
        createdTime: Foundation.Date? = nil,
        credentialProviderArn: Swift.String? = nil,
        credentialProviderVendor: BedrockAgentCoreControlClientTypes.CredentialProviderVendorType? = nil,
        lastUpdatedTime: Foundation.Date? = nil,
        name: Swift.String? = nil,
        oauth2ProviderConfigOutput: BedrockAgentCoreControlClientTypes.Oauth2ProviderConfigOutput? = nil
    ) {
        self.clientSecretArn = clientSecretArn
        self.createdTime = createdTime
        self.credentialProviderArn = credentialProviderArn
        self.credentialProviderVendor = credentialProviderVendor
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.oauth2ProviderConfigOutput = oauth2ProviderConfigOutput
    }
}

/// Exception thrown when a resource is modified concurrently by multiple requests.
public struct ConcurrentModificationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConcurrentModificationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct SetTokenVaultCMKInput: Swift.Sendable {
    /// The KMS configuration for the token vault, including the key type and KMS key ARN.
    /// This member is required.
    public var kmsConfiguration: BedrockAgentCoreControlClientTypes.KmsConfiguration?
    /// The unique identifier of the token vault to update.
    public var tokenVaultId: Swift.String?

    public init(
        kmsConfiguration: BedrockAgentCoreControlClientTypes.KmsConfiguration? = nil,
        tokenVaultId: Swift.String? = nil
    ) {
        self.kmsConfiguration = kmsConfiguration
        self.tokenVaultId = tokenVaultId
    }
}

public struct SetTokenVaultCMKOutput: Swift.Sendable {
    /// The KMS configuration for the token vault.
    /// This member is required.
    public var kmsConfiguration: BedrockAgentCoreControlClientTypes.KmsConfiguration?
    /// The timestamp when the token vault was last modified.
    /// This member is required.
    public var lastModifiedDate: Foundation.Date?
    /// The ID of the token vault.
    /// This member is required.
    public var tokenVaultId: Swift.String?

    public init(
        kmsConfiguration: BedrockAgentCoreControlClientTypes.KmsConfiguration? = nil,
        lastModifiedDate: Foundation.Date? = nil,
        tokenVaultId: Swift.String? = nil
    ) {
        self.kmsConfiguration = kmsConfiguration
        self.lastModifiedDate = lastModifiedDate
        self.tokenVaultId = tokenVaultId
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource that you want to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the resource. A tag is a key-value pair.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource that you want to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys of the tags to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct CreateWorkloadIdentityInput: Swift.Sendable {
    /// The list of allowed OAuth2 return URLs for resources associated with this workload identity.
    public var allowedResourceOauth2ReturnUrls: [Swift.String]?
    /// The name of the workload identity. The name must be unique within your account.
    /// This member is required.
    public var name: Swift.String?

    public init(
        allowedResourceOauth2ReturnUrls: [Swift.String]? = nil,
        name: Swift.String? = nil
    ) {
        self.allowedResourceOauth2ReturnUrls = allowedResourceOauth2ReturnUrls
        self.name = name
    }
}

public struct CreateWorkloadIdentityOutput: Swift.Sendable {
    /// The list of allowed OAuth2 return URLs for resources associated with this workload identity.
    public var allowedResourceOauth2ReturnUrls: [Swift.String]?
    /// The name of the workload identity.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the workload identity.
    /// This member is required.
    public var workloadIdentityArn: Swift.String?

    public init(
        allowedResourceOauth2ReturnUrls: [Swift.String]? = nil,
        name: Swift.String? = nil,
        workloadIdentityArn: Swift.String? = nil
    ) {
        self.allowedResourceOauth2ReturnUrls = allowedResourceOauth2ReturnUrls
        self.name = name
        self.workloadIdentityArn = workloadIdentityArn
    }
}

public struct DeleteWorkloadIdentityInput: Swift.Sendable {
    /// The name of the workload identity to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    ) {
        self.name = name
    }
}

public struct DeleteWorkloadIdentityOutput: Swift.Sendable {

    public init() { }
}

public struct GetWorkloadIdentityInput: Swift.Sendable {
    /// The name of the workload identity to retrieve.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    ) {
        self.name = name
    }
}

public struct GetWorkloadIdentityOutput: Swift.Sendable {
    /// The list of allowed OAuth2 return URLs for resources associated with this workload identity.
    public var allowedResourceOauth2ReturnUrls: [Swift.String]?
    /// The timestamp when the workload identity was created.
    /// This member is required.
    public var createdTime: Foundation.Date?
    /// The timestamp when the workload identity was last updated.
    /// This member is required.
    public var lastUpdatedTime: Foundation.Date?
    /// The name of the workload identity.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the workload identity.
    /// This member is required.
    public var workloadIdentityArn: Swift.String?

    public init(
        allowedResourceOauth2ReturnUrls: [Swift.String]? = nil,
        createdTime: Foundation.Date? = nil,
        lastUpdatedTime: Foundation.Date? = nil,
        name: Swift.String? = nil,
        workloadIdentityArn: Swift.String? = nil
    ) {
        self.allowedResourceOauth2ReturnUrls = allowedResourceOauth2ReturnUrls
        self.createdTime = createdTime
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.workloadIdentityArn = workloadIdentityArn
    }
}

public struct ListWorkloadIdentitiesInput: Swift.Sendable {
    /// Maximum number of results to return.
    public var maxResults: Swift.Int?
    /// Pagination token.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// Contains information about a workload identity.
    public struct WorkloadIdentityType: Swift.Sendable {
        /// The name of the workload identity.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the workload identity.
        /// This member is required.
        public var workloadIdentityArn: Swift.String?

        public init(
            name: Swift.String? = nil,
            workloadIdentityArn: Swift.String? = nil
        ) {
            self.name = name
            self.workloadIdentityArn = workloadIdentityArn
        }
    }
}

public struct ListWorkloadIdentitiesOutput: Swift.Sendable {
    /// Pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The list of workload identities.
    /// This member is required.
    public var workloadIdentities: [BedrockAgentCoreControlClientTypes.WorkloadIdentityType]?

    public init(
        nextToken: Swift.String? = nil,
        workloadIdentities: [BedrockAgentCoreControlClientTypes.WorkloadIdentityType]? = nil
    ) {
        self.nextToken = nextToken
        self.workloadIdentities = workloadIdentities
    }
}

public struct UpdateWorkloadIdentityInput: Swift.Sendable {
    /// The new list of allowed OAuth2 return URLs for resources associated with this workload identity. This list replaces the existing list.
    public var allowedResourceOauth2ReturnUrls: [Swift.String]?
    /// The name of the workload identity to update.
    /// This member is required.
    public var name: Swift.String?

    public init(
        allowedResourceOauth2ReturnUrls: [Swift.String]? = nil,
        name: Swift.String? = nil
    ) {
        self.allowedResourceOauth2ReturnUrls = allowedResourceOauth2ReturnUrls
        self.name = name
    }
}

public struct UpdateWorkloadIdentityOutput: Swift.Sendable {
    /// The list of allowed OAuth2 return URLs for resources associated with this workload identity.
    public var allowedResourceOauth2ReturnUrls: [Swift.String]?
    /// The timestamp when the workload identity was created.
    /// This member is required.
    public var createdTime: Foundation.Date?
    /// The timestamp when the workload identity was last updated.
    /// This member is required.
    public var lastUpdatedTime: Foundation.Date?
    /// The name of the workload identity.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the workload identity.
    /// This member is required.
    public var workloadIdentityArn: Swift.String?

    public init(
        allowedResourceOauth2ReturnUrls: [Swift.String]? = nil,
        createdTime: Foundation.Date? = nil,
        lastUpdatedTime: Foundation.Date? = nil,
        name: Swift.String? = nil,
        workloadIdentityArn: Swift.String? = nil
    ) {
        self.allowedResourceOauth2ReturnUrls = allowedResourceOauth2ReturnUrls
        self.createdTime = createdTime
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.workloadIdentityArn = workloadIdentityArn
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// A schema definition for a gateway target. This structure defines the structure of the API that the target exposes.
    public struct SchemaDefinition: Swift.Sendable {
        /// The description of the schema definition. This description provides information about the purpose and usage of the schema.
        public var description: Swift.String?
        /// The items in the schema definition. This field is used for array types to define the structure of the array elements.
        @Indirect public var items: BedrockAgentCoreControlClientTypes.SchemaDefinition?
        /// The properties of the schema definition. These properties define the fields in the schema.
        public var properties: [Swift.String: BedrockAgentCoreControlClientTypes.SchemaDefinition]?
        /// The required fields in the schema definition. These fields must be provided when using the schema.
        public var `required`: [Swift.String]?
        /// The type of the schema definition. This field specifies the data type of the schema.
        /// This member is required.
        public var type: BedrockAgentCoreControlClientTypes.SchemaType?

        public init(
            description: Swift.String? = nil,
            items: BedrockAgentCoreControlClientTypes.SchemaDefinition? = nil,
            properties: [Swift.String: BedrockAgentCoreControlClientTypes.SchemaDefinition]? = nil,
            `required`: [Swift.String]? = nil,
            type: BedrockAgentCoreControlClientTypes.SchemaType? = nil
        ) {
            self.description = description
            self.items = items
            self.properties = properties
            self.`required` = `required`
            self.type = type
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// A tool definition for a gateway target. This structure defines a tool that the target exposes through the Model Context Protocol.
    public struct ToolDefinition: Swift.Sendable {
        /// The description of the tool. This description provides information about the purpose and usage of the tool.
        /// This member is required.
        public var description: Swift.String?
        /// The input schema for the tool. This schema defines the structure of the input that the tool accepts.
        /// This member is required.
        public var inputSchema: BedrockAgentCoreControlClientTypes.SchemaDefinition?
        /// The name of the tool. This name identifies the tool in the Model Context Protocol.
        /// This member is required.
        public var name: Swift.String?
        /// The output schema for the tool. This schema defines the structure of the output that the tool produces.
        public var outputSchema: BedrockAgentCoreControlClientTypes.SchemaDefinition?

        public init(
            description: Swift.String? = nil,
            inputSchema: BedrockAgentCoreControlClientTypes.SchemaDefinition? = nil,
            name: Swift.String? = nil,
            outputSchema: BedrockAgentCoreControlClientTypes.SchemaDefinition? = nil
        ) {
            self.description = description
            self.inputSchema = inputSchema
            self.name = name
            self.outputSchema = outputSchema
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// A tool schema for a gateway target. This structure defines the schema for a tool that the target exposes through the Model Context Protocol.
    public indirect enum ToolSchema: Swift.Sendable {
        /// The Amazon S3 location of the tool schema. This location contains the schema definition file.
        case s3(BedrockAgentCoreControlClientTypes.S3Configuration)
        /// The inline payload of the tool schema. This payload contains the schema definition directly in the request.
        case inlinepayload([BedrockAgentCoreControlClientTypes.ToolDefinition])
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// The Lambda configuration for a Model Context Protocol target. This structure defines how the gateway uses a Lambda function to communicate with the target.
    public struct McpLambdaTargetConfiguration: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the Lambda function. This function is invoked by the gateway to communicate with the target.
        /// This member is required.
        public var lambdaArn: Swift.String?
        /// The tool schema for the Lambda function. This schema defines the structure of the tools that the Lambda function provides.
        /// This member is required.
        public var toolSchema: BedrockAgentCoreControlClientTypes.ToolSchema?

        public init(
            lambdaArn: Swift.String? = nil,
            toolSchema: BedrockAgentCoreControlClientTypes.ToolSchema? = nil
        ) {
            self.lambdaArn = lambdaArn
            self.toolSchema = toolSchema
        }
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// The Model Context Protocol (MCP) configuration for a target. This structure defines how the gateway uses MCP to communicate with the target.
    public indirect enum McpTargetConfiguration: Swift.Sendable {
        /// The OpenAPI schema for the Model Context Protocol target. This schema defines the API structure of the target.
        case openapischema(BedrockAgentCoreControlClientTypes.ApiSchemaConfiguration)
        /// The Smithy model for the Model Context Protocol target. This model defines the API structure of the target using the Smithy specification.
        case smithymodel(BedrockAgentCoreControlClientTypes.ApiSchemaConfiguration)
        /// The Lambda configuration for the Model Context Protocol target. This configuration defines how the gateway uses a Lambda function to communicate with the target.
        case lambda(BedrockAgentCoreControlClientTypes.McpLambdaTargetConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentCoreControlClientTypes {

    /// The configuration for a gateway target. This structure defines how the gateway connects to and interacts with the target endpoint.
    public indirect enum TargetConfiguration: Swift.Sendable {
        /// The Model Context Protocol (MCP) configuration for the target. This configuration defines how the gateway uses MCP to communicate with the target.
        case mcp(BedrockAgentCoreControlClientTypes.McpTargetConfiguration)
        case sdkUnknown(Swift.String)
    }
}

public struct CreateGatewayTargetInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, the service ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// The credential provider configurations for the target. These configurations specify how the gateway authenticates with the target endpoint.
    /// This member is required.
    public var credentialProviderConfigurations: [BedrockAgentCoreControlClientTypes.CredentialProviderConfiguration]?
    /// The description of the gateway target.
    public var description: Swift.String?
    /// The identifier of the gateway to create a target for.
    /// This member is required.
    public var gatewayIdentifier: Swift.String?
    /// The name of the gateway target. The name must be unique within the gateway.
    /// This member is required.
    public var name: Swift.String?
    /// The configuration settings for the target, including endpoint information and schema definitions.
    /// This member is required.
    public var targetConfiguration: BedrockAgentCoreControlClientTypes.TargetConfiguration?

    public init(
        clientToken: Swift.String? = nil,
        credentialProviderConfigurations: [BedrockAgentCoreControlClientTypes.CredentialProviderConfiguration]? = nil,
        description: Swift.String? = nil,
        gatewayIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        targetConfiguration: BedrockAgentCoreControlClientTypes.TargetConfiguration? = nil
    ) {
        self.clientToken = clientToken
        self.credentialProviderConfigurations = credentialProviderConfigurations
        self.description = description
        self.gatewayIdentifier = gatewayIdentifier
        self.name = name
        self.targetConfiguration = targetConfiguration
    }
}

extension CreateGatewayTargetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGatewayTargetInput(clientToken: \(Swift.String(describing: clientToken)), credentialProviderConfigurations: \(Swift.String(describing: credentialProviderConfigurations)), gatewayIdentifier: \(Swift.String(describing: gatewayIdentifier)), targetConfiguration: \(Swift.String(describing: targetConfiguration)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct CreateGatewayTargetOutput: Swift.Sendable {
    /// The timestamp when the target was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The credential provider configurations for the target.
    /// This member is required.
    public var credentialProviderConfigurations: [BedrockAgentCoreControlClientTypes.CredentialProviderConfiguration]?
    /// The description of the target.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the gateway.
    /// This member is required.
    public var gatewayArn: Swift.String?
    /// The name of the target.
    /// This member is required.
    public var name: Swift.String?
    /// The current status of the target.
    /// This member is required.
    public var status: BedrockAgentCoreControlClientTypes.TargetStatus?
    /// The reasons for the current status of the target.
    public var statusReasons: [Swift.String]?
    /// The configuration settings for the target.
    /// This member is required.
    public var targetConfiguration: BedrockAgentCoreControlClientTypes.TargetConfiguration?
    /// The unique identifier of the created target.
    /// This member is required.
    public var targetId: Swift.String?
    /// The timestamp when the target was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        createdAt: Foundation.Date? = nil,
        credentialProviderConfigurations: [BedrockAgentCoreControlClientTypes.CredentialProviderConfiguration]? = nil,
        description: Swift.String? = nil,
        gatewayArn: Swift.String? = nil,
        name: Swift.String? = nil,
        status: BedrockAgentCoreControlClientTypes.TargetStatus? = nil,
        statusReasons: [Swift.String]? = nil,
        targetConfiguration: BedrockAgentCoreControlClientTypes.TargetConfiguration? = nil,
        targetId: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.createdAt = createdAt
        self.credentialProviderConfigurations = credentialProviderConfigurations
        self.description = description
        self.gatewayArn = gatewayArn
        self.name = name
        self.status = status
        self.statusReasons = statusReasons
        self.targetConfiguration = targetConfiguration
        self.targetId = targetId
        self.updatedAt = updatedAt
    }
}

extension CreateGatewayTargetOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGatewayTargetOutput(createdAt: \(Swift.String(describing: createdAt)), credentialProviderConfigurations: \(Swift.String(describing: credentialProviderConfigurations)), gatewayArn: \(Swift.String(describing: gatewayArn)), status: \(Swift.String(describing: status)), statusReasons: \(Swift.String(describing: statusReasons)), targetConfiguration: \(Swift.String(describing: targetConfiguration)), targetId: \(Swift.String(describing: targetId)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct GetGatewayTargetOutput: Swift.Sendable {
    /// The timestamp when the gateway target was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The credential provider configurations for the gateway target.
    /// This member is required.
    public var credentialProviderConfigurations: [BedrockAgentCoreControlClientTypes.CredentialProviderConfiguration]?
    /// The description of the gateway target.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the gateway.
    /// This member is required.
    public var gatewayArn: Swift.String?
    /// The name of the gateway target.
    /// This member is required.
    public var name: Swift.String?
    /// The current status of the gateway target.
    /// This member is required.
    public var status: BedrockAgentCoreControlClientTypes.TargetStatus?
    /// The reasons for the current status of the gateway target.
    public var statusReasons: [Swift.String]?
    /// The configuration for a gateway target. This structure defines how the gateway connects to and interacts with the target endpoint.
    /// This member is required.
    public var targetConfiguration: BedrockAgentCoreControlClientTypes.TargetConfiguration?
    /// The unique identifier of the gateway target.
    /// This member is required.
    public var targetId: Swift.String?
    /// The timestamp when the gateway target was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        createdAt: Foundation.Date? = nil,
        credentialProviderConfigurations: [BedrockAgentCoreControlClientTypes.CredentialProviderConfiguration]? = nil,
        description: Swift.String? = nil,
        gatewayArn: Swift.String? = nil,
        name: Swift.String? = nil,
        status: BedrockAgentCoreControlClientTypes.TargetStatus? = nil,
        statusReasons: [Swift.String]? = nil,
        targetConfiguration: BedrockAgentCoreControlClientTypes.TargetConfiguration? = nil,
        targetId: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.createdAt = createdAt
        self.credentialProviderConfigurations = credentialProviderConfigurations
        self.description = description
        self.gatewayArn = gatewayArn
        self.name = name
        self.status = status
        self.statusReasons = statusReasons
        self.targetConfiguration = targetConfiguration
        self.targetId = targetId
        self.updatedAt = updatedAt
    }
}

extension GetGatewayTargetOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetGatewayTargetOutput(createdAt: \(Swift.String(describing: createdAt)), credentialProviderConfigurations: \(Swift.String(describing: credentialProviderConfigurations)), gatewayArn: \(Swift.String(describing: gatewayArn)), status: \(Swift.String(describing: status)), statusReasons: \(Swift.String(describing: statusReasons)), targetConfiguration: \(Swift.String(describing: targetConfiguration)), targetId: \(Swift.String(describing: targetId)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct UpdateGatewayTargetInput: Swift.Sendable {
    /// The updated credential provider configurations for the gateway target.
    /// This member is required.
    public var credentialProviderConfigurations: [BedrockAgentCoreControlClientTypes.CredentialProviderConfiguration]?
    /// The updated description for the gateway target.
    public var description: Swift.String?
    /// The unique identifier of the gateway associated with the target.
    /// This member is required.
    public var gatewayIdentifier: Swift.String?
    /// The updated name for the gateway target.
    /// This member is required.
    public var name: Swift.String?
    /// The configuration for a gateway target. This structure defines how the gateway connects to and interacts with the target endpoint.
    /// This member is required.
    public var targetConfiguration: BedrockAgentCoreControlClientTypes.TargetConfiguration?
    /// The unique identifier of the gateway target to update.
    /// This member is required.
    public var targetId: Swift.String?

    public init(
        credentialProviderConfigurations: [BedrockAgentCoreControlClientTypes.CredentialProviderConfiguration]? = nil,
        description: Swift.String? = nil,
        gatewayIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        targetConfiguration: BedrockAgentCoreControlClientTypes.TargetConfiguration? = nil,
        targetId: Swift.String? = nil
    ) {
        self.credentialProviderConfigurations = credentialProviderConfigurations
        self.description = description
        self.gatewayIdentifier = gatewayIdentifier
        self.name = name
        self.targetConfiguration = targetConfiguration
        self.targetId = targetId
    }
}

extension UpdateGatewayTargetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGatewayTargetInput(credentialProviderConfigurations: \(Swift.String(describing: credentialProviderConfigurations)), gatewayIdentifier: \(Swift.String(describing: gatewayIdentifier)), targetConfiguration: \(Swift.String(describing: targetConfiguration)), targetId: \(Swift.String(describing: targetId)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct UpdateGatewayTargetOutput: Swift.Sendable {
    /// The timestamp when the gateway target was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The updated credential provider configurations for the gateway target.
    /// This member is required.
    public var credentialProviderConfigurations: [BedrockAgentCoreControlClientTypes.CredentialProviderConfiguration]?
    /// The updated description of the gateway target.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the gateway.
    /// This member is required.
    public var gatewayArn: Swift.String?
    /// The updated name of the gateway target.
    /// This member is required.
    public var name: Swift.String?
    /// The current status of the updated gateway target.
    /// This member is required.
    public var status: BedrockAgentCoreControlClientTypes.TargetStatus?
    /// The reasons for the current status of the updated gateway target.
    public var statusReasons: [Swift.String]?
    /// The configuration for a gateway target. This structure defines how the gateway connects to and interacts with the target endpoint.
    /// This member is required.
    public var targetConfiguration: BedrockAgentCoreControlClientTypes.TargetConfiguration?
    /// The unique identifier of the updated gateway target.
    /// This member is required.
    public var targetId: Swift.String?
    /// The timestamp when the gateway target was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        createdAt: Foundation.Date? = nil,
        credentialProviderConfigurations: [BedrockAgentCoreControlClientTypes.CredentialProviderConfiguration]? = nil,
        description: Swift.String? = nil,
        gatewayArn: Swift.String? = nil,
        name: Swift.String? = nil,
        status: BedrockAgentCoreControlClientTypes.TargetStatus? = nil,
        statusReasons: [Swift.String]? = nil,
        targetConfiguration: BedrockAgentCoreControlClientTypes.TargetConfiguration? = nil,
        targetId: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.createdAt = createdAt
        self.credentialProviderConfigurations = credentialProviderConfigurations
        self.description = description
        self.gatewayArn = gatewayArn
        self.name = name
        self.status = status
        self.statusReasons = statusReasons
        self.targetConfiguration = targetConfiguration
        self.targetId = targetId
        self.updatedAt = updatedAt
    }
}

extension UpdateGatewayTargetOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGatewayTargetOutput(createdAt: \(Swift.String(describing: createdAt)), credentialProviderConfigurations: \(Swift.String(describing: credentialProviderConfigurations)), gatewayArn: \(Swift.String(describing: gatewayArn)), status: \(Swift.String(describing: status)), statusReasons: \(Swift.String(describing: statusReasons)), targetConfiguration: \(Swift.String(describing: targetConfiguration)), targetId: \(Swift.String(describing: targetId)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateAgentRuntimeInput {

    static func urlPathProvider(_ value: CreateAgentRuntimeInput) -> Swift.String? {
        return "/runtimes"
    }
}

extension CreateAgentRuntimeEndpointInput {

    static func urlPathProvider(_ value: CreateAgentRuntimeEndpointInput) -> Swift.String? {
        guard let agentRuntimeId = value.agentRuntimeId else {
            return nil
        }
        return "/runtimes/\(agentRuntimeId.urlPercentEncoding())/runtime-endpoints"
    }
}

extension CreateApiKeyCredentialProviderInput {

    static func urlPathProvider(_ value: CreateApiKeyCredentialProviderInput) -> Swift.String? {
        return "/identities/CreateApiKeyCredentialProvider"
    }
}

extension CreateBrowserInput {

    static func urlPathProvider(_ value: CreateBrowserInput) -> Swift.String? {
        return "/browsers"
    }
}

extension CreateCodeInterpreterInput {

    static func urlPathProvider(_ value: CreateCodeInterpreterInput) -> Swift.String? {
        return "/code-interpreters"
    }
}

extension CreateGatewayInput {

    static func urlPathProvider(_ value: CreateGatewayInput) -> Swift.String? {
        return "/gateways"
    }
}

extension CreateGatewayTargetInput {

    static func urlPathProvider(_ value: CreateGatewayTargetInput) -> Swift.String? {
        guard let gatewayIdentifier = value.gatewayIdentifier else {
            return nil
        }
        return "/gateways/\(gatewayIdentifier.urlPercentEncoding())/targets"
    }
}

extension CreateMemoryInput {

    static func urlPathProvider(_ value: CreateMemoryInput) -> Swift.String? {
        return "/memories/create"
    }
}

extension CreateOauth2CredentialProviderInput {

    static func urlPathProvider(_ value: CreateOauth2CredentialProviderInput) -> Swift.String? {
        return "/identities/CreateOauth2CredentialProvider"
    }
}

extension CreateWorkloadIdentityInput {

    static func urlPathProvider(_ value: CreateWorkloadIdentityInput) -> Swift.String? {
        return "/identities/CreateWorkloadIdentity"
    }
}

extension DeleteAgentRuntimeInput {

    static func urlPathProvider(_ value: DeleteAgentRuntimeInput) -> Swift.String? {
        guard let agentRuntimeId = value.agentRuntimeId else {
            return nil
        }
        return "/runtimes/\(agentRuntimeId.urlPercentEncoding())"
    }
}

extension DeleteAgentRuntimeEndpointInput {

    static func urlPathProvider(_ value: DeleteAgentRuntimeEndpointInput) -> Swift.String? {
        guard let agentRuntimeId = value.agentRuntimeId else {
            return nil
        }
        guard let endpointName = value.endpointName else {
            return nil
        }
        return "/runtimes/\(agentRuntimeId.urlPercentEncoding())/runtime-endpoints/\(endpointName.urlPercentEncoding())"
    }
}

extension DeleteAgentRuntimeEndpointInput {

    static func queryItemProvider(_ value: DeleteAgentRuntimeEndpointInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeleteApiKeyCredentialProviderInput {

    static func urlPathProvider(_ value: DeleteApiKeyCredentialProviderInput) -> Swift.String? {
        return "/identities/DeleteApiKeyCredentialProvider"
    }
}

extension DeleteBrowserInput {

    static func urlPathProvider(_ value: DeleteBrowserInput) -> Swift.String? {
        guard let browserId = value.browserId else {
            return nil
        }
        return "/browsers/\(browserId.urlPercentEncoding())"
    }
}

extension DeleteBrowserInput {

    static func queryItemProvider(_ value: DeleteBrowserInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeleteCodeInterpreterInput {

    static func urlPathProvider(_ value: DeleteCodeInterpreterInput) -> Swift.String? {
        guard let codeInterpreterId = value.codeInterpreterId else {
            return nil
        }
        return "/code-interpreters/\(codeInterpreterId.urlPercentEncoding())"
    }
}

extension DeleteCodeInterpreterInput {

    static func queryItemProvider(_ value: DeleteCodeInterpreterInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeleteGatewayInput {

    static func urlPathProvider(_ value: DeleteGatewayInput) -> Swift.String? {
        guard let gatewayIdentifier = value.gatewayIdentifier else {
            return nil
        }
        return "/gateways/\(gatewayIdentifier.urlPercentEncoding())"
    }
}

extension DeleteGatewayTargetInput {

    static func urlPathProvider(_ value: DeleteGatewayTargetInput) -> Swift.String? {
        guard let gatewayIdentifier = value.gatewayIdentifier else {
            return nil
        }
        guard let targetId = value.targetId else {
            return nil
        }
        return "/gateways/\(gatewayIdentifier.urlPercentEncoding())/targets/\(targetId.urlPercentEncoding())"
    }
}

extension DeleteMemoryInput {

    static func urlPathProvider(_ value: DeleteMemoryInput) -> Swift.String? {
        guard let memoryId = value.memoryId else {
            return nil
        }
        return "/memories/\(memoryId.urlPercentEncoding())/delete"
    }
}

extension DeleteMemoryInput {

    static func queryItemProvider(_ value: DeleteMemoryInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeleteOauth2CredentialProviderInput {

    static func urlPathProvider(_ value: DeleteOauth2CredentialProviderInput) -> Swift.String? {
        return "/identities/DeleteOauth2CredentialProvider"
    }
}

extension DeleteWorkloadIdentityInput {

    static func urlPathProvider(_ value: DeleteWorkloadIdentityInput) -> Swift.String? {
        return "/identities/DeleteWorkloadIdentity"
    }
}

extension GetAgentRuntimeInput {

    static func urlPathProvider(_ value: GetAgentRuntimeInput) -> Swift.String? {
        guard let agentRuntimeId = value.agentRuntimeId else {
            return nil
        }
        return "/runtimes/\(agentRuntimeId.urlPercentEncoding())"
    }
}

extension GetAgentRuntimeInput {

    static func queryItemProvider(_ value: GetAgentRuntimeInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let agentRuntimeVersion = value.agentRuntimeVersion {
            let agentRuntimeVersionQueryItem = Smithy.URIQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(agentRuntimeVersion).urlPercentEncoding())
            items.append(agentRuntimeVersionQueryItem)
        }
        return items
    }
}

extension GetAgentRuntimeEndpointInput {

    static func urlPathProvider(_ value: GetAgentRuntimeEndpointInput) -> Swift.String? {
        guard let agentRuntimeId = value.agentRuntimeId else {
            return nil
        }
        guard let endpointName = value.endpointName else {
            return nil
        }
        return "/runtimes/\(agentRuntimeId.urlPercentEncoding())/runtime-endpoints/\(endpointName.urlPercentEncoding())"
    }
}

extension GetApiKeyCredentialProviderInput {

    static func urlPathProvider(_ value: GetApiKeyCredentialProviderInput) -> Swift.String? {
        return "/identities/GetApiKeyCredentialProvider"
    }
}

extension GetBrowserInput {

    static func urlPathProvider(_ value: GetBrowserInput) -> Swift.String? {
        guard let browserId = value.browserId else {
            return nil
        }
        return "/browsers/\(browserId.urlPercentEncoding())"
    }
}

extension GetCodeInterpreterInput {

    static func urlPathProvider(_ value: GetCodeInterpreterInput) -> Swift.String? {
        guard let codeInterpreterId = value.codeInterpreterId else {
            return nil
        }
        return "/code-interpreters/\(codeInterpreterId.urlPercentEncoding())"
    }
}

extension GetGatewayInput {

    static func urlPathProvider(_ value: GetGatewayInput) -> Swift.String? {
        guard let gatewayIdentifier = value.gatewayIdentifier else {
            return nil
        }
        return "/gateways/\(gatewayIdentifier.urlPercentEncoding())"
    }
}

extension GetGatewayTargetInput {

    static func urlPathProvider(_ value: GetGatewayTargetInput) -> Swift.String? {
        guard let gatewayIdentifier = value.gatewayIdentifier else {
            return nil
        }
        guard let targetId = value.targetId else {
            return nil
        }
        return "/gateways/\(gatewayIdentifier.urlPercentEncoding())/targets/\(targetId.urlPercentEncoding())"
    }
}

extension GetMemoryInput {

    static func urlPathProvider(_ value: GetMemoryInput) -> Swift.String? {
        guard let memoryId = value.memoryId else {
            return nil
        }
        return "/memories/\(memoryId.urlPercentEncoding())/details"
    }
}

extension GetOauth2CredentialProviderInput {

    static func urlPathProvider(_ value: GetOauth2CredentialProviderInput) -> Swift.String? {
        return "/identities/GetOauth2CredentialProvider"
    }
}

extension GetTokenVaultInput {

    static func urlPathProvider(_ value: GetTokenVaultInput) -> Swift.String? {
        return "/identities/get-token-vault"
    }
}

extension GetWorkloadIdentityInput {

    static func urlPathProvider(_ value: GetWorkloadIdentityInput) -> Swift.String? {
        return "/identities/GetWorkloadIdentity"
    }
}

extension ListAgentRuntimeEndpointsInput {

    static func urlPathProvider(_ value: ListAgentRuntimeEndpointsInput) -> Swift.String? {
        guard let agentRuntimeId = value.agentRuntimeId else {
            return nil
        }
        return "/runtimes/\(agentRuntimeId.urlPercentEncoding())/runtime-endpoints"
    }
}

extension ListAgentRuntimeEndpointsInput {

    static func queryItemProvider(_ value: ListAgentRuntimeEndpointsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListAgentRuntimesInput {

    static func urlPathProvider(_ value: ListAgentRuntimesInput) -> Swift.String? {
        return "/runtimes"
    }
}

extension ListAgentRuntimesInput {

    static func queryItemProvider(_ value: ListAgentRuntimesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListAgentRuntimeVersionsInput {

    static func urlPathProvider(_ value: ListAgentRuntimeVersionsInput) -> Swift.String? {
        guard let agentRuntimeId = value.agentRuntimeId else {
            return nil
        }
        return "/runtimes/\(agentRuntimeId.urlPercentEncoding())/versions"
    }
}

extension ListAgentRuntimeVersionsInput {

    static func queryItemProvider(_ value: ListAgentRuntimeVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListApiKeyCredentialProvidersInput {

    static func urlPathProvider(_ value: ListApiKeyCredentialProvidersInput) -> Swift.String? {
        return "/identities/ListApiKeyCredentialProviders"
    }
}

extension ListBrowsersInput {

    static func urlPathProvider(_ value: ListBrowsersInput) -> Swift.String? {
        return "/browsers"
    }
}

extension ListBrowsersInput {

    static func queryItemProvider(_ value: ListBrowsersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let type = value.type {
            let typeQueryItem = Smithy.URIQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        return items
    }
}

extension ListCodeInterpretersInput {

    static func urlPathProvider(_ value: ListCodeInterpretersInput) -> Swift.String? {
        return "/code-interpreters"
    }
}

extension ListCodeInterpretersInput {

    static func queryItemProvider(_ value: ListCodeInterpretersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let type = value.type {
            let typeQueryItem = Smithy.URIQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        return items
    }
}

extension ListGatewaysInput {

    static func urlPathProvider(_ value: ListGatewaysInput) -> Swift.String? {
        return "/gateways"
    }
}

extension ListGatewaysInput {

    static func queryItemProvider(_ value: ListGatewaysInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListGatewayTargetsInput {

    static func urlPathProvider(_ value: ListGatewayTargetsInput) -> Swift.String? {
        guard let gatewayIdentifier = value.gatewayIdentifier else {
            return nil
        }
        return "/gateways/\(gatewayIdentifier.urlPercentEncoding())/targets"
    }
}

extension ListGatewayTargetsInput {

    static func queryItemProvider(_ value: ListGatewayTargetsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListMemoriesInput {

    static func urlPathProvider(_ value: ListMemoriesInput) -> Swift.String? {
        return "/memories"
    }
}

extension ListOauth2CredentialProvidersInput {

    static func urlPathProvider(_ value: ListOauth2CredentialProvidersInput) -> Swift.String? {
        return "/identities/ListOauth2CredentialProviders"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension ListWorkloadIdentitiesInput {

    static func urlPathProvider(_ value: ListWorkloadIdentitiesInput) -> Swift.String? {
        return "/identities/ListWorkloadIdentities"
    }
}

extension SetTokenVaultCMKInput {

    static func urlPathProvider(_ value: SetTokenVaultCMKInput) -> Swift.String? {
        return "/identities/set-token-vault-cmk"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateAgentRuntimeInput {

    static func urlPathProvider(_ value: UpdateAgentRuntimeInput) -> Swift.String? {
        guard let agentRuntimeId = value.agentRuntimeId else {
            return nil
        }
        return "/runtimes/\(agentRuntimeId.urlPercentEncoding())"
    }
}

extension UpdateAgentRuntimeEndpointInput {

    static func urlPathProvider(_ value: UpdateAgentRuntimeEndpointInput) -> Swift.String? {
        guard let agentRuntimeId = value.agentRuntimeId else {
            return nil
        }
        guard let endpointName = value.endpointName else {
            return nil
        }
        return "/runtimes/\(agentRuntimeId.urlPercentEncoding())/runtime-endpoints/\(endpointName.urlPercentEncoding())"
    }
}

extension UpdateApiKeyCredentialProviderInput {

    static func urlPathProvider(_ value: UpdateApiKeyCredentialProviderInput) -> Swift.String? {
        return "/identities/UpdateApiKeyCredentialProvider"
    }
}

extension UpdateGatewayInput {

    static func urlPathProvider(_ value: UpdateGatewayInput) -> Swift.String? {
        guard let gatewayIdentifier = value.gatewayIdentifier else {
            return nil
        }
        return "/gateways/\(gatewayIdentifier.urlPercentEncoding())"
    }
}

extension UpdateGatewayTargetInput {

    static func urlPathProvider(_ value: UpdateGatewayTargetInput) -> Swift.String? {
        guard let gatewayIdentifier = value.gatewayIdentifier else {
            return nil
        }
        guard let targetId = value.targetId else {
            return nil
        }
        return "/gateways/\(gatewayIdentifier.urlPercentEncoding())/targets/\(targetId.urlPercentEncoding())"
    }
}

extension UpdateMemoryInput {

    static func urlPathProvider(_ value: UpdateMemoryInput) -> Swift.String? {
        guard let memoryId = value.memoryId else {
            return nil
        }
        return "/memories/\(memoryId.urlPercentEncoding())/update"
    }
}

extension UpdateOauth2CredentialProviderInput {

    static func urlPathProvider(_ value: UpdateOauth2CredentialProviderInput) -> Swift.String? {
        return "/identities/UpdateOauth2CredentialProvider"
    }
}

extension UpdateWorkloadIdentityInput {

    static func urlPathProvider(_ value: UpdateWorkloadIdentityInput) -> Swift.String? {
        return "/identities/UpdateWorkloadIdentity"
    }
}

extension CreateAgentRuntimeInput {

    static func write(value: CreateAgentRuntimeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["agentRuntimeArtifact"].write(value.agentRuntimeArtifact, with: BedrockAgentCoreControlClientTypes.AgentRuntimeArtifact.write(value:to:))
        try writer["agentRuntimeName"].write(value.agentRuntimeName)
        try writer["authorizerConfiguration"].write(value.authorizerConfiguration, with: BedrockAgentCoreControlClientTypes.AuthorizerConfiguration.write(value:to:))
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["environmentVariables"].writeMap(value.environmentVariables, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["networkConfiguration"].write(value.networkConfiguration, with: BedrockAgentCoreControlClientTypes.NetworkConfiguration.write(value:to:))
        try writer["protocolConfiguration"].write(value.protocolConfiguration, with: BedrockAgentCoreControlClientTypes.ProtocolConfiguration.write(value:to:))
        try writer["requestHeaderConfiguration"].write(value.requestHeaderConfiguration, with: BedrockAgentCoreControlClientTypes.RequestHeaderConfiguration.write(value:to:))
        try writer["roleArn"].write(value.roleArn)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateAgentRuntimeEndpointInput {

    static func write(value: CreateAgentRuntimeEndpointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["agentRuntimeVersion"].write(value.agentRuntimeVersion)
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateApiKeyCredentialProviderInput {

    static func write(value: CreateApiKeyCredentialProviderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiKey"].write(value.apiKey)
        try writer["name"].write(value.name)
    }
}

extension CreateBrowserInput {

    static func write(value: CreateBrowserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["executionRoleArn"].write(value.executionRoleArn)
        try writer["name"].write(value.name)
        try writer["networkConfiguration"].write(value.networkConfiguration, with: BedrockAgentCoreControlClientTypes.BrowserNetworkConfiguration.write(value:to:))
        try writer["recording"].write(value.recording, with: BedrockAgentCoreControlClientTypes.RecordingConfig.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateCodeInterpreterInput {

    static func write(value: CreateCodeInterpreterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["executionRoleArn"].write(value.executionRoleArn)
        try writer["name"].write(value.name)
        try writer["networkConfiguration"].write(value.networkConfiguration, with: BedrockAgentCoreControlClientTypes.CodeInterpreterNetworkConfiguration.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateGatewayInput {

    static func write(value: CreateGatewayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authorizerConfiguration"].write(value.authorizerConfiguration, with: BedrockAgentCoreControlClientTypes.AuthorizerConfiguration.write(value:to:))
        try writer["authorizerType"].write(value.authorizerType)
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["exceptionLevel"].write(value.exceptionLevel)
        try writer["kmsKeyArn"].write(value.kmsKeyArn)
        try writer["name"].write(value.name)
        try writer["protocolConfiguration"].write(value.protocolConfiguration, with: BedrockAgentCoreControlClientTypes.GatewayProtocolConfiguration.write(value:to:))
        try writer["protocolType"].write(value.protocolType)
        try writer["roleArn"].write(value.roleArn)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateGatewayTargetInput {

    static func write(value: CreateGatewayTargetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["credentialProviderConfigurations"].writeList(value.credentialProviderConfigurations, memberWritingClosure: BedrockAgentCoreControlClientTypes.CredentialProviderConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["targetConfiguration"].write(value.targetConfiguration, with: BedrockAgentCoreControlClientTypes.TargetConfiguration.write(value:to:))
    }
}

extension CreateMemoryInput {

    static func write(value: CreateMemoryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["encryptionKeyArn"].write(value.encryptionKeyArn)
        try writer["eventExpiryDuration"].write(value.eventExpiryDuration)
        try writer["memoryExecutionRoleArn"].write(value.memoryExecutionRoleArn)
        try writer["memoryStrategies"].writeList(value.memoryStrategies, memberWritingClosure: BedrockAgentCoreControlClientTypes.MemoryStrategyInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
    }
}

extension CreateOauth2CredentialProviderInput {

    static func write(value: CreateOauth2CredentialProviderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["credentialProviderVendor"].write(value.credentialProviderVendor)
        try writer["name"].write(value.name)
        try writer["oauth2ProviderConfigInput"].write(value.oauth2ProviderConfigInput, with: BedrockAgentCoreControlClientTypes.Oauth2ProviderConfigInput.write(value:to:))
    }
}

extension CreateWorkloadIdentityInput {

    static func write(value: CreateWorkloadIdentityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["allowedResourceOauth2ReturnUrls"].writeList(value.allowedResourceOauth2ReturnUrls, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
    }
}

extension DeleteApiKeyCredentialProviderInput {

    static func write(value: DeleteApiKeyCredentialProviderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
    }
}

extension DeleteOauth2CredentialProviderInput {

    static func write(value: DeleteOauth2CredentialProviderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
    }
}

extension DeleteWorkloadIdentityInput {

    static func write(value: DeleteWorkloadIdentityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
    }
}

extension GetApiKeyCredentialProviderInput {

    static func write(value: GetApiKeyCredentialProviderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
    }
}

extension GetOauth2CredentialProviderInput {

    static func write(value: GetOauth2CredentialProviderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
    }
}

extension GetTokenVaultInput {

    static func write(value: GetTokenVaultInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tokenVaultId"].write(value.tokenVaultId)
    }
}

extension GetWorkloadIdentityInput {

    static func write(value: GetWorkloadIdentityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
    }
}

extension ListApiKeyCredentialProvidersInput {

    static func write(value: ListApiKeyCredentialProvidersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListMemoriesInput {

    static func write(value: ListMemoriesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListOauth2CredentialProvidersInput {

    static func write(value: ListOauth2CredentialProvidersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListWorkloadIdentitiesInput {

    static func write(value: ListWorkloadIdentitiesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension SetTokenVaultCMKInput {

    static func write(value: SetTokenVaultCMKInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["kmsConfiguration"].write(value.kmsConfiguration, with: BedrockAgentCoreControlClientTypes.KmsConfiguration.write(value:to:))
        try writer["tokenVaultId"].write(value.tokenVaultId)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateAgentRuntimeInput {

    static func write(value: UpdateAgentRuntimeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["agentRuntimeArtifact"].write(value.agentRuntimeArtifact, with: BedrockAgentCoreControlClientTypes.AgentRuntimeArtifact.write(value:to:))
        try writer["authorizerConfiguration"].write(value.authorizerConfiguration, with: BedrockAgentCoreControlClientTypes.AuthorizerConfiguration.write(value:to:))
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["environmentVariables"].writeMap(value.environmentVariables, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["networkConfiguration"].write(value.networkConfiguration, with: BedrockAgentCoreControlClientTypes.NetworkConfiguration.write(value:to:))
        try writer["protocolConfiguration"].write(value.protocolConfiguration, with: BedrockAgentCoreControlClientTypes.ProtocolConfiguration.write(value:to:))
        try writer["requestHeaderConfiguration"].write(value.requestHeaderConfiguration, with: BedrockAgentCoreControlClientTypes.RequestHeaderConfiguration.write(value:to:))
        try writer["roleArn"].write(value.roleArn)
    }
}

extension UpdateAgentRuntimeEndpointInput {

    static func write(value: UpdateAgentRuntimeEndpointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["agentRuntimeVersion"].write(value.agentRuntimeVersion)
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
    }
}

extension UpdateApiKeyCredentialProviderInput {

    static func write(value: UpdateApiKeyCredentialProviderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiKey"].write(value.apiKey)
        try writer["name"].write(value.name)
    }
}

extension UpdateGatewayInput {

    static func write(value: UpdateGatewayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authorizerConfiguration"].write(value.authorizerConfiguration, with: BedrockAgentCoreControlClientTypes.AuthorizerConfiguration.write(value:to:))
        try writer["authorizerType"].write(value.authorizerType)
        try writer["description"].write(value.description)
        try writer["exceptionLevel"].write(value.exceptionLevel)
        try writer["kmsKeyArn"].write(value.kmsKeyArn)
        try writer["name"].write(value.name)
        try writer["protocolConfiguration"].write(value.protocolConfiguration, with: BedrockAgentCoreControlClientTypes.GatewayProtocolConfiguration.write(value:to:))
        try writer["protocolType"].write(value.protocolType)
        try writer["roleArn"].write(value.roleArn)
    }
}

extension UpdateGatewayTargetInput {

    static func write(value: UpdateGatewayTargetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["credentialProviderConfigurations"].writeList(value.credentialProviderConfigurations, memberWritingClosure: BedrockAgentCoreControlClientTypes.CredentialProviderConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["targetConfiguration"].write(value.targetConfiguration, with: BedrockAgentCoreControlClientTypes.TargetConfiguration.write(value:to:))
    }
}

extension UpdateMemoryInput {

    static func write(value: UpdateMemoryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["eventExpiryDuration"].write(value.eventExpiryDuration)
        try writer["memoryExecutionRoleArn"].write(value.memoryExecutionRoleArn)
        try writer["memoryStrategies"].write(value.memoryStrategies, with: BedrockAgentCoreControlClientTypes.ModifyMemoryStrategies.write(value:to:))
    }
}

extension UpdateOauth2CredentialProviderInput {

    static func write(value: UpdateOauth2CredentialProviderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["credentialProviderVendor"].write(value.credentialProviderVendor)
        try writer["name"].write(value.name)
        try writer["oauth2ProviderConfigInput"].write(value.oauth2ProviderConfigInput, with: BedrockAgentCoreControlClientTypes.Oauth2ProviderConfigInput.write(value:to:))
    }
}

extension UpdateWorkloadIdentityInput {

    static func write(value: UpdateWorkloadIdentityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["allowedResourceOauth2ReturnUrls"].writeList(value.allowedResourceOauth2ReturnUrls, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
    }
}

extension CreateAgentRuntimeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAgentRuntimeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAgentRuntimeOutput()
        value.agentRuntimeArn = try reader["agentRuntimeArn"].readIfPresent() ?? ""
        value.agentRuntimeId = try reader["agentRuntimeId"].readIfPresent() ?? ""
        value.agentRuntimeVersion = try reader["agentRuntimeVersion"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.workloadIdentityDetails = try reader["workloadIdentityDetails"].readIfPresent(with: BedrockAgentCoreControlClientTypes.WorkloadIdentityDetails.read(from:))
        return value
    }
}

extension CreateAgentRuntimeEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAgentRuntimeEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAgentRuntimeEndpointOutput()
        value.agentRuntimeArn = try reader["agentRuntimeArn"].readIfPresent() ?? ""
        value.agentRuntimeEndpointArn = try reader["agentRuntimeEndpointArn"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.targetVersion = try reader["targetVersion"].readIfPresent() ?? ""
        return value
    }
}

extension CreateApiKeyCredentialProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateApiKeyCredentialProviderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateApiKeyCredentialProviderOutput()
        value.apiKeySecretArn = try reader["apiKeySecretArn"].readIfPresent(with: BedrockAgentCoreControlClientTypes.Secret.read(from:))
        value.credentialProviderArn = try reader["credentialProviderArn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension CreateBrowserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateBrowserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateBrowserOutput()
        value.browserArn = try reader["browserArn"].readIfPresent() ?? ""
        value.browserId = try reader["browserId"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension CreateCodeInterpreterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCodeInterpreterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCodeInterpreterOutput()
        value.codeInterpreterArn = try reader["codeInterpreterArn"].readIfPresent() ?? ""
        value.codeInterpreterId = try reader["codeInterpreterId"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension CreateGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGatewayOutput()
        value.authorizerConfiguration = try reader["authorizerConfiguration"].readIfPresent(with: BedrockAgentCoreControlClientTypes.AuthorizerConfiguration.read(from:))
        value.authorizerType = try reader["authorizerType"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.exceptionLevel = try reader["exceptionLevel"].readIfPresent()
        value.gatewayArn = try reader["gatewayArn"].readIfPresent() ?? ""
        value.gatewayId = try reader["gatewayId"].readIfPresent() ?? ""
        value.gatewayUrl = try reader["gatewayUrl"].readIfPresent()
        value.kmsKeyArn = try reader["kmsKeyArn"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.protocolConfiguration = try reader["protocolConfiguration"].readIfPresent(with: BedrockAgentCoreControlClientTypes.GatewayProtocolConfiguration.read(from:))
        value.protocolType = try reader["protocolType"].readIfPresent() ?? .sdkUnknown("")
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusReasons = try reader["statusReasons"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.workloadIdentityDetails = try reader["workloadIdentityDetails"].readIfPresent(with: BedrockAgentCoreControlClientTypes.WorkloadIdentityDetails.read(from:))
        return value
    }
}

extension CreateGatewayTargetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateGatewayTargetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGatewayTargetOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.credentialProviderConfigurations = try reader["credentialProviderConfigurations"].readListIfPresent(memberReadingClosure: BedrockAgentCoreControlClientTypes.CredentialProviderConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.description = try reader["description"].readIfPresent()
        value.gatewayArn = try reader["gatewayArn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusReasons = try reader["statusReasons"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.targetConfiguration = try reader["targetConfiguration"].readIfPresent(with: BedrockAgentCoreControlClientTypes.TargetConfiguration.read(from:))
        value.targetId = try reader["targetId"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension CreateMemoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMemoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMemoryOutput()
        value.memory = try reader["memory"].readIfPresent(with: BedrockAgentCoreControlClientTypes.Memory.read(from:))
        return value
    }
}

extension CreateOauth2CredentialProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateOauth2CredentialProviderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateOauth2CredentialProviderOutput()
        value.clientSecretArn = try reader["clientSecretArn"].readIfPresent(with: BedrockAgentCoreControlClientTypes.Secret.read(from:))
        value.credentialProviderArn = try reader["credentialProviderArn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension CreateWorkloadIdentityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateWorkloadIdentityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWorkloadIdentityOutput()
        value.allowedResourceOauth2ReturnUrls = try reader["allowedResourceOauth2ReturnUrls"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["name"].readIfPresent() ?? ""
        value.workloadIdentityArn = try reader["workloadIdentityArn"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteAgentRuntimeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAgentRuntimeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteAgentRuntimeOutput()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeleteAgentRuntimeEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAgentRuntimeEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteAgentRuntimeEndpointOutput()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeleteApiKeyCredentialProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteApiKeyCredentialProviderOutput {
        return DeleteApiKeyCredentialProviderOutput()
    }
}

extension DeleteBrowserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteBrowserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteBrowserOutput()
        value.browserId = try reader["browserId"].readIfPresent() ?? ""
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeleteCodeInterpreterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCodeInterpreterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteCodeInterpreterOutput()
        value.codeInterpreterId = try reader["codeInterpreterId"].readIfPresent() ?? ""
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeleteGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteGatewayOutput()
        value.gatewayId = try reader["gatewayId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusReasons = try reader["statusReasons"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DeleteGatewayTargetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteGatewayTargetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteGatewayTargetOutput()
        value.gatewayArn = try reader["gatewayArn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusReasons = try reader["statusReasons"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.targetId = try reader["targetId"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteMemoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMemoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteMemoryOutput()
        value.memoryId = try reader["memoryId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension DeleteOauth2CredentialProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteOauth2CredentialProviderOutput {
        return DeleteOauth2CredentialProviderOutput()
    }
}

extension DeleteWorkloadIdentityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteWorkloadIdentityOutput {
        return DeleteWorkloadIdentityOutput()
    }
}

extension GetAgentRuntimeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAgentRuntimeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAgentRuntimeOutput()
        value.agentRuntimeArn = try reader["agentRuntimeArn"].readIfPresent() ?? ""
        value.agentRuntimeArtifact = try reader["agentRuntimeArtifact"].readIfPresent(with: BedrockAgentCoreControlClientTypes.AgentRuntimeArtifact.read(from:))
        value.agentRuntimeId = try reader["agentRuntimeId"].readIfPresent() ?? ""
        value.agentRuntimeName = try reader["agentRuntimeName"].readIfPresent() ?? ""
        value.agentRuntimeVersion = try reader["agentRuntimeVersion"].readIfPresent() ?? ""
        value.authorizerConfiguration = try reader["authorizerConfiguration"].readIfPresent(with: BedrockAgentCoreControlClientTypes.AuthorizerConfiguration.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.environmentVariables = try reader["environmentVariables"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.networkConfiguration = try reader["networkConfiguration"].readIfPresent(with: BedrockAgentCoreControlClientTypes.NetworkConfiguration.read(from:))
        value.protocolConfiguration = try reader["protocolConfiguration"].readIfPresent(with: BedrockAgentCoreControlClientTypes.ProtocolConfiguration.read(from:))
        value.requestHeaderConfiguration = try reader["requestHeaderConfiguration"].readIfPresent(with: BedrockAgentCoreControlClientTypes.RequestHeaderConfiguration.read(from:))
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.workloadIdentityDetails = try reader["workloadIdentityDetails"].readIfPresent(with: BedrockAgentCoreControlClientTypes.WorkloadIdentityDetails.read(from:))
        return value
    }
}

extension GetAgentRuntimeEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAgentRuntimeEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAgentRuntimeEndpointOutput()
        value.agentRuntimeArn = try reader["agentRuntimeArn"].readIfPresent() ?? ""
        value.agentRuntimeEndpointArn = try reader["agentRuntimeEndpointArn"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.liveVersion = try reader["liveVersion"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.targetVersion = try reader["targetVersion"].readIfPresent()
        return value
    }
}

extension GetApiKeyCredentialProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetApiKeyCredentialProviderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetApiKeyCredentialProviderOutput()
        value.apiKeySecretArn = try reader["apiKeySecretArn"].readIfPresent(with: BedrockAgentCoreControlClientTypes.Secret.read(from:))
        value.createdTime = try reader["createdTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.credentialProviderArn = try reader["credentialProviderArn"].readIfPresent() ?? ""
        value.lastUpdatedTime = try reader["lastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension GetBrowserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBrowserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBrowserOutput()
        value.browserArn = try reader["browserArn"].readIfPresent() ?? ""
        value.browserId = try reader["browserId"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.executionRoleArn = try reader["executionRoleArn"].readIfPresent()
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.name = try reader["name"].readIfPresent() ?? ""
        value.networkConfiguration = try reader["networkConfiguration"].readIfPresent(with: BedrockAgentCoreControlClientTypes.BrowserNetworkConfiguration.read(from:))
        value.recording = try reader["recording"].readIfPresent(with: BedrockAgentCoreControlClientTypes.RecordingConfig.read(from:))
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GetCodeInterpreterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCodeInterpreterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCodeInterpreterOutput()
        value.codeInterpreterArn = try reader["codeInterpreterArn"].readIfPresent() ?? ""
        value.codeInterpreterId = try reader["codeInterpreterId"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.executionRoleArn = try reader["executionRoleArn"].readIfPresent()
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.name = try reader["name"].readIfPresent() ?? ""
        value.networkConfiguration = try reader["networkConfiguration"].readIfPresent(with: BedrockAgentCoreControlClientTypes.CodeInterpreterNetworkConfiguration.read(from:))
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GetGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGatewayOutput()
        value.authorizerConfiguration = try reader["authorizerConfiguration"].readIfPresent(with: BedrockAgentCoreControlClientTypes.AuthorizerConfiguration.read(from:))
        value.authorizerType = try reader["authorizerType"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.exceptionLevel = try reader["exceptionLevel"].readIfPresent()
        value.gatewayArn = try reader["gatewayArn"].readIfPresent() ?? ""
        value.gatewayId = try reader["gatewayId"].readIfPresent() ?? ""
        value.gatewayUrl = try reader["gatewayUrl"].readIfPresent()
        value.kmsKeyArn = try reader["kmsKeyArn"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.protocolConfiguration = try reader["protocolConfiguration"].readIfPresent(with: BedrockAgentCoreControlClientTypes.GatewayProtocolConfiguration.read(from:))
        value.protocolType = try reader["protocolType"].readIfPresent() ?? .sdkUnknown("")
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusReasons = try reader["statusReasons"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.workloadIdentityDetails = try reader["workloadIdentityDetails"].readIfPresent(with: BedrockAgentCoreControlClientTypes.WorkloadIdentityDetails.read(from:))
        return value
    }
}

extension GetGatewayTargetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetGatewayTargetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGatewayTargetOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.credentialProviderConfigurations = try reader["credentialProviderConfigurations"].readListIfPresent(memberReadingClosure: BedrockAgentCoreControlClientTypes.CredentialProviderConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.description = try reader["description"].readIfPresent()
        value.gatewayArn = try reader["gatewayArn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusReasons = try reader["statusReasons"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.targetConfiguration = try reader["targetConfiguration"].readIfPresent(with: BedrockAgentCoreControlClientTypes.TargetConfiguration.read(from:))
        value.targetId = try reader["targetId"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension GetMemoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMemoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMemoryOutput()
        value.memory = try reader["memory"].readIfPresent(with: BedrockAgentCoreControlClientTypes.Memory.read(from:))
        return value
    }
}

extension GetOauth2CredentialProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetOauth2CredentialProviderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetOauth2CredentialProviderOutput()
        value.clientSecretArn = try reader["clientSecretArn"].readIfPresent(with: BedrockAgentCoreControlClientTypes.Secret.read(from:))
        value.createdTime = try reader["createdTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.credentialProviderArn = try reader["credentialProviderArn"].readIfPresent() ?? ""
        value.credentialProviderVendor = try reader["credentialProviderVendor"].readIfPresent() ?? .sdkUnknown("")
        value.lastUpdatedTime = try reader["lastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.name = try reader["name"].readIfPresent() ?? ""
        value.oauth2ProviderConfigOutput = try reader["oauth2ProviderConfigOutput"].readIfPresent(with: BedrockAgentCoreControlClientTypes.Oauth2ProviderConfigOutput.read(from:))
        return value
    }
}

extension GetTokenVaultOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTokenVaultOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTokenVaultOutput()
        value.kmsConfiguration = try reader["kmsConfiguration"].readIfPresent(with: BedrockAgentCoreControlClientTypes.KmsConfiguration.read(from:))
        value.lastModifiedDate = try reader["lastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.tokenVaultId = try reader["tokenVaultId"].readIfPresent() ?? ""
        return value
    }
}

extension GetWorkloadIdentityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWorkloadIdentityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWorkloadIdentityOutput()
        value.allowedResourceOauth2ReturnUrls = try reader["allowedResourceOauth2ReturnUrls"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdTime = try reader["createdTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedTime = try reader["lastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.name = try reader["name"].readIfPresent() ?? ""
        value.workloadIdentityArn = try reader["workloadIdentityArn"].readIfPresent() ?? ""
        return value
    }
}

extension ListAgentRuntimeEndpointsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAgentRuntimeEndpointsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAgentRuntimeEndpointsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.runtimeEndpoints = try reader["runtimeEndpoints"].readListIfPresent(memberReadingClosure: BedrockAgentCoreControlClientTypes.AgentRuntimeEndpoint.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListAgentRuntimesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAgentRuntimesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAgentRuntimesOutput()
        value.agentRuntimes = try reader["agentRuntimes"].readListIfPresent(memberReadingClosure: BedrockAgentCoreControlClientTypes.AgentRuntime.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAgentRuntimeVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAgentRuntimeVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAgentRuntimeVersionsOutput()
        value.agentRuntimes = try reader["agentRuntimes"].readListIfPresent(memberReadingClosure: BedrockAgentCoreControlClientTypes.AgentRuntime.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListApiKeyCredentialProvidersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListApiKeyCredentialProvidersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListApiKeyCredentialProvidersOutput()
        value.credentialProviders = try reader["credentialProviders"].readListIfPresent(memberReadingClosure: BedrockAgentCoreControlClientTypes.ApiKeyCredentialProviderItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListBrowsersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBrowsersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBrowsersOutput()
        value.browserSummaries = try reader["browserSummaries"].readListIfPresent(memberReadingClosure: BedrockAgentCoreControlClientTypes.BrowserSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListCodeInterpretersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCodeInterpretersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCodeInterpretersOutput()
        value.codeInterpreterSummaries = try reader["codeInterpreterSummaries"].readListIfPresent(memberReadingClosure: BedrockAgentCoreControlClientTypes.CodeInterpreterSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListGatewaysOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListGatewaysOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListGatewaysOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: BedrockAgentCoreControlClientTypes.GatewaySummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListGatewayTargetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListGatewayTargetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListGatewayTargetsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: BedrockAgentCoreControlClientTypes.TargetSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListMemoriesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMemoriesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMemoriesOutput()
        value.memories = try reader["memories"].readListIfPresent(memberReadingClosure: BedrockAgentCoreControlClientTypes.MemorySummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListOauth2CredentialProvidersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOauth2CredentialProvidersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOauth2CredentialProvidersOutput()
        value.credentialProviders = try reader["credentialProviders"].readListIfPresent(memberReadingClosure: BedrockAgentCoreControlClientTypes.Oauth2CredentialProviderItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListWorkloadIdentitiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWorkloadIdentitiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWorkloadIdentitiesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.workloadIdentities = try reader["workloadIdentities"].readListIfPresent(memberReadingClosure: BedrockAgentCoreControlClientTypes.WorkloadIdentityType.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension SetTokenVaultCMKOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SetTokenVaultCMKOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SetTokenVaultCMKOutput()
        value.kmsConfiguration = try reader["kmsConfiguration"].readIfPresent(with: BedrockAgentCoreControlClientTypes.KmsConfiguration.read(from:))
        value.lastModifiedDate = try reader["lastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.tokenVaultId = try reader["tokenVaultId"].readIfPresent() ?? ""
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateAgentRuntimeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAgentRuntimeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAgentRuntimeOutput()
        value.agentRuntimeArn = try reader["agentRuntimeArn"].readIfPresent() ?? ""
        value.agentRuntimeId = try reader["agentRuntimeId"].readIfPresent() ?? ""
        value.agentRuntimeVersion = try reader["agentRuntimeVersion"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.workloadIdentityDetails = try reader["workloadIdentityDetails"].readIfPresent(with: BedrockAgentCoreControlClientTypes.WorkloadIdentityDetails.read(from:))
        return value
    }
}

extension UpdateAgentRuntimeEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAgentRuntimeEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAgentRuntimeEndpointOutput()
        value.agentRuntimeArn = try reader["agentRuntimeArn"].readIfPresent() ?? ""
        value.agentRuntimeEndpointArn = try reader["agentRuntimeEndpointArn"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.liveVersion = try reader["liveVersion"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.targetVersion = try reader["targetVersion"].readIfPresent()
        return value
    }
}

extension UpdateApiKeyCredentialProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateApiKeyCredentialProviderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateApiKeyCredentialProviderOutput()
        value.apiKeySecretArn = try reader["apiKeySecretArn"].readIfPresent(with: BedrockAgentCoreControlClientTypes.Secret.read(from:))
        value.createdTime = try reader["createdTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.credentialProviderArn = try reader["credentialProviderArn"].readIfPresent() ?? ""
        value.lastUpdatedTime = try reader["lastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateGatewayOutput()
        value.authorizerConfiguration = try reader["authorizerConfiguration"].readIfPresent(with: BedrockAgentCoreControlClientTypes.AuthorizerConfiguration.read(from:))
        value.authorizerType = try reader["authorizerType"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.exceptionLevel = try reader["exceptionLevel"].readIfPresent()
        value.gatewayArn = try reader["gatewayArn"].readIfPresent() ?? ""
        value.gatewayId = try reader["gatewayId"].readIfPresent() ?? ""
        value.gatewayUrl = try reader["gatewayUrl"].readIfPresent()
        value.kmsKeyArn = try reader["kmsKeyArn"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.protocolConfiguration = try reader["protocolConfiguration"].readIfPresent(with: BedrockAgentCoreControlClientTypes.GatewayProtocolConfiguration.read(from:))
        value.protocolType = try reader["protocolType"].readIfPresent() ?? .sdkUnknown("")
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusReasons = try reader["statusReasons"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.workloadIdentityDetails = try reader["workloadIdentityDetails"].readIfPresent(with: BedrockAgentCoreControlClientTypes.WorkloadIdentityDetails.read(from:))
        return value
    }
}

extension UpdateGatewayTargetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateGatewayTargetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateGatewayTargetOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.credentialProviderConfigurations = try reader["credentialProviderConfigurations"].readListIfPresent(memberReadingClosure: BedrockAgentCoreControlClientTypes.CredentialProviderConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.description = try reader["description"].readIfPresent()
        value.gatewayArn = try reader["gatewayArn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusReasons = try reader["statusReasons"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.targetConfiguration = try reader["targetConfiguration"].readIfPresent(with: BedrockAgentCoreControlClientTypes.TargetConfiguration.read(from:))
        value.targetId = try reader["targetId"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension UpdateMemoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateMemoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateMemoryOutput()
        value.memory = try reader["memory"].readIfPresent(with: BedrockAgentCoreControlClientTypes.Memory.read(from:))
        return value
    }
}

extension UpdateOauth2CredentialProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateOauth2CredentialProviderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateOauth2CredentialProviderOutput()
        value.clientSecretArn = try reader["clientSecretArn"].readIfPresent(with: BedrockAgentCoreControlClientTypes.Secret.read(from:))
        value.createdTime = try reader["createdTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.credentialProviderArn = try reader["credentialProviderArn"].readIfPresent() ?? ""
        value.credentialProviderVendor = try reader["credentialProviderVendor"].readIfPresent() ?? .sdkUnknown("")
        value.lastUpdatedTime = try reader["lastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.name = try reader["name"].readIfPresent() ?? ""
        value.oauth2ProviderConfigOutput = try reader["oauth2ProviderConfigOutput"].readIfPresent(with: BedrockAgentCoreControlClientTypes.Oauth2ProviderConfigOutput.read(from:))
        return value
    }
}

extension UpdateWorkloadIdentityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateWorkloadIdentityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateWorkloadIdentityOutput()
        value.allowedResourceOauth2ReturnUrls = try reader["allowedResourceOauth2ReturnUrls"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdTime = try reader["createdTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedTime = try reader["lastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.name = try reader["name"].readIfPresent() ?? ""
        value.workloadIdentityArn = try reader["workloadIdentityArn"].readIfPresent() ?? ""
        return value
    }
}

enum CreateAgentRuntimeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAgentRuntimeEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateApiKeyCredentialProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "DecryptionFailure": return try DecryptionFailure.makeError(baseError: baseError)
            case "EncryptionFailure": return try EncryptionFailure.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateBrowserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCodeInterpreterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateGatewayTargetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateMemoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateOauth2CredentialProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "DecryptionFailure": return try DecryptionFailure.makeError(baseError: baseError)
            case "EncryptionFailure": return try EncryptionFailure.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateWorkloadIdentityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAgentRuntimeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAgentRuntimeEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteApiKeyCredentialProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteBrowserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCodeInterpreterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteGatewayTargetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMemoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteOauth2CredentialProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteWorkloadIdentityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAgentRuntimeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAgentRuntimeEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetApiKeyCredentialProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DecryptionFailure": return try DecryptionFailure.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBrowserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCodeInterpreterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetGatewayTargetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMemoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetOauth2CredentialProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DecryptionFailure": return try DecryptionFailure.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTokenVaultOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWorkloadIdentityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAgentRuntimeEndpointsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAgentRuntimesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAgentRuntimeVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListApiKeyCredentialProvidersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBrowsersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCodeInterpretersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListGatewaysOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListGatewayTargetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMemoriesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOauth2CredentialProvidersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWorkloadIdentitiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SetTokenVaultCMKOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAgentRuntimeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAgentRuntimeEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateApiKeyCredentialProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "DecryptionFailure": return try DecryptionFailure.makeError(baseError: baseError)
            case "EncryptionFailure": return try EncryptionFailure.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateGatewayTargetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateMemoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateOauth2CredentialProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "DecryptionFailure": return try DecryptionFailure.makeError(baseError: baseError)
            case "EncryptionFailure": return try EncryptionFailure.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateWorkloadIdentityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: BedrockAgentCoreControlClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DecryptionFailure {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> DecryptionFailure {
        let reader = baseError.errorBodyReader
        var value = DecryptionFailure()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EncryptionFailure {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> EncryptionFailure {
        let reader = baseError.errorBodyReader
        var value = EncryptionFailure()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = ResourceLimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnauthorizedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnauthorizedException {
        let reader = baseError.errorBodyReader
        var value = UnauthorizedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceException {
        let reader = baseError.errorBodyReader
        var value = ServiceException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottledException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottledException {
        let reader = baseError.errorBodyReader
        var value = ThrottledException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConcurrentModificationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConcurrentModificationException {
        let reader = baseError.errorBodyReader
        var value = ConcurrentModificationException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.WorkloadIdentityDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.WorkloadIdentityDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.WorkloadIdentityDetails()
        value.workloadIdentityArn = try reader["workloadIdentityArn"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.Secret {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.Secret {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.Secret()
        value.secretArn = try reader["secretArn"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.GatewayProtocolConfiguration {

    static func write(value: BedrockAgentCoreControlClientTypes.GatewayProtocolConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .mcp(mcp):
                try writer["mcp"].write(mcp, with: BedrockAgentCoreControlClientTypes.MCPGatewayConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.GatewayProtocolConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "mcp":
                return .mcp(try reader["mcp"].read(with: BedrockAgentCoreControlClientTypes.MCPGatewayConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentCoreControlClientTypes.MCPGatewayConfiguration {

    static func write(value: BedrockAgentCoreControlClientTypes.MCPGatewayConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["instructions"].write(value.instructions)
        try writer["searchType"].write(value.searchType)
        try writer["supportedVersions"].writeList(value.supportedVersions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.MCPGatewayConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.MCPGatewayConfiguration()
        value.supportedVersions = try reader["supportedVersions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.instructions = try reader["instructions"].readIfPresent()
        value.searchType = try reader["searchType"].readIfPresent()
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.AuthorizerConfiguration {

    static func write(value: BedrockAgentCoreControlClientTypes.AuthorizerConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .customjwtauthorizer(customjwtauthorizer):
                try writer["customJWTAuthorizer"].write(customjwtauthorizer, with: BedrockAgentCoreControlClientTypes.CustomJWTAuthorizerConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.AuthorizerConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "customJWTAuthorizer":
                return .customjwtauthorizer(try reader["customJWTAuthorizer"].read(with: BedrockAgentCoreControlClientTypes.CustomJWTAuthorizerConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentCoreControlClientTypes.CustomJWTAuthorizerConfiguration {

    static func write(value: BedrockAgentCoreControlClientTypes.CustomJWTAuthorizerConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["allowedAudience"].writeList(value.allowedAudience, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["allowedClients"].writeList(value.allowedClients, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["discoveryUrl"].write(value.discoveryUrl)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.CustomJWTAuthorizerConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.CustomJWTAuthorizerConfiguration()
        value.discoveryUrl = try reader["discoveryUrl"].readIfPresent() ?? ""
        value.allowedAudience = try reader["allowedAudience"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.allowedClients = try reader["allowedClients"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.TargetConfiguration {

    static func write(value: BedrockAgentCoreControlClientTypes.TargetConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .mcp(mcp):
                try writer["mcp"].write(mcp, with: BedrockAgentCoreControlClientTypes.McpTargetConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.TargetConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "mcp":
                return .mcp(try reader["mcp"].read(with: BedrockAgentCoreControlClientTypes.McpTargetConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentCoreControlClientTypes.McpTargetConfiguration {

    static func write(value: BedrockAgentCoreControlClientTypes.McpTargetConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .lambda(lambda):
                try writer["lambda"].write(lambda, with: BedrockAgentCoreControlClientTypes.McpLambdaTargetConfiguration.write(value:to:))
            case let .openapischema(openapischema):
                try writer["openApiSchema"].write(openapischema, with: BedrockAgentCoreControlClientTypes.ApiSchemaConfiguration.write(value:to:))
            case let .smithymodel(smithymodel):
                try writer["smithyModel"].write(smithymodel, with: BedrockAgentCoreControlClientTypes.ApiSchemaConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.McpTargetConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "openApiSchema":
                return .openapischema(try reader["openApiSchema"].read(with: BedrockAgentCoreControlClientTypes.ApiSchemaConfiguration.read(from:)))
            case "smithyModel":
                return .smithymodel(try reader["smithyModel"].read(with: BedrockAgentCoreControlClientTypes.ApiSchemaConfiguration.read(from:)))
            case "lambda":
                return .lambda(try reader["lambda"].read(with: BedrockAgentCoreControlClientTypes.McpLambdaTargetConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentCoreControlClientTypes.McpLambdaTargetConfiguration {

    static func write(value: BedrockAgentCoreControlClientTypes.McpLambdaTargetConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["lambdaArn"].write(value.lambdaArn)
        try writer["toolSchema"].write(value.toolSchema, with: BedrockAgentCoreControlClientTypes.ToolSchema.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.McpLambdaTargetConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.McpLambdaTargetConfiguration()
        value.lambdaArn = try reader["lambdaArn"].readIfPresent() ?? ""
        value.toolSchema = try reader["toolSchema"].readIfPresent(with: BedrockAgentCoreControlClientTypes.ToolSchema.read(from:))
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.ToolSchema {

    static func write(value: BedrockAgentCoreControlClientTypes.ToolSchema?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .inlinepayload(inlinepayload):
                try writer["inlinePayload"].writeList(inlinepayload, memberWritingClosure: BedrockAgentCoreControlClientTypes.ToolDefinition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .s3(s3):
                try writer["s3"].write(s3, with: BedrockAgentCoreControlClientTypes.S3Configuration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.ToolSchema {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "s3":
                return .s3(try reader["s3"].read(with: BedrockAgentCoreControlClientTypes.S3Configuration.read(from:)))
            case "inlinePayload":
                return .inlinepayload(try reader["inlinePayload"].readList(memberReadingClosure: BedrockAgentCoreControlClientTypes.ToolDefinition.read(from:), memberNodeInfo: "member", isFlattened: false))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentCoreControlClientTypes.ToolDefinition {

    static func write(value: BedrockAgentCoreControlClientTypes.ToolDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["inputSchema"].write(value.inputSchema, with: BedrockAgentCoreControlClientTypes.SchemaDefinition.write(value:to:))
        try writer["name"].write(value.name)
        try writer["outputSchema"].write(value.outputSchema, with: BedrockAgentCoreControlClientTypes.SchemaDefinition.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.ToolDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.ToolDefinition()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent() ?? ""
        value.inputSchema = try reader["inputSchema"].readIfPresent(with: BedrockAgentCoreControlClientTypes.SchemaDefinition.read(from:))
        value.outputSchema = try reader["outputSchema"].readIfPresent(with: BedrockAgentCoreControlClientTypes.SchemaDefinition.read(from:))
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.SchemaDefinition {

    static func write(value: BedrockAgentCoreControlClientTypes.SchemaDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["items"].write(value.items, with: BedrockAgentCoreControlClientTypes.SchemaDefinition.write(value:to:))
        try writer["properties"].writeMap(value.properties, valueWritingClosure: BedrockAgentCoreControlClientTypes.SchemaDefinition.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["required"].writeList(value.`required`, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.SchemaDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.SchemaDefinition()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.properties = try reader["properties"].readMapIfPresent(valueReadingClosure: BedrockAgentCoreControlClientTypes.SchemaDefinition.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.`required` = try reader["required"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.items = try reader["items"].readIfPresent(with: BedrockAgentCoreControlClientTypes.SchemaDefinition.read(from:))
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.S3Configuration {

    static func write(value: BedrockAgentCoreControlClientTypes.S3Configuration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketOwnerAccountId"].write(value.bucketOwnerAccountId)
        try writer["uri"].write(value.uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.S3Configuration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.S3Configuration()
        value.uri = try reader["uri"].readIfPresent()
        value.bucketOwnerAccountId = try reader["bucketOwnerAccountId"].readIfPresent()
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.ApiSchemaConfiguration {

    static func write(value: BedrockAgentCoreControlClientTypes.ApiSchemaConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .inlinepayload(inlinepayload):
                try writer["inlinePayload"].write(inlinepayload)
            case let .s3(s3):
                try writer["s3"].write(s3, with: BedrockAgentCoreControlClientTypes.S3Configuration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.ApiSchemaConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "s3":
                return .s3(try reader["s3"].read(with: BedrockAgentCoreControlClientTypes.S3Configuration.read(from:)))
            case "inlinePayload":
                return .inlinepayload(try reader["inlinePayload"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentCoreControlClientTypes.CredentialProviderConfiguration {

    static func write(value: BedrockAgentCoreControlClientTypes.CredentialProviderConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["credentialProvider"].write(value.credentialProvider, with: BedrockAgentCoreControlClientTypes.CredentialProvider.write(value:to:))
        try writer["credentialProviderType"].write(value.credentialProviderType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.CredentialProviderConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.CredentialProviderConfiguration()
        value.credentialProviderType = try reader["credentialProviderType"].readIfPresent() ?? .sdkUnknown("")
        value.credentialProvider = try reader["credentialProvider"].readIfPresent(with: BedrockAgentCoreControlClientTypes.CredentialProvider.read(from:))
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.CredentialProvider {

    static func write(value: BedrockAgentCoreControlClientTypes.CredentialProvider?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .apikeycredentialprovider(apikeycredentialprovider):
                try writer["apiKeyCredentialProvider"].write(apikeycredentialprovider, with: BedrockAgentCoreControlClientTypes.GatewayApiKeyCredentialProvider.write(value:to:))
            case let .oauthcredentialprovider(oauthcredentialprovider):
                try writer["oauthCredentialProvider"].write(oauthcredentialprovider, with: BedrockAgentCoreControlClientTypes.OAuthCredentialProvider.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.CredentialProvider {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "oauthCredentialProvider":
                return .oauthcredentialprovider(try reader["oauthCredentialProvider"].read(with: BedrockAgentCoreControlClientTypes.OAuthCredentialProvider.read(from:)))
            case "apiKeyCredentialProvider":
                return .apikeycredentialprovider(try reader["apiKeyCredentialProvider"].read(with: BedrockAgentCoreControlClientTypes.GatewayApiKeyCredentialProvider.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentCoreControlClientTypes.GatewayApiKeyCredentialProvider {

    static func write(value: BedrockAgentCoreControlClientTypes.GatewayApiKeyCredentialProvider?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["credentialLocation"].write(value.credentialLocation)
        try writer["credentialParameterName"].write(value.credentialParameterName)
        try writer["credentialPrefix"].write(value.credentialPrefix)
        try writer["providerArn"].write(value.providerArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.GatewayApiKeyCredentialProvider {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.GatewayApiKeyCredentialProvider()
        value.providerArn = try reader["providerArn"].readIfPresent() ?? ""
        value.credentialParameterName = try reader["credentialParameterName"].readIfPresent()
        value.credentialPrefix = try reader["credentialPrefix"].readIfPresent()
        value.credentialLocation = try reader["credentialLocation"].readIfPresent()
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.OAuthCredentialProvider {

    static func write(value: BedrockAgentCoreControlClientTypes.OAuthCredentialProvider?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["customParameters"].writeMap(value.customParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["providerArn"].write(value.providerArn)
        try writer["scopes"].writeList(value.scopes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.OAuthCredentialProvider {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.OAuthCredentialProvider()
        value.providerArn = try reader["providerArn"].readIfPresent() ?? ""
        value.scopes = try reader["scopes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.customParameters = try reader["customParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.Memory {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.Memory {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.Memory()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.encryptionKeyArn = try reader["encryptionKeyArn"].readIfPresent()
        value.memoryExecutionRoleArn = try reader["memoryExecutionRoleArn"].readIfPresent()
        value.eventExpiryDuration = try reader["eventExpiryDuration"].readIfPresent() ?? 0
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.strategies = try reader["strategies"].readListIfPresent(memberReadingClosure: BedrockAgentCoreControlClientTypes.MemoryStrategy.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.MemoryStrategy {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.MemoryStrategy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.MemoryStrategy()
        value.strategyId = try reader["strategyId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.configuration = try reader["configuration"].readIfPresent(with: BedrockAgentCoreControlClientTypes.StrategyConfiguration.read(from:))
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.namespaces = try reader["namespaces"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.StrategyConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.StrategyConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.StrategyConfiguration()
        value.type = try reader["type"].readIfPresent()
        value.extraction = try reader["extraction"].readIfPresent(with: BedrockAgentCoreControlClientTypes.ExtractionConfiguration.read(from:))
        value.consolidation = try reader["consolidation"].readIfPresent(with: BedrockAgentCoreControlClientTypes.ConsolidationConfiguration.read(from:))
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.ConsolidationConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.ConsolidationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "customConsolidationConfiguration":
                return .customconsolidationconfiguration(try reader["customConsolidationConfiguration"].read(with: BedrockAgentCoreControlClientTypes.CustomConsolidationConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentCoreControlClientTypes.CustomConsolidationConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.CustomConsolidationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "semanticConsolidationOverride":
                return .semanticconsolidationoverride(try reader["semanticConsolidationOverride"].read(with: BedrockAgentCoreControlClientTypes.SemanticConsolidationOverride.read(from:)))
            case "summaryConsolidationOverride":
                return .summaryconsolidationoverride(try reader["summaryConsolidationOverride"].read(with: BedrockAgentCoreControlClientTypes.SummaryConsolidationOverride.read(from:)))
            case "userPreferenceConsolidationOverride":
                return .userpreferenceconsolidationoverride(try reader["userPreferenceConsolidationOverride"].read(with: BedrockAgentCoreControlClientTypes.UserPreferenceConsolidationOverride.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentCoreControlClientTypes.UserPreferenceConsolidationOverride {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.UserPreferenceConsolidationOverride {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.UserPreferenceConsolidationOverride()
        value.appendToPrompt = try reader["appendToPrompt"].readIfPresent() ?? ""
        value.modelId = try reader["modelId"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.SummaryConsolidationOverride {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.SummaryConsolidationOverride {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.SummaryConsolidationOverride()
        value.appendToPrompt = try reader["appendToPrompt"].readIfPresent() ?? ""
        value.modelId = try reader["modelId"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.SemanticConsolidationOverride {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.SemanticConsolidationOverride {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.SemanticConsolidationOverride()
        value.appendToPrompt = try reader["appendToPrompt"].readIfPresent() ?? ""
        value.modelId = try reader["modelId"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.ExtractionConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.ExtractionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "customExtractionConfiguration":
                return .customextractionconfiguration(try reader["customExtractionConfiguration"].read(with: BedrockAgentCoreControlClientTypes.CustomExtractionConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentCoreControlClientTypes.CustomExtractionConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.CustomExtractionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "semanticExtractionOverride":
                return .semanticextractionoverride(try reader["semanticExtractionOverride"].read(with: BedrockAgentCoreControlClientTypes.SemanticExtractionOverride.read(from:)))
            case "userPreferenceExtractionOverride":
                return .userpreferenceextractionoverride(try reader["userPreferenceExtractionOverride"].read(with: BedrockAgentCoreControlClientTypes.UserPreferenceExtractionOverride.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentCoreControlClientTypes.UserPreferenceExtractionOverride {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.UserPreferenceExtractionOverride {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.UserPreferenceExtractionOverride()
        value.appendToPrompt = try reader["appendToPrompt"].readIfPresent() ?? ""
        value.modelId = try reader["modelId"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.SemanticExtractionOverride {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.SemanticExtractionOverride {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.SemanticExtractionOverride()
        value.appendToPrompt = try reader["appendToPrompt"].readIfPresent() ?? ""
        value.modelId = try reader["modelId"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.AgentRuntimeArtifact {

    static func write(value: BedrockAgentCoreControlClientTypes.AgentRuntimeArtifact?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .containerconfiguration(containerconfiguration):
                try writer["containerConfiguration"].write(containerconfiguration, with: BedrockAgentCoreControlClientTypes.ContainerConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.AgentRuntimeArtifact {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "containerConfiguration":
                return .containerconfiguration(try reader["containerConfiguration"].read(with: BedrockAgentCoreControlClientTypes.ContainerConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentCoreControlClientTypes.ContainerConfiguration {

    static func write(value: BedrockAgentCoreControlClientTypes.ContainerConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["containerUri"].write(value.containerUri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.ContainerConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.ContainerConfiguration()
        value.containerUri = try reader["containerUri"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.NetworkConfiguration {

    static func write(value: BedrockAgentCoreControlClientTypes.NetworkConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["networkMode"].write(value.networkMode)
        try writer["networkModeConfig"].write(value.networkModeConfig, with: BedrockAgentCoreControlClientTypes.VpcConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.NetworkConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.NetworkConfiguration()
        value.networkMode = try reader["networkMode"].readIfPresent() ?? .sdkUnknown("")
        value.networkModeConfig = try reader["networkModeConfig"].readIfPresent(with: BedrockAgentCoreControlClientTypes.VpcConfig.read(from:))
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.VpcConfig {

    static func write(value: BedrockAgentCoreControlClientTypes.VpcConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["securityGroups"].writeList(value.securityGroups, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["subnets"].writeList(value.subnets, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.VpcConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.VpcConfig()
        value.securityGroups = try reader["securityGroups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.subnets = try reader["subnets"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.ProtocolConfiguration {

    static func write(value: BedrockAgentCoreControlClientTypes.ProtocolConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["serverProtocol"].write(value.serverProtocol)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.ProtocolConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.ProtocolConfiguration()
        value.serverProtocol = try reader["serverProtocol"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.RequestHeaderConfiguration {

    static func write(value: BedrockAgentCoreControlClientTypes.RequestHeaderConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .requestheaderallowlist(requestheaderallowlist):
                try writer["requestHeaderAllowlist"].writeList(requestheaderallowlist, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.RequestHeaderConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "requestHeaderAllowlist":
                return .requestheaderallowlist(try reader["requestHeaderAllowlist"].readList(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentCoreControlClientTypes.BrowserNetworkConfiguration {

    static func write(value: BedrockAgentCoreControlClientTypes.BrowserNetworkConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["networkMode"].write(value.networkMode)
        try writer["vpcConfig"].write(value.vpcConfig, with: BedrockAgentCoreControlClientTypes.VpcConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.BrowserNetworkConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.BrowserNetworkConfiguration()
        value.networkMode = try reader["networkMode"].readIfPresent() ?? BedrockAgentCoreControlClientTypes.BrowserNetworkMode.`public`
        value.vpcConfig = try reader["vpcConfig"].readIfPresent(with: BedrockAgentCoreControlClientTypes.VpcConfig.read(from:))
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.RecordingConfig {

    static func write(value: BedrockAgentCoreControlClientTypes.RecordingConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enabled"].write(value.enabled)
        try writer["s3Location"].write(value.s3Location, with: BedrockAgentCoreControlClientTypes.S3Location.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.RecordingConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.RecordingConfig()
        value.enabled = try reader["enabled"].readIfPresent() ?? false
        value.s3Location = try reader["s3Location"].readIfPresent(with: BedrockAgentCoreControlClientTypes.S3Location.read(from:))
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.S3Location {

    static func write(value: BedrockAgentCoreControlClientTypes.S3Location?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucket"].write(value.bucket)
        try writer["prefix"].write(value.`prefix`)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.S3Location {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.S3Location()
        value.bucket = try reader["bucket"].readIfPresent() ?? ""
        value.`prefix` = try reader["prefix"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.CodeInterpreterNetworkConfiguration {

    static func write(value: BedrockAgentCoreControlClientTypes.CodeInterpreterNetworkConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["networkMode"].write(value.networkMode)
        try writer["vpcConfig"].write(value.vpcConfig, with: BedrockAgentCoreControlClientTypes.VpcConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.CodeInterpreterNetworkConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.CodeInterpreterNetworkConfiguration()
        value.networkMode = try reader["networkMode"].readIfPresent() ?? BedrockAgentCoreControlClientTypes.CodeInterpreterNetworkMode.sandbox
        value.vpcConfig = try reader["vpcConfig"].readIfPresent(with: BedrockAgentCoreControlClientTypes.VpcConfig.read(from:))
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.Oauth2ProviderConfigOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.Oauth2ProviderConfigOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "customOauth2ProviderConfig":
                return .customoauth2providerconfig(try reader["customOauth2ProviderConfig"].read(with: BedrockAgentCoreControlClientTypes.CustomOauth2ProviderConfigOutput.read(from:)))
            case "googleOauth2ProviderConfig":
                return .googleoauth2providerconfig(try reader["googleOauth2ProviderConfig"].read(with: BedrockAgentCoreControlClientTypes.GoogleOauth2ProviderConfigOutput.read(from:)))
            case "githubOauth2ProviderConfig":
                return .githuboauth2providerconfig(try reader["githubOauth2ProviderConfig"].read(with: BedrockAgentCoreControlClientTypes.GithubOauth2ProviderConfigOutput.read(from:)))
            case "slackOauth2ProviderConfig":
                return .slackoauth2providerconfig(try reader["slackOauth2ProviderConfig"].read(with: BedrockAgentCoreControlClientTypes.SlackOauth2ProviderConfigOutput.read(from:)))
            case "salesforceOauth2ProviderConfig":
                return .salesforceoauth2providerconfig(try reader["salesforceOauth2ProviderConfig"].read(with: BedrockAgentCoreControlClientTypes.SalesforceOauth2ProviderConfigOutput.read(from:)))
            case "microsoftOauth2ProviderConfig":
                return .microsoftoauth2providerconfig(try reader["microsoftOauth2ProviderConfig"].read(with: BedrockAgentCoreControlClientTypes.MicrosoftOauth2ProviderConfigOutput.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentCoreControlClientTypes.MicrosoftOauth2ProviderConfigOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.MicrosoftOauth2ProviderConfigOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.MicrosoftOauth2ProviderConfigOutput()
        value.oauthDiscovery = try reader["oauthDiscovery"].readIfPresent(with: BedrockAgentCoreControlClientTypes.Oauth2Discovery.read(from:))
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.Oauth2Discovery {

    static func write(value: BedrockAgentCoreControlClientTypes.Oauth2Discovery?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .authorizationservermetadata(authorizationservermetadata):
                try writer["authorizationServerMetadata"].write(authorizationservermetadata, with: BedrockAgentCoreControlClientTypes.Oauth2AuthorizationServerMetadata.write(value:to:))
            case let .discoveryurl(discoveryurl):
                try writer["discoveryUrl"].write(discoveryurl)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.Oauth2Discovery {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "discoveryUrl":
                return .discoveryurl(try reader["discoveryUrl"].read())
            case "authorizationServerMetadata":
                return .authorizationservermetadata(try reader["authorizationServerMetadata"].read(with: BedrockAgentCoreControlClientTypes.Oauth2AuthorizationServerMetadata.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentCoreControlClientTypes.Oauth2AuthorizationServerMetadata {

    static func write(value: BedrockAgentCoreControlClientTypes.Oauth2AuthorizationServerMetadata?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authorizationEndpoint"].write(value.authorizationEndpoint)
        try writer["issuer"].write(value.issuer)
        try writer["responseTypes"].writeList(value.responseTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tokenEndpoint"].write(value.tokenEndpoint)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.Oauth2AuthorizationServerMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.Oauth2AuthorizationServerMetadata()
        value.issuer = try reader["issuer"].readIfPresent() ?? ""
        value.authorizationEndpoint = try reader["authorizationEndpoint"].readIfPresent() ?? ""
        value.tokenEndpoint = try reader["tokenEndpoint"].readIfPresent() ?? ""
        value.responseTypes = try reader["responseTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.SalesforceOauth2ProviderConfigOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.SalesforceOauth2ProviderConfigOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.SalesforceOauth2ProviderConfigOutput()
        value.oauthDiscovery = try reader["oauthDiscovery"].readIfPresent(with: BedrockAgentCoreControlClientTypes.Oauth2Discovery.read(from:))
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.SlackOauth2ProviderConfigOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.SlackOauth2ProviderConfigOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.SlackOauth2ProviderConfigOutput()
        value.oauthDiscovery = try reader["oauthDiscovery"].readIfPresent(with: BedrockAgentCoreControlClientTypes.Oauth2Discovery.read(from:))
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.GithubOauth2ProviderConfigOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.GithubOauth2ProviderConfigOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.GithubOauth2ProviderConfigOutput()
        value.oauthDiscovery = try reader["oauthDiscovery"].readIfPresent(with: BedrockAgentCoreControlClientTypes.Oauth2Discovery.read(from:))
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.GoogleOauth2ProviderConfigOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.GoogleOauth2ProviderConfigOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.GoogleOauth2ProviderConfigOutput()
        value.oauthDiscovery = try reader["oauthDiscovery"].readIfPresent(with: BedrockAgentCoreControlClientTypes.Oauth2Discovery.read(from:))
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.CustomOauth2ProviderConfigOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.CustomOauth2ProviderConfigOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.CustomOauth2ProviderConfigOutput()
        value.oauthDiscovery = try reader["oauthDiscovery"].readIfPresent(with: BedrockAgentCoreControlClientTypes.Oauth2Discovery.read(from:))
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.KmsConfiguration {

    static func write(value: BedrockAgentCoreControlClientTypes.KmsConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["keyType"].write(value.keyType)
        try writer["kmsKeyArn"].write(value.kmsKeyArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.KmsConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.KmsConfiguration()
        value.keyType = try reader["keyType"].readIfPresent() ?? .sdkUnknown("")
        value.kmsKeyArn = try reader["kmsKeyArn"].readIfPresent()
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.AgentRuntimeEndpoint {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.AgentRuntimeEndpoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.AgentRuntimeEndpoint()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.liveVersion = try reader["liveVersion"].readIfPresent()
        value.targetVersion = try reader["targetVersion"].readIfPresent()
        value.agentRuntimeEndpointArn = try reader["agentRuntimeEndpointArn"].readIfPresent() ?? ""
        value.agentRuntimeArn = try reader["agentRuntimeArn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.id = try reader["id"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.AgentRuntime {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.AgentRuntime {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.AgentRuntime()
        value.agentRuntimeArn = try reader["agentRuntimeArn"].readIfPresent() ?? ""
        value.agentRuntimeId = try reader["agentRuntimeId"].readIfPresent() ?? ""
        value.agentRuntimeVersion = try reader["agentRuntimeVersion"].readIfPresent() ?? ""
        value.agentRuntimeName = try reader["agentRuntimeName"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent() ?? ""
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.ApiKeyCredentialProviderItem {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.ApiKeyCredentialProviderItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.ApiKeyCredentialProviderItem()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.credentialProviderArn = try reader["credentialProviderArn"].readIfPresent() ?? ""
        value.createdTime = try reader["createdTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedTime = try reader["lastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.BrowserSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.BrowserSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.BrowserSummary()
        value.browserId = try reader["browserId"].readIfPresent() ?? ""
        value.browserArn = try reader["browserArn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.CodeInterpreterSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.CodeInterpreterSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.CodeInterpreterSummary()
        value.codeInterpreterId = try reader["codeInterpreterId"].readIfPresent() ?? ""
        value.codeInterpreterArn = try reader["codeInterpreterArn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.GatewaySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.GatewaySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.GatewaySummary()
        value.gatewayId = try reader["gatewayId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.description = try reader["description"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.authorizerType = try reader["authorizerType"].readIfPresent() ?? .sdkUnknown("")
        value.protocolType = try reader["protocolType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.TargetSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.TargetSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.TargetSummary()
        value.targetId = try reader["targetId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.description = try reader["description"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.MemorySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.MemorySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.MemorySummary()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.Oauth2CredentialProviderItem {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.Oauth2CredentialProviderItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.Oauth2CredentialProviderItem()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.credentialProviderVendor = try reader["credentialProviderVendor"].readIfPresent() ?? .sdkUnknown("")
        value.credentialProviderArn = try reader["credentialProviderArn"].readIfPresent() ?? ""
        value.createdTime = try reader["createdTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedTime = try reader["lastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.WorkloadIdentityType {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.WorkloadIdentityType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.WorkloadIdentityType()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.workloadIdentityArn = try reader["workloadIdentityArn"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreControlClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreControlClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentCoreControlClientTypes.MemoryStrategyInput {

    static func write(value: BedrockAgentCoreControlClientTypes.MemoryStrategyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .custommemorystrategy(custommemorystrategy):
                try writer["customMemoryStrategy"].write(custommemorystrategy, with: BedrockAgentCoreControlClientTypes.CustomMemoryStrategyInput.write(value:to:))
            case let .semanticmemorystrategy(semanticmemorystrategy):
                try writer["semanticMemoryStrategy"].write(semanticmemorystrategy, with: BedrockAgentCoreControlClientTypes.SemanticMemoryStrategyInput.write(value:to:))
            case let .summarymemorystrategy(summarymemorystrategy):
                try writer["summaryMemoryStrategy"].write(summarymemorystrategy, with: BedrockAgentCoreControlClientTypes.SummaryMemoryStrategyInput.write(value:to:))
            case let .userpreferencememorystrategy(userpreferencememorystrategy):
                try writer["userPreferenceMemoryStrategy"].write(userpreferencememorystrategy, with: BedrockAgentCoreControlClientTypes.UserPreferenceMemoryStrategyInput.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension BedrockAgentCoreControlClientTypes.CustomMemoryStrategyInput {

    static func write(value: BedrockAgentCoreControlClientTypes.CustomMemoryStrategyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["configuration"].write(value.configuration, with: BedrockAgentCoreControlClientTypes.CustomConfigurationInput.write(value:to:))
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["namespaces"].writeList(value.namespaces, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BedrockAgentCoreControlClientTypes.CustomConfigurationInput {

    static func write(value: BedrockAgentCoreControlClientTypes.CustomConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .semanticoverride(semanticoverride):
                try writer["semanticOverride"].write(semanticoverride, with: BedrockAgentCoreControlClientTypes.SemanticOverrideConfigurationInput.write(value:to:))
            case let .summaryoverride(summaryoverride):
                try writer["summaryOverride"].write(summaryoverride, with: BedrockAgentCoreControlClientTypes.SummaryOverrideConfigurationInput.write(value:to:))
            case let .userpreferenceoverride(userpreferenceoverride):
                try writer["userPreferenceOverride"].write(userpreferenceoverride, with: BedrockAgentCoreControlClientTypes.UserPreferenceOverrideConfigurationInput.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension BedrockAgentCoreControlClientTypes.UserPreferenceOverrideConfigurationInput {

    static func write(value: BedrockAgentCoreControlClientTypes.UserPreferenceOverrideConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["consolidation"].write(value.consolidation, with: BedrockAgentCoreControlClientTypes.UserPreferenceOverrideConsolidationConfigurationInput.write(value:to:))
        try writer["extraction"].write(value.extraction, with: BedrockAgentCoreControlClientTypes.UserPreferenceOverrideExtractionConfigurationInput.write(value:to:))
    }
}

extension BedrockAgentCoreControlClientTypes.UserPreferenceOverrideConsolidationConfigurationInput {

    static func write(value: BedrockAgentCoreControlClientTypes.UserPreferenceOverrideConsolidationConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appendToPrompt"].write(value.appendToPrompt)
        try writer["modelId"].write(value.modelId)
    }
}

extension BedrockAgentCoreControlClientTypes.UserPreferenceOverrideExtractionConfigurationInput {

    static func write(value: BedrockAgentCoreControlClientTypes.UserPreferenceOverrideExtractionConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appendToPrompt"].write(value.appendToPrompt)
        try writer["modelId"].write(value.modelId)
    }
}

extension BedrockAgentCoreControlClientTypes.SummaryOverrideConfigurationInput {

    static func write(value: BedrockAgentCoreControlClientTypes.SummaryOverrideConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["consolidation"].write(value.consolidation, with: BedrockAgentCoreControlClientTypes.SummaryOverrideConsolidationConfigurationInput.write(value:to:))
    }
}

extension BedrockAgentCoreControlClientTypes.SummaryOverrideConsolidationConfigurationInput {

    static func write(value: BedrockAgentCoreControlClientTypes.SummaryOverrideConsolidationConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appendToPrompt"].write(value.appendToPrompt)
        try writer["modelId"].write(value.modelId)
    }
}

extension BedrockAgentCoreControlClientTypes.SemanticOverrideConfigurationInput {

    static func write(value: BedrockAgentCoreControlClientTypes.SemanticOverrideConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["consolidation"].write(value.consolidation, with: BedrockAgentCoreControlClientTypes.SemanticOverrideConsolidationConfigurationInput.write(value:to:))
        try writer["extraction"].write(value.extraction, with: BedrockAgentCoreControlClientTypes.SemanticOverrideExtractionConfigurationInput.write(value:to:))
    }
}

extension BedrockAgentCoreControlClientTypes.SemanticOverrideConsolidationConfigurationInput {

    static func write(value: BedrockAgentCoreControlClientTypes.SemanticOverrideConsolidationConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appendToPrompt"].write(value.appendToPrompt)
        try writer["modelId"].write(value.modelId)
    }
}

extension BedrockAgentCoreControlClientTypes.SemanticOverrideExtractionConfigurationInput {

    static func write(value: BedrockAgentCoreControlClientTypes.SemanticOverrideExtractionConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appendToPrompt"].write(value.appendToPrompt)
        try writer["modelId"].write(value.modelId)
    }
}

extension BedrockAgentCoreControlClientTypes.UserPreferenceMemoryStrategyInput {

    static func write(value: BedrockAgentCoreControlClientTypes.UserPreferenceMemoryStrategyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["namespaces"].writeList(value.namespaces, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BedrockAgentCoreControlClientTypes.SummaryMemoryStrategyInput {

    static func write(value: BedrockAgentCoreControlClientTypes.SummaryMemoryStrategyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["namespaces"].writeList(value.namespaces, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BedrockAgentCoreControlClientTypes.SemanticMemoryStrategyInput {

    static func write(value: BedrockAgentCoreControlClientTypes.SemanticMemoryStrategyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["namespaces"].writeList(value.namespaces, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BedrockAgentCoreControlClientTypes.Oauth2ProviderConfigInput {

    static func write(value: BedrockAgentCoreControlClientTypes.Oauth2ProviderConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .customoauth2providerconfig(customoauth2providerconfig):
                try writer["customOauth2ProviderConfig"].write(customoauth2providerconfig, with: BedrockAgentCoreControlClientTypes.CustomOauth2ProviderConfigInput.write(value:to:))
            case let .githuboauth2providerconfig(githuboauth2providerconfig):
                try writer["githubOauth2ProviderConfig"].write(githuboauth2providerconfig, with: BedrockAgentCoreControlClientTypes.GithubOauth2ProviderConfigInput.write(value:to:))
            case let .googleoauth2providerconfig(googleoauth2providerconfig):
                try writer["googleOauth2ProviderConfig"].write(googleoauth2providerconfig, with: BedrockAgentCoreControlClientTypes.GoogleOauth2ProviderConfigInput.write(value:to:))
            case let .microsoftoauth2providerconfig(microsoftoauth2providerconfig):
                try writer["microsoftOauth2ProviderConfig"].write(microsoftoauth2providerconfig, with: BedrockAgentCoreControlClientTypes.MicrosoftOauth2ProviderConfigInput.write(value:to:))
            case let .salesforceoauth2providerconfig(salesforceoauth2providerconfig):
                try writer["salesforceOauth2ProviderConfig"].write(salesforceoauth2providerconfig, with: BedrockAgentCoreControlClientTypes.SalesforceOauth2ProviderConfigInput.write(value:to:))
            case let .slackoauth2providerconfig(slackoauth2providerconfig):
                try writer["slackOauth2ProviderConfig"].write(slackoauth2providerconfig, with: BedrockAgentCoreControlClientTypes.SlackOauth2ProviderConfigInput.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension BedrockAgentCoreControlClientTypes.MicrosoftOauth2ProviderConfigInput {

    static func write(value: BedrockAgentCoreControlClientTypes.MicrosoftOauth2ProviderConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientId"].write(value.clientId)
        try writer["clientSecret"].write(value.clientSecret)
    }
}

extension BedrockAgentCoreControlClientTypes.SalesforceOauth2ProviderConfigInput {

    static func write(value: BedrockAgentCoreControlClientTypes.SalesforceOauth2ProviderConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientId"].write(value.clientId)
        try writer["clientSecret"].write(value.clientSecret)
    }
}

extension BedrockAgentCoreControlClientTypes.SlackOauth2ProviderConfigInput {

    static func write(value: BedrockAgentCoreControlClientTypes.SlackOauth2ProviderConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientId"].write(value.clientId)
        try writer["clientSecret"].write(value.clientSecret)
    }
}

extension BedrockAgentCoreControlClientTypes.GithubOauth2ProviderConfigInput {

    static func write(value: BedrockAgentCoreControlClientTypes.GithubOauth2ProviderConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientId"].write(value.clientId)
        try writer["clientSecret"].write(value.clientSecret)
    }
}

extension BedrockAgentCoreControlClientTypes.GoogleOauth2ProviderConfigInput {

    static func write(value: BedrockAgentCoreControlClientTypes.GoogleOauth2ProviderConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientId"].write(value.clientId)
        try writer["clientSecret"].write(value.clientSecret)
    }
}

extension BedrockAgentCoreControlClientTypes.CustomOauth2ProviderConfigInput {

    static func write(value: BedrockAgentCoreControlClientTypes.CustomOauth2ProviderConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientId"].write(value.clientId)
        try writer["clientSecret"].write(value.clientSecret)
        try writer["oauthDiscovery"].write(value.oauthDiscovery, with: BedrockAgentCoreControlClientTypes.Oauth2Discovery.write(value:to:))
    }
}

extension BedrockAgentCoreControlClientTypes.ModifyMemoryStrategies {

    static func write(value: BedrockAgentCoreControlClientTypes.ModifyMemoryStrategies?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["addMemoryStrategies"].writeList(value.addMemoryStrategies, memberWritingClosure: BedrockAgentCoreControlClientTypes.MemoryStrategyInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["deleteMemoryStrategies"].writeList(value.deleteMemoryStrategies, memberWritingClosure: BedrockAgentCoreControlClientTypes.DeleteMemoryStrategyInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["modifyMemoryStrategies"].writeList(value.modifyMemoryStrategies, memberWritingClosure: BedrockAgentCoreControlClientTypes.ModifyMemoryStrategyInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BedrockAgentCoreControlClientTypes.DeleteMemoryStrategyInput {

    static func write(value: BedrockAgentCoreControlClientTypes.DeleteMemoryStrategyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["memoryStrategyId"].write(value.memoryStrategyId)
    }
}

extension BedrockAgentCoreControlClientTypes.ModifyMemoryStrategyInput {

    static func write(value: BedrockAgentCoreControlClientTypes.ModifyMemoryStrategyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["configuration"].write(value.configuration, with: BedrockAgentCoreControlClientTypes.ModifyStrategyConfiguration.write(value:to:))
        try writer["description"].write(value.description)
        try writer["memoryStrategyId"].write(value.memoryStrategyId)
        try writer["namespaces"].writeList(value.namespaces, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BedrockAgentCoreControlClientTypes.ModifyStrategyConfiguration {

    static func write(value: BedrockAgentCoreControlClientTypes.ModifyStrategyConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["consolidation"].write(value.consolidation, with: BedrockAgentCoreControlClientTypes.ModifyConsolidationConfiguration.write(value:to:))
        try writer["extraction"].write(value.extraction, with: BedrockAgentCoreControlClientTypes.ModifyExtractionConfiguration.write(value:to:))
    }
}

extension BedrockAgentCoreControlClientTypes.ModifyConsolidationConfiguration {

    static func write(value: BedrockAgentCoreControlClientTypes.ModifyConsolidationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .customconsolidationconfiguration(customconsolidationconfiguration):
                try writer["customConsolidationConfiguration"].write(customconsolidationconfiguration, with: BedrockAgentCoreControlClientTypes.CustomConsolidationConfigurationInput.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension BedrockAgentCoreControlClientTypes.CustomConsolidationConfigurationInput {

    static func write(value: BedrockAgentCoreControlClientTypes.CustomConsolidationConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .semanticconsolidationoverride(semanticconsolidationoverride):
                try writer["semanticConsolidationOverride"].write(semanticconsolidationoverride, with: BedrockAgentCoreControlClientTypes.SemanticOverrideConsolidationConfigurationInput.write(value:to:))
            case let .summaryconsolidationoverride(summaryconsolidationoverride):
                try writer["summaryConsolidationOverride"].write(summaryconsolidationoverride, with: BedrockAgentCoreControlClientTypes.SummaryOverrideConsolidationConfigurationInput.write(value:to:))
            case let .userpreferenceconsolidationoverride(userpreferenceconsolidationoverride):
                try writer["userPreferenceConsolidationOverride"].write(userpreferenceconsolidationoverride, with: BedrockAgentCoreControlClientTypes.UserPreferenceOverrideConsolidationConfigurationInput.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension BedrockAgentCoreControlClientTypes.ModifyExtractionConfiguration {

    static func write(value: BedrockAgentCoreControlClientTypes.ModifyExtractionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .customextractionconfiguration(customextractionconfiguration):
                try writer["customExtractionConfiguration"].write(customextractionconfiguration, with: BedrockAgentCoreControlClientTypes.CustomExtractionConfigurationInput.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension BedrockAgentCoreControlClientTypes.CustomExtractionConfigurationInput {

    static func write(value: BedrockAgentCoreControlClientTypes.CustomExtractionConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .semanticextractionoverride(semanticextractionoverride):
                try writer["semanticExtractionOverride"].write(semanticextractionoverride, with: BedrockAgentCoreControlClientTypes.SemanticOverrideExtractionConfigurationInput.write(value:to:))
            case let .userpreferenceextractionoverride(userpreferenceextractionoverride):
                try writer["userPreferenceExtractionOverride"].write(userpreferenceextractionoverride, with: BedrockAgentCoreControlClientTypes.UserPreferenceOverrideExtractionConfigurationInput.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

public enum BedrockAgentCoreControlClientTypes {}
