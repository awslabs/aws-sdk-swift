// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ControlTowerClientTypes.BaselineOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case operationIdentifier
        case operationType
        case startTime
        case status
        case statusMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .dateTime, forKey: .endTime)
        }
        if let operationIdentifier = self.operationIdentifier {
            try encodeContainer.encode(operationIdentifier, forKey: .operationIdentifier)
        }
        if let operationType = self.operationType {
            try encodeContainer.encode(operationType.rawValue, forKey: .operationType)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationIdentifier)
        operationIdentifier = operationIdentifierDecoded
        let operationTypeDecoded = try containerValues.decodeIfPresent(ControlTowerClientTypes.BaselineOperationType.self, forKey: .operationType)
        operationType = operationTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ControlTowerClientTypes.BaselineOperationStatus.self, forKey: .status)
        status = statusDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endTime)
        endTime = endTimeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension ControlTowerClientTypes {
    /// An object of shape BaselineOperation, returning details about the specified Baseline operation ID.
    public struct BaselineOperation: Swift.Equatable {
        /// The end time of the operation (if applicable), in ISO 8601 format.
        public var endTime: ClientRuntime.Date?
        /// The identifier of the specified operation.
        public var operationIdentifier: Swift.String?
        /// An enumerated type (enum) with possible values of ENABLE_BASELINE, DISABLE_BASELINE, UPDATE_ENABLED_BASELINE, or RESET_ENABLED_BASELINE.
        public var operationType: ControlTowerClientTypes.BaselineOperationType?
        /// The start time of the operation, in ISO 8601 format.
        public var startTime: ClientRuntime.Date?
        /// An enumerated type (enum) with possible values of SUCCEEDED, FAILED, or IN_PROGRESS.
        public var status: ControlTowerClientTypes.BaselineOperationStatus?
        /// A status message that gives more information about the operation's status, if applicable.
        public var statusMessage: Swift.String?

        public init(
            endTime: ClientRuntime.Date? = nil,
            operationIdentifier: Swift.String? = nil,
            operationType: ControlTowerClientTypes.BaselineOperationType? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: ControlTowerClientTypes.BaselineOperationStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.endTime = endTime
            self.operationIdentifier = operationIdentifier
            self.operationType = operationType
            self.startTime = startTime
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension ControlTowerClientTypes {
    public enum BaselineOperationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [BaselineOperationStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BaselineOperationStatus(rawValue: rawValue) ?? BaselineOperationStatus.sdkUnknown(rawValue)
        }
    }
}

extension ControlTowerClientTypes {
    public enum BaselineOperationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disableBaseline
        case enableBaseline
        case resetEnabledBaseline
        case updateEnabledBaseline
        case sdkUnknown(Swift.String)

        public static var allCases: [BaselineOperationType] {
            return [
                .disableBaseline,
                .enableBaseline,
                .resetEnabledBaseline,
                .updateEnabledBaseline,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disableBaseline: return "DISABLE_BASELINE"
            case .enableBaseline: return "ENABLE_BASELINE"
            case .resetEnabledBaseline: return "RESET_ENABLED_BASELINE"
            case .updateEnabledBaseline: return "UPDATE_ENABLED_BASELINE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BaselineOperationType(rawValue: rawValue) ?? BaselineOperationType.sdkUnknown(rawValue)
        }
    }
}

extension ControlTowerClientTypes.BaselineSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case description
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension ControlTowerClientTypes {
    /// Returns a summary of information about a Baseline object.
    public struct BaselineSummary: Swift.Equatable {
        /// The full ARN of a Baseline.
        /// This member is required.
        public var arn: Swift.String?
        /// A summary description of a Baseline.
        public var description: Swift.String?
        /// The human-readable name of a Baseline.
        /// This member is required.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.name = name
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Updating or deleting the resource can cause an inconsistent state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ControlTowerClientTypes.ControlOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case operationType
        case startTime
        case status
        case statusMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .dateTime, forKey: .endTime)
        }
        if let operationType = self.operationType {
            try encodeContainer.encode(operationType.rawValue, forKey: .operationType)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationTypeDecoded = try containerValues.decodeIfPresent(ControlTowerClientTypes.ControlOperationType.self, forKey: .operationType)
        operationType = operationTypeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endTime)
        endTime = endTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ControlTowerClientTypes.ControlOperationStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension ControlTowerClientTypes {
    /// An operation performed by the control.
    public struct ControlOperation: Swift.Equatable {
        /// The time that the operation finished.
        public var endTime: ClientRuntime.Date?
        /// One of ENABLE_CONTROL or DISABLE_CONTROL.
        public var operationType: ControlTowerClientTypes.ControlOperationType?
        /// The time that the operation began.
        public var startTime: ClientRuntime.Date?
        /// One of IN_PROGRESS, SUCEEDED, or FAILED.
        public var status: ControlTowerClientTypes.ControlOperationStatus?
        /// If the operation result is FAILED, this string contains a message explaining why the operation failed.
        public var statusMessage: Swift.String?

        public init(
            endTime: ClientRuntime.Date? = nil,
            operationType: ControlTowerClientTypes.ControlOperationType? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: ControlTowerClientTypes.ControlOperationStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.endTime = endTime
            self.operationType = operationType
            self.startTime = startTime
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension ControlTowerClientTypes {
    public enum ControlOperationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ControlOperationStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ControlOperationStatus(rawValue: rawValue) ?? ControlOperationStatus.sdkUnknown(rawValue)
        }
    }
}

extension ControlTowerClientTypes {
    public enum ControlOperationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disableControl
        case enableControl
        case updateEnabledControl
        case sdkUnknown(Swift.String)

        public static var allCases: [ControlOperationType] {
            return [
                .disableControl,
                .enableControl,
                .updateEnabledControl,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disableControl: return "DISABLE_CONTROL"
            case .enableControl: return "ENABLE_CONTROL"
            case .updateEnabledControl: return "UPDATE_ENABLED_CONTROL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ControlOperationType(rawValue: rawValue) ?? ControlOperationType.sdkUnknown(rawValue)
        }
    }
}

public enum ControlTowerClientTypes {}

extension CreateLandingZoneInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case manifest
        case tags
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let manifest = self.manifest {
            try encodeContainer.encode(manifest, forKey: .manifest)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }
}

extension CreateLandingZoneInput {

    static func urlPathProvider(_ value: CreateLandingZoneInput) -> Swift.String? {
        return "/create-landingzone"
    }
}

public struct CreateLandingZoneInput: Swift.Equatable {
    /// The manifest.yaml file is a text file that describes your Amazon Web Services resources. For examples, review [The manifest file](https://docs.aws.amazon.com/controltower/latest/userguide/the-manifest-file).
    /// This member is required.
    public var manifest: ClientRuntime.Document?
    /// Tags to be applied to the landing zone.
    public var tags: [Swift.String:Swift.String]?
    /// The landing zone version, for example, 3.0.
    /// This member is required.
    public var version: Swift.String?

    public init(
        manifest: ClientRuntime.Document? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        version: Swift.String? = nil
    )
    {
        self.manifest = manifest
        self.tags = tags
        self.version = version
    }
}

struct CreateLandingZoneInputBody: Swift.Equatable {
    let version: Swift.String?
    let manifest: ClientRuntime.Document?
    let tags: [Swift.String:Swift.String]?
}

extension CreateLandingZoneInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case manifest
        case tags
        case version
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let manifestDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .manifest)
        manifest = manifestDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateLandingZoneOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateLandingZoneOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.operationIdentifier = output.operationIdentifier
        } else {
            self.arn = nil
            self.operationIdentifier = nil
        }
    }
}

public struct CreateLandingZoneOutput: Swift.Equatable {
    /// The ARN of the landing zone resource.
    /// This member is required.
    public var arn: Swift.String?
    /// A unique identifier assigned to a CreateLandingZone operation. You can use this identifier as an input of GetLandingZoneOperation to check the operation's status.
    /// This member is required.
    public var operationIdentifier: Swift.String?

    public init(
        arn: Swift.String? = nil,
        operationIdentifier: Swift.String? = nil
    )
    {
        self.arn = arn
        self.operationIdentifier = operationIdentifier
    }
}

struct CreateLandingZoneOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let operationIdentifier: Swift.String?
}

extension CreateLandingZoneOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case operationIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let operationIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationIdentifier)
        operationIdentifier = operationIdentifierDecoded
    }
}

enum CreateLandingZoneOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteLandingZoneInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case landingZoneIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let landingZoneIdentifier = self.landingZoneIdentifier {
            try encodeContainer.encode(landingZoneIdentifier, forKey: .landingZoneIdentifier)
        }
    }
}

extension DeleteLandingZoneInput {

    static func urlPathProvider(_ value: DeleteLandingZoneInput) -> Swift.String? {
        return "/delete-landingzone"
    }
}

public struct DeleteLandingZoneInput: Swift.Equatable {
    /// The unique identifier of the landing zone.
    /// This member is required.
    public var landingZoneIdentifier: Swift.String?

    public init(
        landingZoneIdentifier: Swift.String? = nil
    )
    {
        self.landingZoneIdentifier = landingZoneIdentifier
    }
}

struct DeleteLandingZoneInputBody: Swift.Equatable {
    let landingZoneIdentifier: Swift.String?
}

extension DeleteLandingZoneInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case landingZoneIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let landingZoneIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .landingZoneIdentifier)
        landingZoneIdentifier = landingZoneIdentifierDecoded
    }
}

extension DeleteLandingZoneOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteLandingZoneOutputBody = try responseDecoder.decode(responseBody: data)
            self.operationIdentifier = output.operationIdentifier
        } else {
            self.operationIdentifier = nil
        }
    }
}

public struct DeleteLandingZoneOutput: Swift.Equatable {
    /// >A unique identifier assigned to a DeleteLandingZone operation. You can use this identifier as an input parameter of GetLandingZoneOperation to check the operation's status.
    /// This member is required.
    public var operationIdentifier: Swift.String?

    public init(
        operationIdentifier: Swift.String? = nil
    )
    {
        self.operationIdentifier = operationIdentifier
    }
}

struct DeleteLandingZoneOutputBody: Swift.Equatable {
    let operationIdentifier: Swift.String?
}

extension DeleteLandingZoneOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationIdentifier)
        operationIdentifier = operationIdentifierDecoded
    }
}

enum DeleteLandingZoneOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisableBaselineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabledBaselineIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabledBaselineIdentifier = self.enabledBaselineIdentifier {
            try encodeContainer.encode(enabledBaselineIdentifier, forKey: .enabledBaselineIdentifier)
        }
    }
}

extension DisableBaselineInput {

    static func urlPathProvider(_ value: DisableBaselineInput) -> Swift.String? {
        return "/disable-baseline"
    }
}

public struct DisableBaselineInput: Swift.Equatable {
    /// Identifier of the EnabledBaseline resource to be deactivated, in ARN format.
    /// This member is required.
    public var enabledBaselineIdentifier: Swift.String?

    public init(
        enabledBaselineIdentifier: Swift.String? = nil
    )
    {
        self.enabledBaselineIdentifier = enabledBaselineIdentifier
    }
}

struct DisableBaselineInputBody: Swift.Equatable {
    let enabledBaselineIdentifier: Swift.String?
}

extension DisableBaselineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabledBaselineIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledBaselineIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .enabledBaselineIdentifier)
        enabledBaselineIdentifier = enabledBaselineIdentifierDecoded
    }
}

extension DisableBaselineOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisableBaselineOutputBody = try responseDecoder.decode(responseBody: data)
            self.operationIdentifier = output.operationIdentifier
        } else {
            self.operationIdentifier = nil
        }
    }
}

public struct DisableBaselineOutput: Swift.Equatable {
    /// The ID (in UUID format) of the asynchronous DisableBaseline operation. This operationIdentifier is used to track status through calls to the GetBaselineOperation API.
    /// This member is required.
    public var operationIdentifier: Swift.String?

    public init(
        operationIdentifier: Swift.String? = nil
    )
    {
        self.operationIdentifier = operationIdentifier
    }
}

struct DisableBaselineOutputBody: Swift.Equatable {
    let operationIdentifier: Swift.String?
}

extension DisableBaselineOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationIdentifier)
        operationIdentifier = operationIdentifierDecoded
    }
}

enum DisableBaselineOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisableControlInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlIdentifier
        case targetIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let controlIdentifier = self.controlIdentifier {
            try encodeContainer.encode(controlIdentifier, forKey: .controlIdentifier)
        }
        if let targetIdentifier = self.targetIdentifier {
            try encodeContainer.encode(targetIdentifier, forKey: .targetIdentifier)
        }
    }
}

extension DisableControlInput {

    static func urlPathProvider(_ value: DisableControlInput) -> Swift.String? {
        return "/disable-control"
    }
}

public struct DisableControlInput: Swift.Equatable {
    /// The ARN of the control. Only Strongly recommended and Elective controls are permitted, with the exception of the Region deny control. For information on how to find the controlIdentifier, see [the overview page](https://docs.aws.amazon.com/controltower/latest/APIReference/Welcome.html).
    /// This member is required.
    public var controlIdentifier: Swift.String?
    /// The ARN of the organizational unit. For information on how to find the targetIdentifier, see [the overview page](https://docs.aws.amazon.com/controltower/latest/APIReference/Welcome.html).
    /// This member is required.
    public var targetIdentifier: Swift.String?

    public init(
        controlIdentifier: Swift.String? = nil,
        targetIdentifier: Swift.String? = nil
    )
    {
        self.controlIdentifier = controlIdentifier
        self.targetIdentifier = targetIdentifier
    }
}

struct DisableControlInputBody: Swift.Equatable {
    let controlIdentifier: Swift.String?
    let targetIdentifier: Swift.String?
}

extension DisableControlInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlIdentifier
        case targetIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlIdentifier)
        controlIdentifier = controlIdentifierDecoded
        let targetIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetIdentifier)
        targetIdentifier = targetIdentifierDecoded
    }
}

extension DisableControlOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisableControlOutputBody = try responseDecoder.decode(responseBody: data)
            self.operationIdentifier = output.operationIdentifier
        } else {
            self.operationIdentifier = nil
        }
    }
}

public struct DisableControlOutput: Swift.Equatable {
    /// The ID of the asynchronous operation, which is used to track status. The operation is available for 90 days.
    /// This member is required.
    public var operationIdentifier: Swift.String?

    public init(
        operationIdentifier: Swift.String? = nil
    )
    {
        self.operationIdentifier = operationIdentifier
    }
}

struct DisableControlOutputBody: Swift.Equatable {
    let operationIdentifier: Swift.String?
}

extension DisableControlOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationIdentifier)
        operationIdentifier = operationIdentifierDecoded
    }
}

enum DisableControlOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ControlTowerClientTypes {
    public enum DriftStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case drifted
        case inSync
        case notChecking
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [DriftStatus] {
            return [
                .drifted,
                .inSync,
                .notChecking,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .drifted: return "DRIFTED"
            case .inSync: return "IN_SYNC"
            case .notChecking: return "NOT_CHECKING"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DriftStatus(rawValue: rawValue) ?? DriftStatus.sdkUnknown(rawValue)
        }
    }
}

extension ControlTowerClientTypes.DriftStatusSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case driftStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let driftStatus = self.driftStatus {
            try encodeContainer.encode(driftStatus.rawValue, forKey: .driftStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let driftStatusDecoded = try containerValues.decodeIfPresent(ControlTowerClientTypes.DriftStatus.self, forKey: .driftStatus)
        driftStatus = driftStatusDecoded
    }
}

extension ControlTowerClientTypes {
    /// The drift summary of the enabled control. Amazon Web Services Control Tower expects the enabled control configuration to include all supported and governed Regions. If the enabled control differs from the expected configuration, it is defined to be in a state of drift. You can repair this drift by resetting the enabled control.
    public struct DriftStatusSummary: Swift.Equatable {
        /// The drift status of the enabled control. Valid values:
        ///
        /// * DRIFTED: The enabledControl deployed in this configuration doesnâ€™t match the configuration that Amazon Web Services Control Tower expected.
        ///
        /// * IN_SYNC: The enabledControl deployed in this configuration matches the configuration that Amazon Web Services Control Tower expected.
        ///
        /// * NOT_CHECKING: Amazon Web Services Control Tower does not check drift for this enabled control. Drift is not supported for the control type.
        ///
        /// * UNKNOWN: Amazon Web Services Control Tower is not able to check the drift status for the enabled control.
        public var driftStatus: ControlTowerClientTypes.DriftStatus?

        public init(
            driftStatus: ControlTowerClientTypes.DriftStatus? = nil
        )
        {
            self.driftStatus = driftStatus
        }
    }

}

extension EnableBaselineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineIdentifier
        case baselineVersion
        case parameters
        case tags
        case targetIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baselineIdentifier = self.baselineIdentifier {
            try encodeContainer.encode(baselineIdentifier, forKey: .baselineIdentifier)
        }
        if let baselineVersion = self.baselineVersion {
            try encodeContainer.encode(baselineVersion, forKey: .baselineVersion)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameters)
            for enabledbaselineparameter0 in parameters {
                try parametersContainer.encode(enabledbaselineparameter0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targetIdentifier = self.targetIdentifier {
            try encodeContainer.encode(targetIdentifier, forKey: .targetIdentifier)
        }
    }
}

extension EnableBaselineInput {

    static func urlPathProvider(_ value: EnableBaselineInput) -> Swift.String? {
        return "/enable-baseline"
    }
}

public struct EnableBaselineInput: Swift.Equatable {
    /// The ARN of the baseline to be enabled.
    /// This member is required.
    public var baselineIdentifier: Swift.String?
    /// The specific version to be enabled of the specified baseline.
    /// This member is required.
    public var baselineVersion: Swift.String?
    /// A list of key-value objects that specify enablement parameters, where key is a string and value is a document of any type.
    public var parameters: [ControlTowerClientTypes.EnabledBaselineParameter]?
    /// Tags associated with input to EnableBaseline.
    public var tags: [Swift.String:Swift.String]?
    /// The ARN of the target on which the baseline will be enabled. Only OUs are supported as targets.
    /// This member is required.
    public var targetIdentifier: Swift.String?

    public init(
        baselineIdentifier: Swift.String? = nil,
        baselineVersion: Swift.String? = nil,
        parameters: [ControlTowerClientTypes.EnabledBaselineParameter]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        targetIdentifier: Swift.String? = nil
    )
    {
        self.baselineIdentifier = baselineIdentifier
        self.baselineVersion = baselineVersion
        self.parameters = parameters
        self.tags = tags
        self.targetIdentifier = targetIdentifier
    }
}

struct EnableBaselineInputBody: Swift.Equatable {
    let baselineVersion: Swift.String?
    let parameters: [ControlTowerClientTypes.EnabledBaselineParameter]?
    let baselineIdentifier: Swift.String?
    let targetIdentifier: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension EnableBaselineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineIdentifier
        case baselineVersion
        case parameters
        case tags
        case targetIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineVersion)
        baselineVersion = baselineVersionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([ControlTowerClientTypes.EnabledBaselineParameter?].self, forKey: .parameters)
        var parametersDecoded0:[ControlTowerClientTypes.EnabledBaselineParameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [ControlTowerClientTypes.EnabledBaselineParameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
        let baselineIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineIdentifier)
        baselineIdentifier = baselineIdentifierDecoded
        let targetIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetIdentifier)
        targetIdentifier = targetIdentifierDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension EnableBaselineOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EnableBaselineOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.operationIdentifier = output.operationIdentifier
        } else {
            self.arn = nil
            self.operationIdentifier = nil
        }
    }
}

public struct EnableBaselineOutput: Swift.Equatable {
    /// The ARN of the EnabledBaseline resource.
    /// This member is required.
    public var arn: Swift.String?
    /// The ID (in UUID format) of the asynchronous EnableBaseline operation. This operationIdentifier is used to track status through calls to the GetBaselineOperation API.
    /// This member is required.
    public var operationIdentifier: Swift.String?

    public init(
        arn: Swift.String? = nil,
        operationIdentifier: Swift.String? = nil
    )
    {
        self.arn = arn
        self.operationIdentifier = operationIdentifier
    }
}

struct EnableBaselineOutputBody: Swift.Equatable {
    let operationIdentifier: Swift.String?
    let arn: Swift.String?
}

extension EnableBaselineOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case operationIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationIdentifier)
        operationIdentifier = operationIdentifierDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum EnableBaselineOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EnableControlInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlIdentifier
        case parameters
        case tags
        case targetIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let controlIdentifier = self.controlIdentifier {
            try encodeContainer.encode(controlIdentifier, forKey: .controlIdentifier)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameters)
            for enabledcontrolparameter0 in parameters {
                try parametersContainer.encode(enabledcontrolparameter0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targetIdentifier = self.targetIdentifier {
            try encodeContainer.encode(targetIdentifier, forKey: .targetIdentifier)
        }
    }
}

extension EnableControlInput {

    static func urlPathProvider(_ value: EnableControlInput) -> Swift.String? {
        return "/enable-control"
    }
}

public struct EnableControlInput: Swift.Equatable {
    /// The ARN of the control. Only Strongly recommended and Elective controls are permitted, with the exception of the Region deny control. For information on how to find the controlIdentifier, see [the overview page](https://docs.aws.amazon.com/controltower/latest/APIReference/Welcome.html).
    /// This member is required.
    public var controlIdentifier: Swift.String?
    /// A list of input parameter values, which are specified to configure the control when you enable it.
    public var parameters: [ControlTowerClientTypes.EnabledControlParameter]?
    /// Tags to be applied to the EnabledControl resource.
    public var tags: [Swift.String:Swift.String]?
    /// The ARN of the organizational unit. For information on how to find the targetIdentifier, see [the overview page](https://docs.aws.amazon.com/controltower/latest/APIReference/Welcome.html).
    /// This member is required.
    public var targetIdentifier: Swift.String?

    public init(
        controlIdentifier: Swift.String? = nil,
        parameters: [ControlTowerClientTypes.EnabledControlParameter]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        targetIdentifier: Swift.String? = nil
    )
    {
        self.controlIdentifier = controlIdentifier
        self.parameters = parameters
        self.tags = tags
        self.targetIdentifier = targetIdentifier
    }
}

struct EnableControlInputBody: Swift.Equatable {
    let controlIdentifier: Swift.String?
    let targetIdentifier: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let parameters: [ControlTowerClientTypes.EnabledControlParameter]?
}

extension EnableControlInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlIdentifier
        case parameters
        case tags
        case targetIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlIdentifier)
        controlIdentifier = controlIdentifierDecoded
        let targetIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetIdentifier)
        targetIdentifier = targetIdentifierDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let parametersContainer = try containerValues.decodeIfPresent([ControlTowerClientTypes.EnabledControlParameter?].self, forKey: .parameters)
        var parametersDecoded0:[ControlTowerClientTypes.EnabledControlParameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [ControlTowerClientTypes.EnabledControlParameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension EnableControlOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EnableControlOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.operationIdentifier = output.operationIdentifier
        } else {
            self.arn = nil
            self.operationIdentifier = nil
        }
    }
}

public struct EnableControlOutput: Swift.Equatable {
    /// The ARN of the EnabledControl resource.
    public var arn: Swift.String?
    /// The ID of the asynchronous operation, which is used to track status. The operation is available for 90 days.
    /// This member is required.
    public var operationIdentifier: Swift.String?

    public init(
        arn: Swift.String? = nil,
        operationIdentifier: Swift.String? = nil
    )
    {
        self.arn = arn
        self.operationIdentifier = operationIdentifier
    }
}

struct EnableControlOutputBody: Swift.Equatable {
    let operationIdentifier: Swift.String?
    let arn: Swift.String?
}

extension EnableControlOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case operationIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationIdentifier)
        operationIdentifier = operationIdentifierDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum EnableControlOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ControlTowerClientTypes.EnabledBaselineDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case baselineIdentifier
        case baselineVersion
        case parameters
        case statusSummary
        case targetIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let baselineIdentifier = self.baselineIdentifier {
            try encodeContainer.encode(baselineIdentifier, forKey: .baselineIdentifier)
        }
        if let baselineVersion = self.baselineVersion {
            try encodeContainer.encode(baselineVersion, forKey: .baselineVersion)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameters)
            for enabledbaselineparametersummary0 in parameters {
                try parametersContainer.encode(enabledbaselineparametersummary0)
            }
        }
        if let statusSummary = self.statusSummary {
            try encodeContainer.encode(statusSummary, forKey: .statusSummary)
        }
        if let targetIdentifier = self.targetIdentifier {
            try encodeContainer.encode(targetIdentifier, forKey: .targetIdentifier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let baselineIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineIdentifier)
        baselineIdentifier = baselineIdentifierDecoded
        let baselineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineVersion)
        baselineVersion = baselineVersionDecoded
        let targetIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetIdentifier)
        targetIdentifier = targetIdentifierDecoded
        let statusSummaryDecoded = try containerValues.decodeIfPresent(ControlTowerClientTypes.EnablementStatusSummary.self, forKey: .statusSummary)
        statusSummary = statusSummaryDecoded
        let parametersContainer = try containerValues.decodeIfPresent([ControlTowerClientTypes.EnabledBaselineParameterSummary?].self, forKey: .parameters)
        var parametersDecoded0:[ControlTowerClientTypes.EnabledBaselineParameterSummary]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [ControlTowerClientTypes.EnabledBaselineParameterSummary]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension ControlTowerClientTypes {
    /// Details of the EnabledBaseline resource.
    public struct EnabledBaselineDetails: Swift.Equatable {
        /// The ARN of the EnabledBaseline resource.
        /// This member is required.
        public var arn: Swift.String?
        /// The specific Baseline enabled as part of the EnabledBaseline resource.
        /// This member is required.
        public var baselineIdentifier: Swift.String?
        /// The enabled version of the Baseline.
        public var baselineVersion: Swift.String?
        /// Shows the parameters that are applied when enabling this Baseline.
        public var parameters: [ControlTowerClientTypes.EnabledBaselineParameterSummary]?
        /// The deployment summary of the enabled control.
        /// This member is required.
        public var statusSummary: ControlTowerClientTypes.EnablementStatusSummary?
        /// The target on which to enable the Baseline.
        /// This member is required.
        public var targetIdentifier: Swift.String?

        public init(
            arn: Swift.String? = nil,
            baselineIdentifier: Swift.String? = nil,
            baselineVersion: Swift.String? = nil,
            parameters: [ControlTowerClientTypes.EnabledBaselineParameterSummary]? = nil,
            statusSummary: ControlTowerClientTypes.EnablementStatusSummary? = nil,
            targetIdentifier: Swift.String? = nil
        )
        {
            self.arn = arn
            self.baselineIdentifier = baselineIdentifier
            self.baselineVersion = baselineVersion
            self.parameters = parameters
            self.statusSummary = statusSummary
            self.targetIdentifier = targetIdentifier
        }
    }

}

extension ControlTowerClientTypes.EnabledBaselineFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineIdentifiers
        case targetIdentifiers
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baselineIdentifiers = baselineIdentifiers {
            var baselineIdentifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .baselineIdentifiers)
            for arn0 in baselineIdentifiers {
                try baselineIdentifiersContainer.encode(arn0)
            }
        }
        if let targetIdentifiers = targetIdentifiers {
            var targetIdentifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetIdentifiers)
            for arn0 in targetIdentifiers {
                try targetIdentifiersContainer.encode(arn0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetIdentifiersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetIdentifiers)
        var targetIdentifiersDecoded0:[Swift.String]? = nil
        if let targetIdentifiersContainer = targetIdentifiersContainer {
            targetIdentifiersDecoded0 = [Swift.String]()
            for string0 in targetIdentifiersContainer {
                if let string0 = string0 {
                    targetIdentifiersDecoded0?.append(string0)
                }
            }
        }
        targetIdentifiers = targetIdentifiersDecoded0
        let baselineIdentifiersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .baselineIdentifiers)
        var baselineIdentifiersDecoded0:[Swift.String]? = nil
        if let baselineIdentifiersContainer = baselineIdentifiersContainer {
            baselineIdentifiersDecoded0 = [Swift.String]()
            for string0 in baselineIdentifiersContainer {
                if let string0 = string0 {
                    baselineIdentifiersDecoded0?.append(string0)
                }
            }
        }
        baselineIdentifiers = baselineIdentifiersDecoded0
    }
}

extension ControlTowerClientTypes {
    /// A filter applied on the ListEnabledBaseline operation. Allowed filters are baselineIdentifiers and targetIdentifiers. The filter can be applied for either, or both.
    public struct EnabledBaselineFilter: Swift.Equatable {
        /// Identifiers for the Baseline objects returned as part of the filter operation.
        public var baselineIdentifiers: [Swift.String]?
        /// Identifiers for the targets of the Baseline filter operation.
        public var targetIdentifiers: [Swift.String]?

        public init(
            baselineIdentifiers: [Swift.String]? = nil,
            targetIdentifiers: [Swift.String]? = nil
        )
        {
            self.baselineIdentifiers = baselineIdentifiers
            self.targetIdentifiers = targetIdentifiers
        }
    }

}

extension ControlTowerClientTypes.EnabledBaselineParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .value)
        value = valueDecoded
    }
}

extension ControlTowerClientTypes {
    /// A key-value parameter to an EnabledBaseline resource.
    public struct EnabledBaselineParameter: Swift.Equatable {
        /// A string denoting the parameter key.
        /// This member is required.
        public var key: Swift.String?
        /// A low-level Document object of any type (for example, a Java Object).
        /// This member is required.
        public var value: ClientRuntime.Document?

        public init(
            key: Swift.String? = nil,
            value: ClientRuntime.Document? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension ControlTowerClientTypes.EnabledBaselineParameterSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .value)
        value = valueDecoded
    }
}

extension ControlTowerClientTypes {
    /// Summary of an applied parameter to an EnabledBaseline resource.
    public struct EnabledBaselineParameterSummary: Swift.Equatable {
        /// A string denoting the parameter key.
        /// This member is required.
        public var key: Swift.String?
        /// A low-level document object of any type (for example, a Java Object).
        /// This member is required.
        public var value: ClientRuntime.Document?

        public init(
            key: Swift.String? = nil,
            value: ClientRuntime.Document? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension ControlTowerClientTypes.EnabledBaselineSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case baselineIdentifier
        case baselineVersion
        case statusSummary
        case targetIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let baselineIdentifier = self.baselineIdentifier {
            try encodeContainer.encode(baselineIdentifier, forKey: .baselineIdentifier)
        }
        if let baselineVersion = self.baselineVersion {
            try encodeContainer.encode(baselineVersion, forKey: .baselineVersion)
        }
        if let statusSummary = self.statusSummary {
            try encodeContainer.encode(statusSummary, forKey: .statusSummary)
        }
        if let targetIdentifier = self.targetIdentifier {
            try encodeContainer.encode(targetIdentifier, forKey: .targetIdentifier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let baselineIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineIdentifier)
        baselineIdentifier = baselineIdentifierDecoded
        let baselineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineVersion)
        baselineVersion = baselineVersionDecoded
        let targetIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetIdentifier)
        targetIdentifier = targetIdentifierDecoded
        let statusSummaryDecoded = try containerValues.decodeIfPresent(ControlTowerClientTypes.EnablementStatusSummary.self, forKey: .statusSummary)
        statusSummary = statusSummaryDecoded
    }
}

extension ControlTowerClientTypes {
    /// Returns a summary of information about an EnabledBaseline object.
    public struct EnabledBaselineSummary: Swift.Equatable {
        /// The ARN of the EnabledBaseline resource
        /// This member is required.
        public var arn: Swift.String?
        /// The specific baseline that is enabled as part of the EnabledBaseline resource.
        /// This member is required.
        public var baselineIdentifier: Swift.String?
        /// The enabled version of the baseline.
        public var baselineVersion: Swift.String?
        /// The deployment summary of the enabled control.
        /// This member is required.
        public var statusSummary: ControlTowerClientTypes.EnablementStatusSummary?
        /// The target upon which the baseline is enabled.
        /// This member is required.
        public var targetIdentifier: Swift.String?

        public init(
            arn: Swift.String? = nil,
            baselineIdentifier: Swift.String? = nil,
            baselineVersion: Swift.String? = nil,
            statusSummary: ControlTowerClientTypes.EnablementStatusSummary? = nil,
            targetIdentifier: Swift.String? = nil
        )
        {
            self.arn = arn
            self.baselineIdentifier = baselineIdentifier
            self.baselineVersion = baselineVersion
            self.statusSummary = statusSummary
            self.targetIdentifier = targetIdentifier
        }
    }

}

extension ControlTowerClientTypes.EnabledControlDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case controlIdentifier
        case driftStatusSummary
        case parameters
        case statusSummary
        case targetIdentifier
        case targetRegions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let controlIdentifier = self.controlIdentifier {
            try encodeContainer.encode(controlIdentifier, forKey: .controlIdentifier)
        }
        if let driftStatusSummary = self.driftStatusSummary {
            try encodeContainer.encode(driftStatusSummary, forKey: .driftStatusSummary)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameters)
            for enabledcontrolparametersummary0 in parameters {
                try parametersContainer.encode(enabledcontrolparametersummary0)
            }
        }
        if let statusSummary = self.statusSummary {
            try encodeContainer.encode(statusSummary, forKey: .statusSummary)
        }
        if let targetIdentifier = self.targetIdentifier {
            try encodeContainer.encode(targetIdentifier, forKey: .targetIdentifier)
        }
        if let targetRegions = targetRegions {
            var targetRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetRegions)
            for region0 in targetRegions {
                try targetRegionsContainer.encode(region0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let controlIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlIdentifier)
        controlIdentifier = controlIdentifierDecoded
        let targetIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetIdentifier)
        targetIdentifier = targetIdentifierDecoded
        let targetRegionsContainer = try containerValues.decodeIfPresent([ControlTowerClientTypes.Region?].self, forKey: .targetRegions)
        var targetRegionsDecoded0:[ControlTowerClientTypes.Region]? = nil
        if let targetRegionsContainer = targetRegionsContainer {
            targetRegionsDecoded0 = [ControlTowerClientTypes.Region]()
            for structure0 in targetRegionsContainer {
                if let structure0 = structure0 {
                    targetRegionsDecoded0?.append(structure0)
                }
            }
        }
        targetRegions = targetRegionsDecoded0
        let statusSummaryDecoded = try containerValues.decodeIfPresent(ControlTowerClientTypes.EnablementStatusSummary.self, forKey: .statusSummary)
        statusSummary = statusSummaryDecoded
        let driftStatusSummaryDecoded = try containerValues.decodeIfPresent(ControlTowerClientTypes.DriftStatusSummary.self, forKey: .driftStatusSummary)
        driftStatusSummary = driftStatusSummaryDecoded
        let parametersContainer = try containerValues.decodeIfPresent([ControlTowerClientTypes.EnabledControlParameterSummary?].self, forKey: .parameters)
        var parametersDecoded0:[ControlTowerClientTypes.EnabledControlParameterSummary]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [ControlTowerClientTypes.EnabledControlParameterSummary]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension ControlTowerClientTypes {
    /// Information about the enabled control.
    public struct EnabledControlDetails: Swift.Equatable {
        /// The ARN of the enabled control.
        public var arn: Swift.String?
        /// The control identifier of the enabled control. For information on how to find the controlIdentifier, see [the overview page](https://docs.aws.amazon.com/controltower/latest/APIReference/Welcome.html).
        public var controlIdentifier: Swift.String?
        /// The drift status of the enabled control.
        public var driftStatusSummary: ControlTowerClientTypes.DriftStatusSummary?
        /// Array of EnabledControlParameter objects.
        public var parameters: [ControlTowerClientTypes.EnabledControlParameterSummary]?
        /// The deployment summary of the enabled control.
        public var statusSummary: ControlTowerClientTypes.EnablementStatusSummary?
        /// The ARN of the organizational unit. For information on how to find the targetIdentifier, see [the overview page](https://docs.aws.amazon.com/controltower/latest/APIReference/Welcome.html).
        public var targetIdentifier: Swift.String?
        /// Target Amazon Web Services Regions for the enabled control.
        public var targetRegions: [ControlTowerClientTypes.Region]?

        public init(
            arn: Swift.String? = nil,
            controlIdentifier: Swift.String? = nil,
            driftStatusSummary: ControlTowerClientTypes.DriftStatusSummary? = nil,
            parameters: [ControlTowerClientTypes.EnabledControlParameterSummary]? = nil,
            statusSummary: ControlTowerClientTypes.EnablementStatusSummary? = nil,
            targetIdentifier: Swift.String? = nil,
            targetRegions: [ControlTowerClientTypes.Region]? = nil
        )
        {
            self.arn = arn
            self.controlIdentifier = controlIdentifier
            self.driftStatusSummary = driftStatusSummary
            self.parameters = parameters
            self.statusSummary = statusSummary
            self.targetIdentifier = targetIdentifier
            self.targetRegions = targetRegions
        }
    }

}

extension ControlTowerClientTypes.EnabledControlParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .value)
        value = valueDecoded
    }
}

extension ControlTowerClientTypes {
    /// A key/value pair, where Key is of type String and Value is of type Document.
    public struct EnabledControlParameter: Swift.Equatable {
        /// The key of a key/value pair.
        /// This member is required.
        public var key: Swift.String?
        /// The value of a key/value pair.
        /// This member is required.
        public var value: ClientRuntime.Document?

        public init(
            key: Swift.String? = nil,
            value: ClientRuntime.Document? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension ControlTowerClientTypes.EnabledControlParameterSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .value)
        value = valueDecoded
    }
}

extension ControlTowerClientTypes {
    /// Returns a summary of information about the parameters of an enabled control.
    public struct EnabledControlParameterSummary: Swift.Equatable {
        /// The key of a key/value pair.
        /// This member is required.
        public var key: Swift.String?
        /// The value of a key/value pair.
        /// This member is required.
        public var value: ClientRuntime.Document?

        public init(
            key: Swift.String? = nil,
            value: ClientRuntime.Document? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension ControlTowerClientTypes.EnabledControlSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case controlIdentifier
        case driftStatusSummary
        case statusSummary
        case targetIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let controlIdentifier = self.controlIdentifier {
            try encodeContainer.encode(controlIdentifier, forKey: .controlIdentifier)
        }
        if let driftStatusSummary = self.driftStatusSummary {
            try encodeContainer.encode(driftStatusSummary, forKey: .driftStatusSummary)
        }
        if let statusSummary = self.statusSummary {
            try encodeContainer.encode(statusSummary, forKey: .statusSummary)
        }
        if let targetIdentifier = self.targetIdentifier {
            try encodeContainer.encode(targetIdentifier, forKey: .targetIdentifier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlIdentifier)
        controlIdentifier = controlIdentifierDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let targetIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetIdentifier)
        targetIdentifier = targetIdentifierDecoded
        let statusSummaryDecoded = try containerValues.decodeIfPresent(ControlTowerClientTypes.EnablementStatusSummary.self, forKey: .statusSummary)
        statusSummary = statusSummaryDecoded
        let driftStatusSummaryDecoded = try containerValues.decodeIfPresent(ControlTowerClientTypes.DriftStatusSummary.self, forKey: .driftStatusSummary)
        driftStatusSummary = driftStatusSummaryDecoded
    }
}

extension ControlTowerClientTypes {
    /// Returns a summary of information about an enabled control.
    public struct EnabledControlSummary: Swift.Equatable {
        /// The ARN of the enabled control.
        public var arn: Swift.String?
        /// The controlIdentifier of the enabled control.
        public var controlIdentifier: Swift.String?
        /// The drift status of the enabled control.
        public var driftStatusSummary: ControlTowerClientTypes.DriftStatusSummary?
        /// A short description of the status of the enabled control.
        public var statusSummary: ControlTowerClientTypes.EnablementStatusSummary?
        /// The ARN of the organizational unit.
        public var targetIdentifier: Swift.String?

        public init(
            arn: Swift.String? = nil,
            controlIdentifier: Swift.String? = nil,
            driftStatusSummary: ControlTowerClientTypes.DriftStatusSummary? = nil,
            statusSummary: ControlTowerClientTypes.EnablementStatusSummary? = nil,
            targetIdentifier: Swift.String? = nil
        )
        {
            self.arn = arn
            self.controlIdentifier = controlIdentifier
            self.driftStatusSummary = driftStatusSummary
            self.statusSummary = statusSummary
            self.targetIdentifier = targetIdentifier
        }
    }

}

extension ControlTowerClientTypes {
    public enum EnablementStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case succeeded
        case underChange
        case sdkUnknown(Swift.String)

        public static var allCases: [EnablementStatus] {
            return [
                .failed,
                .succeeded,
                .underChange,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .succeeded: return "SUCCEEDED"
            case .underChange: return "UNDER_CHANGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EnablementStatus(rawValue: rawValue) ?? EnablementStatus.sdkUnknown(rawValue)
        }
    }
}

extension ControlTowerClientTypes.EnablementStatusSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastOperationIdentifier
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastOperationIdentifier = self.lastOperationIdentifier {
            try encodeContainer.encode(lastOperationIdentifier, forKey: .lastOperationIdentifier)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ControlTowerClientTypes.EnablementStatus.self, forKey: .status)
        status = statusDecoded
        let lastOperationIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastOperationIdentifier)
        lastOperationIdentifier = lastOperationIdentifierDecoded
    }
}

extension ControlTowerClientTypes {
    /// The deployment summary of the enabled control.
    public struct EnablementStatusSummary: Swift.Equatable {
        /// The last operation identifier for the enabled control.
        public var lastOperationIdentifier: Swift.String?
        /// The deployment status of the enabled control. Valid values:
        ///
        /// * SUCCEEDED: The enabledControl configuration was deployed successfully.
        ///
        /// * UNDER_CHANGE: The enabledControl configuration is changing.
        ///
        /// * FAILED: The enabledControl configuration failed to deploy.
        public var status: ControlTowerClientTypes.EnablementStatus?

        public init(
            lastOperationIdentifier: Swift.String? = nil,
            status: ControlTowerClientTypes.EnablementStatus? = nil
        )
        {
            self.lastOperationIdentifier = lastOperationIdentifier
            self.status = status
        }
    }

}

extension GetBaselineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baselineIdentifier = self.baselineIdentifier {
            try encodeContainer.encode(baselineIdentifier, forKey: .baselineIdentifier)
        }
    }
}

extension GetBaselineInput {

    static func urlPathProvider(_ value: GetBaselineInput) -> Swift.String? {
        return "/get-baseline"
    }
}

public struct GetBaselineInput: Swift.Equatable {
    /// The ARN of the Baseline resource to be retrieved.
    /// This member is required.
    public var baselineIdentifier: Swift.String?

    public init(
        baselineIdentifier: Swift.String? = nil
    )
    {
        self.baselineIdentifier = baselineIdentifier
    }
}

struct GetBaselineInputBody: Swift.Equatable {
    let baselineIdentifier: Swift.String?
}

extension GetBaselineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineIdentifier)
        baselineIdentifier = baselineIdentifierDecoded
    }
}

extension GetBaselineOperationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operationIdentifier = self.operationIdentifier {
            try encodeContainer.encode(operationIdentifier, forKey: .operationIdentifier)
        }
    }
}

extension GetBaselineOperationInput {

    static func urlPathProvider(_ value: GetBaselineOperationInput) -> Swift.String? {
        return "/get-baseline-operation"
    }
}

public struct GetBaselineOperationInput: Swift.Equatable {
    /// The operation ID returned from mutating asynchronous APIs (Enable, Disable, Update, Reset).
    /// This member is required.
    public var operationIdentifier: Swift.String?

    public init(
        operationIdentifier: Swift.String? = nil
    )
    {
        self.operationIdentifier = operationIdentifier
    }
}

struct GetBaselineOperationInputBody: Swift.Equatable {
    let operationIdentifier: Swift.String?
}

extension GetBaselineOperationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationIdentifier)
        operationIdentifier = operationIdentifierDecoded
    }
}

extension GetBaselineOperationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBaselineOperationOutputBody = try responseDecoder.decode(responseBody: data)
            self.baselineOperation = output.baselineOperation
        } else {
            self.baselineOperation = nil
        }
    }
}

public struct GetBaselineOperationOutput: Swift.Equatable {
    /// A baselineOperation object that shows information about the specified operation ID.
    /// This member is required.
    public var baselineOperation: ControlTowerClientTypes.BaselineOperation?

    public init(
        baselineOperation: ControlTowerClientTypes.BaselineOperation? = nil
    )
    {
        self.baselineOperation = baselineOperation
    }
}

struct GetBaselineOperationOutputBody: Swift.Equatable {
    let baselineOperation: ControlTowerClientTypes.BaselineOperation?
}

extension GetBaselineOperationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineOperation
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineOperationDecoded = try containerValues.decodeIfPresent(ControlTowerClientTypes.BaselineOperation.self, forKey: .baselineOperation)
        baselineOperation = baselineOperationDecoded
    }
}

enum GetBaselineOperationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetBaselineOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBaselineOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.description = output.description
            self.name = output.name
        } else {
            self.arn = nil
            self.description = nil
            self.name = nil
        }
    }
}

public struct GetBaselineOutput: Swift.Equatable {
    /// The baseline ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// A description of the baseline.
    public var description: Swift.String?
    /// A user-friendly name for the baseline.
    /// This member is required.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.name = name
    }
}

struct GetBaselineOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
}

extension GetBaselineOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case description
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

enum GetBaselineOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetControlOperationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operationIdentifier = self.operationIdentifier {
            try encodeContainer.encode(operationIdentifier, forKey: .operationIdentifier)
        }
    }
}

extension GetControlOperationInput {

    static func urlPathProvider(_ value: GetControlOperationInput) -> Swift.String? {
        return "/get-control-operation"
    }
}

public struct GetControlOperationInput: Swift.Equatable {
    /// The ID of the asynchronous operation, which is used to track status. The operation is available for 90 days.
    /// This member is required.
    public var operationIdentifier: Swift.String?

    public init(
        operationIdentifier: Swift.String? = nil
    )
    {
        self.operationIdentifier = operationIdentifier
    }
}

struct GetControlOperationInputBody: Swift.Equatable {
    let operationIdentifier: Swift.String?
}

extension GetControlOperationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationIdentifier)
        operationIdentifier = operationIdentifierDecoded
    }
}

extension GetControlOperationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetControlOperationOutputBody = try responseDecoder.decode(responseBody: data)
            self.controlOperation = output.controlOperation
        } else {
            self.controlOperation = nil
        }
    }
}

public struct GetControlOperationOutput: Swift.Equatable {
    /// An operation performed by the control.
    /// This member is required.
    public var controlOperation: ControlTowerClientTypes.ControlOperation?

    public init(
        controlOperation: ControlTowerClientTypes.ControlOperation? = nil
    )
    {
        self.controlOperation = controlOperation
    }
}

struct GetControlOperationOutputBody: Swift.Equatable {
    let controlOperation: ControlTowerClientTypes.ControlOperation?
}

extension GetControlOperationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlOperation
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlOperationDecoded = try containerValues.decodeIfPresent(ControlTowerClientTypes.ControlOperation.self, forKey: .controlOperation)
        controlOperation = controlOperationDecoded
    }
}

enum GetControlOperationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEnabledBaselineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabledBaselineIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabledBaselineIdentifier = self.enabledBaselineIdentifier {
            try encodeContainer.encode(enabledBaselineIdentifier, forKey: .enabledBaselineIdentifier)
        }
    }
}

extension GetEnabledBaselineInput {

    static func urlPathProvider(_ value: GetEnabledBaselineInput) -> Swift.String? {
        return "/get-enabled-baseline"
    }
}

public struct GetEnabledBaselineInput: Swift.Equatable {
    /// Identifier of the EnabledBaseline resource to be retrieved, in ARN format.
    /// This member is required.
    public var enabledBaselineIdentifier: Swift.String?

    public init(
        enabledBaselineIdentifier: Swift.String? = nil
    )
    {
        self.enabledBaselineIdentifier = enabledBaselineIdentifier
    }
}

struct GetEnabledBaselineInputBody: Swift.Equatable {
    let enabledBaselineIdentifier: Swift.String?
}

extension GetEnabledBaselineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabledBaselineIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledBaselineIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .enabledBaselineIdentifier)
        enabledBaselineIdentifier = enabledBaselineIdentifierDecoded
    }
}

extension GetEnabledBaselineOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEnabledBaselineOutputBody = try responseDecoder.decode(responseBody: data)
            self.enabledBaselineDetails = output.enabledBaselineDetails
        } else {
            self.enabledBaselineDetails = nil
        }
    }
}

public struct GetEnabledBaselineOutput: Swift.Equatable {
    /// Details of the EnabledBaseline resource.
    public var enabledBaselineDetails: ControlTowerClientTypes.EnabledBaselineDetails?

    public init(
        enabledBaselineDetails: ControlTowerClientTypes.EnabledBaselineDetails? = nil
    )
    {
        self.enabledBaselineDetails = enabledBaselineDetails
    }
}

struct GetEnabledBaselineOutputBody: Swift.Equatable {
    let enabledBaselineDetails: ControlTowerClientTypes.EnabledBaselineDetails?
}

extension GetEnabledBaselineOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabledBaselineDetails
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledBaselineDetailsDecoded = try containerValues.decodeIfPresent(ControlTowerClientTypes.EnabledBaselineDetails.self, forKey: .enabledBaselineDetails)
        enabledBaselineDetails = enabledBaselineDetailsDecoded
    }
}

enum GetEnabledBaselineOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEnabledControlInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabledControlIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabledControlIdentifier = self.enabledControlIdentifier {
            try encodeContainer.encode(enabledControlIdentifier, forKey: .enabledControlIdentifier)
        }
    }
}

extension GetEnabledControlInput {

    static func urlPathProvider(_ value: GetEnabledControlInput) -> Swift.String? {
        return "/get-enabled-control"
    }
}

public struct GetEnabledControlInput: Swift.Equatable {
    /// The controlIdentifier of the enabled control.
    /// This member is required.
    public var enabledControlIdentifier: Swift.String?

    public init(
        enabledControlIdentifier: Swift.String? = nil
    )
    {
        self.enabledControlIdentifier = enabledControlIdentifier
    }
}

struct GetEnabledControlInputBody: Swift.Equatable {
    let enabledControlIdentifier: Swift.String?
}

extension GetEnabledControlInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabledControlIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledControlIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .enabledControlIdentifier)
        enabledControlIdentifier = enabledControlIdentifierDecoded
    }
}

extension GetEnabledControlOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEnabledControlOutputBody = try responseDecoder.decode(responseBody: data)
            self.enabledControlDetails = output.enabledControlDetails
        } else {
            self.enabledControlDetails = nil
        }
    }
}

public struct GetEnabledControlOutput: Swift.Equatable {
    /// Information about the enabled control.
    /// This member is required.
    public var enabledControlDetails: ControlTowerClientTypes.EnabledControlDetails?

    public init(
        enabledControlDetails: ControlTowerClientTypes.EnabledControlDetails? = nil
    )
    {
        self.enabledControlDetails = enabledControlDetails
    }
}

struct GetEnabledControlOutputBody: Swift.Equatable {
    let enabledControlDetails: ControlTowerClientTypes.EnabledControlDetails?
}

extension GetEnabledControlOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabledControlDetails
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledControlDetailsDecoded = try containerValues.decodeIfPresent(ControlTowerClientTypes.EnabledControlDetails.self, forKey: .enabledControlDetails)
        enabledControlDetails = enabledControlDetailsDecoded
    }
}

enum GetEnabledControlOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetLandingZoneInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case landingZoneIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let landingZoneIdentifier = self.landingZoneIdentifier {
            try encodeContainer.encode(landingZoneIdentifier, forKey: .landingZoneIdentifier)
        }
    }
}

extension GetLandingZoneInput {

    static func urlPathProvider(_ value: GetLandingZoneInput) -> Swift.String? {
        return "/get-landingzone"
    }
}

public struct GetLandingZoneInput: Swift.Equatable {
    /// The unique identifier of the landing zone.
    /// This member is required.
    public var landingZoneIdentifier: Swift.String?

    public init(
        landingZoneIdentifier: Swift.String? = nil
    )
    {
        self.landingZoneIdentifier = landingZoneIdentifier
    }
}

struct GetLandingZoneInputBody: Swift.Equatable {
    let landingZoneIdentifier: Swift.String?
}

extension GetLandingZoneInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case landingZoneIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let landingZoneIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .landingZoneIdentifier)
        landingZoneIdentifier = landingZoneIdentifierDecoded
    }
}

extension GetLandingZoneOperationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operationIdentifier = self.operationIdentifier {
            try encodeContainer.encode(operationIdentifier, forKey: .operationIdentifier)
        }
    }
}

extension GetLandingZoneOperationInput {

    static func urlPathProvider(_ value: GetLandingZoneOperationInput) -> Swift.String? {
        return "/get-landingzone-operation"
    }
}

public struct GetLandingZoneOperationInput: Swift.Equatable {
    /// A unique identifier assigned to a landing zone operation.
    /// This member is required.
    public var operationIdentifier: Swift.String?

    public init(
        operationIdentifier: Swift.String? = nil
    )
    {
        self.operationIdentifier = operationIdentifier
    }
}

struct GetLandingZoneOperationInputBody: Swift.Equatable {
    let operationIdentifier: Swift.String?
}

extension GetLandingZoneOperationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationIdentifier)
        operationIdentifier = operationIdentifierDecoded
    }
}

extension GetLandingZoneOperationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLandingZoneOperationOutputBody = try responseDecoder.decode(responseBody: data)
            self.operationDetails = output.operationDetails
        } else {
            self.operationDetails = nil
        }
    }
}

public struct GetLandingZoneOperationOutput: Swift.Equatable {
    /// Details about a landing zone operation.
    /// This member is required.
    public var operationDetails: ControlTowerClientTypes.LandingZoneOperationDetail?

    public init(
        operationDetails: ControlTowerClientTypes.LandingZoneOperationDetail? = nil
    )
    {
        self.operationDetails = operationDetails
    }
}

struct GetLandingZoneOperationOutputBody: Swift.Equatable {
    let operationDetails: ControlTowerClientTypes.LandingZoneOperationDetail?
}

extension GetLandingZoneOperationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationDetails
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationDetailsDecoded = try containerValues.decodeIfPresent(ControlTowerClientTypes.LandingZoneOperationDetail.self, forKey: .operationDetails)
        operationDetails = operationDetailsDecoded
    }
}

enum GetLandingZoneOperationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetLandingZoneOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLandingZoneOutputBody = try responseDecoder.decode(responseBody: data)
            self.landingZone = output.landingZone
        } else {
            self.landingZone = nil
        }
    }
}

public struct GetLandingZoneOutput: Swift.Equatable {
    /// Information about the landing zone.
    /// This member is required.
    public var landingZone: ControlTowerClientTypes.LandingZoneDetail?

    public init(
        landingZone: ControlTowerClientTypes.LandingZoneDetail? = nil
    )
    {
        self.landingZone = landingZone
    }
}

struct GetLandingZoneOutputBody: Swift.Equatable {
    let landingZone: ControlTowerClientTypes.LandingZoneDetail?
}

extension GetLandingZoneOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case landingZone
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let landingZoneDecoded = try containerValues.decodeIfPresent(ControlTowerClientTypes.LandingZoneDetail.self, forKey: .landingZone)
        landingZone = landingZoneDecoded
    }
}

enum GetLandingZoneOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An unexpected error occurred during processing of a request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ControlTowerClientTypes.LandingZoneDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case driftStatus
        case latestAvailableVersion
        case manifest
        case status
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let driftStatus = self.driftStatus {
            try encodeContainer.encode(driftStatus, forKey: .driftStatus)
        }
        if let latestAvailableVersion = self.latestAvailableVersion {
            try encodeContainer.encode(latestAvailableVersion, forKey: .latestAvailableVersion)
        }
        if let manifest = self.manifest {
            try encodeContainer.encode(manifest, forKey: .manifest)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let manifestDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .manifest)
        manifest = manifestDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ControlTowerClientTypes.LandingZoneStatus.self, forKey: .status)
        status = statusDecoded
        let latestAvailableVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestAvailableVersion)
        latestAvailableVersion = latestAvailableVersionDecoded
        let driftStatusDecoded = try containerValues.decodeIfPresent(ControlTowerClientTypes.LandingZoneDriftStatusSummary.self, forKey: .driftStatus)
        driftStatus = driftStatusDecoded
    }
}

extension ControlTowerClientTypes {
    /// Information about the landing zone.
    public struct LandingZoneDetail: Swift.Equatable {
        /// The ARN of the landing zone.
        public var arn: Swift.String?
        /// The drift status of the landing zone.
        public var driftStatus: ControlTowerClientTypes.LandingZoneDriftStatusSummary?
        /// The latest available version of the landing zone.
        public var latestAvailableVersion: Swift.String?
        /// The landing zone manifest.yaml text file that specifies the landing zone configurations.
        /// This member is required.
        public var manifest: ClientRuntime.Document?
        /// The landing zone deployment status. One of ACTIVE, PROCESSING, FAILED.
        public var status: ControlTowerClientTypes.LandingZoneStatus?
        /// The landing zone's current deployed version.
        /// This member is required.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            driftStatus: ControlTowerClientTypes.LandingZoneDriftStatusSummary? = nil,
            latestAvailableVersion: Swift.String? = nil,
            manifest: ClientRuntime.Document? = nil,
            status: ControlTowerClientTypes.LandingZoneStatus? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.driftStatus = driftStatus
            self.latestAvailableVersion = latestAvailableVersion
            self.manifest = manifest
            self.status = status
            self.version = version
        }
    }

}

extension ControlTowerClientTypes {
    public enum LandingZoneDriftStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case drifted
        case inSync
        case sdkUnknown(Swift.String)

        public static var allCases: [LandingZoneDriftStatus] {
            return [
                .drifted,
                .inSync,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .drifted: return "DRIFTED"
            case .inSync: return "IN_SYNC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LandingZoneDriftStatus(rawValue: rawValue) ?? LandingZoneDriftStatus.sdkUnknown(rawValue)
        }
    }
}

extension ControlTowerClientTypes.LandingZoneDriftStatusSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ControlTowerClientTypes.LandingZoneDriftStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ControlTowerClientTypes {
    /// The drift status summary of the landing zone. If the landing zone differs from the expected configuration, it is defined to be in a state of drift. You can repair this drift by resetting the landing zone.
    public struct LandingZoneDriftStatusSummary: Swift.Equatable {
        /// The drift status of the landing zone. Valid values:
        ///
        /// * DRIFTED: The landing zone deployed in this configuration does not match the configuration that Amazon Web Services Control Tower expected.
        ///
        /// * IN_SYNC: The landing zone deployed in this configuration matches the configuration that Amazon Web Services Control Tower expected.
        public var status: ControlTowerClientTypes.LandingZoneDriftStatus?

        public init(
            status: ControlTowerClientTypes.LandingZoneDriftStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension ControlTowerClientTypes.LandingZoneOperationDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case operationType
        case startTime
        case status
        case statusMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .dateTime, forKey: .endTime)
        }
        if let operationType = self.operationType {
            try encodeContainer.encode(operationType.rawValue, forKey: .operationType)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationTypeDecoded = try containerValues.decodeIfPresent(ControlTowerClientTypes.LandingZoneOperationType.self, forKey: .operationType)
        operationType = operationTypeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endTime)
        endTime = endTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ControlTowerClientTypes.LandingZoneOperationStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension ControlTowerClientTypes {
    /// Information about a landing zone operation.
    public struct LandingZoneOperationDetail: Swift.Equatable {
        /// The landing zone operation end time.
        public var endTime: ClientRuntime.Date?
        /// The landing zone operation type. Valid values:
        ///
        /// * DELETE: The DeleteLandingZone operation.
        ///
        /// * CREATE: The CreateLandingZone operation.
        ///
        /// * UPDATE: The UpdateLandingZone operation.
        ///
        /// * RESET: The ResetLandingZone operation.
        public var operationType: ControlTowerClientTypes.LandingZoneOperationType?
        /// The landing zone operation start time.
        public var startTime: ClientRuntime.Date?
        /// Valid values:
        ///
        /// * SUCCEEDED: The landing zone operation succeeded.
        ///
        /// * IN_PROGRESS: The landing zone operation is in progress.
        ///
        /// * FAILED: The landing zone operation failed.
        public var status: ControlTowerClientTypes.LandingZoneOperationStatus?
        /// If the operation result is FAILED, this string contains a message explaining why the operation failed.
        public var statusMessage: Swift.String?

        public init(
            endTime: ClientRuntime.Date? = nil,
            operationType: ControlTowerClientTypes.LandingZoneOperationType? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: ControlTowerClientTypes.LandingZoneOperationStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.endTime = endTime
            self.operationType = operationType
            self.startTime = startTime
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension ControlTowerClientTypes {
    public enum LandingZoneOperationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [LandingZoneOperationStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LandingZoneOperationStatus(rawValue: rawValue) ?? LandingZoneOperationStatus.sdkUnknown(rawValue)
        }
    }
}

extension ControlTowerClientTypes {
    public enum LandingZoneOperationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case create
        case delete
        case reset
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [LandingZoneOperationType] {
            return [
                .create,
                .delete,
                .reset,
                .update,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .create: return "CREATE"
            case .delete: return "DELETE"
            case .reset: return "RESET"
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LandingZoneOperationType(rawValue: rawValue) ?? LandingZoneOperationType.sdkUnknown(rawValue)
        }
    }
}

extension ControlTowerClientTypes {
    public enum LandingZoneStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case failed
        case processing
        case sdkUnknown(Swift.String)

        public static var allCases: [LandingZoneStatus] {
            return [
                .active,
                .failed,
                .processing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .failed: return "FAILED"
            case .processing: return "PROCESSING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LandingZoneStatus(rawValue: rawValue) ?? LandingZoneStatus.sdkUnknown(rawValue)
        }
    }
}

extension ControlTowerClientTypes.LandingZoneSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension ControlTowerClientTypes {
    /// Returns a summary of information about a landing zone.
    public struct LandingZoneSummary: Swift.Equatable {
        /// The ARN of the landing zone.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension ListBaselinesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListBaselinesInput {

    static func urlPathProvider(_ value: ListBaselinesInput) -> Swift.String? {
        return "/list-baselines"
    }
}

public struct ListBaselinesInput: Swift.Equatable {
    /// The maximum number of results to be shown.
    public var maxResults: Swift.Int?
    /// A pagination token.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBaselinesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListBaselinesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListBaselinesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListBaselinesOutputBody = try responseDecoder.decode(responseBody: data)
            self.baselines = output.baselines
            self.nextToken = output.nextToken
        } else {
            self.baselines = nil
            self.nextToken = nil
        }
    }
}

public struct ListBaselinesOutput: Swift.Equatable {
    /// A list of Baseline object details.
    /// This member is required.
    public var baselines: [ControlTowerClientTypes.BaselineSummary]?
    /// A pagination token.
    public var nextToken: Swift.String?

    public init(
        baselines: [ControlTowerClientTypes.BaselineSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.baselines = baselines
        self.nextToken = nextToken
    }
}

struct ListBaselinesOutputBody: Swift.Equatable {
    let baselines: [ControlTowerClientTypes.BaselineSummary]?
    let nextToken: Swift.String?
}

extension ListBaselinesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselines
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselinesContainer = try containerValues.decodeIfPresent([ControlTowerClientTypes.BaselineSummary?].self, forKey: .baselines)
        var baselinesDecoded0:[ControlTowerClientTypes.BaselineSummary]? = nil
        if let baselinesContainer = baselinesContainer {
            baselinesDecoded0 = [ControlTowerClientTypes.BaselineSummary]()
            for structure0 in baselinesContainer {
                if let structure0 = structure0 {
                    baselinesDecoded0?.append(structure0)
                }
            }
        }
        baselines = baselinesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListBaselinesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEnabledBaselinesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListEnabledBaselinesInput {

    static func urlPathProvider(_ value: ListEnabledBaselinesInput) -> Swift.String? {
        return "/list-enabled-baselines"
    }
}

public struct ListEnabledBaselinesInput: Swift.Equatable {
    /// A filter applied on the ListEnabledBaseline operation. Allowed filters are baselineIdentifiers and targetIdentifiers. The filter can be applied for either, or both.
    public var filter: ControlTowerClientTypes.EnabledBaselineFilter?
    /// The maximum number of results to be shown.
    public var maxResults: Swift.Int?
    /// A pagination token.
    public var nextToken: Swift.String?

    public init(
        filter: ControlTowerClientTypes.EnabledBaselineFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEnabledBaselinesInputBody: Swift.Equatable {
    let filter: ControlTowerClientTypes.EnabledBaselineFilter?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListEnabledBaselinesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(ControlTowerClientTypes.EnabledBaselineFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEnabledBaselinesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEnabledBaselinesOutputBody = try responseDecoder.decode(responseBody: data)
            self.enabledBaselines = output.enabledBaselines
            self.nextToken = output.nextToken
        } else {
            self.enabledBaselines = nil
            self.nextToken = nil
        }
    }
}

public struct ListEnabledBaselinesOutput: Swift.Equatable {
    /// Retuens a list of summaries of EnabledBaseline resources.
    /// This member is required.
    public var enabledBaselines: [ControlTowerClientTypes.EnabledBaselineSummary]?
    /// A pagination token.
    public var nextToken: Swift.String?

    public init(
        enabledBaselines: [ControlTowerClientTypes.EnabledBaselineSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.enabledBaselines = enabledBaselines
        self.nextToken = nextToken
    }
}

struct ListEnabledBaselinesOutputBody: Swift.Equatable {
    let enabledBaselines: [ControlTowerClientTypes.EnabledBaselineSummary]?
    let nextToken: Swift.String?
}

extension ListEnabledBaselinesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabledBaselines
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledBaselinesContainer = try containerValues.decodeIfPresent([ControlTowerClientTypes.EnabledBaselineSummary?].self, forKey: .enabledBaselines)
        var enabledBaselinesDecoded0:[ControlTowerClientTypes.EnabledBaselineSummary]? = nil
        if let enabledBaselinesContainer = enabledBaselinesContainer {
            enabledBaselinesDecoded0 = [ControlTowerClientTypes.EnabledBaselineSummary]()
            for structure0 in enabledBaselinesContainer {
                if let structure0 = structure0 {
                    enabledBaselinesDecoded0?.append(structure0)
                }
            }
        }
        enabledBaselines = enabledBaselinesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEnabledBaselinesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEnabledControlsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case targetIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let targetIdentifier = self.targetIdentifier {
            try encodeContainer.encode(targetIdentifier, forKey: .targetIdentifier)
        }
    }
}

extension ListEnabledControlsInput {

    static func urlPathProvider(_ value: ListEnabledControlsInput) -> Swift.String? {
        return "/list-enabled-controls"
    }
}

public struct ListEnabledControlsInput: Swift.Equatable {
    /// How many results to return per API call.
    public var maxResults: Swift.Int?
    /// The token to continue the list from a previous API call with the same parameters.
    public var nextToken: Swift.String?
    /// The ARN of the organizational unit. For information on how to find the targetIdentifier, see [the overview page](https://docs.aws.amazon.com/controltower/latest/APIReference/Welcome.html).
    /// This member is required.
    public var targetIdentifier: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        targetIdentifier: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.targetIdentifier = targetIdentifier
    }
}

struct ListEnabledControlsInputBody: Swift.Equatable {
    let targetIdentifier: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListEnabledControlsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case targetIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetIdentifier)
        targetIdentifier = targetIdentifierDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEnabledControlsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEnabledControlsOutputBody = try responseDecoder.decode(responseBody: data)
            self.enabledControls = output.enabledControls
            self.nextToken = output.nextToken
        } else {
            self.enabledControls = nil
            self.nextToken = nil
        }
    }
}

public struct ListEnabledControlsOutput: Swift.Equatable {
    /// Lists the controls enabled by Amazon Web Services Control Tower on the specified organizational unit and the accounts it contains.
    /// This member is required.
    public var enabledControls: [ControlTowerClientTypes.EnabledControlSummary]?
    /// Retrieves the next page of results. If the string is empty, the response is the end of the results.
    public var nextToken: Swift.String?

    public init(
        enabledControls: [ControlTowerClientTypes.EnabledControlSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.enabledControls = enabledControls
        self.nextToken = nextToken
    }
}

struct ListEnabledControlsOutputBody: Swift.Equatable {
    let enabledControls: [ControlTowerClientTypes.EnabledControlSummary]?
    let nextToken: Swift.String?
}

extension ListEnabledControlsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabledControls
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledControlsContainer = try containerValues.decodeIfPresent([ControlTowerClientTypes.EnabledControlSummary?].self, forKey: .enabledControls)
        var enabledControlsDecoded0:[ControlTowerClientTypes.EnabledControlSummary]? = nil
        if let enabledControlsContainer = enabledControlsContainer {
            enabledControlsDecoded0 = [ControlTowerClientTypes.EnabledControlSummary]()
            for structure0 in enabledControlsContainer {
                if let structure0 = structure0 {
                    enabledControlsDecoded0?.append(structure0)
                }
            }
        }
        enabledControls = enabledControlsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEnabledControlsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLandingZonesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListLandingZonesInput {

    static func urlPathProvider(_ value: ListLandingZonesInput) -> Swift.String? {
        return "/list-landingzones"
    }
}

public struct ListLandingZonesInput: Swift.Equatable {
    /// The maximum number of returned landing zone ARNs, which is one.
    public var maxResults: Swift.Int?
    /// The token to continue the list from a previous API call with the same parameters.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLandingZonesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListLandingZonesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListLandingZonesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLandingZonesOutputBody = try responseDecoder.decode(responseBody: data)
            self.landingZones = output.landingZones
            self.nextToken = output.nextToken
        } else {
            self.landingZones = nil
            self.nextToken = nil
        }
    }
}

public struct ListLandingZonesOutput: Swift.Equatable {
    /// The ARN of the landing zone.
    /// This member is required.
    public var landingZones: [ControlTowerClientTypes.LandingZoneSummary]?
    /// Retrieves the next page of results. If the string is empty, the response is the end of the results.
    public var nextToken: Swift.String?

    public init(
        landingZones: [ControlTowerClientTypes.LandingZoneSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.landingZones = landingZones
        self.nextToken = nextToken
    }
}

struct ListLandingZonesOutputBody: Swift.Equatable {
    let landingZones: [ControlTowerClientTypes.LandingZoneSummary]?
    let nextToken: Swift.String?
}

extension ListLandingZonesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case landingZones
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let landingZonesContainer = try containerValues.decodeIfPresent([ControlTowerClientTypes.LandingZoneSummary?].self, forKey: .landingZones)
        var landingZonesDecoded0:[ControlTowerClientTypes.LandingZoneSummary]? = nil
        if let landingZonesContainer = landingZonesContainer {
            landingZonesDecoded0 = [ControlTowerClientTypes.LandingZoneSummary]()
            for structure0 in landingZonesContainer {
                if let structure0 = structure0 {
                    landingZonesDecoded0?.append(structure0)
                }
            }
        }
        landingZones = landingZonesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListLandingZonesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A list of tags, as key:value strings.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ControlTowerClientTypes.Region: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ControlTowerClientTypes {
    /// An Amazon Web Services Region in which Amazon Web Services Control Tower expects to find the control deployed. The expected Regions are based on the Regions that are governed by the landing zone. In certain cases, a control is not actually enabled in the Region as expected, such as during drift, or [mixed governance](https://docs.aws.amazon.com/controltower/latest/userguide/region-how.html#mixed-governance).
    public struct Region: Swift.Equatable {
        /// The Amazon Web Services Region name.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension ResetEnabledBaselineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabledBaselineIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabledBaselineIdentifier = self.enabledBaselineIdentifier {
            try encodeContainer.encode(enabledBaselineIdentifier, forKey: .enabledBaselineIdentifier)
        }
    }
}

extension ResetEnabledBaselineInput {

    static func urlPathProvider(_ value: ResetEnabledBaselineInput) -> Swift.String? {
        return "/reset-enabled-baseline"
    }
}

public struct ResetEnabledBaselineInput: Swift.Equatable {
    /// Specifies the ID of the EnabledBaseline resource to be re-enabled, in ARN format.
    /// This member is required.
    public var enabledBaselineIdentifier: Swift.String?

    public init(
        enabledBaselineIdentifier: Swift.String? = nil
    )
    {
        self.enabledBaselineIdentifier = enabledBaselineIdentifier
    }
}

struct ResetEnabledBaselineInputBody: Swift.Equatable {
    let enabledBaselineIdentifier: Swift.String?
}

extension ResetEnabledBaselineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabledBaselineIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledBaselineIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .enabledBaselineIdentifier)
        enabledBaselineIdentifier = enabledBaselineIdentifierDecoded
    }
}

extension ResetEnabledBaselineOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResetEnabledBaselineOutputBody = try responseDecoder.decode(responseBody: data)
            self.operationIdentifier = output.operationIdentifier
        } else {
            self.operationIdentifier = nil
        }
    }
}

public struct ResetEnabledBaselineOutput: Swift.Equatable {
    /// The ID (in UUID format) of the asynchronous ResetEnabledBaseline operation. This operationIdentifier is used to track status through calls to the GetBaselineOperation API.
    /// This member is required.
    public var operationIdentifier: Swift.String?

    public init(
        operationIdentifier: Swift.String? = nil
    )
    {
        self.operationIdentifier = operationIdentifier
    }
}

struct ResetEnabledBaselineOutputBody: Swift.Equatable {
    let operationIdentifier: Swift.String?
}

extension ResetEnabledBaselineOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationIdentifier)
        operationIdentifier = operationIdentifierDecoded
    }
}

enum ResetEnabledBaselineOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResetLandingZoneInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case landingZoneIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let landingZoneIdentifier = self.landingZoneIdentifier {
            try encodeContainer.encode(landingZoneIdentifier, forKey: .landingZoneIdentifier)
        }
    }
}

extension ResetLandingZoneInput {

    static func urlPathProvider(_ value: ResetLandingZoneInput) -> Swift.String? {
        return "/reset-landingzone"
    }
}

public struct ResetLandingZoneInput: Swift.Equatable {
    /// The unique identifier of the landing zone.
    /// This member is required.
    public var landingZoneIdentifier: Swift.String?

    public init(
        landingZoneIdentifier: Swift.String? = nil
    )
    {
        self.landingZoneIdentifier = landingZoneIdentifier
    }
}

struct ResetLandingZoneInputBody: Swift.Equatable {
    let landingZoneIdentifier: Swift.String?
}

extension ResetLandingZoneInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case landingZoneIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let landingZoneIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .landingZoneIdentifier)
        landingZoneIdentifier = landingZoneIdentifierDecoded
    }
}

extension ResetLandingZoneOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResetLandingZoneOutputBody = try responseDecoder.decode(responseBody: data)
            self.operationIdentifier = output.operationIdentifier
        } else {
            self.operationIdentifier = nil
        }
    }
}

public struct ResetLandingZoneOutput: Swift.Equatable {
    /// A unique identifier assigned to a ResetLandingZone operation. You can use this identifier as an input parameter of GetLandingZoneOperation to check the operation's status.
    /// This member is required.
    public var operationIdentifier: Swift.String?

    public init(
        operationIdentifier: Swift.String? = nil
    )
    {
        self.operationIdentifier = operationIdentifier
    }
}

struct ResetLandingZoneOutputBody: Swift.Equatable {
    let operationIdentifier: Swift.String?
}

extension ResetLandingZoneOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationIdentifier)
        operationIdentifier = operationIdentifierDecoded
    }
}

enum ResetLandingZoneOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request references a resource that does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request would cause a service quota to be exceeded. The limit is 10 concurrent operations.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource to be tagged.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tags to be applied to the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the service quota that was exceeded.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The number of seconds the caller should wait before retrying.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
        /// The ID of the service that is associated with the error.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tag keys to be removed from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateEnabledBaselineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineVersion
        case enabledBaselineIdentifier
        case parameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baselineVersion = self.baselineVersion {
            try encodeContainer.encode(baselineVersion, forKey: .baselineVersion)
        }
        if let enabledBaselineIdentifier = self.enabledBaselineIdentifier {
            try encodeContainer.encode(enabledBaselineIdentifier, forKey: .enabledBaselineIdentifier)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameters)
            for enabledbaselineparameter0 in parameters {
                try parametersContainer.encode(enabledbaselineparameter0)
            }
        }
    }
}

extension UpdateEnabledBaselineInput {

    static func urlPathProvider(_ value: UpdateEnabledBaselineInput) -> Swift.String? {
        return "/update-enabled-baseline"
    }
}

public struct UpdateEnabledBaselineInput: Swift.Equatable {
    /// Specifies the new Baseline version, to which the EnabledBaseline should be updated.
    /// This member is required.
    public var baselineVersion: Swift.String?
    /// Specifies the EnabledBaseline resource to be updated.
    /// This member is required.
    public var enabledBaselineIdentifier: Swift.String?
    /// Parameters to apply when making an update.
    public var parameters: [ControlTowerClientTypes.EnabledBaselineParameter]?

    public init(
        baselineVersion: Swift.String? = nil,
        enabledBaselineIdentifier: Swift.String? = nil,
        parameters: [ControlTowerClientTypes.EnabledBaselineParameter]? = nil
    )
    {
        self.baselineVersion = baselineVersion
        self.enabledBaselineIdentifier = enabledBaselineIdentifier
        self.parameters = parameters
    }
}

struct UpdateEnabledBaselineInputBody: Swift.Equatable {
    let baselineVersion: Swift.String?
    let parameters: [ControlTowerClientTypes.EnabledBaselineParameter]?
    let enabledBaselineIdentifier: Swift.String?
}

extension UpdateEnabledBaselineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineVersion
        case enabledBaselineIdentifier
        case parameters
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineVersion)
        baselineVersion = baselineVersionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([ControlTowerClientTypes.EnabledBaselineParameter?].self, forKey: .parameters)
        var parametersDecoded0:[ControlTowerClientTypes.EnabledBaselineParameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [ControlTowerClientTypes.EnabledBaselineParameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
        let enabledBaselineIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .enabledBaselineIdentifier)
        enabledBaselineIdentifier = enabledBaselineIdentifierDecoded
    }
}

extension UpdateEnabledBaselineOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateEnabledBaselineOutputBody = try responseDecoder.decode(responseBody: data)
            self.operationIdentifier = output.operationIdentifier
        } else {
            self.operationIdentifier = nil
        }
    }
}

public struct UpdateEnabledBaselineOutput: Swift.Equatable {
    /// The ID (in UUID format) of the asynchronous UpdateEnabledBaseline operation. This operationIdentifier is used to track status through calls to the GetBaselineOperation API.
    /// This member is required.
    public var operationIdentifier: Swift.String?

    public init(
        operationIdentifier: Swift.String? = nil
    )
    {
        self.operationIdentifier = operationIdentifier
    }
}

struct UpdateEnabledBaselineOutputBody: Swift.Equatable {
    let operationIdentifier: Swift.String?
}

extension UpdateEnabledBaselineOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationIdentifier)
        operationIdentifier = operationIdentifierDecoded
    }
}

enum UpdateEnabledBaselineOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateEnabledControlInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabledControlIdentifier
        case parameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabledControlIdentifier = self.enabledControlIdentifier {
            try encodeContainer.encode(enabledControlIdentifier, forKey: .enabledControlIdentifier)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameters)
            for enabledcontrolparameter0 in parameters {
                try parametersContainer.encode(enabledcontrolparameter0)
            }
        }
    }
}

extension UpdateEnabledControlInput {

    static func urlPathProvider(_ value: UpdateEnabledControlInput) -> Swift.String? {
        return "/update-enabled-control"
    }
}

public struct UpdateEnabledControlInput: Swift.Equatable {
    /// The ARN of the enabled control that will be updated.
    /// This member is required.
    public var enabledControlIdentifier: Swift.String?
    /// A key/value pair, where Key is of type String and Value is of type Document.
    /// This member is required.
    public var parameters: [ControlTowerClientTypes.EnabledControlParameter]?

    public init(
        enabledControlIdentifier: Swift.String? = nil,
        parameters: [ControlTowerClientTypes.EnabledControlParameter]? = nil
    )
    {
        self.enabledControlIdentifier = enabledControlIdentifier
        self.parameters = parameters
    }
}

struct UpdateEnabledControlInputBody: Swift.Equatable {
    let parameters: [ControlTowerClientTypes.EnabledControlParameter]?
    let enabledControlIdentifier: Swift.String?
}

extension UpdateEnabledControlInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabledControlIdentifier
        case parameters
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parametersContainer = try containerValues.decodeIfPresent([ControlTowerClientTypes.EnabledControlParameter?].self, forKey: .parameters)
        var parametersDecoded0:[ControlTowerClientTypes.EnabledControlParameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [ControlTowerClientTypes.EnabledControlParameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
        let enabledControlIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .enabledControlIdentifier)
        enabledControlIdentifier = enabledControlIdentifierDecoded
    }
}

extension UpdateEnabledControlOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateEnabledControlOutputBody = try responseDecoder.decode(responseBody: data)
            self.operationIdentifier = output.operationIdentifier
        } else {
            self.operationIdentifier = nil
        }
    }
}

public struct UpdateEnabledControlOutput: Swift.Equatable {
    /// The operation identifier for this UpdateEnabledControl operation.
    /// This member is required.
    public var operationIdentifier: Swift.String?

    public init(
        operationIdentifier: Swift.String? = nil
    )
    {
        self.operationIdentifier = operationIdentifier
    }
}

struct UpdateEnabledControlOutputBody: Swift.Equatable {
    let operationIdentifier: Swift.String?
}

extension UpdateEnabledControlOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationIdentifier)
        operationIdentifier = operationIdentifierDecoded
    }
}

enum UpdateEnabledControlOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateLandingZoneInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case landingZoneIdentifier
        case manifest
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let landingZoneIdentifier = self.landingZoneIdentifier {
            try encodeContainer.encode(landingZoneIdentifier, forKey: .landingZoneIdentifier)
        }
        if let manifest = self.manifest {
            try encodeContainer.encode(manifest, forKey: .manifest)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }
}

extension UpdateLandingZoneInput {

    static func urlPathProvider(_ value: UpdateLandingZoneInput) -> Swift.String? {
        return "/update-landingzone"
    }
}

public struct UpdateLandingZoneInput: Swift.Equatable {
    /// The unique identifier of the landing zone.
    /// This member is required.
    public var landingZoneIdentifier: Swift.String?
    /// The manifest.yaml file is a text file that describes your Amazon Web Services resources. For examples, review [The manifest file](https://docs.aws.amazon.com/controltower/latest/userguide/the-manifest-file).
    /// This member is required.
    public var manifest: ClientRuntime.Document?
    /// The landing zone version, for example, 3.2.
    /// This member is required.
    public var version: Swift.String?

    public init(
        landingZoneIdentifier: Swift.String? = nil,
        manifest: ClientRuntime.Document? = nil,
        version: Swift.String? = nil
    )
    {
        self.landingZoneIdentifier = landingZoneIdentifier
        self.manifest = manifest
        self.version = version
    }
}

struct UpdateLandingZoneInputBody: Swift.Equatable {
    let version: Swift.String?
    let manifest: ClientRuntime.Document?
    let landingZoneIdentifier: Swift.String?
}

extension UpdateLandingZoneInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case landingZoneIdentifier
        case manifest
        case version
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let manifestDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .manifest)
        manifest = manifestDecoded
        let landingZoneIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .landingZoneIdentifier)
        landingZoneIdentifier = landingZoneIdentifierDecoded
    }
}

extension UpdateLandingZoneOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateLandingZoneOutputBody = try responseDecoder.decode(responseBody: data)
            self.operationIdentifier = output.operationIdentifier
        } else {
            self.operationIdentifier = nil
        }
    }
}

public struct UpdateLandingZoneOutput: Swift.Equatable {
    /// A unique identifier assigned to a UpdateLandingZone operation. You can use this identifier as an input of GetLandingZoneOperation to check the operation's status.
    /// This member is required.
    public var operationIdentifier: Swift.String?

    public init(
        operationIdentifier: Swift.String? = nil
    )
    {
        self.operationIdentifier = operationIdentifier
    }
}

struct UpdateLandingZoneOutputBody: Swift.Equatable {
    let operationIdentifier: Swift.String?
}

extension UpdateLandingZoneOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationIdentifier)
        operationIdentifier = operationIdentifierDecoded
    }
}

enum UpdateLandingZoneOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input does not satisfy the constraints specified by an Amazon Web Services service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
