// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// User does not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Updating or deleting a resource can cause an inconsistent state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ControlTowerClientTypes.ControlOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case operationType
        case startTime
        case status
        case statusMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .dateTime, forKey: .endTime)
        }
        if let operationType = self.operationType {
            try encodeContainer.encode(operationType.rawValue, forKey: .operationType)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationTypeDecoded = try containerValues.decodeIfPresent(ControlTowerClientTypes.ControlOperationType.self, forKey: .operationType)
        operationType = operationTypeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endTime)
        endTime = endTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ControlTowerClientTypes.ControlOperationStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension ControlTowerClientTypes {
    /// An operation performed by the control.
    public struct ControlOperation: Swift.Equatable {
        /// The time that the operation finished.
        public var endTime: ClientRuntime.Date?
        /// One of ENABLE_CONTROL or DISABLE_CONTROL.
        public var operationType: ControlTowerClientTypes.ControlOperationType?
        /// The time that the operation began.
        public var startTime: ClientRuntime.Date?
        /// One of IN_PROGRESS, SUCEEDED, or FAILED.
        public var status: ControlTowerClientTypes.ControlOperationStatus?
        /// If the operation result is FAILED, this string contains a message explaining why the operation failed.
        public var statusMessage: Swift.String?

        public init(
            endTime: ClientRuntime.Date? = nil,
            operationType: ControlTowerClientTypes.ControlOperationType? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: ControlTowerClientTypes.ControlOperationStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.endTime = endTime
            self.operationType = operationType
            self.startTime = startTime
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension ControlTowerClientTypes {
    public enum ControlOperationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ControlOperationStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ControlOperationStatus(rawValue: rawValue) ?? ControlOperationStatus.sdkUnknown(rawValue)
        }
    }
}

extension ControlTowerClientTypes {
    public enum ControlOperationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disableControl
        case enableControl
        case sdkUnknown(Swift.String)

        public static var allCases: [ControlOperationType] {
            return [
                .disableControl,
                .enableControl,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disableControl: return "DISABLE_CONTROL"
            case .enableControl: return "ENABLE_CONTROL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ControlOperationType(rawValue: rawValue) ?? ControlOperationType.sdkUnknown(rawValue)
        }
    }
}

extension DisableControlInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlIdentifier
        case targetIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let controlIdentifier = self.controlIdentifier {
            try encodeContainer.encode(controlIdentifier, forKey: .controlIdentifier)
        }
        if let targetIdentifier = self.targetIdentifier {
            try encodeContainer.encode(targetIdentifier, forKey: .targetIdentifier)
        }
    }
}

extension DisableControlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/disable-control"
    }
}

public struct DisableControlInput: Swift.Equatable {
    /// The ARN of the control. Only Strongly recommended and Elective controls are permitted, with the exception of the Region deny control. For information on how to find the controlIdentifier, see [the overview page](https://docs.aws.amazon.com/controltower/latest/APIReference/Welcome.html).
    /// This member is required.
    public var controlIdentifier: Swift.String?
    /// The ARN of the organizational unit. For information on how to find the targetIdentifier, see [the overview page](https://docs.aws.amazon.com/controltower/latest/APIReference/Welcome.html).
    /// This member is required.
    public var targetIdentifier: Swift.String?

    public init(
        controlIdentifier: Swift.String? = nil,
        targetIdentifier: Swift.String? = nil
    )
    {
        self.controlIdentifier = controlIdentifier
        self.targetIdentifier = targetIdentifier
    }
}

struct DisableControlInputBody: Swift.Equatable {
    let controlIdentifier: Swift.String?
    let targetIdentifier: Swift.String?
}

extension DisableControlInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlIdentifier
        case targetIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlIdentifier)
        controlIdentifier = controlIdentifierDecoded
        let targetIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetIdentifier)
        targetIdentifier = targetIdentifierDecoded
    }
}

extension DisableControlOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisableControlOutputBody = try responseDecoder.decode(responseBody: data)
            self.operationIdentifier = output.operationIdentifier
        } else {
            self.operationIdentifier = nil
        }
    }
}

public struct DisableControlOutput: Swift.Equatable {
    /// The ID of the asynchronous operation, which is used to track status. The operation is available for 90 days.
    /// This member is required.
    public var operationIdentifier: Swift.String?

    public init(
        operationIdentifier: Swift.String? = nil
    )
    {
        self.operationIdentifier = operationIdentifier
    }
}

struct DisableControlOutputBody: Swift.Equatable {
    let operationIdentifier: Swift.String?
}

extension DisableControlOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationIdentifier)
        operationIdentifier = operationIdentifierDecoded
    }
}

enum DisableControlOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ControlTowerClientTypes {
    public enum DriftStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case drifted
        case inSync
        case notChecking
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [DriftStatus] {
            return [
                .drifted,
                .inSync,
                .notChecking,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .drifted: return "DRIFTED"
            case .inSync: return "IN_SYNC"
            case .notChecking: return "NOT_CHECKING"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DriftStatus(rawValue: rawValue) ?? DriftStatus.sdkUnknown(rawValue)
        }
    }
}

extension ControlTowerClientTypes.DriftStatusSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case driftStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let driftStatus = self.driftStatus {
            try encodeContainer.encode(driftStatus.rawValue, forKey: .driftStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let driftStatusDecoded = try containerValues.decodeIfPresent(ControlTowerClientTypes.DriftStatus.self, forKey: .driftStatus)
        driftStatus = driftStatusDecoded
    }
}

extension ControlTowerClientTypes {
    /// The drift summary of the enabled control. AWS Control Tower expects the enabled control configuration to include all supported and governed Regions. If the enabled control differs from the expected configuration, it is defined to be in a state of drift. You can repair this drift by resetting the enabled control.
    public struct DriftStatusSummary: Swift.Equatable {
        /// The drift status of the enabled control. Valid values:
        ///
        /// * DRIFTED: The enabledControl deployed in this configuration doesn’t match the configuration that AWS Control Tower expected.
        ///
        /// * IN_SYNC: The enabledControl deployed in this configuration matches the configuration that AWS Control Tower expected.
        ///
        /// * NOT_CHECKING: AWS Control Tower does not check drift for this enabled control. Drift is not supported for the control type.
        ///
        /// * UNKNOWN: AWS Control Tower is not able to check the drift status for the enabled control.
        public var driftStatus: ControlTowerClientTypes.DriftStatus?

        public init(
            driftStatus: ControlTowerClientTypes.DriftStatus? = nil
        )
        {
            self.driftStatus = driftStatus
        }
    }

}

extension EnableControlInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlIdentifier
        case targetIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let controlIdentifier = self.controlIdentifier {
            try encodeContainer.encode(controlIdentifier, forKey: .controlIdentifier)
        }
        if let targetIdentifier = self.targetIdentifier {
            try encodeContainer.encode(targetIdentifier, forKey: .targetIdentifier)
        }
    }
}

extension EnableControlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/enable-control"
    }
}

public struct EnableControlInput: Swift.Equatable {
    /// The ARN of the control. Only Strongly recommended and Elective controls are permitted, with the exception of the Region deny control. For information on how to find the controlIdentifier, see [the overview page](https://docs.aws.amazon.com/controltower/latest/APIReference/Welcome.html).
    /// This member is required.
    public var controlIdentifier: Swift.String?
    /// The ARN of the organizational unit. For information on how to find the targetIdentifier, see [the overview page](https://docs.aws.amazon.com/controltower/latest/APIReference/Welcome.html).
    /// This member is required.
    public var targetIdentifier: Swift.String?

    public init(
        controlIdentifier: Swift.String? = nil,
        targetIdentifier: Swift.String? = nil
    )
    {
        self.controlIdentifier = controlIdentifier
        self.targetIdentifier = targetIdentifier
    }
}

struct EnableControlInputBody: Swift.Equatable {
    let controlIdentifier: Swift.String?
    let targetIdentifier: Swift.String?
}

extension EnableControlInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlIdentifier
        case targetIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlIdentifier)
        controlIdentifier = controlIdentifierDecoded
        let targetIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetIdentifier)
        targetIdentifier = targetIdentifierDecoded
    }
}

extension EnableControlOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EnableControlOutputBody = try responseDecoder.decode(responseBody: data)
            self.operationIdentifier = output.operationIdentifier
        } else {
            self.operationIdentifier = nil
        }
    }
}

public struct EnableControlOutput: Swift.Equatable {
    /// The ID of the asynchronous operation, which is used to track status. The operation is available for 90 days.
    /// This member is required.
    public var operationIdentifier: Swift.String?

    public init(
        operationIdentifier: Swift.String? = nil
    )
    {
        self.operationIdentifier = operationIdentifier
    }
}

struct EnableControlOutputBody: Swift.Equatable {
    let operationIdentifier: Swift.String?
}

extension EnableControlOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationIdentifier)
        operationIdentifier = operationIdentifierDecoded
    }
}

enum EnableControlOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ControlTowerClientTypes.EnabledControlDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case controlIdentifier
        case driftStatusSummary
        case statusSummary
        case targetIdentifier
        case targetRegions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let controlIdentifier = self.controlIdentifier {
            try encodeContainer.encode(controlIdentifier, forKey: .controlIdentifier)
        }
        if let driftStatusSummary = self.driftStatusSummary {
            try encodeContainer.encode(driftStatusSummary, forKey: .driftStatusSummary)
        }
        if let statusSummary = self.statusSummary {
            try encodeContainer.encode(statusSummary, forKey: .statusSummary)
        }
        if let targetIdentifier = self.targetIdentifier {
            try encodeContainer.encode(targetIdentifier, forKey: .targetIdentifier)
        }
        if let targetRegions = targetRegions {
            var targetRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetRegions)
            for region0 in targetRegions {
                try targetRegionsContainer.encode(region0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let controlIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlIdentifier)
        controlIdentifier = controlIdentifierDecoded
        let targetIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetIdentifier)
        targetIdentifier = targetIdentifierDecoded
        let targetRegionsContainer = try containerValues.decodeIfPresent([ControlTowerClientTypes.Region?].self, forKey: .targetRegions)
        var targetRegionsDecoded0:[ControlTowerClientTypes.Region]? = nil
        if let targetRegionsContainer = targetRegionsContainer {
            targetRegionsDecoded0 = [ControlTowerClientTypes.Region]()
            for structure0 in targetRegionsContainer {
                if let structure0 = structure0 {
                    targetRegionsDecoded0?.append(structure0)
                }
            }
        }
        targetRegions = targetRegionsDecoded0
        let statusSummaryDecoded = try containerValues.decodeIfPresent(ControlTowerClientTypes.EnablementStatusSummary.self, forKey: .statusSummary)
        statusSummary = statusSummaryDecoded
        let driftStatusSummaryDecoded = try containerValues.decodeIfPresent(ControlTowerClientTypes.DriftStatusSummary.self, forKey: .driftStatusSummary)
        driftStatusSummary = driftStatusSummaryDecoded
    }
}

extension ControlTowerClientTypes {
    /// Information about the enabled control.
    public struct EnabledControlDetails: Swift.Equatable {
        /// The ARN of the enabled control.
        public var arn: Swift.String?
        /// The control identifier of the enabled control. For information on how to find the controlIdentifier, see [the overview page](https://docs.aws.amazon.com/controltower/latest/APIReference/Welcome.html).
        public var controlIdentifier: Swift.String?
        /// The drift status of the enabled control.
        public var driftStatusSummary: ControlTowerClientTypes.DriftStatusSummary?
        /// The deployment summary of the enabled control.
        public var statusSummary: ControlTowerClientTypes.EnablementStatusSummary?
        /// The ARN of the organizational unit. For information on how to find the targetIdentifier, see [the overview page](https://docs.aws.amazon.com/controltower/latest/APIReference/Welcome.html).
        public var targetIdentifier: Swift.String?
        /// Target AWS Regions for the enabled control.
        public var targetRegions: [ControlTowerClientTypes.Region]?

        public init(
            arn: Swift.String? = nil,
            controlIdentifier: Swift.String? = nil,
            driftStatusSummary: ControlTowerClientTypes.DriftStatusSummary? = nil,
            statusSummary: ControlTowerClientTypes.EnablementStatusSummary? = nil,
            targetIdentifier: Swift.String? = nil,
            targetRegions: [ControlTowerClientTypes.Region]? = nil
        )
        {
            self.arn = arn
            self.controlIdentifier = controlIdentifier
            self.driftStatusSummary = driftStatusSummary
            self.statusSummary = statusSummary
            self.targetIdentifier = targetIdentifier
            self.targetRegions = targetRegions
        }
    }

}

extension ControlTowerClientTypes.EnabledControlSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case controlIdentifier
        case driftStatusSummary
        case statusSummary
        case targetIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let controlIdentifier = self.controlIdentifier {
            try encodeContainer.encode(controlIdentifier, forKey: .controlIdentifier)
        }
        if let driftStatusSummary = self.driftStatusSummary {
            try encodeContainer.encode(driftStatusSummary, forKey: .driftStatusSummary)
        }
        if let statusSummary = self.statusSummary {
            try encodeContainer.encode(statusSummary, forKey: .statusSummary)
        }
        if let targetIdentifier = self.targetIdentifier {
            try encodeContainer.encode(targetIdentifier, forKey: .targetIdentifier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlIdentifier)
        controlIdentifier = controlIdentifierDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let targetIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetIdentifier)
        targetIdentifier = targetIdentifierDecoded
        let statusSummaryDecoded = try containerValues.decodeIfPresent(ControlTowerClientTypes.EnablementStatusSummary.self, forKey: .statusSummary)
        statusSummary = statusSummaryDecoded
        let driftStatusSummaryDecoded = try containerValues.decodeIfPresent(ControlTowerClientTypes.DriftStatusSummary.self, forKey: .driftStatusSummary)
        driftStatusSummary = driftStatusSummaryDecoded
    }
}

extension ControlTowerClientTypes {
    /// A summary of enabled controls.
    public struct EnabledControlSummary: Swift.Equatable {
        /// The ARN of the enabled control.
        public var arn: Swift.String?
        /// The ARN of the control. Only Strongly recommended and Elective controls are permitted, with the exception of the Region deny control. For information on how to find the controlIdentifier, see [the overview page](https://docs.aws.amazon.com/controltower/latest/APIReference/Welcome.html).
        public var controlIdentifier: Swift.String?
        /// The drift status of the enabled control.
        public var driftStatusSummary: ControlTowerClientTypes.DriftStatusSummary?
        ///
        public var statusSummary: ControlTowerClientTypes.EnablementStatusSummary?
        /// The ARN of the organizational unit.
        public var targetIdentifier: Swift.String?

        public init(
            arn: Swift.String? = nil,
            controlIdentifier: Swift.String? = nil,
            driftStatusSummary: ControlTowerClientTypes.DriftStatusSummary? = nil,
            statusSummary: ControlTowerClientTypes.EnablementStatusSummary? = nil,
            targetIdentifier: Swift.String? = nil
        )
        {
            self.arn = arn
            self.controlIdentifier = controlIdentifier
            self.driftStatusSummary = driftStatusSummary
            self.statusSummary = statusSummary
            self.targetIdentifier = targetIdentifier
        }
    }

}

extension ControlTowerClientTypes {
    public enum EnablementStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case succeeded
        case underChange
        case sdkUnknown(Swift.String)

        public static var allCases: [EnablementStatus] {
            return [
                .failed,
                .succeeded,
                .underChange,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .succeeded: return "SUCCEEDED"
            case .underChange: return "UNDER_CHANGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EnablementStatus(rawValue: rawValue) ?? EnablementStatus.sdkUnknown(rawValue)
        }
    }
}

extension ControlTowerClientTypes.EnablementStatusSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastOperationIdentifier
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastOperationIdentifier = self.lastOperationIdentifier {
            try encodeContainer.encode(lastOperationIdentifier, forKey: .lastOperationIdentifier)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ControlTowerClientTypes.EnablementStatus.self, forKey: .status)
        status = statusDecoded
        let lastOperationIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastOperationIdentifier)
        lastOperationIdentifier = lastOperationIdentifierDecoded
    }
}

extension ControlTowerClientTypes {
    /// The deployment summary of the enabled control.
    public struct EnablementStatusSummary: Swift.Equatable {
        /// The last operation identifier for the enabled control.
        public var lastOperationIdentifier: Swift.String?
        /// The deployment status of the enabled control. Valid values:
        ///
        /// * SUCCEEDED: The enabledControl configuration was deployed successfully.
        ///
        /// * UNDER_CHANGE: The enabledControl configuration is changing.
        ///
        /// * FAILED: The enabledControl configuration failed to deploy.
        public var status: ControlTowerClientTypes.EnablementStatus?

        public init(
            lastOperationIdentifier: Swift.String? = nil,
            status: ControlTowerClientTypes.EnablementStatus? = nil
        )
        {
            self.lastOperationIdentifier = lastOperationIdentifier
            self.status = status
        }
    }

}

extension GetControlOperationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operationIdentifier = self.operationIdentifier {
            try encodeContainer.encode(operationIdentifier, forKey: .operationIdentifier)
        }
    }
}

extension GetControlOperationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/get-control-operation"
    }
}

public struct GetControlOperationInput: Swift.Equatable {
    /// The ID of the asynchronous operation, which is used to track status. The operation is available for 90 days.
    /// This member is required.
    public var operationIdentifier: Swift.String?

    public init(
        operationIdentifier: Swift.String? = nil
    )
    {
        self.operationIdentifier = operationIdentifier
    }
}

struct GetControlOperationInputBody: Swift.Equatable {
    let operationIdentifier: Swift.String?
}

extension GetControlOperationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationIdentifier)
        operationIdentifier = operationIdentifierDecoded
    }
}

extension GetControlOperationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetControlOperationOutputBody = try responseDecoder.decode(responseBody: data)
            self.controlOperation = output.controlOperation
        } else {
            self.controlOperation = nil
        }
    }
}

public struct GetControlOperationOutput: Swift.Equatable {
    /// An operation performed by the control.
    /// This member is required.
    public var controlOperation: ControlTowerClientTypes.ControlOperation?

    public init(
        controlOperation: ControlTowerClientTypes.ControlOperation? = nil
    )
    {
        self.controlOperation = controlOperation
    }
}

struct GetControlOperationOutputBody: Swift.Equatable {
    let controlOperation: ControlTowerClientTypes.ControlOperation?
}

extension GetControlOperationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlOperation
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlOperationDecoded = try containerValues.decodeIfPresent(ControlTowerClientTypes.ControlOperation.self, forKey: .controlOperation)
        controlOperation = controlOperationDecoded
    }
}

enum GetControlOperationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEnabledControlInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabledControlIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabledControlIdentifier = self.enabledControlIdentifier {
            try encodeContainer.encode(enabledControlIdentifier, forKey: .enabledControlIdentifier)
        }
    }
}

extension GetEnabledControlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/get-enabled-control"
    }
}

public struct GetEnabledControlInput: Swift.Equatable {
    /// The ARN of the enabled control.
    /// This member is required.
    public var enabledControlIdentifier: Swift.String?

    public init(
        enabledControlIdentifier: Swift.String? = nil
    )
    {
        self.enabledControlIdentifier = enabledControlIdentifier
    }
}

struct GetEnabledControlInputBody: Swift.Equatable {
    let enabledControlIdentifier: Swift.String?
}

extension GetEnabledControlInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabledControlIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledControlIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .enabledControlIdentifier)
        enabledControlIdentifier = enabledControlIdentifierDecoded
    }
}

extension GetEnabledControlOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEnabledControlOutputBody = try responseDecoder.decode(responseBody: data)
            self.enabledControlDetails = output.enabledControlDetails
        } else {
            self.enabledControlDetails = nil
        }
    }
}

public struct GetEnabledControlOutput: Swift.Equatable {
    /// Information about the enabled control.
    /// This member is required.
    public var enabledControlDetails: ControlTowerClientTypes.EnabledControlDetails?

    public init(
        enabledControlDetails: ControlTowerClientTypes.EnabledControlDetails? = nil
    )
    {
        self.enabledControlDetails = enabledControlDetails
    }
}

struct GetEnabledControlOutputBody: Swift.Equatable {
    let enabledControlDetails: ControlTowerClientTypes.EnabledControlDetails?
}

extension GetEnabledControlOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabledControlDetails
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledControlDetailsDecoded = try containerValues.decodeIfPresent(ControlTowerClientTypes.EnabledControlDetails.self, forKey: .enabledControlDetails)
        enabledControlDetails = enabledControlDetailsDecoded
    }
}

enum GetEnabledControlOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Unexpected error during processing of request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListEnabledControlsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case targetIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let targetIdentifier = self.targetIdentifier {
            try encodeContainer.encode(targetIdentifier, forKey: .targetIdentifier)
        }
    }
}

extension ListEnabledControlsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-enabled-controls"
    }
}

public struct ListEnabledControlsInput: Swift.Equatable {
    /// How many results to return per API call.
    public var maxResults: Swift.Int?
    /// The token to continue the list from a previous API call with the same parameters.
    public var nextToken: Swift.String?
    /// The ARN of the organizational unit. For information on how to find the targetIdentifier, see [the overview page](https://docs.aws.amazon.com/controltower/latest/APIReference/Welcome.html).
    /// This member is required.
    public var targetIdentifier: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        targetIdentifier: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.targetIdentifier = targetIdentifier
    }
}

struct ListEnabledControlsInputBody: Swift.Equatable {
    let targetIdentifier: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListEnabledControlsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case targetIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetIdentifier)
        targetIdentifier = targetIdentifierDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEnabledControlsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEnabledControlsOutputBody = try responseDecoder.decode(responseBody: data)
            self.enabledControls = output.enabledControls
            self.nextToken = output.nextToken
        } else {
            self.enabledControls = nil
            self.nextToken = nil
        }
    }
}

public struct ListEnabledControlsOutput: Swift.Equatable {
    /// Lists the controls enabled by AWS Control Tower on the specified organizational unit and the accounts it contains.
    /// This member is required.
    public var enabledControls: [ControlTowerClientTypes.EnabledControlSummary]?
    /// Retrieves the next page of results. If the string is empty, the current response is the end of the results.
    public var nextToken: Swift.String?

    public init(
        enabledControls: [ControlTowerClientTypes.EnabledControlSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.enabledControls = enabledControls
        self.nextToken = nextToken
    }
}

struct ListEnabledControlsOutputBody: Swift.Equatable {
    let enabledControls: [ControlTowerClientTypes.EnabledControlSummary]?
    let nextToken: Swift.String?
}

extension ListEnabledControlsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabledControls
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledControlsContainer = try containerValues.decodeIfPresent([ControlTowerClientTypes.EnabledControlSummary?].self, forKey: .enabledControls)
        var enabledControlsDecoded0:[ControlTowerClientTypes.EnabledControlSummary]? = nil
        if let enabledControlsContainer = enabledControlsContainer {
            enabledControlsDecoded0 = [ControlTowerClientTypes.EnabledControlSummary]()
            for structure0 in enabledControlsContainer {
                if let structure0 = structure0 {
                    enabledControlsDecoded0?.append(structure0)
                }
            }
        }
        enabledControls = enabledControlsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEnabledControlsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ControlTowerClientTypes.Region: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ControlTowerClientTypes {
    /// An AWS Region in which AWS Control Tower expects to find the control deployed. The expected Regions are based on the Regions that are governed by the landing zone. In certain cases, a control is not actually enabled in the Region as expected, such as during drift, or [mixed governance](https://docs.aws.amazon.com/controltower/latest/userguide/region-how.html#mixed-governance).
    public struct Region: Swift.Equatable {
        /// The AWS Region name.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Request references a resource which does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Request would cause a service quota to be exceeded. The limit is 10 concurrent operations.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the service quota that was exceeded.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The number of seconds the caller should wait before retrying.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
        /// The ID of the service that is associated with the error.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input fails to satisfy the constraints specified by an AWS service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
