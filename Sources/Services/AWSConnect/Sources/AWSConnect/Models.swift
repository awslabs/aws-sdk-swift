//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.listWritingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

public struct AssociateApprovedOriginOutput {

    public init() { }
}

public struct AssociateBotOutput {

    public init() { }
}

public struct AssociateLambdaFunctionOutput {

    public init() { }
}

public struct AssociateLexBotOutput {

    public init() { }
}

public struct AssociatePhoneNumberContactFlowOutput {

    public init() { }
}

public struct AssociateQueueQuickConnectsOutput {

    public init() { }
}

public struct AssociateRoutingProfileQueuesOutput {

    public init() { }
}

public struct AssociateUserProficienciesOutput {

    public init() { }
}

public struct CreatePredefinedAttributeOutput {

    public init() { }
}

public struct DeleteContactEvaluationOutput {

    public init() { }
}

public struct DeleteEvaluationFormOutput {

    public init() { }
}

public struct DeleteHoursOfOperationOutput {

    public init() { }
}

public struct DeleteInstanceOutput {

    public init() { }
}

public struct DeleteIntegrationAssociationOutput {

    public init() { }
}

public struct DeletePredefinedAttributeOutput {

    public init() { }
}

public struct DeletePromptOutput {

    public init() { }
}

public struct DeleteQueueOutput {

    public init() { }
}

public struct DeleteQuickConnectOutput {

    public init() { }
}

public struct DeleteRoutingProfileOutput {

    public init() { }
}

public struct DeleteRuleOutput {

    public init() { }
}

public struct DeleteSecurityProfileOutput {

    public init() { }
}

public struct DeleteUseCaseOutput {

    public init() { }
}

public struct DeleteUserHierarchyGroupOutput {

    public init() { }
}

public struct DeleteUserOutput {

    public init() { }
}

public struct DisassociateAnalyticsDataSetOutput {

    public init() { }
}

public struct DisassociateApprovedOriginOutput {

    public init() { }
}

public struct DisassociateBotOutput {

    public init() { }
}

public struct DisassociateInstanceStorageConfigOutput {

    public init() { }
}

public struct DisassociateLambdaFunctionOutput {

    public init() { }
}

public struct DisassociateLexBotOutput {

    public init() { }
}

public struct DisassociatePhoneNumberContactFlowOutput {

    public init() { }
}

public struct DisassociateQueueQuickConnectsOutput {

    public init() { }
}

public struct DisassociateRoutingProfileQueuesOutput {

    public init() { }
}

public struct DisassociateSecurityKeyOutput {

    public init() { }
}

public struct DisassociateUserProficienciesOutput {

    public init() { }
}

public struct ReleasePhoneNumberOutput {

    public init() { }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceOutput {

    public init() { }
}

public struct UpdateAgentStatusOutput {

    public init() { }
}

public struct UpdateAuthenticationProfileOutput {

    public init() { }
}

public struct UpdateHoursOfOperationOutput {

    public init() { }
}

public struct UpdateInstanceAttributeOutput {

    public init() { }
}

public struct UpdateInstanceStorageConfigOutput {

    public init() { }
}

public struct UpdatePhoneNumberMetadataOutput {

    public init() { }
}

public struct UpdatePredefinedAttributeOutput {

    public init() { }
}

public struct UpdateQueueHoursOfOperationOutput {

    public init() { }
}

public struct UpdateQueueMaxContactsOutput {

    public init() { }
}

public struct UpdateQueueNameOutput {

    public init() { }
}

public struct UpdateQueueOutboundCallerConfigOutput {

    public init() { }
}

public struct UpdateQueueStatusOutput {

    public init() { }
}

public struct UpdateQuickConnectConfigOutput {

    public init() { }
}

public struct UpdateQuickConnectNameOutput {

    public init() { }
}

public struct UpdateRoutingProfileAgentAvailabilityTimerOutput {

    public init() { }
}

public struct UpdateRoutingProfileConcurrencyOutput {

    public init() { }
}

public struct UpdateRoutingProfileDefaultOutboundQueueOutput {

    public init() { }
}

public struct UpdateRoutingProfileNameOutput {

    public init() { }
}

public struct UpdateRoutingProfileQueuesOutput {

    public init() { }
}

public struct UpdateRuleOutput {

    public init() { }
}

public struct UpdateSecurityProfileOutput {

    public init() { }
}

public struct UpdateUserHierarchyGroupNameOutput {

    public init() { }
}

public struct UpdateUserHierarchyOutput {

    public init() { }
}

public struct UpdateUserHierarchyStructureOutput {

    public init() { }
}

public struct UpdateUserIdentityInfoOutput {

    public init() { }
}

public struct UpdateUserPhoneConfigOutput {

    public init() { }
}

public struct UpdateUserProficienciesOutput {

    public init() { }
}

public struct UpdateUserRoutingProfileOutput {

    public init() { }
}

public struct UpdateUserSecurityProfilesOutput {

    public init() { }
}

/// You do not have sufficient permissions to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ConnectClientTypes {

    public enum ActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case assignContactCategory
        case createCase
        case createTask
        case endAssociatedTasks
        case generateEventbridgeEvent
        case sendNotification
        case submitAutoEvaluation
        case updateCase
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionType] {
            return [
                .assignContactCategory,
                .createCase,
                .createTask,
                .endAssociatedTasks,
                .generateEventbridgeEvent,
                .sendNotification,
                .submitAutoEvaluation,
                .updateCase
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .assignContactCategory: return "ASSIGN_CONTACT_CATEGORY"
            case .createCase: return "CREATE_CASE"
            case .createTask: return "CREATE_TASK"
            case .endAssociatedTasks: return "END_ASSOCIATED_TASKS"
            case .generateEventbridgeEvent: return "GENERATE_EVENTBRIDGE_EVENT"
            case .sendNotification: return "SEND_NOTIFICATION"
            case .submitAutoEvaluation: return "SUBMIT_AUTO_EVALUATION"
            case .updateCase: return "UPDATE_CASE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// Information about an action.
    public struct ActionSummary {
        /// The action type.
        /// This member is required.
        public var actionType: ConnectClientTypes.ActionType?

        public init(
            actionType: ConnectClientTypes.ActionType? = nil
        )
        {
            self.actionType = actionType
        }
    }

}

/// Request processing failed because of an error or failure with the service.
public struct InternalServiceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServiceException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// One or more of the specified parameters are not valid.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message about the parameters.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A resource already has that name.
public struct ResourceConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message about the resource.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The throttling limit has been exceeded.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct ActivateEvaluationFormInput {
    /// The unique identifier for the evaluation form.
    /// This member is required.
    public var evaluationFormId: Swift.String?
    /// The version of the evaluation form to activate. If the version property is not provided, the latest version of the evaluation form is activated.
    /// This member is required.
    public var evaluationFormVersion: Swift.Int?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        evaluationFormId: Swift.String? = nil,
        evaluationFormVersion: Swift.Int? = 0,
        instanceId: Swift.String? = nil
    )
    {
        self.evaluationFormId = evaluationFormId
        self.evaluationFormVersion = evaluationFormVersion
        self.instanceId = instanceId
    }
}

public struct ActivateEvaluationFormOutput {
    /// The Amazon Resource Name (ARN) for the evaluation form resource.
    /// This member is required.
    public var evaluationFormArn: Swift.String?
    /// The unique identifier for the evaluation form.
    /// This member is required.
    public var evaluationFormId: Swift.String?
    /// A version of the evaluation form.
    /// This member is required.
    public var evaluationFormVersion: Swift.Int

    public init(
        evaluationFormArn: Swift.String? = nil,
        evaluationFormId: Swift.String? = nil,
        evaluationFormVersion: Swift.Int = 0
    )
    {
        self.evaluationFormArn = evaluationFormArn
        self.evaluationFormId = evaluationFormId
        self.evaluationFormVersion = evaluationFormVersion
    }
}

extension ConnectClientTypes {

    public enum AgentAvailabilityTimer: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case timeSinceLastActivity
        case timeSinceLastInbound
        case sdkUnknown(Swift.String)

        public static var allCases: [AgentAvailabilityTimer] {
            return [
                .timeSinceLastActivity,
                .timeSinceLastInbound
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .timeSinceLastActivity: return "TIME_SINCE_LAST_ACTIVITY"
            case .timeSinceLastInbound: return "TIME_SINCE_LAST_INBOUND"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// Information about a traffic distribution.
    public struct Distribution {
        /// The percentage of the traffic that is distributed, in increments of 10.
        /// This member is required.
        public var percentage: Swift.Int
        /// The Amazon Web Services Region where the traffic is distributed.
        /// This member is required.
        public var region: Swift.String?

        public init(
            percentage: Swift.Int = 0,
            region: Swift.String? = nil
        )
        {
            self.percentage = percentage
            self.region = region
        }
    }

}

extension ConnectClientTypes {
    /// The distribution of agents between the instance and its replica(s).
    public struct AgentConfig {
        /// Information about traffic distributions.
        /// This member is required.
        public var distributions: [ConnectClientTypes.Distribution]?

        public init(
            distributions: [ConnectClientTypes.Distribution]? = nil
        )
        {
            self.distributions = distributions
        }
    }

}

extension ConnectClientTypes {

    public enum ContactState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case connected
        case connectedOnhold
        case connecting
        case ended
        case error
        case incoming
        case missed
        case pending
        case rejected
        case sdkUnknown(Swift.String)

        public static var allCases: [ContactState] {
            return [
                .connected,
                .connectedOnhold,
                .connecting,
                .ended,
                .error,
                .incoming,
                .missed,
                .pending,
                .rejected
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .connected: return "CONNECTED"
            case .connectedOnhold: return "CONNECTED_ONHOLD"
            case .connecting: return "CONNECTING"
            case .ended: return "ENDED"
            case .error: return "ERROR"
            case .incoming: return "INCOMING"
            case .missed: return "MISSED"
            case .pending: return "PENDING"
            case .rejected: return "REJECTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {

    public enum Channel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case chat
        case task
        case voice
        case sdkUnknown(Swift.String)

        public static var allCases: [Channel] {
            return [
                .chat,
                .task,
                .voice
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .chat: return "CHAT"
            case .task: return "TASK"
            case .voice: return "VOICE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {

    public enum ContactInitiationMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case api
        case callback
        case disconnect
        case externalOutbound
        case inbound
        case monitor
        case outbound
        case queueTransfer
        case transfer
        case sdkUnknown(Swift.String)

        public static var allCases: [ContactInitiationMethod] {
            return [
                .api,
                .callback,
                .disconnect,
                .externalOutbound,
                .inbound,
                .monitor,
                .outbound,
                .queueTransfer,
                .transfer
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .api: return "API"
            case .callback: return "CALLBACK"
            case .disconnect: return "DISCONNECT"
            case .externalOutbound: return "EXTERNAL_OUTBOUND"
            case .inbound: return "INBOUND"
            case .monitor: return "MONITOR"
            case .outbound: return "OUTBOUND"
            case .queueTransfer: return "QUEUE_TRANSFER"
            case .transfer: return "TRANSFER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// Contains information about a queue resource for which metrics are returned.
    public struct QueueReference {
        /// The Amazon Resource Name (ARN) of the queue.
        public var arn: Swift.String?
        /// The identifier of the queue.
        public var id: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
        }
    }

}

extension ConnectClientTypes {
    /// Information about the [contact](https://docs.aws.amazon.com/connect/latest/APIReference/API_Contact.html) associated to the user.
    public struct AgentContactReference {
        /// The [state of the contact](https://docs.aws.amazon.com/connect/latest/adminguide/about-contact-states.html). When AgentContactState is set to CONNECTED_ONHOLD, StateStartTimestamp is not changed. Instead, StateStartTimestamp reflects the time the contact was CONNECTED to the agent.
        public var agentContactState: ConnectClientTypes.ContactState?
        /// The channel of the contact.
        public var channel: ConnectClientTypes.Channel?
        /// The time at which the contact was connected to an agent.
        public var connectedToAgentTimestamp: Foundation.Date?
        /// The identifier of the contact in this instance of Amazon Connect.
        public var contactId: Swift.String?
        /// How the contact was initiated.
        public var initiationMethod: ConnectClientTypes.ContactInitiationMethod?
        /// Contains information about a queue resource for which metrics are returned.
        public var queue: ConnectClientTypes.QueueReference?
        /// The epoch timestamp when the contact state started.
        public var stateStartTimestamp: Foundation.Date?

        public init(
            agentContactState: ConnectClientTypes.ContactState? = nil,
            channel: ConnectClientTypes.Channel? = nil,
            connectedToAgentTimestamp: Foundation.Date? = nil,
            contactId: Swift.String? = nil,
            initiationMethod: ConnectClientTypes.ContactInitiationMethod? = nil,
            queue: ConnectClientTypes.QueueReference? = nil,
            stateStartTimestamp: Foundation.Date? = nil
        )
        {
            self.agentContactState = agentContactState
            self.channel = channel
            self.connectedToAgentTimestamp = connectedToAgentTimestamp
            self.contactId = contactId
            self.initiationMethod = initiationMethod
            self.queue = queue
            self.stateStartTimestamp = stateStartTimestamp
        }
    }

}

extension ConnectClientTypes {
    /// Information about an agent hierarchy group.
    public struct AgentHierarchyGroup {
        /// The Amazon Resource Name (ARN) of the group.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension ConnectClientTypes {
    /// A structure that defines search criteria for contacts using agent hierarchy group levels. For more information about agent hierarchies, see [Set Up Agent Hierarchies](https://docs.aws.amazon.com/connect/latest/adminguide/agent-hierarchy.html) in the Amazon Connect Administrator Guide.
    public struct AgentHierarchyGroups {
        /// The identifiers for level 1 hierarchy groups.
        public var l1Ids: [Swift.String]?
        /// The identifiers for level 2 hierarchy groups.
        public var l2Ids: [Swift.String]?
        /// The identifiers for level 3 hierarchy groups.
        public var l3Ids: [Swift.String]?
        /// The identifiers for level 4 hierarchy groups.
        public var l4Ids: [Swift.String]?
        /// The identifiers for level 5 hierarchy groups.
        public var l5Ids: [Swift.String]?

        public init(
            l1Ids: [Swift.String]? = nil,
            l2Ids: [Swift.String]? = nil,
            l3Ids: [Swift.String]? = nil,
            l4Ids: [Swift.String]? = nil,
            l5Ids: [Swift.String]? = nil
        )
        {
            self.l1Ids = l1Ids
            self.l2Ids = l2Ids
            self.l3Ids = l3Ids
            self.l4Ids = l4Ids
            self.l5Ids = l5Ids
        }
    }

}

extension ConnectClientTypes {

    public enum VideoCapability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case send
        case sdkUnknown(Swift.String)

        public static var allCases: [VideoCapability] {
            return [
                .send
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .send: return "SEND"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// The configuration for the allowed capabilities for participants present over the call.
    public struct ParticipantCapabilities {
        /// The configuration having the video sharing capabilities for participants over the call.
        public var video: ConnectClientTypes.VideoCapability?

        public init(
            video: ConnectClientTypes.VideoCapability? = nil
        )
        {
            self.video = video
        }
    }

}

extension ConnectClientTypes {
    /// Information regarding the device.
    public struct DeviceInfo {
        /// Operating system that the participant used for the call.
        public var operatingSystem: Swift.String?
        /// Name of the platform that the participant used for the call.
        public var platformName: Swift.String?
        /// Version of the platform that the participant used for the call.
        public var platformVersion: Swift.String?

        public init(
            operatingSystem: Swift.String? = nil,
            platformName: Swift.String? = nil,
            platformVersion: Swift.String? = nil
        )
        {
            self.operatingSystem = operatingSystem
            self.platformName = platformName
            self.platformVersion = platformVersion
        }
    }

}

extension ConnectClientTypes {
    /// Information about the agent hierarchy. Hierarchies can be configured with up to five levels.
    public struct HierarchyGroups {
        /// The group at level one of the agent hierarchy.
        public var level1: ConnectClientTypes.AgentHierarchyGroup?
        /// The group at level two of the agent hierarchy.
        public var level2: ConnectClientTypes.AgentHierarchyGroup?
        /// The group at level three of the agent hierarchy.
        public var level3: ConnectClientTypes.AgentHierarchyGroup?
        /// The group at level four of the agent hierarchy.
        public var level4: ConnectClientTypes.AgentHierarchyGroup?
        /// The group at level five of the agent hierarchy.
        public var level5: ConnectClientTypes.AgentHierarchyGroup?

        public init(
            level1: ConnectClientTypes.AgentHierarchyGroup? = nil,
            level2: ConnectClientTypes.AgentHierarchyGroup? = nil,
            level3: ConnectClientTypes.AgentHierarchyGroup? = nil,
            level4: ConnectClientTypes.AgentHierarchyGroup? = nil,
            level5: ConnectClientTypes.AgentHierarchyGroup? = nil
        )
        {
            self.level1 = level1
            self.level2 = level2
            self.level3 = level3
            self.level4 = level4
            self.level5 = level5
        }
    }

}

extension ConnectClientTypes {
    /// Information about the agent who accepted the contact.
    public struct AgentInfo {
        /// Agent pause duration for a contact in seconds.
        public var agentPauseDurationInSeconds: Swift.Int?
        /// The configuration for the allowed capabilities for participants present over the call.
        public var capabilities: ConnectClientTypes.ParticipantCapabilities?
        /// The timestamp when the contact was connected to the agent.
        public var connectedToAgentTimestamp: Foundation.Date?
        /// Information regarding Agent’s device.
        public var deviceInfo: ConnectClientTypes.DeviceInfo?
        /// The agent hierarchy groups for the agent.
        public var hierarchyGroups: ConnectClientTypes.HierarchyGroups?
        /// The identifier of the agent who accepted the contact.
        public var id: Swift.String?

        public init(
            agentPauseDurationInSeconds: Swift.Int? = nil,
            capabilities: ConnectClientTypes.ParticipantCapabilities? = nil,
            connectedToAgentTimestamp: Foundation.Date? = nil,
            deviceInfo: ConnectClientTypes.DeviceInfo? = nil,
            hierarchyGroups: ConnectClientTypes.HierarchyGroups? = nil,
            id: Swift.String? = nil
        )
        {
            self.agentPauseDurationInSeconds = agentPauseDurationInSeconds
            self.capabilities = capabilities
            self.connectedToAgentTimestamp = connectedToAgentTimestamp
            self.deviceInfo = deviceInfo
            self.hierarchyGroups = hierarchyGroups
            self.id = id
        }
    }

}

extension ConnectClientTypes {
    /// Contains information for score and potential quality issues for Audio
    public struct AudioQualityMetricsInfo {
        /// List of potential issues causing degradation of quality on a media connection. If the service did not detect any potential quality issues the list is empty. Valid values: HighPacketLoss | HighRoundTripTime | HighJitterBuffer
        public var potentialQualityIssues: [Swift.String]?
        /// Number measuring the estimated quality of the media connection.
        public var qualityScore: Swift.Float

        public init(
            potentialQualityIssues: [Swift.String]? = nil,
            qualityScore: Swift.Float = 0.0
        )
        {
            self.potentialQualityIssues = potentialQualityIssues
            self.qualityScore = qualityScore
        }
    }

}

extension ConnectClientTypes {
    /// Information about the quality of the Agent's media connection
    public struct AgentQualityMetrics {
        /// Information about the audio quality of the Agent
        public var audio: ConnectClientTypes.AudioQualityMetricsInfo?

        public init(
            audio: ConnectClientTypes.AudioQualityMetricsInfo? = nil
        )
        {
            self.audio = audio
        }
    }

}

extension ConnectClientTypes {
    /// Can be used to define a list of preferred agents to target the contact to within the queue.  Note that agents must have the queue in their routing profile in order to be offered the  contact.
    public struct AgentsCriteria {
        /// An object to specify a list of agents, by user ID.
        public var agentIds: [Swift.String]?

        public init(
            agentIds: [Swift.String]? = nil
        )
        {
            self.agentIds = agentIds
        }
    }

}

extension ConnectClientTypes {

    public enum AgentStatusState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AgentStatusState] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {

    public enum AgentStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case custom
        case offline
        case routable
        case sdkUnknown(Swift.String)

        public static var allCases: [AgentStatusType] {
            return [
                .custom,
                .offline,
                .routable
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .custom: return "CUSTOM"
            case .offline: return "OFFLINE"
            case .routable: return "ROUTABLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// Contains information about an agent status.
    public struct AgentStatus {
        /// The Amazon Resource Name (ARN) of the agent status.
        public var agentStatusARN: Swift.String?
        /// The identifier of the agent status.
        public var agentStatusId: Swift.String?
        /// The description of the agent status.
        public var description: Swift.String?
        /// The display order of the agent status.
        public var displayOrder: Swift.Int?
        /// The Amazon Web Services Region where this resource was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when this resource was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// The name of the agent status.
        public var name: Swift.String?
        /// The state of the agent status.
        public var state: ConnectClientTypes.AgentStatusState?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public var tags: [Swift.String: Swift.String]?
        /// The type of agent status.
        public var type: ConnectClientTypes.AgentStatusType?

        public init(
            agentStatusARN: Swift.String? = nil,
            agentStatusId: Swift.String? = nil,
            description: Swift.String? = nil,
            displayOrder: Swift.Int? = nil,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            state: ConnectClientTypes.AgentStatusState? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            type: ConnectClientTypes.AgentStatusType? = nil
        )
        {
            self.agentStatusARN = agentStatusARN
            self.agentStatusId = agentStatusId
            self.description = description
            self.displayOrder = displayOrder
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.state = state
            self.tags = tags
            self.type = type
        }
    }

}

extension ConnectClientTypes {
    /// Information about the agent's status.
    public struct AgentStatusReference {
        /// The Amazon Resource Name (ARN) of the agent's status.
        public var statusArn: Swift.String?
        /// The name of the agent status.
        public var statusName: Swift.String?
        /// The start timestamp of the agent's status.
        public var statusStartTimestamp: Foundation.Date?

        public init(
            statusArn: Swift.String? = nil,
            statusName: Swift.String? = nil,
            statusStartTimestamp: Foundation.Date? = nil
        )
        {
            self.statusArn = statusArn
            self.statusName = statusName
            self.statusStartTimestamp = statusStartTimestamp
        }
    }

}

extension ConnectClientTypes {

    public enum StringComparisonType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case contains
        case exact
        case startsWith
        case sdkUnknown(Swift.String)

        public static var allCases: [StringComparisonType] {
            return [
                .contains,
                .exact,
                .startsWith
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contains: return "CONTAINS"
            case .exact: return "EXACT"
            case .startsWith: return "STARTS_WITH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// A leaf node condition which can be used to specify a string condition.
    public struct StringCondition {
        /// The type of comparison to be made when evaluating the string condition.
        public var comparisonType: ConnectClientTypes.StringComparisonType?
        /// The name of the field in the string condition.
        public var fieldName: Swift.String?
        /// The value of the string.
        public var value: Swift.String?

        public init(
            comparisonType: ConnectClientTypes.StringComparisonType? = nil,
            fieldName: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.comparisonType = comparisonType
            self.fieldName = fieldName
            self.value = value
        }
    }

}

extension ConnectClientTypes {
    /// A leaf node condition which can be used to specify a tag condition, for example, HAVE BPO = 123.
    public struct TagCondition {
        /// The tag key in the tag condition.
        public var tagKey: Swift.String?
        /// The tag value in the tag condition.
        public var tagValue: Swift.String?

        public init(
            tagKey: Swift.String? = nil,
            tagValue: Swift.String? = nil
        )
        {
            self.tagKey = tagKey
            self.tagValue = tagValue
        }
    }

}

extension ConnectClientTypes {
    /// A list of conditions which would be applied together with an AND condition.
    public struct CommonAttributeAndCondition {
        /// A leaf node condition which can be used to specify a tag condition.
        public var tagConditions: [ConnectClientTypes.TagCondition]?

        public init(
            tagConditions: [ConnectClientTypes.TagCondition]? = nil
        )
        {
            self.tagConditions = tagConditions
        }
    }

}

extension ConnectClientTypes {
    /// An object that can be used to specify Tag conditions inside the SearchFilter. This accepts an OR or AND (List of List) input where:
    ///
    /// * The top level list specifies conditions that need to be applied with OR operator.
    ///
    /// * The inner list specifies conditions that need to be applied with AND operator.
    public struct ControlPlaneAttributeFilter {
        /// A list of conditions which would be applied together with an AND condition.
        public var andCondition: ConnectClientTypes.CommonAttributeAndCondition?
        /// A list of conditions which would be applied together with an OR condition.
        public var orConditions: [ConnectClientTypes.CommonAttributeAndCondition]?
        /// A leaf node condition which can be used to specify a tag condition, for example, HAVE BPO = 123.
        public var tagCondition: ConnectClientTypes.TagCondition?

        public init(
            andCondition: ConnectClientTypes.CommonAttributeAndCondition? = nil,
            orConditions: [ConnectClientTypes.CommonAttributeAndCondition]? = nil,
            tagCondition: ConnectClientTypes.TagCondition? = nil
        )
        {
            self.andCondition = andCondition
            self.orConditions = orConditions
            self.tagCondition = tagCondition
        }
    }

}

extension ConnectClientTypes {
    /// Filters to be applied to search results.
    public struct AgentStatusSearchFilter {
        /// An object that can be used to specify Tag conditions inside the SearchFilter. This accepts an OR of AND (List of List) input where:
        ///
        /// * The top level list specifies conditions that need to be applied with OR operator.
        ///
        /// * The inner list specifies conditions that need to be applied with AND operator.
        public var attributeFilter: ConnectClientTypes.ControlPlaneAttributeFilter?

        public init(
            attributeFilter: ConnectClientTypes.ControlPlaneAttributeFilter? = nil
        )
        {
            self.attributeFilter = attributeFilter
        }
    }

}

extension ConnectClientTypes {
    /// Summary information for an agent status.
    public struct AgentStatusSummary {
        /// The Amazon Resource Name (ARN) for the agent status.
        public var arn: Swift.String?
        /// The identifier for an agent status.
        public var id: Swift.String?
        /// The Amazon Web Services Region where this resource was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when this resource was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// The name of the agent status.
        public var name: Swift.String?
        /// The type of the agent status.
        public var type: ConnectClientTypes.AgentStatusType?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            type: ConnectClientTypes.AgentStatusType? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.type = type
        }
    }

}

extension ConnectClientTypes {
    /// Information about the capabilities enabled for participants of the contact.
    public struct AllowedCapabilities {
        /// Information about the agent's video sharing capabilities.
        public var agent: ConnectClientTypes.ParticipantCapabilities?
        /// Information about the customer's video sharing capabilities.
        public var customer: ConnectClientTypes.ParticipantCapabilities?

        public init(
            agent: ConnectClientTypes.ParticipantCapabilities? = nil,
            customer: ConnectClientTypes.ParticipantCapabilities? = nil
        )
        {
            self.agent = agent
            self.customer = customer
        }
    }

}

extension ConnectClientTypes {

    public enum MonitorCapability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case barge
        case silentMonitor
        case sdkUnknown(Swift.String)

        public static var allCases: [MonitorCapability] {
            return [
                .barge,
                .silentMonitor
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .barge: return "BARGE"
            case .silentMonitor: return "SILENT_MONITOR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {

    public enum AttachedFileInvalidRequestExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case invalidFileName
        case invalidFileSize
        case invalidFileType
        case sdkUnknown(Swift.String)

        public static var allCases: [AttachedFileInvalidRequestExceptionReason] {
            return [
                .invalidFileName,
                .invalidFileSize,
                .invalidFileType
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .invalidFileName: return "INVALID_FILE_NAME"
            case .invalidFileSize: return "INVALID_FILE_SIZE"
            case .invalidFileType: return "INVALID_FILE_TYPE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// Reason why the request was invalid.
    public enum InvalidRequestExceptionReason {
        /// Reason why the StartAttachedFiledUpload request was invalid.
        case attachedfileinvalidrequestexceptionreason(ConnectClientTypes.AttachedFileInvalidRequestExceptionReason)
        case sdkUnknown(Swift.String)
    }

}

/// The request is not valid.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message about the request.
        public internal(set) var message: Swift.String? = nil
        /// Reason why the request was invalid.
        public internal(set) var reason: ConnectClientTypes.InvalidRequestExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: ConnectClientTypes.InvalidRequestExceptionReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

public struct AssociateAnalyticsDataSetInput {
    /// The identifier of the dataset to associate with the target account.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the target account. Use to associate a dataset to a different account than the one containing the Amazon Connect instance. If not specified, by default this value is the Amazon Web Services account that has the Amazon Connect instance.
    public var targetAccountId: Swift.String?

    public init(
        dataSetId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        targetAccountId: Swift.String? = nil
    )
    {
        self.dataSetId = dataSetId
        self.instanceId = instanceId
        self.targetAccountId = targetAccountId
    }
}

public struct AssociateAnalyticsDataSetOutput {
    /// The identifier of the dataset that was associated.
    public var dataSetId: Swift.String?
    /// The Amazon Resource Name (ARN) of the Resource Access Manager share.
    public var resourceShareArn: Swift.String?
    /// The Resource Access Manager share ID that is generated.
    public var resourceShareId: Swift.String?
    /// The identifier of the target account.
    public var targetAccountId: Swift.String?

    public init(
        dataSetId: Swift.String? = nil,
        resourceShareArn: Swift.String? = nil,
        resourceShareId: Swift.String? = nil,
        targetAccountId: Swift.String? = nil
    )
    {
        self.dataSetId = dataSetId
        self.resourceShareArn = resourceShareArn
        self.resourceShareId = resourceShareId
        self.targetAccountId = targetAccountId
    }
}

/// The service quota has been exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AssociateApprovedOriginInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The domain to add to your allow list.
    /// This member is required.
    public var origin: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        origin: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.origin = origin
    }
}

/// The allowed limit for the resource has been exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message about the limit.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ConnectClientTypes {
    /// Configuration information of an Amazon Lex bot.
    public struct LexBot {
        /// The Amazon Web Services Region where the Amazon Lex bot was created.
        /// This member is required.
        public var lexRegion: Swift.String?
        /// The name of the Amazon Lex bot.
        /// This member is required.
        public var name: Swift.String?

        public init(
            lexRegion: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.lexRegion = lexRegion
            self.name = name
        }
    }

}

extension ConnectClientTypes {
    /// Configuration information of an Amazon Lex V2 bot.
    public struct LexV2Bot {
        /// The Amazon Resource Name (ARN) of the Amazon Lex V2 bot.
        public var aliasArn: Swift.String?

        public init(
            aliasArn: Swift.String? = nil
        )
        {
            self.aliasArn = aliasArn
        }
    }

}

public struct AssociateBotInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Configuration information of an Amazon Lex bot.
    public var lexBot: ConnectClientTypes.LexBot?
    /// The Amazon Lex V2 bot to associate with the instance.
    public var lexV2Bot: ConnectClientTypes.LexV2Bot?

    public init(
        instanceId: Swift.String? = nil,
        lexBot: ConnectClientTypes.LexBot? = nil,
        lexV2Bot: ConnectClientTypes.LexV2Bot? = nil
    )
    {
        self.instanceId = instanceId
        self.lexBot = lexBot
        self.lexV2Bot = lexV2Bot
    }
}

extension ConnectClientTypes {

    public enum VocabularyLanguageCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case arAe
        case caEs
        case daDk
        case deCh
        case deDe
        case enAb
        case enAu
        case enGb
        case enIe
        case enIn
        case enNz
        case enUs
        case enWl
        case enZa
        case esEs
        case esUs
        case fiFi
        case frCa
        case frFr
        case hiIn
        case idId
        case itIt
        case jaJp
        case koKr
        case msMy
        case nlNl
        case noNo
        case plPl
        case ptBr
        case ptPt
        case svSe
        case tlPh
        case zhCn
        case sdkUnknown(Swift.String)

        public static var allCases: [VocabularyLanguageCode] {
            return [
                .arAe,
                .caEs,
                .daDk,
                .deCh,
                .deDe,
                .enAb,
                .enAu,
                .enGb,
                .enIe,
                .enIn,
                .enNz,
                .enUs,
                .enWl,
                .enZa,
                .esEs,
                .esUs,
                .fiFi,
                .frCa,
                .frFr,
                .hiIn,
                .idId,
                .itIt,
                .jaJp,
                .koKr,
                .msMy,
                .nlNl,
                .noNo,
                .plPl,
                .ptBr,
                .ptPt,
                .svSe,
                .tlPh,
                .zhCn
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .arAe: return "ar-AE"
            case .caEs: return "ca-ES"
            case .daDk: return "da-DK"
            case .deCh: return "de-CH"
            case .deDe: return "de-DE"
            case .enAb: return "en-AB"
            case .enAu: return "en-AU"
            case .enGb: return "en-GB"
            case .enIe: return "en-IE"
            case .enIn: return "en-IN"
            case .enNz: return "en-NZ"
            case .enUs: return "en-US"
            case .enWl: return "en-WL"
            case .enZa: return "en-ZA"
            case .esEs: return "es-ES"
            case .esUs: return "es-US"
            case .fiFi: return "fi-FI"
            case .frCa: return "fr-CA"
            case .frFr: return "fr-FR"
            case .hiIn: return "hi-IN"
            case .idId: return "id-ID"
            case .itIt: return "it-IT"
            case .jaJp: return "ja-JP"
            case .koKr: return "ko-KR"
            case .msMy: return "ms-MY"
            case .nlNl: return "nl-NL"
            case .noNo: return "no-NO"
            case .plPl: return "pl-PL"
            case .ptBr: return "pt-BR"
            case .ptPt: return "pt-PT"
            case .svSe: return "sv-SE"
            case .tlPh: return "tl-PH"
            case .zhCn: return "zh-CN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct AssociateDefaultVocabularyInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see [What is Amazon Transcribe?](https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html)
    /// This member is required.
    public var languageCode: ConnectClientTypes.VocabularyLanguageCode?
    /// The identifier of the custom vocabulary. If this is empty, the default is set to none.
    public var vocabularyId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        languageCode: ConnectClientTypes.VocabularyLanguageCode? = nil,
        vocabularyId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.languageCode = languageCode
        self.vocabularyId = vocabularyId
    }
}

public struct AssociateDefaultVocabularyOutput {

    public init() { }
}

extension ConnectClientTypes {

    public enum FlowAssociationResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case smsPhoneNumber
        case sdkUnknown(Swift.String)

        public static var allCases: [FlowAssociationResourceType] {
            return [
                .smsPhoneNumber
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .smsPhoneNumber: return "SMS_PHONE_NUMBER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct AssociateFlowInput {
    /// The identifier of the flow.
    /// This member is required.
    public var flowId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// A valid resource type.
    /// This member is required.
    public var resourceType: ConnectClientTypes.FlowAssociationResourceType?

    public init(
        flowId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: ConnectClientTypes.FlowAssociationResourceType? = nil
    )
    {
        self.flowId = flowId
        self.instanceId = instanceId
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

public struct AssociateFlowOutput {

    public init() { }
}

extension ConnectClientTypes {

    public enum InstanceStorageResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case agentEvents
        case attachments
        case callRecordings
        case chatTranscripts
        case contactEvaluations
        case contactTraceRecords
        case mediaStreams
        case realTimeContactAnalysisChatSegments
        case realTimeContactAnalysisSegments
        case realTimeContactAnalysisVoiceSegments
        case scheduledReports
        case screenRecordings
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceStorageResourceType] {
            return [
                .agentEvents,
                .attachments,
                .callRecordings,
                .chatTranscripts,
                .contactEvaluations,
                .contactTraceRecords,
                .mediaStreams,
                .realTimeContactAnalysisChatSegments,
                .realTimeContactAnalysisSegments,
                .realTimeContactAnalysisVoiceSegments,
                .scheduledReports,
                .screenRecordings
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .agentEvents: return "AGENT_EVENTS"
            case .attachments: return "ATTACHMENTS"
            case .callRecordings: return "CALL_RECORDINGS"
            case .chatTranscripts: return "CHAT_TRANSCRIPTS"
            case .contactEvaluations: return "CONTACT_EVALUATIONS"
            case .contactTraceRecords: return "CONTACT_TRACE_RECORDS"
            case .mediaStreams: return "MEDIA_STREAMS"
            case .realTimeContactAnalysisChatSegments: return "REAL_TIME_CONTACT_ANALYSIS_CHAT_SEGMENTS"
            case .realTimeContactAnalysisSegments: return "REAL_TIME_CONTACT_ANALYSIS_SEGMENTS"
            case .realTimeContactAnalysisVoiceSegments: return "REAL_TIME_CONTACT_ANALYSIS_VOICE_SEGMENTS"
            case .scheduledReports: return "SCHEDULED_REPORTS"
            case .screenRecordings: return "SCREEN_RECORDINGS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// Configuration information of a Kinesis Data Firehose delivery stream.
    public struct KinesisFirehoseConfig {
        /// The Amazon Resource Name (ARN) of the delivery stream.
        /// This member is required.
        public var firehoseArn: Swift.String?

        public init(
            firehoseArn: Swift.String? = nil
        )
        {
            self.firehoseArn = firehoseArn
        }
    }

}

extension ConnectClientTypes {
    /// Configuration information of a Kinesis data stream.
    public struct KinesisStreamConfig {
        /// The Amazon Resource Name (ARN) of the data stream.
        /// This member is required.
        public var streamArn: Swift.String?

        public init(
            streamArn: Swift.String? = nil
        )
        {
            self.streamArn = streamArn
        }
    }

}

extension ConnectClientTypes {

    public enum EncryptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case kms
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionType] {
            return [
                .kms
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .kms: return "KMS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// The encryption configuration.
    public struct EncryptionConfig {
        /// The type of encryption.
        /// This member is required.
        public var encryptionType: ConnectClientTypes.EncryptionType?
        /// The full ARN of the encryption key. Be sure to provide the full ARN of the encryption key, not just the ID. Amazon Connect supports only KMS keys with the default key spec of [SYMMETRIC_DEFAULT](https://docs.aws.amazon.com/kms/latest/developerguide/asymmetric-key-specs.html#key-spec-symmetric-default).
        /// This member is required.
        public var keyId: Swift.String?

        public init(
            encryptionType: ConnectClientTypes.EncryptionType? = nil,
            keyId: Swift.String? = nil
        )
        {
            self.encryptionType = encryptionType
            self.keyId = keyId
        }
    }

}

extension ConnectClientTypes {
    /// Configuration information of a Kinesis video stream.
    public struct KinesisVideoStreamConfig {
        /// The encryption configuration.
        /// This member is required.
        public var encryptionConfig: ConnectClientTypes.EncryptionConfig?
        /// The prefix of the video stream.
        /// This member is required.
        public var `prefix`: Swift.String?
        /// The number of hours data is retained in the stream. Kinesis Video Streams retains the data in a data store that is associated with the stream. The default value is 0, indicating that the stream does not persist data.
        /// This member is required.
        public var retentionPeriodHours: Swift.Int

        public init(
            encryptionConfig: ConnectClientTypes.EncryptionConfig? = nil,
            `prefix`: Swift.String? = nil,
            retentionPeriodHours: Swift.Int = 0
        )
        {
            self.encryptionConfig = encryptionConfig
            self.`prefix` = `prefix`
            self.retentionPeriodHours = retentionPeriodHours
        }
    }

}

extension ConnectClientTypes {
    /// Information about the Amazon Simple Storage Service (Amazon S3) storage type.
    public struct S3Config {
        /// The S3 bucket name.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The S3 bucket prefix.
        /// This member is required.
        public var bucketPrefix: Swift.String?
        /// The Amazon S3 encryption configuration.
        public var encryptionConfig: ConnectClientTypes.EncryptionConfig?

        public init(
            bucketName: Swift.String? = nil,
            bucketPrefix: Swift.String? = nil,
            encryptionConfig: ConnectClientTypes.EncryptionConfig? = nil
        )
        {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.encryptionConfig = encryptionConfig
        }
    }

}

extension ConnectClientTypes {

    public enum StorageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case kinesisFirehose
        case kinesisStream
        case kinesisVideoStream
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageType] {
            return [
                .kinesisFirehose,
                .kinesisStream,
                .kinesisVideoStream,
                .s3
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .kinesisFirehose: return "KINESIS_FIREHOSE"
            case .kinesisStream: return "KINESIS_STREAM"
            case .kinesisVideoStream: return "KINESIS_VIDEO_STREAM"
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// The storage configuration for the instance.
    public struct InstanceStorageConfig {
        /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
        public var associationId: Swift.String?
        /// The configuration of the Kinesis Firehose delivery stream.
        public var kinesisFirehoseConfig: ConnectClientTypes.KinesisFirehoseConfig?
        /// The configuration of the Kinesis data stream.
        public var kinesisStreamConfig: ConnectClientTypes.KinesisStreamConfig?
        /// The configuration of the Kinesis video stream.
        public var kinesisVideoStreamConfig: ConnectClientTypes.KinesisVideoStreamConfig?
        /// The S3 bucket configuration.
        public var s3Config: ConnectClientTypes.S3Config?
        /// A valid storage type.
        /// This member is required.
        public var storageType: ConnectClientTypes.StorageType?

        public init(
            associationId: Swift.String? = nil,
            kinesisFirehoseConfig: ConnectClientTypes.KinesisFirehoseConfig? = nil,
            kinesisStreamConfig: ConnectClientTypes.KinesisStreamConfig? = nil,
            kinesisVideoStreamConfig: ConnectClientTypes.KinesisVideoStreamConfig? = nil,
            s3Config: ConnectClientTypes.S3Config? = nil,
            storageType: ConnectClientTypes.StorageType? = nil
        )
        {
            self.associationId = associationId
            self.kinesisFirehoseConfig = kinesisFirehoseConfig
            self.kinesisStreamConfig = kinesisStreamConfig
            self.kinesisVideoStreamConfig = kinesisVideoStreamConfig
            self.s3Config = s3Config
            self.storageType = storageType
        }
    }

}

public struct AssociateInstanceStorageConfigInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A valid resource type. To [enable streaming for real-time analysis of contacts](https://docs.aws.amazon.com/connect/latest/adminguide/enable-contact-analysis-segment-streams.html), use the following types:
    ///
    /// * For chat contacts, use REAL_TIME_CONTACT_ANALYSIS_CHAT_SEGMENTS.
    ///
    /// * For voice contacts, use REAL_TIME_CONTACT_ANALYSIS_VOICE_SEGMENTS.
    ///
    ///
    /// REAL_TIME_CONTACT_ANALYSIS_SEGMENTS is deprecated, but it is still supported and will apply only to VOICE channel contacts. Use REAL_TIME_CONTACT_ANALYSIS_VOICE_SEGMENTS for voice contacts moving forward. If you have previously associated a stream with REAL_TIME_CONTACT_ANALYSIS_SEGMENTS, no action is needed to update the stream to REAL_TIME_CONTACT_ANALYSIS_VOICE_SEGMENTS.
    /// This member is required.
    public var resourceType: ConnectClientTypes.InstanceStorageResourceType?
    /// A valid storage type.
    /// This member is required.
    public var storageConfig: ConnectClientTypes.InstanceStorageConfig?

    public init(
        instanceId: Swift.String? = nil,
        resourceType: ConnectClientTypes.InstanceStorageResourceType? = nil,
        storageConfig: ConnectClientTypes.InstanceStorageConfig? = nil
    )
    {
        self.instanceId = instanceId
        self.resourceType = resourceType
        self.storageConfig = storageConfig
    }
}

public struct AssociateInstanceStorageConfigOutput {
    /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
    public var associationId: Swift.String?

    public init(
        associationId: Swift.String? = nil
    )
    {
        self.associationId = associationId
    }
}

public struct AssociateLambdaFunctionInput {
    /// The Amazon Resource Name (ARN) for the Lambda function being associated. Maximum number of characters allowed is 140.
    /// This member is required.
    public var functionArn: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        functionArn: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.functionArn = functionArn
        self.instanceId = instanceId
    }
}

public struct AssociateLexBotInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The Amazon Lex bot to associate with the instance.
    /// This member is required.
    public var lexBot: ConnectClientTypes.LexBot?

    public init(
        instanceId: Swift.String? = nil,
        lexBot: ConnectClientTypes.LexBot? = nil
    )
    {
        self.instanceId = instanceId
        self.lexBot = lexBot
    }
}

public struct AssociatePhoneNumberContactFlowInput {
    /// The identifier of the flow.
    /// This member is required.
    public var contactFlowId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A unique identifier for the phone number.
    /// This member is required.
    public var phoneNumberId: Swift.String?

    public init(
        contactFlowId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        phoneNumberId: Swift.String? = nil
    )
    {
        self.contactFlowId = contactFlowId
        self.instanceId = instanceId
        self.phoneNumberId = phoneNumberId
    }
}

public struct AssociateQueueQuickConnectsInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the queue.
    /// This member is required.
    public var queueId: Swift.String?
    /// The quick connects to associate with this queue.
    /// This member is required.
    public var quickConnectIds: [Swift.String]?

    public init(
        instanceId: Swift.String? = nil,
        queueId: Swift.String? = nil,
        quickConnectIds: [Swift.String]? = nil
    )
    {
        self.instanceId = instanceId
        self.queueId = queueId
        self.quickConnectIds = quickConnectIds
    }
}

extension ConnectClientTypes {
    /// Contains the channel and queue identifier for a routing profile.
    public struct RoutingProfileQueueReference {
        /// The channels agents can handle in the Contact Control Panel (CCP) for this routing profile.
        /// This member is required.
        public var channel: ConnectClientTypes.Channel?
        /// The identifier for the queue.
        /// This member is required.
        public var queueId: Swift.String?

        public init(
            channel: ConnectClientTypes.Channel? = nil,
            queueId: Swift.String? = nil
        )
        {
            self.channel = channel
            self.queueId = queueId
        }
    }

}

extension ConnectClientTypes {
    /// Contains information about the queue and channel for which priority and delay can be set.
    public struct RoutingProfileQueueConfig {
        /// The delay, in seconds, a contact should be in the queue before they are routed to an available agent. For more information, see [Queues: priority and delay](https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html) in the Amazon Connect Administrator Guide.
        /// This member is required.
        public var delay: Swift.Int?
        /// The order in which contacts are to be handled for the queue. For more information, see [Queues: priority and delay](https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html).
        /// This member is required.
        public var priority: Swift.Int?
        /// Contains information about a queue resource.
        /// This member is required.
        public var queueReference: ConnectClientTypes.RoutingProfileQueueReference?

        public init(
            delay: Swift.Int? = 0,
            priority: Swift.Int? = nil,
            queueReference: ConnectClientTypes.RoutingProfileQueueReference? = nil
        )
        {
            self.delay = delay
            self.priority = priority
            self.queueReference = queueReference
        }
    }

}

public struct AssociateRoutingProfileQueuesInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The queues to associate with this routing profile.
    /// This member is required.
    public var queueConfigs: [ConnectClientTypes.RoutingProfileQueueConfig]?
    /// The identifier of the routing profile.
    /// This member is required.
    public var routingProfileId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        queueConfigs: [ConnectClientTypes.RoutingProfileQueueConfig]? = nil,
        routingProfileId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.queueConfigs = queueConfigs
        self.routingProfileId = routingProfileId
    }
}

public struct AssociateSecurityKeyInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A valid security key in PEM format as a String.
    /// This member is required.
    public var key: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        key: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.key = key
    }
}

public struct AssociateSecurityKeyOutput {
    /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
    public var associationId: Swift.String?

    public init(
        associationId: Swift.String? = nil
    )
    {
        self.associationId = associationId
    }
}

public struct AssociateTrafficDistributionGroupUserInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.
    /// This member is required.
    public var trafficDistributionGroupId: Swift.String?
    /// The identifier of the user account. This can be the ID or the ARN of the user.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        trafficDistributionGroupId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.trafficDistributionGroupId = trafficDistributionGroupId
        self.userId = userId
    }
}

public struct AssociateTrafficDistributionGroupUserOutput {

    public init() { }
}

extension ConnectClientTypes {
    /// Information about proficiency of a user.
    public struct UserProficiency {
        /// The name of user's proficiency. You must use name of predefined attribute present in the Amazon Connect instance.
        /// This member is required.
        public var attributeName: Swift.String?
        /// The value of user's proficiency. You must use value of predefined attribute present in the Amazon Connect instance.
        /// This member is required.
        public var attributeValue: Swift.String?
        /// The level of the proficiency. The valid values are 1, 2, 3, 4 and 5.
        /// This member is required.
        public var level: Swift.Float?

        public init(
            attributeName: Swift.String? = nil,
            attributeValue: Swift.String? = nil,
            level: Swift.Float? = 1.0
        )
        {
            self.attributeName = attributeName
            self.attributeValue = attributeValue
            self.level = level
        }
    }

}

public struct AssociateUserProficienciesInput {
    /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN of the instance).
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the user account.
    /// This member is required.
    public var userId: Swift.String?
    /// The proficiencies to associate with the user.
    /// This member is required.
    public var userProficiencies: [ConnectClientTypes.UserProficiency]?

    public init(
        instanceId: Swift.String? = nil,
        userId: Swift.String? = nil,
        userProficiencies: [ConnectClientTypes.UserProficiency]? = nil
    )
    {
        self.instanceId = instanceId
        self.userId = userId
        self.userProficiencies = userProficiencies
    }
}

public struct BatchAssociateAnalyticsDataSetInput {
    /// An array of dataset identifiers to associate.
    /// This member is required.
    public var dataSetIds: [Swift.String]?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the target account. Use to associate a dataset to a different account than the one containing the Amazon Connect instance. If not specified, by default this value is the Amazon Web Services account that has the Amazon Connect instance.
    public var targetAccountId: Swift.String?

    public init(
        dataSetIds: [Swift.String]? = nil,
        instanceId: Swift.String? = nil,
        targetAccountId: Swift.String? = nil
    )
    {
        self.dataSetIds = dataSetIds
        self.instanceId = instanceId
        self.targetAccountId = targetAccountId
    }
}

extension ConnectClientTypes {
    /// This API is in preview release for Amazon Connect and is subject to change. Information about associations that are successfully created: DataSetId, TargetAccountId, ResourceShareId, ResourceShareArn.
    public struct AnalyticsDataAssociationResult {
        /// The identifier of the dataset.
        public var dataSetId: Swift.String?
        /// The Amazon Resource Name (ARN) of the Resource Access Manager share.
        public var resourceShareArn: Swift.String?
        /// The Resource Access Manager share ID.
        public var resourceShareId: Swift.String?
        /// The identifier of the target account.
        public var targetAccountId: Swift.String?

        public init(
            dataSetId: Swift.String? = nil,
            resourceShareArn: Swift.String? = nil,
            resourceShareId: Swift.String? = nil,
            targetAccountId: Swift.String? = nil
        )
        {
            self.dataSetId = dataSetId
            self.resourceShareArn = resourceShareArn
            self.resourceShareId = resourceShareId
            self.targetAccountId = targetAccountId
        }
    }

}

extension ConnectClientTypes {
    /// This API is in preview release for Amazon Connect and is subject to change. List of errors for dataset association failures.
    public struct ErrorResult {
        /// The error code.
        public var errorCode: Swift.String?
        /// The corresponding error message for the error code.
        public var errorMessage: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

public struct BatchAssociateAnalyticsDataSetOutput {
    /// Information about associations that are successfully created: DataSetId, TargetAccountId, ResourceShareId, ResourceShareArn.
    public var created: [ConnectClientTypes.AnalyticsDataAssociationResult]?
    /// A list of errors for datasets that aren't successfully associated with the target account.
    public var errors: [ConnectClientTypes.ErrorResult]?

    public init(
        created: [ConnectClientTypes.AnalyticsDataAssociationResult]? = nil,
        errors: [ConnectClientTypes.ErrorResult]? = nil
    )
    {
        self.created = created
        self.errors = errors
    }
}

public struct BatchDisassociateAnalyticsDataSetInput {
    /// An array of associated dataset identifiers to remove.
    /// This member is required.
    public var dataSetIds: [Swift.String]?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the target account. Use to disassociate a dataset from a different account than the one containing the Amazon Connect instance. If not specified, by default this value is the Amazon Web Services account that has the Amazon Connect instance.
    public var targetAccountId: Swift.String?

    public init(
        dataSetIds: [Swift.String]? = nil,
        instanceId: Swift.String? = nil,
        targetAccountId: Swift.String? = nil
    )
    {
        self.dataSetIds = dataSetIds
        self.instanceId = instanceId
        self.targetAccountId = targetAccountId
    }
}

public struct BatchDisassociateAnalyticsDataSetOutput {
    /// An array of successfully disassociated dataset identifiers.
    public var deleted: [Swift.String]?
    /// A list of errors for any datasets not successfully removed.
    public var errors: [ConnectClientTypes.ErrorResult]?

    public init(
        deleted: [Swift.String]? = nil,
        errors: [ConnectClientTypes.ErrorResult]? = nil
    )
    {
        self.deleted = deleted
        self.errors = errors
    }
}

public struct BatchGetAttachedFileMetadataInput {
    /// The resource to which the attached file is (being) uploaded to. [Cases](https://docs.aws.amazon.com/connect/latest/APIReference/API_connect-cases_CreateCase.html) are the only current supported resource. This value must be a valid ARN.
    /// This member is required.
    public var associatedResourceArn: Swift.String?
    /// The unique identifiers of the attached file resource.
    /// This member is required.
    public var fileIds: [Swift.String]?
    /// The unique identifier of the Connect instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        associatedResourceArn: Swift.String? = nil,
        fileIds: [Swift.String]? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.associatedResourceArn = associatedResourceArn
        self.fileIds = fileIds
        self.instanceId = instanceId
    }
}

extension ConnectClientTypes {
    /// Error describing a failure to retrieve attached file metadata through BatchGetAttachedFileMetadata action.
    public struct AttachedFileError {
        /// Status code describing the failure.
        public var errorCode: Swift.String?
        /// Why the attached file couldn't be retrieved.
        public var errorMessage: Swift.String?
        /// The unique identifier of the attached file resource.
        public var fileId: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            fileId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.fileId = fileId
        }
    }

}

extension ConnectClientTypes {
    /// Information on the identity that created the file.
    public enum CreatedByInfo {
        /// An agent ARN representing a [connect user](https://docs.aws.amazon.com/service-authorization/latest/reference/list_amazonconnect.html#amazonconnect-resources-for-iam-policies).
        case connectuserarn(Swift.String)
        /// STS or IAM ARN representing the identity of API Caller. SDK users cannot populate this and this value is calculated automatically if ConnectUserArn is not provided.
        case awsidentityarn(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension ConnectClientTypes {

    public enum FileStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case approved
        case failed
        case processing
        case rejected
        case sdkUnknown(Swift.String)

        public static var allCases: [FileStatusType] {
            return [
                .approved,
                .failed,
                .processing,
                .rejected
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .approved: return "APPROVED"
            case .failed: return "FAILED"
            case .processing: return "PROCESSING"
            case .rejected: return "REJECTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {

    public enum FileUseCaseType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case attachment
        case sdkUnknown(Swift.String)

        public static var allCases: [FileUseCaseType] {
            return [
                .attachment
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .attachment: return "ATTACHMENT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// Information about the attached file.
    public struct AttachedFile {
        /// The resource to which the attached file is (being) uploaded to. [Cases](https://docs.aws.amazon.com/connect/latest/APIReference/API_connect-cases_CreateCase.html) are the only current supported resource. This value must be a valid ARN.
        public var associatedResourceArn: Swift.String?
        /// Represents the identity that created the file.
        public var createdBy: ConnectClientTypes.CreatedByInfo?
        /// The time of Creation of the file resource as an ISO timestamp. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2024-05-03T02:41:28.172Z.
        /// This member is required.
        public var creationTime: Swift.String?
        /// The unique identifier of the attached file resource (ARN).
        /// This member is required.
        public var fileArn: Swift.String?
        /// The unique identifier of the attached file resource.
        /// This member is required.
        public var fileId: Swift.String?
        /// A case-sensitive name of the attached file being uploaded.
        /// This member is required.
        public var fileName: Swift.String?
        /// The size of the attached file in bytes.
        /// This member is required.
        public var fileSizeInBytes: Swift.Int?
        /// The current status of the attached file.
        /// This member is required.
        public var fileStatus: ConnectClientTypes.FileStatusType?
        /// The use case for the file.
        public var fileUseCaseType: ConnectClientTypes.FileUseCaseType?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public var tags: [Swift.String: Swift.String]?

        public init(
            associatedResourceArn: Swift.String? = nil,
            createdBy: ConnectClientTypes.CreatedByInfo? = nil,
            creationTime: Swift.String? = nil,
            fileArn: Swift.String? = nil,
            fileId: Swift.String? = nil,
            fileName: Swift.String? = nil,
            fileSizeInBytes: Swift.Int? = nil,
            fileStatus: ConnectClientTypes.FileStatusType? = nil,
            fileUseCaseType: ConnectClientTypes.FileUseCaseType? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.associatedResourceArn = associatedResourceArn
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.fileArn = fileArn
            self.fileId = fileId
            self.fileName = fileName
            self.fileSizeInBytes = fileSizeInBytes
            self.fileStatus = fileStatus
            self.fileUseCaseType = fileUseCaseType
            self.tags = tags
        }
    }

}

public struct BatchGetAttachedFileMetadataOutput {
    /// List of errors of attached files that could not be retrieved.
    public var errors: [ConnectClientTypes.AttachedFileError]?
    /// List of attached files that were successfully retrieved.
    public var files: [ConnectClientTypes.AttachedFile]?

    public init(
        errors: [ConnectClientTypes.AttachedFileError]? = nil,
        files: [ConnectClientTypes.AttachedFile]? = nil
    )
    {
        self.errors = errors
        self.files = files
    }
}

extension ConnectClientTypes {

    public enum ListFlowAssociationResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case voicePhoneNumber
        case sdkUnknown(Swift.String)

        public static var allCases: [ListFlowAssociationResourceType] {
            return [
                .voicePhoneNumber
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .voicePhoneNumber: return "VOICE_PHONE_NUMBER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct BatchGetFlowAssociationInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A list of resource identifiers to retrieve flow associations.
    /// This member is required.
    public var resourceIds: [Swift.String]?
    /// The type of resource association.
    public var resourceType: ConnectClientTypes.ListFlowAssociationResourceType?

    public init(
        instanceId: Swift.String? = nil,
        resourceIds: [Swift.String]? = nil,
        resourceType: ConnectClientTypes.ListFlowAssociationResourceType? = nil
    )
    {
        self.instanceId = instanceId
        self.resourceIds = resourceIds
        self.resourceType = resourceType
    }
}

extension ConnectClientTypes {
    /// Information about flow associations.
    public struct FlowAssociationSummary {
        /// The identifier of the flow.
        public var flowId: Swift.String?
        /// The identifier of the resource.
        public var resourceId: Swift.String?
        /// The type of resource association.
        public var resourceType: ConnectClientTypes.ListFlowAssociationResourceType?

        public init(
            flowId: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceType: ConnectClientTypes.ListFlowAssociationResourceType? = nil
        )
        {
            self.flowId = flowId
            self.resourceId = resourceId
            self.resourceType = resourceType
        }
    }

}

public struct BatchGetFlowAssociationOutput {
    /// Information about flow associations.
    public var flowAssociationSummaryList: [ConnectClientTypes.FlowAssociationSummary]?

    public init(
        flowAssociationSummaryList: [ConnectClientTypes.FlowAssociationSummary]? = nil
    )
    {
        self.flowAssociationSummaryList = flowAssociationSummaryList
    }
}

/// An entity with the same name already exists.
public struct IdempotencyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IdempotencyException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ConnectClientTypes {
    /// Information associated with a campaign.
    public struct Campaign {
        /// A unique identifier for a campaign.
        public var campaignId: Swift.String?

        public init(
            campaignId: Swift.String? = nil
        )
        {
            self.campaignId = campaignId
        }
    }

}

extension ConnectClientTypes {

    public enum EndpointType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case contactFlow
        case telephoneNumber
        case voip
        case sdkUnknown(Swift.String)

        public static var allCases: [EndpointType] {
            return [
                .contactFlow,
                .telephoneNumber,
                .voip
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contactFlow: return "CONTACT_FLOW"
            case .telephoneNumber: return "TELEPHONE_NUMBER"
            case .voip: return "VOIP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// Information about the endpoint.
    public struct Endpoint {
        /// Address of the endpoint.
        public var address: Swift.String?
        /// Type of the endpoint.
        public var type: ConnectClientTypes.EndpointType?

        public init(
            address: Swift.String? = nil,
            type: ConnectClientTypes.EndpointType? = nil
        )
        {
            self.address = address
            self.type = type
        }
    }

}

extension ConnectClientTypes {
    /// Request object with information to create a contact.
    public struct ContactDataRequest {
        /// List of attributes to be stored in a contact.
        public var attributes: [Swift.String: Swift.String]?
        /// Structure to store information associated with a campaign.
        public var campaign: ConnectClientTypes.Campaign?
        /// Endpoint of the customer for which contact will be initiated.
        public var customerEndpoint: ConnectClientTypes.Endpoint?
        /// The identifier of the queue associated with the Amazon Connect instance in which contacts that are created will be queued.
        public var queueId: Swift.String?
        /// Identifier to uniquely identify individual requests in the batch.
        public var requestIdentifier: Swift.String?
        /// Endpoint associated with the Amazon Connect instance from which outbound contact will be initiated for the campaign.
        public var systemEndpoint: ConnectClientTypes.Endpoint?

        public init(
            attributes: [Swift.String: Swift.String]? = nil,
            campaign: ConnectClientTypes.Campaign? = nil,
            customerEndpoint: ConnectClientTypes.Endpoint? = nil,
            queueId: Swift.String? = nil,
            requestIdentifier: Swift.String? = nil,
            systemEndpoint: ConnectClientTypes.Endpoint? = nil
        )
        {
            self.attributes = attributes
            self.campaign = campaign
            self.customerEndpoint = customerEndpoint
            self.queueId = queueId
            self.requestIdentifier = requestIdentifier
            self.systemEndpoint = systemEndpoint
        }
    }

}

public struct BatchPutContactInput {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// List of individual contact requests.
    /// This member is required.
    public var contactDataRequestList: [ConnectClientTypes.ContactDataRequest]?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        contactDataRequestList: [ConnectClientTypes.ContactDataRequest]? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.contactDataRequestList = contactDataRequestList
        self.instanceId = instanceId
    }
}

extension ConnectClientTypes {

    public enum FailureReasonCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case idempotencyException
        case internalError
        case invalidAttributeKey
        case invalidCustomerEndpoint
        case invalidQueue
        case invalidSystemEndpoint
        case missingCampaign
        case missingCustomerEndpoint
        case missingQueueIdAndSystemEndpoint
        case requestThrottled
        case sdkUnknown(Swift.String)

        public static var allCases: [FailureReasonCode] {
            return [
                .idempotencyException,
                .internalError,
                .invalidAttributeKey,
                .invalidCustomerEndpoint,
                .invalidQueue,
                .invalidSystemEndpoint,
                .missingCampaign,
                .missingCustomerEndpoint,
                .missingQueueIdAndSystemEndpoint,
                .requestThrottled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .idempotencyException: return "IDEMPOTENCY_EXCEPTION"
            case .internalError: return "INTERNAL_ERROR"
            case .invalidAttributeKey: return "INVALID_ATTRIBUTE_KEY"
            case .invalidCustomerEndpoint: return "INVALID_CUSTOMER_ENDPOINT"
            case .invalidQueue: return "INVALID_QUEUE"
            case .invalidSystemEndpoint: return "INVALID_SYSTEM_ENDPOINT"
            case .missingCampaign: return "MISSING_CAMPAIGN"
            case .missingCustomerEndpoint: return "MISSING_CUSTOMER_ENDPOINT"
            case .missingQueueIdAndSystemEndpoint: return "MISSING_QUEUE_ID_AND_SYSTEM_ENDPOINT"
            case .requestThrottled: return "REQUEST_THROTTLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// Request for which contact failed to be generated.
    public struct FailedRequest {
        /// Reason code for the failure.
        public var failureReasonCode: ConnectClientTypes.FailureReasonCode?
        /// Why the request to create a contact failed.
        public var failureReasonMessage: Swift.String?
        /// Request identifier provided in the API call in the ContactDataRequest to create a contact.
        public var requestIdentifier: Swift.String?

        public init(
            failureReasonCode: ConnectClientTypes.FailureReasonCode? = nil,
            failureReasonMessage: Swift.String? = nil,
            requestIdentifier: Swift.String? = nil
        )
        {
            self.failureReasonCode = failureReasonCode
            self.failureReasonMessage = failureReasonMessage
            self.requestIdentifier = requestIdentifier
        }
    }

}

extension ConnectClientTypes {
    /// Request for which contact was successfully created.
    public struct SuccessfulRequest {
        /// The contactId of the contact that was created successfully.
        public var contactId: Swift.String?
        /// Request identifier provided in the API call in the ContactDataRequest to create a contact.
        public var requestIdentifier: Swift.String?

        public init(
            contactId: Swift.String? = nil,
            requestIdentifier: Swift.String? = nil
        )
        {
            self.contactId = contactId
            self.requestIdentifier = requestIdentifier
        }
    }

}

public struct BatchPutContactOutput {
    /// List of requests for which contact creation failed.
    public var failedRequestList: [ConnectClientTypes.FailedRequest]?
    /// List of requests for which contact was successfully created.
    public var successfulRequestList: [ConnectClientTypes.SuccessfulRequest]?

    public init(
        failedRequestList: [ConnectClientTypes.FailedRequest]? = nil,
        successfulRequestList: [ConnectClientTypes.SuccessfulRequest]? = nil
    )
    {
        self.failedRequestList = failedRequestList
        self.successfulRequestList = successfulRequestList
    }
}

public struct ClaimPhoneNumberInput {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/). Pattern: ^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$
    public var clientToken: Swift.String?
    /// The identifier of the Amazon Connect instance that phone numbers are claimed to. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance. You must enter InstanceId or TargetArn.
    public var instanceId: Swift.String?
    /// The phone number you want to claim. Phone numbers are formatted [+] [country code] [subscriber number including area code].
    /// This member is required.
    public var phoneNumber: Swift.String?
    /// The description of the phone number.
    public var phoneNumberDescription: Swift.String?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String: Swift.String]?
    /// The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone number inbound traffic is routed through. You must enter InstanceId or TargetArn.
    public var targetArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        phoneNumber: Swift.String? = nil,
        phoneNumberDescription: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        targetArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.instanceId = instanceId
        self.phoneNumber = phoneNumber
        self.phoneNumberDescription = phoneNumberDescription
        self.tags = tags
        self.targetArn = targetArn
    }
}

public struct ClaimPhoneNumberOutput {
    /// The Amazon Resource Name (ARN) of the phone number.
    public var phoneNumberArn: Swift.String?
    /// A unique identifier for the phone number.
    public var phoneNumberId: Swift.String?

    public init(
        phoneNumberArn: Swift.String? = nil,
        phoneNumberId: Swift.String? = nil
    )
    {
        self.phoneNumberArn = phoneNumberArn
        self.phoneNumberId = phoneNumberId
    }
}

/// Request to CompleteAttachedFileUpload API
public struct CompleteAttachedFileUploadInput {
    /// The resource to which the attached file is (being) uploaded to. [Cases](https://docs.aws.amazon.com/connect/latest/APIReference/API_connect-cases_CreateCase.html) are the only current supported resource. This value must be a valid ARN.
    /// This member is required.
    public var associatedResourceArn: Swift.String?
    /// The unique identifier of the attached file resource.
    /// This member is required.
    public var fileId: Swift.String?
    /// The unique identifier of the Amazon Connect instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        associatedResourceArn: Swift.String? = nil,
        fileId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.associatedResourceArn = associatedResourceArn
        self.fileId = fileId
        self.instanceId = instanceId
    }
}

/// Response from CompleteAttachedFileUpload API
public struct CompleteAttachedFileUploadOutput {

    public init() { }
}

/// A resource with the specified name already exists.
public struct DuplicateResourceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DuplicateResourceException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateAgentStatusInput {
    /// The description of the status.
    public var description: Swift.String?
    /// The display order of the status.
    public var displayOrder: Swift.Int?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the status.
    /// This member is required.
    public var name: Swift.String?
    /// The state of the status.
    /// This member is required.
    public var state: ConnectClientTypes.AgentStatusState?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String: Swift.String]?

    public init(
        description: Swift.String? = nil,
        displayOrder: Swift.Int? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        state: ConnectClientTypes.AgentStatusState? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.description = description
        self.displayOrder = displayOrder
        self.instanceId = instanceId
        self.name = name
        self.state = state
        self.tags = tags
    }
}

public struct CreateAgentStatusOutput {
    /// The Amazon Resource Name (ARN) of the agent status.
    public var agentStatusARN: Swift.String?
    /// The identifier of the agent status.
    public var agentStatusId: Swift.String?

    public init(
        agentStatusARN: Swift.String? = nil,
        agentStatusId: Swift.String? = nil
    )
    {
        self.agentStatusARN = agentStatusARN
        self.agentStatusId = agentStatusId
    }
}

extension ConnectClientTypes {
    /// Information about a problem detail.
    public struct ProblemDetail {
        /// The problem detail's message.
        public var message: Swift.String?

        public init(
            message: Swift.String? = nil
        )
        {
            self.message = message
        }
    }

}

/// The flow is not valid.
public struct InvalidContactFlowException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The problems with the flow. Please fix before trying again.
        public internal(set) var problems: [ConnectClientTypes.ProblemDetail]? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidContactFlowException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        problems: [ConnectClientTypes.ProblemDetail]? = nil
    )
    {
        self.properties.problems = problems
    }
}

extension ConnectClientTypes {

    public enum ContactFlowStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case published
        case saved
        case sdkUnknown(Swift.String)

        public static var allCases: [ContactFlowStatus] {
            return [
                .published,
                .saved
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .published: return "PUBLISHED"
            case .saved: return "SAVED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {

    public enum ContactFlowType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case agentHold
        case agentTransfer
        case agentWhisper
        case contactFlow
        case customerHold
        case customerQueue
        case customerWhisper
        case outboundWhisper
        case queueTransfer
        case sdkUnknown(Swift.String)

        public static var allCases: [ContactFlowType] {
            return [
                .agentHold,
                .agentTransfer,
                .agentWhisper,
                .contactFlow,
                .customerHold,
                .customerQueue,
                .customerWhisper,
                .outboundWhisper,
                .queueTransfer
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .agentHold: return "AGENT_HOLD"
            case .agentTransfer: return "AGENT_TRANSFER"
            case .agentWhisper: return "AGENT_WHISPER"
            case .contactFlow: return "CONTACT_FLOW"
            case .customerHold: return "CUSTOMER_HOLD"
            case .customerQueue: return "CUSTOMER_QUEUE"
            case .customerWhisper: return "CUSTOMER_WHISPER"
            case .outboundWhisper: return "OUTBOUND_WHISPER"
            case .queueTransfer: return "QUEUE_TRANSFER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateContactFlowInput {
    /// The JSON string that represents the content of the flow. For an example, see [Example flow in Amazon Connect Flow language](https://docs.aws.amazon.com/connect/latest/APIReference/flow-language-example.html). Length Constraints: Minimum length of 1. Maximum length of 256000.
    /// This member is required.
    public var content: Swift.String?
    /// The description of the flow.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the flow.
    /// This member is required.
    public var name: Swift.String?
    /// Indicates the flow status as either SAVED or PUBLISHED. The PUBLISHED status will initiate validation on the content. the SAVED status does not initiate validation of the content. SAVED | PUBLISHED.
    public var status: ConnectClientTypes.ContactFlowStatus?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String: Swift.String]?
    /// The type of the flow. For descriptions of the available types, see [Choose a flow type](https://docs.aws.amazon.com/connect/latest/adminguide/create-contact-flow.html#contact-flow-types) in the Amazon Connect Administrator Guide.
    /// This member is required.
    public var type: ConnectClientTypes.ContactFlowType?

    public init(
        content: Swift.String? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        status: ConnectClientTypes.ContactFlowStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        type: ConnectClientTypes.ContactFlowType? = nil
    )
    {
        self.content = content
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.status = status
        self.tags = tags
        self.type = type
    }
}

public struct CreateContactFlowOutput {
    /// The Amazon Resource Name (ARN) of the flow.
    public var contactFlowArn: Swift.String?
    /// The identifier of the flow.
    public var contactFlowId: Swift.String?

    public init(
        contactFlowArn: Swift.String? = nil,
        contactFlowId: Swift.String? = nil
    )
    {
        self.contactFlowArn = contactFlowArn
        self.contactFlowId = contactFlowId
    }
}

/// The problems with the module. Please fix before trying again.
public struct InvalidContactFlowModuleException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var problems: [ConnectClientTypes.ProblemDetail]? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidContactFlowModuleException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        problems: [ConnectClientTypes.ProblemDetail]? = nil
    )
    {
        self.properties.problems = problems
    }
}

public struct CreateContactFlowModuleInput {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The JSON string that represents the content of the flow. For an example, see [Example flow in Amazon Connect Flow language](https://docs.aws.amazon.com/connect/latest/APIReference/flow-language-example.html).
    /// This member is required.
    public var content: Swift.String?
    /// The description of the flow module.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the flow module.
    /// This member is required.
    public var name: Swift.String?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        content: Swift.String? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.content = content
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.tags = tags
    }
}

public struct CreateContactFlowModuleOutput {
    /// The Amazon Resource Name (ARN) of the flow module.
    public var arn: Swift.String?
    /// The identifier of the flow module.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

extension ConnectClientTypes {

    public enum EvaluationFormQuestionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case numeric
        case singleselect
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [EvaluationFormQuestionType] {
            return [
                .numeric,
                .singleselect,
                .text
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .numeric: return "NUMERIC"
            case .singleselect: return "SINGLESELECT"
            case .text: return "TEXT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {

    public enum NumericQuestionPropertyAutomationLabel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case agentInteractionDuration
        case contactDuration
        case customerHoldTime
        case nonTalkTime
        case nonTalkTimePercentage
        case numberOfInterruptions
        case overallAgentSentimentScore
        case overallCustomerSentimentScore
        case sdkUnknown(Swift.String)

        public static var allCases: [NumericQuestionPropertyAutomationLabel] {
            return [
                .agentInteractionDuration,
                .contactDuration,
                .customerHoldTime,
                .nonTalkTime,
                .nonTalkTimePercentage,
                .numberOfInterruptions,
                .overallAgentSentimentScore,
                .overallCustomerSentimentScore
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .agentInteractionDuration: return "AGENT_INTERACTION_DURATION"
            case .contactDuration: return "CONTACT_DURATION"
            case .customerHoldTime: return "CUSTOMER_HOLD_TIME"
            case .nonTalkTime: return "NON_TALK_TIME"
            case .nonTalkTimePercentage: return "NON_TALK_TIME_PERCENTAGE"
            case .numberOfInterruptions: return "NUMBER_OF_INTERRUPTIONS"
            case .overallAgentSentimentScore: return "OVERALL_AGENT_SENTIMENT_SCORE"
            case .overallCustomerSentimentScore: return "OVERALL_CUSTOMER_SENTIMENT_SCORE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// Information about the property value used in automation of a numeric questions. Label values are associated with minimum and maximum values for the numeric question.
    ///
    /// * Sentiment scores have a minimum value of -5 and maximum value of 5.
    ///
    /// * Duration labels, such as NON_TALK_TIME, CONTACT_DURATION, AGENT_INTERACTION_DURATION, CUSTOMER_HOLD_TIME have a minimum value of 0 and maximum value of 28800.
    ///
    /// * Percentages have a minimum value of 0 and maximum value of 100.
    ///
    /// * NUMBER_OF_INTERRUPTIONS has a minimum value of 0 and maximum value of 1000.
    public struct NumericQuestionPropertyValueAutomation {
        /// The property label of the automation.
        /// This member is required.
        public var label: ConnectClientTypes.NumericQuestionPropertyAutomationLabel?

        public init(
            label: ConnectClientTypes.NumericQuestionPropertyAutomationLabel? = nil
        )
        {
            self.label = label
        }
    }

}

extension ConnectClientTypes {
    /// Information about the automation configuration in numeric questions.
    public enum EvaluationFormNumericQuestionAutomation {
        /// The property value of the automation.
        case propertyvalue(ConnectClientTypes.NumericQuestionPropertyValueAutomation)
        case sdkUnknown(Swift.String)
    }

}

extension ConnectClientTypes {
    /// Information about the option range used for scoring in numeric questions.
    public struct EvaluationFormNumericQuestionOption {
        /// The flag to mark the option as automatic fail. If an automatic fail answer is provided, the overall evaluation gets a score of 0.
        public var automaticFail: Swift.Bool
        /// The maximum answer value of the range option.
        /// This member is required.
        public var maxValue: Swift.Int
        /// The minimum answer value of the range option.
        /// This member is required.
        public var minValue: Swift.Int
        /// The score assigned to answer values within the range option.
        public var score: Swift.Int

        public init(
            automaticFail: Swift.Bool = false,
            maxValue: Swift.Int = 0,
            minValue: Swift.Int = 0,
            score: Swift.Int = 0
        )
        {
            self.automaticFail = automaticFail
            self.maxValue = maxValue
            self.minValue = minValue
            self.score = score
        }
    }

}

extension ConnectClientTypes {
    /// Information about properties for a numeric question in an evaluation form.
    public struct EvaluationFormNumericQuestionProperties {
        /// The automation properties of the numeric question.
        public var automation: ConnectClientTypes.EvaluationFormNumericQuestionAutomation?
        /// The maximum answer value.
        /// This member is required.
        public var maxValue: Swift.Int
        /// The minimum answer value.
        /// This member is required.
        public var minValue: Swift.Int
        /// The scoring options of the numeric question.
        public var options: [ConnectClientTypes.EvaluationFormNumericQuestionOption]?

        public init(
            automation: ConnectClientTypes.EvaluationFormNumericQuestionAutomation? = nil,
            maxValue: Swift.Int = 0,
            minValue: Swift.Int = 0,
            options: [ConnectClientTypes.EvaluationFormNumericQuestionOption]? = nil
        )
        {
            self.automation = automation
            self.maxValue = maxValue
            self.minValue = minValue
            self.options = options
        }
    }

}

extension ConnectClientTypes {

    public enum SingleSelectQuestionRuleCategoryAutomationCondition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case notPresent
        case present
        case sdkUnknown(Swift.String)

        public static var allCases: [SingleSelectQuestionRuleCategoryAutomationCondition] {
            return [
                .notPresent,
                .present
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .notPresent: return "NOT_PRESENT"
            case .present: return "PRESENT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// Information about the automation option based on a rule category for a single select question.
    public struct SingleSelectQuestionRuleCategoryAutomation {
        /// The category name, as defined in Rules.
        /// This member is required.
        public var category: Swift.String?
        /// The condition to apply for the automation option. If the condition is PRESENT, then the option is applied when the contact data includes the category. Similarly, if the condition is NOT_PRESENT, then the option is applied when the contact data does not include the category.
        /// This member is required.
        public var condition: ConnectClientTypes.SingleSelectQuestionRuleCategoryAutomationCondition?
        /// The identifier of the answer option.
        /// This member is required.
        public var optionRefId: Swift.String?

        public init(
            category: Swift.String? = nil,
            condition: ConnectClientTypes.SingleSelectQuestionRuleCategoryAutomationCondition? = nil,
            optionRefId: Swift.String? = nil
        )
        {
            self.category = category
            self.condition = condition
            self.optionRefId = optionRefId
        }
    }

}

extension ConnectClientTypes {
    /// Information about the automation option of a single select question.
    public enum EvaluationFormSingleSelectQuestionAutomationOption {
        /// The automation option based on a rule category for the single select question.
        case rulecategory(ConnectClientTypes.SingleSelectQuestionRuleCategoryAutomation)
        case sdkUnknown(Swift.String)
    }

}

extension ConnectClientTypes {
    /// Information about the automation configuration in single select questions. Automation options are evaluated in order, and the first matched option is applied. If no automation option matches, and there is a default option, then the default option is applied.
    public struct EvaluationFormSingleSelectQuestionAutomation {
        /// The identifier of the default answer option, when none of the automation options match the criteria.
        public var defaultOptionRefId: Swift.String?
        /// The automation options of the single select question.
        /// This member is required.
        public var options: [ConnectClientTypes.EvaluationFormSingleSelectQuestionAutomationOption]?

        public init(
            defaultOptionRefId: Swift.String? = nil,
            options: [ConnectClientTypes.EvaluationFormSingleSelectQuestionAutomationOption]? = nil
        )
        {
            self.defaultOptionRefId = defaultOptionRefId
            self.options = options
        }
    }

}

extension ConnectClientTypes {

    public enum EvaluationFormSingleSelectQuestionDisplayMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dropdown
        case radio
        case sdkUnknown(Swift.String)

        public static var allCases: [EvaluationFormSingleSelectQuestionDisplayMode] {
            return [
                .dropdown,
                .radio
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dropdown: return "DROPDOWN"
            case .radio: return "RADIO"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// Information about the automation configuration in single select questions.
    public struct EvaluationFormSingleSelectQuestionOption {
        /// The flag to mark the option as automatic fail. If an automatic fail answer is provided, the overall evaluation gets a score of 0.
        public var automaticFail: Swift.Bool
        /// The identifier of the answer option. An identifier must be unique within the question.
        /// This member is required.
        public var refId: Swift.String?
        /// The score assigned to the answer option.
        public var score: Swift.Int
        /// The title of the answer option.
        /// This member is required.
        public var text: Swift.String?

        public init(
            automaticFail: Swift.Bool = false,
            refId: Swift.String? = nil,
            score: Swift.Int = 0,
            text: Swift.String? = nil
        )
        {
            self.automaticFail = automaticFail
            self.refId = refId
            self.score = score
            self.text = text
        }
    }

}

extension ConnectClientTypes {
    /// Information about the options in single select questions.
    public struct EvaluationFormSingleSelectQuestionProperties {
        /// The display mode of the single select question.
        public var automation: ConnectClientTypes.EvaluationFormSingleSelectQuestionAutomation?
        /// The display mode of the single select question.
        public var displayAs: ConnectClientTypes.EvaluationFormSingleSelectQuestionDisplayMode?
        /// The answer options of the single select question.
        /// This member is required.
        public var options: [ConnectClientTypes.EvaluationFormSingleSelectQuestionOption]?

        public init(
            automation: ConnectClientTypes.EvaluationFormSingleSelectQuestionAutomation? = nil,
            displayAs: ConnectClientTypes.EvaluationFormSingleSelectQuestionDisplayMode? = nil,
            options: [ConnectClientTypes.EvaluationFormSingleSelectQuestionOption]? = nil
        )
        {
            self.automation = automation
            self.displayAs = displayAs
            self.options = options
        }
    }

}

extension ConnectClientTypes {
    /// Information about properties for a question in an evaluation form. The question type properties must be either for a numeric question or a single select question.
    public enum EvaluationFormQuestionTypeProperties {
        /// The properties of the numeric question.
        case numeric(ConnectClientTypes.EvaluationFormNumericQuestionProperties)
        /// The properties of the numeric question.
        case singleselect(ConnectClientTypes.EvaluationFormSingleSelectQuestionProperties)
        case sdkUnknown(Swift.String)
    }

}

extension ConnectClientTypes {
    /// Information about a question from an evaluation form.
    public struct EvaluationFormQuestion {
        /// The instructions of the section.
        public var instructions: Swift.String?
        /// The flag to enable not applicable answers to the question.
        public var notApplicableEnabled: Swift.Bool
        /// The type of the question.
        /// This member is required.
        public var questionType: ConnectClientTypes.EvaluationFormQuestionType?
        /// The properties of the type of question. Text questions do not have to define question type properties.
        public var questionTypeProperties: ConnectClientTypes.EvaluationFormQuestionTypeProperties?
        /// The identifier of the question. An identifier must be unique within the evaluation form.
        /// This member is required.
        public var refId: Swift.String?
        /// The title of the question.
        /// This member is required.
        public var title: Swift.String?
        /// The scoring weight of the section.
        public var weight: Swift.Double

        public init(
            instructions: Swift.String? = nil,
            notApplicableEnabled: Swift.Bool = false,
            questionType: ConnectClientTypes.EvaluationFormQuestionType? = nil,
            questionTypeProperties: ConnectClientTypes.EvaluationFormQuestionTypeProperties? = nil,
            refId: Swift.String? = nil,
            title: Swift.String? = nil,
            weight: Swift.Double = 0.0
        )
        {
            self.instructions = instructions
            self.notApplicableEnabled = notApplicableEnabled
            self.questionType = questionType
            self.questionTypeProperties = questionTypeProperties
            self.refId = refId
            self.title = title
            self.weight = weight
        }
    }

}

extension ConnectClientTypes {

    public enum EvaluationFormScoringMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case questionOnly
        case sectionOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [EvaluationFormScoringMode] {
            return [
                .questionOnly,
                .sectionOnly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .questionOnly: return "QUESTION_ONLY"
            case .sectionOnly: return "SECTION_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {

    public enum EvaluationFormScoringStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [EvaluationFormScoringStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// Information about scoring strategy for an evaluation form.
    public struct EvaluationFormScoringStrategy {
        /// The scoring mode of the evaluation form.
        /// This member is required.
        public var mode: ConnectClientTypes.EvaluationFormScoringMode?
        /// The scoring status of the evaluation form.
        /// This member is required.
        public var status: ConnectClientTypes.EvaluationFormScoringStatus?

        public init(
            mode: ConnectClientTypes.EvaluationFormScoringMode? = nil,
            status: ConnectClientTypes.EvaluationFormScoringStatus? = nil
        )
        {
            self.mode = mode
            self.status = status
        }
    }

}

public struct CreateEvaluationFormOutput {
    /// The Amazon Resource Name (ARN) for the evaluation form resource.
    /// This member is required.
    public var evaluationFormArn: Swift.String?
    /// The unique identifier for the evaluation form.
    /// This member is required.
    public var evaluationFormId: Swift.String?

    public init(
        evaluationFormArn: Swift.String? = nil,
        evaluationFormId: Swift.String? = nil
    )
    {
        self.evaluationFormArn = evaluationFormArn
        self.evaluationFormId = evaluationFormId
    }
}

extension ConnectClientTypes {

    public enum HoursOfOperationDays: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case friday
        case monday
        case saturday
        case sunday
        case thursday
        case tuesday
        case wednesday
        case sdkUnknown(Swift.String)

        public static var allCases: [HoursOfOperationDays] {
            return [
                .friday,
                .monday,
                .saturday,
                .sunday,
                .thursday,
                .tuesday,
                .wednesday
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .friday: return "FRIDAY"
            case .monday: return "MONDAY"
            case .saturday: return "SATURDAY"
            case .sunday: return "SUNDAY"
            case .thursday: return "THURSDAY"
            case .tuesday: return "TUESDAY"
            case .wednesday: return "WEDNESDAY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// The start time or end time for an hours of operation.
    public struct HoursOfOperationTimeSlice {
        /// The hours.
        /// This member is required.
        public var hours: Swift.Int?
        /// The minutes.
        /// This member is required.
        public var minutes: Swift.Int?

        public init(
            hours: Swift.Int? = 0,
            minutes: Swift.Int? = 0
        )
        {
            self.hours = hours
            self.minutes = minutes
        }
    }

}

extension ConnectClientTypes {
    /// Contains information about the hours of operation.
    public struct HoursOfOperationConfig {
        /// The day that the hours of operation applies to.
        /// This member is required.
        public var day: ConnectClientTypes.HoursOfOperationDays?
        /// The end time that your contact center closes.
        /// This member is required.
        public var endTime: ConnectClientTypes.HoursOfOperationTimeSlice?
        /// The start time that your contact center opens.
        /// This member is required.
        public var startTime: ConnectClientTypes.HoursOfOperationTimeSlice?

        public init(
            day: ConnectClientTypes.HoursOfOperationDays? = nil,
            endTime: ConnectClientTypes.HoursOfOperationTimeSlice? = nil,
            startTime: ConnectClientTypes.HoursOfOperationTimeSlice? = nil
        )
        {
            self.day = day
            self.endTime = endTime
            self.startTime = startTime
        }
    }

}

public struct CreateHoursOfOperationInput {
    /// Configuration information for the hours of operation: day, start time, and end time.
    /// This member is required.
    public var config: [ConnectClientTypes.HoursOfOperationConfig]?
    /// The description of the hours of operation.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the hours of operation.
    /// This member is required.
    public var name: Swift.String?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String: Swift.String]?
    /// The time zone of the hours of operation.
    /// This member is required.
    public var timeZone: Swift.String?

    public init(
        config: [ConnectClientTypes.HoursOfOperationConfig]? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        timeZone: Swift.String? = nil
    )
    {
        self.config = config
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.tags = tags
        self.timeZone = timeZone
    }
}

public struct CreateHoursOfOperationOutput {
    /// The Amazon Resource Name (ARN) for the hours of operation.
    public var hoursOfOperationArn: Swift.String?
    /// The identifier for the hours of operation.
    public var hoursOfOperationId: Swift.String?

    public init(
        hoursOfOperationArn: Swift.String? = nil,
        hoursOfOperationId: Swift.String? = nil
    )
    {
        self.hoursOfOperationArn = hoursOfOperationArn
        self.hoursOfOperationId = hoursOfOperationId
    }
}

extension ConnectClientTypes {

    public enum DirectoryType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case connectManaged
        case existingDirectory
        case saml
        case sdkUnknown(Swift.String)

        public static var allCases: [DirectoryType] {
            return [
                .connectManaged,
                .existingDirectory,
                .saml
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .connectManaged: return "CONNECT_MANAGED"
            case .existingDirectory: return "EXISTING_DIRECTORY"
            case .saml: return "SAML"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateInstanceInput {
    /// The idempotency token.
    public var clientToken: Swift.String?
    /// The identifier for the directory.
    public var directoryId: Swift.String?
    /// The type of identity management for your Amazon Connect users.
    /// This member is required.
    public var identityManagementType: ConnectClientTypes.DirectoryType?
    /// Your contact center handles incoming contacts.
    /// This member is required.
    public var inboundCallsEnabled: Swift.Bool?
    /// The name for your instance.
    public var instanceAlias: Swift.String?
    /// Your contact center allows outbound calls.
    /// This member is required.
    public var outboundCallsEnabled: Swift.Bool?
    /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        directoryId: Swift.String? = nil,
        identityManagementType: ConnectClientTypes.DirectoryType? = nil,
        inboundCallsEnabled: Swift.Bool? = nil,
        instanceAlias: Swift.String? = nil,
        outboundCallsEnabled: Swift.Bool? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.directoryId = directoryId
        self.identityManagementType = identityManagementType
        self.inboundCallsEnabled = inboundCallsEnabled
        self.instanceAlias = instanceAlias
        self.outboundCallsEnabled = outboundCallsEnabled
        self.tags = tags
    }
}

extension CreateInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateInstanceInput(clientToken: \(Swift.String(describing: clientToken)), directoryId: \(Swift.String(describing: directoryId)), identityManagementType: \(Swift.String(describing: identityManagementType)), inboundCallsEnabled: \(Swift.String(describing: inboundCallsEnabled)), outboundCallsEnabled: \(Swift.String(describing: outboundCallsEnabled)), tags: \(Swift.String(describing: tags)), instanceAlias: \"CONTENT_REDACTED\")"}
}

public struct CreateInstanceOutput {
    /// The Amazon Resource Name (ARN) of the instance.
    public var arn: Swift.String?
    /// The identifier for the instance.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

extension ConnectClientTypes {

    public enum IntegrationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case application
        case casesDomain
        case event
        case fileScanner
        case pinpointApp
        case voiceId
        case wisdomAssistant
        case wisdomKnowledgeBase
        case wisdomQuickResponses
        case sdkUnknown(Swift.String)

        public static var allCases: [IntegrationType] {
            return [
                .application,
                .casesDomain,
                .event,
                .fileScanner,
                .pinpointApp,
                .voiceId,
                .wisdomAssistant,
                .wisdomKnowledgeBase,
                .wisdomQuickResponses
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .application: return "APPLICATION"
            case .casesDomain: return "CASES_DOMAIN"
            case .event: return "EVENT"
            case .fileScanner: return "FILE_SCANNER"
            case .pinpointApp: return "PINPOINT_APP"
            case .voiceId: return "VOICE_ID"
            case .wisdomAssistant: return "WISDOM_ASSISTANT"
            case .wisdomKnowledgeBase: return "WISDOM_KNOWLEDGE_BASE"
            case .wisdomQuickResponses: return "WISDOM_QUICK_RESPONSES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {

    public enum SourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cases
        case salesforce
        case zendesk
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceType] {
            return [
                .cases,
                .salesforce,
                .zendesk
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cases: return "CASES"
            case .salesforce: return "SALESFORCE"
            case .zendesk: return "ZENDESK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateIntegrationAssociationInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The Amazon Resource Name (ARN) of the integration. When integrating with Amazon Pinpoint, the Amazon Connect and Amazon Pinpoint instances must be in the same account.
    /// This member is required.
    public var integrationArn: Swift.String?
    /// The type of information to be ingested.
    /// This member is required.
    public var integrationType: ConnectClientTypes.IntegrationType?
    /// The name of the external application. This field is only required for the EVENT integration type.
    public var sourceApplicationName: Swift.String?
    /// The URL for the external application. This field is only required for the EVENT integration type.
    public var sourceApplicationUrl: Swift.String?
    /// The type of the data source. This field is only required for the EVENT integration type.
    public var sourceType: ConnectClientTypes.SourceType?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String: Swift.String]?

    public init(
        instanceId: Swift.String? = nil,
        integrationArn: Swift.String? = nil,
        integrationType: ConnectClientTypes.IntegrationType? = nil,
        sourceApplicationName: Swift.String? = nil,
        sourceApplicationUrl: Swift.String? = nil,
        sourceType: ConnectClientTypes.SourceType? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.instanceId = instanceId
        self.integrationArn = integrationArn
        self.integrationType = integrationType
        self.sourceApplicationName = sourceApplicationName
        self.sourceApplicationUrl = sourceApplicationUrl
        self.sourceType = sourceType
        self.tags = tags
    }
}

public struct CreateIntegrationAssociationOutput {
    /// The Amazon Resource Name (ARN) for the association.
    public var integrationAssociationArn: Swift.String?
    /// The identifier for the integration association.
    public var integrationAssociationId: Swift.String?

    public init(
        integrationAssociationArn: Swift.String? = nil,
        integrationAssociationId: Swift.String? = nil
    )
    {
        self.integrationAssociationArn = integrationAssociationArn
        self.integrationAssociationId = integrationAssociationId
    }
}

extension ConnectClientTypes {

    public enum ParticipantRole: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case agent
        case customer
        case customBot
        case supervisor
        case system
        case sdkUnknown(Swift.String)

        public static var allCases: [ParticipantRole] {
            return [
                .agent,
                .customer,
                .customBot,
                .supervisor,
                .system
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .agent: return "AGENT"
            case .customer: return "CUSTOMER"
            case .customBot: return "CUSTOM_BOT"
            case .supervisor: return "SUPERVISOR"
            case .system: return "SYSTEM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// The details to add for the participant.
    public struct ParticipantDetailsToAdd {
        /// The display name of the participant.
        public var displayName: Swift.String?
        /// The role of the participant being added.
        public var participantRole: ConnectClientTypes.ParticipantRole?

        public init(
            displayName: Swift.String? = nil,
            participantRole: ConnectClientTypes.ParticipantRole? = nil
        )
        {
            self.displayName = displayName
            self.participantRole = participantRole
        }
    }

}

public struct CreateParticipantInput {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The identifier of the contact in this instance of Amazon Connect. Only contacts in the CHAT channel are supported.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Information identifying the participant. The only Valid value for ParticipantRole is CUSTOM_BOT. DisplayName is Required.
    /// This member is required.
    public var participantDetails: ConnectClientTypes.ParticipantDetailsToAdd?

    public init(
        clientToken: Swift.String? = nil,
        contactId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        participantDetails: ConnectClientTypes.ParticipantDetailsToAdd? = nil
    )
    {
        self.clientToken = clientToken
        self.contactId = contactId
        self.instanceId = instanceId
        self.participantDetails = participantDetails
    }
}

extension ConnectClientTypes {
    /// The credentials used by the participant.
    public struct ParticipantTokenCredentials {
        /// The expiration of the token. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
        public var expiry: Swift.String?
        /// The token used by the chat participant to call [CreateParticipantConnection](https://docs.aws.amazon.com/connect-participant/latest/APIReference/API_CreateParticipantConnection.html). The participant token is valid for the lifetime of a chat participant.
        public var participantToken: Swift.String?

        public init(
            expiry: Swift.String? = nil,
            participantToken: Swift.String? = nil
        )
        {
            self.expiry = expiry
            self.participantToken = participantToken
        }
    }

}

public struct CreateParticipantOutput {
    /// The token used by the chat participant to call CreateParticipantConnection. The participant token is valid for the lifetime of a chat participant.
    public var participantCredentials: ConnectClientTypes.ParticipantTokenCredentials?
    /// The identifier for a chat participant. The participantId for a chat participant is the same throughout the chat lifecycle.
    public var participantId: Swift.String?

    public init(
        participantCredentials: ConnectClientTypes.ParticipantTokenCredentials? = nil,
        participantId: Swift.String? = nil
    )
    {
        self.participantCredentials = participantCredentials
        self.participantId = participantId
    }
}

extension ConnectClientTypes {

    public enum RehydrationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case entirePastSession
        case fromSegment
        case sdkUnknown(Swift.String)

        public static var allCases: [RehydrationType] {
            return [
                .entirePastSession,
                .fromSegment
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .entirePastSession: return "ENTIRE_PAST_SESSION"
            case .fromSegment: return "FROM_SEGMENT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreatePersistentContactAssociationInput {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// This is the contactId of the current contact that the CreatePersistentContactAssociation API is being called from.
    /// This member is required.
    public var initialContactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The contactId chosen for rehydration depends on the type chosen.
    ///
    /// * ENTIRE_PAST_SESSION: Rehydrates a chat from the most recently terminated past chat contact of the specified past ended chat session. To use this type, provide the initialContactId of the past ended chat session in the sourceContactId field. In this type, Amazon Connect determines what the most recent chat contact on the past ended chat session and uses it to start a persistent chat.
    ///
    /// * FROM_SEGMENT: Rehydrates a chat from the specified past chat contact provided in the sourceContactId field.
    ///
    ///
    /// The actual contactId used for rehydration is provided in the response of this API. To illustrate how to use rehydration type, consider the following example: A customer starts a chat session. Agent a1 accepts the chat and a conversation starts between the customer and Agent a1. This first contact creates a contact ID C1. Agent a1 then transfers the chat to Agent a2. This creates another contact ID C2. At this point Agent a2 ends the chat. The customer is forwarded to the disconnect flow for a post chat survey that creates another contact ID C3. After the chat survey, the chat session ends. Later, the customer returns and wants to resume their past chat session. At this point, the customer can have following use cases:
    ///
    /// * Use Case 1: The customer wants to continue the past chat session but they want to hide the post chat survey. For this they will use the following configuration:
    ///
    /// * Configuration
    ///
    /// * SourceContactId = "C2"
    ///
    /// * RehydrationType = "FROM_SEGMENT"
    ///
    ///
    ///
    ///
    /// * Expected behavior
    ///
    /// * This starts a persistent chat session from the specified past ended contact (C2). Transcripts of past chat sessions C2 and C1 are accessible in the current persistent chat session. Note that chat segment C3 is dropped from the persistent chat session.
    ///
    ///
    ///
    ///
    ///
    ///
    ///
    /// * Use Case 2: The customer wants to continue the past chat session and see the transcript of the entire past engagement, including the post chat survey. For this they will use the following configuration:
    ///
    /// * Configuration
    ///
    /// * SourceContactId = "C1"
    ///
    /// * RehydrationType = "ENTIRE_PAST_SESSION"
    ///
    ///
    ///
    ///
    /// * Expected behavior
    ///
    /// * This starts a persistent chat session from the most recently ended chat contact (C3). Transcripts of past chat sessions C3, C2 and C1 are accessible in the current persistent chat session.
    /// This member is required.
    public var rehydrationType: ConnectClientTypes.RehydrationType?
    /// The contactId from which a persistent chat session must be started.
    /// This member is required.
    public var sourceContactId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        initialContactId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        rehydrationType: ConnectClientTypes.RehydrationType? = nil,
        sourceContactId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.initialContactId = initialContactId
        self.instanceId = instanceId
        self.rehydrationType = rehydrationType
        self.sourceContactId = sourceContactId
    }
}

public struct CreatePersistentContactAssociationOutput {
    /// The contactId from which a persistent chat session is started. This field is populated only for persistent chat.
    public var continuedFromContactId: Swift.String?

    public init(
        continuedFromContactId: Swift.String? = nil
    )
    {
        self.continuedFromContactId = continuedFromContactId
    }
}

extension ConnectClientTypes {
    /// Information about values of a predefined attribute.
    public enum PredefinedAttributeValues {
        /// Predefined attribute values of type string list.
        case stringlist([Swift.String])
        case sdkUnknown(Swift.String)
    }

}

public struct CreatePredefinedAttributeInput {
    /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the predefined attribute.
    /// This member is required.
    public var name: Swift.String?
    /// The values of the predefined attribute.
    /// This member is required.
    public var values: ConnectClientTypes.PredefinedAttributeValues?

    public init(
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        values: ConnectClientTypes.PredefinedAttributeValues? = nil
    )
    {
        self.instanceId = instanceId
        self.name = name
        self.values = values
    }
}

public struct CreatePromptInput {
    /// The description of the prompt.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the prompt.
    /// This member is required.
    public var name: Swift.String?
    /// The URI for the S3 bucket where the prompt is stored. You can provide S3 pre-signed URLs returned by the [GetPromptFile](https://docs.aws.amazon.com/connect/latest/APIReference/API_GetPromptFile.html) API instead of providing S3 URIs.
    /// This member is required.
    public var s3Uri: Swift.String?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String: Swift.String]?

    public init(
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        s3Uri: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.s3Uri = s3Uri
        self.tags = tags
    }
}

public struct CreatePromptOutput {
    /// The Amazon Resource Name (ARN) of the prompt.
    public var promptARN: Swift.String?
    /// A unique identifier for the prompt.
    public var promptId: Swift.String?

    public init(
        promptARN: Swift.String? = nil,
        promptId: Swift.String? = nil
    )
    {
        self.promptARN = promptARN
        self.promptId = promptId
    }
}

extension ConnectClientTypes {
    /// The outbound caller ID name, number, and outbound whisper flow.
    public struct OutboundCallerConfig {
        /// The caller ID name.
        public var outboundCallerIdName: Swift.String?
        /// The caller ID number.
        public var outboundCallerIdNumberId: Swift.String?
        /// The outbound whisper flow to be used during an outbound call.
        public var outboundFlowId: Swift.String?

        public init(
            outboundCallerIdName: Swift.String? = nil,
            outboundCallerIdNumberId: Swift.String? = nil,
            outboundFlowId: Swift.String? = nil
        )
        {
            self.outboundCallerIdName = outboundCallerIdName
            self.outboundCallerIdNumberId = outboundCallerIdNumberId
            self.outboundFlowId = outboundFlowId
        }
    }

}

public struct CreateQueueInput {
    /// The description of the queue.
    public var description: Swift.String?
    /// The identifier for the hours of operation.
    /// This member is required.
    public var hoursOfOperationId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of contacts that can be in the queue before it is considered full.
    public var maxContacts: Swift.Int?
    /// The name of the queue.
    /// This member is required.
    public var name: Swift.String?
    /// The outbound caller ID name, number, and outbound whisper flow.
    public var outboundCallerConfig: ConnectClientTypes.OutboundCallerConfig?
    /// The quick connects available to agents who are working the queue.
    public var quickConnectIds: [Swift.String]?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String: Swift.String]?

    public init(
        description: Swift.String? = nil,
        hoursOfOperationId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        maxContacts: Swift.Int? = 0,
        name: Swift.String? = nil,
        outboundCallerConfig: ConnectClientTypes.OutboundCallerConfig? = nil,
        quickConnectIds: [Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.description = description
        self.hoursOfOperationId = hoursOfOperationId
        self.instanceId = instanceId
        self.maxContacts = maxContacts
        self.name = name
        self.outboundCallerConfig = outboundCallerConfig
        self.quickConnectIds = quickConnectIds
        self.tags = tags
    }
}

public struct CreateQueueOutput {
    /// The Amazon Resource Name (ARN) of the queue.
    public var queueArn: Swift.String?
    /// The identifier for the queue.
    public var queueId: Swift.String?

    public init(
        queueArn: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.queueArn = queueArn
        self.queueId = queueId
    }
}

extension ConnectClientTypes {
    /// Contains information about a phone number for a quick connect.
    public struct PhoneNumberQuickConnectConfig {
        /// The phone number in E.164 format.
        /// This member is required.
        public var phoneNumber: Swift.String?

        public init(
            phoneNumber: Swift.String? = nil
        )
        {
            self.phoneNumber = phoneNumber
        }
    }

}

extension ConnectClientTypes {
    /// Contains information about a queue for a quick connect. The flow must be of type Transfer to Queue.
    public struct QueueQuickConnectConfig {
        /// The identifier of the flow.
        /// This member is required.
        public var contactFlowId: Swift.String?
        /// The identifier for the queue.
        /// This member is required.
        public var queueId: Swift.String?

        public init(
            contactFlowId: Swift.String? = nil,
            queueId: Swift.String? = nil
        )
        {
            self.contactFlowId = contactFlowId
            self.queueId = queueId
        }
    }

}

extension ConnectClientTypes {

    public enum QuickConnectType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case phoneNumber
        case queue
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [QuickConnectType] {
            return [
                .phoneNumber,
                .queue,
                .user
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .phoneNumber: return "PHONE_NUMBER"
            case .queue: return "QUEUE"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// Contains information about the quick connect configuration settings for a user. The contact flow must be of type Transfer to Agent.
    public struct UserQuickConnectConfig {
        /// The identifier of the flow.
        /// This member is required.
        public var contactFlowId: Swift.String?
        /// The identifier of the user.
        /// This member is required.
        public var userId: Swift.String?

        public init(
            contactFlowId: Swift.String? = nil,
            userId: Swift.String? = nil
        )
        {
            self.contactFlowId = contactFlowId
            self.userId = userId
        }
    }

}

extension ConnectClientTypes {
    /// Contains configuration settings for a quick connect.
    public struct QuickConnectConfig {
        /// The phone configuration. This is required only if QuickConnectType is PHONE_NUMBER.
        public var phoneConfig: ConnectClientTypes.PhoneNumberQuickConnectConfig?
        /// The queue configuration. This is required only if QuickConnectType is QUEUE.
        public var queueConfig: ConnectClientTypes.QueueQuickConnectConfig?
        /// The type of quick connect. In the Amazon Connect admin website, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE).
        /// This member is required.
        public var quickConnectType: ConnectClientTypes.QuickConnectType?
        /// The user configuration. This is required only if QuickConnectType is USER.
        public var userConfig: ConnectClientTypes.UserQuickConnectConfig?

        public init(
            phoneConfig: ConnectClientTypes.PhoneNumberQuickConnectConfig? = nil,
            queueConfig: ConnectClientTypes.QueueQuickConnectConfig? = nil,
            quickConnectType: ConnectClientTypes.QuickConnectType? = nil,
            userConfig: ConnectClientTypes.UserQuickConnectConfig? = nil
        )
        {
            self.phoneConfig = phoneConfig
            self.queueConfig = queueConfig
            self.quickConnectType = quickConnectType
            self.userConfig = userConfig
        }
    }

}

public struct CreateQuickConnectInput {
    /// The description of the quick connect.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A unique name of the quick connect.
    /// This member is required.
    public var name: Swift.String?
    /// Configuration settings for the quick connect.
    /// This member is required.
    public var quickConnectConfig: ConnectClientTypes.QuickConnectConfig?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String: Swift.String]?

    public init(
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        quickConnectConfig: ConnectClientTypes.QuickConnectConfig? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.quickConnectConfig = quickConnectConfig
        self.tags = tags
    }
}

public struct CreateQuickConnectOutput {
    /// The Amazon Resource Name (ARN) for the quick connect.
    public var quickConnectARN: Swift.String?
    /// The identifier for the quick connect.
    public var quickConnectId: Swift.String?

    public init(
        quickConnectARN: Swift.String? = nil,
        quickConnectId: Swift.String? = nil
    )
    {
        self.quickConnectARN = quickConnectARN
        self.quickConnectId = quickConnectId
    }
}

extension ConnectClientTypes {

    public enum BehaviorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case routeAnyChannel
        case routeCurrentChannelOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [BehaviorType] {
            return [
                .routeAnyChannel,
                .routeCurrentChannelOnly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .routeAnyChannel: return "ROUTE_ANY_CHANNEL"
            case .routeCurrentChannelOnly: return "ROUTE_CURRENT_CHANNEL_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// Defines the cross-channel routing behavior that allows an agent working on a contact in one channel to be offered a contact from a different channel.
    public struct CrossChannelBehavior {
        /// Specifies the other channels that can be routed to an agent handling their current channel.
        /// This member is required.
        public var behaviorType: ConnectClientTypes.BehaviorType?

        public init(
            behaviorType: ConnectClientTypes.BehaviorType? = nil
        )
        {
            self.behaviorType = behaviorType
        }
    }

}

extension ConnectClientTypes {
    /// Contains information about which channels are supported, and how many contacts an agent can have on a channel simultaneously.
    public struct MediaConcurrency {
        /// The channels that agents can handle in the Contact Control Panel (CCP).
        /// This member is required.
        public var channel: ConnectClientTypes.Channel?
        /// The number of contacts an agent can have on a channel simultaneously. Valid Range for VOICE: Minimum value of 1. Maximum value of 1. Valid Range for CHAT: Minimum value of 1. Maximum value of 10. Valid Range for TASK: Minimum value of 1. Maximum value of 10.
        /// This member is required.
        public var concurrency: Swift.Int?
        /// Defines the cross-channel routing behavior for each channel that is enabled for this Routing Profile. For example, this allows you to offer an agent a different contact from another channel when they are currently working with a contact from a Voice channel.
        public var crossChannelBehavior: ConnectClientTypes.CrossChannelBehavior?

        public init(
            channel: ConnectClientTypes.Channel? = nil,
            concurrency: Swift.Int? = nil,
            crossChannelBehavior: ConnectClientTypes.CrossChannelBehavior? = nil
        )
        {
            self.channel = channel
            self.concurrency = concurrency
            self.crossChannelBehavior = crossChannelBehavior
        }
    }

}

public struct CreateRoutingProfileInput {
    /// Whether agents with this routing profile will have their routing order calculated based on longest idle time or time since their last inbound contact.
    public var agentAvailabilityTimer: ConnectClientTypes.AgentAvailabilityTimer?
    /// The default outbound queue for the routing profile.
    /// This member is required.
    public var defaultOutboundQueueId: Swift.String?
    /// Description of the routing profile. Must not be more than 250 characters.
    /// This member is required.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The channels that agents can handle in the Contact Control Panel (CCP) for this routing profile.
    /// This member is required.
    public var mediaConcurrencies: [ConnectClientTypes.MediaConcurrency]?
    /// The name of the routing profile. Must not be more than 127 characters.
    /// This member is required.
    public var name: Swift.String?
    /// The inbound queues associated with the routing profile. If no queue is added, the agent can make only outbound calls. The limit of 10 array members applies to the maximum number of RoutingProfileQueueConfig objects that can be passed during a CreateRoutingProfile API request. It is different from the quota of 50 queues per routing profile per instance that is listed in [Amazon Connect service quotas](https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html).
    public var queueConfigs: [ConnectClientTypes.RoutingProfileQueueConfig]?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String: Swift.String]?

    public init(
        agentAvailabilityTimer: ConnectClientTypes.AgentAvailabilityTimer? = nil,
        defaultOutboundQueueId: Swift.String? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        mediaConcurrencies: [ConnectClientTypes.MediaConcurrency]? = nil,
        name: Swift.String? = nil,
        queueConfigs: [ConnectClientTypes.RoutingProfileQueueConfig]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.agentAvailabilityTimer = agentAvailabilityTimer
        self.defaultOutboundQueueId = defaultOutboundQueueId
        self.description = description
        self.instanceId = instanceId
        self.mediaConcurrencies = mediaConcurrencies
        self.name = name
        self.queueConfigs = queueConfigs
        self.tags = tags
    }
}

public struct CreateRoutingProfileOutput {
    /// The Amazon Resource Name (ARN) of the routing profile.
    public var routingProfileArn: Swift.String?
    /// The identifier of the routing profile.
    public var routingProfileId: Swift.String?

    public init(
        routingProfileArn: Swift.String? = nil,
        routingProfileId: Swift.String? = nil
    )
    {
        self.routingProfileArn = routingProfileArn
        self.routingProfileId = routingProfileId
    }
}

extension ConnectClientTypes {
    /// This action must be set if TriggerEventSource is one of the following values: OnPostCallAnalysisAvailable | OnRealTimeCallAnalysisAvailable | OnRealTimeChatAnalysisAvailable | OnPostChatAnalysisAvailable. Contact is categorized using the rule name. RuleName is used as ContactCategory.
    public struct AssignContactCategoryActionDefinition {

        public init() { }
    }

}

extension ConnectClientTypes {
    /// An empty value.
    public struct EmptyFieldValue {

        public init() { }
    }

}

extension ConnectClientTypes {
    /// Object to store union of Field values.
    public struct FieldValueUnion {
        /// A Boolean number value type.
        public var booleanValue: Swift.Bool
        /// A Double number value type.
        public var doubleValue: Swift.Double?
        /// An empty value.
        public var emptyValue: ConnectClientTypes.EmptyFieldValue?
        /// String value type.
        public var stringValue: Swift.String?

        public init(
            booleanValue: Swift.Bool = false,
            doubleValue: Swift.Double? = nil,
            emptyValue: ConnectClientTypes.EmptyFieldValue? = nil,
            stringValue: Swift.String? = nil
        )
        {
            self.booleanValue = booleanValue
            self.doubleValue = doubleValue
            self.emptyValue = emptyValue
            self.stringValue = stringValue
        }
    }

}

extension ConnectClientTypes {
    /// Object for case field values.
    public struct FieldValue {
        /// Unique identifier of a field.
        /// This member is required.
        public var id: Swift.String?
        /// Union of potential field value types.
        /// This member is required.
        public var value: ConnectClientTypes.FieldValueUnion?

        public init(
            id: Swift.String? = nil,
            value: ConnectClientTypes.FieldValueUnion? = nil
        )
        {
            self.id = id
            self.value = value
        }
    }

}

extension ConnectClientTypes {
    /// The CreateCase action definition.
    public struct CreateCaseActionDefinition {
        /// An array of objects with Field ID and Value data.
        /// This member is required.
        public var fields: [ConnectClientTypes.FieldValue]?
        /// A unique identifier of a template.
        /// This member is required.
        public var templateId: Swift.String?

        public init(
            fields: [ConnectClientTypes.FieldValue]? = nil,
            templateId: Swift.String? = nil
        )
        {
            self.fields = fields
            self.templateId = templateId
        }
    }

}

extension ConnectClientTypes {
    /// End associated tasks related to a case.
    public struct EndAssociatedTasksActionDefinition {

        public init() { }
    }

}

extension ConnectClientTypes {
    /// The EventBridge action definition.
    public struct EventBridgeActionDefinition {
        /// The name.
        /// This member is required.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension ConnectClientTypes {

    public enum NotificationContentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case plainText
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationContentType] {
            return [
                .plainText
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .plainText: return "PLAIN_TEXT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {

    public enum NotificationDeliveryType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case email
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationDeliveryType] {
            return [
                .email
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .email: return "EMAIL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// The type of notification recipient.
    public struct NotificationRecipientType {
        /// A list of user IDs.
        public var userIds: [Swift.String]?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }. Amazon Connect users with the specified tags will be notified.
        public var userTags: [Swift.String: Swift.String]?

        public init(
            userIds: [Swift.String]? = nil,
            userTags: [Swift.String: Swift.String]? = nil
        )
        {
            self.userIds = userIds
            self.userTags = userTags
        }
    }

}

extension ConnectClientTypes {
    /// Information about the send notification action.
    public struct SendNotificationActionDefinition {
        /// Notification content. Supports variable injection. For more information, see [JSONPath reference](https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html) in the Amazon Connect Administrators Guide.
        /// This member is required.
        public var content: Swift.String?
        /// Content type format.
        /// This member is required.
        public var contentType: ConnectClientTypes.NotificationContentType?
        /// Notification delivery method.
        /// This member is required.
        public var deliveryMethod: ConnectClientTypes.NotificationDeliveryType?
        /// Notification recipient.
        /// This member is required.
        public var recipient: ConnectClientTypes.NotificationRecipientType?
        /// The subject of the email if the delivery method is EMAIL. Supports variable injection. For more information, see [JSONPath reference](https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html) in the Amazon Connect Administrators Guide.
        public var subject: Swift.String?

        public init(
            content: Swift.String? = nil,
            contentType: ConnectClientTypes.NotificationContentType? = nil,
            deliveryMethod: ConnectClientTypes.NotificationDeliveryType? = nil,
            recipient: ConnectClientTypes.NotificationRecipientType? = nil,
            subject: Swift.String? = nil
        )
        {
            self.content = content
            self.contentType = contentType
            self.deliveryMethod = deliveryMethod
            self.recipient = recipient
            self.subject = subject
        }
    }

}

extension ConnectClientTypes {
    /// Information about the submit automated evaluation action.
    public struct SubmitAutoEvaluationActionDefinition {
        /// The identifier of the auto-evaluation enabled form.
        /// This member is required.
        public var evaluationFormId: Swift.String?

        public init(
            evaluationFormId: Swift.String? = nil
        )
        {
            self.evaluationFormId = evaluationFormId
        }
    }

}

extension ConnectClientTypes {

    public enum ReferenceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case attachment
        case date
        case email
        case number
        case string
        case url
        case sdkUnknown(Swift.String)

        public static var allCases: [ReferenceType] {
            return [
                .attachment,
                .date,
                .email,
                .number,
                .string,
                .url
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .attachment: return "ATTACHMENT"
            case .date: return "DATE"
            case .email: return "EMAIL"
            case .number: return "NUMBER"
            case .string: return "STRING"
            case .url: return "URL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// Well-formed data on a contact, used by agents to complete a contact request. You can have up to 4,096 UTF-8 bytes across all references for a contact.
    public struct Reference {
        /// The type of the reference. DATE must be of type Epoch timestamp.
        /// This member is required.
        public var type: ConnectClientTypes.ReferenceType?
        /// A valid value for the reference. For example, for a URL reference, a formatted URL that is displayed to an agent in the Contact Control Panel (CCP).
        /// This member is required.
        public var value: Swift.String?

        public init(
            type: ConnectClientTypes.ReferenceType? = nil,
            value: Swift.String? = nil
        )
        {
            self.type = type
            self.value = value
        }
    }

}

extension ConnectClientTypes {
    /// Information about the task action.
    public struct TaskActionDefinition {
        /// The identifier of the flow.
        /// This member is required.
        public var contactFlowId: Swift.String?
        /// The description. Supports variable injection. For more information, see [JSONPath reference](https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html) in the Amazon Connect Administrators Guide.
        public var description: Swift.String?
        /// The name. Supports variable injection. For more information, see [JSONPath reference](https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html) in the Amazon Connect Administrators Guide.
        /// This member is required.
        public var name: Swift.String?
        /// Information about the reference when the referenceType is URL. Otherwise, null. (Supports variable injection in the Value field.)
        public var references: [Swift.String: ConnectClientTypes.Reference]?

        public init(
            contactFlowId: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            references: [Swift.String: ConnectClientTypes.Reference]? = nil
        )
        {
            self.contactFlowId = contactFlowId
            self.description = description
            self.name = name
            self.references = references
        }
    }

}

extension ConnectClientTypes {
    /// The UpdateCase action definition.
    public struct UpdateCaseActionDefinition {
        /// An array of objects with Field ID and Value data.
        /// This member is required.
        public var fields: [ConnectClientTypes.FieldValue]?

        public init(
            fields: [ConnectClientTypes.FieldValue]? = nil
        )
        {
            self.fields = fields
        }
    }

}

extension ConnectClientTypes {
    /// Information about the action to be performed when a rule is triggered.
    public struct RuleAction {
        /// The type of action that creates a rule.
        /// This member is required.
        public var actionType: ConnectClientTypes.ActionType?
        /// Information about the contact category action. Supported only for TriggerEventSource values: OnPostCallAnalysisAvailable | OnRealTimeCallAnalysisAvailable | OnRealTimeChatAnalysisAvailable | OnPostChatAnalysisAvailable | OnZendeskTicketCreate | OnZendeskTicketStatusUpdate | OnSalesforceCaseCreate
        public var assignContactCategoryAction: ConnectClientTypes.AssignContactCategoryActionDefinition?
        /// Information about the create case action. Supported only for TriggerEventSource values: OnPostCallAnalysisAvailable | OnPostChatAnalysisAvailable.
        public var createCaseAction: ConnectClientTypes.CreateCaseActionDefinition?
        /// Information about the end associated tasks action. Supported only for TriggerEventSource values: OnCaseUpdate.
        public var endAssociatedTasksAction: ConnectClientTypes.EndAssociatedTasksActionDefinition?
        /// Information about the EventBridge action. Supported only for TriggerEventSource values: OnPostCallAnalysisAvailable | OnRealTimeCallAnalysisAvailable | OnRealTimeChatAnalysisAvailable | OnPostChatAnalysisAvailable | OnContactEvaluationSubmit | OnMetricDataUpdate
        public var eventBridgeAction: ConnectClientTypes.EventBridgeActionDefinition?
        /// Information about the send notification action. Supported only for TriggerEventSource values: OnPostCallAnalysisAvailable | OnRealTimeCallAnalysisAvailable | OnRealTimeChatAnalysisAvailable | OnPostChatAnalysisAvailable | OnContactEvaluationSubmit | OnMetricDataUpdate
        public var sendNotificationAction: ConnectClientTypes.SendNotificationActionDefinition?
        /// Information about the submit automated evaluation action.
        public var submitAutoEvaluationAction: ConnectClientTypes.SubmitAutoEvaluationActionDefinition?
        /// Information about the task action. This field is required if TriggerEventSource is one of the following values: OnZendeskTicketCreate | OnZendeskTicketStatusUpdate | OnSalesforceCaseCreate
        public var taskAction: ConnectClientTypes.TaskActionDefinition?
        /// Information about the update case action. Supported only for TriggerEventSource values: OnCaseCreate | OnCaseUpdate.
        public var updateCaseAction: ConnectClientTypes.UpdateCaseActionDefinition?

        public init(
            actionType: ConnectClientTypes.ActionType? = nil,
            assignContactCategoryAction: ConnectClientTypes.AssignContactCategoryActionDefinition? = nil,
            createCaseAction: ConnectClientTypes.CreateCaseActionDefinition? = nil,
            endAssociatedTasksAction: ConnectClientTypes.EndAssociatedTasksActionDefinition? = nil,
            eventBridgeAction: ConnectClientTypes.EventBridgeActionDefinition? = nil,
            sendNotificationAction: ConnectClientTypes.SendNotificationActionDefinition? = nil,
            submitAutoEvaluationAction: ConnectClientTypes.SubmitAutoEvaluationActionDefinition? = nil,
            taskAction: ConnectClientTypes.TaskActionDefinition? = nil,
            updateCaseAction: ConnectClientTypes.UpdateCaseActionDefinition? = nil
        )
        {
            self.actionType = actionType
            self.assignContactCategoryAction = assignContactCategoryAction
            self.createCaseAction = createCaseAction
            self.endAssociatedTasksAction = endAssociatedTasksAction
            self.eventBridgeAction = eventBridgeAction
            self.sendNotificationAction = sendNotificationAction
            self.submitAutoEvaluationAction = submitAutoEvaluationAction
            self.taskAction = taskAction
            self.updateCaseAction = updateCaseAction
        }
    }

}

extension ConnectClientTypes {

    public enum RulePublishStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case draft
        case published
        case sdkUnknown(Swift.String)

        public static var allCases: [RulePublishStatus] {
            return [
                .draft,
                .published
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .draft: return "DRAFT"
            case .published: return "PUBLISHED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {

    public enum EventSourceName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case oncasecreate
        case oncaseupdate
        case oncontactevaluationsubmit
        case onmetricdataupdate
        case onpostcallanalysisavailable
        case onpostchatanalysisavailable
        case onrealtimecallanalysisavailable
        case onrealtimechatanalysisavailable
        case onsalesforcecasecreate
        case onzendeskticketcreate
        case onzendeskticketstatusupdate
        case sdkUnknown(Swift.String)

        public static var allCases: [EventSourceName] {
            return [
                .oncasecreate,
                .oncaseupdate,
                .oncontactevaluationsubmit,
                .onmetricdataupdate,
                .onpostcallanalysisavailable,
                .onpostchatanalysisavailable,
                .onrealtimecallanalysisavailable,
                .onrealtimechatanalysisavailable,
                .onsalesforcecasecreate,
                .onzendeskticketcreate,
                .onzendeskticketstatusupdate
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .oncasecreate: return "OnCaseCreate"
            case .oncaseupdate: return "OnCaseUpdate"
            case .oncontactevaluationsubmit: return "OnContactEvaluationSubmit"
            case .onmetricdataupdate: return "OnMetricDataUpdate"
            case .onpostcallanalysisavailable: return "OnPostCallAnalysisAvailable"
            case .onpostchatanalysisavailable: return "OnPostChatAnalysisAvailable"
            case .onrealtimecallanalysisavailable: return "OnRealTimeCallAnalysisAvailable"
            case .onrealtimechatanalysisavailable: return "OnRealTimeChatAnalysisAvailable"
            case .onsalesforcecasecreate: return "OnSalesforceCaseCreate"
            case .onzendeskticketcreate: return "OnZendeskTicketCreate"
            case .onzendeskticketstatusupdate: return "OnZendeskTicketStatusUpdate"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// The name of the event source. This field is required if TriggerEventSource is one of the following values: OnZendeskTicketCreate | OnZendeskTicketStatusUpdate | OnSalesforceCaseCreate | OnContactEvaluationSubmit | OnMetricDataUpdate.
    public struct RuleTriggerEventSource {
        /// The name of the event source.
        /// This member is required.
        public var eventSourceName: ConnectClientTypes.EventSourceName?
        /// The identifier for the integration association.
        public var integrationAssociationId: Swift.String?

        public init(
            eventSourceName: ConnectClientTypes.EventSourceName? = nil,
            integrationAssociationId: Swift.String? = nil
        )
        {
            self.eventSourceName = eventSourceName
            self.integrationAssociationId = integrationAssociationId
        }
    }

}

public struct CreateRuleInput {
    /// A list of actions to be run when the rule is triggered.
    /// This member is required.
    public var actions: [ConnectClientTypes.RuleAction]?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The conditions of the rule.
    /// This member is required.
    public var function: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A unique name for the rule.
    /// This member is required.
    public var name: Swift.String?
    /// The publish status of the rule.
    /// This member is required.
    public var publishStatus: ConnectClientTypes.RulePublishStatus?
    /// The event source to trigger the rule.
    /// This member is required.
    public var triggerEventSource: ConnectClientTypes.RuleTriggerEventSource?

    public init(
        actions: [ConnectClientTypes.RuleAction]? = nil,
        clientToken: Swift.String? = nil,
        function: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        publishStatus: ConnectClientTypes.RulePublishStatus? = nil,
        triggerEventSource: ConnectClientTypes.RuleTriggerEventSource? = nil
    )
    {
        self.actions = actions
        self.clientToken = clientToken
        self.function = function
        self.instanceId = instanceId
        self.name = name
        self.publishStatus = publishStatus
        self.triggerEventSource = triggerEventSource
    }
}

public struct CreateRuleOutput {
    /// The Amazon Resource Name (ARN) of the rule.
    /// This member is required.
    public var ruleArn: Swift.String?
    /// A unique identifier for the rule.
    /// This member is required.
    public var ruleId: Swift.String?

    public init(
        ruleArn: Swift.String? = nil,
        ruleId: Swift.String? = nil
    )
    {
        self.ruleArn = ruleArn
        self.ruleId = ruleId
    }
}

extension ConnectClientTypes {
    /// This API is in preview release for Amazon Connect and is subject to change. A third-party application's metadata.
    public struct Application {
        /// The permissions that the agent is granted on the application. Only the ACCESS permission is supported.
        public var applicationPermissions: [Swift.String]?
        /// Namespace of the application that you want to give access to.
        public var namespace: Swift.String?

        public init(
            applicationPermissions: [Swift.String]? = nil,
            namespace: Swift.String? = nil
        )
        {
            self.applicationPermissions = applicationPermissions
            self.namespace = namespace
        }
    }

}

public struct CreateSecurityProfileInput {
    /// The identifier of the hierarchy group that a security profile uses to restrict access to resources in Amazon Connect.
    public var allowedAccessControlHierarchyGroupId: Swift.String?
    /// The list of tags that a security profile uses to restrict access to resources in Amazon Connect.
    public var allowedAccessControlTags: [Swift.String: Swift.String]?
    /// A list of third-party applications that the security profile will give access to.
    public var applications: [ConnectClientTypes.Application]?
    /// The description of the security profile.
    public var description: Swift.String?
    /// The list of resources that a security profile applies hierarchy restrictions to in Amazon Connect. Following are acceptable ResourceNames: User.
    public var hierarchyRestrictedResources: [Swift.String]?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Permissions assigned to the security profile. For a list of valid permissions, see [List of security profile permissions](https://docs.aws.amazon.com/connect/latest/adminguide/security-profile-list.html).
    public var permissions: [Swift.String]?
    /// The name of the security profile.
    /// This member is required.
    public var securityProfileName: Swift.String?
    /// The list of resources that a security profile applies tag restrictions to in Amazon Connect. Following are acceptable ResourceNames: User | SecurityProfile | Queue | RoutingProfile
    public var tagRestrictedResources: [Swift.String]?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String: Swift.String]?

    public init(
        allowedAccessControlHierarchyGroupId: Swift.String? = nil,
        allowedAccessControlTags: [Swift.String: Swift.String]? = nil,
        applications: [ConnectClientTypes.Application]? = nil,
        description: Swift.String? = nil,
        hierarchyRestrictedResources: [Swift.String]? = nil,
        instanceId: Swift.String? = nil,
        permissions: [Swift.String]? = nil,
        securityProfileName: Swift.String? = nil,
        tagRestrictedResources: [Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.allowedAccessControlHierarchyGroupId = allowedAccessControlHierarchyGroupId
        self.allowedAccessControlTags = allowedAccessControlTags
        self.applications = applications
        self.description = description
        self.hierarchyRestrictedResources = hierarchyRestrictedResources
        self.instanceId = instanceId
        self.permissions = permissions
        self.securityProfileName = securityProfileName
        self.tagRestrictedResources = tagRestrictedResources
        self.tags = tags
    }
}

public struct CreateSecurityProfileOutput {
    /// The Amazon Resource Name (ARN) for the security profile.
    public var securityProfileArn: Swift.String?
    /// The identifier for the security profle.
    public var securityProfileId: Swift.String?

    public init(
        securityProfileArn: Swift.String? = nil,
        securityProfileId: Swift.String? = nil
    )
    {
        self.securityProfileArn = securityProfileArn
        self.securityProfileId = securityProfileId
    }
}

extension ConnectClientTypes {

    public enum PropertyValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case invalidFormat
        case notSupported
        case referencedResourceNotFound
        case requiredPropertyMissing
        case resourceNameAlreadyExists
        case uniqueConstraintViolated
        case sdkUnknown(Swift.String)

        public static var allCases: [PropertyValidationExceptionReason] {
            return [
                .invalidFormat,
                .notSupported,
                .referencedResourceNotFound,
                .requiredPropertyMissing,
                .resourceNameAlreadyExists,
                .uniqueConstraintViolated
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .invalidFormat: return "INVALID_FORMAT"
            case .notSupported: return "NOT_SUPPORTED"
            case .referencedResourceNotFound: return "REFERENCED_RESOURCE_NOT_FOUND"
            case .requiredPropertyMissing: return "REQUIRED_PROPERTY_MISSING"
            case .resourceNameAlreadyExists: return "RESOURCE_NAME_ALREADY_EXISTS"
            case .uniqueConstraintViolated: return "UNIQUE_CONSTRAINT_VIOLATED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// Contains information about why a property is not valid.
    public struct PropertyValidationExceptionProperty {
        /// A message describing why the property is not valid.
        /// This member is required.
        public var message: Swift.String?
        /// The full property path.
        /// This member is required.
        public var propertyPath: Swift.String?
        /// Why the property is not valid.
        /// This member is required.
        public var reason: ConnectClientTypes.PropertyValidationExceptionReason?

        public init(
            message: Swift.String? = nil,
            propertyPath: Swift.String? = nil,
            reason: ConnectClientTypes.PropertyValidationExceptionReason? = nil
        )
        {
            self.message = message
            self.propertyPath = propertyPath
            self.reason = reason
        }
    }

}

/// The property is not valid.
public struct PropertyValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        public internal(set) var propertyList: [ConnectClientTypes.PropertyValidationExceptionProperty]? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PropertyValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        propertyList: [ConnectClientTypes.PropertyValidationExceptionProperty]? = nil
    )
    {
        self.properties.message = message
        self.properties.propertyList = propertyList
    }
}

extension ConnectClientTypes {
    /// The identifier of the task template field.
    public struct TaskTemplateFieldIdentifier {
        /// The name of the task template field.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension ConnectClientTypes {
    /// A field that is invisible to an agent.
    public struct InvisibleFieldInfo {
        /// Identifier of the invisible field.
        public var id: ConnectClientTypes.TaskTemplateFieldIdentifier?

        public init(
            id: ConnectClientTypes.TaskTemplateFieldIdentifier? = nil
        )
        {
            self.id = id
        }
    }

}

extension ConnectClientTypes {
    /// Indicates a field that is read-only to an agent.
    public struct ReadOnlyFieldInfo {
        /// Identifier of the read-only field.
        public var id: ConnectClientTypes.TaskTemplateFieldIdentifier?

        public init(
            id: ConnectClientTypes.TaskTemplateFieldIdentifier? = nil
        )
        {
            self.id = id
        }
    }

}

extension ConnectClientTypes {
    /// Information about a required field.
    public struct RequiredFieldInfo {
        /// The unique identifier for the field.
        public var id: ConnectClientTypes.TaskTemplateFieldIdentifier?

        public init(
            id: ConnectClientTypes.TaskTemplateFieldIdentifier? = nil
        )
        {
            self.id = id
        }
    }

}

extension ConnectClientTypes {
    /// Describes constraints that apply to the template fields.
    public struct TaskTemplateConstraints {
        /// Lists the fields that are invisible to agents.
        public var invisibleFields: [ConnectClientTypes.InvisibleFieldInfo]?
        /// Lists the fields that are read-only to agents, and cannot be edited.
        public var readOnlyFields: [ConnectClientTypes.ReadOnlyFieldInfo]?
        /// Lists the fields that are required to be filled by agents.
        public var requiredFields: [ConnectClientTypes.RequiredFieldInfo]?

        public init(
            invisibleFields: [ConnectClientTypes.InvisibleFieldInfo]? = nil,
            readOnlyFields: [ConnectClientTypes.ReadOnlyFieldInfo]? = nil,
            requiredFields: [ConnectClientTypes.RequiredFieldInfo]? = nil
        )
        {
            self.invisibleFields = invisibleFields
            self.readOnlyFields = readOnlyFields
            self.requiredFields = requiredFields
        }
    }

}

extension ConnectClientTypes {
    /// Describes a default field and its corresponding value.
    public struct TaskTemplateDefaultFieldValue {
        /// Default value for the field.
        public var defaultValue: Swift.String?
        /// Identifier of a field.
        public var id: ConnectClientTypes.TaskTemplateFieldIdentifier?

        public init(
            defaultValue: Swift.String? = nil,
            id: ConnectClientTypes.TaskTemplateFieldIdentifier? = nil
        )
        {
            self.defaultValue = defaultValue
            self.id = id
        }
    }

}

extension ConnectClientTypes {
    /// Describes default values for fields on a template.
    public struct TaskTemplateDefaults {
        /// Default value for the field.
        public var defaultFieldValues: [ConnectClientTypes.TaskTemplateDefaultFieldValue]?

        public init(
            defaultFieldValues: [ConnectClientTypes.TaskTemplateDefaultFieldValue]? = nil
        )
        {
            self.defaultFieldValues = defaultFieldValues
        }
    }

}

extension ConnectClientTypes {

    public enum TaskTemplateFieldType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case boolean
        case dateTime
        case description
        case email
        case name
        case number
        case quickConnect
        case scheduledTime
        case singleSelect
        case text
        case textArea
        case url
        case sdkUnknown(Swift.String)

        public static var allCases: [TaskTemplateFieldType] {
            return [
                .boolean,
                .dateTime,
                .description,
                .email,
                .name,
                .number,
                .quickConnect,
                .scheduledTime,
                .singleSelect,
                .text,
                .textArea,
                .url
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .boolean: return "BOOLEAN"
            case .dateTime: return "DATE_TIME"
            case .description: return "DESCRIPTION"
            case .email: return "EMAIL"
            case .name: return "NAME"
            case .number: return "NUMBER"
            case .quickConnect: return "QUICK_CONNECT"
            case .scheduledTime: return "SCHEDULED_TIME"
            case .singleSelect: return "SINGLE_SELECT"
            case .text: return "TEXT"
            case .textArea: return "TEXT_AREA"
            case .url: return "URL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// Describes a single task template field.
    public struct TaskTemplateField {
        /// The description of the field.
        public var description: Swift.String?
        /// The unique identifier for the field.
        /// This member is required.
        public var id: ConnectClientTypes.TaskTemplateFieldIdentifier?
        /// A list of options for a single select field.
        public var singleSelectOptions: [Swift.String]?
        /// Indicates the type of field.
        public var type: ConnectClientTypes.TaskTemplateFieldType?

        public init(
            description: Swift.String? = nil,
            id: ConnectClientTypes.TaskTemplateFieldIdentifier? = nil,
            singleSelectOptions: [Swift.String]? = nil,
            type: ConnectClientTypes.TaskTemplateFieldType? = nil
        )
        {
            self.description = description
            self.id = id
            self.singleSelectOptions = singleSelectOptions
            self.type = type
        }
    }

}

extension ConnectClientTypes {

    public enum TaskTemplateStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [TaskTemplateStatus] {
            return [
                .active,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateTaskTemplateInput {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// Constraints that are applicable to the fields listed.
    public var constraints: ConnectClientTypes.TaskTemplateConstraints?
    /// The identifier of the flow that runs by default when a task is created by referencing this template.
    public var contactFlowId: Swift.String?
    /// The default values for fields when a task is created by referencing this template.
    public var defaults: ConnectClientTypes.TaskTemplateDefaults?
    /// The description of the task template.
    public var description: Swift.String?
    /// Fields that are part of the template.
    /// This member is required.
    public var fields: [ConnectClientTypes.TaskTemplateField]?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the task template.
    /// This member is required.
    public var name: Swift.String?
    /// Marks a template as ACTIVE or INACTIVE for a task to refer to it. Tasks can only be created from ACTIVE templates. If a template is marked as INACTIVE, then a task that refers to this template cannot be created.
    public var status: ConnectClientTypes.TaskTemplateStatus?

    public init(
        clientToken: Swift.String? = nil,
        constraints: ConnectClientTypes.TaskTemplateConstraints? = nil,
        contactFlowId: Swift.String? = nil,
        defaults: ConnectClientTypes.TaskTemplateDefaults? = nil,
        description: Swift.String? = nil,
        fields: [ConnectClientTypes.TaskTemplateField]? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        status: ConnectClientTypes.TaskTemplateStatus? = nil
    )
    {
        self.clientToken = clientToken
        self.constraints = constraints
        self.contactFlowId = contactFlowId
        self.defaults = defaults
        self.description = description
        self.fields = fields
        self.instanceId = instanceId
        self.name = name
        self.status = status
    }
}

public struct CreateTaskTemplateOutput {
    /// The Amazon Resource Name (ARN) for the task template resource.
    /// This member is required.
    public var arn: Swift.String?
    /// The identifier of the task template resource.
    /// This member is required.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

/// The resource is not ready.
public struct ResourceNotReadyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotReadyException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateTrafficDistributionGroupInput {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// A description for the traffic distribution group.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance that has been replicated. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name for the traffic distribution group.
    /// This member is required.
    public var name: Swift.String?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.tags = tags
    }
}

public struct CreateTrafficDistributionGroupOutput {
    /// The Amazon Resource Name (ARN) of the traffic distribution group.
    public var arn: Swift.String?
    /// The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

extension ConnectClientTypes {

    public enum UseCaseType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case connectCampaigns
        case rulesEvaluation
        case sdkUnknown(Swift.String)

        public static var allCases: [UseCaseType] {
            return [
                .connectCampaigns,
                .rulesEvaluation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .connectCampaigns: return "CONNECT_CAMPAIGNS"
            case .rulesEvaluation: return "RULES_EVALUATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateUseCaseInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the integration association.
    /// This member is required.
    public var integrationAssociationId: Swift.String?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String: Swift.String]?
    /// The type of use case to associate to the integration association. Each integration association can have only one of each use case type.
    /// This member is required.
    public var useCaseType: ConnectClientTypes.UseCaseType?

    public init(
        instanceId: Swift.String? = nil,
        integrationAssociationId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        useCaseType: ConnectClientTypes.UseCaseType? = nil
    )
    {
        self.instanceId = instanceId
        self.integrationAssociationId = integrationAssociationId
        self.tags = tags
        self.useCaseType = useCaseType
    }
}

public struct CreateUseCaseOutput {
    /// The Amazon Resource Name (ARN) for the use case.
    public var useCaseArn: Swift.String?
    /// The identifier of the use case.
    public var useCaseId: Swift.String?

    public init(
        useCaseArn: Swift.String? = nil,
        useCaseId: Swift.String? = nil
    )
    {
        self.useCaseArn = useCaseArn
        self.useCaseId = useCaseId
    }
}

extension ConnectClientTypes {
    /// Contains information about the identity of a user. For Amazon Connect instances that are created with the EXISTING_DIRECTORY identity management type, FirstName, LastName, and Email cannot be updated from within Amazon Connect because they are managed by the directory.
    public struct UserIdentityInfo {
        /// The email address. If you are using SAML for identity management and include this parameter, an error is returned.
        public var email: Swift.String?
        /// The first name. This is required if you are using Amazon Connect or SAML for identity management.
        public var firstName: Swift.String?
        /// The last name. This is required if you are using Amazon Connect or SAML for identity management.
        public var lastName: Swift.String?
        /// The user's mobile number.
        public var mobile: Swift.String?
        /// The user's secondary email address. If you provide a secondary email, the user receives email notifications - other than password reset notifications - to this email address instead of to their primary email address. Pattern: (?=^.{0,265}$)[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,63}
        public var secondaryEmail: Swift.String?

        public init(
            email: Swift.String? = nil,
            firstName: Swift.String? = nil,
            lastName: Swift.String? = nil,
            mobile: Swift.String? = nil,
            secondaryEmail: Swift.String? = nil
        )
        {
            self.email = email
            self.firstName = firstName
            self.lastName = lastName
            self.mobile = mobile
            self.secondaryEmail = secondaryEmail
        }
    }

}

extension ConnectClientTypes.UserIdentityInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserIdentityInfo(mobile: \(Swift.String(describing: mobile)), email: \"CONTENT_REDACTED\", firstName: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\", secondaryEmail: \"CONTENT_REDACTED\")"}
}

extension ConnectClientTypes {

    public enum PhoneType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deskPhone
        case softPhone
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneType] {
            return [
                .deskPhone,
                .softPhone
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deskPhone: return "DESK_PHONE"
            case .softPhone: return "SOFT_PHONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// Contains information about the phone configuration settings for a user.
    public struct UserPhoneConfig {
        /// The After Call Work (ACW) timeout setting, in seconds. This parameter has a minimum value of 0 and a maximum value of 2,000,000 seconds (24 days). Enter 0 if you don't want to allocate a specific amount of ACW time. It essentially means an indefinite amount of time. When the conversation ends, ACW starts; the agent must choose Close contact to end ACW. When returned by a SearchUsers call, AfterContactWorkTimeLimit is returned in milliseconds.
        public var afterContactWorkTimeLimit: Swift.Int
        /// The Auto accept setting.
        public var autoAccept: Swift.Bool
        /// The phone number for the user's desk phone.
        public var deskPhoneNumber: Swift.String?
        /// The phone type.
        /// This member is required.
        public var phoneType: ConnectClientTypes.PhoneType?

        public init(
            afterContactWorkTimeLimit: Swift.Int = 0,
            autoAccept: Swift.Bool = false,
            deskPhoneNumber: Swift.String? = nil,
            phoneType: ConnectClientTypes.PhoneType? = nil
        )
        {
            self.afterContactWorkTimeLimit = afterContactWorkTimeLimit
            self.autoAccept = autoAccept
            self.deskPhoneNumber = deskPhoneNumber
            self.phoneType = phoneType
        }
    }

}

public struct CreateUserInput {
    /// The identifier of the user account in the directory used for identity management. If Amazon Connect cannot access the directory, you can specify this identifier to authenticate users. If you include the identifier, we assume that Amazon Connect cannot access the directory. Otherwise, the identity information is used to authenticate users from your directory. This parameter is required if you are using an existing directory for identity management in Amazon Connect when Amazon Connect cannot access your directory to authenticate users. If you are using SAML for identity management and include this parameter, an error is returned.
    public var directoryUserId: Swift.String?
    /// The identifier of the hierarchy group for the user.
    public var hierarchyGroupId: Swift.String?
    /// The information about the identity of the user.
    public var identityInfo: ConnectClientTypes.UserIdentityInfo?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The password for the user account. A password is required if you are using Amazon Connect for identity management. Otherwise, it is an error to include a password.
    public var password: Swift.String?
    /// The phone settings for the user.
    /// This member is required.
    public var phoneConfig: ConnectClientTypes.UserPhoneConfig?
    /// The identifier of the routing profile for the user.
    /// This member is required.
    public var routingProfileId: Swift.String?
    /// The identifier of the security profile for the user.
    /// This member is required.
    public var securityProfileIds: [Swift.String]?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String: Swift.String]?
    /// The user name for the account. For instances not using SAML for identity management, the user name can include up to 20 characters. If you are using SAML for identity management, the user name can include up to 64 characters from [a-zA-Z0-9_-.\@]+. Username can include @ only if used in an email format. For example:
    ///
    /// * Correct: testuser
    ///
    /// * Correct: testuser@example.com
    ///
    /// * Incorrect: testuser@example
    /// This member is required.
    public var username: Swift.String?

    public init(
        directoryUserId: Swift.String? = nil,
        hierarchyGroupId: Swift.String? = nil,
        identityInfo: ConnectClientTypes.UserIdentityInfo? = nil,
        instanceId: Swift.String? = nil,
        password: Swift.String? = nil,
        phoneConfig: ConnectClientTypes.UserPhoneConfig? = nil,
        routingProfileId: Swift.String? = nil,
        securityProfileIds: [Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        username: Swift.String? = nil
    )
    {
        self.directoryUserId = directoryUserId
        self.hierarchyGroupId = hierarchyGroupId
        self.identityInfo = identityInfo
        self.instanceId = instanceId
        self.password = password
        self.phoneConfig = phoneConfig
        self.routingProfileId = routingProfileId
        self.securityProfileIds = securityProfileIds
        self.tags = tags
        self.username = username
    }
}

extension CreateUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserInput(directoryUserId: \(Swift.String(describing: directoryUserId)), hierarchyGroupId: \(Swift.String(describing: hierarchyGroupId)), identityInfo: \(Swift.String(describing: identityInfo)), instanceId: \(Swift.String(describing: instanceId)), phoneConfig: \(Swift.String(describing: phoneConfig)), routingProfileId: \(Swift.String(describing: routingProfileId)), securityProfileIds: \(Swift.String(describing: securityProfileIds)), tags: \(Swift.String(describing: tags)), username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

public struct CreateUserOutput {
    /// The Amazon Resource Name (ARN) of the user account.
    public var userArn: Swift.String?
    /// The identifier of the user account.
    public var userId: Swift.String?

    public init(
        userArn: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.userArn = userArn
        self.userId = userId
    }
}

public struct CreateUserHierarchyGroupInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the user hierarchy group. Must not be more than 100 characters.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier for the parent hierarchy group. The user hierarchy is created at level one if the parent group ID is null.
    public var parentGroupId: Swift.String?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String: Swift.String]?

    public init(
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        parentGroupId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.instanceId = instanceId
        self.name = name
        self.parentGroupId = parentGroupId
        self.tags = tags
    }
}

public struct CreateUserHierarchyGroupOutput {
    /// The Amazon Resource Name (ARN) of the hierarchy group.
    public var hierarchyGroupArn: Swift.String?
    /// The identifier of the hierarchy group.
    public var hierarchyGroupId: Swift.String?

    public init(
        hierarchyGroupArn: Swift.String? = nil,
        hierarchyGroupId: Swift.String? = nil
    )
    {
        self.hierarchyGroupArn = hierarchyGroupArn
        self.hierarchyGroupId = hierarchyGroupId
    }
}

extension ConnectClientTypes {

    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case contact
        case contactFlow
        case hierarchyGroup
        case hierarchyLevel
        case instance
        case participant
        case phoneNumber
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .contact,
                .contactFlow,
                .hierarchyGroup,
                .hierarchyLevel,
                .instance,
                .participant,
                .phoneNumber,
                .user
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contact: return "CONTACT"
            case .contactFlow: return "CONTACT_FLOW"
            case .hierarchyGroup: return "HIERARCHY_GROUP"
            case .hierarchyLevel: return "HIERARCHY_LEVEL"
            case .instance: return "INSTANCE"
            case .participant: return "PARTICIPANT"
            case .phoneNumber: return "PHONE_NUMBER"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// That resource is already in use. Please try another.
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The identifier for the resource.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of resource.
        public internal(set) var resourceType: ConnectClientTypes.ResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: ConnectClientTypes.ResourceType? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// Displayed when rate-related API limits are exceeded.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ConnectClientTypes {
    /// View content containing all content necessary to render a view except for runtime input data and the runtime input schema, which is auto-generated by this operation.
    public struct ViewInputContent {
        /// A list of possible actions from the view.
        public var actions: [Swift.String]?
        /// The view template representing the structure of the view.
        public var template: Swift.String?

        public init(
            actions: [Swift.String]? = nil,
            template: Swift.String? = nil
        )
        {
            self.actions = actions
            self.template = template
        }
    }

}

extension ConnectClientTypes.ViewInputContent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ViewInputContent(template: \(Swift.String(describing: template)), actions: \"CONTENT_REDACTED\")"}
}

extension ConnectClientTypes {

    public enum ViewStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case published
        case saved
        case sdkUnknown(Swift.String)

        public static var allCases: [ViewStatus] {
            return [
                .published,
                .saved
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .published: return "PUBLISHED"
            case .saved: return "SAVED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateViewInput {
    /// A unique Id for each create view request to avoid duplicate view creation. For example, the view is idempotent ClientToken is provided.
    public var clientToken: Swift.String?
    /// View content containing all content necessary to render a view except for runtime input data. The total uncompressed content has a maximum file size of 400kB.
    /// This member is required.
    public var content: ConnectClientTypes.ViewInputContent?
    /// The description of the view.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the view.
    /// This member is required.
    public var name: Swift.String?
    /// Indicates the view status as either SAVED or PUBLISHED. The PUBLISHED status will initiate validation on the content.
    /// This member is required.
    public var status: ConnectClientTypes.ViewStatus?
    /// The tags associated with the view resource (not specific to view version).These tags can be used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        content: ConnectClientTypes.ViewInputContent? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        status: ConnectClientTypes.ViewStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.content = content
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.status = status
        self.tags = tags
    }
}

extension CreateViewInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateViewInput(clientToken: \(Swift.String(describing: clientToken)), content: \(Swift.String(describing: content)), description: \(Swift.String(describing: description)), instanceId: \(Swift.String(describing: instanceId)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), name: \"CONTENT_REDACTED\")"}
}

extension ConnectClientTypes {
    /// View content containing all content necessary to render a view except for runtime input data.
    public struct ViewContent {
        /// A list of possible actions from the view.
        public var actions: [Swift.String]?
        /// The data schema matching data that the view template must be provided to render.
        public var inputSchema: Swift.String?
        /// The view template representing the structure of the view.
        public var template: Swift.String?

        public init(
            actions: [Swift.String]? = nil,
            inputSchema: Swift.String? = nil,
            template: Swift.String? = nil
        )
        {
            self.actions = actions
            self.inputSchema = inputSchema
            self.template = template
        }
    }

}

extension ConnectClientTypes.ViewContent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ViewContent(template: \(Swift.String(describing: template)), actions: \"CONTENT_REDACTED\", inputSchema: \"CONTENT_REDACTED\")"}
}

extension ConnectClientTypes {

    public enum ViewType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsManaged
        case customerManaged
        case sdkUnknown(Swift.String)

        public static var allCases: [ViewType] {
            return [
                .awsManaged,
                .customerManaged
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsManaged: return "AWS_MANAGED"
            case .customerManaged: return "CUSTOMER_MANAGED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// A view resource object. Contains metadata and content necessary to render the view.
    public struct View {
        /// The Amazon Resource Name (ARN) of the view.
        public var arn: Swift.String?
        /// View content containing all content necessary to render a view except for runtime input data.
        public var content: ConnectClientTypes.ViewContent?
        /// The timestamp of when the view was created.
        public var createdTime: Foundation.Date?
        /// The description of the view.
        public var description: Swift.String?
        /// The identifier of the view.
        public var id: Swift.String?
        /// Latest timestamp of the UpdateViewContent or CreateViewVersion operations.
        public var lastModifiedTime: Foundation.Date?
        /// The name of the view.
        public var name: Swift.String?
        /// Indicates the view status as either SAVED or PUBLISHED. The PUBLISHED status will initiate validation on the content.
        public var status: ConnectClientTypes.ViewStatus?
        /// The tags associated with the view resource (not specific to view version).
        public var tags: [Swift.String: Swift.String]?
        /// The type of the view - CUSTOMER_MANAGED.
        public var type: ConnectClientTypes.ViewType?
        /// Current version of the view.
        public var version: Swift.Int
        /// The description of the version.
        public var versionDescription: Swift.String?
        /// Indicates the checksum value of the latest published view content.
        public var viewContentSha256: Swift.String?

        public init(
            arn: Swift.String? = nil,
            content: ConnectClientTypes.ViewContent? = nil,
            createdTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            status: ConnectClientTypes.ViewStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            type: ConnectClientTypes.ViewType? = nil,
            version: Swift.Int = 0,
            versionDescription: Swift.String? = nil,
            viewContentSha256: Swift.String? = nil
        )
        {
            self.arn = arn
            self.content = content
            self.createdTime = createdTime
            self.description = description
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.status = status
            self.tags = tags
            self.type = type
            self.version = version
            self.versionDescription = versionDescription
            self.viewContentSha256 = viewContentSha256
        }
    }

}

extension ConnectClientTypes.View: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "View(arn: \(Swift.String(describing: arn)), content: \(Swift.String(describing: content)), createdTime: \(Swift.String(describing: createdTime)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)), version: \(Swift.String(describing: version)), versionDescription: \(Swift.String(describing: versionDescription)), viewContentSha256: \(Swift.String(describing: viewContentSha256)), name: \"CONTENT_REDACTED\")"}
}

public struct CreateViewOutput {
    /// A view resource object. Contains metadata and content necessary to render the view.
    public var view: ConnectClientTypes.View?

    public init(
        view: ConnectClientTypes.View? = nil
    )
    {
        self.view = view
    }
}

public struct CreateViewVersionInput {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The description for the version being published.
    public var versionDescription: Swift.String?
    /// Indicates the checksum value of the latest published view content.
    public var viewContentSha256: Swift.String?
    /// The identifier of the view. Both ViewArn and ViewId can be used.
    /// This member is required.
    public var viewId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        versionDescription: Swift.String? = nil,
        viewContentSha256: Swift.String? = nil,
        viewId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.versionDescription = versionDescription
        self.viewContentSha256 = viewContentSha256
        self.viewId = viewId
    }
}

public struct CreateViewVersionOutput {
    /// All view data is contained within the View object.
    public var view: ConnectClientTypes.View?

    public init(
        view: ConnectClientTypes.View? = nil
    )
    {
        self.view = view
    }
}

public struct CreateVocabularyInput {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/). If a create request is received more than once with same client token, subsequent requests return the previous response without creating a vocabulary again.
    public var clientToken: Swift.String?
    /// The content of the custom vocabulary in plain-text format with a table of values. Each row in the table represents a word or a phrase, described with Phrase, IPA, SoundsLike, and DisplayAs fields. Separate the fields with TAB characters. The size limit is 50KB. For more information, see [Create a custom vocabulary using a table](https://docs.aws.amazon.com/transcribe/latest/dg/custom-vocabulary.html#create-vocabulary-table).
    /// This member is required.
    public var content: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see [What is Amazon Transcribe?](https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html)
    /// This member is required.
    public var languageCode: ConnectClientTypes.VocabularyLanguageCode?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String: Swift.String]?
    /// A unique name of the custom vocabulary.
    /// This member is required.
    public var vocabularyName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        content: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        languageCode: ConnectClientTypes.VocabularyLanguageCode? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        vocabularyName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.content = content
        self.instanceId = instanceId
        self.languageCode = languageCode
        self.tags = tags
        self.vocabularyName = vocabularyName
    }
}

extension ConnectClientTypes {

    public enum VocabularyState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creationFailed
        case creationInProgress
        case deleteInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [VocabularyState] {
            return [
                .active,
                .creationFailed,
                .creationInProgress,
                .deleteInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creationFailed: return "CREATION_FAILED"
            case .creationInProgress: return "CREATION_IN_PROGRESS"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateVocabularyOutput {
    /// The current state of the custom vocabulary.
    /// This member is required.
    public var state: ConnectClientTypes.VocabularyState?
    /// The Amazon Resource Name (ARN) of the custom vocabulary.
    /// This member is required.
    public var vocabularyArn: Swift.String?
    /// The identifier of the custom vocabulary.
    /// This member is required.
    public var vocabularyId: Swift.String?

    public init(
        state: ConnectClientTypes.VocabularyState? = nil,
        vocabularyArn: Swift.String? = nil,
        vocabularyId: Swift.String? = nil
    )
    {
        self.state = state
        self.vocabularyArn = vocabularyArn
        self.vocabularyId = vocabularyId
    }
}

public struct DeactivateEvaluationFormInput {
    /// The unique identifier for the evaluation form.
    /// This member is required.
    public var evaluationFormId: Swift.String?
    /// A version of the evaluation form. If the version property is not provided, the latest version of the evaluation form is deactivated.
    /// This member is required.
    public var evaluationFormVersion: Swift.Int?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        evaluationFormId: Swift.String? = nil,
        evaluationFormVersion: Swift.Int? = 0,
        instanceId: Swift.String? = nil
    )
    {
        self.evaluationFormId = evaluationFormId
        self.evaluationFormVersion = evaluationFormVersion
        self.instanceId = instanceId
    }
}

public struct DeactivateEvaluationFormOutput {
    /// The Amazon Resource Name (ARN) for the evaluation form resource.
    /// This member is required.
    public var evaluationFormArn: Swift.String?
    /// The unique identifier for the evaluation form.
    /// This member is required.
    public var evaluationFormId: Swift.String?
    /// The version of the deactivated evaluation form resource.
    /// This member is required.
    public var evaluationFormVersion: Swift.Int

    public init(
        evaluationFormArn: Swift.String? = nil,
        evaluationFormId: Swift.String? = nil,
        evaluationFormVersion: Swift.Int = 0
    )
    {
        self.evaluationFormArn = evaluationFormArn
        self.evaluationFormId = evaluationFormId
        self.evaluationFormVersion = evaluationFormVersion
    }
}

/// Request to DeleteAttachedFile API
public struct DeleteAttachedFileInput {
    /// The resource to which the attached file is (being) uploaded to. [Cases](https://docs.aws.amazon.com/connect/latest/APIReference/API_connect-cases_CreateCase.html) are the only current supported resource. This value must be a valid ARN.
    /// This member is required.
    public var associatedResourceArn: Swift.String?
    /// The unique identifier of the attached file resource.
    /// This member is required.
    public var fileId: Swift.String?
    /// The unique identifier of the Connect instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        associatedResourceArn: Swift.String? = nil,
        fileId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.associatedResourceArn = associatedResourceArn
        self.fileId = fileId
        self.instanceId = instanceId
    }
}

/// Response from DeleteAttachedFile API
public struct DeleteAttachedFileOutput {

    public init() { }
}

public struct DeleteContactEvaluationInput {
    /// A unique identifier for the contact evaluation.
    /// This member is required.
    public var evaluationId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        evaluationId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.evaluationId = evaluationId
        self.instanceId = instanceId
    }
}

public struct DeleteContactFlowInput {
    /// The identifier of the flow.
    /// This member is required.
    public var contactFlowId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        contactFlowId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.contactFlowId = contactFlowId
        self.instanceId = instanceId
    }
}

public struct DeleteContactFlowOutput {

    public init() { }
}

public struct DeleteContactFlowModuleInput {
    /// The identifier of the flow module.
    /// This member is required.
    public var contactFlowModuleId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        contactFlowModuleId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.contactFlowModuleId = contactFlowModuleId
        self.instanceId = instanceId
    }
}

public struct DeleteContactFlowModuleOutput {

    public init() { }
}

public struct DeleteEvaluationFormInput {
    /// The unique identifier for the evaluation form.
    /// This member is required.
    public var evaluationFormId: Swift.String?
    /// The unique identifier for the evaluation form.
    public var evaluationFormVersion: Swift.Int?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        evaluationFormId: Swift.String? = nil,
        evaluationFormVersion: Swift.Int? = 0,
        instanceId: Swift.String? = nil
    )
    {
        self.evaluationFormId = evaluationFormId
        self.evaluationFormVersion = evaluationFormVersion
        self.instanceId = instanceId
    }
}

public struct DeleteHoursOfOperationInput {
    /// The identifier for the hours of operation.
    /// This member is required.
    public var hoursOfOperationId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        hoursOfOperationId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.hoursOfOperationId = hoursOfOperationId
        self.instanceId = instanceId
    }
}

public struct DeleteInstanceInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        instanceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

public struct DeleteIntegrationAssociationInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the integration association.
    /// This member is required.
    public var integrationAssociationId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        integrationAssociationId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.integrationAssociationId = integrationAssociationId
    }
}

public struct DeletePredefinedAttributeInput {
    /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the predefined attribute.
    /// This member is required.
    public var name: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.name = name
    }
}

public struct DeletePromptInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A unique identifier for the prompt.
    /// This member is required.
    public var promptId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        promptId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.promptId = promptId
    }
}

public struct DeleteQueueInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the queue.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.queueId = queueId
    }
}

public struct DeleteQuickConnectInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the quick connect.
    /// This member is required.
    public var quickConnectId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        quickConnectId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.quickConnectId = quickConnectId
    }
}

public struct DeleteRoutingProfileInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the routing profile.
    /// This member is required.
    public var routingProfileId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        routingProfileId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.routingProfileId = routingProfileId
    }
}

public struct DeleteRuleInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A unique identifier for the rule.
    /// This member is required.
    public var ruleId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        ruleId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.ruleId = ruleId
    }
}

public struct DeleteSecurityProfileInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the security profle.
    /// This member is required.
    public var securityProfileId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        securityProfileId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.securityProfileId = securityProfileId
    }
}

public struct DeleteTaskTemplateInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A unique identifier for the task template.
    /// This member is required.
    public var taskTemplateId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        taskTemplateId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.taskTemplateId = taskTemplateId
    }
}

public struct DeleteTaskTemplateOutput {

    public init() { }
}

public struct DeleteTrafficDistributionGroupInput {
    /// The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.
    /// This member is required.
    public var trafficDistributionGroupId: Swift.String?

    public init(
        trafficDistributionGroupId: Swift.String? = nil
    )
    {
        self.trafficDistributionGroupId = trafficDistributionGroupId
    }
}

public struct DeleteTrafficDistributionGroupOutput {

    public init() { }
}

public struct DeleteUseCaseInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the integration association.
    /// This member is required.
    public var integrationAssociationId: Swift.String?
    /// The identifier for the use case.
    /// This member is required.
    public var useCaseId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        integrationAssociationId: Swift.String? = nil,
        useCaseId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.integrationAssociationId = integrationAssociationId
        self.useCaseId = useCaseId
    }
}

public struct DeleteUserInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the user.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.userId = userId
    }
}

public struct DeleteUserHierarchyGroupInput {
    /// The identifier of the hierarchy group.
    /// This member is required.
    public var hierarchyGroupId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        hierarchyGroupId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.hierarchyGroupId = hierarchyGroupId
        self.instanceId = instanceId
    }
}

public struct DeleteViewInput {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the view. Both ViewArn and ViewId can be used.
    /// This member is required.
    public var viewId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        viewId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.viewId = viewId
    }
}

public struct DeleteViewOutput {

    public init() { }
}

public struct DeleteViewVersionInput {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the view. Both ViewArn and ViewId can be used.
    /// This member is required.
    public var viewId: Swift.String?
    /// The version number of the view.
    /// This member is required.
    public var viewVersion: Swift.Int?

    public init(
        instanceId: Swift.String? = nil,
        viewId: Swift.String? = nil,
        viewVersion: Swift.Int? = 0
    )
    {
        self.instanceId = instanceId
        self.viewId = viewId
        self.viewVersion = viewVersion
    }
}

public struct DeleteViewVersionOutput {

    public init() { }
}

public struct DeleteVocabularyInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the custom vocabulary.
    /// This member is required.
    public var vocabularyId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        vocabularyId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.vocabularyId = vocabularyId
    }
}

public struct DeleteVocabularyOutput {
    /// The current state of the custom vocabulary.
    /// This member is required.
    public var state: ConnectClientTypes.VocabularyState?
    /// The Amazon Resource Name (ARN) of the custom vocabulary.
    /// This member is required.
    public var vocabularyArn: Swift.String?
    /// The identifier of the custom vocabulary.
    /// This member is required.
    public var vocabularyId: Swift.String?

    public init(
        state: ConnectClientTypes.VocabularyState? = nil,
        vocabularyArn: Swift.String? = nil,
        vocabularyId: Swift.String? = nil
    )
    {
        self.state = state
        self.vocabularyArn = vocabularyArn
        self.vocabularyId = vocabularyId
    }
}

public struct DescribeAgentStatusInput {
    /// The identifier for the agent status.
    /// This member is required.
    public var agentStatusId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        agentStatusId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.agentStatusId = agentStatusId
        self.instanceId = instanceId
    }
}

public struct DescribeAgentStatusOutput {
    /// The agent status.
    public var agentStatus: ConnectClientTypes.AgentStatus?

    public init(
        agentStatus: ConnectClientTypes.AgentStatus? = nil
    )
    {
        self.agentStatus = agentStatus
    }
}

public struct DescribeAuthenticationProfileInput {
    /// A unique identifier for the authentication profile.
    /// This member is required.
    public var authenticationProfileId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        authenticationProfileId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.authenticationProfileId = authenticationProfileId
        self.instanceId = instanceId
    }
}

extension ConnectClientTypes {
    /// This API is in preview release for Amazon Connect and is subject to change. To request access to this API, contact Amazon Web Services Support. Information about an authentication profile. An authentication profile is a resource that stores the authentication settings for users in your contact center. You use authentication profiles to set up IP address range restrictions and session timeouts. For more information, see [Set IP address restrictions or session timeouts](https://docs.aws.amazon.com/connect/latest/adminguide/authentication-profiles.html).
    public struct AuthenticationProfile {
        /// A list of IP address range strings that are allowed to access the Amazon Connect instance. For more information about how to configure IP addresses, see [Configure IP address based access control](https://docs.aws.amazon.com/connect/latest/adminguide/authentication-profiles.html#configure-ip-based-ac) in the Amazon Connect Administrator Guide.
        public var allowedIps: [Swift.String]?
        /// The Amazon Resource Name (ARN) for the authentication profile.
        public var arn: Swift.String?
        /// A list of IP address range strings that are blocked from accessing the Amazon Connect instance. For more information about how to configure IP addresses, see [Configure IP address based access control](https://docs.aws.amazon.com/connect/latest/adminguide/authentication-profiles.html#configure-ip-based-ac) in the Amazon Connect Administrator Guide.
        public var blockedIps: [Swift.String]?
        /// The timestamp when the authentication profile was created.
        public var createdTime: Foundation.Date?
        /// The description for the authentication profile.
        public var description: Swift.String?
        /// A unique identifier for the authentication profile.
        public var id: Swift.String?
        /// Shows whether the authentication profile is the default authentication profile for the Amazon Connect instance. The default authentication profile applies to all agents in an Amazon Connect instance, unless overridden by another authentication profile.
        public var isDefault: Swift.Bool
        /// The Amazon Web Services Region where the authentication profile was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when the authentication profile was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// The long lived session duration for users logged in to Amazon Connect, in minutes. After this time period, users must log in again. For more information, see [Configure the session duration](https://docs.aws.amazon.com/connect/latest/adminguide/authentication-profiles.html#configure-session-timeouts) in the Amazon Connect Administrator Guide.
        public var maxSessionDuration: Swift.Int?
        /// The name for the authentication profile.
        public var name: Swift.String?
        /// The short lived session duration configuration for users logged in to Amazon Connect, in minutes. This value determines the maximum possible time before an agent is authenticated. For more information, see [Configure the session duration](https://docs.aws.amazon.com/connect/latest/adminguide/authentication-profiles.html#configure-session-timeouts) in the Amazon Connect Administrator Guide.
        public var periodicSessionDuration: Swift.Int?

        public init(
            allowedIps: [Swift.String]? = nil,
            arn: Swift.String? = nil,
            blockedIps: [Swift.String]? = nil,
            createdTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            isDefault: Swift.Bool = false,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            maxSessionDuration: Swift.Int? = nil,
            name: Swift.String? = nil,
            periodicSessionDuration: Swift.Int? = nil
        )
        {
            self.allowedIps = allowedIps
            self.arn = arn
            self.blockedIps = blockedIps
            self.createdTime = createdTime
            self.description = description
            self.id = id
            self.isDefault = isDefault
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.maxSessionDuration = maxSessionDuration
            self.name = name
            self.periodicSessionDuration = periodicSessionDuration
        }
    }

}

public struct DescribeAuthenticationProfileOutput {
    /// The authentication profile object being described.
    public var authenticationProfile: ConnectClientTypes.AuthenticationProfile?

    public init(
        authenticationProfile: ConnectClientTypes.AuthenticationProfile? = nil
    )
    {
        self.authenticationProfile = authenticationProfile
    }
}

public struct DescribeContactInput {
    /// The identifier of the contact.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        contactId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.contactId = contactId
        self.instanceId = instanceId
    }
}

extension ConnectClientTypes {

    public enum AnsweringMachineDetectionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case amdError
        case amdNotApplicable
        case amdUnanswered
        case amdUnresolved
        case answered
        case error
        case faxMachineDetected
        case humanAnswered
        case sitToneBusy
        case sitToneDetected
        case sitToneInvalidNumber
        case undetected
        case voicemailBeep
        case voicemailNoBeep
        case sdkUnknown(Swift.String)

        public static var allCases: [AnsweringMachineDetectionStatus] {
            return [
                .amdError,
                .amdNotApplicable,
                .amdUnanswered,
                .amdUnresolved,
                .answered,
                .error,
                .faxMachineDetected,
                .humanAnswered,
                .sitToneBusy,
                .sitToneDetected,
                .sitToneInvalidNumber,
                .undetected,
                .voicemailBeep,
                .voicemailNoBeep
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .amdError: return "AMD_ERROR"
            case .amdNotApplicable: return "AMD_NOT_APPLICABLE"
            case .amdUnanswered: return "AMD_UNANSWERED"
            case .amdUnresolved: return "AMD_UNRESOLVED"
            case .answered: return "ANSWERED"
            case .error: return "ERROR"
            case .faxMachineDetected: return "FAX_MACHINE_DETECTED"
            case .humanAnswered: return "HUMAN_ANSWERED"
            case .sitToneBusy: return "SIT_TONE_BUSY"
            case .sitToneDetected: return "SIT_TONE_DETECTED"
            case .sitToneInvalidNumber: return "SIT_TONE_INVALID_NUMBER"
            case .undetected: return "UNDETECTED"
            case .voicemailBeep: return "VOICEMAIL_BEEP"
            case .voicemailNoBeep: return "VOICEMAIL_NO_BEEP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// Information about the Customer on the contact.
    public struct Customer {
        /// The configuration for the allowed capabilities for participants present over the call.
        public var capabilities: ConnectClientTypes.ParticipantCapabilities?
        /// Information regarding Customer’s device.
        public var deviceInfo: ConnectClientTypes.DeviceInfo?

        public init(
            capabilities: ConnectClientTypes.ParticipantCapabilities? = nil,
            deviceInfo: ConnectClientTypes.DeviceInfo? = nil
        )
        {
            self.capabilities = capabilities
            self.deviceInfo = deviceInfo
        }
    }

}

extension ConnectClientTypes {
    /// Information about customer’s voice activity.
    public struct CustomerVoiceActivity {
        /// Timestamp that measures the end of the customer greeting from an outbound voice call.
        public var greetingEndTimestamp: Foundation.Date?
        /// Timestamp that measures the beginning of the customer greeting from an outbound voice call.
        public var greetingStartTimestamp: Foundation.Date?

        public init(
            greetingEndTimestamp: Foundation.Date? = nil,
            greetingStartTimestamp: Foundation.Date? = nil
        )
        {
            self.greetingEndTimestamp = greetingEndTimestamp
            self.greetingStartTimestamp = greetingStartTimestamp
        }
    }

}

extension ConnectClientTypes {
    /// Information about the call disconnect experience.
    public struct DisconnectDetails {
        /// Indicates the potential disconnection issues for a call. This field is not populated if the service does not detect potential issues.
        public var potentialDisconnectIssue: Swift.String?

        public init(
            potentialDisconnectIssue: Swift.String? = nil
        )
        {
            self.potentialDisconnectIssue = potentialDisconnectIssue
        }
    }

}

extension ConnectClientTypes {
    /// Information about the quality of the Customer's media connection
    public struct CustomerQualityMetrics {
        /// Information about the audio quality of the Customer
        public var audio: ConnectClientTypes.AudioQualityMetricsInfo?

        public init(
            audio: ConnectClientTypes.AudioQualityMetricsInfo? = nil
        )
        {
            self.audio = audio
        }
    }

}

extension ConnectClientTypes {
    /// Information about the quality of the participant's media connection.
    public struct QualityMetrics {
        /// Information about the quality of Agent media connection.
        public var agent: ConnectClientTypes.AgentQualityMetrics?
        /// Information about the quality of Customer media connection.
        public var customer: ConnectClientTypes.CustomerQualityMetrics?

        public init(
            agent: ConnectClientTypes.AgentQualityMetrics? = nil,
            customer: ConnectClientTypes.CustomerQualityMetrics? = nil
        )
        {
            self.agent = agent
            self.customer = customer
        }
    }

}

extension ConnectClientTypes {
    /// If this contact was queued, this contains information about the queue.
    public struct QueueInfo {
        /// The timestamp when the contact was added to the queue.
        public var enqueueTimestamp: Foundation.Date?
        /// The unique identifier for the queue.
        public var id: Swift.String?

        public init(
            enqueueTimestamp: Foundation.Date? = nil,
            id: Swift.String? = nil
        )
        {
            self.enqueueTimestamp = enqueueTimestamp
            self.id = id
        }
    }

}

extension ConnectClientTypes {
    /// An object to specify the expiration of a routing step.
    public struct Expiry {
        /// The number of seconds to wait before expiring the routing step.
        public var durationInSeconds: Swift.Int?
        /// The timestamp indicating when the routing step expires.
        public var expiryTimestamp: Foundation.Date?

        public init(
            durationInSeconds: Swift.Int? = nil,
            expiryTimestamp: Foundation.Date? = nil
        )
        {
            self.durationInSeconds = durationInSeconds
            self.expiryTimestamp = expiryTimestamp
        }
    }

}

extension ConnectClientTypes {
    /// An object to define AgentsCriteria.
    public struct MatchCriteria {
        /// An object to define agentIds.
        public var agentsCriteria: ConnectClientTypes.AgentsCriteria?

        public init(
            agentsCriteria: ConnectClientTypes.AgentsCriteria? = nil
        )
        {
            self.agentsCriteria = agentsCriteria
        }
    }

}

extension ConnectClientTypes {
    /// An object to specify the predefined attribute condition.
    public struct AttributeCondition {
        /// The operator of the condition.
        public var comparisonOperator: Swift.String?
        /// An object to define AgentsCriteria.
        public var matchCriteria: ConnectClientTypes.MatchCriteria?
        /// The name of predefined attribute.
        public var name: Swift.String?
        /// The proficiency level of the condition.
        public var proficiencyLevel: Swift.Float?
        /// The value of predefined attribute.
        public var value: Swift.String?

        public init(
            comparisonOperator: Swift.String? = nil,
            matchCriteria: ConnectClientTypes.MatchCriteria? = nil,
            name: Swift.String? = nil,
            proficiencyLevel: Swift.Float? = nil,
            value: Swift.String? = nil
        )
        {
            self.comparisonOperator = comparisonOperator
            self.matchCriteria = matchCriteria
            self.name = name
            self.proficiencyLevel = proficiencyLevel
            self.value = value
        }
    }

}

extension ConnectClientTypes {

    public enum RoutingCriteriaStepStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case expired
        case inactive
        case joined
        case sdkUnknown(Swift.String)

        public static var allCases: [RoutingCriteriaStepStatus] {
            return [
                .active,
                .expired,
                .inactive,
                .joined
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .expired: return "EXPIRED"
            case .inactive: return "INACTIVE"
            case .joined: return "JOINED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// A value for a segment attribute. This is structured as a map where the key is valueString and the value is a string.
    public struct SegmentAttributeValue {
        /// The value of a segment attribute.
        public var valueString: Swift.String?

        public init(
            valueString: Swift.String? = nil
        )
        {
            self.valueString = valueString
        }
    }

}

extension ConnectClientTypes {
    /// Information about Amazon Connect Wisdom.
    public struct WisdomInfo {
        /// The Amazon Resource Name (ARN) of the Wisdom session.
        public var sessionArn: Swift.String?

        public init(
            sessionArn: Swift.String? = nil
        )
        {
            self.sessionArn = sessionArn
        }
    }

}

public struct DescribeContactEvaluationInput {
    /// A unique identifier for the contact evaluation.
    /// This member is required.
    public var evaluationId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        evaluationId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.evaluationId = evaluationId
        self.instanceId = instanceId
    }
}

extension ConnectClientTypes {
    /// Information about answer data for a contact evaluation. Answer data must be either string, numeric, or not applicable.
    public enum EvaluationAnswerData {
        /// The string value for an answer in a contact evaluation.
        case stringvalue(Swift.String)
        /// The numeric value for an answer in a contact evaluation.
        case numericvalue(Swift.Double)
        /// The flag to mark the question as not applicable.
        case notapplicable(Swift.Bool)
        case sdkUnknown(Swift.String)
    }

}

extension ConnectClientTypes {
    /// Information about output answers for a contact evaluation.
    public struct EvaluationAnswerOutput {
        /// The system suggested value for an answer in a contact evaluation.
        public var systemSuggestedValue: ConnectClientTypes.EvaluationAnswerData?
        /// The value for an answer in a contact evaluation.
        public var value: ConnectClientTypes.EvaluationAnswerData?

        public init(
            systemSuggestedValue: ConnectClientTypes.EvaluationAnswerData? = nil,
            value: ConnectClientTypes.EvaluationAnswerData? = nil
        )
        {
            self.systemSuggestedValue = systemSuggestedValue
            self.value = value
        }
    }

}

extension ConnectClientTypes {
    /// Information about scores of a contact evaluation item (section or question).
    public struct EvaluationScore {
        /// The flag that marks the item as automatic fail. If the item or a child item gets an automatic fail answer, this flag will be true.
        public var automaticFail: Swift.Bool
        /// The flag to mark the item as not applicable for scoring.
        public var notApplicable: Swift.Bool
        /// The score percentage for an item in a contact evaluation.
        public var percentage: Swift.Double

        public init(
            automaticFail: Swift.Bool = false,
            notApplicable: Swift.Bool = false,
            percentage: Swift.Double = 0.0
        )
        {
            self.automaticFail = automaticFail
            self.notApplicable = notApplicable
            self.percentage = percentage
        }
    }

}

extension ConnectClientTypes {
    /// Metadata information about a contact evaluation.
    public struct EvaluationMetadata {
        /// The identifier of the agent who performed the contact.
        public var contactAgentId: Swift.String?
        /// The identifier of the contact in this instance of Amazon Connect.
        /// This member is required.
        public var contactId: Swift.String?
        /// The Amazon Resource Name (ARN) of the user who last updated the evaluation.
        /// This member is required.
        public var evaluatorArn: Swift.String?
        /// The overall score of the contact evaluation.
        public var score: ConnectClientTypes.EvaluationScore?

        public init(
            contactAgentId: Swift.String? = nil,
            contactId: Swift.String? = nil,
            evaluatorArn: Swift.String? = nil,
            score: ConnectClientTypes.EvaluationScore? = nil
        )
        {
            self.contactAgentId = contactAgentId
            self.contactId = contactId
            self.evaluatorArn = evaluatorArn
            self.score = score
        }
    }

}

extension ConnectClientTypes {
    /// Information about notes for a contact evaluation.
    public struct EvaluationNote {
        /// The note for an item (section or question) in a contact evaluation. Even though a note in an evaluation can have up to 3072 chars, there is also a limit on the total number of chars for all the notes in the evaluation combined. Assuming there are N questions in the evaluation being submitted, then the max char limit for all notes combined is N x 1024.
        public var value: Swift.String?

        public init(
            value: Swift.String? = nil
        )
        {
            self.value = value
        }
    }

}

extension ConnectClientTypes {

    public enum EvaluationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case draft
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [EvaluationStatus] {
            return [
                .draft,
                .submitted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .draft: return "DRAFT"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// Information about a contact evaluation.
    public struct Evaluation {
        /// A map of question identifiers to answer value.
        /// This member is required.
        public var answers: [Swift.String: ConnectClientTypes.EvaluationAnswerOutput]?
        /// The timestamp for when the evaluation was created.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) for the contact evaluation resource.
        /// This member is required.
        public var evaluationArn: Swift.String?
        /// A unique identifier for the contact evaluation.
        /// This member is required.
        public var evaluationId: Swift.String?
        /// The timestamp for when the evaluation was last updated.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// Metadata about the contact evaluation.
        /// This member is required.
        public var metadata: ConnectClientTypes.EvaluationMetadata?
        /// A map of question identifiers to note value.
        /// This member is required.
        public var notes: [Swift.String: ConnectClientTypes.EvaluationNote]?
        /// A map of item (section or question) identifiers to score value.
        public var scores: [Swift.String: ConnectClientTypes.EvaluationScore]?
        /// The status of the contact evaluation.
        /// This member is required.
        public var status: ConnectClientTypes.EvaluationStatus?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public var tags: [Swift.String: Swift.String]?

        public init(
            answers: [Swift.String: ConnectClientTypes.EvaluationAnswerOutput]? = nil,
            createdTime: Foundation.Date? = nil,
            evaluationArn: Swift.String? = nil,
            evaluationId: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            metadata: ConnectClientTypes.EvaluationMetadata? = nil,
            notes: [Swift.String: ConnectClientTypes.EvaluationNote]? = nil,
            scores: [Swift.String: ConnectClientTypes.EvaluationScore]? = nil,
            status: ConnectClientTypes.EvaluationStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.answers = answers
            self.createdTime = createdTime
            self.evaluationArn = evaluationArn
            self.evaluationId = evaluationId
            self.lastModifiedTime = lastModifiedTime
            self.metadata = metadata
            self.notes = notes
            self.scores = scores
            self.status = status
            self.tags = tags
        }
    }

}

/// The flow has not been published.
public struct ContactFlowNotPublishedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ContactFlowNotPublishedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DescribeContactFlowInput {
    /// The identifier of the flow.
    /// This member is required.
    public var contactFlowId: Swift.String?
    /// The identifier of the Amazon Connect instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        contactFlowId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.contactFlowId = contactFlowId
        self.instanceId = instanceId
    }
}

extension ConnectClientTypes {

    public enum ContactFlowState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case archived
        case sdkUnknown(Swift.String)

        public static var allCases: [ContactFlowState] {
            return [
                .active,
                .archived
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .archived: return "ARCHIVED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// Contains information about a flow.
    public struct ContactFlow {
        /// The Amazon Resource Name (ARN) of the flow.
        public var arn: Swift.String?
        /// The JSON string that represents the content of the flow. For an example, see [Example flow in Amazon Connect Flow language](https://docs.aws.amazon.com/connect/latest/APIReference/flow-language-example.html). Length Constraints: Minimum length of 1. Maximum length of 256000.
        public var content: Swift.String?
        /// The description of the flow.
        public var description: Swift.String?
        /// The identifier of the flow.
        public var id: Swift.String?
        /// The name of the flow.
        public var name: Swift.String?
        /// The type of flow.
        public var state: ConnectClientTypes.ContactFlowState?
        /// The status of the contact flow.
        public var status: ConnectClientTypes.ContactFlowStatus?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public var tags: [Swift.String: Swift.String]?
        /// The type of the flow. For descriptions of the available types, see [Choose a flow type](https://docs.aws.amazon.com/connect/latest/adminguide/create-contact-flow.html#contact-flow-types) in the Amazon Connect Administrator Guide.
        public var type: ConnectClientTypes.ContactFlowType?

        public init(
            arn: Swift.String? = nil,
            content: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            state: ConnectClientTypes.ContactFlowState? = nil,
            status: ConnectClientTypes.ContactFlowStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            type: ConnectClientTypes.ContactFlowType? = nil
        )
        {
            self.arn = arn
            self.content = content
            self.description = description
            self.id = id
            self.name = name
            self.state = state
            self.status = status
            self.tags = tags
            self.type = type
        }
    }

}

public struct DescribeContactFlowOutput {
    /// Information about the flow.
    public var contactFlow: ConnectClientTypes.ContactFlow?

    public init(
        contactFlow: ConnectClientTypes.ContactFlow? = nil
    )
    {
        self.contactFlow = contactFlow
    }
}

public struct DescribeContactFlowModuleInput {
    /// The identifier of the flow module.
    /// This member is required.
    public var contactFlowModuleId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        contactFlowModuleId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.contactFlowModuleId = contactFlowModuleId
        self.instanceId = instanceId
    }
}

extension ConnectClientTypes {

    public enum ContactFlowModuleState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case archived
        case sdkUnknown(Swift.String)

        public static var allCases: [ContactFlowModuleState] {
            return [
                .active,
                .archived
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .archived: return "ARCHIVED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {

    public enum ContactFlowModuleStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case published
        case saved
        case sdkUnknown(Swift.String)

        public static var allCases: [ContactFlowModuleStatus] {
            return [
                .published,
                .saved
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .published: return "PUBLISHED"
            case .saved: return "SAVED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// Contains information about a flow module.
    public struct ContactFlowModule {
        /// The Amazon Resource Name (ARN).
        public var arn: Swift.String?
        /// The JSON string that represents the content of the flow. For an example, see [Example flow in Amazon Connect Flow language](https://docs.aws.amazon.com/connect/latest/APIReference/flow-language-example.html).
        public var content: Swift.String?
        /// The description of the flow module.
        public var description: Swift.String?
        /// The identifier of the flow module.
        public var id: Swift.String?
        /// The name of the flow module.
        public var name: Swift.String?
        /// The type of flow module.
        public var state: ConnectClientTypes.ContactFlowModuleState?
        /// The status of the flow module.
        public var status: ConnectClientTypes.ContactFlowModuleStatus?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            content: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            state: ConnectClientTypes.ContactFlowModuleState? = nil,
            status: ConnectClientTypes.ContactFlowModuleStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.content = content
            self.description = description
            self.id = id
            self.name = name
            self.state = state
            self.status = status
            self.tags = tags
        }
    }

}

public struct DescribeContactFlowModuleOutput {
    /// Information about the flow module.
    public var contactFlowModule: ConnectClientTypes.ContactFlowModule?

    public init(
        contactFlowModule: ConnectClientTypes.ContactFlowModule? = nil
    )
    {
        self.contactFlowModule = contactFlowModule
    }
}

public struct DescribeEvaluationFormInput {
    /// A unique identifier for the contact evaluation.
    /// This member is required.
    public var evaluationFormId: Swift.String?
    /// A version of the evaluation form.
    public var evaluationFormVersion: Swift.Int?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        evaluationFormId: Swift.String? = nil,
        evaluationFormVersion: Swift.Int? = 0,
        instanceId: Swift.String? = nil
    )
    {
        self.evaluationFormId = evaluationFormId
        self.evaluationFormVersion = evaluationFormVersion
        self.instanceId = instanceId
    }
}

extension ConnectClientTypes {

    public enum EvaluationFormVersionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case draft
        case sdkUnknown(Swift.String)

        public static var allCases: [EvaluationFormVersionStatus] {
            return [
                .active,
                .draft
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .draft: return "DRAFT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeHoursOfOperationInput {
    /// The identifier for the hours of operation.
    /// This member is required.
    public var hoursOfOperationId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        hoursOfOperationId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.hoursOfOperationId = hoursOfOperationId
        self.instanceId = instanceId
    }
}

extension ConnectClientTypes {
    /// Information about of the hours of operation.
    public struct HoursOfOperation {
        /// Configuration information for the hours of operation.
        public var config: [ConnectClientTypes.HoursOfOperationConfig]?
        /// The description for the hours of operation.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) for the hours of operation.
        public var hoursOfOperationArn: Swift.String?
        /// The identifier for the hours of operation.
        public var hoursOfOperationId: Swift.String?
        /// The Amazon Web Services Region where this resource was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when this resource was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// The name for the hours of operation.
        public var name: Swift.String?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public var tags: [Swift.String: Swift.String]?
        /// The time zone for the hours of operation.
        public var timeZone: Swift.String?

        public init(
            config: [ConnectClientTypes.HoursOfOperationConfig]? = nil,
            description: Swift.String? = nil,
            hoursOfOperationArn: Swift.String? = nil,
            hoursOfOperationId: Swift.String? = nil,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            timeZone: Swift.String? = nil
        )
        {
            self.config = config
            self.description = description
            self.hoursOfOperationArn = hoursOfOperationArn
            self.hoursOfOperationId = hoursOfOperationId
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.tags = tags
            self.timeZone = timeZone
        }
    }

}

public struct DescribeHoursOfOperationOutput {
    /// The hours of operation.
    public var hoursOfOperation: ConnectClientTypes.HoursOfOperation?

    public init(
        hoursOfOperation: ConnectClientTypes.HoursOfOperation? = nil
    )
    {
        self.hoursOfOperation = hoursOfOperation
    }
}

public struct DescribeInstanceInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        instanceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

extension ConnectClientTypes {

    public enum InstanceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creationFailed
        case creationInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceStatus] {
            return [
                .active,
                .creationFailed,
                .creationInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creationFailed: return "CREATION_FAILED"
            case .creationInProgress: return "CREATION_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// Relevant details why the instance was not successfully created.
    public struct InstanceStatusReason {
        /// The message.
        public var message: Swift.String?

        public init(
            message: Swift.String? = nil
        )
        {
            self.message = message
        }
    }

}

extension ConnectClientTypes {
    /// The Amazon Connect instance.
    public struct Instance {
        /// The Amazon Resource Name (ARN) of the instance.
        public var arn: Swift.String?
        /// When the instance was created.
        public var createdTime: Foundation.Date?
        /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
        public var id: Swift.String?
        /// The identity management type.
        public var identityManagementType: ConnectClientTypes.DirectoryType?
        /// Whether inbound calls are enabled.
        public var inboundCallsEnabled: Swift.Bool?
        /// This URL allows contact center users to access the Amazon Connect admin website.
        public var instanceAccessUrl: Swift.String?
        /// The alias of instance.
        public var instanceAlias: Swift.String?
        /// The state of the instance.
        public var instanceStatus: ConnectClientTypes.InstanceStatus?
        /// Whether outbound calls are enabled.
        public var outboundCallsEnabled: Swift.Bool?
        /// The service role of the instance.
        public var serviceRole: Swift.String?
        /// Relevant details why the instance was not successfully created.
        public var statusReason: ConnectClientTypes.InstanceStatusReason?
        /// The tags of an instance.
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            id: Swift.String? = nil,
            identityManagementType: ConnectClientTypes.DirectoryType? = nil,
            inboundCallsEnabled: Swift.Bool? = nil,
            instanceAccessUrl: Swift.String? = nil,
            instanceAlias: Swift.String? = nil,
            instanceStatus: ConnectClientTypes.InstanceStatus? = nil,
            outboundCallsEnabled: Swift.Bool? = nil,
            serviceRole: Swift.String? = nil,
            statusReason: ConnectClientTypes.InstanceStatusReason? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.id = id
            self.identityManagementType = identityManagementType
            self.inboundCallsEnabled = inboundCallsEnabled
            self.instanceAccessUrl = instanceAccessUrl
            self.instanceAlias = instanceAlias
            self.instanceStatus = instanceStatus
            self.outboundCallsEnabled = outboundCallsEnabled
            self.serviceRole = serviceRole
            self.statusReason = statusReason
            self.tags = tags
        }
    }

}

extension ConnectClientTypes.Instance: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Instance(arn: \(Swift.String(describing: arn)), createdTime: \(Swift.String(describing: createdTime)), id: \(Swift.String(describing: id)), identityManagementType: \(Swift.String(describing: identityManagementType)), inboundCallsEnabled: \(Swift.String(describing: inboundCallsEnabled)), instanceAccessUrl: \(Swift.String(describing: instanceAccessUrl)), instanceStatus: \(Swift.String(describing: instanceStatus)), outboundCallsEnabled: \(Swift.String(describing: outboundCallsEnabled)), serviceRole: \(Swift.String(describing: serviceRole)), statusReason: \(Swift.String(describing: statusReason)), tags: \(Swift.String(describing: tags)), instanceAlias: \"CONTENT_REDACTED\")"}
}

extension ConnectClientTypes {

    public enum InstanceReplicationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case instanceReplicationComplete
        case instanceReplicationDeletionFailed
        case instanceReplicationFailed
        case instanceReplicationInProgress
        case instanceReplicaDeleting
        case resourceReplicationNotStarted
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceReplicationStatus] {
            return [
                .instanceReplicationComplete,
                .instanceReplicationDeletionFailed,
                .instanceReplicationFailed,
                .instanceReplicationInProgress,
                .instanceReplicaDeleting,
                .resourceReplicationNotStarted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .instanceReplicationComplete: return "INSTANCE_REPLICATION_COMPLETE"
            case .instanceReplicationDeletionFailed: return "INSTANCE_REPLICATION_DELETION_FAILED"
            case .instanceReplicationFailed: return "INSTANCE_REPLICATION_FAILED"
            case .instanceReplicationInProgress: return "INSTANCE_REPLICATION_IN_PROGRESS"
            case .instanceReplicaDeleting: return "INSTANCE_REPLICA_DELETING"
            case .resourceReplicationNotStarted: return "RESOURCE_REPLICATION_NOT_STARTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// Status information about the replication process, where you use the [ReplicateInstance](https://docs.aws.amazon.com/connect/latest/APIReference/API_ReplicateInstance.html) API to create a replica of your Amazon Connect instance in another Amazon Web Services Region. For more information, see [Set up Amazon Connect Global Resiliency](https://docs.aws.amazon.com/connect/latest/adminguide/setup-connect-global-resiliency.html) in the Amazon Connect Administrator Guide.
    public struct ReplicationStatusSummary {
        /// The Amazon Web Services Region. This can be either the source or the replica Region, depending where it appears in the summary list.
        public var region: Swift.String?
        /// The state of the replication.
        public var replicationStatus: ConnectClientTypes.InstanceReplicationStatus?
        /// A description of the replication status. Use this information to resolve any issues that are preventing the successful replication of your Amazon Connect instance to another Region.
        public var replicationStatusReason: Swift.String?

        public init(
            region: Swift.String? = nil,
            replicationStatus: ConnectClientTypes.InstanceReplicationStatus? = nil,
            replicationStatusReason: Swift.String? = nil
        )
        {
            self.region = region
            self.replicationStatus = replicationStatus
            self.replicationStatusReason = replicationStatusReason
        }
    }

}

extension ConnectClientTypes {
    /// Details about the status of the replication of a source Amazon Connect instance across Amazon Web Services Regions. Use these details to understand the general status of a given replication. For information about why a replication process may fail, see [Why a ReplicateInstance call fails](https://docs.aws.amazon.com/connect/latest/adminguide/create-replica-connect-instance.html#why-replicateinstance-fails) in the Create a replica of your existing Amazon Connect instance topic in the Amazon Connect Administrator Guide.
    public struct ReplicationConfiguration {
        /// The URL that is used to sign-in to your Amazon Connect instance according to your traffic distribution group configuration. For more information about sign-in and traffic distribution groups, see [Important things to know](https://docs.aws.amazon.com/connect/latest/adminguide/setup-traffic-distribution-groups.html) in the Create traffic distribution groups topic in the Amazon Connect Administrator Guide.
        public var globalSignInEndpoint: Swift.String?
        /// A list of replication status summaries. The summaries contain details about the replication of configuration information for Amazon Connect resources, for each Amazon Web Services Region.
        public var replicationStatusSummaryList: [ConnectClientTypes.ReplicationStatusSummary]?
        /// The Amazon Web Services Region where the source Amazon Connect instance was created. This is the Region where the [ReplicateInstance](https://docs.aws.amazon.com/connect/latest/APIReference/API_ReplicateInstance.html) API was called to start the replication process.
        public var sourceRegion: Swift.String?

        public init(
            globalSignInEndpoint: Swift.String? = nil,
            replicationStatusSummaryList: [ConnectClientTypes.ReplicationStatusSummary]? = nil,
            sourceRegion: Swift.String? = nil
        )
        {
            self.globalSignInEndpoint = globalSignInEndpoint
            self.replicationStatusSummaryList = replicationStatusSummaryList
            self.sourceRegion = sourceRegion
        }
    }

}

public struct DescribeInstanceOutput {
    /// The name of the instance.
    public var instance: ConnectClientTypes.Instance?
    /// Status information about the replication process. This field is included only when you are using the [ReplicateInstance](https://docs.aws.amazon.com/connect/latest/APIReference/API_ReplicateInstance.html) API to replicate an Amazon Connect instance across Amazon Web Services Regions. For information about replicating Amazon Connect instances, see [Create a replica of your existing Amazon Connect instance](https://docs.aws.amazon.com/connect/latest/adminguide/create-replica-connect-instance.html) in the Amazon Connect Administrator Guide.
    public var replicationConfiguration: ConnectClientTypes.ReplicationConfiguration?

    public init(
        instance: ConnectClientTypes.Instance? = nil,
        replicationConfiguration: ConnectClientTypes.ReplicationConfiguration? = nil
    )
    {
        self.instance = instance
        self.replicationConfiguration = replicationConfiguration
    }
}

extension ConnectClientTypes {

    public enum InstanceAttributeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case autoResolveBestVoices
        case contactflowLogs
        case contactLens
        case earlyMedia
        case enhancedChatMonitoring
        case enhancedContactMonitoring
        case highVolumeOutbound
        case inboundCalls
        case multiPartyConference
        case outboundCalls
        case useCustomTtsVoices
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceAttributeType] {
            return [
                .autoResolveBestVoices,
                .contactflowLogs,
                .contactLens,
                .earlyMedia,
                .enhancedChatMonitoring,
                .enhancedContactMonitoring,
                .highVolumeOutbound,
                .inboundCalls,
                .multiPartyConference,
                .outboundCalls,
                .useCustomTtsVoices
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .autoResolveBestVoices: return "AUTO_RESOLVE_BEST_VOICES"
            case .contactflowLogs: return "CONTACTFLOW_LOGS"
            case .contactLens: return "CONTACT_LENS"
            case .earlyMedia: return "EARLY_MEDIA"
            case .enhancedChatMonitoring: return "ENHANCED_CHAT_MONITORING"
            case .enhancedContactMonitoring: return "ENHANCED_CONTACT_MONITORING"
            case .highVolumeOutbound: return "HIGH_VOLUME_OUTBOUND"
            case .inboundCalls: return "INBOUND_CALLS"
            case .multiPartyConference: return "MULTI_PARTY_CONFERENCE"
            case .outboundCalls: return "OUTBOUND_CALLS"
            case .useCustomTtsVoices: return "USE_CUSTOM_TTS_VOICES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeInstanceAttributeInput {
    /// The type of attribute.
    /// This member is required.
    public var attributeType: ConnectClientTypes.InstanceAttributeType?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        attributeType: ConnectClientTypes.InstanceAttributeType? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.attributeType = attributeType
        self.instanceId = instanceId
    }
}

extension ConnectClientTypes {
    /// A toggle for an individual feature at the instance level.
    public struct Attribute {
        /// The type of attribute.
        public var attributeType: ConnectClientTypes.InstanceAttributeType?
        /// The value of the attribute.
        public var value: Swift.String?

        public init(
            attributeType: ConnectClientTypes.InstanceAttributeType? = nil,
            value: Swift.String? = nil
        )
        {
            self.attributeType = attributeType
            self.value = value
        }
    }

}

public struct DescribeInstanceAttributeOutput {
    /// The type of attribute.
    public var attribute: ConnectClientTypes.Attribute?

    public init(
        attribute: ConnectClientTypes.Attribute? = nil
    )
    {
        self.attribute = attribute
    }
}

public struct DescribeInstanceStorageConfigInput {
    /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
    /// This member is required.
    public var associationId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A valid resource type.
    /// This member is required.
    public var resourceType: ConnectClientTypes.InstanceStorageResourceType?

    public init(
        associationId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        resourceType: ConnectClientTypes.InstanceStorageResourceType? = nil
    )
    {
        self.associationId = associationId
        self.instanceId = instanceId
        self.resourceType = resourceType
    }
}

public struct DescribeInstanceStorageConfigOutput {
    /// A valid storage type.
    public var storageConfig: ConnectClientTypes.InstanceStorageConfig?

    public init(
        storageConfig: ConnectClientTypes.InstanceStorageConfig? = nil
    )
    {
        self.storageConfig = storageConfig
    }
}

public struct DescribePhoneNumberInput {
    /// A unique identifier for the phone number.
    /// This member is required.
    public var phoneNumberId: Swift.String?

    public init(
        phoneNumberId: Swift.String? = nil
    )
    {
        self.phoneNumberId = phoneNumberId
    }
}

extension ConnectClientTypes {

    public enum PhoneNumberCountryCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ad
        case ae
        case af
        case ag
        case ai
        case al
        case am
        case an
        case ao
        case aq
        case ar
        case `as`
        case at
        case au
        case aw
        case az
        case ba
        case bb
        case bd
        case be
        case bf
        case bg
        case bh
        case bi
        case bj
        case bl
        case bm
        case bn
        case bo
        case br
        case bs
        case bt
        case bw
        case by
        case bz
        case ca
        case cc
        case cd
        case cf
        case cg
        case ch
        case ci
        case ck
        case cl
        case cm
        case cn
        case co
        case cr
        case cu
        case cv
        case cw
        case cx
        case cy
        case cz
        case de
        case dj
        case dk
        case dm
        case `do`
        case dz
        case ec
        case ee
        case eg
        case eh
        case er
        case es
        case et
        case fi
        case fj
        case fk
        case fm
        case fo
        case fr
        case ga
        case gb
        case gd
        case ge
        case gg
        case gh
        case gi
        case gl
        case gm
        case gn
        case gq
        case gr
        case gt
        case gu
        case gw
        case gy
        case hk
        case hn
        case hr
        case ht
        case hu
        case id
        case ie
        case il
        case im
        case `in`
        case io
        case iq
        case ir
        case `is`
        case it
        case je
        case jm
        case jo
        case jp
        case ke
        case kg
        case kh
        case ki
        case km
        case kn
        case kp
        case kr
        case kw
        case ky
        case kz
        case la
        case lb
        case lc
        case li
        case lk
        case lr
        case ls
        case lt
        case lu
        case lv
        case ly
        case ma
        case mc
        case md
        case me
        case mf
        case mg
        case mh
        case mk
        case ml
        case mm
        case mn
        case mo
        case mp
        case mr
        case ms
        case mt
        case mu
        case mv
        case mw
        case mx
        case my
        case mz
        case na
        case nc
        case ne
        case ng
        case ni
        case nl
        case no
        case np
        case nr
        case nu
        case nz
        case om
        case pa
        case pe
        case pf
        case pg
        case ph
        case pk
        case pl
        case pm
        case pn
        case pr
        case pt
        case pw
        case py
        case qa
        case re
        case ro
        case rs
        case ru
        case rw
        case sa
        case sb
        case sc
        case sd
        case se
        case sg
        case sh
        case si
        case sj
        case sk
        case sl
        case sm
        case sn
        case so
        case sr
        case st
        case sv
        case sx
        case sy
        case sz
        case tc
        case td
        case tg
        case th
        case tj
        case tk
        case tl
        case tm
        case tn
        case to
        case tr
        case tt
        case tv
        case tw
        case tz
        case ua
        case ug
        case us
        case uy
        case uz
        case va
        case vc
        case ve
        case vg
        case vi
        case vn
        case vu
        case wf
        case ws
        case ye
        case yt
        case za
        case zm
        case zw
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberCountryCode] {
            return [
                .ad,
                .ae,
                .af,
                .ag,
                .ai,
                .al,
                .am,
                .an,
                .ao,
                .aq,
                .ar,
                .as,
                .at,
                .au,
                .aw,
                .az,
                .ba,
                .bb,
                .bd,
                .be,
                .bf,
                .bg,
                .bh,
                .bi,
                .bj,
                .bl,
                .bm,
                .bn,
                .bo,
                .br,
                .bs,
                .bt,
                .bw,
                .by,
                .bz,
                .ca,
                .cc,
                .cd,
                .cf,
                .cg,
                .ch,
                .ci,
                .ck,
                .cl,
                .cm,
                .cn,
                .co,
                .cr,
                .cu,
                .cv,
                .cw,
                .cx,
                .cy,
                .cz,
                .de,
                .dj,
                .dk,
                .dm,
                .do,
                .dz,
                .ec,
                .ee,
                .eg,
                .eh,
                .er,
                .es,
                .et,
                .fi,
                .fj,
                .fk,
                .fm,
                .fo,
                .fr,
                .ga,
                .gb,
                .gd,
                .ge,
                .gg,
                .gh,
                .gi,
                .gl,
                .gm,
                .gn,
                .gq,
                .gr,
                .gt,
                .gu,
                .gw,
                .gy,
                .hk,
                .hn,
                .hr,
                .ht,
                .hu,
                .id,
                .ie,
                .il,
                .im,
                .in,
                .io,
                .iq,
                .ir,
                .is,
                .it,
                .je,
                .jm,
                .jo,
                .jp,
                .ke,
                .kg,
                .kh,
                .ki,
                .km,
                .kn,
                .kp,
                .kr,
                .kw,
                .ky,
                .kz,
                .la,
                .lb,
                .lc,
                .li,
                .lk,
                .lr,
                .ls,
                .lt,
                .lu,
                .lv,
                .ly,
                .ma,
                .mc,
                .md,
                .me,
                .mf,
                .mg,
                .mh,
                .mk,
                .ml,
                .mm,
                .mn,
                .mo,
                .mp,
                .mr,
                .ms,
                .mt,
                .mu,
                .mv,
                .mw,
                .mx,
                .my,
                .mz,
                .na,
                .nc,
                .ne,
                .ng,
                .ni,
                .nl,
                .no,
                .np,
                .nr,
                .nu,
                .nz,
                .om,
                .pa,
                .pe,
                .pf,
                .pg,
                .ph,
                .pk,
                .pl,
                .pm,
                .pn,
                .pr,
                .pt,
                .pw,
                .py,
                .qa,
                .re,
                .ro,
                .rs,
                .ru,
                .rw,
                .sa,
                .sb,
                .sc,
                .sd,
                .se,
                .sg,
                .sh,
                .si,
                .sj,
                .sk,
                .sl,
                .sm,
                .sn,
                .so,
                .sr,
                .st,
                .sv,
                .sx,
                .sy,
                .sz,
                .tc,
                .td,
                .tg,
                .th,
                .tj,
                .tk,
                .tl,
                .tm,
                .tn,
                .to,
                .tr,
                .tt,
                .tv,
                .tw,
                .tz,
                .ua,
                .ug,
                .us,
                .uy,
                .uz,
                .va,
                .vc,
                .ve,
                .vg,
                .vi,
                .vn,
                .vu,
                .wf,
                .ws,
                .ye,
                .yt,
                .za,
                .zm,
                .zw
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ad: return "AD"
            case .ae: return "AE"
            case .af: return "AF"
            case .ag: return "AG"
            case .ai: return "AI"
            case .al: return "AL"
            case .am: return "AM"
            case .an: return "AN"
            case .ao: return "AO"
            case .aq: return "AQ"
            case .ar: return "AR"
            case .as: return "AS"
            case .at: return "AT"
            case .au: return "AU"
            case .aw: return "AW"
            case .az: return "AZ"
            case .ba: return "BA"
            case .bb: return "BB"
            case .bd: return "BD"
            case .be: return "BE"
            case .bf: return "BF"
            case .bg: return "BG"
            case .bh: return "BH"
            case .bi: return "BI"
            case .bj: return "BJ"
            case .bl: return "BL"
            case .bm: return "BM"
            case .bn: return "BN"
            case .bo: return "BO"
            case .br: return "BR"
            case .bs: return "BS"
            case .bt: return "BT"
            case .bw: return "BW"
            case .by: return "BY"
            case .bz: return "BZ"
            case .ca: return "CA"
            case .cc: return "CC"
            case .cd: return "CD"
            case .cf: return "CF"
            case .cg: return "CG"
            case .ch: return "CH"
            case .ci: return "CI"
            case .ck: return "CK"
            case .cl: return "CL"
            case .cm: return "CM"
            case .cn: return "CN"
            case .co: return "CO"
            case .cr: return "CR"
            case .cu: return "CU"
            case .cv: return "CV"
            case .cw: return "CW"
            case .cx: return "CX"
            case .cy: return "CY"
            case .cz: return "CZ"
            case .de: return "DE"
            case .dj: return "DJ"
            case .dk: return "DK"
            case .dm: return "DM"
            case .do: return "DO"
            case .dz: return "DZ"
            case .ec: return "EC"
            case .ee: return "EE"
            case .eg: return "EG"
            case .eh: return "EH"
            case .er: return "ER"
            case .es: return "ES"
            case .et: return "ET"
            case .fi: return "FI"
            case .fj: return "FJ"
            case .fk: return "FK"
            case .fm: return "FM"
            case .fo: return "FO"
            case .fr: return "FR"
            case .ga: return "GA"
            case .gb: return "GB"
            case .gd: return "GD"
            case .ge: return "GE"
            case .gg: return "GG"
            case .gh: return "GH"
            case .gi: return "GI"
            case .gl: return "GL"
            case .gm: return "GM"
            case .gn: return "GN"
            case .gq: return "GQ"
            case .gr: return "GR"
            case .gt: return "GT"
            case .gu: return "GU"
            case .gw: return "GW"
            case .gy: return "GY"
            case .hk: return "HK"
            case .hn: return "HN"
            case .hr: return "HR"
            case .ht: return "HT"
            case .hu: return "HU"
            case .id: return "ID"
            case .ie: return "IE"
            case .il: return "IL"
            case .im: return "IM"
            case .in: return "IN"
            case .io: return "IO"
            case .iq: return "IQ"
            case .ir: return "IR"
            case .is: return "IS"
            case .it: return "IT"
            case .je: return "JE"
            case .jm: return "JM"
            case .jo: return "JO"
            case .jp: return "JP"
            case .ke: return "KE"
            case .kg: return "KG"
            case .kh: return "KH"
            case .ki: return "KI"
            case .km: return "KM"
            case .kn: return "KN"
            case .kp: return "KP"
            case .kr: return "KR"
            case .kw: return "KW"
            case .ky: return "KY"
            case .kz: return "KZ"
            case .la: return "LA"
            case .lb: return "LB"
            case .lc: return "LC"
            case .li: return "LI"
            case .lk: return "LK"
            case .lr: return "LR"
            case .ls: return "LS"
            case .lt: return "LT"
            case .lu: return "LU"
            case .lv: return "LV"
            case .ly: return "LY"
            case .ma: return "MA"
            case .mc: return "MC"
            case .md: return "MD"
            case .me: return "ME"
            case .mf: return "MF"
            case .mg: return "MG"
            case .mh: return "MH"
            case .mk: return "MK"
            case .ml: return "ML"
            case .mm: return "MM"
            case .mn: return "MN"
            case .mo: return "MO"
            case .mp: return "MP"
            case .mr: return "MR"
            case .ms: return "MS"
            case .mt: return "MT"
            case .mu: return "MU"
            case .mv: return "MV"
            case .mw: return "MW"
            case .mx: return "MX"
            case .my: return "MY"
            case .mz: return "MZ"
            case .na: return "NA"
            case .nc: return "NC"
            case .ne: return "NE"
            case .ng: return "NG"
            case .ni: return "NI"
            case .nl: return "NL"
            case .no: return "NO"
            case .np: return "NP"
            case .nr: return "NR"
            case .nu: return "NU"
            case .nz: return "NZ"
            case .om: return "OM"
            case .pa: return "PA"
            case .pe: return "PE"
            case .pf: return "PF"
            case .pg: return "PG"
            case .ph: return "PH"
            case .pk: return "PK"
            case .pl: return "PL"
            case .pm: return "PM"
            case .pn: return "PN"
            case .pr: return "PR"
            case .pt: return "PT"
            case .pw: return "PW"
            case .py: return "PY"
            case .qa: return "QA"
            case .re: return "RE"
            case .ro: return "RO"
            case .rs: return "RS"
            case .ru: return "RU"
            case .rw: return "RW"
            case .sa: return "SA"
            case .sb: return "SB"
            case .sc: return "SC"
            case .sd: return "SD"
            case .se: return "SE"
            case .sg: return "SG"
            case .sh: return "SH"
            case .si: return "SI"
            case .sj: return "SJ"
            case .sk: return "SK"
            case .sl: return "SL"
            case .sm: return "SM"
            case .sn: return "SN"
            case .so: return "SO"
            case .sr: return "SR"
            case .st: return "ST"
            case .sv: return "SV"
            case .sx: return "SX"
            case .sy: return "SY"
            case .sz: return "SZ"
            case .tc: return "TC"
            case .td: return "TD"
            case .tg: return "TG"
            case .th: return "TH"
            case .tj: return "TJ"
            case .tk: return "TK"
            case .tl: return "TL"
            case .tm: return "TM"
            case .tn: return "TN"
            case .to: return "TO"
            case .tr: return "TR"
            case .tt: return "TT"
            case .tv: return "TV"
            case .tw: return "TW"
            case .tz: return "TZ"
            case .ua: return "UA"
            case .ug: return "UG"
            case .us: return "US"
            case .uy: return "UY"
            case .uz: return "UZ"
            case .va: return "VA"
            case .vc: return "VC"
            case .ve: return "VE"
            case .vg: return "VG"
            case .vi: return "VI"
            case .vn: return "VN"
            case .vu: return "VU"
            case .wf: return "WF"
            case .ws: return "WS"
            case .ye: return "YE"
            case .yt: return "YT"
            case .za: return "ZA"
            case .zm: return "ZM"
            case .zw: return "ZW"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {

    public enum PhoneNumberWorkflowStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case claimed
        case failed
        case inprogress
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberWorkflowStatus] {
            return [
                .claimed,
                .failed,
                .inprogress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .claimed: return "CLAIMED"
            case .failed: return "FAILED"
            case .inprogress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// The status of the phone number.
    ///
    /// * CLAIMED means the previous [ClaimPhoneNumber](https://docs.aws.amazon.com/connect/latest/APIReference/API_ClaimPhoneNumber.html) or [UpdatePhoneNumber](https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumber.html) operation succeeded.
    ///
    /// * IN_PROGRESS means a [ClaimPhoneNumber](https://docs.aws.amazon.com/connect/latest/APIReference/API_ClaimPhoneNumber.html), [UpdatePhoneNumber](https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumber.html), or [UpdatePhoneNumberMetadata](https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumberMetadata.html) operation is still in progress and has not yet completed. You can call [DescribePhoneNumber](https://docs.aws.amazon.com/connect/latest/APIReference/API_DescribePhoneNumber.html) at a later time to verify if the previous operation has completed.
    ///
    /// * FAILED indicates that the previous [ClaimPhoneNumber](https://docs.aws.amazon.com/connect/latest/APIReference/API_ClaimPhoneNumber.html) or [UpdatePhoneNumber](https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumber.html) operation has failed. It will include a message indicating the failure reason. A common reason for a failure may be that the TargetArn value you are claiming or updating a phone number to has reached its limit of total claimed numbers. If you received a FAILED status from a ClaimPhoneNumber API call, you have one day to retry claiming the phone number before the number is released back to the inventory for other customers to claim.
    public struct PhoneNumberStatus {
        /// The status message.
        public var message: Swift.String?
        /// The status.
        public var status: ConnectClientTypes.PhoneNumberWorkflowStatus?

        public init(
            message: Swift.String? = nil,
            status: ConnectClientTypes.PhoneNumberWorkflowStatus? = nil
        )
        {
            self.message = message
            self.status = status
        }
    }

}

extension ConnectClientTypes {

    public enum PhoneNumberType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case did
        case shared
        case shortCode
        case thirdPartyDid
        case thirdPartyTf
        case tollFree
        case uifn
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberType] {
            return [
                .did,
                .shared,
                .shortCode,
                .thirdPartyDid,
                .thirdPartyTf,
                .tollFree,
                .uifn
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .did: return "DID"
            case .shared: return "SHARED"
            case .shortCode: return "SHORT_CODE"
            case .thirdPartyDid: return "THIRD_PARTY_DID"
            case .thirdPartyTf: return "THIRD_PARTY_TF"
            case .tollFree: return "TOLL_FREE"
            case .uifn: return "UIFN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// Information about a phone number that has been claimed to your Amazon Connect instance or traffic distribution group.
    public struct ClaimedPhoneNumberSummary {
        /// The identifier of the Amazon Connect instance that phone numbers are claimed to. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
        public var instanceId: Swift.String?
        /// The phone number. Phone numbers are formatted [+] [country code] [subscriber number including area code].
        public var phoneNumber: Swift.String?
        /// The Amazon Resource Name (ARN) of the phone number.
        public var phoneNumberArn: Swift.String?
        /// The ISO country code.
        public var phoneNumberCountryCode: ConnectClientTypes.PhoneNumberCountryCode?
        /// The description of the phone number.
        public var phoneNumberDescription: Swift.String?
        /// A unique identifier for the phone number.
        public var phoneNumberId: Swift.String?
        /// The status of the phone number.
        ///
        /// * CLAIMED means the previous [ClaimPhoneNumber](https://docs.aws.amazon.com/connect/latest/APIReference/API_ClaimPhoneNumber.html) or [UpdatePhoneNumber](https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumber.html) operation succeeded.
        ///
        /// * IN_PROGRESS means a [ClaimPhoneNumber](https://docs.aws.amazon.com/connect/latest/APIReference/API_ClaimPhoneNumber.html), [UpdatePhoneNumber](https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumber.html), or [UpdatePhoneNumberMetadata](https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumberMetadata.html) operation is still in progress and has not yet completed. You can call [DescribePhoneNumber](https://docs.aws.amazon.com/connect/latest/APIReference/API_DescribePhoneNumber.html) at a later time to verify if the previous operation has completed.
        ///
        /// * FAILED indicates that the previous [ClaimPhoneNumber](https://docs.aws.amazon.com/connect/latest/APIReference/API_ClaimPhoneNumber.html) or [UpdatePhoneNumber](https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumber.html) operation has failed. It will include a message indicating the failure reason. A common reason for a failure may be that the TargetArn value you are claiming or updating a phone number to has reached its limit of total claimed numbers. If you received a FAILED status from a ClaimPhoneNumber API call, you have one day to retry claiming the phone number before the number is released back to the inventory for other customers to claim.
        ///
        ///
        /// You will not be billed for the phone number during the 1-day period if number claiming fails.
        public var phoneNumberStatus: ConnectClientTypes.PhoneNumberStatus?
        /// The type of phone number.
        public var phoneNumberType: ConnectClientTypes.PhoneNumberType?
        /// The claimed phone number ARN that was previously imported from the external service, such as Amazon Pinpoint. If it is from Amazon Pinpoint, it looks like the ARN of the phone number that was imported from Amazon Pinpoint.
        public var sourcePhoneNumberArn: Swift.String?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public var tags: [Swift.String: Swift.String]?
        /// The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone number inbound traffic is routed through.
        public var targetArn: Swift.String?

        public init(
            instanceId: Swift.String? = nil,
            phoneNumber: Swift.String? = nil,
            phoneNumberArn: Swift.String? = nil,
            phoneNumberCountryCode: ConnectClientTypes.PhoneNumberCountryCode? = nil,
            phoneNumberDescription: Swift.String? = nil,
            phoneNumberId: Swift.String? = nil,
            phoneNumberStatus: ConnectClientTypes.PhoneNumberStatus? = nil,
            phoneNumberType: ConnectClientTypes.PhoneNumberType? = nil,
            sourcePhoneNumberArn: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            targetArn: Swift.String? = nil
        )
        {
            self.instanceId = instanceId
            self.phoneNumber = phoneNumber
            self.phoneNumberArn = phoneNumberArn
            self.phoneNumberCountryCode = phoneNumberCountryCode
            self.phoneNumberDescription = phoneNumberDescription
            self.phoneNumberId = phoneNumberId
            self.phoneNumberStatus = phoneNumberStatus
            self.phoneNumberType = phoneNumberType
            self.sourcePhoneNumberArn = sourcePhoneNumberArn
            self.tags = tags
            self.targetArn = targetArn
        }
    }

}

public struct DescribePhoneNumberOutput {
    /// Information about a phone number that's been claimed to your Amazon Connect instance or traffic distribution group.
    public var claimedPhoneNumberSummary: ConnectClientTypes.ClaimedPhoneNumberSummary?

    public init(
        claimedPhoneNumberSummary: ConnectClientTypes.ClaimedPhoneNumberSummary? = nil
    )
    {
        self.claimedPhoneNumberSummary = claimedPhoneNumberSummary
    }
}

public struct DescribePredefinedAttributeInput {
    /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the predefined attribute.
    /// This member is required.
    public var name: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.name = name
    }
}

extension ConnectClientTypes {
    /// Information about a predefined attribute.
    public struct PredefinedAttribute {
        /// Last modified region.
        public var lastModifiedRegion: Swift.String?
        /// Last modified time.
        public var lastModifiedTime: Foundation.Date?
        /// The name of the predefined attribute.
        public var name: Swift.String?
        /// The values of the predefined attribute.
        public var values: ConnectClientTypes.PredefinedAttributeValues?

        public init(
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            values: ConnectClientTypes.PredefinedAttributeValues? = nil
        )
        {
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.values = values
        }
    }

}

public struct DescribePredefinedAttributeOutput {
    /// Information about the predefined attribute.
    public var predefinedAttribute: ConnectClientTypes.PredefinedAttribute?

    public init(
        predefinedAttribute: ConnectClientTypes.PredefinedAttribute? = nil
    )
    {
        self.predefinedAttribute = predefinedAttribute
    }
}

public struct DescribePromptInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A unique identifier for the prompt.
    /// This member is required.
    public var promptId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        promptId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.promptId = promptId
    }
}

extension ConnectClientTypes {
    /// Information about a prompt.
    public struct Prompt {
        /// The description of the prompt.
        public var description: Swift.String?
        /// The Amazon Web Services Region where this resource was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when this resource was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// The name of the prompt.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the prompt.
        public var promptARN: Swift.String?
        /// A unique identifier for the prompt.
        public var promptId: Swift.String?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public var tags: [Swift.String: Swift.String]?

        public init(
            description: Swift.String? = nil,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            promptARN: Swift.String? = nil,
            promptId: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.description = description
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.promptARN = promptARN
            self.promptId = promptId
            self.tags = tags
        }
    }

}

public struct DescribePromptOutput {
    /// Information about the prompt.
    public var prompt: ConnectClientTypes.Prompt?

    public init(
        prompt: ConnectClientTypes.Prompt? = nil
    )
    {
        self.prompt = prompt
    }
}

public struct DescribeQueueInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the queue.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.queueId = queueId
    }
}

extension ConnectClientTypes {

    public enum QueueStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [QueueStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// Contains information about a queue.
    public struct Queue {
        /// The description of the queue.
        public var description: Swift.String?
        /// The identifier for the hours of operation.
        public var hoursOfOperationId: Swift.String?
        /// The Amazon Web Services Region where this resource was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when this resource was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// The maximum number of contacts that can be in the queue before it is considered full.
        public var maxContacts: Swift.Int?
        /// The name of the queue.
        public var name: Swift.String?
        /// The outbound caller ID name, number, and outbound whisper flow.
        public var outboundCallerConfig: ConnectClientTypes.OutboundCallerConfig?
        /// The Amazon Resource Name (ARN) for the queue.
        public var queueArn: Swift.String?
        /// The identifier for the queue.
        public var queueId: Swift.String?
        /// The status of the queue.
        public var status: ConnectClientTypes.QueueStatus?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public var tags: [Swift.String: Swift.String]?

        public init(
            description: Swift.String? = nil,
            hoursOfOperationId: Swift.String? = nil,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            maxContacts: Swift.Int? = 0,
            name: Swift.String? = nil,
            outboundCallerConfig: ConnectClientTypes.OutboundCallerConfig? = nil,
            queueArn: Swift.String? = nil,
            queueId: Swift.String? = nil,
            status: ConnectClientTypes.QueueStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.description = description
            self.hoursOfOperationId = hoursOfOperationId
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.maxContacts = maxContacts
            self.name = name
            self.outboundCallerConfig = outboundCallerConfig
            self.queueArn = queueArn
            self.queueId = queueId
            self.status = status
            self.tags = tags
        }
    }

}

public struct DescribeQueueOutput {
    /// The name of the queue.
    public var queue: ConnectClientTypes.Queue?

    public init(
        queue: ConnectClientTypes.Queue? = nil
    )
    {
        self.queue = queue
    }
}

public struct DescribeQuickConnectInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the quick connect.
    /// This member is required.
    public var quickConnectId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        quickConnectId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.quickConnectId = quickConnectId
    }
}

extension ConnectClientTypes {
    /// Contains information about a quick connect.
    public struct QuickConnect {
        /// The description.
        public var description: Swift.String?
        /// The Amazon Web Services Region where this resource was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when this resource was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// The name of the quick connect.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the quick connect.
        public var quickConnectARN: Swift.String?
        /// Contains information about the quick connect.
        public var quickConnectConfig: ConnectClientTypes.QuickConnectConfig?
        /// The identifier for the quick connect.
        public var quickConnectId: Swift.String?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public var tags: [Swift.String: Swift.String]?

        public init(
            description: Swift.String? = nil,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            quickConnectARN: Swift.String? = nil,
            quickConnectConfig: ConnectClientTypes.QuickConnectConfig? = nil,
            quickConnectId: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.description = description
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.quickConnectARN = quickConnectARN
            self.quickConnectConfig = quickConnectConfig
            self.quickConnectId = quickConnectId
            self.tags = tags
        }
    }

}

public struct DescribeQuickConnectOutput {
    /// Information about the quick connect.
    public var quickConnect: ConnectClientTypes.QuickConnect?

    public init(
        quickConnect: ConnectClientTypes.QuickConnect? = nil
    )
    {
        self.quickConnect = quickConnect
    }
}

public struct DescribeRoutingProfileInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the routing profile.
    /// This member is required.
    public var routingProfileId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        routingProfileId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.routingProfileId = routingProfileId
    }
}

extension ConnectClientTypes {
    /// Contains information about a routing profile.
    public struct RoutingProfile {
        /// Whether agents with this routing profile will have their routing order calculated based on time since their last inbound contact or longest idle time.
        public var agentAvailabilityTimer: ConnectClientTypes.AgentAvailabilityTimer?
        /// The IDs of the associated queue.
        public var associatedQueueIds: [Swift.String]?
        /// The identifier of the default outbound queue for this routing profile.
        public var defaultOutboundQueueId: Swift.String?
        /// The description of the routing profile.
        public var description: Swift.String?
        /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
        public var instanceId: Swift.String?
        /// Whether this a default routing profile.
        public var isDefault: Swift.Bool
        /// The Amazon Web Services Region where this resource was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when this resource was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// The channels agents can handle in the Contact Control Panel (CCP) for this routing profile.
        public var mediaConcurrencies: [ConnectClientTypes.MediaConcurrency]?
        /// The name of the routing profile.
        public var name: Swift.String?
        /// The number of associated queues in routing profile.
        public var numberOfAssociatedQueues: Swift.Int?
        /// The number of associated users in routing profile.
        public var numberOfAssociatedUsers: Swift.Int?
        /// The Amazon Resource Name (ARN) of the routing profile.
        public var routingProfileArn: Swift.String?
        /// The identifier of the routing profile.
        public var routingProfileId: Swift.String?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public var tags: [Swift.String: Swift.String]?

        public init(
            agentAvailabilityTimer: ConnectClientTypes.AgentAvailabilityTimer? = nil,
            associatedQueueIds: [Swift.String]? = nil,
            defaultOutboundQueueId: Swift.String? = nil,
            description: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            isDefault: Swift.Bool = false,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            mediaConcurrencies: [ConnectClientTypes.MediaConcurrency]? = nil,
            name: Swift.String? = nil,
            numberOfAssociatedQueues: Swift.Int? = nil,
            numberOfAssociatedUsers: Swift.Int? = nil,
            routingProfileArn: Swift.String? = nil,
            routingProfileId: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.agentAvailabilityTimer = agentAvailabilityTimer
            self.associatedQueueIds = associatedQueueIds
            self.defaultOutboundQueueId = defaultOutboundQueueId
            self.description = description
            self.instanceId = instanceId
            self.isDefault = isDefault
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.mediaConcurrencies = mediaConcurrencies
            self.name = name
            self.numberOfAssociatedQueues = numberOfAssociatedQueues
            self.numberOfAssociatedUsers = numberOfAssociatedUsers
            self.routingProfileArn = routingProfileArn
            self.routingProfileId = routingProfileId
            self.tags = tags
        }
    }

}

public struct DescribeRoutingProfileOutput {
    /// The routing profile.
    public var routingProfile: ConnectClientTypes.RoutingProfile?

    public init(
        routingProfile: ConnectClientTypes.RoutingProfile? = nil
    )
    {
        self.routingProfile = routingProfile
    }
}

public struct DescribeRuleInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A unique identifier for the rule.
    /// This member is required.
    public var ruleId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        ruleId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.ruleId = ruleId
    }
}

extension ConnectClientTypes {
    /// Information about a rule.
    public struct Rule {
        /// A list of actions to be run when the rule is triggered.
        /// This member is required.
        public var actions: [ConnectClientTypes.RuleAction]?
        /// The timestamp for when the rule was created.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// The conditions of the rule.
        /// This member is required.
        public var function: Swift.String?
        /// The Amazon Resource Name (ARN) of the user who last updated the rule.
        /// This member is required.
        public var lastUpdatedBy: Swift.String?
        /// The timestamp for the when the rule was last updated.
        /// This member is required.
        public var lastUpdatedTime: Foundation.Date?
        /// The name of the rule.
        /// This member is required.
        public var name: Swift.String?
        /// The publish status of the rule.
        /// This member is required.
        public var publishStatus: ConnectClientTypes.RulePublishStatus?
        /// The Amazon Resource Name (ARN) of the rule.
        /// This member is required.
        public var ruleArn: Swift.String?
        /// A unique identifier for the rule.
        /// This member is required.
        public var ruleId: Swift.String?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public var tags: [Swift.String: Swift.String]?
        /// The event source to trigger the rule.
        /// This member is required.
        public var triggerEventSource: ConnectClientTypes.RuleTriggerEventSource?

        public init(
            actions: [ConnectClientTypes.RuleAction]? = nil,
            createdTime: Foundation.Date? = nil,
            function: Swift.String? = nil,
            lastUpdatedBy: Swift.String? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            publishStatus: ConnectClientTypes.RulePublishStatus? = nil,
            ruleArn: Swift.String? = nil,
            ruleId: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            triggerEventSource: ConnectClientTypes.RuleTriggerEventSource? = nil
        )
        {
            self.actions = actions
            self.createdTime = createdTime
            self.function = function
            self.lastUpdatedBy = lastUpdatedBy
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.publishStatus = publishStatus
            self.ruleArn = ruleArn
            self.ruleId = ruleId
            self.tags = tags
            self.triggerEventSource = triggerEventSource
        }
    }

}

public struct DescribeRuleOutput {
    /// Information about the rule.
    /// This member is required.
    public var rule: ConnectClientTypes.Rule?

    public init(
        rule: ConnectClientTypes.Rule? = nil
    )
    {
        self.rule = rule
    }
}

public struct DescribeSecurityProfileInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the security profle.
    /// This member is required.
    public var securityProfileId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        securityProfileId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.securityProfileId = securityProfileId
    }
}

extension ConnectClientTypes {
    /// Contains information about a security profile.
    public struct SecurityProfile {
        /// The identifier of the hierarchy group that a security profile uses to restrict access to resources in Amazon Connect.
        public var allowedAccessControlHierarchyGroupId: Swift.String?
        /// The list of tags that a security profile uses to restrict access to resources in Amazon Connect.
        public var allowedAccessControlTags: [Swift.String: Swift.String]?
        /// The Amazon Resource Name (ARN) for the secruity profile.
        public var arn: Swift.String?
        /// The description of the security profile.
        public var description: Swift.String?
        /// The list of resources that a security profile applies hierarchy restrictions to in Amazon Connect. Following are acceptable ResourceNames: User.
        public var hierarchyRestrictedResources: [Swift.String]?
        /// The identifier for the security profile.
        public var id: Swift.String?
        /// The Amazon Web Services Region where this resource was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when this resource was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// The organization resource identifier for the security profile.
        public var organizationResourceId: Swift.String?
        /// The name for the security profile.
        public var securityProfileName: Swift.String?
        /// The list of resources that a security profile applies tag restrictions to in Amazon Connect.
        public var tagRestrictedResources: [Swift.String]?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public var tags: [Swift.String: Swift.String]?

        public init(
            allowedAccessControlHierarchyGroupId: Swift.String? = nil,
            allowedAccessControlTags: [Swift.String: Swift.String]? = nil,
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            hierarchyRestrictedResources: [Swift.String]? = nil,
            id: Swift.String? = nil,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            organizationResourceId: Swift.String? = nil,
            securityProfileName: Swift.String? = nil,
            tagRestrictedResources: [Swift.String]? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.allowedAccessControlHierarchyGroupId = allowedAccessControlHierarchyGroupId
            self.allowedAccessControlTags = allowedAccessControlTags
            self.arn = arn
            self.description = description
            self.hierarchyRestrictedResources = hierarchyRestrictedResources
            self.id = id
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.organizationResourceId = organizationResourceId
            self.securityProfileName = securityProfileName
            self.tagRestrictedResources = tagRestrictedResources
            self.tags = tags
        }
    }

}

public struct DescribeSecurityProfileOutput {
    /// The security profile.
    public var securityProfile: ConnectClientTypes.SecurityProfile?

    public init(
        securityProfile: ConnectClientTypes.SecurityProfile? = nil
    )
    {
        self.securityProfile = securityProfile
    }
}

public struct DescribeTrafficDistributionGroupInput {
    /// The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.
    /// This member is required.
    public var trafficDistributionGroupId: Swift.String?

    public init(
        trafficDistributionGroupId: Swift.String? = nil
    )
    {
        self.trafficDistributionGroupId = trafficDistributionGroupId
    }
}

extension ConnectClientTypes {

    public enum TrafficDistributionGroupStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creationFailed
        case creationInProgress
        case deletionFailed
        case pendingDeletion
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [TrafficDistributionGroupStatus] {
            return [
                .active,
                .creationFailed,
                .creationInProgress,
                .deletionFailed,
                .pendingDeletion,
                .updateInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creationFailed: return "CREATION_FAILED"
            case .creationInProgress: return "CREATION_IN_PROGRESS"
            case .deletionFailed: return "DELETION_FAILED"
            case .pendingDeletion: return "PENDING_DELETION"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// Information about a traffic distribution group.
    public struct TrafficDistributionGroup {
        /// The Amazon Resource Name (ARN) of the traffic distribution group.
        public var arn: Swift.String?
        /// The description of the traffic distribution group.
        public var description: Swift.String?
        /// The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.
        public var id: Swift.String?
        /// The Amazon Resource Name (ARN).
        public var instanceArn: Swift.String?
        /// Whether this is the default traffic distribution group created during instance replication. The default traffic distribution group cannot be deleted by the DeleteTrafficDistributionGroup API. The default traffic distribution group is deleted as part of the process for deleting a replica. The SignInConfig distribution is available only on a default TrafficDistributionGroup (see the IsDefault parameter in the [TrafficDistributionGroup](https://docs.aws.amazon.com/connect/latest/APIReference/API_TrafficDistributionGroup.html) data type). If you call UpdateTrafficDistribution with a modified SignInConfig and a non-default TrafficDistributionGroup, an InvalidRequestException is returned.
        public var isDefault: Swift.Bool
        /// The name of the traffic distribution group.
        public var name: Swift.String?
        /// The status of the traffic distribution group.
        ///
        /// * CREATION_IN_PROGRESS means the previous [CreateTrafficDistributionGroup](https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html) operation is still in progress and has not yet completed.
        ///
        /// * ACTIVE means the previous [CreateTrafficDistributionGroup](https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html) operation has succeeded.
        ///
        /// * CREATION_FAILED indicates that the previous [CreateTrafficDistributionGroup](https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html) operation has failed.
        ///
        /// * PENDING_DELETION means the previous [DeleteTrafficDistributionGroup](https://docs.aws.amazon.com/connect/latest/APIReference/API_DeleteTrafficDistributionGroup.html) operation is still in progress and has not yet completed.
        ///
        /// * DELETION_FAILED means the previous [DeleteTrafficDistributionGroup](https://docs.aws.amazon.com/connect/latest/APIReference/API_DeleteTrafficDistributionGroup.html) operation has failed.
        ///
        /// * UPDATE_IN_PROGRESS means the previous [UpdateTrafficDistribution](https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdateTrafficDistribution.html) operation is still in progress and has not yet completed.
        public var status: ConnectClientTypes.TrafficDistributionGroupStatus?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            instanceArn: Swift.String? = nil,
            isDefault: Swift.Bool = false,
            name: Swift.String? = nil,
            status: ConnectClientTypes.TrafficDistributionGroupStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.id = id
            self.instanceArn = instanceArn
            self.isDefault = isDefault
            self.name = name
            self.status = status
            self.tags = tags
        }
    }

}

public struct DescribeTrafficDistributionGroupOutput {
    /// Information about the traffic distribution group.
    public var trafficDistributionGroup: ConnectClientTypes.TrafficDistributionGroup?

    public init(
        trafficDistributionGroup: ConnectClientTypes.TrafficDistributionGroup? = nil
    )
    {
        self.trafficDistributionGroup = trafficDistributionGroup
    }
}

public struct DescribeUserInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the user account.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.userId = userId
    }
}

extension ConnectClientTypes {
    /// Contains information about a user account for an Amazon Connect instance.
    public struct User {
        /// The Amazon Resource Name (ARN) of the user account.
        public var arn: Swift.String?
        /// The identifier of the user account in the directory used for identity management.
        public var directoryUserId: Swift.String?
        /// The identifier of the hierarchy group for the user.
        public var hierarchyGroupId: Swift.String?
        /// The identifier of the user account.
        public var id: Swift.String?
        /// Information about the user identity.
        public var identityInfo: ConnectClientTypes.UserIdentityInfo?
        /// The Amazon Web Services Region where this resource was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when this resource was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// Information about the phone configuration for the user.
        public var phoneConfig: ConnectClientTypes.UserPhoneConfig?
        /// The identifier of the routing profile for the user.
        public var routingProfileId: Swift.String?
        /// The identifiers of the security profiles for the user.
        public var securityProfileIds: [Swift.String]?
        /// The tags.
        public var tags: [Swift.String: Swift.String]?
        /// The user name assigned to the user account.
        public var username: Swift.String?

        public init(
            arn: Swift.String? = nil,
            directoryUserId: Swift.String? = nil,
            hierarchyGroupId: Swift.String? = nil,
            id: Swift.String? = nil,
            identityInfo: ConnectClientTypes.UserIdentityInfo? = nil,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            phoneConfig: ConnectClientTypes.UserPhoneConfig? = nil,
            routingProfileId: Swift.String? = nil,
            securityProfileIds: [Swift.String]? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            username: Swift.String? = nil
        )
        {
            self.arn = arn
            self.directoryUserId = directoryUserId
            self.hierarchyGroupId = hierarchyGroupId
            self.id = id
            self.identityInfo = identityInfo
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.phoneConfig = phoneConfig
            self.routingProfileId = routingProfileId
            self.securityProfileIds = securityProfileIds
            self.tags = tags
            self.username = username
        }
    }

}

public struct DescribeUserOutput {
    /// Information about the user account and configuration settings.
    public var user: ConnectClientTypes.User?

    public init(
        user: ConnectClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

public struct DescribeUserHierarchyGroupInput {
    /// The identifier of the hierarchy group.
    /// This member is required.
    public var hierarchyGroupId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        hierarchyGroupId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.hierarchyGroupId = hierarchyGroupId
        self.instanceId = instanceId
    }
}

extension ConnectClientTypes {
    /// Contains summary information about a hierarchy group.
    public struct HierarchyGroupSummary {
        /// The Amazon Resource Name (ARN) of the hierarchy group.
        public var arn: Swift.String?
        /// The identifier of the hierarchy group.
        public var id: Swift.String?
        /// The Amazon Web Services Region where this resource was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when this resource was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// The name of the hierarchy group.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
        }
    }

}

extension ConnectClientTypes {
    /// Contains information about the levels of a hierarchy group.
    public struct HierarchyPath {
        /// Information about level five.
        public var levelFive: ConnectClientTypes.HierarchyGroupSummary?
        /// Information about level four.
        public var levelFour: ConnectClientTypes.HierarchyGroupSummary?
        /// Information about level one.
        public var levelOne: ConnectClientTypes.HierarchyGroupSummary?
        /// Information about level three.
        public var levelThree: ConnectClientTypes.HierarchyGroupSummary?
        /// Information about level two.
        public var levelTwo: ConnectClientTypes.HierarchyGroupSummary?

        public init(
            levelFive: ConnectClientTypes.HierarchyGroupSummary? = nil,
            levelFour: ConnectClientTypes.HierarchyGroupSummary? = nil,
            levelOne: ConnectClientTypes.HierarchyGroupSummary? = nil,
            levelThree: ConnectClientTypes.HierarchyGroupSummary? = nil,
            levelTwo: ConnectClientTypes.HierarchyGroupSummary? = nil
        )
        {
            self.levelFive = levelFive
            self.levelFour = levelFour
            self.levelOne = levelOne
            self.levelThree = levelThree
            self.levelTwo = levelTwo
        }
    }

}

extension ConnectClientTypes {
    /// Contains information about a hierarchy group.
    public struct HierarchyGroup {
        /// The Amazon Resource Name (ARN) of the hierarchy group.
        public var arn: Swift.String?
        /// Information about the levels in the hierarchy group.
        public var hierarchyPath: ConnectClientTypes.HierarchyPath?
        /// The identifier of the hierarchy group.
        public var id: Swift.String?
        /// The Amazon Web Services Region where this resource was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when this resource was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// The identifier of the level in the hierarchy group.
        public var levelId: Swift.String?
        /// The name of the hierarchy group.
        public var name: Swift.String?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            hierarchyPath: ConnectClientTypes.HierarchyPath? = nil,
            id: Swift.String? = nil,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            levelId: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.hierarchyPath = hierarchyPath
            self.id = id
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.levelId = levelId
            self.name = name
            self.tags = tags
        }
    }

}

public struct DescribeUserHierarchyGroupOutput {
    /// Information about the hierarchy group.
    public var hierarchyGroup: ConnectClientTypes.HierarchyGroup?

    public init(
        hierarchyGroup: ConnectClientTypes.HierarchyGroup? = nil
    )
    {
        self.hierarchyGroup = hierarchyGroup
    }
}

public struct DescribeUserHierarchyStructureInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        instanceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

extension ConnectClientTypes {
    /// Contains information about a hierarchy level.
    public struct HierarchyLevel {
        /// The Amazon Resource Name (ARN) of the hierarchy level.
        public var arn: Swift.String?
        /// The identifier of the hierarchy level.
        public var id: Swift.String?
        /// The Amazon Web Services Region where this resource was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when this resource was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// The name of the hierarchy level.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
        }
    }

}

extension ConnectClientTypes {
    /// Contains information about a hierarchy structure.
    public struct HierarchyStructure {
        /// Information about level five.
        public var levelFive: ConnectClientTypes.HierarchyLevel?
        /// Information about level four.
        public var levelFour: ConnectClientTypes.HierarchyLevel?
        /// Information about level one.
        public var levelOne: ConnectClientTypes.HierarchyLevel?
        /// Information about level three.
        public var levelThree: ConnectClientTypes.HierarchyLevel?
        /// Information about level two.
        public var levelTwo: ConnectClientTypes.HierarchyLevel?

        public init(
            levelFive: ConnectClientTypes.HierarchyLevel? = nil,
            levelFour: ConnectClientTypes.HierarchyLevel? = nil,
            levelOne: ConnectClientTypes.HierarchyLevel? = nil,
            levelThree: ConnectClientTypes.HierarchyLevel? = nil,
            levelTwo: ConnectClientTypes.HierarchyLevel? = nil
        )
        {
            self.levelFive = levelFive
            self.levelFour = levelFour
            self.levelOne = levelOne
            self.levelThree = levelThree
            self.levelTwo = levelTwo
        }
    }

}

public struct DescribeUserHierarchyStructureOutput {
    /// Information about the hierarchy structure.
    public var hierarchyStructure: ConnectClientTypes.HierarchyStructure?

    public init(
        hierarchyStructure: ConnectClientTypes.HierarchyStructure? = nil
    )
    {
        self.hierarchyStructure = hierarchyStructure
    }
}

public struct DescribeViewInput {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The ViewId of the view. This must be an ARN for Amazon Web Services managed views.
    /// This member is required.
    public var viewId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        viewId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.viewId = viewId
    }
}

public struct DescribeViewOutput {
    /// All view data is contained within the View object.
    public var view: ConnectClientTypes.View?

    public init(
        view: ConnectClientTypes.View? = nil
    )
    {
        self.view = view
    }
}

public struct DescribeVocabularyInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the custom vocabulary.
    /// This member is required.
    public var vocabularyId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        vocabularyId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.vocabularyId = vocabularyId
    }
}

extension ConnectClientTypes {
    /// Contains information about a custom vocabulary.
    public struct Vocabulary {
        /// The Amazon Resource Name (ARN) of the custom vocabulary.
        /// This member is required.
        public var arn: Swift.String?
        /// The content of the custom vocabulary in plain-text format with a table of values. Each row in the table represents a word or a phrase, described with Phrase, IPA, SoundsLike, and DisplayAs fields. Separate the fields with TAB characters. For more information, see [Create a custom vocabulary using a table](https://docs.aws.amazon.com/transcribe/latest/dg/custom-vocabulary.html#create-vocabulary-table).
        public var content: Swift.String?
        /// The reason why the custom vocabulary was not created.
        public var failureReason: Swift.String?
        /// The identifier of the custom vocabulary.
        /// This member is required.
        public var id: Swift.String?
        /// The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see [What is Amazon Transcribe?](https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html)
        /// This member is required.
        public var languageCode: ConnectClientTypes.VocabularyLanguageCode?
        /// The timestamp when the custom vocabulary was last modified.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// A unique name of the custom vocabulary.
        /// This member is required.
        public var name: Swift.String?
        /// The current state of the custom vocabulary.
        /// This member is required.
        public var state: ConnectClientTypes.VocabularyState?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            content: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            id: Swift.String? = nil,
            languageCode: ConnectClientTypes.VocabularyLanguageCode? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            state: ConnectClientTypes.VocabularyState? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.content = content
            self.failureReason = failureReason
            self.id = id
            self.languageCode = languageCode
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.state = state
            self.tags = tags
        }
    }

}

public struct DescribeVocabularyOutput {
    /// A list of specific words that you want Contact Lens for Amazon Connect to recognize in your audio input. They are generally domain-specific words and phrases, words that Contact Lens is not recognizing, or proper nouns.
    /// This member is required.
    public var vocabulary: ConnectClientTypes.Vocabulary?

    public init(
        vocabulary: ConnectClientTypes.Vocabulary? = nil
    )
    {
        self.vocabulary = vocabulary
    }
}

public struct DisassociateAnalyticsDataSetInput {
    /// The identifier of the dataset to remove.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the target account. Use to associate a dataset to a different account than the one containing the Amazon Connect instance. If not specified, by default this value is the Amazon Web Services account that has the Amazon Connect instance.
    public var targetAccountId: Swift.String?

    public init(
        dataSetId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        targetAccountId: Swift.String? = nil
    )
    {
        self.dataSetId = dataSetId
        self.instanceId = instanceId
        self.targetAccountId = targetAccountId
    }
}

public struct DisassociateApprovedOriginInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The domain URL of the integrated application.
    /// This member is required.
    public var origin: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        origin: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.origin = origin
    }
}

public struct DisassociateBotInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Configuration information of an Amazon Lex bot.
    public var lexBot: ConnectClientTypes.LexBot?
    /// The Amazon Lex V2 bot to disassociate from the instance.
    public var lexV2Bot: ConnectClientTypes.LexV2Bot?

    public init(
        instanceId: Swift.String? = nil,
        lexBot: ConnectClientTypes.LexBot? = nil,
        lexV2Bot: ConnectClientTypes.LexV2Bot? = nil
    )
    {
        self.instanceId = instanceId
        self.lexBot = lexBot
        self.lexV2Bot = lexV2Bot
    }
}

public struct DisassociateFlowInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// A valid resource type.
    /// This member is required.
    public var resourceType: ConnectClientTypes.FlowAssociationResourceType?

    public init(
        instanceId: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: ConnectClientTypes.FlowAssociationResourceType? = nil
    )
    {
        self.instanceId = instanceId
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

public struct DisassociateFlowOutput {

    public init() { }
}

public struct DisassociateInstanceStorageConfigInput {
    /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
    /// This member is required.
    public var associationId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A valid resource type.
    /// This member is required.
    public var resourceType: ConnectClientTypes.InstanceStorageResourceType?

    public init(
        associationId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        resourceType: ConnectClientTypes.InstanceStorageResourceType? = nil
    )
    {
        self.associationId = associationId
        self.instanceId = instanceId
        self.resourceType = resourceType
    }
}

public struct DisassociateLambdaFunctionInput {
    /// The Amazon Resource Name (ARN) of the Lambda function being disassociated.
    /// This member is required.
    public var functionArn: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance..
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        functionArn: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.functionArn = functionArn
        self.instanceId = instanceId
    }
}

public struct DisassociateLexBotInput {
    /// The name of the Amazon Lex bot. Maximum character limit of 50.
    /// This member is required.
    public var botName: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The Amazon Web Services Region in which the Amazon Lex bot has been created.
    /// This member is required.
    public var lexRegion: Swift.String?

    public init(
        botName: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        lexRegion: Swift.String? = nil
    )
    {
        self.botName = botName
        self.instanceId = instanceId
        self.lexRegion = lexRegion
    }
}

public struct DisassociatePhoneNumberContactFlowInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A unique identifier for the phone number.
    /// This member is required.
    public var phoneNumberId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        phoneNumberId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.phoneNumberId = phoneNumberId
    }
}

public struct DisassociateQueueQuickConnectsInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the queue.
    /// This member is required.
    public var queueId: Swift.String?
    /// The quick connects to disassociate from the queue.
    /// This member is required.
    public var quickConnectIds: [Swift.String]?

    public init(
        instanceId: Swift.String? = nil,
        queueId: Swift.String? = nil,
        quickConnectIds: [Swift.String]? = nil
    )
    {
        self.instanceId = instanceId
        self.queueId = queueId
        self.quickConnectIds = quickConnectIds
    }
}

public struct DisassociateRoutingProfileQueuesInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The queues to disassociate from this routing profile.
    /// This member is required.
    public var queueReferences: [ConnectClientTypes.RoutingProfileQueueReference]?
    /// The identifier of the routing profile.
    /// This member is required.
    public var routingProfileId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        queueReferences: [ConnectClientTypes.RoutingProfileQueueReference]? = nil,
        routingProfileId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.queueReferences = queueReferences
        self.routingProfileId = routingProfileId
    }
}

public struct DisassociateSecurityKeyInput {
    /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
    /// This member is required.
    public var associationId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        associationId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.associationId = associationId
        self.instanceId = instanceId
    }
}

public struct DisassociateTrafficDistributionGroupUserInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.
    /// This member is required.
    public var trafficDistributionGroupId: Swift.String?
    /// The identifier for the user. This can be the ID or the ARN of the user.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        trafficDistributionGroupId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.trafficDistributionGroupId = trafficDistributionGroupId
        self.userId = userId
    }
}

public struct DisassociateTrafficDistributionGroupUserOutput {

    public init() { }
}

extension ConnectClientTypes {
    /// Information about proficiency to be disassociated from the user.
    public struct UserProficiencyDisassociate {
        /// The name of user's proficiency.
        /// This member is required.
        public var attributeName: Swift.String?
        /// The value of user's proficiency.
        /// This member is required.
        public var attributeValue: Swift.String?

        public init(
            attributeName: Swift.String? = nil,
            attributeValue: Swift.String? = nil
        )
        {
            self.attributeName = attributeName
            self.attributeValue = attributeValue
        }
    }

}

public struct DisassociateUserProficienciesInput {
    /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the user account.
    /// This member is required.
    public var userId: Swift.String?
    /// The proficiencies to disassociate from the user.
    /// This member is required.
    public var userProficiencies: [ConnectClientTypes.UserProficiencyDisassociate]?

    public init(
        instanceId: Swift.String? = nil,
        userId: Swift.String? = nil,
        userProficiencies: [ConnectClientTypes.UserProficiencyDisassociate]? = nil
    )
    {
        self.instanceId = instanceId
        self.userId = userId
        self.userProficiencies = userProficiencies
    }
}

public struct DismissUserContactInput {
    /// The identifier of the contact.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the user account.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        contactId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.contactId = contactId
        self.instanceId = instanceId
        self.userId = userId
    }
}

public struct DismissUserContactOutput {

    public init() { }
}

/// Request to GetAttachedFile API.
public struct GetAttachedFileInput {
    /// The resource to which the attached file is (being) uploaded to. [Cases](https://docs.aws.amazon.com/connect/latest/APIReference/API_connect-cases_CreateCase.html) are the only current supported resource. This value must be a valid ARN.
    /// This member is required.
    public var associatedResourceArn: Swift.String?
    /// The unique identifier of the attached file resource.
    /// This member is required.
    public var fileId: Swift.String?
    /// The unique identifier of the Connect instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Optional override for the expiry of the pre-signed S3 URL in seconds. The default value is 300.
    public var urlExpiryInSeconds: Swift.Int?

    public init(
        associatedResourceArn: Swift.String? = nil,
        fileId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        urlExpiryInSeconds: Swift.Int? = nil
    )
    {
        self.associatedResourceArn = associatedResourceArn
        self.fileId = fileId
        self.instanceId = instanceId
        self.urlExpiryInSeconds = urlExpiryInSeconds
    }
}

extension ConnectClientTypes {
    /// Metadata used to download the attached file.
    public struct DownloadUrlMetadata {
        /// A pre-signed URL that should be used to download the attached file.
        public var url: Swift.String?
        /// The expiration time of the URL in ISO timestamp. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
        public var urlExpiry: Swift.String?

        public init(
            url: Swift.String? = nil,
            urlExpiry: Swift.String? = nil
        )
        {
            self.url = url
            self.urlExpiry = urlExpiry
        }
    }

}

/// Response from GetAttachedFile API.
public struct GetAttachedFileOutput {
    /// The resource to which the attached file is (being) uploaded to. [Cases](https://docs.aws.amazon.com/connect/latest/APIReference/API_connect-cases_CreateCase.html) are the only current supported resource.
    public var associatedResourceArn: Swift.String?
    /// Represents the identity that created the file.
    public var createdBy: ConnectClientTypes.CreatedByInfo?
    /// The time of Creation of the file resource as an ISO timestamp. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2024-05-03T02:41:28.172Z.
    public var creationTime: Swift.String?
    /// URL and expiry to be used when downloading the attached file.
    public var downloadUrlMetadata: ConnectClientTypes.DownloadUrlMetadata?
    /// The unique identifier of the attached file resource (ARN).
    public var fileArn: Swift.String?
    /// The unique identifier of the attached file resource.
    public var fileId: Swift.String?
    /// A case-sensitive name of the attached file being uploaded.
    public var fileName: Swift.String?
    /// The size of the attached file in bytes.
    /// This member is required.
    public var fileSizeInBytes: Swift.Int?
    /// The current status of the attached file.
    public var fileStatus: ConnectClientTypes.FileStatusType?
    /// The use case for the file.
    public var fileUseCaseType: ConnectClientTypes.FileUseCaseType?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String: Swift.String]?

    public init(
        associatedResourceArn: Swift.String? = nil,
        createdBy: ConnectClientTypes.CreatedByInfo? = nil,
        creationTime: Swift.String? = nil,
        downloadUrlMetadata: ConnectClientTypes.DownloadUrlMetadata? = nil,
        fileArn: Swift.String? = nil,
        fileId: Swift.String? = nil,
        fileName: Swift.String? = nil,
        fileSizeInBytes: Swift.Int? = nil,
        fileStatus: ConnectClientTypes.FileStatusType? = nil,
        fileUseCaseType: ConnectClientTypes.FileUseCaseType? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.associatedResourceArn = associatedResourceArn
        self.createdBy = createdBy
        self.creationTime = creationTime
        self.downloadUrlMetadata = downloadUrlMetadata
        self.fileArn = fileArn
        self.fileId = fileId
        self.fileName = fileName
        self.fileSizeInBytes = fileSizeInBytes
        self.fileStatus = fileStatus
        self.fileUseCaseType = fileUseCaseType
        self.tags = tags
    }
}

public struct GetContactAttributesInput {
    /// The identifier of the initial contact.
    /// This member is required.
    public var initialContactId: Swift.String?
    /// The identifier of the Amazon Connect instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        initialContactId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.initialContactId = initialContactId
        self.instanceId = instanceId
    }
}

public struct GetContactAttributesOutput {
    /// Information about the attributes.
    public var attributes: [Swift.String: Swift.String]?

    public init(
        attributes: [Swift.String: Swift.String]? = nil
    )
    {
        self.attributes = attributes
    }
}

extension ConnectClientTypes {

    /// The current metric names.
    public enum CurrentMetricName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case agentsAfterContactWork
        case agentsAvailable
        case agentsError
        case agentsNonProductive
        case agentsOnline
        case agentsOnCall
        case agentsOnContact
        case agentsStaffed
        case contactsInQueue
        case contactsScheduled
        case oldestContactAge
        case slotsActive
        case slotsAvailable
        case sdkUnknown(Swift.String)

        public static var allCases: [CurrentMetricName] {
            return [
                .agentsAfterContactWork,
                .agentsAvailable,
                .agentsError,
                .agentsNonProductive,
                .agentsOnline,
                .agentsOnCall,
                .agentsOnContact,
                .agentsStaffed,
                .contactsInQueue,
                .contactsScheduled,
                .oldestContactAge,
                .slotsActive,
                .slotsAvailable
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .agentsAfterContactWork: return "AGENTS_AFTER_CONTACT_WORK"
            case .agentsAvailable: return "AGENTS_AVAILABLE"
            case .agentsError: return "AGENTS_ERROR"
            case .agentsNonProductive: return "AGENTS_NON_PRODUCTIVE"
            case .agentsOnline: return "AGENTS_ONLINE"
            case .agentsOnCall: return "AGENTS_ON_CALL"
            case .agentsOnContact: return "AGENTS_ON_CONTACT"
            case .agentsStaffed: return "AGENTS_STAFFED"
            case .contactsInQueue: return "CONTACTS_IN_QUEUE"
            case .contactsScheduled: return "CONTACTS_SCHEDULED"
            case .oldestContactAge: return "OLDEST_CONTACT_AGE"
            case .slotsActive: return "SLOTS_ACTIVE"
            case .slotsAvailable: return "SLOTS_AVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {

    public enum Unit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case count
        case percent
        case seconds
        case sdkUnknown(Swift.String)

        public static var allCases: [Unit] {
            return [
                .count,
                .percent,
                .seconds
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .count: return "COUNT"
            case .percent: return "PERCENT"
            case .seconds: return "SECONDS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// Contains information about a real-time metric. For a description of each metric, see [Real-time Metrics Definitions](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html) in the Amazon Connect Administrator Guide.
    public struct CurrentMetric {
        /// The name of the metric.
        public var name: ConnectClientTypes.CurrentMetricName?
        /// The unit for the metric.
        public var unit: ConnectClientTypes.Unit?

        public init(
            name: ConnectClientTypes.CurrentMetricName? = nil,
            unit: ConnectClientTypes.Unit? = nil
        )
        {
            self.name = name
            self.unit = unit
        }
    }

}

extension ConnectClientTypes {
    /// Contains the filter to apply when retrieving metrics.
    public struct Filters {
        /// The channel to use to filter the metrics.
        public var channels: [ConnectClientTypes.Channel]?
        /// The queues to use to filter the metrics. You should specify at least one queue, and can specify up to 100 queues per request. The GetCurrentMetricsData API in particular requires a queue when you include a Filter in your request.
        public var queues: [Swift.String]?
        /// A list of up to 100 routing profile IDs or ARNs.
        public var routingProfiles: [Swift.String]?
        /// A list of expressions as a filter, in which an expression is an object of a step in a routing criteria.
        public var routingStepExpressions: [Swift.String]?

        public init(
            channels: [ConnectClientTypes.Channel]? = nil,
            queues: [Swift.String]? = nil,
            routingProfiles: [Swift.String]? = nil,
            routingStepExpressions: [Swift.String]? = nil
        )
        {
            self.channels = channels
            self.queues = queues
            self.routingProfiles = routingProfiles
            self.routingStepExpressions = routingStepExpressions
        }
    }

}

extension ConnectClientTypes {

    public enum Grouping: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case channel
        case queue
        case routingProfile
        case routingStepExpression
        case sdkUnknown(Swift.String)

        public static var allCases: [Grouping] {
            return [
                .channel,
                .queue,
                .routingProfile,
                .routingStepExpression
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .channel: return "CHANNEL"
            case .queue: return "QUEUE"
            case .routingProfile: return "ROUTING_PROFILE"
            case .routingStepExpression: return "ROUTING_STEP_EXPRESSION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {

    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// The way to sort the resulting response based on metrics. By default resources are sorted based on AGENTS_ONLINE, DESCENDING. The metric collection is sorted based on the input metrics.
    public struct CurrentMetricSortCriteria {
        /// The current metric names.
        public var sortByMetric: ConnectClientTypes.CurrentMetricName?
        /// The way to sort.
        public var sortOrder: ConnectClientTypes.SortOrder?

        public init(
            sortByMetric: ConnectClientTypes.CurrentMetricName? = nil,
            sortOrder: ConnectClientTypes.SortOrder? = nil
        )
        {
            self.sortByMetric = sortByMetric
            self.sortOrder = sortOrder
        }
    }

}

public struct GetCurrentMetricDataInput {
    /// The metrics to retrieve. Specify the name and unit for each metric. The following metrics are available. For a description of all the metrics, see [Real-time Metrics Definitions](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html) in the Amazon Connect Administrator Guide. AGENTS_AFTER_CONTACT_WORK Unit: COUNT Name in real-time metrics report: [ACW](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#aftercallwork-real-time) AGENTS_AVAILABLE Unit: COUNT Name in real-time metrics report: [Available](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#available-real-time) AGENTS_ERROR Unit: COUNT Name in real-time metrics report: [Error](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#error-real-time) AGENTS_NON_PRODUCTIVE Unit: COUNT Name in real-time metrics report: [NPT (Non-Productive Time)](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#non-productive-time-real-time) AGENTS_ON_CALL Unit: COUNT Name in real-time metrics report: [On contact](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#on-call-real-time) AGENTS_ON_CONTACT Unit: COUNT Name in real-time metrics report: [On contact](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#on-call-real-time) AGENTS_ONLINE Unit: COUNT Name in real-time metrics report: [Online](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#online-real-time) AGENTS_STAFFED Unit: COUNT Name in real-time metrics report: [Staffed](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#staffed-real-time) CONTACTS_IN_QUEUE Unit: COUNT Name in real-time metrics report: [In queue](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#in-queue-real-time) CONTACTS_SCHEDULED Unit: COUNT Name in real-time metrics report: [Scheduled](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#scheduled-real-time) OLDEST_CONTACT_AGE Unit: SECONDS When you use groupings, Unit says SECONDS and the Value is returned in SECONDS. When you do not use groupings, Unit says SECONDS but the Value is returned in MILLISECONDS. For example, if you get a response like this: { "Metric": { "Name": "OLDEST_CONTACT_AGE", "Unit": "SECONDS" }, "Value": 24113.0 } The actual OLDEST_CONTACT_AGE is 24 seconds. When the filter RoutingStepExpression is used, this metric is still calculated from enqueue time. For example, if a contact that has been queued under  for 10 seconds has expired and  becomes active, then OLDEST_CONTACT_AGE for this queue will be counted starting from 10, not 0. Name in real-time metrics report: [Oldest](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#oldest-real-time) SLOTS_ACTIVE Unit: COUNT Name in real-time metrics report: [Active](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#active-real-time) SLOTS_AVAILABLE Unit: COUNT Name in real-time metrics report: [Availability](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#availability-real-time)
    /// This member is required.
    public var currentMetrics: [ConnectClientTypes.CurrentMetric]?
    /// The filters to apply to returned metrics. You can filter up to the following limits:
    ///
    /// * Queues: 100
    ///
    /// * Routing profiles: 100
    ///
    /// * Channels: 3 (VOICE, CHAT, and TASK channels are supported.)
    ///
    /// * RoutingStepExpressions: 50
    ///
    ///
    /// Metric data is retrieved only for the resources associated with the queues or routing profiles, and by any channels included in the filter. (You cannot filter by both queue AND routing profile.) You can include both resource IDs and resource ARNs in the same request. When using the RoutingStepExpression filter, you need to pass exactly one QueueId. The filter is also case sensitive so when using the RoutingStepExpression filter, grouping by ROUTING_STEP_EXPRESSION is required. Currently tagging is only supported on the resources that are passed in the filter.
    /// This member is required.
    public var filters: ConnectClientTypes.Filters?
    /// The grouping applied to the metrics returned. For example, when grouped by QUEUE, the metrics returned apply to each queue rather than aggregated for all queues.
    ///
    /// * If you group by CHANNEL, you should include a Channels filter. VOICE, CHAT, and TASK channels are supported.
    ///
    /// * If you group by ROUTING_PROFILE, you must include either a queue or routing profile filter. In addition, a routing profile filter is required for metrics CONTACTS_SCHEDULED, CONTACTS_IN_QUEUE, and  OLDEST_CONTACT_AGE.
    ///
    /// * If no Grouping is included in the request, a summary of metrics is returned.
    ///
    /// * When using the RoutingStepExpression filter, group by ROUTING_STEP_EXPRESSION is required.
    public var groupings: [ConnectClientTypes.Grouping]?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. The token expires after 5 minutes from the time it is created. Subsequent requests that use the token must use the same request parameters as the request that generated the token.
    public var nextToken: Swift.String?
    /// The way to sort the resulting response based on metrics. You can enter one sort criteria. By default resources are sorted based on AGENTS_ONLINE, DESCENDING. The metric collection is sorted based on the input metrics. Note the following:
    ///
    /// * Sorting on SLOTS_ACTIVE and SLOTS_AVAILABLE is not supported.
    public var sortCriteria: [ConnectClientTypes.CurrentMetricSortCriteria]?

    public init(
        currentMetrics: [ConnectClientTypes.CurrentMetric]? = nil,
        filters: ConnectClientTypes.Filters? = nil,
        groupings: [ConnectClientTypes.Grouping]? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortCriteria: [ConnectClientTypes.CurrentMetricSortCriteria]? = nil
    )
    {
        self.currentMetrics = currentMetrics
        self.filters = filters
        self.groupings = groupings
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

extension ConnectClientTypes {
    /// Contains the data for a real-time metric.
    public struct CurrentMetricData {
        /// Information about the metric.
        public var metric: ConnectClientTypes.CurrentMetric?
        /// The value of the metric.
        public var value: Swift.Double?

        public init(
            metric: ConnectClientTypes.CurrentMetric? = nil,
            value: Swift.Double? = nil
        )
        {
            self.metric = metric
            self.value = value
        }
    }

}

extension ConnectClientTypes {
    /// Information about the routing profile assigned to the user.
    public struct RoutingProfileReference {
        /// The Amazon Resource Name (ARN) of the routing profile.
        public var arn: Swift.String?
        /// The identifier of the routing profile.
        public var id: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
        }
    }

}

extension ConnectClientTypes {
    /// Contains information about the dimensions for a set of metrics.
    public struct Dimensions {
        /// The channel used for grouping and filters.
        public var channel: ConnectClientTypes.Channel?
        /// Information about the queue for which metrics are returned.
        public var queue: ConnectClientTypes.QueueReference?
        /// Information about the routing profile assigned to the user.
        public var routingProfile: ConnectClientTypes.RoutingProfileReference?
        /// The expression of a step in a routing criteria.
        public var routingStepExpression: Swift.String?

        public init(
            channel: ConnectClientTypes.Channel? = nil,
            queue: ConnectClientTypes.QueueReference? = nil,
            routingProfile: ConnectClientTypes.RoutingProfileReference? = nil,
            routingStepExpression: Swift.String? = nil
        )
        {
            self.channel = channel
            self.queue = queue
            self.routingProfile = routingProfile
            self.routingStepExpression = routingStepExpression
        }
    }

}

extension ConnectClientTypes {
    /// Contains information about a set of real-time metrics.
    public struct CurrentMetricResult {
        /// The set of metrics.
        public var collections: [ConnectClientTypes.CurrentMetricData]?
        /// The dimensions for the metrics.
        public var dimensions: ConnectClientTypes.Dimensions?

        public init(
            collections: [ConnectClientTypes.CurrentMetricData]? = nil,
            dimensions: ConnectClientTypes.Dimensions? = nil
        )
        {
            self.collections = collections
            self.dimensions = dimensions
        }
    }

}

public struct GetCurrentMetricDataOutput {
    /// The total count of the result, regardless of the current page size.
    public var approximateTotalCount: Swift.Int?
    /// The time at which the metrics were retrieved and cached for pagination.
    public var dataSnapshotTime: Foundation.Date?
    /// Information about the real-time metrics.
    public var metricResults: [ConnectClientTypes.CurrentMetricResult]?
    /// If there are additional results, this is the token for the next set of results. The token expires after 5 minutes from the time it is created. Subsequent requests that use the token must use the same request parameters as the request that generated the token.
    public var nextToken: Swift.String?

    public init(
        approximateTotalCount: Swift.Int? = nil,
        dataSnapshotTime: Foundation.Date? = nil,
        metricResults: [ConnectClientTypes.CurrentMetricResult]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.approximateTotalCount = approximateTotalCount
        self.dataSnapshotTime = dataSnapshotTime
        self.metricResults = metricResults
        self.nextToken = nextToken
    }
}

extension ConnectClientTypes {
    /// Filters user data based on the contact information that is associated to the users. It contains a list of [contact states](https://docs.aws.amazon.com/connect/latest/adminguide/about-contact-states.html).
    public struct ContactFilter {
        /// A list of up to 9 [contact states](https://docs.aws.amazon.com/connect/latest/adminguide/about-contact-states.html).
        public var contactStates: [ConnectClientTypes.ContactState]?

        public init(
            contactStates: [ConnectClientTypes.ContactState]? = nil
        )
        {
            self.contactStates = contactStates
        }
    }

}

extension ConnectClientTypes {
    /// A filter for the user data.
    public struct UserDataFilters {
        /// A list of up to 100 agent IDs or ARNs.
        public var agents: [Swift.String]?
        /// A filter for the user data based on the contact information that is associated to the user. It contains a list of contact states.
        public var contactFilter: ConnectClientTypes.ContactFilter?
        /// A list of up to 100 queues or ARNs.
        public var queues: [Swift.String]?
        /// A list of up to 100 routing profile IDs or ARNs.
        public var routingProfiles: [Swift.String]?
        /// A UserHierarchyGroup ID or ARN.
        public var userHierarchyGroups: [Swift.String]?

        public init(
            agents: [Swift.String]? = nil,
            contactFilter: ConnectClientTypes.ContactFilter? = nil,
            queues: [Swift.String]? = nil,
            routingProfiles: [Swift.String]? = nil,
            userHierarchyGroups: [Swift.String]? = nil
        )
        {
            self.agents = agents
            self.contactFilter = contactFilter
            self.queues = queues
            self.routingProfiles = routingProfiles
            self.userHierarchyGroups = userHierarchyGroups
        }
    }

}

public struct GetCurrentUserDataInput {
    /// The filters to apply to returned user data. You can filter up to the following limits:
    ///
    /// * Queues: 100
    ///
    /// * Routing profiles: 100
    ///
    /// * Agents: 100
    ///
    /// * Contact states: 9
    ///
    /// * User hierarchy groups: 1
    ///
    ///
    /// The user data is retrieved for only the specified values/resources in the filter. A maximum of one filter can be passed from queues, routing profiles, agents, and user hierarchy groups. Currently tagging is only supported on the resources that are passed in the filter.
    /// This member is required.
    public var filters: ConnectClientTypes.UserDataFilters?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: ConnectClientTypes.UserDataFilters? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ConnectClientTypes {
    /// Information about the hierarchy group.
    public struct HierarchyGroupSummaryReference {
        /// The Amazon Resource Name (ARN) for the hierarchy group.
        public var arn: Swift.String?
        /// The unique identifier for the hierarchy group.
        public var id: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
        }
    }

}

extension ConnectClientTypes {
    /// Information about the levels in the hierarchy group.
    public struct HierarchyPathReference {
        /// Information about level five.
        public var levelFive: ConnectClientTypes.HierarchyGroupSummaryReference?
        /// Information about level four.
        public var levelFour: ConnectClientTypes.HierarchyGroupSummaryReference?
        /// Information about level one.
        public var levelOne: ConnectClientTypes.HierarchyGroupSummaryReference?
        /// Information about level three.
        public var levelThree: ConnectClientTypes.HierarchyGroupSummaryReference?
        /// Information about level two.
        public var levelTwo: ConnectClientTypes.HierarchyGroupSummaryReference?

        public init(
            levelFive: ConnectClientTypes.HierarchyGroupSummaryReference? = nil,
            levelFour: ConnectClientTypes.HierarchyGroupSummaryReference? = nil,
            levelOne: ConnectClientTypes.HierarchyGroupSummaryReference? = nil,
            levelThree: ConnectClientTypes.HierarchyGroupSummaryReference? = nil,
            levelTwo: ConnectClientTypes.HierarchyGroupSummaryReference? = nil
        )
        {
            self.levelFive = levelFive
            self.levelFour = levelFour
            self.levelOne = levelOne
            self.levelThree = levelThree
            self.levelTwo = levelTwo
        }
    }

}

extension ConnectClientTypes {
    /// Information about the user.
    public struct UserReference {
        /// The Amazon Resource Name (ARN) for the user.
        public var arn: Swift.String?
        /// The unique identifier for the user.
        public var id: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
        }
    }

}

extension ConnectClientTypes {
    /// Data for a user.
    public struct UserData {
        /// A map of active slots by channel. The key is a channel name. The value is an integer: the number of active slots.
        public var activeSlotsByChannel: [Swift.String: Swift.Int]?
        /// A map of available slots by channel. The key is a channel name. The value is an integer: the available number of slots.
        public var availableSlotsByChannel: [Swift.String: Swift.Int]?
        /// A list of contact reference information.
        public var contacts: [ConnectClientTypes.AgentContactReference]?
        /// Contains information about the levels of a hierarchy group assigned to a user.
        public var hierarchyPath: ConnectClientTypes.HierarchyPathReference?
        /// A map of maximum slots by channel. The key is a channel name. The value is an integer: the maximum number of slots. This is calculated from [MediaConcurrency](https://docs.aws.amazon.com/connect/latest/APIReference/API_MediaConcurrency.html) of the RoutingProfile assigned to the agent.
        public var maxSlotsByChannel: [Swift.String: Swift.Int]?
        /// The Next status of the agent.
        public var nextStatus: Swift.String?
        /// Information about the routing profile that is assigned to the user.
        public var routingProfile: ConnectClientTypes.RoutingProfileReference?
        /// The status of the agent that they manually set in their Contact Control Panel (CCP), or that the supervisor manually changes in the real-time metrics report.
        public var status: ConnectClientTypes.AgentStatusReference?
        /// Information about the user for the data that is returned. It contains the resourceId and ARN of the user.
        public var user: ConnectClientTypes.UserReference?

        public init(
            activeSlotsByChannel: [Swift.String: Swift.Int]? = nil,
            availableSlotsByChannel: [Swift.String: Swift.Int]? = nil,
            contacts: [ConnectClientTypes.AgentContactReference]? = nil,
            hierarchyPath: ConnectClientTypes.HierarchyPathReference? = nil,
            maxSlotsByChannel: [Swift.String: Swift.Int]? = nil,
            nextStatus: Swift.String? = nil,
            routingProfile: ConnectClientTypes.RoutingProfileReference? = nil,
            status: ConnectClientTypes.AgentStatusReference? = nil,
            user: ConnectClientTypes.UserReference? = nil
        )
        {
            self.activeSlotsByChannel = activeSlotsByChannel
            self.availableSlotsByChannel = availableSlotsByChannel
            self.contacts = contacts
            self.hierarchyPath = hierarchyPath
            self.maxSlotsByChannel = maxSlotsByChannel
            self.nextStatus = nextStatus
            self.routingProfile = routingProfile
            self.status = status
            self.user = user
        }
    }

}

public struct GetCurrentUserDataOutput {
    /// The total count of the result, regardless of the current page size.
    public var approximateTotalCount: Swift.Int?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// A list of the user data that is returned.
    public var userDataList: [ConnectClientTypes.UserData]?

    public init(
        approximateTotalCount: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        userDataList: [ConnectClientTypes.UserData]? = nil
    )
    {
        self.approximateTotalCount = approximateTotalCount
        self.nextToken = nextToken
        self.userDataList = userDataList
    }
}

/// No user with the specified credentials was found in the Amazon Connect instance.
public struct UserNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UserNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct GetFederationTokenInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        instanceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

extension ConnectClientTypes {
    /// Contains credentials to use for federation.
    public struct Credentials {
        /// An access token generated for a federated user to access Amazon Connect.
        public var accessToken: Swift.String?
        /// A token generated with an expiration time for the session a user is logged in to Amazon Connect.
        public var accessTokenExpiration: Foundation.Date?
        /// Renews a token generated for a user to access the Amazon Connect instance.
        public var refreshToken: Swift.String?
        /// Renews the expiration timer for a generated token.
        public var refreshTokenExpiration: Foundation.Date?

        public init(
            accessToken: Swift.String? = nil,
            accessTokenExpiration: Foundation.Date? = nil,
            refreshToken: Swift.String? = nil,
            refreshTokenExpiration: Foundation.Date? = nil
        )
        {
            self.accessToken = accessToken
            self.accessTokenExpiration = accessTokenExpiration
            self.refreshToken = refreshToken
            self.refreshTokenExpiration = refreshTokenExpiration
        }
    }

}

extension ConnectClientTypes.Credentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

public struct GetFederationTokenOutput {
    /// The credentials to use for federation.
    public var credentials: ConnectClientTypes.Credentials?
    /// The URL to sign into the user's instance.
    public var signInUrl: Swift.String?
    /// The Amazon Resource Name (ARN) of the user.
    public var userArn: Swift.String?
    /// The identifier for the user. This can be the ID or the ARN of the user.
    public var userId: Swift.String?

    public init(
        credentials: ConnectClientTypes.Credentials? = nil,
        signInUrl: Swift.String? = nil,
        userArn: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.credentials = credentials
        self.signInUrl = signInUrl
        self.userArn = userArn
        self.userId = userId
    }
}

extension GetFederationTokenOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFederationTokenOutput(signInUrl: \(Swift.String(describing: signInUrl)), userArn: \(Swift.String(describing: userArn)), userId: \(Swift.String(describing: userId)), credentials: \"CONTENT_REDACTED\")"}
}

public struct GetFlowAssociationInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// A valid resource type.
    /// This member is required.
    public var resourceType: ConnectClientTypes.FlowAssociationResourceType?

    public init(
        instanceId: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: ConnectClientTypes.FlowAssociationResourceType? = nil
    )
    {
        self.instanceId = instanceId
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

public struct GetFlowAssociationOutput {
    /// The identifier of the flow.
    public var flowId: Swift.String?
    /// The identifier of the resource.
    public var resourceId: Swift.String?
    /// A valid resource type.
    public var resourceType: ConnectClientTypes.FlowAssociationResourceType?

    public init(
        flowId: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: ConnectClientTypes.FlowAssociationResourceType? = nil
    )
    {
        self.flowId = flowId
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

extension ConnectClientTypes {

    /// The historical metric names.
    public enum HistoricalMetricName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case abandonTime
        case afterContactWorkTime
        case apiContactsHandled
        case callbackContactsHandled
        case contactsAbandoned
        case contactsAgentHungUpFirst
        case contactsConsulted
        case contactsHandled
        case contactsHandledIncoming
        case contactsHandledOutbound
        case contactsHoldAbandons
        case contactsMissed
        case contactsQueued
        case contactsTransferredIn
        case contactsTransferredInFromQueue
        case contactsTransferredOut
        case contactsTransferredOutFromQueue
        case handleTime
        case holdTime
        case interactionAndHoldTime
        case interactionTime
        case occupancy
        case queuedTime
        case queueAnswerTime
        case serviceLevel
        case sdkUnknown(Swift.String)

        public static var allCases: [HistoricalMetricName] {
            return [
                .abandonTime,
                .afterContactWorkTime,
                .apiContactsHandled,
                .callbackContactsHandled,
                .contactsAbandoned,
                .contactsAgentHungUpFirst,
                .contactsConsulted,
                .contactsHandled,
                .contactsHandledIncoming,
                .contactsHandledOutbound,
                .contactsHoldAbandons,
                .contactsMissed,
                .contactsQueued,
                .contactsTransferredIn,
                .contactsTransferredInFromQueue,
                .contactsTransferredOut,
                .contactsTransferredOutFromQueue,
                .handleTime,
                .holdTime,
                .interactionAndHoldTime,
                .interactionTime,
                .occupancy,
                .queuedTime,
                .queueAnswerTime,
                .serviceLevel
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .abandonTime: return "ABANDON_TIME"
            case .afterContactWorkTime: return "AFTER_CONTACT_WORK_TIME"
            case .apiContactsHandled: return "API_CONTACTS_HANDLED"
            case .callbackContactsHandled: return "CALLBACK_CONTACTS_HANDLED"
            case .contactsAbandoned: return "CONTACTS_ABANDONED"
            case .contactsAgentHungUpFirst: return "CONTACTS_AGENT_HUNG_UP_FIRST"
            case .contactsConsulted: return "CONTACTS_CONSULTED"
            case .contactsHandled: return "CONTACTS_HANDLED"
            case .contactsHandledIncoming: return "CONTACTS_HANDLED_INCOMING"
            case .contactsHandledOutbound: return "CONTACTS_HANDLED_OUTBOUND"
            case .contactsHoldAbandons: return "CONTACTS_HOLD_ABANDONS"
            case .contactsMissed: return "CONTACTS_MISSED"
            case .contactsQueued: return "CONTACTS_QUEUED"
            case .contactsTransferredIn: return "CONTACTS_TRANSFERRED_IN"
            case .contactsTransferredInFromQueue: return "CONTACTS_TRANSFERRED_IN_FROM_QUEUE"
            case .contactsTransferredOut: return "CONTACTS_TRANSFERRED_OUT"
            case .contactsTransferredOutFromQueue: return "CONTACTS_TRANSFERRED_OUT_FROM_QUEUE"
            case .handleTime: return "HANDLE_TIME"
            case .holdTime: return "HOLD_TIME"
            case .interactionAndHoldTime: return "INTERACTION_AND_HOLD_TIME"
            case .interactionTime: return "INTERACTION_TIME"
            case .occupancy: return "OCCUPANCY"
            case .queuedTime: return "QUEUED_TIME"
            case .queueAnswerTime: return "QUEUE_ANSWER_TIME"
            case .serviceLevel: return "SERVICE_LEVEL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {

    public enum Statistic: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case avg
        case max
        case sum
        case sdkUnknown(Swift.String)

        public static var allCases: [Statistic] {
            return [
                .avg,
                .max,
                .sum
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .avg: return "AVG"
            case .max: return "MAX"
            case .sum: return "SUM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {

    public enum Comparison: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case lt
        case sdkUnknown(Swift.String)

        public static var allCases: [Comparison] {
            return [
                .lt
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .lt: return "LT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// Contains information about the threshold for service level metrics.
    public struct Threshold {
        /// The type of comparison. Only "less than" (LT) comparisons are supported.
        public var comparison: ConnectClientTypes.Comparison?
        /// The threshold value to compare.
        public var thresholdValue: Swift.Double?

        public init(
            comparison: ConnectClientTypes.Comparison? = nil,
            thresholdValue: Swift.Double? = nil
        )
        {
            self.comparison = comparison
            self.thresholdValue = thresholdValue
        }
    }

}

extension ConnectClientTypes {
    /// Contains information about a historical metric. For a description of each metric, see [Historical Metrics Definitions](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html) in the Amazon Connect Administrator Guide.
    public struct HistoricalMetric {
        /// The name of the metric.
        public var name: ConnectClientTypes.HistoricalMetricName?
        /// The statistic for the metric.
        public var statistic: ConnectClientTypes.Statistic?
        /// The threshold for the metric, used with service level metrics.
        public var threshold: ConnectClientTypes.Threshold?
        /// The unit for the metric.
        public var unit: ConnectClientTypes.Unit?

        public init(
            name: ConnectClientTypes.HistoricalMetricName? = nil,
            statistic: ConnectClientTypes.Statistic? = nil,
            threshold: ConnectClientTypes.Threshold? = nil,
            unit: ConnectClientTypes.Unit? = nil
        )
        {
            self.name = name
            self.statistic = statistic
            self.threshold = threshold
            self.unit = unit
        }
    }

}

public struct GetMetricDataInput {
    /// The timestamp, in UNIX Epoch time format, at which to end the reporting interval for the retrieval of historical metrics data. The time must be specified using an interval of 5 minutes, such as 11:00, 11:05, 11:10, and must be later than the start time timestamp. The time range between the start and end time must be less than 24 hours.
    /// This member is required.
    public var endTime: Foundation.Date?
    /// The queues, up to 100, or channels, to use to filter the metrics returned. Metric data is retrieved only for the resources associated with the queues or channels included in the filter. You can include both queue IDs and queue ARNs in the same request. VOICE, CHAT, and TASK channels are supported. RoutingStepExpression is not a valid filter for GetMetricData and we recommend switching to GetMetricDataV2 for more up-to-date features. To filter by Queues, enter the queue ID/ARN, not the name of the queue.
    /// This member is required.
    public var filters: ConnectClientTypes.Filters?
    /// The grouping applied to the metrics returned. For example, when results are grouped by queue, the metrics returned are grouped by queue. The values returned apply to the metrics for each queue rather than aggregated for all queues. If no grouping is specified, a summary of metrics for all queues is returned. RoutingStepExpression is not a valid filter for GetMetricData and we recommend switching to GetMetricDataV2 for more up-to-date features.
    public var groupings: [ConnectClientTypes.Grouping]?
    /// The metrics to retrieve. Specify the name, unit, and statistic for each metric. The following historical metrics are available. For a description of each metric, see [Historical Metrics Definitions](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html) in the Amazon Connect Administrator Guide. This API does not support a contacts incoming metric (there's no CONTACTS_INCOMING metric missing from the documented list). ABANDON_TIME Unit: SECONDS Statistic: AVG AFTER_CONTACT_WORK_TIME Unit: SECONDS Statistic: AVG API_CONTACTS_HANDLED Unit: COUNT Statistic: SUM CALLBACK_CONTACTS_HANDLED Unit: COUNT Statistic: SUM CONTACTS_ABANDONED Unit: COUNT Statistic: SUM CONTACTS_AGENT_HUNG_UP_FIRST Unit: COUNT Statistic: SUM CONTACTS_CONSULTED Unit: COUNT Statistic: SUM CONTACTS_HANDLED Unit: COUNT Statistic: SUM CONTACTS_HANDLED_INCOMING Unit: COUNT Statistic: SUM CONTACTS_HANDLED_OUTBOUND Unit: COUNT Statistic: SUM CONTACTS_HOLD_ABANDONS Unit: COUNT Statistic: SUM CONTACTS_MISSED Unit: COUNT Statistic: SUM CONTACTS_QUEUED Unit: COUNT Statistic: SUM CONTACTS_TRANSFERRED_IN Unit: COUNT Statistic: SUM CONTACTS_TRANSFERRED_IN_FROM_QUEUE Unit: COUNT Statistic: SUM CONTACTS_TRANSFERRED_OUT Unit: COUNT Statistic: SUM CONTACTS_TRANSFERRED_OUT_FROM_QUEUE Unit: COUNT Statistic: SUM HANDLE_TIME Unit: SECONDS Statistic: AVG HOLD_TIME Unit: SECONDS Statistic: AVG INTERACTION_AND_HOLD_TIME Unit: SECONDS Statistic: AVG INTERACTION_TIME Unit: SECONDS Statistic: AVG OCCUPANCY Unit: PERCENT Statistic: AVG QUEUE_ANSWER_TIME Unit: SECONDS Statistic: AVG QUEUED_TIME Unit: SECONDS Statistic: MAX SERVICE_LEVEL You can include up to 20 SERVICE_LEVEL metrics in a request. Unit: PERCENT Statistic: AVG Threshold: For ThresholdValue, enter any whole number from 1 to 604800 (inclusive), in seconds. For Comparison, you must enter LT (for "Less than").
    /// This member is required.
    public var historicalMetrics: [ConnectClientTypes.HistoricalMetric]?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The timestamp, in UNIX Epoch time format, at which to start the reporting interval for the retrieval of historical metrics data. The time must be specified using a multiple of 5 minutes, such as 10:05, 10:10, 10:15. The start time cannot be earlier than 24 hours before the time of the request. Historical metrics are available only for 24 hours.
    /// This member is required.
    public var startTime: Foundation.Date?

    public init(
        endTime: Foundation.Date? = nil,
        filters: ConnectClientTypes.Filters? = nil,
        groupings: [ConnectClientTypes.Grouping]? = nil,
        historicalMetrics: [ConnectClientTypes.HistoricalMetric]? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.endTime = endTime
        self.filters = filters
        self.groupings = groupings
        self.historicalMetrics = historicalMetrics
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
    }
}

extension ConnectClientTypes {
    /// Contains the data for a historical metric.
    public struct HistoricalMetricData {
        /// Information about the metric.
        public var metric: ConnectClientTypes.HistoricalMetric?
        /// The value of the metric.
        public var value: Swift.Double?

        public init(
            metric: ConnectClientTypes.HistoricalMetric? = nil,
            value: Swift.Double? = nil
        )
        {
            self.metric = metric
            self.value = value
        }
    }

}

extension ConnectClientTypes {
    /// Contains information about the historical metrics retrieved.
    public struct HistoricalMetricResult {
        /// The set of metrics.
        public var collections: [ConnectClientTypes.HistoricalMetricData]?
        /// The dimension for the metrics.
        public var dimensions: ConnectClientTypes.Dimensions?

        public init(
            collections: [ConnectClientTypes.HistoricalMetricData]? = nil,
            dimensions: ConnectClientTypes.Dimensions? = nil
        )
        {
            self.collections = collections
            self.dimensions = dimensions
        }
    }

}

public struct GetMetricDataOutput {
    /// Information about the historical metrics. If no grouping is specified, a summary of metric data is returned.
    public var metricResults: [ConnectClientTypes.HistoricalMetricResult]?
    /// If there are additional results, this is the token for the next set of results. The token expires after 5 minutes from the time it is created. Subsequent requests that use the token must use the same request parameters as the request that generated the token.
    public var nextToken: Swift.String?

    public init(
        metricResults: [ConnectClientTypes.HistoricalMetricResult]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.metricResults = metricResults
        self.nextToken = nextToken
    }
}

extension ConnectClientTypes {
    /// Contains the filter to apply when retrieving metrics with the [GetMetricDataV2](https://docs.aws.amazon.com/connect/latest/APIReference/API_GetMetricDataV2.html) API.
    public struct FilterV2 {
        /// The key to use for filtering data. For example, QUEUE, ROUTING_PROFILE, AGENT, CHANNEL, AGENT_HIERARCHY_LEVEL_ONE, AGENT_HIERARCHY_LEVEL_TWO, AGENT_HIERARCHY_LEVEL_THREE, AGENT_HIERARCHY_LEVEL_FOUR, AGENT_HIERARCHY_LEVEL_FIVE. There must be at least 1 key and a maximum 5 keys.
        public var filterKey: Swift.String?
        /// The identifiers to use for filtering data. For example, if you have a filter key of QUEUE, you would add queue IDs or ARNs in FilterValues.
        public var filterValues: [Swift.String]?

        public init(
            filterKey: Swift.String? = nil,
            filterValues: [Swift.String]? = nil
        )
        {
            self.filterKey = filterKey
            self.filterValues = filterValues
        }
    }

}

extension ConnectClientTypes {

    public enum IntervalPeriod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case day
        case fifteenMin
        case hour
        case thirtyMin
        case total
        case week
        case sdkUnknown(Swift.String)

        public static var allCases: [IntervalPeriod] {
            return [
                .day,
                .fifteenMin,
                .hour,
                .thirtyMin,
                .total,
                .week
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .day: return "DAY"
            case .fifteenMin: return "FIFTEEN_MIN"
            case .hour: return "HOUR"
            case .thirtyMin: return "THIRTY_MIN"
            case .total: return "TOTAL"
            case .week: return "WEEK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// Information about the interval period to use for returning results.
    public struct IntervalDetails {
        /// IntervalPeriod: An aggregated grouping applied to request metrics. Valid IntervalPeriod values are: FIFTEEN_MIN | THIRTY_MIN | HOUR | DAY | WEEK | TOTAL. For example, if IntervalPeriod is selected THIRTY_MIN, StartTime and EndTime differs by 1 day, then Amazon Connect returns 48 results in the response. Each result is aggregated by the THIRTY_MIN period. By default Amazon Connect aggregates results based on the TOTAL interval period. The following list describes restrictions on StartTime and EndTime based on what IntervalPeriod is requested.
        ///
        /// * FIFTEEN_MIN: The difference between StartTime and EndTime must be less than 3 days.
        ///
        /// * THIRTY_MIN: The difference between StartTime and EndTime must be less than 3 days.
        ///
        /// * HOUR: The difference between StartTime and EndTime must be less than 3 days.
        ///
        /// * DAY: The difference between StartTime and EndTime must be less than 35 days.
        ///
        /// * WEEK: The difference between StartTime and EndTime must be less than 35 days.
        ///
        /// * TOTAL: The difference between StartTime and EndTime must be less than 35 days.
        public var intervalPeriod: ConnectClientTypes.IntervalPeriod?
        /// The timezone applied to requested metrics.
        public var timeZone: Swift.String?

        public init(
            intervalPeriod: ConnectClientTypes.IntervalPeriod? = nil,
            timeZone: Swift.String? = nil
        )
        {
            self.intervalPeriod = intervalPeriod
            self.timeZone = timeZone
        }
    }

}

extension ConnectClientTypes {
    /// Contains information about the filter used when retrieving metrics. MetricFiltersV2 can be used on the following metrics: AVG_AGENT_CONNECTING_TIME, CONTACTS_CREATED, CONTACTS_HANDLED, SUM_CONTACTS_DISCONNECTED.
    public struct MetricFilterV2 {
        /// The key to use for filtering data. Valid metric filter keys: INITIATION_METHOD, DISCONNECT_REASON. These are the same values as the InitiationMethod and DisconnectReason in the contact record. For more information, see [ContactTraceRecord](https://docs.aws.amazon.com/connect/latest/adminguide/ctr-data-model.html#ctr-ContactTraceRecord) in the Amazon Connect Administrator Guide.
        public var metricFilterKey: Swift.String?
        /// The values to use for filtering data. Valid metric filter values for INITIATION_METHOD: INBOUND | OUTBOUND | TRANSFER | QUEUE_TRANSFER | CALLBACK | API Valid metric filter values for DISCONNECT_REASON: CUSTOMER_DISCONNECT | AGENT_DISCONNECT | THIRD_PARTY_DISCONNECT | TELECOM_PROBLEM | BARGED | CONTACT_FLOW_DISCONNECT | OTHER | EXPIRED | API
        public var metricFilterValues: [Swift.String]?
        /// The flag to use to filter on requested metric filter values or to not filter on requested metric filter values. By default the negate is false, which indicates to filter on the requested metric filter.
        public var negate: Swift.Bool

        public init(
            metricFilterKey: Swift.String? = nil,
            metricFilterValues: [Swift.String]? = nil,
            negate: Swift.Bool = false
        )
        {
            self.metricFilterKey = metricFilterKey
            self.metricFilterValues = metricFilterValues
            self.negate = negate
        }
    }

}

extension ConnectClientTypes {
    /// Contains information about the threshold for service level metrics.
    public struct ThresholdV2 {
        /// The type of comparison. Only "less than" (LT) and "greater than" (GT) comparisons are supported.
        public var comparison: Swift.String?
        /// The threshold value to compare.
        public var thresholdValue: Swift.Double?

        public init(
            comparison: Swift.String? = nil,
            thresholdValue: Swift.Double? = nil
        )
        {
            self.comparison = comparison
            self.thresholdValue = thresholdValue
        }
    }

}

extension ConnectClientTypes {
    /// Contains information about the metric.
    public struct MetricV2 {
        /// Contains the filters to be used when returning data.
        public var metricFilters: [ConnectClientTypes.MetricFilterV2]?
        /// The name of the metric. This parameter is required. The following Required = No is incorrect.
        public var name: Swift.String?
        /// Contains information about the threshold for service level metrics.
        public var threshold: [ConnectClientTypes.ThresholdV2]?

        public init(
            metricFilters: [ConnectClientTypes.MetricFilterV2]? = nil,
            name: Swift.String? = nil,
            threshold: [ConnectClientTypes.ThresholdV2]? = nil
        )
        {
            self.metricFilters = metricFilters
            self.name = name
            self.threshold = threshold
        }
    }

}

public struct GetMetricDataV2Input {
    /// The timestamp, in UNIX Epoch time format, at which to end the reporting interval for the retrieval of historical metrics data. The time must be later than the start time timestamp. It cannot be later than the current timestamp.
    /// This member is required.
    public var endTime: Foundation.Date?
    /// The filters to apply to returned metrics. You can filter on the following resources:
    ///
    /// * Agents
    ///
    /// * Campaigns
    ///
    /// * Channels
    ///
    /// * Feature
    ///
    /// * Queues
    ///
    /// * Routing profiles
    ///
    /// * Routing step expression
    ///
    /// * User hierarchy groups
    ///
    ///
    /// At least one filter must be passed from queues, routing profiles, agents, or user hierarchy groups. For metrics for outbound campaigns analytics, you can also use campaigns to satisfy at least one filter requirement. To filter by phone number, see [Create a historical metrics report](https://docs.aws.amazon.com/connect/latest/adminguide/create-historical-metrics-report.html) in the Amazon Connect Administrator Guide. Note the following limits:
    ///
    /// * Filter keys: A maximum of 5 filter keys are supported in a single request. Valid filter keys: AGENT | AGENT_HIERARCHY_LEVEL_ONE | AGENT_HIERARCHY_LEVEL_TWO | AGENT_HIERARCHY_LEVEL_THREE | AGENT_HIERARCHY_LEVEL_FOUR | AGENT_HIERARCHY_LEVEL_FIVE | ANSWERING_MACHINE_DETECTION_STATUS | CAMPAIGN | CASE_TEMPLATE_ARN | CASE_STATUS | CHANNEL | contact/segmentAttributes/connect:Subtype | DISCONNECT_REASON | FEATURE | FLOW_TYPE | FLOWS_NEXT_RESOURCE_ID | FLOWS_NEXT_RESOURCE_QUEUE_ID | FLOWS_OUTCOME_TYPE | FLOWS_RESOURCE_ID | INITIATION_METHOD | RESOURCE_PUBLISHED_TIMESTAMP | ROUTING_PROFILE | ROUTING_STEP_EXPRESSION | QUEUE | Q_CONNECT_ENABLED |
    ///
    /// * Filter values: A maximum of 100 filter values are supported in a single request. VOICE, CHAT, and TASK are valid filterValue for the CHANNEL filter key. They do not count towards limitation of 100 filter values. For example, a GetMetricDataV2 request can filter by 50 queues, 35 agents, and 15 routing profiles for a total of 100 filter values, along with 3 channel filters. contact_lens_conversational_analytics is a valid filterValue for the FEATURE filter key. It is available only to contacts analyzed by Contact Lens conversational analytics. connect:Chat, connect:SMS, connect:Telephony, and connect:WebRTC are valid filterValue examples (not exhaustive) for the contact/segmentAttributes/connect:Subtype filter key. ROUTING_STEP_EXPRESSION is a valid filter key with a filter value up to 3000 length. This filter is case and order sensitive. JSON string fields must be sorted in ascending order and JSON array order should be kept as is. Q_CONNECT_ENABLED. TRUE and FALSE are the only valid filterValues for the Q_CONNECT_ENABLED filter key.
    ///
    /// * TRUE includes all contacts that had Amazon Q in Connect enabled as part of the flow.
    ///
    /// * FALSE includes all contacts that did not have Amazon Q in Connect enabled as part of the flow
    ///
    ///
    /// This filter is available only for contact record-driven metrics. [Campaign](https://docs.aws.amazon.com/connect/latest/APIReference/API_connect-outbound-campaigns_Campaign.html) ARNs are valid filterValues for the CAMPAIGN filter key.
    /// This member is required.
    public var filters: [ConnectClientTypes.FilterV2]?
    /// The grouping applied to the metrics that are returned. For example, when results are grouped by queue, the metrics returned are grouped by queue. The values that are returned apply to the metrics for each queue. They are not aggregated for all queues. If no grouping is specified, a summary of all metrics is returned. Valid grouping keys: AGENT | AGENT_HIERARCHY_LEVEL_ONE | AGENT_HIERARCHY_LEVEL_TWO | AGENT_HIERARCHY_LEVEL_THREE | AGENT_HIERARCHY_LEVEL_FOUR | AGENT_HIERARCHY_LEVEL_FIVE | ANSWERING_MACHINE_DETECTION_STATUS | CAMPAIGN | CASE_TEMPLATE_ARN | CASE_STATUS | CHANNEL | contact/segmentAttributes/connect:Subtype | DISCONNECT_REASON | FLOWS_RESOURCE_ID | FLOWS_MODULE_RESOURCE_ID | FLOW_TYPE | FLOWS_OUTCOME_TYPE | INITIATION_METHOD | Q_CONNECT_ENABLED | QUEUE | RESOURCE_PUBLISHED_TIMESTAMP | ROUTING_PROFILE | ROUTING_STEP_EXPRESSION
    public var groupings: [Swift.String]?
    /// The interval period and timezone to apply to returned metrics.
    ///
    /// * IntervalPeriod: An aggregated grouping applied to request metrics. Valid IntervalPeriod values are: FIFTEEN_MIN | THIRTY_MIN | HOUR | DAY | WEEK | TOTAL. For example, if IntervalPeriod is selected THIRTY_MIN, StartTime and EndTime differs by 1 day, then Amazon Connect returns 48 results in the response. Each result is aggregated by the THIRTY_MIN period. By default Amazon Connect aggregates results based on the TOTAL interval period. The following list describes restrictions on StartTime and EndTime based on which IntervalPeriod is requested.
    ///
    /// * FIFTEEN_MIN: The difference between StartTime and EndTime must be less than 3 days.
    ///
    /// * THIRTY_MIN: The difference between StartTime and EndTime must be less than 3 days.
    ///
    /// * HOUR: The difference between StartTime and EndTime must be less than 3 days.
    ///
    /// * DAY: The difference between StartTime and EndTime must be less than 35 days.
    ///
    /// * WEEK: The difference between StartTime and EndTime must be less than 35 days.
    ///
    /// * TOTAL: The difference between StartTime and EndTime must be less than 35 days.
    ///
    ///
    ///
    ///
    /// * TimeZone: The timezone applied to requested metrics.
    public var interval: ConnectClientTypes.IntervalDetails?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The metrics to retrieve. Specify the name, groupings, and filters for each metric. The following historical metrics are available. For a description of each metric, see [Historical metrics definitions](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html) in the Amazon Connect Administrator Guide. ABANDONMENT_RATE Unit: Percent Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Feature, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: [Abandonment rate](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#abandonment-rate-historical) AGENT_ADHERENT_TIME This metric is available only in Amazon Web Services Regions where [Forecasting, capacity planning, and scheduling](https://docs.aws.amazon.com/connect/latest/adminguide/regions.html#optimization_region) is available. Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy UI name: [Adherent time](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#adherent-time-historical) AGENT_ANSWER_RATE Unit: Percent Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy UI name: [Agent answer rate](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#agent-answer-rate-historical) AGENT_NON_ADHERENT_TIME Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy UI name: [Non-adherent time](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#non-adherent-time) AGENT_NON_RESPONSE Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy UI name: [Agent non-response](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#agent-non-response) AGENT_NON_RESPONSE_WITHOUT_CUSTOMER_ABANDONS Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy Data for this metric is available starting from October 1, 2023 0:00:00 GMT. UI name: [Agent non-response without customer abandons](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#agent-nonresponse-no-abandon-historical) AGENT_OCCUPANCY Unit: Percentage Valid groupings and filters: Routing Profile, Agent, Agent Hierarchy UI name: [Occupancy](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#occupancy-historical) AGENT_SCHEDULE_ADHERENCE This metric is available only in Amazon Web Services Regions where [Forecasting, capacity planning, and scheduling](https://docs.aws.amazon.com/connect/latest/adminguide/regions.html#optimization_region) is available. Unit: Percent Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy UI name: [Adherence](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#adherence-historical) AGENT_SCHEDULED_TIME This metric is available only in Amazon Web Services Regions where [Forecasting, capacity planning, and scheduling](https://docs.aws.amazon.com/connect/latest/adminguide/regions.html#optimization_region) is available. Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy UI name: [Scheduled time](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#scheduled-time-historical) AVG_ABANDON_TIME Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Feature, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: [Average queue abandon time](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-queue-abandon-time-historical) AVG_ACTIVE_TIME Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Q in Connect UI name: [Average active time](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-active-time-historical) AVG_AFTER_CONTACT_WORK_TIME Unit: Seconds Valid metric filter key: INITIATION_METHOD Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Feature, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: [Average after contact work time](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-acw-time-historical) Feature is a valid filter but not a valid grouping. AVG_AGENT_CONNECTING_TIME Unit: Seconds Valid metric filter key: INITIATION_METHOD. For now, this metric only supports the following as INITIATION_METHOD: INBOUND | OUTBOUND | CALLBACK | API Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy UI name: [Average agent API connecting time](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#htm-avg-agent-api-connecting-time) The Negate key in Metric Level Filters is not applicable for this metric. AVG_AGENT_PAUSE_TIME Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Q in Connect UI name: [Average agent pause time](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-agent-pause-time-historical) AVG_CASE_RELATED_CONTACTS Unit: Count Required filter key: CASE_TEMPLATE_ARN Valid groupings and filters: CASE_TEMPLATE_ARN, CASE_STATUS UI name: [Average contacts per case](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-contacts-case-historical) AVG_CASE_RESOLUTION_TIME Unit: Seconds Required filter key: CASE_TEMPLATE_ARN Valid groupings and filters: CASE_TEMPLATE_ARN, CASE_STATUS UI name: [Average case resolution time](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-case-resolution-time-historical) AVG_CONTACT_DURATION Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Feature, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: [Average contact duration](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-contact-duration-historical) Feature is a valid filter but not a valid grouping. AVG_CONVERSATION_DURATION Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Feature, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: [Average conversation duration](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-conversation-duration-historical) AVG_DIALS_PER_MINUTE This metric is available only for contacts analyzed by outbound campaigns analytics. Unit: Count Valid groupings and filters: Campaign, Agent, Queue, Routing Profile UI name: [Average dials per minute](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-dials-historical) AVG_FLOW_TIME Unit: Seconds Valid groupings and filters: Channel, contact/segmentAttributes/connect:Subtype, Flow type, Flows module resource ID, Flows next resource ID, Flows next resource queue ID, Flows outcome type, Flows resource ID, Initiation method, Resource published timestamp UI name: [Average flow time](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-flow-time-historical) AVG_GREETING_TIME_AGENT This metric is available only for contacts analyzed by Contact Lens conversational analytics. Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: [Average agent greeting time](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-greeting-time-agent-historical) AVG_HANDLE_TIME Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Feature, contact/segmentAttributes/connect:Subtype, RoutingStepExpression UI name: [Average handle time](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-handle-time-historical) Feature is a valid filter but not a valid grouping. AVG_HOLD_TIME Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Feature, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: [Average customer hold time](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-customer-hold-time-historical) Feature is a valid filter but not a valid grouping. AVG_HOLD_TIME_ALL_CONTACTS Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: [Average customer hold time all contacts](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#avg-customer-hold-time-all-contacts-historical) AVG_HOLDS Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Feature, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: [Average holds](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-holds-historical) Feature is a valid filter but not a valid grouping. AVG_INTERACTION_AND_HOLD_TIME Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: [Average agent interaction and customer hold time](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-agent-interaction-customer-hold-time-historical) AVG_INTERACTION_TIME Unit: Seconds Valid metric filter key: INITIATION_METHOD Valid groupings and filters: Queue, Channel, Routing Profile, Feature, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: [Average agent interaction time](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-agent-interaction-time-historical) Feature is a valid filter but not a valid grouping. AVG_INTERRUPTIONS_AGENT This metric is available only for contacts analyzed by Contact Lens conversational analytics. Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: [Average agent interruptions](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-interruptions-agent-historical) AVG_INTERRUPTION_TIME_AGENT This metric is available only for contacts analyzed by Contact Lens conversational analytics. Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: [Average agent interruption time](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-interruptions-time-agent-historical) AVG_NON_TALK_TIME This metric is available only for contacts analyzed by Contact Lens conversational analytics. Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: [Average non-talk time](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html##average-non-talk-time-historical) AVG_QUEUE_ANSWER_TIME Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Feature, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: [Average queue answer time](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-queue-answer-time-historical) Feature is a valid filter but not a valid grouping. AVG_RESOLUTION_TIME Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: [Average resolution time](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-resolution-time-historical) AVG_TALK_TIME This metric is available only for contacts analyzed by Contact Lens conversational analytics. Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: [Average talk time](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-talk-time-historical) AVG_TALK_TIME_AGENT This metric is available only for contacts analyzed by Contact Lens conversational analytics. Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: [Average agent talk time](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-talk-time-agent-historical) AVG_TALK_TIME_CUSTOMER This metric is available only for contacts analyzed by Contact Lens conversational analytics. Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: [Average customer talk time](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-talk-time-customer-historical) AVG_WAIT_TIME_AFTER_CUSTOMER_CONNECTION This metric is available only for contacts analyzed by outbound campaigns analytics. Unit: Seconds Valid groupings and filters: Campaign UI name: [Average wait time after customer connection](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-wait-time-historical) CAMPAIGN_CONTACTS_ABANDONED_AFTER_X This metric is available only for contacts analyzed by outbound campaigns analytics. Unit: Count Valid groupings and filters: Campaign, Agent Threshold: For ThresholdValue, enter any whole number from 1 to 604800 (inclusive), in seconds. For Comparison, you must enter GT (for Greater than). UI name: [Campaign contacts abandoned after X](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#campaign-contacts-abandoned-historical) CAMPAIGN_CONTACTS_ABANDONED_AFTER_X_RATE This metric is available only for contacts analyzed by outbound campaigns analytics. Unit: Percent Valid groupings and filters: Campaign, Agent Threshold: For ThresholdValue, enter any whole number from 1 to 604800 (inclusive), in seconds. For Comparison, you must enter GT (for Greater than). UI name: [Campaign contacts abandoned after X rate](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#campaign-contacts-abandoned-rate-historical) CASES_CREATED Unit: Count Required filter key: CASE_TEMPLATE_ARN Valid groupings and filters: CASE_TEMPLATE_ARN, CASE_STATUS UI name: [Cases created](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#cases-created-historical) CONTACTS_CREATED Unit: Count Valid metric filter key: INITIATION_METHOD Valid groupings and filters: Queue, Channel, Routing Profile, Feature, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: [Contacts created](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contacts-created-historical) Feature is a valid filter but not a valid grouping. CONTACTS_HANDLED Unit: Count Valid metric filter key: INITIATION_METHOD, DISCONNECT_REASON Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Feature, contact/segmentAttributes/connect:Subtype, RoutingStepExpression, Q in Connect UI name: [API contacts handled](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#api-contacts-handled-historical) Feature is a valid filter but not a valid grouping. CONTACTS_HANDLED_BY_CONNECTED_TO_AGENT Unit: Count Valid metric filter key: INITIATION_METHOD Valid groupings and filters: Queue, Channel, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: [Contacts handled (connected to agent timestamp)](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contacts-handled-by-connected-to-agent-historical) CONTACTS_HOLD_ABANDONS Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: [Contacts hold disconnect](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contacts-handled-by-connected-to-agent-historical) CONTACTS_ON_HOLD_AGENT_DISCONNECT Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Q in Connect UI name: [Contacts hold agent disconnect](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contacts-hold-agent-disconnect-historical) CONTACTS_ON_HOLD_CUSTOMER_DISCONNECT Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Q in Connect UI name: [Contacts hold customer disconnect](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contacts-hold-customer-disconnect-historical) CONTACTS_PUT_ON_HOLD Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Q in Connect UI name: [Contacts put on hold](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contacts-hold-customer-disconnect-historical) CONTACTS_TRANSFERRED_OUT_EXTERNAL Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Q in Connect UI name: [Contacts transferred out external](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contacts-transferred-out-external-historical) CONTACTS_TRANSFERRED_OUT_INTERNAL Unit: Percent Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Q in Connect UI name: [Contacts transferred out internal](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contacts-transferred-out-internal-historical) CONTACTS_QUEUED Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: [Contacts queued](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contacts-queued-historical) CONTACTS_QUEUED_BY_ENQUEUE Unit: Count Valid groupings and filters: Queue, Channel, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype UI name: [Contacts queued (enqueue timestamp)](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contacts-queued-by-enqueue-historical) CONTACTS_REMOVED_FROM_QUEUE_IN_X Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Q in Connect Threshold: For ThresholdValue, enter any whole number from 1 to 604800 (inclusive), in seconds. For Comparison, you must enter LT (for "Less than"). UI name: [Contacts removed from queue in X seconds](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contacts-removed-historical) CONTACTS_RESOLVED_IN_X Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, contact/segmentAttributes/connect:Subtype, Q in Connect Threshold: For ThresholdValue enter any whole number from 1 to 604800 (inclusive), in seconds. For Comparison, you must enter LT (for "Less than"). UI name: [Contacts resolved in X](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contacts-resolved-historical) CONTACTS_TRANSFERRED_OUT Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Feature, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: [Contacts transferred out](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contacts-transferred-out-historical) Feature is a valid filter but not a valid grouping. CONTACTS_TRANSFERRED_OUT_BY_AGENT Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: [Contacts transferred out by agent](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contacts-transferred-out-by-agent-historical) CONTACTS_TRANSFERRED_OUT_FROM_QUEUE Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: [Contacts transferred out queue](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contacts-transferred-out-by-agent-historical) CURRENT_CASES Unit: Count Required filter key: CASE_TEMPLATE_ARN Valid groupings and filters: CASE_TEMPLATE_ARN, CASE_STATUS UI name: [Current cases](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#current-cases-historical) DELIVERY_ATTEMPTS This metric is available only for contacts analyzed by outbound campaigns analytics. Unit: Count Valid metric filter key: ANSWERING_MACHINE_DETECTION_STATUS, DISCONNECT_REASON Valid groupings and filters: Campaign, Agent, Queue, Routing Profile, Answering Machine Detection Status, Disconnect Reason UI name: [Delivery attempts](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#delivery-attempts-historical) DELIVERY_ATTEMPT_DISPOSITION_RATE This metric is available only for contacts analyzed by outbound campaigns analytics, and with the answering machine detection enabled. Unit: Percent Valid metric filter key: ANSWERING_MACHINE_DETECTION_STATUS, DISCONNECT_REASON Valid groupings and filters: Campaign, Agent, Answering Machine Detection Status, Disconnect Reason Answering Machine Detection Status and Disconnect Reason are valid filters but not valid groupings. UI name: [Delivery attempt disposition rate](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#delivery-attempt-disposition-rate-historical) FLOWS_OUTCOME Unit: Count Valid groupings and filters: Channel, contact/segmentAttributes/connect:Subtype, Flow type, Flows module resource ID, Flows next resource ID, Flows next resource queue ID, Flows outcome type, Flows resource ID, Initiation method, Resource published timestamp UI name: [Flows outcome](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#flows-outcome-historical) FLOWS_STARTED Unit: Count Valid groupings and filters: Channel, contact/segmentAttributes/connect:Subtype, Flow type, Flows module resource ID, Flows resource ID, Initiation method, Resource published timestamp UI name: [Flows started](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#flows-started-historical) HUMAN_ANSWERED_CALLS This metric is available only for contacts analyzed by outbound campaigns analytics, and with the answering machine detection enabled. Unit: Count Valid groupings and filters: Campaign, Agent UI name: [Human answered](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#human-answered-historical) MAX_FLOW_TIME Unit: Seconds Valid groupings and filters: Channel, contact/segmentAttributes/connect:Subtype, Flow type, Flows module resource ID, Flows next resource ID, Flows next resource queue ID, Flows outcome type, Flows resource ID, Initiation method, Resource published timestamp UI name: [Maximum flow time](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#maximum-flow-time-historical) MAX_QUEUED_TIME Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: [Maximum queued time](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#maximum-queued-time-historical) MIN_FLOW_TIME Unit: Seconds Valid groupings and filters: Channel, contact/segmentAttributes/connect:Subtype, Flow type, Flows module resource ID, Flows next resource ID, Flows next resource queue ID, Flows outcome type, Flows resource ID, Initiation method, Resource published timestamp UI name: [Minimum flow time](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#minimum-flow-time-historical) PERCENT_CASES_FIRST_CONTACT_RESOLVED Unit: Percent Required filter key: CASE_TEMPLATE_ARN Valid groupings and filters: CASE_TEMPLATE_ARN, CASE_STATUS UI name: [Cases resolved on first contact](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#cases-resolved-first-contact-historical) PERCENT_CONTACTS_STEP_EXPIRED Unit: Percent Valid groupings and filters: Queue, RoutingStepExpression UI name: This metric is available in Real-time Metrics UI but not on the Historical Metrics UI. PERCENT_CONTACTS_STEP_JOINED Unit: Percent Valid groupings and filters: Queue, RoutingStepExpression UI name: This metric is available in Real-time Metrics UI but not on the Historical Metrics UI. PERCENT_FLOWS_OUTCOME Unit: Percent Valid metric filter key: FLOWS_OUTCOME_TYPE Valid groupings and filters: Channel, contact/segmentAttributes/connect:Subtype, Flow type, Flows module resource ID, Flows next resource ID, Flows next resource queue ID, Flows outcome type, Flows resource ID, Initiation method, Resource published timestamp UI name: [Flows outcome percentage](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#flows-outcome-percentage-historical). The FLOWS_OUTCOME_TYPE is not a valid grouping. PERCENT_NON_TALK_TIME This metric is available only for contacts analyzed by Contact Lens conversational analytics. Unit: Percentage Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: [Non-talk time percent](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#ntt-historical) PERCENT_TALK_TIME This metric is available only for contacts analyzed by Contact Lens conversational analytics. Unit: Percentage Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: [Talk time percent](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#tt-historical) PERCENT_TALK_TIME_AGENT This metric is available only for contacts analyzed by Contact Lens conversational analytics. Unit: Percentage Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: [Agent talk time percent](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#ttagent-historical) PERCENT_TALK_TIME_CUSTOMER This metric is available only for contacts analyzed by Contact Lens conversational analytics. Unit: Percentage Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: [Customer talk time percent](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#ttcustomer-historical) REOPENED_CASE_ACTIONS Unit: Count Required filter key: CASE_TEMPLATE_ARN Valid groupings and filters: CASE_TEMPLATE_ARN, CASE_STATUS UI name: [Cases reopened](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#cases-reopened-historical) RESOLVED_CASE_ACTIONS Unit: Count Required filter key: CASE_TEMPLATE_ARN Valid groupings and filters: CASE_TEMPLATE_ARN, CASE_STATUS UI name: [Cases resolved](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#cases-resolved-historical) SERVICE_LEVEL You can include up to 20 SERVICE_LEVEL metrics in a request. Unit: Percent Valid groupings and filters: Queue, Channel, Routing Profile, Q in Connect Threshold: For ThresholdValue, enter any whole number from 1 to 604800 (inclusive), in seconds. For Comparison, you must enter LT (for "Less than"). UI name: [Service level X](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#service-level-historical) STEP_CONTACTS_QUEUED Unit: Count Valid groupings and filters: Queue, RoutingStepExpression UI name: This metric is available in Real-time Metrics UI but not on the Historical Metrics UI. SUM_AFTER_CONTACT_WORK_TIME Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Q in Connect UI name: [After contact work time](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#acw-historical) SUM_CONNECTING_TIME_AGENT Unit: Seconds Valid metric filter key: INITIATION_METHOD. This metric only supports the following filter keys as INITIATION_METHOD: INBOUND | OUTBOUND | CALLBACK | API Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy UI name: [Agent API connecting time](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#htm-agent-api-connecting-time) The Negate key in Metric Level Filters is not applicable for this metric. CONTACTS_ABANDONED Unit: Count Metric filter:
    ///
    /// * Valid values: API| Incoming | Outbound | Transfer | Callback | Queue_Transfer| Disconnect
    ///
    ///
    /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, RoutingStepExpression, Q in Connect UI name: [Contact abandoned](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contacts-abandoned-historical) SUM_CONTACTS_ABANDONED_IN_X Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, contact/segmentAttributes/connect:Subtype, Q in Connect Threshold: For ThresholdValue, enter any whole number from 1 to 604800 (inclusive), in seconds. For Comparison, you must enter LT (for "Less than"). UI name: [Contacts abandoned in X seconds](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contacts-abandoned-x-historical) SUM_CONTACTS_ANSWERED_IN_X Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, contact/segmentAttributes/connect:Subtype, Q in Connect Threshold: For ThresholdValue, enter any whole number from 1 to 604800 (inclusive), in seconds. For Comparison, you must enter LT (for "Less than"). UI name: [Contacts answered in X seconds](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contacts-answered-x-historical) SUM_CONTACT_FLOW_TIME Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Q in Connect UI name: [Contact flow time](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contact-flow-time-historical) SUM_CONTACT_TIME_AGENT Unit: Seconds Valid groupings and filters: Routing Profile, Agent, Agent Hierarchy UI name: [Agent on contact time](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#agent-on-contact-time-historical) SUM_CONTACTS_DISCONNECTED Valid metric filter key: DISCONNECT_REASON Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: [Contact disconnected](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contact-disconnected-historical) SUM_ERROR_STATUS_TIME_AGENT Unit: Seconds Valid groupings and filters: Routing Profile, Agent, Agent Hierarchy UI name: [Error status time](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#error-status-time-historical) SUM_HANDLE_TIME Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Q in Connect UI name: [Contact handle time](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contact-handle-time-historical) SUM_HOLD_TIME Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Q in Connect UI name: [Customer hold time](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#customer-hold-time-historical) SUM_IDLE_TIME_AGENT Unit: Seconds Valid groupings and filters: Routing Profile, Agent, Agent Hierarchy UI name: [Agent idle time](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#agent-idle-time-historica) SUM_INTERACTION_AND_HOLD_TIME Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Q in Connect UI name: [Agent interaction and hold time](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#agent-interaction-hold-time-historical) SUM_INTERACTION_TIME Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy UI name: [Agent interaction time](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#agent-interaction-time-historical) SUM_NON_PRODUCTIVE_TIME_AGENT Unit: Seconds Valid groupings and filters: Routing Profile, Agent, Agent Hierarchy UI name: [Non-Productive Time](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#npt-historical) SUM_ONLINE_TIME_AGENT Unit: Seconds Valid groupings and filters: Routing Profile, Agent, Agent Hierarchy UI name: [Online time](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#online-time-historical) SUM_RETRY_CALLBACK_ATTEMPTS Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: [Callback attempts](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#callback-attempts-historical)
    /// This member is required.
    public var metrics: [ConnectClientTypes.MetricV2]?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource. This includes the instanceId an Amazon Connect instance.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The timestamp, in UNIX Epoch time format, at which to start the reporting interval for the retrieval of historical metrics data. The time must be before the end time timestamp. The start and end time depends on the IntervalPeriod selected. By default the time range between start and end time is 35 days. Historical metrics are available for 3 months.
    /// This member is required.
    public var startTime: Foundation.Date?

    public init(
        endTime: Foundation.Date? = nil,
        filters: [ConnectClientTypes.FilterV2]? = nil,
        groupings: [Swift.String]? = nil,
        interval: ConnectClientTypes.IntervalDetails? = nil,
        maxResults: Swift.Int? = nil,
        metrics: [ConnectClientTypes.MetricV2]? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.endTime = endTime
        self.filters = filters
        self.groupings = groupings
        self.interval = interval
        self.maxResults = maxResults
        self.metrics = metrics
        self.nextToken = nextToken
        self.resourceArn = resourceArn
        self.startTime = startTime
    }
}

extension ConnectClientTypes {
    /// Contains the name, thresholds, and metric filters.
    public struct MetricDataV2 {
        /// The metric name, thresholds, and metric filters of the returned metric.
        public var metric: ConnectClientTypes.MetricV2?
        /// The corresponding value of the metric returned in the response.
        public var value: Swift.Double?

        public init(
            metric: ConnectClientTypes.MetricV2? = nil,
            value: Swift.Double? = nil
        )
        {
            self.metric = metric
            self.value = value
        }
    }

}

extension ConnectClientTypes {
    /// The interval period with the start and end time for the metrics.
    public struct MetricInterval {
        /// The timestamp, in UNIX Epoch time format. End time is based on the interval period selected. For example, If IntervalPeriod is selected THIRTY_MIN, StartTime and EndTime in the API request differs by 1 day, then 48 results are returned in the response. Each result is aggregated by the 30 minutes period, with each StartTime and EndTime differing by 30 minutes.
        public var endTime: Foundation.Date?
        /// The interval period provided in the API request.
        public var interval: ConnectClientTypes.IntervalPeriod?
        /// The timestamp, in UNIX Epoch time format. Start time is based on the interval period selected.
        public var startTime: Foundation.Date?

        public init(
            endTime: Foundation.Date? = nil,
            interval: ConnectClientTypes.IntervalPeriod? = nil,
            startTime: Foundation.Date? = nil
        )
        {
            self.endTime = endTime
            self.interval = interval
            self.startTime = startTime
        }
    }

}

extension ConnectClientTypes {
    /// Contains information about the metric results.
    public struct MetricResultV2 {
        /// The set of metrics.
        public var collections: [ConnectClientTypes.MetricDataV2]?
        /// The dimension for the metrics.
        public var dimensions: [Swift.String: Swift.String]?
        /// The interval period with the start and end time for the metrics.
        public var metricInterval: ConnectClientTypes.MetricInterval?

        public init(
            collections: [ConnectClientTypes.MetricDataV2]? = nil,
            dimensions: [Swift.String: Swift.String]? = nil,
            metricInterval: ConnectClientTypes.MetricInterval? = nil
        )
        {
            self.collections = collections
            self.dimensions = dimensions
            self.metricInterval = metricInterval
        }
    }

}

public struct GetMetricDataV2Output {
    /// Information about the metrics requested in the API request If no grouping is specified, a summary of metric data is returned.
    public var metricResults: [ConnectClientTypes.MetricResultV2]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        metricResults: [ConnectClientTypes.MetricResultV2]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.metricResults = metricResults
        self.nextToken = nextToken
    }
}

public struct GetPromptFileInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A unique identifier for the prompt.
    /// This member is required.
    public var promptId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        promptId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.promptId = promptId
    }
}

public struct GetPromptFileOutput {
    /// The Amazon Web Services Region where this resource was last modified.
    public var lastModifiedRegion: Swift.String?
    /// The timestamp when this resource was last modified.
    public var lastModifiedTime: Foundation.Date?
    /// A generated URL to the prompt that can be given to an unauthorized user so they can access the prompt in S3.
    public var promptPresignedUrl: Swift.String?

    public init(
        lastModifiedRegion: Swift.String? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        promptPresignedUrl: Swift.String? = nil
    )
    {
        self.lastModifiedRegion = lastModifiedRegion
        self.lastModifiedTime = lastModifiedTime
        self.promptPresignedUrl = promptPresignedUrl
    }
}

public struct GetTaskTemplateInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The system generated version of a task template that is associated with a task, when the task is created.
    public var snapshotVersion: Swift.String?
    /// A unique identifier for the task template.
    /// This member is required.
    public var taskTemplateId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        snapshotVersion: Swift.String? = nil,
        taskTemplateId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.snapshotVersion = snapshotVersion
        self.taskTemplateId = taskTemplateId
    }
}

public struct GetTaskTemplateOutput {
    /// The Amazon Resource Name (ARN).
    /// This member is required.
    public var arn: Swift.String?
    /// Constraints that are applicable to the fields listed.
    public var constraints: ConnectClientTypes.TaskTemplateConstraints?
    /// The identifier of the flow that runs by default when a task is created by referencing this template.
    public var contactFlowId: Swift.String?
    /// The timestamp when the task template was created.
    public var createdTime: Foundation.Date?
    /// The default values for fields when a task is created by referencing this template.
    public var defaults: ConnectClientTypes.TaskTemplateDefaults?
    /// The description of the task template.
    public var description: Swift.String?
    /// Fields that are part of the template.
    public var fields: [ConnectClientTypes.TaskTemplateField]?
    /// A unique identifier for the task template.
    /// This member is required.
    public var id: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    public var instanceId: Swift.String?
    /// The timestamp when the task template was last modified.
    public var lastModifiedTime: Foundation.Date?
    /// The name of the task template.
    /// This member is required.
    public var name: Swift.String?
    /// Marks a template as ACTIVE or INACTIVE for a task to refer to it. Tasks can only be created from ACTIVE templates. If a template is marked as INACTIVE, then a task that refers to this template cannot be created.
    public var status: ConnectClientTypes.TaskTemplateStatus?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        constraints: ConnectClientTypes.TaskTemplateConstraints? = nil,
        contactFlowId: Swift.String? = nil,
        createdTime: Foundation.Date? = nil,
        defaults: ConnectClientTypes.TaskTemplateDefaults? = nil,
        description: Swift.String? = nil,
        fields: [ConnectClientTypes.TaskTemplateField]? = nil,
        id: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        name: Swift.String? = nil,
        status: ConnectClientTypes.TaskTemplateStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.constraints = constraints
        self.contactFlowId = contactFlowId
        self.createdTime = createdTime
        self.defaults = defaults
        self.description = description
        self.fields = fields
        self.id = id
        self.instanceId = instanceId
        self.lastModifiedTime = lastModifiedTime
        self.name = name
        self.status = status
        self.tags = tags
    }
}

public struct GetTrafficDistributionInput {
    /// The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension ConnectClientTypes {
    /// The distribution of sign in traffic between the instance and its replica(s).
    public struct SignInDistribution {
        /// Whether sign in distribution is enabled.
        /// This member is required.
        public var enabled: Swift.Bool
        /// The Amazon Web Services Region of the sign in distribution.
        /// This member is required.
        public var region: Swift.String?

        public init(
            enabled: Swift.Bool = false,
            region: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.region = region
        }
    }

}

extension ConnectClientTypes {
    /// The distribution that determines which Amazon Web Services Regions should be used to sign in agents in to both the instance and its replica(s).
    public struct SignInConfig {
        /// Information about traffic distributions.
        /// This member is required.
        public var distributions: [ConnectClientTypes.SignInDistribution]?

        public init(
            distributions: [ConnectClientTypes.SignInDistribution]? = nil
        )
        {
            self.distributions = distributions
        }
    }

}

extension ConnectClientTypes {
    /// The distribution of traffic between the instance and its replicas.
    public struct TelephonyConfig {
        /// Information about traffic distributions.
        /// This member is required.
        public var distributions: [ConnectClientTypes.Distribution]?

        public init(
            distributions: [ConnectClientTypes.Distribution]? = nil
        )
        {
            self.distributions = distributions
        }
    }

}

public struct GetTrafficDistributionOutput {
    /// The distribution of agents between the instance and its replica(s).
    public var agentConfig: ConnectClientTypes.AgentConfig?
    /// The Amazon Resource Name (ARN) of the traffic distribution group.
    public var arn: Swift.String?
    /// The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.
    public var id: Swift.String?
    /// The distribution that determines which Amazon Web Services Regions should be used to sign in agents in to both the instance and its replica(s).
    public var signInConfig: ConnectClientTypes.SignInConfig?
    /// The distribution of traffic between the instance and its replicas.
    public var telephonyConfig: ConnectClientTypes.TelephonyConfig?

    public init(
        agentConfig: ConnectClientTypes.AgentConfig? = nil,
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        signInConfig: ConnectClientTypes.SignInConfig? = nil,
        telephonyConfig: ConnectClientTypes.TelephonyConfig? = nil
    )
    {
        self.agentConfig = agentConfig
        self.arn = arn
        self.id = id
        self.signInConfig = signInConfig
        self.telephonyConfig = telephonyConfig
    }
}

public struct ImportPhoneNumberInput {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The description of the phone number.
    public var phoneNumberDescription: Swift.String?
    /// The claimed phone number ARN being imported from the external service, such as Amazon Pinpoint. If it is from Amazon Pinpoint, it looks like the ARN of the phone number to import from Amazon Pinpoint.
    /// This member is required.
    public var sourcePhoneNumberArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        phoneNumberDescription: Swift.String? = nil,
        sourcePhoneNumberArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.instanceId = instanceId
        self.phoneNumberDescription = phoneNumberDescription
        self.sourcePhoneNumberArn = sourcePhoneNumberArn
        self.tags = tags
    }
}

public struct ImportPhoneNumberOutput {
    /// The Amazon Resource Name (ARN) of the phone number.
    public var phoneNumberArn: Swift.String?
    /// A unique identifier for the phone number.
    public var phoneNumberId: Swift.String?

    public init(
        phoneNumberArn: Swift.String? = nil,
        phoneNumberId: Swift.String? = nil
    )
    {
        self.phoneNumberArn = phoneNumberArn
        self.phoneNumberId = phoneNumberId
    }
}

public struct ListAgentStatusesInput {
    /// Available agent status types.
    public var agentStatusTypes: [ConnectClientTypes.AgentStatusType]?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        agentStatusTypes: [ConnectClientTypes.AgentStatusType]? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentStatusTypes = agentStatusTypes
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAgentStatusesOutput {
    /// A summary of agent statuses.
    public var agentStatusSummaryList: [ConnectClientTypes.AgentStatusSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        agentStatusSummaryList: [ConnectClientTypes.AgentStatusSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentStatusSummaryList = agentStatusSummaryList
        self.nextToken = nextToken
    }
}

public struct ListAnalyticsDataAssociationsInput {
    /// The identifier of the dataset to get the association status.
    public var dataSetId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        dataSetId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataSetId = dataSetId
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAnalyticsDataAssociationsOutput {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// An array of successful results: DataSetId, TargetAccountId, ResourceShareId, ResourceShareArn. This is a paginated API, so nextToken is given if there are more results to be returned.
    public var results: [ConnectClientTypes.AnalyticsDataAssociationResult]?

    public init(
        nextToken: Swift.String? = nil,
        results: [ConnectClientTypes.AnalyticsDataAssociationResult]? = nil
    )
    {
        self.nextToken = nextToken
        self.results = results
    }
}

public struct ListApprovedOriginsInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListApprovedOriginsOutput {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// The approved origins.
    public var origins: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        origins: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.origins = origins
    }
}

public struct ListAuthenticationProfilesInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ConnectClientTypes {
    /// This API is in preview release for Amazon Connect and is subject to change. To request access to this API, contact Amazon Web Services Support. A summary of a given authentication profile.
    public struct AuthenticationProfileSummary {
        /// The Amazon Resource Name (ARN) of the authentication profile summary.
        public var arn: Swift.String?
        /// The unique identifier of the authentication profile.
        public var id: Swift.String?
        /// Shows whether the authentication profile is the default authentication profile for the Amazon Connect instance. The default authentication profile applies to all agents in an Amazon Connect instance, unless overridden by another authentication profile.
        public var isDefault: Swift.Bool
        /// The Amazon Web Services Region when the authentication profile summary was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when the authentication profile summary was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// The name of the authentication profile summary.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            isDefault: Swift.Bool = false,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.isDefault = isDefault
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
        }
    }

}

public struct ListAuthenticationProfilesOutput {
    /// A summary of a given authentication profile.
    public var authenticationProfileSummaryList: [ConnectClientTypes.AuthenticationProfileSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        authenticationProfileSummaryList: [ConnectClientTypes.AuthenticationProfileSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.authenticationProfileSummaryList = authenticationProfileSummaryList
        self.nextToken = nextToken
    }
}

extension ConnectClientTypes {

    public enum LexVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case v1
        case v2
        case sdkUnknown(Swift.String)

        public static var allCases: [LexVersion] {
            return [
                .v1,
                .v2
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .v1: return "V1"
            case .v2: return "V2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListBotsInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The version of Amazon Lex or Amazon Lex V2.
    /// This member is required.
    public var lexVersion: ConnectClientTypes.LexVersion?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        lexVersion: ConnectClientTypes.LexVersion? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.lexVersion = lexVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ConnectClientTypes {
    /// Configuration information of an Amazon Lex or Amazon Lex V2 bot.
    public struct LexBotConfig {
        /// Configuration information of an Amazon Lex bot.
        public var lexBot: ConnectClientTypes.LexBot?
        /// Configuration information of an Amazon Lex V2 bot.
        public var lexV2Bot: ConnectClientTypes.LexV2Bot?

        public init(
            lexBot: ConnectClientTypes.LexBot? = nil,
            lexV2Bot: ConnectClientTypes.LexV2Bot? = nil
        )
        {
            self.lexBot = lexBot
            self.lexV2Bot = lexV2Bot
        }
    }

}

public struct ListBotsOutput {
    /// The names and Amazon Web Services Regions of the Amazon Lex or Amazon Lex V2 bots associated with the specified instance.
    public var lexBots: [ConnectClientTypes.LexBotConfig]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        lexBots: [ConnectClientTypes.LexBotConfig]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.lexBots = lexBots
        self.nextToken = nextToken
    }
}

public struct ListContactEvaluationsInput {
    /// The identifier of the contact in this instance of Amazon Connect.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. This is not expected to be set because the value returned in the previous response is always null.
    public var nextToken: Swift.String?

    public init(
        contactId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contactId = contactId
        self.instanceId = instanceId
        self.nextToken = nextToken
    }
}

extension ConnectClientTypes {
    /// Summary information about a contact evaluation.
    public struct EvaluationSummary {
        /// The timestamp for when the evaluation was created.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) for the contact evaluation resource.
        /// This member is required.
        public var evaluationArn: Swift.String?
        /// The unique identifier for the evaluation form.
        /// This member is required.
        public var evaluationFormId: Swift.String?
        /// A title of the evaluation form.
        /// This member is required.
        public var evaluationFormTitle: Swift.String?
        /// A unique identifier for the contact evaluation.
        /// This member is required.
        public var evaluationId: Swift.String?
        /// The Amazon Resource Name (ARN) of the user who last updated the evaluation.
        /// This member is required.
        public var evaluatorArn: Swift.String?
        /// The timestamp for when the evaluation was last updated.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// The overall score of the contact evaluation.
        public var score: ConnectClientTypes.EvaluationScore?
        /// The status of the contact evaluation.
        /// This member is required.
        public var status: ConnectClientTypes.EvaluationStatus?

        public init(
            createdTime: Foundation.Date? = nil,
            evaluationArn: Swift.String? = nil,
            evaluationFormId: Swift.String? = nil,
            evaluationFormTitle: Swift.String? = nil,
            evaluationId: Swift.String? = nil,
            evaluatorArn: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            score: ConnectClientTypes.EvaluationScore? = nil,
            status: ConnectClientTypes.EvaluationStatus? = nil
        )
        {
            self.createdTime = createdTime
            self.evaluationArn = evaluationArn
            self.evaluationFormId = evaluationFormId
            self.evaluationFormTitle = evaluationFormTitle
            self.evaluationId = evaluationId
            self.evaluatorArn = evaluatorArn
            self.lastModifiedTime = lastModifiedTime
            self.score = score
            self.status = status
        }
    }

}

public struct ListContactEvaluationsOutput {
    /// Provides details about a list of contact evaluations belonging to an instance.
    /// This member is required.
    public var evaluationSummaryList: [ConnectClientTypes.EvaluationSummary]?
    /// If there are additional results, this is the token for the next set of results. This is always returned as null in the response.
    public var nextToken: Swift.String?

    public init(
        evaluationSummaryList: [ConnectClientTypes.EvaluationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.evaluationSummaryList = evaluationSummaryList
        self.nextToken = nextToken
    }
}

public struct ListContactFlowModulesInput {
    /// The state of the flow module.
    public var contactFlowModuleState: ConnectClientTypes.ContactFlowModuleState?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        contactFlowModuleState: ConnectClientTypes.ContactFlowModuleState? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contactFlowModuleState = contactFlowModuleState
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ConnectClientTypes {
    /// Contains summary information about a flow.
    public struct ContactFlowModuleSummary {
        /// The Amazon Resource Name (ARN) of the flow module.
        public var arn: Swift.String?
        /// The identifier of the flow module.
        public var id: Swift.String?
        /// The name of the flow module.
        public var name: Swift.String?
        /// The type of flow module.
        public var state: ConnectClientTypes.ContactFlowModuleState?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            state: ConnectClientTypes.ContactFlowModuleState? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.name = name
            self.state = state
        }
    }

}

public struct ListContactFlowModulesOutput {
    /// Information about the flow module.
    public var contactFlowModulesSummaryList: [ConnectClientTypes.ContactFlowModuleSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        contactFlowModulesSummaryList: [ConnectClientTypes.ContactFlowModuleSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contactFlowModulesSummaryList = contactFlowModulesSummaryList
        self.nextToken = nextToken
    }
}

public struct ListContactFlowsInput {
    /// The type of flow.
    public var contactFlowTypes: [ConnectClientTypes.ContactFlowType]?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page. The default MaxResult size is 100.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        contactFlowTypes: [ConnectClientTypes.ContactFlowType]? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contactFlowTypes = contactFlowTypes
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ConnectClientTypes {
    /// Contains summary information about a flow. You can also create and update flows using the [Amazon Connect Flow language](https://docs.aws.amazon.com/connect/latest/APIReference/flow-language.html).
    public struct ContactFlowSummary {
        /// The Amazon Resource Name (ARN) of the flow.
        public var arn: Swift.String?
        /// The type of flow.
        public var contactFlowState: ConnectClientTypes.ContactFlowState?
        /// The status of the contact flow.
        public var contactFlowStatus: ConnectClientTypes.ContactFlowStatus?
        /// The type of flow.
        public var contactFlowType: ConnectClientTypes.ContactFlowType?
        /// The identifier of the flow.
        public var id: Swift.String?
        /// The name of the flow.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            contactFlowState: ConnectClientTypes.ContactFlowState? = nil,
            contactFlowStatus: ConnectClientTypes.ContactFlowStatus? = nil,
            contactFlowType: ConnectClientTypes.ContactFlowType? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.contactFlowState = contactFlowState
            self.contactFlowStatus = contactFlowStatus
            self.contactFlowType = contactFlowType
            self.id = id
            self.name = name
        }
    }

}

public struct ListContactFlowsOutput {
    /// Information about the flows.
    public var contactFlowSummaryList: [ConnectClientTypes.ContactFlowSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        contactFlowSummaryList: [ConnectClientTypes.ContactFlowSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contactFlowSummaryList = contactFlowSummaryList
        self.nextToken = nextToken
    }
}

public struct ListContactReferencesInput {
    /// The identifier of the initial contact.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. This is not expected to be set, because the value returned in the previous response is always null.
    public var nextToken: Swift.String?
    /// The type of reference.
    /// This member is required.
    public var referenceTypes: [ConnectClientTypes.ReferenceType]?

    public init(
        contactId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        referenceTypes: [ConnectClientTypes.ReferenceType]? = nil
    )
    {
        self.contactId = contactId
        self.instanceId = instanceId
        self.nextToken = nextToken
        self.referenceTypes = referenceTypes
    }
}

extension ConnectClientTypes {

    public enum ReferenceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case approved
        case rejected
        case sdkUnknown(Swift.String)

        public static var allCases: [ReferenceStatus] {
            return [
                .approved,
                .rejected
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .approved: return "APPROVED"
            case .rejected: return "REJECTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// Information about a reference when the referenceType is ATTACHMENT. Otherwise, null.
    public struct AttachmentReference {
        /// Identifier of the attachment reference.
        public var name: Swift.String?
        /// Status of the attachment reference type.
        public var status: ConnectClientTypes.ReferenceStatus?
        /// The location path of the attachment reference.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            status: ConnectClientTypes.ReferenceStatus? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.status = status
            self.value = value
        }
    }

}

extension ConnectClientTypes {
    /// Information about a reference when the referenceType is DATE. Otherwise, null.
    public struct DateReference {
        /// Identifier of the date reference.
        public var name: Swift.String?
        /// A valid date.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension ConnectClientTypes {
    /// Information about a reference when the referenceType is EMAIL. Otherwise, null.
    public struct EmailReference {
        /// Identifier of the email reference.
        public var name: Swift.String?
        /// A valid email address.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension ConnectClientTypes {
    /// Information about a reference when the referenceType is NUMBER. Otherwise, null.
    public struct NumberReference {
        /// Identifier of the number reference.
        public var name: Swift.String?
        /// A valid number.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension ConnectClientTypes {
    /// Information about a reference when the referenceType is STRING. Otherwise, null.
    public struct StringReference {
        /// Identifier of the string reference.
        public var name: Swift.String?
        /// A valid string.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension ConnectClientTypes {
    /// The URL reference.
    public struct UrlReference {
        /// Identifier of the URL reference.
        public var name: Swift.String?
        /// A valid URL.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension ConnectClientTypes {
    /// Contains summary information about a reference. ReferenceSummary contains only one non null field between the URL and attachment based on the reference type.
    public enum ReferenceSummary {
        /// Information about the reference when the referenceType is URL. Otherwise, null.
        case url(ConnectClientTypes.UrlReference)
        /// Information about the reference when the referenceType is ATTACHMENT. Otherwise, null.
        case attachment(ConnectClientTypes.AttachmentReference)
        /// Information about a reference when the referenceType is STRING. Otherwise, null.
        case string(ConnectClientTypes.StringReference)
        /// Information about a reference when the referenceType is NUMBER. Otherwise, null.
        case number(ConnectClientTypes.NumberReference)
        /// Information about a reference when the referenceType is DATE. Otherwise, null.
        case date(ConnectClientTypes.DateReference)
        /// Information about a reference when the referenceType is EMAIL. Otherwise, null.
        case email(ConnectClientTypes.EmailReference)
        case sdkUnknown(Swift.String)
    }

}

public struct ListContactReferencesOutput {
    /// If there are additional results, this is the token for the next set of results. This is always returned as null in the response.
    public var nextToken: Swift.String?
    /// Information about the flows.
    public var referenceSummaryList: [ConnectClientTypes.ReferenceSummary]?

    public init(
        nextToken: Swift.String? = nil,
        referenceSummaryList: [ConnectClientTypes.ReferenceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.referenceSummaryList = referenceSummaryList
    }
}

public struct ListDefaultVocabulariesInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see [What is Amazon Transcribe?](https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html)
    public var languageCode: ConnectClientTypes.VocabularyLanguageCode?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        languageCode: ConnectClientTypes.VocabularyLanguageCode? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.languageCode = languageCode
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ConnectClientTypes {
    /// Contains information about a default vocabulary.
    public struct DefaultVocabulary {
        /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
        /// This member is required.
        public var instanceId: Swift.String?
        /// The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see [What is Amazon Transcribe?](https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html)
        /// This member is required.
        public var languageCode: ConnectClientTypes.VocabularyLanguageCode?
        /// The identifier of the custom vocabulary.
        /// This member is required.
        public var vocabularyId: Swift.String?
        /// A unique name of the custom vocabulary.
        /// This member is required.
        public var vocabularyName: Swift.String?

        public init(
            instanceId: Swift.String? = nil,
            languageCode: ConnectClientTypes.VocabularyLanguageCode? = nil,
            vocabularyId: Swift.String? = nil,
            vocabularyName: Swift.String? = nil
        )
        {
            self.instanceId = instanceId
            self.languageCode = languageCode
            self.vocabularyId = vocabularyId
            self.vocabularyName = vocabularyName
        }
    }

}

public struct ListDefaultVocabulariesOutput {
    /// A list of default vocabularies.
    /// This member is required.
    public var defaultVocabularyList: [ConnectClientTypes.DefaultVocabulary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        defaultVocabularyList: [ConnectClientTypes.DefaultVocabulary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.defaultVocabularyList = defaultVocabularyList
        self.nextToken = nextToken
    }
}

public struct ListEvaluationFormsInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ConnectClientTypes {
    /// Summary information about an evaluation form.
    public struct EvaluationFormSummary {
        /// The version of the active evaluation form version.
        public var activeVersion: Swift.Int?
        /// The Amazon Resource Name (ARN) of the user who created the evaluation form.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The timestamp for when the evaluation form was created.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) for the evaluation form resource.
        /// This member is required.
        public var evaluationFormArn: Swift.String?
        /// The unique identifier for the evaluation form.
        /// This member is required.
        public var evaluationFormId: Swift.String?
        /// The Amazon Resource Name (ARN) of the user who last activated the evaluation form.
        public var lastActivatedBy: Swift.String?
        /// The timestamp for when the evaluation form was last activated.
        public var lastActivatedTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the user who last updated the evaluation form.
        /// This member is required.
        public var lastModifiedBy: Swift.String?
        /// The timestamp for when the evaluation form was last updated.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// The version number of the latest evaluation form version.
        /// This member is required.
        public var latestVersion: Swift.Int
        /// A title of the evaluation form.
        /// This member is required.
        public var title: Swift.String?

        public init(
            activeVersion: Swift.Int? = 0,
            createdBy: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            evaluationFormArn: Swift.String? = nil,
            evaluationFormId: Swift.String? = nil,
            lastActivatedBy: Swift.String? = nil,
            lastActivatedTime: Foundation.Date? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            latestVersion: Swift.Int = 0,
            title: Swift.String? = nil
        )
        {
            self.activeVersion = activeVersion
            self.createdBy = createdBy
            self.createdTime = createdTime
            self.evaluationFormArn = evaluationFormArn
            self.evaluationFormId = evaluationFormId
            self.lastActivatedBy = lastActivatedBy
            self.lastActivatedTime = lastActivatedTime
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.latestVersion = latestVersion
            self.title = title
        }
    }

}

public struct ListEvaluationFormsOutput {
    /// Provides details about a list of evaluation forms belonging to an instance.
    /// This member is required.
    public var evaluationFormSummaryList: [ConnectClientTypes.EvaluationFormSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        evaluationFormSummaryList: [ConnectClientTypes.EvaluationFormSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.evaluationFormSummaryList = evaluationFormSummaryList
        self.nextToken = nextToken
    }
}

public struct ListEvaluationFormVersionsInput {
    /// The unique identifier for the evaluation form.
    /// This member is required.
    public var evaluationFormId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        evaluationFormId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.evaluationFormId = evaluationFormId
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ConnectClientTypes {
    /// Summary information about an evaluation form.
    public struct EvaluationFormVersionSummary {
        /// The Amazon Resource Name (ARN) of the user who created the evaluation form.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The timestamp for when the evaluation form was created.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) for the evaluation form resource.
        /// This member is required.
        public var evaluationFormArn: Swift.String?
        /// The unique identifier for the evaluation form.
        /// This member is required.
        public var evaluationFormId: Swift.String?
        /// A version of the evaluation form.
        /// This member is required.
        public var evaluationFormVersion: Swift.Int
        /// The Amazon Resource Name (ARN) of the user who last updated the evaluation form.
        /// This member is required.
        public var lastModifiedBy: Swift.String?
        /// The timestamp for when the evaluation form was last updated.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// The flag indicating whether the evaluation form is locked for changes.
        /// This member is required.
        public var locked: Swift.Bool
        /// The status of the evaluation form.
        /// This member is required.
        public var status: ConnectClientTypes.EvaluationFormVersionStatus?

        public init(
            createdBy: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            evaluationFormArn: Swift.String? = nil,
            evaluationFormId: Swift.String? = nil,
            evaluationFormVersion: Swift.Int = 0,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            locked: Swift.Bool = false,
            status: ConnectClientTypes.EvaluationFormVersionStatus? = nil
        )
        {
            self.createdBy = createdBy
            self.createdTime = createdTime
            self.evaluationFormArn = evaluationFormArn
            self.evaluationFormId = evaluationFormId
            self.evaluationFormVersion = evaluationFormVersion
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.locked = locked
            self.status = status
        }
    }

}

public struct ListEvaluationFormVersionsOutput {
    /// Provides details about a list of evaluation forms belonging to an instance.
    /// This member is required.
    public var evaluationFormVersionSummaryList: [ConnectClientTypes.EvaluationFormVersionSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        evaluationFormVersionSummaryList: [ConnectClientTypes.EvaluationFormVersionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.evaluationFormVersionSummaryList = evaluationFormVersionSummaryList
        self.nextToken = nextToken
    }
}

public struct ListFlowAssociationsInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A valid resource type.
    public var resourceType: ConnectClientTypes.ListFlowAssociationResourceType?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceType: ConnectClientTypes.ListFlowAssociationResourceType? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceType = resourceType
    }
}

public struct ListFlowAssociationsOutput {
    /// Summary of flow associations.
    public var flowAssociationSummaryList: [ConnectClientTypes.FlowAssociationSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        flowAssociationSummaryList: [ConnectClientTypes.FlowAssociationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.flowAssociationSummaryList = flowAssociationSummaryList
        self.nextToken = nextToken
    }
}

public struct ListHoursOfOperationsInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page. The default MaxResult size is 100.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ConnectClientTypes {
    /// Contains summary information about hours of operation for a contact center.
    public struct HoursOfOperationSummary {
        /// The Amazon Resource Name (ARN) of the hours of operation.
        public var arn: Swift.String?
        /// The identifier of the hours of operation.
        public var id: Swift.String?
        /// The Amazon Web Services Region where this resource was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when this resource was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// The name of the hours of operation.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
        }
    }

}

public struct ListHoursOfOperationsOutput {
    /// Information about the hours of operation.
    public var hoursOfOperationSummaryList: [ConnectClientTypes.HoursOfOperationSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        hoursOfOperationSummaryList: [ConnectClientTypes.HoursOfOperationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.hoursOfOperationSummaryList = hoursOfOperationSummaryList
        self.nextToken = nextToken
    }
}

public struct ListInstanceAttributesInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListInstanceAttributesOutput {
    /// The attribute types.
    public var attributes: [ConnectClientTypes.Attribute]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        attributes: [ConnectClientTypes.Attribute]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.nextToken = nextToken
    }
}

public struct ListInstancesInput {
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ConnectClientTypes {
    /// Information about the instance.
    public struct InstanceSummary {
        /// The Amazon Resource Name (ARN) of the instance.
        public var arn: Swift.String?
        /// When the instance was created.
        public var createdTime: Foundation.Date?
        /// The identifier of the instance.
        public var id: Swift.String?
        /// The identity management type of the instance.
        public var identityManagementType: ConnectClientTypes.DirectoryType?
        /// Whether inbound calls are enabled.
        public var inboundCallsEnabled: Swift.Bool?
        /// This URL allows contact center users to access the Amazon Connect admin website.
        public var instanceAccessUrl: Swift.String?
        /// The alias of the instance.
        public var instanceAlias: Swift.String?
        /// The state of the instance.
        public var instanceStatus: ConnectClientTypes.InstanceStatus?
        /// Whether outbound calls are enabled.
        public var outboundCallsEnabled: Swift.Bool?
        /// The service role of the instance.
        public var serviceRole: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            id: Swift.String? = nil,
            identityManagementType: ConnectClientTypes.DirectoryType? = nil,
            inboundCallsEnabled: Swift.Bool? = nil,
            instanceAccessUrl: Swift.String? = nil,
            instanceAlias: Swift.String? = nil,
            instanceStatus: ConnectClientTypes.InstanceStatus? = nil,
            outboundCallsEnabled: Swift.Bool? = nil,
            serviceRole: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.id = id
            self.identityManagementType = identityManagementType
            self.inboundCallsEnabled = inboundCallsEnabled
            self.instanceAccessUrl = instanceAccessUrl
            self.instanceAlias = instanceAlias
            self.instanceStatus = instanceStatus
            self.outboundCallsEnabled = outboundCallsEnabled
            self.serviceRole = serviceRole
        }
    }

}

extension ConnectClientTypes.InstanceSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstanceSummary(arn: \(Swift.String(describing: arn)), createdTime: \(Swift.String(describing: createdTime)), id: \(Swift.String(describing: id)), identityManagementType: \(Swift.String(describing: identityManagementType)), inboundCallsEnabled: \(Swift.String(describing: inboundCallsEnabled)), instanceAccessUrl: \(Swift.String(describing: instanceAccessUrl)), instanceStatus: \(Swift.String(describing: instanceStatus)), outboundCallsEnabled: \(Swift.String(describing: outboundCallsEnabled)), serviceRole: \(Swift.String(describing: serviceRole)), instanceAlias: \"CONTENT_REDACTED\")"}
}

public struct ListInstancesOutput {
    /// Information about the instances.
    public var instanceSummaryList: [ConnectClientTypes.InstanceSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceSummaryList: [ConnectClientTypes.InstanceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceSummaryList = instanceSummaryList
        self.nextToken = nextToken
    }
}

public struct ListInstanceStorageConfigsInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A valid resource type.
    /// This member is required.
    public var resourceType: ConnectClientTypes.InstanceStorageResourceType?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceType: ConnectClientTypes.InstanceStorageResourceType? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceType = resourceType
    }
}

public struct ListInstanceStorageConfigsOutput {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// A valid storage type.
    public var storageConfigs: [ConnectClientTypes.InstanceStorageConfig]?

    public init(
        nextToken: Swift.String? = nil,
        storageConfigs: [ConnectClientTypes.InstanceStorageConfig]? = nil
    )
    {
        self.nextToken = nextToken
        self.storageConfigs = storageConfigs
    }
}

public struct ListIntegrationAssociationsInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The Amazon Resource Name (ARN) of the integration.
    public var integrationArn: Swift.String?
    /// The integration type.
    public var integrationType: ConnectClientTypes.IntegrationType?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        integrationArn: Swift.String? = nil,
        integrationType: ConnectClientTypes.IntegrationType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.integrationArn = integrationArn
        self.integrationType = integrationType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ConnectClientTypes {
    /// Contains summary information about the associated AppIntegrations.
    public struct IntegrationAssociationSummary {
        /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
        public var instanceId: Swift.String?
        /// The Amazon Resource Name (ARN) for the AppIntegration.
        public var integrationArn: Swift.String?
        /// The Amazon Resource Name (ARN) for the AppIntegration association.
        public var integrationAssociationArn: Swift.String?
        /// The identifier for the AppIntegration association.
        public var integrationAssociationId: Swift.String?
        /// The integration type.
        public var integrationType: ConnectClientTypes.IntegrationType?
        /// The user-provided, friendly name for the external application.
        public var sourceApplicationName: Swift.String?
        /// The URL for the external application.
        public var sourceApplicationUrl: Swift.String?
        /// The name of the source.
        public var sourceType: ConnectClientTypes.SourceType?

        public init(
            instanceId: Swift.String? = nil,
            integrationArn: Swift.String? = nil,
            integrationAssociationArn: Swift.String? = nil,
            integrationAssociationId: Swift.String? = nil,
            integrationType: ConnectClientTypes.IntegrationType? = nil,
            sourceApplicationName: Swift.String? = nil,
            sourceApplicationUrl: Swift.String? = nil,
            sourceType: ConnectClientTypes.SourceType? = nil
        )
        {
            self.instanceId = instanceId
            self.integrationArn = integrationArn
            self.integrationAssociationArn = integrationAssociationArn
            self.integrationAssociationId = integrationAssociationId
            self.integrationType = integrationType
            self.sourceApplicationName = sourceApplicationName
            self.sourceApplicationUrl = sourceApplicationUrl
            self.sourceType = sourceType
        }
    }

}

public struct ListIntegrationAssociationsOutput {
    /// The associations.
    public var integrationAssociationSummaryList: [ConnectClientTypes.IntegrationAssociationSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        integrationAssociationSummaryList: [ConnectClientTypes.IntegrationAssociationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.integrationAssociationSummaryList = integrationAssociationSummaryList
        self.nextToken = nextToken
    }
}

public struct ListLambdaFunctionsInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListLambdaFunctionsOutput {
    /// The Lambdafunction ARNs associated with the specified instance.
    public var lambdaFunctions: [Swift.String]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        lambdaFunctions: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.lambdaFunctions = lambdaFunctions
        self.nextToken = nextToken
    }
}

public struct ListLexBotsInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page. If no value is specified, the default is 10.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListLexBotsOutput {
    /// The names and Amazon Web Services Regions of the Amazon Lex bots associated with the specified instance.
    public var lexBots: [ConnectClientTypes.LexBot]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        lexBots: [ConnectClientTypes.LexBot]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.lexBots = lexBots
        self.nextToken = nextToken
    }
}

public struct ListPhoneNumbersInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page. The default MaxResult size is 100.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ISO country code.
    public var phoneNumberCountryCodes: [ConnectClientTypes.PhoneNumberCountryCode]?
    /// The type of phone number. We recommend using [ListPhoneNumbersV2](https://docs.aws.amazon.com/connect/latest/APIReference/API_ListPhoneNumbersV2.html) to return phone number types. While ListPhoneNumbers returns number types UIFN, SHARED, THIRD_PARTY_TF, and THIRD_PARTY_DID, it incorrectly lists them as TOLL_FREE or DID.
    public var phoneNumberTypes: [ConnectClientTypes.PhoneNumberType]?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        phoneNumberCountryCodes: [ConnectClientTypes.PhoneNumberCountryCode]? = nil,
        phoneNumberTypes: [ConnectClientTypes.PhoneNumberType]? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.phoneNumberCountryCodes = phoneNumberCountryCodes
        self.phoneNumberTypes = phoneNumberTypes
    }
}

extension ConnectClientTypes {
    /// Contains summary information about a phone number for a contact center.
    public struct PhoneNumberSummary {
        /// The Amazon Resource Name (ARN) of the phone number.
        public var arn: Swift.String?
        /// The identifier of the phone number.
        public var id: Swift.String?
        /// The phone number.
        public var phoneNumber: Swift.String?
        /// The ISO country code.
        public var phoneNumberCountryCode: ConnectClientTypes.PhoneNumberCountryCode?
        /// The type of phone number.
        public var phoneNumberType: ConnectClientTypes.PhoneNumberType?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            phoneNumber: Swift.String? = nil,
            phoneNumberCountryCode: ConnectClientTypes.PhoneNumberCountryCode? = nil,
            phoneNumberType: ConnectClientTypes.PhoneNumberType? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.phoneNumber = phoneNumber
            self.phoneNumberCountryCode = phoneNumberCountryCode
            self.phoneNumberType = phoneNumberType
        }
    }

}

public struct ListPhoneNumbersOutput {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the phone numbers.
    public var phoneNumberSummaryList: [ConnectClientTypes.PhoneNumberSummary]?

    public init(
        nextToken: Swift.String? = nil,
        phoneNumberSummaryList: [ConnectClientTypes.PhoneNumberSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.phoneNumberSummaryList = phoneNumberSummaryList
    }
}

public struct ListPhoneNumbersV2Input {
    /// The identifier of the Amazon Connect instance that phone numbers are claimed to. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance. If both TargetArn and InstanceId are not provided, this API lists numbers claimed to all the Amazon Connect instances belonging to your account in the same AWS Region as the request.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ISO country code.
    public var phoneNumberCountryCodes: [ConnectClientTypes.PhoneNumberCountryCode]?
    /// The prefix of the phone number. If provided, it must contain + as part of the country code.
    public var phoneNumberPrefix: Swift.String?
    /// The type of phone number.
    public var phoneNumberTypes: [ConnectClientTypes.PhoneNumberType]?
    /// The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone number inbound traffic is routed through. If both TargetArn and InstanceId input are not provided, this API lists numbers claimed to all the Amazon Connect instances belonging to your account in the same Amazon Web Services Region as the request.
    public var targetArn: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        phoneNumberCountryCodes: [ConnectClientTypes.PhoneNumberCountryCode]? = nil,
        phoneNumberPrefix: Swift.String? = nil,
        phoneNumberTypes: [ConnectClientTypes.PhoneNumberType]? = nil,
        targetArn: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.phoneNumberCountryCodes = phoneNumberCountryCodes
        self.phoneNumberPrefix = phoneNumberPrefix
        self.phoneNumberTypes = phoneNumberTypes
        self.targetArn = targetArn
    }
}

extension ConnectClientTypes {
    /// Information about phone numbers that have been claimed to your Amazon Connect instance or traffic distribution group.
    public struct ListPhoneNumbersSummary {
        /// The identifier of the Amazon Connect instance that phone numbers are claimed to. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
        public var instanceId: Swift.String?
        /// The phone number. Phone numbers are formatted [+] [country code] [subscriber number including area code].
        public var phoneNumber: Swift.String?
        /// The Amazon Resource Name (ARN) of the phone number.
        public var phoneNumberArn: Swift.String?
        /// The ISO country code.
        public var phoneNumberCountryCode: ConnectClientTypes.PhoneNumberCountryCode?
        /// The description of the phone number.
        public var phoneNumberDescription: Swift.String?
        /// A unique identifier for the phone number.
        public var phoneNumberId: Swift.String?
        /// The type of phone number.
        public var phoneNumberType: ConnectClientTypes.PhoneNumberType?
        /// The claimed phone number ARN that was previously imported from the external service, such as Amazon Pinpoint. If it is from Amazon Pinpoint, it looks like the ARN of the phone number that was imported from Amazon Pinpoint.
        public var sourcePhoneNumberArn: Swift.String?
        /// The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone number inbound traffic is routed through.
        public var targetArn: Swift.String?

        public init(
            instanceId: Swift.String? = nil,
            phoneNumber: Swift.String? = nil,
            phoneNumberArn: Swift.String? = nil,
            phoneNumberCountryCode: ConnectClientTypes.PhoneNumberCountryCode? = nil,
            phoneNumberDescription: Swift.String? = nil,
            phoneNumberId: Swift.String? = nil,
            phoneNumberType: ConnectClientTypes.PhoneNumberType? = nil,
            sourcePhoneNumberArn: Swift.String? = nil,
            targetArn: Swift.String? = nil
        )
        {
            self.instanceId = instanceId
            self.phoneNumber = phoneNumber
            self.phoneNumberArn = phoneNumberArn
            self.phoneNumberCountryCode = phoneNumberCountryCode
            self.phoneNumberDescription = phoneNumberDescription
            self.phoneNumberId = phoneNumberId
            self.phoneNumberType = phoneNumberType
            self.sourcePhoneNumberArn = sourcePhoneNumberArn
            self.targetArn = targetArn
        }
    }

}

public struct ListPhoneNumbersV2Output {
    /// Information about phone numbers that have been claimed to your Amazon Connect instances or traffic distribution groups.
    public var listPhoneNumbersSummaryList: [ConnectClientTypes.ListPhoneNumbersSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        listPhoneNumbersSummaryList: [ConnectClientTypes.ListPhoneNumbersSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.listPhoneNumbersSummaryList = listPhoneNumbersSummaryList
        self.nextToken = nextToken
    }
}

public struct ListPredefinedAttributesInput {
    /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ConnectClientTypes {
    /// Summary of a predefined attribute.
    public struct PredefinedAttributeSummary {
        /// Last modified region.
        public var lastModifiedRegion: Swift.String?
        /// Last modified time.
        public var lastModifiedTime: Foundation.Date?
        /// The name of the predefined attribute.
        public var name: Swift.String?

        public init(
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
        }
    }

}

public struct ListPredefinedAttributesOutput {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Summary of the predefined attributes.
    public var predefinedAttributeSummaryList: [ConnectClientTypes.PredefinedAttributeSummary]?

    public init(
        nextToken: Swift.String? = nil,
        predefinedAttributeSummaryList: [ConnectClientTypes.PredefinedAttributeSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.predefinedAttributeSummaryList = predefinedAttributeSummaryList
    }
}

public struct ListPromptsInput {
    /// The identifier of the Amazon Connect instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page. The default MaxResult size is 100.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ConnectClientTypes {
    /// Contains information about the prompt.
    public struct PromptSummary {
        /// The Amazon Resource Name (ARN) of the prompt.
        public var arn: Swift.String?
        /// The identifier of the prompt.
        public var id: Swift.String?
        /// The Amazon Web Services Region where this resource was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when this resource was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// The name of the prompt.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
        }
    }

}

public struct ListPromptsOutput {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the prompts.
    public var promptSummaryList: [ConnectClientTypes.PromptSummary]?

    public init(
        nextToken: Swift.String? = nil,
        promptSummaryList: [ConnectClientTypes.PromptSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.promptSummaryList = promptSummaryList
    }
}

public struct ListQueueQuickConnectsInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page. The default MaxResult size is 100.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The identifier for the queue.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queueId = queueId
    }
}

extension ConnectClientTypes {
    /// Contains summary information about a quick connect.
    public struct QuickConnectSummary {
        /// The Amazon Resource Name (ARN) of the quick connect.
        public var arn: Swift.String?
        /// The identifier for the quick connect.
        public var id: Swift.String?
        /// The Amazon Web Services Region where this resource was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when this resource was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// The name of the quick connect.
        public var name: Swift.String?
        /// The type of quick connect. In the Amazon Connect admin website, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE).
        public var quickConnectType: ConnectClientTypes.QuickConnectType?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            quickConnectType: ConnectClientTypes.QuickConnectType? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.quickConnectType = quickConnectType
        }
    }

}

public struct ListQueueQuickConnectsOutput {
    /// The Amazon Web Services Region where this resource was last modified.
    public var lastModifiedRegion: Swift.String?
    /// The timestamp when this resource was last modified.
    public var lastModifiedTime: Foundation.Date?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the quick connects.
    public var quickConnectSummaryList: [ConnectClientTypes.QuickConnectSummary]?

    public init(
        lastModifiedRegion: Swift.String? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        nextToken: Swift.String? = nil,
        quickConnectSummaryList: [ConnectClientTypes.QuickConnectSummary]? = nil
    )
    {
        self.lastModifiedRegion = lastModifiedRegion
        self.lastModifiedTime = lastModifiedTime
        self.nextToken = nextToken
        self.quickConnectSummaryList = quickConnectSummaryList
    }
}

extension ConnectClientTypes {

    public enum QueueType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case agent
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [QueueType] {
            return [
                .agent,
                .standard
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .agent: return "AGENT"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListQueuesInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page. The default MaxResult size is 100.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The type of queue.
    public var queueTypes: [ConnectClientTypes.QueueType]?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queueTypes: [ConnectClientTypes.QueueType]? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queueTypes = queueTypes
    }
}

extension ConnectClientTypes {
    /// Contains summary information about a queue.
    public struct QueueSummary {
        /// The Amazon Resource Name (ARN) of the queue.
        public var arn: Swift.String?
        /// The identifier of the queue.
        public var id: Swift.String?
        /// The Amazon Web Services Region where this resource was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when this resource was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// The name of the queue.
        public var name: Swift.String?
        /// The type of queue.
        public var queueType: ConnectClientTypes.QueueType?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            queueType: ConnectClientTypes.QueueType? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.queueType = queueType
        }
    }

}

public struct ListQueuesOutput {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the queues.
    public var queueSummaryList: [ConnectClientTypes.QueueSummary]?

    public init(
        nextToken: Swift.String? = nil,
        queueSummaryList: [ConnectClientTypes.QueueSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.queueSummaryList = queueSummaryList
    }
}

public struct ListQuickConnectsInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page. The default MaxResult size is 100.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The type of quick connect. In the Amazon Connect admin website, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE).
    public var quickConnectTypes: [ConnectClientTypes.QuickConnectType]?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        quickConnectTypes: [ConnectClientTypes.QuickConnectType]? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.quickConnectTypes = quickConnectTypes
    }
}

public struct ListQuickConnectsOutput {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the quick connects.
    public var quickConnectSummaryList: [ConnectClientTypes.QuickConnectSummary]?

    public init(
        nextToken: Swift.String? = nil,
        quickConnectSummaryList: [ConnectClientTypes.QuickConnectSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.quickConnectSummaryList = quickConnectSummaryList
    }
}

/// Thrown for analyzed content when requested OutputType was not enabled for a given contact. For example, if an OutputType.Raw was requested for a contact that had `RedactedOnly` Redaction policy set in Contact flow.
public struct OutputTypeNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OutputTypeNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ConnectClientTypes {

    public enum RealTimeContactAnalysisOutputType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case raw
        case redacted
        case sdkUnknown(Swift.String)

        public static var allCases: [RealTimeContactAnalysisOutputType] {
            return [
                .raw,
                .redacted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .raw: return "Raw"
            case .redacted: return "Redacted"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {

    public enum RealTimeContactAnalysisSegmentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case attachments
        case categories
        case event
        case issues
        case postcontactsummary
        case transcript
        case sdkUnknown(Swift.String)

        public static var allCases: [RealTimeContactAnalysisSegmentType] {
            return [
                .attachments,
                .categories,
                .event,
                .issues,
                .postcontactsummary,
                .transcript
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .attachments: return "Attachments"
            case .categories: return "Categories"
            case .event: return "Event"
            case .issues: return "Issues"
            case .postcontactsummary: return "PostContactSummary"
            case .transcript: return "Transcript"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListRealtimeContactAnalysisSegmentsV2Input {
    /// The identifier of the contact in this instance of Amazon Connect.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The Contact Lens output type to be returned.
    /// This member is required.
    public var outputType: ConnectClientTypes.RealTimeContactAnalysisOutputType?
    /// Enum with segment types . Each value corresponds to a segment type returned in the segments list of the API. Each segment type has its own structure. Different channels may have different sets of supported segment types.
    /// This member is required.
    public var segmentTypes: [ConnectClientTypes.RealTimeContactAnalysisSegmentType]?

    public init(
        contactId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        outputType: ConnectClientTypes.RealTimeContactAnalysisOutputType? = nil,
        segmentTypes: [ConnectClientTypes.RealTimeContactAnalysisSegmentType]? = nil
    )
    {
        self.contactId = contactId
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.outputType = outputType
        self.segmentTypes = segmentTypes
    }
}

extension ConnectClientTypes {

    public enum RealTimeContactAnalysisSupportedChannel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case chat
        case voice
        case sdkUnknown(Swift.String)

        public static var allCases: [RealTimeContactAnalysisSupportedChannel] {
            return [
                .chat,
                .voice
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .chat: return "CHAT"
            case .voice: return "VOICE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {

    public enum ArtifactStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case approved
        case inProgress
        case rejected
        case sdkUnknown(Swift.String)

        public static var allCases: [ArtifactStatus] {
            return [
                .approved,
                .inProgress,
                .rejected
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .approved: return "APPROVED"
            case .inProgress: return "IN_PROGRESS"
            case .rejected: return "REJECTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// Object that describes attached file.
    public struct RealTimeContactAnalysisAttachment {
        /// A unique identifier for the attachment.
        /// This member is required.
        public var attachmentId: Swift.String?
        /// A case-sensitive name of the attachment being uploaded. Can be redacted.
        /// This member is required.
        public var attachmentName: Swift.String?
        /// Describes the MIME file type of the attachment. For a list of supported file types, see [Feature specifications](https://docs.aws.amazon.com/connect/latest/adminguide/feature-limits.html) in the Amazon Connect Administrator Guide.
        public var contentType: Swift.String?
        /// Status of the attachment.
        public var status: ConnectClientTypes.ArtifactStatus?

        public init(
            attachmentId: Swift.String? = nil,
            attachmentName: Swift.String? = nil,
            contentType: Swift.String? = nil,
            status: ConnectClientTypes.ArtifactStatus? = nil
        )
        {
            self.attachmentId = attachmentId
            self.attachmentName = attachmentName
            self.contentType = contentType
            self.status = status
        }
    }

}

extension ConnectClientTypes {
    /// Object describing time with which the segment is associated. It can have different representations of time. Currently supported: absoluteTime
    public enum RealTimeContactAnalysisTimeData {
        /// Time represented in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
        case absolutetime(Foundation.Date)
        case sdkUnknown(Swift.String)
    }

}

extension ConnectClientTypes {
    /// Segment containing list of attachments.
    public struct RealTimeContactAnalysisSegmentAttachments {
        /// List of objects describing an individual attachment.
        /// This member is required.
        public var attachments: [ConnectClientTypes.RealTimeContactAnalysisAttachment]?
        /// The display name of the participant. Can be redacted.
        public var displayName: Swift.String?
        /// The identifier of the segment.
        /// This member is required.
        public var id: Swift.String?
        /// The identifier of the participant.
        /// This member is required.
        public var participantId: Swift.String?
        /// The role of the participant. For example, is it a customer, agent, or system.
        /// This member is required.
        public var participantRole: ConnectClientTypes.ParticipantRole?
        /// Field describing the time of the event. It can have different representations of time.
        /// This member is required.
        public var time: ConnectClientTypes.RealTimeContactAnalysisTimeData?

        public init(
            attachments: [ConnectClientTypes.RealTimeContactAnalysisAttachment]? = nil,
            displayName: Swift.String? = nil,
            id: Swift.String? = nil,
            participantId: Swift.String? = nil,
            participantRole: ConnectClientTypes.ParticipantRole? = nil,
            time: ConnectClientTypes.RealTimeContactAnalysisTimeData? = nil
        )
        {
            self.attachments = attachments
            self.displayName = displayName
            self.id = id
            self.participantId = participantId
            self.participantRole = participantRole
            self.time = time
        }
    }

}

extension ConnectClientTypes {
    /// Begin and end offsets for a part of text.
    public struct RealTimeContactAnalysisCharacterInterval {
        /// The beginning of the character interval.
        /// This member is required.
        public var beginOffsetChar: Swift.Int
        /// The end of the character interval.
        /// This member is required.
        public var endOffsetChar: Swift.Int

        public init(
            beginOffsetChar: Swift.Int = 0,
            endOffsetChar: Swift.Int = 0
        )
        {
            self.beginOffsetChar = beginOffsetChar
            self.endOffsetChar = endOffsetChar
        }
    }

}

extension ConnectClientTypes {
    /// Transcript representation containing Id and list of character intervals that are associated with analysis data. For example, this object within a RealTimeContactAnalysisPointOfInterest in Category.MatchedDetails would have character interval describing part of the text that matched category.
    public struct RealTimeContactAnalysisTranscriptItemWithCharacterOffsets {
        /// List of character intervals within transcript content/text.
        public var characterOffsets: ConnectClientTypes.RealTimeContactAnalysisCharacterInterval?
        /// Transcript identifier. Matches the identifier from one of the TranscriptSegments.
        /// This member is required.
        public var id: Swift.String?

        public init(
            characterOffsets: ConnectClientTypes.RealTimeContactAnalysisCharacterInterval? = nil,
            id: Swift.String? = nil
        )
        {
            self.characterOffsets = characterOffsets
            self.id = id
        }
    }

}

extension ConnectClientTypes {
    /// The section of the contact transcript segment that category rule was detected.
    public struct RealTimeContactAnalysisPointOfInterest {
        /// List of the transcript items (segments) that are associated with a given point of interest.
        public var transcriptItems: [ConnectClientTypes.RealTimeContactAnalysisTranscriptItemWithCharacterOffsets]?

        public init(
            transcriptItems: [ConnectClientTypes.RealTimeContactAnalysisTranscriptItemWithCharacterOffsets]? = nil
        )
        {
            self.transcriptItems = transcriptItems
        }
    }

}

extension ConnectClientTypes {
    /// Provides information about the category rule that was matched.
    public struct RealTimeContactAnalysisCategoryDetails {
        /// List of PointOfInterest - objects describing a single match of a rule.
        /// This member is required.
        public var pointsOfInterest: [ConnectClientTypes.RealTimeContactAnalysisPointOfInterest]?

        public init(
            pointsOfInterest: [ConnectClientTypes.RealTimeContactAnalysisPointOfInterest]? = nil
        )
        {
            self.pointsOfInterest = pointsOfInterest
        }
    }

}

extension ConnectClientTypes {
    /// The matched category rules.
    public struct RealTimeContactAnalysisSegmentCategories {
        /// Map between the name of the matched rule and RealTimeContactAnalysisCategoryDetails.
        /// This member is required.
        public var matchedDetails: [Swift.String: ConnectClientTypes.RealTimeContactAnalysisCategoryDetails]?

        public init(
            matchedDetails: [Swift.String: ConnectClientTypes.RealTimeContactAnalysisCategoryDetails]? = nil
        )
        {
            self.matchedDetails = matchedDetails
        }
    }

}

extension ConnectClientTypes {
    /// Segment type describing a contact event.
    public struct RealTimeContactAnalysisSegmentEvent {
        /// The display name of the participant. Can be redacted.
        public var displayName: Swift.String?
        /// Type of the event. For example, application/vnd.amazonaws.connect.event.participant.left.
        /// This member is required.
        public var eventType: Swift.String?
        /// The identifier of the contact event.
        /// This member is required.
        public var id: Swift.String?
        /// The identifier of the participant.
        public var participantId: Swift.String?
        /// The role of the participant. For example, is it a customer, agent, or system.
        public var participantRole: ConnectClientTypes.ParticipantRole?
        /// Field describing the time of the event. It can have different representations of time.
        /// This member is required.
        public var time: ConnectClientTypes.RealTimeContactAnalysisTimeData?

        public init(
            displayName: Swift.String? = nil,
            eventType: Swift.String? = nil,
            id: Swift.String? = nil,
            participantId: Swift.String? = nil,
            participantRole: ConnectClientTypes.ParticipantRole? = nil,
            time: ConnectClientTypes.RealTimeContactAnalysisTimeData? = nil
        )
        {
            self.displayName = displayName
            self.eventType = eventType
            self.id = id
            self.participantId = participantId
            self.participantRole = participantRole
            self.time = time
        }
    }

}

extension ConnectClientTypes {
    /// Transcript representation containing Id, Content and list of character intervals that are associated with analysis data. For example, this object within an issue detected would describe both content that contains identified issue and intervals where that content is taken from.
    public struct RealTimeContactAnalysisTranscriptItemWithContent {
        /// Begin and end offsets for a part of text.
        public var characterOffsets: ConnectClientTypes.RealTimeContactAnalysisCharacterInterval?
        /// Part of the transcript content that contains identified issue. Can be redacted
        public var content: Swift.String?
        /// Transcript identifier. Matches the identifier from one of the TranscriptSegments.
        /// This member is required.
        public var id: Swift.String?

        public init(
            characterOffsets: ConnectClientTypes.RealTimeContactAnalysisCharacterInterval? = nil,
            content: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.characterOffsets = characterOffsets
            self.content = content
            self.id = id
        }
    }

}

extension ConnectClientTypes {
    /// Potential issues that are detected based on an artificial intelligence analysis of each turn in the conversation.
    public struct RealTimeContactAnalysisIssueDetected {
        /// List of the transcript items (segments) that are associated with a given issue.
        /// This member is required.
        public var transcriptItems: [ConnectClientTypes.RealTimeContactAnalysisTranscriptItemWithContent]?

        public init(
            transcriptItems: [ConnectClientTypes.RealTimeContactAnalysisTranscriptItemWithContent]? = nil
        )
        {
            self.transcriptItems = transcriptItems
        }
    }

}

extension ConnectClientTypes {
    /// Segment type containing a list of detected issues.
    public struct RealTimeContactAnalysisSegmentIssues {
        /// List of the issues detected.
        /// This member is required.
        public var issuesDetected: [ConnectClientTypes.RealTimeContactAnalysisIssueDetected]?

        public init(
            issuesDetected: [ConnectClientTypes.RealTimeContactAnalysisIssueDetected]? = nil
        )
        {
            self.issuesDetected = issuesDetected
        }
    }

}

extension ConnectClientTypes {

    public enum RealTimeContactAnalysisPostContactSummaryFailureCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failedSafetyGuidelines
        case insufficientConversationContent
        case internalError
        case invalidAnalysisConfiguration
        case quotaExceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [RealTimeContactAnalysisPostContactSummaryFailureCode] {
            return [
                .failedSafetyGuidelines,
                .insufficientConversationContent,
                .internalError,
                .invalidAnalysisConfiguration,
                .quotaExceeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failedSafetyGuidelines: return "FAILED_SAFETY_GUIDELINES"
            case .insufficientConversationContent: return "INSUFFICIENT_CONVERSATION_CONTENT"
            case .internalError: return "INTERNAL_ERROR"
            case .invalidAnalysisConfiguration: return "INVALID_ANALYSIS_CONFIGURATION"
            case .quotaExceeded: return "QUOTA_EXCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {

    public enum RealTimeContactAnalysisPostContactSummaryStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [RealTimeContactAnalysisPostContactSummaryStatus] {
            return [
                .completed,
                .failed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// Information about the post-contact summary for a real-time contact segment.
    public struct RealTimeContactAnalysisSegmentPostContactSummary {
        /// The content of the summary.
        public var content: Swift.String?
        /// If the summary failed to be generated, one of the following failure codes occurs:
        ///
        /// * QUOTA_EXCEEDED: The number of concurrent analytics jobs reached your service quota.
        ///
        /// * INSUFFICIENT_CONVERSATION_CONTENT: The conversation needs to have at least one turn from both the participants in order to generate the summary.
        ///
        /// * FAILED_SAFETY_GUIDELINES: The generated summary cannot be provided because it failed to meet system safety guidelines.
        ///
        /// * INVALID_ANALYSIS_CONFIGURATION: This code occurs when, for example, you're using a [language](https://docs.aws.amazon.com/connect/latest/adminguide/supported-languages.html#supported-languages-contact-lens) that isn't supported by generative AI-powered post-contact summaries.
        ///
        /// * INTERNAL_ERROR: Internal system error.
        public var failureCode: ConnectClientTypes.RealTimeContactAnalysisPostContactSummaryFailureCode?
        /// Whether the summary was successfully COMPLETED or FAILED to be generated.
        /// This member is required.
        public var status: ConnectClientTypes.RealTimeContactAnalysisPostContactSummaryStatus?

        public init(
            content: Swift.String? = nil,
            failureCode: ConnectClientTypes.RealTimeContactAnalysisPostContactSummaryFailureCode? = nil,
            status: ConnectClientTypes.RealTimeContactAnalysisPostContactSummaryStatus? = nil
        )
        {
            self.content = content
            self.failureCode = failureCode
            self.status = status
        }
    }

}

extension ConnectClientTypes {
    /// Object describing redaction applied to the segment.
    public struct RealTimeContactAnalysisTranscriptItemRedaction {
        /// List of character intervals each describing a part of the text that was redacted. For OutputType.Raw, part of the original text that contains data that can be redacted. For  OutputType.Redacted, part of the string with redaction tag.
        public var characterOffsets: [ConnectClientTypes.RealTimeContactAnalysisCharacterInterval]?

        public init(
            characterOffsets: [ConnectClientTypes.RealTimeContactAnalysisCharacterInterval]? = nil
        )
        {
            self.characterOffsets = characterOffsets
        }
    }

}

extension ConnectClientTypes {

    public enum RealTimeContactAnalysisSentimentLabel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case negative
        case neutral
        case positive
        case sdkUnknown(Swift.String)

        public static var allCases: [RealTimeContactAnalysisSentimentLabel] {
            return [
                .negative,
                .neutral,
                .positive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .negative: return "NEGATIVE"
            case .neutral: return "NEUTRAL"
            case .positive: return "POSITIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// The analyzed transcript segment.
    public struct RealTimeContactAnalysisSegmentTranscript {
        /// The content of the transcript. Can be redacted.
        /// This member is required.
        public var content: Swift.String?
        /// The type of content of the item. For example, text/plain.
        public var contentType: Swift.String?
        /// The display name of the participant.
        public var displayName: Swift.String?
        /// The identifier of the transcript.
        /// This member is required.
        public var id: Swift.String?
        /// The identifier of the participant.
        /// This member is required.
        public var participantId: Swift.String?
        /// The role of the participant. For example, is it a customer, agent, or system.
        /// This member is required.
        public var participantRole: ConnectClientTypes.ParticipantRole?
        /// Object describing redaction that was applied to the transcript. If transcript has the field it means part of the transcript was redacted.
        public var redaction: ConnectClientTypes.RealTimeContactAnalysisTranscriptItemRedaction?
        /// The sentiment detected for this piece of transcript.
        public var sentiment: ConnectClientTypes.RealTimeContactAnalysisSentimentLabel?
        /// Field describing the time of the event. It can have different representations of time.
        /// This member is required.
        public var time: ConnectClientTypes.RealTimeContactAnalysisTimeData?

        public init(
            content: Swift.String? = nil,
            contentType: Swift.String? = nil,
            displayName: Swift.String? = nil,
            id: Swift.String? = nil,
            participantId: Swift.String? = nil,
            participantRole: ConnectClientTypes.ParticipantRole? = nil,
            redaction: ConnectClientTypes.RealTimeContactAnalysisTranscriptItemRedaction? = nil,
            sentiment: ConnectClientTypes.RealTimeContactAnalysisSentimentLabel? = nil,
            time: ConnectClientTypes.RealTimeContactAnalysisTimeData? = nil
        )
        {
            self.content = content
            self.contentType = contentType
            self.displayName = displayName
            self.id = id
            self.participantId = participantId
            self.participantRole = participantRole
            self.redaction = redaction
            self.sentiment = sentiment
            self.time = time
        }
    }

}

extension ConnectClientTypes {
    /// An analyzed segment for a real-time analysis session.
    public enum RealtimeContactAnalysisSegment {
        /// The analyzed transcript segment.
        case transcript(ConnectClientTypes.RealTimeContactAnalysisSegmentTranscript)
        /// The matched category rules.
        case categories(ConnectClientTypes.RealTimeContactAnalysisSegmentCategories)
        /// Segment type containing a list of detected issues.
        case issues(ConnectClientTypes.RealTimeContactAnalysisSegmentIssues)
        /// Segment type describing a contact event.
        case event(ConnectClientTypes.RealTimeContactAnalysisSegmentEvent)
        /// The analyzed attachments.
        case attachments(ConnectClientTypes.RealTimeContactAnalysisSegmentAttachments)
        /// Information about the post-contact summary.
        case postcontactsummary(ConnectClientTypes.RealTimeContactAnalysisSegmentPostContactSummary)
        case sdkUnknown(Swift.String)
    }

}

extension ConnectClientTypes {

    public enum RealTimeContactAnalysisStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [RealTimeContactAnalysisStatus] {
            return [
                .completed,
                .failed,
                .inProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListRealtimeContactAnalysisSegmentsV2Output {
    /// The channel of the contact. Voice will not be returned.
    /// This member is required.
    public var channel: ConnectClientTypes.RealTimeContactAnalysisSupportedChannel?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// An analyzed transcript or category.
    /// This member is required.
    public var segments: [ConnectClientTypes.RealtimeContactAnalysisSegment]?
    /// Status of real-time contact analysis.
    /// This member is required.
    public var status: ConnectClientTypes.RealTimeContactAnalysisStatus?

    public init(
        channel: ConnectClientTypes.RealTimeContactAnalysisSupportedChannel? = nil,
        nextToken: Swift.String? = nil,
        segments: [ConnectClientTypes.RealtimeContactAnalysisSegment]? = nil,
        status: ConnectClientTypes.RealTimeContactAnalysisStatus? = nil
    )
    {
        self.channel = channel
        self.nextToken = nextToken
        self.segments = segments
        self.status = status
    }
}

public struct ListRoutingProfileQueuesInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page. The default MaxResult size is 100.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The identifier of the routing profile.
    /// This member is required.
    public var routingProfileId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        routingProfileId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.routingProfileId = routingProfileId
    }
}

extension ConnectClientTypes {
    /// Contains summary information about a routing profile queue.
    public struct RoutingProfileQueueConfigSummary {
        /// The channels this queue supports.
        /// This member is required.
        public var channel: ConnectClientTypes.Channel?
        /// The delay, in seconds, that a contact should be in the queue before they are routed to an available agent. For more information, see [Queues: priority and delay](https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html) in the Amazon Connect Administrator Guide.
        /// This member is required.
        public var delay: Swift.Int
        /// The order in which contacts are to be handled for the queue. For more information, see [Queues: priority and delay](https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html).
        /// This member is required.
        public var priority: Swift.Int?
        /// The Amazon Resource Name (ARN) of the queue.
        /// This member is required.
        public var queueArn: Swift.String?
        /// The identifier for the queue.
        /// This member is required.
        public var queueId: Swift.String?
        /// The name of the queue.
        /// This member is required.
        public var queueName: Swift.String?

        public init(
            channel: ConnectClientTypes.Channel? = nil,
            delay: Swift.Int = 0,
            priority: Swift.Int? = nil,
            queueArn: Swift.String? = nil,
            queueId: Swift.String? = nil,
            queueName: Swift.String? = nil
        )
        {
            self.channel = channel
            self.delay = delay
            self.priority = priority
            self.queueArn = queueArn
            self.queueId = queueId
            self.queueName = queueName
        }
    }

}

public struct ListRoutingProfileQueuesOutput {
    /// The Amazon Web Services Region where this resource was last modified.
    public var lastModifiedRegion: Swift.String?
    /// The timestamp when this resource was last modified.
    public var lastModifiedTime: Foundation.Date?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the routing profiles.
    public var routingProfileQueueConfigSummaryList: [ConnectClientTypes.RoutingProfileQueueConfigSummary]?

    public init(
        lastModifiedRegion: Swift.String? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        nextToken: Swift.String? = nil,
        routingProfileQueueConfigSummaryList: [ConnectClientTypes.RoutingProfileQueueConfigSummary]? = nil
    )
    {
        self.lastModifiedRegion = lastModifiedRegion
        self.lastModifiedTime = lastModifiedTime
        self.nextToken = nextToken
        self.routingProfileQueueConfigSummaryList = routingProfileQueueConfigSummaryList
    }
}

public struct ListRoutingProfilesInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page. The default MaxResult size is 100.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ConnectClientTypes {
    /// Contains summary information about a routing profile.
    public struct RoutingProfileSummary {
        /// The Amazon Resource Name (ARN) of the routing profile.
        public var arn: Swift.String?
        /// The identifier of the routing profile.
        public var id: Swift.String?
        /// The Amazon Web Services Region where this resource was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when this resource was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// The name of the routing profile.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
        }
    }

}

public struct ListRoutingProfilesOutput {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the routing profiles.
    public var routingProfileSummaryList: [ConnectClientTypes.RoutingProfileSummary]?

    public init(
        nextToken: Swift.String? = nil,
        routingProfileSummaryList: [ConnectClientTypes.RoutingProfileSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.routingProfileSummaryList = routingProfileSummaryList
    }
}

public struct ListRulesInput {
    /// The name of the event source.
    public var eventSourceName: ConnectClientTypes.EventSourceName?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The publish status of the rule.
    public var publishStatus: ConnectClientTypes.RulePublishStatus?

    public init(
        eventSourceName: ConnectClientTypes.EventSourceName? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        publishStatus: ConnectClientTypes.RulePublishStatus? = nil
    )
    {
        self.eventSourceName = eventSourceName
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.publishStatus = publishStatus
    }
}

extension ConnectClientTypes {
    /// A list of ActionTypes associated with a rule.
    public struct RuleSummary {
        /// A list of ActionTypes associated with a rule.
        /// This member is required.
        public var actionSummaries: [ConnectClientTypes.ActionSummary]?
        /// The timestamp for when the rule was created.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// The name of the event source.
        /// This member is required.
        public var eventSourceName: ConnectClientTypes.EventSourceName?
        /// The timestamp for when the rule was last updated.
        /// This member is required.
        public var lastUpdatedTime: Foundation.Date?
        /// The name of the rule.
        /// This member is required.
        public var name: Swift.String?
        /// The publish status of the rule.
        /// This member is required.
        public var publishStatus: ConnectClientTypes.RulePublishStatus?
        /// The Amazon Resource Name (ARN) of the rule.
        /// This member is required.
        public var ruleArn: Swift.String?
        /// A unique identifier for the rule.
        /// This member is required.
        public var ruleId: Swift.String?

        public init(
            actionSummaries: [ConnectClientTypes.ActionSummary]? = nil,
            createdTime: Foundation.Date? = nil,
            eventSourceName: ConnectClientTypes.EventSourceName? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            publishStatus: ConnectClientTypes.RulePublishStatus? = nil,
            ruleArn: Swift.String? = nil,
            ruleId: Swift.String? = nil
        )
        {
            self.actionSummaries = actionSummaries
            self.createdTime = createdTime
            self.eventSourceName = eventSourceName
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.publishStatus = publishStatus
            self.ruleArn = ruleArn
            self.ruleId = ruleId
        }
    }

}

public struct ListRulesOutput {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Summary information about a rule.
    /// This member is required.
    public var ruleSummaryList: [ConnectClientTypes.RuleSummary]?

    public init(
        nextToken: Swift.String? = nil,
        ruleSummaryList: [ConnectClientTypes.RuleSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.ruleSummaryList = ruleSummaryList
    }
}

public struct ListSecurityKeysInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ConnectClientTypes {
    /// Configuration information of the security key.
    public struct SecurityKey {
        /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
        public var associationId: Swift.String?
        /// When the security key was created.
        public var creationTime: Foundation.Date?
        /// The key of the security key.
        public var key: Swift.String?

        public init(
            associationId: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            key: Swift.String? = nil
        )
        {
            self.associationId = associationId
            self.creationTime = creationTime
            self.key = key
        }
    }

}

public struct ListSecurityKeysOutput {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// The security keys.
    public var securityKeys: [ConnectClientTypes.SecurityKey]?

    public init(
        nextToken: Swift.String? = nil,
        securityKeys: [ConnectClientTypes.SecurityKey]? = nil
    )
    {
        self.nextToken = nextToken
        self.securityKeys = securityKeys
    }
}

public struct ListSecurityProfileApplicationsInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The identifier for the security profle.
    /// This member is required.
    public var securityProfileId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        securityProfileId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.securityProfileId = securityProfileId
    }
}

public struct ListSecurityProfileApplicationsOutput {
    /// A list of the third-party application's metadata.
    public var applications: [ConnectClientTypes.Application]?
    /// The Amazon Web Services Region where this resource was last modified.
    public var lastModifiedRegion: Swift.String?
    /// The timestamp when this resource was last modified.
    public var lastModifiedTime: Foundation.Date?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        applications: [ConnectClientTypes.Application]? = nil,
        lastModifiedRegion: Swift.String? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applications = applications
        self.lastModifiedRegion = lastModifiedRegion
        self.lastModifiedTime = lastModifiedTime
        self.nextToken = nextToken
    }
}

public struct ListSecurityProfilePermissionsInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The identifier for the security profle.
    /// This member is required.
    public var securityProfileId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        securityProfileId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.securityProfileId = securityProfileId
    }
}

public struct ListSecurityProfilePermissionsOutput {
    /// The Amazon Web Services Region where this resource was last modified.
    public var lastModifiedRegion: Swift.String?
    /// The timestamp when this resource was last modified.
    public var lastModifiedTime: Foundation.Date?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// The permissions granted to the security profile. For a complete list of valid permissions, see [List of security profile permissions](https://docs.aws.amazon.com/connect/latest/adminguide/security-profile-list.html).
    public var permissions: [Swift.String]?

    public init(
        lastModifiedRegion: Swift.String? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        nextToken: Swift.String? = nil,
        permissions: [Swift.String]? = nil
    )
    {
        self.lastModifiedRegion = lastModifiedRegion
        self.lastModifiedTime = lastModifiedTime
        self.nextToken = nextToken
        self.permissions = permissions
    }
}

public struct ListSecurityProfilesInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page. The default MaxResult size is 100.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ConnectClientTypes {
    /// Contains information about a security profile.
    public struct SecurityProfileSummary {
        /// The Amazon Resource Name (ARN) of the security profile.
        public var arn: Swift.String?
        /// The identifier of the security profile.
        public var id: Swift.String?
        /// The Amazon Web Services Region where this resource was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when this resource was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// The name of the security profile.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
        }
    }

}

public struct ListSecurityProfilesOutput {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the security profiles.
    public var securityProfileSummaryList: [ConnectClientTypes.SecurityProfileSummary]?

    public init(
        nextToken: Swift.String? = nil,
        securityProfileSummaryList: [ConnectClientTypes.SecurityProfileSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.securityProfileSummaryList = securityProfileSummaryList
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) of the resource. All Amazon Connect resources (instances, queues, flows, routing profiles, etc) have an ARN. To locate the ARN for an instance, for example, see [Find your Amazon Connect instance ID/ARN](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html).
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// Information about the tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct ListTaskTemplatesInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page. It is not expected that you set this.
    public var maxResults: Swift.Int?
    /// The name of the task template.
    public var name: Swift.String?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. It is not expected that you set this because the value returned in the previous response is always null.
    public var nextToken: Swift.String?
    /// Marks a template as ACTIVE or INACTIVE for a task to refer to it. Tasks can only be created from ACTIVE templates. If a template is marked as INACTIVE, then a task that refers to this template cannot be created.
    public var status: ConnectClientTypes.TaskTemplateStatus?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        status: ConnectClientTypes.TaskTemplateStatus? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.status = status
    }
}

extension ConnectClientTypes {
    /// Contains summary information about the task template.
    public struct TaskTemplateMetadata {
        /// The Amazon Resource Name (ARN) of the task template.
        public var arn: Swift.String?
        /// The timestamp when the task template was created.
        public var createdTime: Foundation.Date?
        /// The description of the task template.
        public var description: Swift.String?
        /// A unique identifier for the task template.
        public var id: Swift.String?
        /// The timestamp when the task template was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// The name of the task template.
        public var name: Swift.String?
        /// Marks a template as ACTIVE or INACTIVE for a task to refer to it. Tasks can only be created from ACTIVE templates. If a template is marked as INACTIVE, then a task that refers to this template cannot be created.
        public var status: ConnectClientTypes.TaskTemplateStatus?

        public init(
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            status: ConnectClientTypes.TaskTemplateStatus? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.status = status
        }
    }

}

public struct ListTaskTemplatesOutput {
    /// If there are additional results, this is the token for the next set of results. This is always returned as a null in the response.
    public var nextToken: Swift.String?
    /// Provides details about a list of task templates belonging to an instance.
    public var taskTemplates: [ConnectClientTypes.TaskTemplateMetadata]?

    public init(
        nextToken: Swift.String? = nil,
        taskTemplates: [ConnectClientTypes.TaskTemplateMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.taskTemplates = taskTemplates
    }
}

public struct ListTrafficDistributionGroupsInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ConnectClientTypes {
    /// Information about traffic distribution groups.
    public struct TrafficDistributionGroupSummary {
        /// The Amazon Resource Name (ARN) of the traffic distribution group.
        public var arn: Swift.String?
        /// The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.
        public var id: Swift.String?
        /// The Amazon Resource Name (ARN) of the traffic distribution group.
        public var instanceArn: Swift.String?
        /// Whether this is the default traffic distribution group created during instance replication. The default traffic distribution group cannot be deleted by the DeleteTrafficDistributionGroup API. The default traffic distribution group is deleted as part of the process for deleting a replica.
        public var isDefault: Swift.Bool
        /// The name of the traffic distribution group.
        public var name: Swift.String?
        /// The status of the traffic distribution group.
        ///
        /// * CREATION_IN_PROGRESS means the previous [CreateTrafficDistributionGroup](https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html) operation is still in progress and has not yet completed.
        ///
        /// * ACTIVE means the previous [CreateTrafficDistributionGroup](https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html) operation has succeeded.
        ///
        /// * CREATION_FAILED indicates that the previous [CreateTrafficDistributionGroup](https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html) operation has failed.
        ///
        /// * PENDING_DELETION means the previous [DeleteTrafficDistributionGroup](https://docs.aws.amazon.com/connect/latest/APIReference/API_DeleteTrafficDistributionGroup.html) operation is still in progress and has not yet completed.
        ///
        /// * DELETION_FAILED means the previous [DeleteTrafficDistributionGroup](https://docs.aws.amazon.com/connect/latest/APIReference/API_DeleteTrafficDistributionGroup.html) operation has failed.
        ///
        /// * UPDATE_IN_PROGRESS means the previous [UpdateTrafficDistributionGroup](https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdateTrafficDistributionGroup.html) operation is still in progress and has not yet completed.
        public var status: ConnectClientTypes.TrafficDistributionGroupStatus?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            instanceArn: Swift.String? = nil,
            isDefault: Swift.Bool = false,
            name: Swift.String? = nil,
            status: ConnectClientTypes.TrafficDistributionGroupStatus? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.instanceArn = instanceArn
            self.isDefault = isDefault
            self.name = name
            self.status = status
        }
    }

}

public struct ListTrafficDistributionGroupsOutput {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// A list of traffic distribution groups.
    public var trafficDistributionGroupSummaryList: [ConnectClientTypes.TrafficDistributionGroupSummary]?

    public init(
        nextToken: Swift.String? = nil,
        trafficDistributionGroupSummaryList: [ConnectClientTypes.TrafficDistributionGroupSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.trafficDistributionGroupSummaryList = trafficDistributionGroupSummaryList
    }
}

public struct ListTrafficDistributionGroupUsersInput {
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.
    /// This member is required.
    public var trafficDistributionGroupId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        trafficDistributionGroupId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.trafficDistributionGroupId = trafficDistributionGroupId
    }
}

extension ConnectClientTypes {
    /// Summary information about a traffic distribution group user.
    public struct TrafficDistributionGroupUserSummary {
        /// The identifier for the user. This can be the ID or the ARN of the user.
        public var userId: Swift.String?

        public init(
            userId: Swift.String? = nil
        )
        {
            self.userId = userId
        }
    }

}

public struct ListTrafficDistributionGroupUsersOutput {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// A list of traffic distribution group users.
    public var trafficDistributionGroupUserSummaryList: [ConnectClientTypes.TrafficDistributionGroupUserSummary]?

    public init(
        nextToken: Swift.String? = nil,
        trafficDistributionGroupUserSummaryList: [ConnectClientTypes.TrafficDistributionGroupUserSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.trafficDistributionGroupUserSummaryList = trafficDistributionGroupUserSummaryList
    }
}

/// Provides summary information about the use cases for the specified integration association.
public struct ListUseCasesInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the integration association.
    /// This member is required.
    public var integrationAssociationId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        integrationAssociationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.integrationAssociationId = integrationAssociationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ConnectClientTypes {
    /// Contains the use case.
    public struct UseCase {
        /// The Amazon Resource Name (ARN) for the use case.
        public var useCaseArn: Swift.String?
        /// The identifier for the use case.
        public var useCaseId: Swift.String?
        /// The type of use case to associate to the integration association. Each integration association can have only one of each use case type.
        public var useCaseType: ConnectClientTypes.UseCaseType?

        public init(
            useCaseArn: Swift.String? = nil,
            useCaseId: Swift.String? = nil,
            useCaseType: ConnectClientTypes.UseCaseType? = nil
        )
        {
            self.useCaseArn = useCaseArn
            self.useCaseId = useCaseId
            self.useCaseType = useCaseType
        }
    }

}

public struct ListUseCasesOutput {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// The use cases.
    public var useCaseSummaryList: [ConnectClientTypes.UseCase]?

    public init(
        nextToken: Swift.String? = nil,
        useCaseSummaryList: [ConnectClientTypes.UseCase]? = nil
    )
    {
        self.nextToken = nextToken
        self.useCaseSummaryList = useCaseSummaryList
    }
}

public struct ListUserHierarchyGroupsInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page. The default MaxResult size is 100.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListUserHierarchyGroupsOutput {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the hierarchy groups.
    public var userHierarchyGroupSummaryList: [ConnectClientTypes.HierarchyGroupSummary]?

    public init(
        nextToken: Swift.String? = nil,
        userHierarchyGroupSummaryList: [ConnectClientTypes.HierarchyGroupSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.userHierarchyGroupSummaryList = userHierarchyGroupSummaryList
    }
}

public struct ListUserProficienciesInput {
    /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The identifier of the user account.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.userId = userId
    }
}

public struct ListUserProficienciesOutput {
    /// The region in which a user's proficiencies were last modified.
    public var lastModifiedRegion: Swift.String?
    /// The last time that the user's proficiencies are were modified.
    public var lastModifiedTime: Foundation.Date?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the user proficiencies.
    public var userProficiencyList: [ConnectClientTypes.UserProficiency]?

    public init(
        lastModifiedRegion: Swift.String? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        nextToken: Swift.String? = nil,
        userProficiencyList: [ConnectClientTypes.UserProficiency]? = nil
    )
    {
        self.lastModifiedRegion = lastModifiedRegion
        self.lastModifiedTime = lastModifiedTime
        self.nextToken = nextToken
        self.userProficiencyList = userProficiencyList
    }
}

public struct ListUsersInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page. The default MaxResult size is 100.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ConnectClientTypes {
    /// Contains summary information about a user.
    public struct UserSummary {
        /// The Amazon Resource Name (ARN) of the user account.
        public var arn: Swift.String?
        /// The identifier of the user account.
        public var id: Swift.String?
        /// The Amazon Web Services Region where this resource was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when this resource was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// The Amazon Connect user name of the user account.
        public var username: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            username: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.username = username
        }
    }

}

public struct ListUsersOutput {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the users.
    public var userSummaryList: [ConnectClientTypes.UserSummary]?

    public init(
        nextToken: Swift.String? = nil,
        userSummaryList: [ConnectClientTypes.UserSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.userSummaryList = userSummaryList
    }
}

public struct ListViewsInput {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page. The default MaxResult size is 100.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The type of the view.
    public var type: ConnectClientTypes.ViewType?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        type: ConnectClientTypes.ViewType? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.type = type
    }
}

extension ConnectClientTypes {
    /// A summary of a view's metadata.
    public struct ViewSummary {
        /// The Amazon Resource Name (ARN) of the view.
        public var arn: Swift.String?
        /// The description of the view.
        public var description: Swift.String?
        /// The identifier of the view.
        public var id: Swift.String?
        /// The name of the view.
        public var name: Swift.String?
        /// Indicates the view status as either SAVED or PUBLISHED. The PUBLISHED status will initiate validation on the content.
        public var status: ConnectClientTypes.ViewStatus?
        /// The type of the view.
        public var type: ConnectClientTypes.ViewType?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: ConnectClientTypes.ViewStatus? = nil,
            type: ConnectClientTypes.ViewType? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.id = id
            self.name = name
            self.status = status
            self.type = type
        }
    }

}

extension ConnectClientTypes.ViewSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ViewSummary(arn: \(Swift.String(describing: arn)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), name: \"CONTENT_REDACTED\")"}
}

public struct ListViewsOutput {
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A list of view summaries.
    public var viewsSummaryList: [ConnectClientTypes.ViewSummary]?

    public init(
        nextToken: Swift.String? = nil,
        viewsSummaryList: [ConnectClientTypes.ViewSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.viewsSummaryList = viewsSummaryList
    }
}

public struct ListViewVersionsInput {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page. The default MaxResult size is 100.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The identifier of the view. Both ViewArn and ViewId can be used.
    /// This member is required.
    public var viewId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        viewId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.viewId = viewId
    }
}

extension ConnectClientTypes {
    /// A summary of a view version's metadata.
    public struct ViewVersionSummary {
        /// The Amazon Resource Name (ARN) of the view version.
        public var arn: Swift.String?
        /// The description of the view version.
        public var description: Swift.String?
        /// The identifier of the view version.
        public var id: Swift.String?
        /// The name of the view version.
        public var name: Swift.String?
        /// The type of the view version.
        public var type: ConnectClientTypes.ViewType?
        /// The sequentially incremented version of the view version.
        public var version: Swift.Int
        /// The description of the view version.
        public var versionDescription: Swift.String?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            type: ConnectClientTypes.ViewType? = nil,
            version: Swift.Int = 0,
            versionDescription: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.id = id
            self.name = name
            self.type = type
            self.version = version
            self.versionDescription = versionDescription
        }
    }

}

extension ConnectClientTypes.ViewVersionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ViewVersionSummary(arn: \(Swift.String(describing: arn)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), type: \(Swift.String(describing: type)), version: \(Swift.String(describing: version)), versionDescription: \(Swift.String(describing: versionDescription)), name: \"CONTENT_REDACTED\")"}
}

public struct ListViewVersionsOutput {
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A list of view version summaries.
    public var viewVersionSummaryList: [ConnectClientTypes.ViewVersionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        viewVersionSummaryList: [ConnectClientTypes.ViewVersionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.viewVersionSummaryList = viewVersionSummaryList
    }
}

public struct MonitorContactInput {
    /// Specify which monitoring actions the user is allowed to take. For example, whether the user is allowed to escalate from silent monitoring to barge. AllowedMonitorCapabilities is required if barge is enabled.
    public var allowedMonitorCapabilities: [ConnectClientTypes.MonitorCapability]?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The identifier of the contact.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the user account.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        allowedMonitorCapabilities: [ConnectClientTypes.MonitorCapability]? = nil,
        clientToken: Swift.String? = nil,
        contactId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.allowedMonitorCapabilities = allowedMonitorCapabilities
        self.clientToken = clientToken
        self.contactId = contactId
        self.instanceId = instanceId
        self.userId = userId
    }
}

public struct MonitorContactOutput {
    /// The ARN of the contact.
    public var contactArn: Swift.String?
    /// The identifier of the contact.
    public var contactId: Swift.String?

    public init(
        contactArn: Swift.String? = nil,
        contactId: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
        self.contactId = contactId
    }
}

/// Operation cannot be performed at this time as there is a conflict with another operation or contact state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct PauseContactInput {
    /// The identifier of the flow.
    public var contactFlowId: Swift.String?
    /// The identifier of the contact.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        contactFlowId: Swift.String? = nil,
        contactId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.contactFlowId = contactFlowId
        self.contactId = contactId
        self.instanceId = instanceId
    }
}

public struct PauseContactOutput {

    public init() { }
}

public struct PutUserStatusInput {
    /// The identifier of the agent status.
    /// This member is required.
    public var agentStatusId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the user.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        agentStatusId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.agentStatusId = agentStatusId
        self.instanceId = instanceId
        self.userId = userId
    }
}

public struct PutUserStatusOutput {

    public init() { }
}

public struct ReleasePhoneNumberInput {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// A unique identifier for the phone number.
    /// This member is required.
    public var phoneNumberId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        phoneNumberId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.phoneNumberId = phoneNumberId
    }
}

public struct ReplicateInstanceInput {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance. You can provide the InstanceId, or the entire ARN.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The alias for the replicated instance. The ReplicaAlias must be unique.
    /// This member is required.
    public var replicaAlias: Swift.String?
    /// The Amazon Web Services Region where to replicate the Amazon Connect instance.
    /// This member is required.
    public var replicaRegion: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        replicaAlias: Swift.String? = nil,
        replicaRegion: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.instanceId = instanceId
        self.replicaAlias = replicaAlias
        self.replicaRegion = replicaRegion
    }
}

extension ReplicateInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReplicateInstanceInput(clientToken: \(Swift.String(describing: clientToken)), instanceId: \(Swift.String(describing: instanceId)), replicaRegion: \(Swift.String(describing: replicaRegion)), replicaAlias: \"CONTENT_REDACTED\")"}
}

public struct ReplicateInstanceOutput {
    /// The Amazon Resource Name (ARN) of the replicated instance.
    public var arn: Swift.String?
    /// The identifier of the replicated instance. You can find the instanceId in the ARN of the instance. The replicated instance has the same identifier as the instance it was replicated from.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

public struct ResumeContactInput {
    /// The identifier of the flow.
    public var contactFlowId: Swift.String?
    /// The identifier of the contact.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        contactFlowId: Swift.String? = nil,
        contactId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.contactFlowId = contactFlowId
        self.contactId = contactId
        self.instanceId = instanceId
    }
}

public struct ResumeContactOutput {

    public init() { }
}

public struct ResumeContactRecordingInput {
    /// The identifier of the contact.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.
    /// This member is required.
    public var initialContactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        contactId: Swift.String? = nil,
        initialContactId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.contactId = contactId
        self.initialContactId = initialContactId
        self.instanceId = instanceId
    }
}

public struct ResumeContactRecordingOutput {

    public init() { }
}

public struct SearchAgentStatusesOutput {
    /// The search criteria to be used to return agent statuses.
    public var agentStatuses: [ConnectClientTypes.AgentStatus]?
    /// The total number of agent statuses which matched your search query.
    public var approximateTotalCount: Swift.Int?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        agentStatuses: [ConnectClientTypes.AgentStatus]? = nil,
        approximateTotalCount: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentStatuses = agentStatuses
        self.approximateTotalCount = approximateTotalCount
        self.nextToken = nextToken
    }
}

public struct SearchAvailablePhoneNumbersInput {
    /// The identifier of the Amazon Connect instance that phone numbers are claimed to. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance. You must enter InstanceId or TargetArn.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ISO country code.
    /// This member is required.
    public var phoneNumberCountryCode: ConnectClientTypes.PhoneNumberCountryCode?
    /// The prefix of the phone number. If provided, it must contain + as part of the country code.
    public var phoneNumberPrefix: Swift.String?
    /// The type of phone number.
    /// This member is required.
    public var phoneNumberType: ConnectClientTypes.PhoneNumberType?
    /// The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone number inbound traffic is routed through. You must enter InstanceId or TargetArn.
    public var targetArn: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        phoneNumberCountryCode: ConnectClientTypes.PhoneNumberCountryCode? = nil,
        phoneNumberPrefix: Swift.String? = nil,
        phoneNumberType: ConnectClientTypes.PhoneNumberType? = nil,
        targetArn: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.phoneNumberCountryCode = phoneNumberCountryCode
        self.phoneNumberPrefix = phoneNumberPrefix
        self.phoneNumberType = phoneNumberType
        self.targetArn = targetArn
    }
}

extension ConnectClientTypes {
    /// Information about available phone numbers.
    public struct AvailableNumberSummary {
        /// The phone number. Phone numbers are formatted [+] [country code] [subscriber number including area code].
        public var phoneNumber: Swift.String?
        /// The ISO country code.
        public var phoneNumberCountryCode: ConnectClientTypes.PhoneNumberCountryCode?
        /// The type of phone number.
        public var phoneNumberType: ConnectClientTypes.PhoneNumberType?

        public init(
            phoneNumber: Swift.String? = nil,
            phoneNumberCountryCode: ConnectClientTypes.PhoneNumberCountryCode? = nil,
            phoneNumberType: ConnectClientTypes.PhoneNumberType? = nil
        )
        {
            self.phoneNumber = phoneNumber
            self.phoneNumberCountryCode = phoneNumberCountryCode
            self.phoneNumberType = phoneNumberType
        }
    }

}

public struct SearchAvailablePhoneNumbersOutput {
    /// A list of available phone numbers that you can claim to your Amazon Connect instance or traffic distribution group.
    public var availableNumbersList: [ConnectClientTypes.AvailableNumberSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        availableNumbersList: [ConnectClientTypes.AvailableNumberSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.availableNumbersList = availableNumbersList
        self.nextToken = nextToken
    }
}

extension ConnectClientTypes {
    /// An object that can be used to specify Tag conditions inside the SearchFilter. This accepts an OR of AND (List of List) input where:
    ///
    /// * Top level list specifies conditions that need to be applied with OR operator
    ///
    /// * Inner list specifies conditions that need to be applied with AND operator.
    public struct ControlPlaneTagFilter {
        /// A list of conditions which would be applied together with an AND condition.
        public var andConditions: [ConnectClientTypes.TagCondition]?
        /// A list of conditions which would be applied together with an OR condition.
        public var orConditions: [[ConnectClientTypes.TagCondition]]?
        /// A leaf node condition which can be used to specify a tag condition.
        public var tagCondition: ConnectClientTypes.TagCondition?

        public init(
            andConditions: [ConnectClientTypes.TagCondition]? = nil,
            orConditions: [[ConnectClientTypes.TagCondition]]? = nil,
            tagCondition: ConnectClientTypes.TagCondition? = nil
        )
        {
            self.andConditions = andConditions
            self.orConditions = orConditions
            self.tagCondition = tagCondition
        }
    }

}

extension ConnectClientTypes {
    /// The search criteria to be used to return flow modules.
    public struct ContactFlowModuleSearchFilter {
        /// An object that can be used to specify Tag conditions inside the SearchFilter. This accepts an OR of AND (List of List) input where:
        ///
        /// * Top level list specifies conditions that need to be applied with OR operator
        ///
        /// * Inner list specifies conditions that need to be applied with AND operator.
        public var tagFilter: ConnectClientTypes.ControlPlaneTagFilter?

        public init(
            tagFilter: ConnectClientTypes.ControlPlaneTagFilter? = nil
        )
        {
            self.tagFilter = tagFilter
        }
    }

}

public struct SearchContactFlowModulesOutput {
    /// The total number of contact flows which matched your search query.
    public var approximateTotalCount: Swift.Int?
    /// The search criteria to be used to return contact flow modules.
    public var contactFlowModules: [ConnectClientTypes.ContactFlowModule]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        approximateTotalCount: Swift.Int? = nil,
        contactFlowModules: [ConnectClientTypes.ContactFlowModule]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.approximateTotalCount = approximateTotalCount
        self.contactFlowModules = contactFlowModules
        self.nextToken = nextToken
    }
}

extension ConnectClientTypes {
    /// Filters to be applied to search results.
    public struct ContactFlowSearchFilter {
        /// An object that can be used to specify Tag conditions inside the SearchFilter. This accepts an OR of AND (List of List) input where:
        ///
        /// * Top level list specifies conditions that need to be applied with OR operator
        ///
        /// * Inner list specifies conditions that need to be applied with AND operator.
        public var tagFilter: ConnectClientTypes.ControlPlaneTagFilter?

        public init(
            tagFilter: ConnectClientTypes.ControlPlaneTagFilter? = nil
        )
        {
            self.tagFilter = tagFilter
        }
    }

}

public struct SearchContactFlowsOutput {
    /// The total number of contact flows which matched your search query.
    public var approximateTotalCount: Swift.Int?
    /// Information about the flows.
    public var contactFlows: [ConnectClientTypes.ContactFlow]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        approximateTotalCount: Swift.Int? = nil,
        contactFlows: [ConnectClientTypes.ContactFlow]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.approximateTotalCount = approximateTotalCount
        self.contactFlows = contactFlows
        self.nextToken = nextToken
    }
}

extension ConnectClientTypes {

    public enum SearchContactsMatchType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case matchAll
        case matchAny
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchContactsMatchType] {
            return [
                .matchAll,
                .matchAny
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .matchAll: return "MATCH_ALL"
            case .matchAny: return "MATCH_ANY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// A structure that defines search criteria base on words or phrases, participants in the Contact Lens conversational analytics transcript.
    public struct TranscriptCriteria {
        /// The match type combining search criteria using multiple search texts in a transcript criteria.
        /// This member is required.
        public var matchType: ConnectClientTypes.SearchContactsMatchType?
        /// The participant role in a transcript
        /// This member is required.
        public var participantRole: ConnectClientTypes.ParticipantRole?
        /// The words or phrases used to search within a transcript.
        /// This member is required.
        public var searchText: [Swift.String]?

        public init(
            matchType: ConnectClientTypes.SearchContactsMatchType? = nil,
            participantRole: ConnectClientTypes.ParticipantRole? = nil,
            searchText: [Swift.String]? = nil
        )
        {
            self.matchType = matchType
            self.participantRole = participantRole
            self.searchText = searchText
        }
    }

}

extension ConnectClientTypes.TranscriptCriteria: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TranscriptCriteria(matchType: \(Swift.String(describing: matchType)), participantRole: \(Swift.String(describing: participantRole)), searchText: \"CONTENT_REDACTED\")"}
}

extension ConnectClientTypes {
    /// A structure that defines search criteria and matching logic to search for contacts by matching text with transcripts analyzed by Amazon Connect Contact Lens.
    public struct Transcript {
        /// The list of search criteria based on Contact Lens conversational analytics transcript.
        /// This member is required.
        public var criteria: [ConnectClientTypes.TranscriptCriteria]?
        /// The match type combining search criteria using multiple transcript criteria.
        public var matchType: ConnectClientTypes.SearchContactsMatchType?

        public init(
            criteria: [ConnectClientTypes.TranscriptCriteria]? = nil,
            matchType: ConnectClientTypes.SearchContactsMatchType? = nil
        )
        {
            self.criteria = criteria
            self.matchType = matchType
        }
    }

}

extension ConnectClientTypes {
    /// A structure that defines search criteria for contacts using analysis outputs from Amazon Connect Contact Lens.
    public struct ContactAnalysis {
        /// Search criteria based on transcript analyzed by Amazon Connect Contact Lens.
        public var transcript: ConnectClientTypes.Transcript?

        public init(
            transcript: ConnectClientTypes.Transcript? = nil
        )
        {
            self.transcript = transcript
        }
    }

}

extension ConnectClientTypes {
    /// The search criteria based on user-defned contact attribute key and values to search on.
    public struct SearchableContactAttributesCriteria {
        /// The key containing a searchable user-defined contact attribute.
        /// This member is required.
        public var key: Swift.String?
        /// The list of values to search for within a user-defined contact attribute.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            key: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }

}

extension ConnectClientTypes.SearchableContactAttributesCriteria: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchableContactAttributesCriteria(key: \"CONTENT_REDACTED\", values: \"CONTENT_REDACTED\")"}
}

extension ConnectClientTypes {
    /// A structure that defines search criteria based on user-defined contact attributes that are configured for contact search.
    public struct SearchableContactAttributes {
        /// The list of criteria based on user-defined contact attributes that are configured for contact search.
        /// This member is required.
        public var criteria: [ConnectClientTypes.SearchableContactAttributesCriteria]?
        /// The match type combining search criteria using multiple searchable contact attributes.
        public var matchType: ConnectClientTypes.SearchContactsMatchType?

        public init(
            criteria: [ConnectClientTypes.SearchableContactAttributesCriteria]? = nil,
            matchType: ConnectClientTypes.SearchContactsMatchType? = nil
        )
        {
            self.criteria = criteria
            self.matchType = matchType
        }
    }

}

extension ConnectClientTypes {
    /// A structure of search criteria to be used to return contacts.
    public struct SearchCriteria {
        /// The agent hierarchy groups of the agent at the time of handling the contact.
        public var agentHierarchyGroups: ConnectClientTypes.AgentHierarchyGroups?
        /// The identifiers of agents who handled the contacts.
        public var agentIds: [Swift.String]?
        /// The list of channels associated with contacts.
        public var channels: [ConnectClientTypes.Channel]?
        /// Search criteria based on analysis outputs from Amazon Connect Contact Lens.
        public var contactAnalysis: ConnectClientTypes.ContactAnalysis?
        /// The list of initiation methods associated with contacts.
        public var initiationMethods: [ConnectClientTypes.ContactInitiationMethod]?
        /// The list of queue IDs associated with contacts.
        public var queueIds: [Swift.String]?
        /// The search criteria based on user-defined contact attributes that have been configured for contact search. For more information, see [Search by custom contact attributes](https://docs.aws.amazon.com/connect/latest/adminguide/search-custom-attributes.html) in the Amazon Connect Administrator Guide. To use SearchableContactAttributes in a search request, the GetContactAttributes action is required to perform an API request. For more information, see [https://docs.aws.amazon.com/service-authorization/latest/reference/list_amazonconnect.html#amazonconnect-actions-as-permissions](https://docs.aws.amazon.com/service-authorization/latest/reference/list_amazonconnect.html#amazonconnect-actions-as-permissions)Actions defined by Amazon Connect.
        public var searchableContactAttributes: ConnectClientTypes.SearchableContactAttributes?

        public init(
            agentHierarchyGroups: ConnectClientTypes.AgentHierarchyGroups? = nil,
            agentIds: [Swift.String]? = nil,
            channels: [ConnectClientTypes.Channel]? = nil,
            contactAnalysis: ConnectClientTypes.ContactAnalysis? = nil,
            initiationMethods: [ConnectClientTypes.ContactInitiationMethod]? = nil,
            queueIds: [Swift.String]? = nil,
            searchableContactAttributes: ConnectClientTypes.SearchableContactAttributes? = nil
        )
        {
            self.agentHierarchyGroups = agentHierarchyGroups
            self.agentIds = agentIds
            self.channels = channels
            self.contactAnalysis = contactAnalysis
            self.initiationMethods = initiationMethods
            self.queueIds = queueIds
            self.searchableContactAttributes = searchableContactAttributes
        }
    }

}

extension ConnectClientTypes {

    public enum SortableFieldName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case channel
        case connectedToAgentTimestamp
        case disconnectTimestamp
        case initiationMethod
        case initiationTimestamp
        case scheduledTimestamp
        case sdkUnknown(Swift.String)

        public static var allCases: [SortableFieldName] {
            return [
                .channel,
                .connectedToAgentTimestamp,
                .disconnectTimestamp,
                .initiationMethod,
                .initiationTimestamp,
                .scheduledTimestamp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .channel: return "CHANNEL"
            case .connectedToAgentTimestamp: return "CONNECTED_TO_AGENT_TIMESTAMP"
            case .disconnectTimestamp: return "DISCONNECT_TIMESTAMP"
            case .initiationMethod: return "INITIATION_METHOD"
            case .initiationTimestamp: return "INITIATION_TIMESTAMP"
            case .scheduledTimestamp: return "SCHEDULED_TIMESTAMP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// A structure that defines the field name to sort by and a sort order.
    public struct Sort {
        /// The name of the field on which to sort.
        /// This member is required.
        public var fieldName: ConnectClientTypes.SortableFieldName?
        /// An ascending or descending sort.
        /// This member is required.
        public var order: ConnectClientTypes.SortOrder?

        public init(
            fieldName: ConnectClientTypes.SortableFieldName? = nil,
            order: ConnectClientTypes.SortOrder? = nil
        )
        {
            self.fieldName = fieldName
            self.order = order
        }
    }

}

extension ConnectClientTypes {

    public enum SearchContactsTimeRangeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case connectedToAgentTimestamp
        case disconnectTimestamp
        case initiationTimestamp
        case scheduledTimestamp
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchContactsTimeRangeType] {
            return [
                .connectedToAgentTimestamp,
                .disconnectTimestamp,
                .initiationTimestamp,
                .scheduledTimestamp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .connectedToAgentTimestamp: return "CONNECTED_TO_AGENT_TIMESTAMP"
            case .disconnectTimestamp: return "DISCONNECT_TIMESTAMP"
            case .initiationTimestamp: return "INITIATION_TIMESTAMP"
            case .scheduledTimestamp: return "SCHEDULED_TIMESTAMP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// A structure of time range that you want to search results.
    public struct SearchContactsTimeRange {
        /// The end time of the time range.
        /// This member is required.
        public var endTime: Foundation.Date?
        /// The start time of the time range.
        /// This member is required.
        public var startTime: Foundation.Date?
        /// The type of timestamp to search.
        /// This member is required.
        public var type: ConnectClientTypes.SearchContactsTimeRangeType?

        public init(
            endTime: Foundation.Date? = nil,
            startTime: Foundation.Date? = nil,
            type: ConnectClientTypes.SearchContactsTimeRangeType? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
            self.type = type
        }
    }

}

public struct SearchContactsInput {
    /// The identifier of Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The search criteria to be used to return contacts.
    public var searchCriteria: ConnectClientTypes.SearchCriteria?
    /// Specifies a field to sort by and a sort order.
    public var sort: ConnectClientTypes.Sort?
    /// Time range that you want to search results.
    /// This member is required.
    public var timeRange: ConnectClientTypes.SearchContactsTimeRange?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchCriteria: ConnectClientTypes.SearchCriteria? = nil,
        sort: ConnectClientTypes.Sort? = nil,
        timeRange: ConnectClientTypes.SearchContactsTimeRange? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchCriteria = searchCriteria
        self.sort = sort
        self.timeRange = timeRange
    }
}

extension ConnectClientTypes {
    /// Information about the agent who accepted the contact.
    public struct ContactSearchSummaryAgentInfo {
        /// The timestamp when the contact was connected to the agent.
        public var connectedToAgentTimestamp: Foundation.Date?
        /// The identifier of the agent who accepted the contact.
        public var id: Swift.String?

        public init(
            connectedToAgentTimestamp: Foundation.Date? = nil,
            id: Swift.String? = nil
        )
        {
            self.connectedToAgentTimestamp = connectedToAgentTimestamp
            self.id = id
        }
    }

}

extension ConnectClientTypes {
    /// If this contact was queued, this contains information about the queue.
    public struct ContactSearchSummaryQueueInfo {
        /// The timestamp when the contact was added to the queue.
        public var enqueueTimestamp: Foundation.Date?
        /// The unique identifier for the queue.
        public var id: Swift.String?

        public init(
            enqueueTimestamp: Foundation.Date? = nil,
            id: Swift.String? = nil
        )
        {
            self.enqueueTimestamp = enqueueTimestamp
            self.id = id
        }
    }

}

extension ConnectClientTypes {
    /// Information of returned contact.
    public struct ContactSearchSummary {
        /// Information about the agent who accepted the contact.
        public var agentInfo: ConnectClientTypes.ContactSearchSummaryAgentInfo?
        /// The Amazon Resource Name (ARN) of the contact.
        public var arn: Swift.String?
        /// How the contact reached your contact center.
        public var channel: ConnectClientTypes.Channel?
        /// The timestamp when the customer endpoint disconnected from Amazon Connect.
        public var disconnectTimestamp: Foundation.Date?
        /// The identifier of the contact summary.
        public var id: Swift.String?
        /// If this contact is related to other contacts, this is the ID of the initial contact.
        public var initialContactId: Swift.String?
        /// Indicates how the contact was initiated.
        public var initiationMethod: ConnectClientTypes.ContactInitiationMethod?
        /// The date and time this contact was initiated, in UTC time. For INBOUND, this is when the contact arrived. For OUTBOUND, this is when the agent began dialing. For CALLBACK, this is when the callback contact was created. For TRANSFER and QUEUE_TRANSFER, this is when the transfer was initiated. For API, this is when the request arrived. For EXTERNAL_OUTBOUND, this is when the agent started dialing the external participant. For MONITOR, this is when the supervisor started listening to a contact.
        public var initiationTimestamp: Foundation.Date?
        /// If this contact is not the first contact, this is the ID of the previous contact.
        public var previousContactId: Swift.String?
        /// If this contact was queued, this contains information about the queue.
        public var queueInfo: ConnectClientTypes.ContactSearchSummaryQueueInfo?
        /// The timestamp, in Unix epoch time format, at which to start running the inbound flow.
        public var scheduledTimestamp: Foundation.Date?

        public init(
            agentInfo: ConnectClientTypes.ContactSearchSummaryAgentInfo? = nil,
            arn: Swift.String? = nil,
            channel: ConnectClientTypes.Channel? = nil,
            disconnectTimestamp: Foundation.Date? = nil,
            id: Swift.String? = nil,
            initialContactId: Swift.String? = nil,
            initiationMethod: ConnectClientTypes.ContactInitiationMethod? = nil,
            initiationTimestamp: Foundation.Date? = nil,
            previousContactId: Swift.String? = nil,
            queueInfo: ConnectClientTypes.ContactSearchSummaryQueueInfo? = nil,
            scheduledTimestamp: Foundation.Date? = nil
        )
        {
            self.agentInfo = agentInfo
            self.arn = arn
            self.channel = channel
            self.disconnectTimestamp = disconnectTimestamp
            self.id = id
            self.initialContactId = initialContactId
            self.initiationMethod = initiationMethod
            self.initiationTimestamp = initiationTimestamp
            self.previousContactId = previousContactId
            self.queueInfo = queueInfo
            self.scheduledTimestamp = scheduledTimestamp
        }
    }

}

public struct SearchContactsOutput {
    /// Information about the contacts.
    /// This member is required.
    public var contacts: [ConnectClientTypes.ContactSearchSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// The total number of contacts which matched your search query.
    public var totalCount: Swift.Int?

    public init(
        contacts: [ConnectClientTypes.ContactSearchSummary]? = nil,
        nextToken: Swift.String? = nil,
        totalCount: Swift.Int? = nil
    )
    {
        self.contacts = contacts
        self.nextToken = nextToken
        self.totalCount = totalCount
    }
}

extension ConnectClientTypes {
    /// Filters to be applied to search results.
    public struct HoursOfOperationSearchFilter {
        /// An object that can be used to specify Tag conditions inside the SearchFilter. This accepts an OR of AND (List of List) input where:
        ///
        /// * Top level list specifies conditions that need to be applied with OR operator
        ///
        /// * Inner list specifies conditions that need to be applied with AND operator.
        public var tagFilter: ConnectClientTypes.ControlPlaneTagFilter?

        public init(
            tagFilter: ConnectClientTypes.ControlPlaneTagFilter? = nil
        )
        {
            self.tagFilter = tagFilter
        }
    }

}

public struct SearchHoursOfOperationsOutput {
    /// The total number of hours of operations which matched your search query.
    public var approximateTotalCount: Swift.Int?
    /// Information about the hours of operations.
    public var hoursOfOperations: [ConnectClientTypes.HoursOfOperation]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        approximateTotalCount: Swift.Int? = nil,
        hoursOfOperations: [ConnectClientTypes.HoursOfOperation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.approximateTotalCount = approximateTotalCount
        self.hoursOfOperations = hoursOfOperations
        self.nextToken = nextToken
    }
}

public struct SearchPredefinedAttributesOutput {
    /// The approximate number of predefined attributes which matched your search query.
    public var approximateTotalCount: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// Predefined attributes matched by the search criteria.
    public var predefinedAttributes: [ConnectClientTypes.PredefinedAttribute]?

    public init(
        approximateTotalCount: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        predefinedAttributes: [ConnectClientTypes.PredefinedAttribute]? = nil
    )
    {
        self.approximateTotalCount = approximateTotalCount
        self.nextToken = nextToken
        self.predefinedAttributes = predefinedAttributes
    }
}

extension ConnectClientTypes {
    /// Filters to be applied to search results.
    public struct PromptSearchFilter {
        /// An object that can be used to specify Tag conditions inside the SearchFilter. This accepts an OR of AND (List of List) input where:
        ///
        /// * Top level list specifies conditions that need to be applied with OR operator
        ///
        /// * Inner list specifies conditions that need to be applied with AND operator.
        public var tagFilter: ConnectClientTypes.ControlPlaneTagFilter?

        public init(
            tagFilter: ConnectClientTypes.ControlPlaneTagFilter? = nil
        )
        {
            self.tagFilter = tagFilter
        }
    }

}

public struct SearchPromptsOutput {
    /// The total number of quick connects which matched your search query.
    public var approximateTotalCount: Swift.Int?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the prompts.
    public var prompts: [ConnectClientTypes.Prompt]?

    public init(
        approximateTotalCount: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        prompts: [ConnectClientTypes.Prompt]? = nil
    )
    {
        self.approximateTotalCount = approximateTotalCount
        self.nextToken = nextToken
        self.prompts = prompts
    }
}

extension ConnectClientTypes {

    public enum SearchableQueueType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchableQueueType] {
            return [
                .standard
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// Filters to be applied to search results.
    public struct QueueSearchFilter {
        /// An object that can be used to specify Tag conditions inside the SearchFilter. This accepts an OR of AND (List of List) input where:
        ///
        /// * Top level list specifies conditions that need to be applied with OR operator
        ///
        /// * Inner list specifies conditions that need to be applied with AND operator.
        public var tagFilter: ConnectClientTypes.ControlPlaneTagFilter?

        public init(
            tagFilter: ConnectClientTypes.ControlPlaneTagFilter? = nil
        )
        {
            self.tagFilter = tagFilter
        }
    }

}

public struct SearchQueuesOutput {
    /// The total number of queues which matched your search query.
    public var approximateTotalCount: Swift.Int?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the queues.
    public var queues: [ConnectClientTypes.Queue]?

    public init(
        approximateTotalCount: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queues: [ConnectClientTypes.Queue]? = nil
    )
    {
        self.approximateTotalCount = approximateTotalCount
        self.nextToken = nextToken
        self.queues = queues
    }
}

extension ConnectClientTypes {
    /// Filters to be applied to search results.
    public struct QuickConnectSearchFilter {
        /// An object that can be used to specify Tag conditions inside the SearchFilter. This accepts an OR of AND (List of List) input where:
        ///
        /// * Top level list specifies conditions that need to be applied with OR operator
        ///
        /// * Inner list specifies conditions that need to be applied with AND operator.
        public var tagFilter: ConnectClientTypes.ControlPlaneTagFilter?

        public init(
            tagFilter: ConnectClientTypes.ControlPlaneTagFilter? = nil
        )
        {
            self.tagFilter = tagFilter
        }
    }

}

public struct SearchQuickConnectsOutput {
    /// The total number of quick connects which matched your search query.
    public var approximateTotalCount: Swift.Int?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the quick connects.
    public var quickConnects: [ConnectClientTypes.QuickConnect]?

    public init(
        approximateTotalCount: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        quickConnects: [ConnectClientTypes.QuickConnect]? = nil
    )
    {
        self.approximateTotalCount = approximateTotalCount
        self.nextToken = nextToken
        self.quickConnects = quickConnects
    }
}

/// Maximum number (1000) of tags have been returned with current request. Consider changing request parameters to get more tags.
public struct MaximumResultReturnedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MaximumResultReturnedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ConnectClientTypes {
    /// The search criteria to be used to return tags.
    public struct TagSearchCondition {
        /// The tag key used in the tag search condition.
        public var tagKey: Swift.String?
        /// The type of comparison to be made when evaluating the tag key in tag search condition.
        public var tagKeyComparisonType: ConnectClientTypes.StringComparisonType?
        /// The tag value used in the tag search condition.
        public var tagValue: Swift.String?
        /// The type of comparison to be made when evaluating the tag value in tag search condition.
        public var tagValueComparisonType: ConnectClientTypes.StringComparisonType?

        public init(
            tagKey: Swift.String? = nil,
            tagKeyComparisonType: ConnectClientTypes.StringComparisonType? = nil,
            tagValue: Swift.String? = nil,
            tagValueComparisonType: ConnectClientTypes.StringComparisonType? = nil
        )
        {
            self.tagKey = tagKey
            self.tagKeyComparisonType = tagKeyComparisonType
            self.tagValue = tagValue
            self.tagValueComparisonType = tagValueComparisonType
        }
    }

}

extension ConnectClientTypes {
    /// The search criteria to be used to search tags.
    public struct ResourceTagsSearchCriteria {
        /// The search criteria to be used to return tags.
        public var tagSearchCondition: ConnectClientTypes.TagSearchCondition?

        public init(
            tagSearchCondition: ConnectClientTypes.TagSearchCondition? = nil
        )
        {
            self.tagSearchCondition = tagSearchCondition
        }
    }

}

public struct SearchResourceTagsInput {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The list of resource types to be used to search tags from. If not provided or if any empty list is provided, this API will search from all supported resource types. Supported resource types
    ///
    /// * AGENT
    ///
    /// * ROUTING_PROFILE
    ///
    /// * STANDARD_QUEUE
    ///
    /// * SECURITY_PROFILE
    ///
    /// * OPERATING_HOURS
    ///
    /// * PROMPT
    ///
    /// * CONTACT_FLOW
    ///
    /// * FLOW_MODULE
    public var resourceTypes: [Swift.String]?
    /// The search criteria to be used to return tags.
    public var searchCriteria: ConnectClientTypes.ResourceTagsSearchCriteria?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceTypes: [Swift.String]? = nil,
        searchCriteria: ConnectClientTypes.ResourceTagsSearchCriteria? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceTypes = resourceTypes
        self.searchCriteria = searchCriteria
    }
}

extension ConnectClientTypes {
    /// A tag set contains tag key and tag value.
    public struct TagSet {
        /// The tag key in the tagSet.
        public var key: Swift.String?
        /// The tag value in the tagSet.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct SearchResourceTagsOutput {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// A list of tags used in the Amazon Connect instance.
    public var tags: [ConnectClientTypes.TagSet]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [ConnectClientTypes.TagSet]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

extension ConnectClientTypes {
    /// Filters to be applied to search results.
    public struct RoutingProfileSearchFilter {
        /// An object that can be used to specify Tag conditions inside the SearchFilter. This accepts an OR of AND (List of List) input where:
        ///
        /// * Top level list specifies conditions that need to be applied with OR operator
        ///
        /// * Inner list specifies conditions that need to be applied with AND operator.
        public var tagFilter: ConnectClientTypes.ControlPlaneTagFilter?

        public init(
            tagFilter: ConnectClientTypes.ControlPlaneTagFilter? = nil
        )
        {
            self.tagFilter = tagFilter
        }
    }

}

public struct SearchRoutingProfilesOutput {
    /// The total number of routing profiles which matched your search query.
    public var approximateTotalCount: Swift.Int?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the routing profiles.
    public var routingProfiles: [ConnectClientTypes.RoutingProfile]?

    public init(
        approximateTotalCount: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        routingProfiles: [ConnectClientTypes.RoutingProfile]? = nil
    )
    {
        self.approximateTotalCount = approximateTotalCount
        self.nextToken = nextToken
        self.routingProfiles = routingProfiles
    }
}

extension ConnectClientTypes {
    /// Filters to be applied to search results.
    public struct SecurityProfilesSearchFilter {
        /// An object that can be used to specify Tag conditions inside the SearchFilter. This accepts an OR of AND (List of List) input where:
        ///
        /// * Top level list specifies conditions that need to be applied with OR operator
        ///
        /// * Inner list specifies conditions that need to be applied with AND operator.
        public var tagFilter: ConnectClientTypes.ControlPlaneTagFilter?

        public init(
            tagFilter: ConnectClientTypes.ControlPlaneTagFilter? = nil
        )
        {
            self.tagFilter = tagFilter
        }
    }

}

extension ConnectClientTypes {
    /// Information about the returned security profiles.
    public struct SecurityProfileSearchSummary {
        /// The Amazon Resource Name (ARN) of the security profile.
        public var arn: Swift.String?
        /// The description of the security profile.
        public var description: Swift.String?
        /// The identifier of the security profile.
        public var id: Swift.String?
        /// The organization resource identifier.
        public var organizationResourceId: Swift.String?
        /// The name of the security profile.
        public var securityProfileName: Swift.String?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            organizationResourceId: Swift.String? = nil,
            securityProfileName: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.id = id
            self.organizationResourceId = organizationResourceId
            self.securityProfileName = securityProfileName
            self.tags = tags
        }
    }

}

public struct SearchSecurityProfilesOutput {
    /// The total number of security profiles which matched your search query.
    public var approximateTotalCount: Swift.Int?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the security profiles.
    public var securityProfiles: [ConnectClientTypes.SecurityProfileSearchSummary]?

    public init(
        approximateTotalCount: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        securityProfiles: [ConnectClientTypes.SecurityProfileSearchSummary]? = nil
    )
    {
        self.approximateTotalCount = approximateTotalCount
        self.nextToken = nextToken
        self.securityProfiles = securityProfiles
    }
}

extension ConnectClientTypes {
    /// Filters to be applied to search results.
    public struct UserHierarchyGroupSearchFilter {
        /// An object that can be used to specify Tag conditions inside the SearchFilter. This accepts an OR or AND (List of List) input where:
        ///
        /// * The top level list specifies conditions that need to be applied with OR operator.
        ///
        /// * The inner list specifies conditions that need to be applied with AND operator.
        public var attributeFilter: ConnectClientTypes.ControlPlaneAttributeFilter?

        public init(
            attributeFilter: ConnectClientTypes.ControlPlaneAttributeFilter? = nil
        )
        {
            self.attributeFilter = attributeFilter
        }
    }

}

public struct SearchUserHierarchyGroupsOutput {
    /// The total number of userHierarchyGroups which matched your search query.
    public var approximateTotalCount: Swift.Int?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the userHierarchyGroups.
    public var userHierarchyGroups: [ConnectClientTypes.HierarchyGroup]?

    public init(
        approximateTotalCount: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        userHierarchyGroups: [ConnectClientTypes.HierarchyGroup]? = nil
    )
    {
        self.approximateTotalCount = approximateTotalCount
        self.nextToken = nextToken
        self.userHierarchyGroups = userHierarchyGroups
    }
}

extension ConnectClientTypes {

    public enum HierarchyGroupMatchType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case exact
        case withChildGroups
        case sdkUnknown(Swift.String)

        public static var allCases: [HierarchyGroupMatchType] {
            return [
                .exact,
                .withChildGroups
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .exact: return "EXACT"
            case .withChildGroups: return "WITH_CHILD_GROUPS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// A leaf node condition which can be used to specify a hierarchy group condition.
    public struct HierarchyGroupCondition {
        /// The type of hierarchy group match.
        public var hierarchyGroupMatchType: ConnectClientTypes.HierarchyGroupMatchType?
        /// The value in the hierarchy group condition.
        public var value: Swift.String?

        public init(
            hierarchyGroupMatchType: ConnectClientTypes.HierarchyGroupMatchType? = nil,
            value: Swift.String? = nil
        )
        {
            self.hierarchyGroupMatchType = hierarchyGroupMatchType
            self.value = value
        }
    }

}

extension ConnectClientTypes {

    public enum NumberComparisonType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equal
        case greater
        case greaterOrEqual
        case lesser
        case lesserOrEqual
        case notEqual
        case range
        case sdkUnknown(Swift.String)

        public static var allCases: [NumberComparisonType] {
            return [
                .equal,
                .greater,
                .greaterOrEqual,
                .lesser,
                .lesserOrEqual,
                .notEqual,
                .range
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equal: return "EQUAL"
            case .greater: return "GREATER"
            case .greaterOrEqual: return "GREATER_OR_EQUAL"
            case .lesser: return "LESSER"
            case .lesserOrEqual: return "LESSER_OR_EQUAL"
            case .notEqual: return "NOT_EQUAL"
            case .range: return "RANGE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// A leaf node condition which can be used to specify a numeric condition. The currently supported value for FieldName is limit.
    public struct NumberCondition {
        /// The type of comparison to be made when evaluating the number condition.
        public var comparisonType: ConnectClientTypes.NumberComparisonType?
        /// The name of the field in the number condition.
        public var fieldName: Swift.String?
        /// The maxValue to be used while evaluating the number condition.
        public var maxValue: Swift.Int?
        /// The minValue to be used while evaluating the number condition.
        public var minValue: Swift.Int?

        public init(
            comparisonType: ConnectClientTypes.NumberComparisonType? = nil,
            fieldName: Swift.String? = nil,
            maxValue: Swift.Int? = nil,
            minValue: Swift.Int? = nil
        )
        {
            self.comparisonType = comparisonType
            self.fieldName = fieldName
            self.maxValue = maxValue
            self.minValue = minValue
        }
    }

}

extension ConnectClientTypes {
    /// A leaf node condition which can be used to specify a ProficiencyName, ProficiencyValue and ProficiencyLimit.
    public struct Condition {
        /// A leaf node condition which can be used to specify a numeric condition.
        public var numberCondition: ConnectClientTypes.NumberCondition?
        /// A leaf node condition which can be used to specify a string condition. The currently supported values for FieldName are name and  value.
        public var stringCondition: ConnectClientTypes.StringCondition?

        public init(
            numberCondition: ConnectClientTypes.NumberCondition? = nil,
            stringCondition: ConnectClientTypes.StringCondition? = nil
        )
        {
            self.numberCondition = numberCondition
            self.stringCondition = stringCondition
        }
    }

}

extension ConnectClientTypes {

    public enum TargetListType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case proficiencies
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetListType] {
            return [
                .proficiencies
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .proficiencies: return "PROFICIENCIES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// A leaf node condition which can be used to specify a List condition to search users with attributes included in Lists like Proficiencies.
    public struct ListCondition {
        /// A list of Condition objects which would be applied together with an AND condition.
        public var conditions: [ConnectClientTypes.Condition]?
        /// The type of target list that will be used to filter the users.
        public var targetListType: ConnectClientTypes.TargetListType?

        public init(
            conditions: [ConnectClientTypes.Condition]? = nil,
            targetListType: ConnectClientTypes.TargetListType? = nil
        )
        {
            self.conditions = conditions
            self.targetListType = targetListType
        }
    }

}

extension ConnectClientTypes {
    /// A list of conditions which would be applied together with an AND condition.
    public struct AttributeAndCondition {
        /// A leaf node condition which can be used to specify a hierarchy group condition.
        public var hierarchyGroupCondition: ConnectClientTypes.HierarchyGroupCondition?
        /// A leaf node condition which can be used to specify a tag condition.
        public var tagConditions: [ConnectClientTypes.TagCondition]?

        public init(
            hierarchyGroupCondition: ConnectClientTypes.HierarchyGroupCondition? = nil,
            tagConditions: [ConnectClientTypes.TagCondition]? = nil
        )
        {
            self.hierarchyGroupCondition = hierarchyGroupCondition
            self.tagConditions = tagConditions
        }
    }

}

extension ConnectClientTypes {
    /// An object that can be used to specify Tag conditions or Hierarchy Group conditions inside the SearchFilter. This accepts an OR of AND (List of List) input where:
    ///
    /// * The top level list specifies conditions that need to be applied with OR operator
    ///
    /// * The inner list specifies conditions that need to be applied with AND operator.
    ///
    ///
    /// Only one field can be populated. Maximum number of allowed Tag conditions is 25. Maximum number of allowed Hierarchy Group conditions is 20.
    public struct ControlPlaneUserAttributeFilter {
        /// A list of conditions which would be applied together with an AND condition.
        public var andCondition: ConnectClientTypes.AttributeAndCondition?
        /// A leaf node condition which can be used to specify a hierarchy group condition.
        public var hierarchyGroupCondition: ConnectClientTypes.HierarchyGroupCondition?
        /// A list of conditions which would be applied together with an OR condition.
        public var orConditions: [ConnectClientTypes.AttributeAndCondition]?
        /// A leaf node condition which can be used to specify a tag condition, for example, HAVE BPO = 123.
        public var tagCondition: ConnectClientTypes.TagCondition?

        public init(
            andCondition: ConnectClientTypes.AttributeAndCondition? = nil,
            hierarchyGroupCondition: ConnectClientTypes.HierarchyGroupCondition? = nil,
            orConditions: [ConnectClientTypes.AttributeAndCondition]? = nil,
            tagCondition: ConnectClientTypes.TagCondition? = nil
        )
        {
            self.andCondition = andCondition
            self.hierarchyGroupCondition = hierarchyGroupCondition
            self.orConditions = orConditions
            self.tagCondition = tagCondition
        }
    }

}

extension ConnectClientTypes {
    /// Filters to be applied to search results.
    public struct UserSearchFilter {
        /// An object that can be used to specify Tag conditions inside the SearchFilter. This accepts an OR of AND (List of List) input where:
        ///
        /// * Top level list specifies conditions that need to be applied with OR operator
        ///
        /// * Inner list specifies conditions that need to be applied with AND operator.
        public var tagFilter: ConnectClientTypes.ControlPlaneTagFilter?
        /// An object that can be used to specify Tag conditions or Hierarchy Group conditions inside the SearchFilter. This accepts an OR of AND (List of List) input where:
        ///
        /// * The top level list specifies conditions that need to be applied with OR operator.
        ///
        /// * The inner list specifies conditions that need to be applied with AND operator.
        ///
        ///
        /// Only one field can be populated. This object can’t be used along with TagFilter. Request can either contain TagFilter or UserAttributeFilter if SearchFilter is specified, combination of both is not supported and such request will throw AccessDeniedException.
        public var userAttributeFilter: ConnectClientTypes.ControlPlaneUserAttributeFilter?

        public init(
            tagFilter: ConnectClientTypes.ControlPlaneTagFilter? = nil,
            userAttributeFilter: ConnectClientTypes.ControlPlaneUserAttributeFilter? = nil
        )
        {
            self.tagFilter = tagFilter
            self.userAttributeFilter = userAttributeFilter
        }
    }

}

extension ConnectClientTypes {
    /// The user's first name and last name.
    public struct UserIdentityInfoLite {
        /// The user's first name.
        public var firstName: Swift.String?
        /// The user's last name.
        public var lastName: Swift.String?

        public init(
            firstName: Swift.String? = nil,
            lastName: Swift.String? = nil
        )
        {
            self.firstName = firstName
            self.lastName = lastName
        }
    }

}

extension ConnectClientTypes.UserIdentityInfoLite: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserIdentityInfoLite(firstName: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\")"}
}

extension ConnectClientTypes {
    /// Information about the returned users.
    public struct UserSearchSummary {
        /// The Amazon Resource Name (ARN) of the user.
        public var arn: Swift.String?
        /// The directory identifier of the user.
        public var directoryUserId: Swift.String?
        /// The identifier of the user's hierarchy group.
        public var hierarchyGroupId: Swift.String?
        /// The identifier of the user's summary.
        public var id: Swift.String?
        /// The user's first name and last name.
        public var identityInfo: ConnectClientTypes.UserIdentityInfoLite?
        /// Contains information about the phone configuration settings for a user.
        public var phoneConfig: ConnectClientTypes.UserPhoneConfig?
        /// The identifier of the user's routing profile.
        public var routingProfileId: Swift.String?
        /// The identifiers of the user's security profiles.
        public var securityProfileIds: [Swift.String]?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public var tags: [Swift.String: Swift.String]?
        /// The name of the user.
        public var username: Swift.String?

        public init(
            arn: Swift.String? = nil,
            directoryUserId: Swift.String? = nil,
            hierarchyGroupId: Swift.String? = nil,
            id: Swift.String? = nil,
            identityInfo: ConnectClientTypes.UserIdentityInfoLite? = nil,
            phoneConfig: ConnectClientTypes.UserPhoneConfig? = nil,
            routingProfileId: Swift.String? = nil,
            securityProfileIds: [Swift.String]? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            username: Swift.String? = nil
        )
        {
            self.arn = arn
            self.directoryUserId = directoryUserId
            self.hierarchyGroupId = hierarchyGroupId
            self.id = id
            self.identityInfo = identityInfo
            self.phoneConfig = phoneConfig
            self.routingProfileId = routingProfileId
            self.securityProfileIds = securityProfileIds
            self.tags = tags
            self.username = username
        }
    }

}

public struct SearchUsersOutput {
    /// The total number of users who matched your search query.
    public var approximateTotalCount: Swift.Int?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the users.
    public var users: [ConnectClientTypes.UserSearchSummary]?

    public init(
        approximateTotalCount: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        users: [ConnectClientTypes.UserSearchSummary]? = nil
    )
    {
        self.approximateTotalCount = approximateTotalCount
        self.nextToken = nextToken
        self.users = users
    }
}

public struct SearchVocabulariesInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see [What is Amazon Transcribe?](https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html)
    public var languageCode: ConnectClientTypes.VocabularyLanguageCode?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The starting pattern of the name of the vocabulary.
    public var nameStartsWith: Swift.String?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The current state of the custom vocabulary.
    public var state: ConnectClientTypes.VocabularyState?

    public init(
        instanceId: Swift.String? = nil,
        languageCode: ConnectClientTypes.VocabularyLanguageCode? = nil,
        maxResults: Swift.Int? = nil,
        nameStartsWith: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        state: ConnectClientTypes.VocabularyState? = nil
    )
    {
        self.instanceId = instanceId
        self.languageCode = languageCode
        self.maxResults = maxResults
        self.nameStartsWith = nameStartsWith
        self.nextToken = nextToken
        self.state = state
    }
}

extension ConnectClientTypes {
    /// Contains summary information about the custom vocabulary.
    public struct VocabularySummary {
        /// The Amazon Resource Name (ARN) of the custom vocabulary.
        /// This member is required.
        public var arn: Swift.String?
        /// The reason why the custom vocabulary was not created.
        public var failureReason: Swift.String?
        /// The identifier of the custom vocabulary.
        /// This member is required.
        public var id: Swift.String?
        /// The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see [What is Amazon Transcribe?](https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html)
        /// This member is required.
        public var languageCode: ConnectClientTypes.VocabularyLanguageCode?
        /// The timestamp when the custom vocabulary was last modified.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// A unique name of the custom vocabulary.
        /// This member is required.
        public var name: Swift.String?
        /// The current state of the custom vocabulary.
        /// This member is required.
        public var state: ConnectClientTypes.VocabularyState?

        public init(
            arn: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            id: Swift.String? = nil,
            languageCode: ConnectClientTypes.VocabularyLanguageCode? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            state: ConnectClientTypes.VocabularyState? = nil
        )
        {
            self.arn = arn
            self.failureReason = failureReason
            self.id = id
            self.languageCode = languageCode
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.state = state
        }
    }

}

public struct SearchVocabulariesOutput {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// The list of the available custom vocabularies.
    public var vocabularySummaryList: [ConnectClientTypes.VocabularySummary]?

    public init(
        nextToken: Swift.String? = nil,
        vocabularySummaryList: [ConnectClientTypes.VocabularySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.vocabularySummaryList = vocabularySummaryList
    }
}

extension ConnectClientTypes {

    public enum ChatEventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disconnect
        case event
        case message
        case sdkUnknown(Swift.String)

        public static var allCases: [ChatEventType] {
            return [
                .disconnect,
                .event,
                .message
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disconnect: return "DISCONNECT"
            case .event: return "EVENT"
            case .message: return "MESSAGE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// Chat integration event containing payload to perform different chat actions such as:
    ///
    /// * Sending a chat message
    ///
    /// * Sending a chat event, such as typing
    ///
    /// * Disconnecting from a chat
    public struct ChatEvent {
        /// Content of the message or event. This is required when Type is MESSAGE and for certain ContentTypes when Type is EVENT.
        ///
        /// * For allowed message content, see the Content parameter in the [SendMessage](https://docs.aws.amazon.com/connect-participant/latest/APIReference/API_SendMessage.html) topic in the Amazon Connect Participant Service API Reference.
        ///
        /// * For allowed event content, see the Content parameter in the [SendEvent](https://docs.aws.amazon.com/connect-participant/latest/APIReference/API_SendEvent.html) topic in the Amazon Connect Participant Service API Reference.
        public var content: Swift.String?
        /// Type of content. This is required when Type is MESSAGE or EVENT.
        ///
        /// * For allowed message content types, see the ContentType parameter in the [SendMessage](https://docs.aws.amazon.com/connect-participant/latest/APIReference/API_SendMessage.html) topic in the Amazon Connect Participant Service API Reference.
        ///
        /// * For allowed event content types, see the ContentType parameter in the [SendEvent](https://docs.aws.amazon.com/connect-participant/latest/APIReference/API_SendEvent.html) topic in the Amazon Connect Participant Service API Reference.
        public var contentType: Swift.String?
        /// Type of chat integration event.
        /// This member is required.
        public var type: ConnectClientTypes.ChatEventType?

        public init(
            content: Swift.String? = nil,
            contentType: Swift.String? = nil,
            type: ConnectClientTypes.ChatEventType? = nil
        )
        {
            self.content = content
            self.contentType = contentType
            self.type = type
        }
    }

}

extension ConnectClientTypes {
    /// The customer's details.
    public struct ParticipantDetails {
        /// Display name of the participant.
        /// This member is required.
        public var displayName: Swift.String?

        public init(
            displayName: Swift.String? = nil
        )
        {
            self.displayName = displayName
        }
    }

}

extension ConnectClientTypes {
    /// The streaming configuration, such as the Amazon SNS streaming endpoint.
    public struct ChatStreamingConfiguration {
        /// The Amazon Resource Name (ARN) of the standard Amazon SNS topic. The Amazon Resource Name (ARN) of the streaming endpoint that is used to publish real-time message streaming for chat conversations.
        /// This member is required.
        public var streamingEndpointArn: Swift.String?

        public init(
            streamingEndpointArn: Swift.String? = nil
        )
        {
            self.streamingEndpointArn = streamingEndpointArn
        }
    }

}

extension ConnectClientTypes {
    /// Payload of chat properties to apply when starting a new contact.
    public struct NewSessionDetails {
        /// A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes. They can be accessed in flows just like any other contact attributes. There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys can include only alphanumeric, dash, and underscore characters.
        public var attributes: [Swift.String: Swift.String]?
        /// The customer's details.
        public var participantDetails: ConnectClientTypes.ParticipantDetails?
        /// The streaming configuration, such as the Amazon SNS streaming endpoint.
        public var streamingConfiguration: ConnectClientTypes.ChatStreamingConfiguration?
        /// The supported chat message content types. Supported types are text/plain, text/markdown, application/json, application/vnd.amazonaws.connect.message.interactive, and application/vnd.amazonaws.connect.message.interactive.response. Content types must always contain  text/plain. You can then put any other supported type in the list. For example, all the following lists are valid because they contain text/plain: [text/plain, text/markdown, application/json],  [text/markdown, text/plain], [text/plain, application/json, application/vnd.amazonaws.connect.message.interactive.response].
        public var supportedMessagingContentTypes: [Swift.String]?

        public init(
            attributes: [Swift.String: Swift.String]? = nil,
            participantDetails: ConnectClientTypes.ParticipantDetails? = nil,
            streamingConfiguration: ConnectClientTypes.ChatStreamingConfiguration? = nil,
            supportedMessagingContentTypes: [Swift.String]? = nil
        )
        {
            self.attributes = attributes
            self.participantDetails = participantDetails
            self.streamingConfiguration = streamingConfiguration
            self.supportedMessagingContentTypes = supportedMessagingContentTypes
        }
    }

}

public struct SendChatIntegrationEventInput {
    /// Chat system identifier, used in part to uniquely identify chat. This is associated with the Amazon Connect instance and flow to be used to start chats. For SMS, this is the phone number destination of inbound SMS messages represented by an Amazon Pinpoint phone number ARN.
    /// This member is required.
    public var destinationId: Swift.String?
    /// Chat integration event payload
    /// This member is required.
    public var event: ConnectClientTypes.ChatEvent?
    /// Contact properties to apply when starting a new chat. If the integration event is handled with an existing chat, this is ignored.
    public var newSessionDetails: ConnectClientTypes.NewSessionDetails?
    /// External identifier of chat customer participant, used in part to uniquely identify a chat. For SMS, this is the E164 phone number of the chat customer participant.
    /// This member is required.
    public var sourceId: Swift.String?
    /// Classification of a channel. This is used in part to uniquely identify chat. Valid value: ["connect:sms"]
    public var subtype: Swift.String?

    public init(
        destinationId: Swift.String? = nil,
        event: ConnectClientTypes.ChatEvent? = nil,
        newSessionDetails: ConnectClientTypes.NewSessionDetails? = nil,
        sourceId: Swift.String? = nil,
        subtype: Swift.String? = nil
    )
    {
        self.destinationId = destinationId
        self.event = event
        self.newSessionDetails = newSessionDetails
        self.sourceId = sourceId
        self.subtype = subtype
    }
}

public struct SendChatIntegrationEventOutput {
    /// Identifier of chat contact used to handle integration event. This may be null if the integration event is not valid without an already existing chat contact.
    public var initialContactId: Swift.String?
    /// Whether handling the integration event resulted in creating a new chat or acting on existing chat.
    public var newChatCreated: Swift.Bool?

    public init(
        initialContactId: Swift.String? = nil,
        newChatCreated: Swift.Bool? = nil
    )
    {
        self.initialContactId = initialContactId
        self.newChatCreated = newChatCreated
    }
}

public struct StartAttachedFileUploadInput {
    /// The resource to which the attached file is (being) uploaded to. [Cases](https://docs.aws.amazon.com/connect/latest/APIReference/API_connect-cases_CreateCase.html) are the only current supported resource. This value must be a valid ARN.
    /// This member is required.
    public var associatedResourceArn: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// Represents the identity that created the file.
    public var createdBy: ConnectClientTypes.CreatedByInfo?
    /// A case-sensitive name of the attached file being uploaded.
    /// This member is required.
    public var fileName: Swift.String?
    /// The size of the attached file in bytes.
    /// This member is required.
    public var fileSizeInBytes: Swift.Int?
    /// The use case for the file.
    /// This member is required.
    public var fileUseCaseType: ConnectClientTypes.FileUseCaseType?
    /// The unique identifier of the Amazon Connect instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String: Swift.String]?
    /// Optional override for the expiry of the pre-signed S3 URL in seconds. The default value is 300.
    public var urlExpiryInSeconds: Swift.Int?

    public init(
        associatedResourceArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        createdBy: ConnectClientTypes.CreatedByInfo? = nil,
        fileName: Swift.String? = nil,
        fileSizeInBytes: Swift.Int? = nil,
        fileUseCaseType: ConnectClientTypes.FileUseCaseType? = nil,
        instanceId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        urlExpiryInSeconds: Swift.Int? = nil
    )
    {
        self.associatedResourceArn = associatedResourceArn
        self.clientToken = clientToken
        self.createdBy = createdBy
        self.fileName = fileName
        self.fileSizeInBytes = fileSizeInBytes
        self.fileUseCaseType = fileUseCaseType
        self.instanceId = instanceId
        self.tags = tags
        self.urlExpiryInSeconds = urlExpiryInSeconds
    }
}

extension ConnectClientTypes {
    /// Fields required when uploading an attached file.
    public struct UploadUrlMetadata {
        /// A map of headers that should be provided when uploading the attached file.
        public var headersToInclude: [Swift.String: Swift.String]?
        /// A pre-signed S3 URL that should be used for uploading the attached file.
        public var url: Swift.String?
        /// The expiration time of the URL in ISO timestamp. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
        public var urlExpiry: Swift.String?

        public init(
            headersToInclude: [Swift.String: Swift.String]? = nil,
            url: Swift.String? = nil,
            urlExpiry: Swift.String? = nil
        )
        {
            self.headersToInclude = headersToInclude
            self.url = url
            self.urlExpiry = urlExpiry
        }
    }

}

/// Response from StartAttachedFileUpload API.
public struct StartAttachedFileUploadOutput {
    /// Represents the identity that created the file.
    public var createdBy: ConnectClientTypes.CreatedByInfo?
    /// The time of Creation of the file resource as an ISO timestamp. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2024-05-03T02:41:28.172Z.
    public var creationTime: Swift.String?
    /// The unique identifier of the attached file resource (ARN).
    public var fileArn: Swift.String?
    /// The unique identifier of the attached file resource.
    public var fileId: Swift.String?
    /// The current status of the attached file.
    public var fileStatus: ConnectClientTypes.FileStatusType?
    /// Information to be used while uploading the attached file.
    public var uploadUrlMetadata: ConnectClientTypes.UploadUrlMetadata?

    public init(
        createdBy: ConnectClientTypes.CreatedByInfo? = nil,
        creationTime: Swift.String? = nil,
        fileArn: Swift.String? = nil,
        fileId: Swift.String? = nil,
        fileStatus: ConnectClientTypes.FileStatusType? = nil,
        uploadUrlMetadata: ConnectClientTypes.UploadUrlMetadata? = nil
    )
    {
        self.createdBy = createdBy
        self.creationTime = creationTime
        self.fileArn = fileArn
        self.fileId = fileId
        self.fileStatus = fileStatus
        self.uploadUrlMetadata = uploadUrlMetadata
    }
}

extension ConnectClientTypes {
    /// A chat message.
    public struct ChatMessage {
        /// The content of the chat message.
        ///
        /// * For text/plain and text/markdown, the Length Constraints are Minimum of 1, Maximum of 1024.
        ///
        /// * For application/json, the Length Constraints are Minimum of 1, Maximum of 12000.
        ///
        /// * For application/vnd.amazonaws.connect.message.interactive.response, the Length Constraints are Minimum of 1, Maximum of 12288.
        /// This member is required.
        public var content: Swift.String?
        /// The type of the content. Supported types are text/plain, text/markdown, application/json, and application/vnd.amazonaws.connect.message.interactive.response.
        /// This member is required.
        public var contentType: Swift.String?

        public init(
            content: Swift.String? = nil,
            contentType: Swift.String? = nil
        )
        {
            self.content = content
            self.contentType = contentType
        }
    }

}

extension ConnectClientTypes {
    /// Enable persistent chats. For more information about enabling persistent chat, and for example use cases and how to configure for them, see [Enable persistent chat](https://docs.aws.amazon.com/connect/latest/adminguide/chat-persistence.html).
    public struct PersistentChat {
        /// The contactId that is used for rehydration depends on the rehydration type. RehydrationType is required for persistent chat.
        ///
        /// * ENTIRE_PAST_SESSION: Rehydrates a chat from the most recently terminated past chat contact of the specified past ended chat session. To use this type, provide the initialContactId of the past ended chat session in the sourceContactId field. In this type, Amazon Connect determines the most recent chat contact on the specified chat session that has ended, and uses it to start a persistent chat.
        ///
        /// * FROM_SEGMENT: Rehydrates a chat from the past chat contact that is specified in the sourceContactId field.
        ///
        ///
        /// The actual contactId used for rehydration is provided in the response of this API.
        public var rehydrationType: ConnectClientTypes.RehydrationType?
        /// The contactId from which a persistent chat session must be started.
        public var sourceContactId: Swift.String?

        public init(
            rehydrationType: ConnectClientTypes.RehydrationType? = nil,
            sourceContactId: Swift.String? = nil
        )
        {
            self.rehydrationType = rehydrationType
            self.sourceContactId = sourceContactId
        }
    }

}

public struct StartChatContactInput {
    /// A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes. They can be accessed in flows just like any other contact attributes. There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys can include only alphanumeric, dash, and underscore characters.
    public var attributes: [Swift.String: Swift.String]?
    /// The total duration of the newly started chat session. If not specified, the chat session duration defaults to 25 hour. The minimum configurable time is 60 minutes. The maximum configurable time is 10,080 minutes (7 days).
    public var chatDurationInMinutes: Swift.Int?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The identifier of the flow for initiating the chat. To see the ContactFlowId in the Amazon Connect admin website, on the navigation menu go to Routing, Contact Flows. Choose the flow. On the flow page, under the name of the flow, choose Show additional flow information. The ContactFlowId is the last part of the ARN, shown here in bold: arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/846ec553-a005-41c0-8341-xxxxxxxxxxxx
    /// This member is required.
    public var contactFlowId: Swift.String?
    /// The initial message to be sent to the newly created chat. If you have a Lex bot in your flow, the initial message is not delivered to the Lex bot.
    public var initialMessage: ConnectClientTypes.ChatMessage?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Information identifying the participant.
    /// This member is required.
    public var participantDetails: ConnectClientTypes.ParticipantDetails?
    /// Enable persistent chats. For more information about enabling persistent chat, and for example use cases and how to configure for them, see [Enable persistent chat](https://docs.aws.amazon.com/connect/latest/adminguide/chat-persistence.html).
    public var persistentChat: ConnectClientTypes.PersistentChat?
    /// The unique identifier for an Amazon Connect contact. This identifier is related to the chat starting. You cannot provide data for both RelatedContactId and PersistentChat.
    public var relatedContactId: Swift.String?
    /// A set of system defined key-value pairs stored on individual contact segments using an attribute map. The attributes are standard Amazon Connect attributes. They can be accessed in flows. Attribute keys can include only alphanumeric, -, and _. This field can be used to show channel subtype, such as connect:Guide. The types application/vnd.amazonaws.connect.message.interactive and application/vnd.amazonaws.connect.message.interactive.response must be present in the SupportedMessagingContentTypes field of this API in order to set SegmentAttributes as { "connect:Subtype": {"valueString" : "connect:Guide" }}.
    public var segmentAttributes: [Swift.String: ConnectClientTypes.SegmentAttributeValue]?
    /// The supported chat message content types. Supported types are text/plain, text/markdown, application/json, application/vnd.amazonaws.connect.message.interactive, and application/vnd.amazonaws.connect.message.interactive.response. Content types must always contain text/plain. You can then put any other supported type in the list. For example, all the following lists are valid because they contain text/plain: [text/plain, text/markdown, application/json], [text/markdown, text/plain], [text/plain, application/json, application/vnd.amazonaws.connect.message.interactive.response]. The type application/vnd.amazonaws.connect.message.interactive is required to use the [Show view](https://docs.aws.amazon.com/connect/latest/adminguide/show-view-block.html) flow block.
    public var supportedMessagingContentTypes: [Swift.String]?

    public init(
        attributes: [Swift.String: Swift.String]? = nil,
        chatDurationInMinutes: Swift.Int? = nil,
        clientToken: Swift.String? = nil,
        contactFlowId: Swift.String? = nil,
        initialMessage: ConnectClientTypes.ChatMessage? = nil,
        instanceId: Swift.String? = nil,
        participantDetails: ConnectClientTypes.ParticipantDetails? = nil,
        persistentChat: ConnectClientTypes.PersistentChat? = nil,
        relatedContactId: Swift.String? = nil,
        segmentAttributes: [Swift.String: ConnectClientTypes.SegmentAttributeValue]? = nil,
        supportedMessagingContentTypes: [Swift.String]? = nil
    )
    {
        self.attributes = attributes
        self.chatDurationInMinutes = chatDurationInMinutes
        self.clientToken = clientToken
        self.contactFlowId = contactFlowId
        self.initialMessage = initialMessage
        self.instanceId = instanceId
        self.participantDetails = participantDetails
        self.persistentChat = persistentChat
        self.relatedContactId = relatedContactId
        self.segmentAttributes = segmentAttributes
        self.supportedMessagingContentTypes = supportedMessagingContentTypes
    }
}

public struct StartChatContactOutput {
    /// The identifier of this contact within the Amazon Connect instance.
    public var contactId: Swift.String?
    /// The contactId from which a persistent chat session is started. This field is populated only for persistent chats.
    public var continuedFromContactId: Swift.String?
    /// The identifier for a chat participant. The participantId for a chat participant is the same throughout the chat lifecycle.
    public var participantId: Swift.String?
    /// The token used by the chat participant to call [CreateParticipantConnection](https://docs.aws.amazon.com/connect-participant/latest/APIReference/API_CreateParticipantConnection.html). The participant token is valid for the lifetime of a chat participant.
    public var participantToken: Swift.String?

    public init(
        contactId: Swift.String? = nil,
        continuedFromContactId: Swift.String? = nil,
        participantId: Swift.String? = nil,
        participantToken: Swift.String? = nil
    )
    {
        self.contactId = contactId
        self.continuedFromContactId = continuedFromContactId
        self.participantId = participantId
        self.participantToken = participantToken
    }
}

public struct StartContactEvaluationInput {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The identifier of the contact in this instance of Amazon Connect.
    /// This member is required.
    public var contactId: Swift.String?
    /// The unique identifier for the evaluation form.
    /// This member is required.
    public var evaluationFormId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        contactId: Swift.String? = nil,
        evaluationFormId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.contactId = contactId
        self.evaluationFormId = evaluationFormId
        self.instanceId = instanceId
    }
}

public struct StartContactEvaluationOutput {
    /// The Amazon Resource Name (ARN) for the contact evaluation resource.
    /// This member is required.
    public var evaluationArn: Swift.String?
    /// A unique identifier for the contact evaluation.
    /// This member is required.
    public var evaluationId: Swift.String?

    public init(
        evaluationArn: Swift.String? = nil,
        evaluationId: Swift.String? = nil
    )
    {
        self.evaluationArn = evaluationArn
        self.evaluationId = evaluationId
    }
}

extension ConnectClientTypes {

    public enum VoiceRecordingTrack: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case fromAgent
        case toAgent
        case sdkUnknown(Swift.String)

        public static var allCases: [VoiceRecordingTrack] {
            return [
                .all,
                .fromAgent,
                .toAgent
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .fromAgent: return "FROM_AGENT"
            case .toAgent: return "TO_AGENT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// Contains information about the recording configuration settings.
    public struct VoiceRecordingConfiguration {
        /// Identifies which track is being recorded.
        public var voiceRecordingTrack: ConnectClientTypes.VoiceRecordingTrack?

        public init(
            voiceRecordingTrack: ConnectClientTypes.VoiceRecordingTrack? = nil
        )
        {
            self.voiceRecordingTrack = voiceRecordingTrack
        }
    }

}

public struct StartContactRecordingInput {
    /// The identifier of the contact.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.
    /// This member is required.
    public var initialContactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The person being recorded.
    /// This member is required.
    public var voiceRecordingConfiguration: ConnectClientTypes.VoiceRecordingConfiguration?

    public init(
        contactId: Swift.String? = nil,
        initialContactId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        voiceRecordingConfiguration: ConnectClientTypes.VoiceRecordingConfiguration? = nil
    )
    {
        self.contactId = contactId
        self.initialContactId = initialContactId
        self.instanceId = instanceId
        self.voiceRecordingConfiguration = voiceRecordingConfiguration
    }
}

public struct StartContactRecordingOutput {

    public init() { }
}

public struct StartContactStreamingInput {
    /// The streaming configuration, such as the Amazon SNS streaming endpoint.
    /// This member is required.
    public var chatStreamingConfiguration: ConnectClientTypes.ChatStreamingConfiguration?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    /// This member is required.
    public var clientToken: Swift.String?
    /// The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        chatStreamingConfiguration: ConnectClientTypes.ChatStreamingConfiguration? = nil,
        clientToken: Swift.String? = nil,
        contactId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.chatStreamingConfiguration = chatStreamingConfiguration
        self.clientToken = clientToken
        self.contactId = contactId
        self.instanceId = instanceId
    }
}

public struct StartContactStreamingOutput {
    /// The identifier of the streaming configuration enabled.
    /// This member is required.
    public var streamingId: Swift.String?

    public init(
        streamingId: Swift.String? = nil
    )
    {
        self.streamingId = streamingId
    }
}

/// Outbound calls to the destination number are not allowed.
public struct DestinationNotAllowedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message about the outbound calls.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DestinationNotAllowedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The contact is not permitted.
public struct OutboundContactNotPermittedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message about the contact.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OutboundContactNotPermittedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ConnectClientTypes {
    /// Configuration of the answering machine detection.
    public struct AnswerMachineDetectionConfig {
        /// Wait for the answering machine prompt.
        public var awaitAnswerMachinePrompt: Swift.Bool
        /// The flag to indicate if answer machine detection analysis needs to be performed for a voice call. If set to true, TrafficType must be set as CAMPAIGN.
        public var enableAnswerMachineDetection: Swift.Bool

        public init(
            awaitAnswerMachinePrompt: Swift.Bool = false,
            enableAnswerMachineDetection: Swift.Bool = false
        )
        {
            self.awaitAnswerMachinePrompt = awaitAnswerMachinePrompt
            self.enableAnswerMachineDetection = enableAnswerMachineDetection
        }
    }

}

extension ConnectClientTypes {

    public enum TrafficType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case campaign
        case general
        case sdkUnknown(Swift.String)

        public static var allCases: [TrafficType] {
            return [
                .campaign,
                .general
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .campaign: return "CAMPAIGN"
            case .general: return "GENERAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct StartOutboundVoiceContactInput {
    /// Configuration of the answering machine detection for this outbound call.
    public var answerMachineDetectionConfig: ConnectClientTypes.AnswerMachineDetectionConfig?
    /// A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes, and can be accessed in flows just like any other contact attributes. There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys can include only alphanumeric, dash, and underscore characters.
    public var attributes: [Swift.String: Swift.String]?
    /// The campaign identifier of the outbound communication.
    public var campaignId: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/). The token is valid for 7 days after creation. If a contact is already started, the contact ID is returned.
    public var clientToken: Swift.String?
    /// The identifier of the flow for the outbound call. To see the ContactFlowId in the Amazon Connect admin website, on the navigation menu go to Routing, Contact Flows. Choose the flow. On the flow page, under the name of the flow, choose Show additional flow information. The ContactFlowId is the last part of the ARN, shown here in bold: arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/846ec553-a005-41c0-8341-xxxxxxxxxxxx
    /// This member is required.
    public var contactFlowId: Swift.String?
    /// A description of the voice contact that is shown to an agent in the Contact Control Panel (CCP).
    public var description: Swift.String?
    /// The phone number of the customer, in E.164 format.
    /// This member is required.
    public var destinationPhoneNumber: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of a voice contact that is shown to an agent in the Contact Control Panel (CCP).
    public var name: Swift.String?
    /// The queue for the call. If you specify a queue, the phone displayed for caller ID is the phone number specified in the queue. If you do not specify a queue, the queue defined in the flow is used. If you do not specify a queue, you must specify a source phone number.
    public var queueId: Swift.String?
    /// A formatted URL that is shown to an agent in the Contact Control Panel (CCP). Contacts can have the following reference types at the time of creation: URL | NUMBER | STRING | DATE | EMAIL. ATTACHMENT is not a supported reference type during voice contact creation.
    public var references: [Swift.String: ConnectClientTypes.Reference]?
    /// The contactId that is related to this contact. Linking voice, task, or chat by using RelatedContactID copies over contact attributes from the related contact to the new contact. All updates to user-defined attributes in the new contact are limited to the individual contact ID. There are no limits to the number of contacts that can be linked by using RelatedContactId.
    public var relatedContactId: Swift.String?
    /// The phone number associated with the Amazon Connect instance, in E.164 format. If you do not specify a source phone number, you must specify a queue.
    public var sourcePhoneNumber: Swift.String?
    /// Denotes the class of traffic. Calls with different traffic types are handled differently by Amazon Connect. The default value is GENERAL. Use CAMPAIGN if EnableAnswerMachineDetection is set to true. For all other cases, use GENERAL.
    public var trafficType: ConnectClientTypes.TrafficType?

    public init(
        answerMachineDetectionConfig: ConnectClientTypes.AnswerMachineDetectionConfig? = nil,
        attributes: [Swift.String: Swift.String]? = nil,
        campaignId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        contactFlowId: Swift.String? = nil,
        description: Swift.String? = nil,
        destinationPhoneNumber: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        queueId: Swift.String? = nil,
        references: [Swift.String: ConnectClientTypes.Reference]? = nil,
        relatedContactId: Swift.String? = nil,
        sourcePhoneNumber: Swift.String? = nil,
        trafficType: ConnectClientTypes.TrafficType? = nil
    )
    {
        self.answerMachineDetectionConfig = answerMachineDetectionConfig
        self.attributes = attributes
        self.campaignId = campaignId
        self.clientToken = clientToken
        self.contactFlowId = contactFlowId
        self.description = description
        self.destinationPhoneNumber = destinationPhoneNumber
        self.instanceId = instanceId
        self.name = name
        self.queueId = queueId
        self.references = references
        self.relatedContactId = relatedContactId
        self.sourcePhoneNumber = sourcePhoneNumber
        self.trafficType = trafficType
    }
}

extension StartOutboundVoiceContactInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartOutboundVoiceContactInput(answerMachineDetectionConfig: \(Swift.String(describing: answerMachineDetectionConfig)), attributes: \(Swift.String(describing: attributes)), campaignId: \(Swift.String(describing: campaignId)), clientToken: \(Swift.String(describing: clientToken)), contactFlowId: \(Swift.String(describing: contactFlowId)), destinationPhoneNumber: \(Swift.String(describing: destinationPhoneNumber)), instanceId: \(Swift.String(describing: instanceId)), queueId: \(Swift.String(describing: queueId)), references: \(Swift.String(describing: references)), relatedContactId: \(Swift.String(describing: relatedContactId)), sourcePhoneNumber: \(Swift.String(describing: sourcePhoneNumber)), trafficType: \(Swift.String(describing: trafficType)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct StartOutboundVoiceContactOutput {
    /// The identifier of this contact within the Amazon Connect instance.
    public var contactId: Swift.String?

    public init(
        contactId: Swift.String? = nil
    )
    {
        self.contactId = contactId
    }
}

public struct StartTaskContactInput {
    /// A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes, and can be accessed in flows just like any other contact attributes. There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys can include only alphanumeric, dash, and underscore characters.
    public var attributes: [Swift.String: Swift.String]?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The identifier of the flow for initiating the tasks. To see the ContactFlowId in the Amazon Connect admin website, on the navigation menu go to Routing, Contact Flows. Choose the flow. On the flow page, under the name of the flow, choose Show additional flow information. The ContactFlowId is the last part of the ARN, shown here in bold: arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/846ec553-a005-41c0-8341-xxxxxxxxxxxx
    public var contactFlowId: Swift.String?
    /// A description of the task that is shown to an agent in the Contact Control Panel (CCP).
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of a task that is shown to an agent in the Contact Control Panel (CCP).
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the previous chat, voice, or task contact. Any updates to user-defined attributes to task contacts linked using the same PreviousContactID will affect every contact in the chain. There can be a maximum of 12 linked task contacts in a chain.
    public var previousContactId: Swift.String?
    /// The identifier for the quick connect. Tasks that are created by using QuickConnectId will use the flow that is defined on agent or queue quick connect. For more information about quick connects, see [Create quick connects](https://docs.aws.amazon.com/connect/latest/adminguide/quick-connects.html).
    public var quickConnectId: Swift.String?
    /// A formatted URL that is shown to an agent in the Contact Control Panel (CCP). Tasks can have the following reference types at the time of creation: URL | NUMBER | STRING | DATE | EMAIL. ATTACHMENT is not a supported reference type during task creation.
    public var references: [Swift.String: ConnectClientTypes.Reference]?
    /// The contactId that is [related](https://docs.aws.amazon.com/connect/latest/adminguide/tasks.html#linked-tasks) to this contact. Linking tasks together by using RelatedContactID copies over contact attributes from the related task contact to the new task contact. All updates to user-defined attributes in the new task contact are limited to the individual contact ID, unlike what happens when tasks are linked by using PreviousContactID. There are no limits to the number of contacts that can be linked by using RelatedContactId.
    public var relatedContactId: Swift.String?
    /// The timestamp, in Unix Epoch seconds format, at which to start running the inbound flow. The scheduled time cannot be in the past. It must be within up to 6 days in future.
    public var scheduledTime: Foundation.Date?
    /// A unique identifier for the task template. For more information about task templates, see [Create task templates](https://docs.aws.amazon.com/connect/latest/adminguide/task-templates.html) in the Amazon Connect Administrator Guide.
    public var taskTemplateId: Swift.String?

    public init(
        attributes: [Swift.String: Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        contactFlowId: Swift.String? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        previousContactId: Swift.String? = nil,
        quickConnectId: Swift.String? = nil,
        references: [Swift.String: ConnectClientTypes.Reference]? = nil,
        relatedContactId: Swift.String? = nil,
        scheduledTime: Foundation.Date? = nil,
        taskTemplateId: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.clientToken = clientToken
        self.contactFlowId = contactFlowId
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.previousContactId = previousContactId
        self.quickConnectId = quickConnectId
        self.references = references
        self.relatedContactId = relatedContactId
        self.scheduledTime = scheduledTime
        self.taskTemplateId = taskTemplateId
    }
}

extension StartTaskContactInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartTaskContactInput(attributes: \(Swift.String(describing: attributes)), clientToken: \(Swift.String(describing: clientToken)), contactFlowId: \(Swift.String(describing: contactFlowId)), instanceId: \(Swift.String(describing: instanceId)), previousContactId: \(Swift.String(describing: previousContactId)), quickConnectId: \(Swift.String(describing: quickConnectId)), references: \(Swift.String(describing: references)), relatedContactId: \(Swift.String(describing: relatedContactId)), scheduledTime: \(Swift.String(describing: scheduledTime)), taskTemplateId: \(Swift.String(describing: taskTemplateId)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct StartTaskContactOutput {
    /// The identifier of this contact within the Amazon Connect instance.
    public var contactId: Swift.String?

    public init(
        contactId: Swift.String? = nil
    )
    {
        self.contactId = contactId
    }
}

public struct StartWebRTCContactInput {
    /// Information about the video sharing capabilities of the participants (customer, agent).
    public var allowedCapabilities: ConnectClientTypes.AllowedCapabilities?
    /// A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes, and can be accessed in flows just like any other contact attributes. There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys can include only alphanumeric, -, and _ characters.
    public var attributes: [Swift.String: Swift.String]?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/). The token is valid for 7 days after creation. If a contact is already started, the contact ID is returned.
    public var clientToken: Swift.String?
    /// The identifier of the flow for the call. To see the ContactFlowId in the Amazon Connect admin website, on the navigation menu go to Routing, Flows. Choose the flow. On the flow page, under the name of the flow, choose Show additional flow information. The ContactFlowId is the last part of the ARN, shown here in bold: arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/846ec553-a005-41c0-8341-xxxxxxxxxxxx
    /// This member is required.
    public var contactFlowId: Swift.String?
    /// A description of the task that is shown to an agent in the Contact Control Panel (CCP).
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The customer's details.
    /// This member is required.
    public var participantDetails: ConnectClientTypes.ParticipantDetails?
    /// A formatted URL that is shown to an agent in the Contact Control Panel (CCP). Tasks can have the following reference types at the time of creation: URL | NUMBER | STRING | DATE | EMAIL. ATTACHMENT is not a supported reference type during task creation.
    public var references: [Swift.String: ConnectClientTypes.Reference]?
    /// The unique identifier for an Amazon Connect contact. This identifier is related to the contact starting.
    public var relatedContactId: Swift.String?

    public init(
        allowedCapabilities: ConnectClientTypes.AllowedCapabilities? = nil,
        attributes: [Swift.String: Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        contactFlowId: Swift.String? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        participantDetails: ConnectClientTypes.ParticipantDetails? = nil,
        references: [Swift.String: ConnectClientTypes.Reference]? = nil,
        relatedContactId: Swift.String? = nil
    )
    {
        self.allowedCapabilities = allowedCapabilities
        self.attributes = attributes
        self.clientToken = clientToken
        self.contactFlowId = contactFlowId
        self.description = description
        self.instanceId = instanceId
        self.participantDetails = participantDetails
        self.references = references
        self.relatedContactId = relatedContactId
    }
}

extension StartWebRTCContactInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartWebRTCContactInput(allowedCapabilities: \(Swift.String(describing: allowedCapabilities)), attributes: \(Swift.String(describing: attributes)), clientToken: \(Swift.String(describing: clientToken)), contactFlowId: \(Swift.String(describing: contactFlowId)), instanceId: \(Swift.String(describing: instanceId)), participantDetails: \(Swift.String(describing: participantDetails)), references: \(Swift.String(describing: references)), relatedContactId: \(Swift.String(describing: relatedContactId)), description: \"CONTENT_REDACTED\")"}
}

extension ConnectClientTypes {
    /// The attendee information, including attendee ID and join token.
    public struct Attendee {
        /// The Amazon Chime SDK attendee ID.
        public var attendeeId: Swift.String?
        /// The join token used by the Amazon Chime SDK attendee.
        public var joinToken: Swift.String?

        public init(
            attendeeId: Swift.String? = nil,
            joinToken: Swift.String? = nil
        )
        {
            self.attendeeId = attendeeId
            self.joinToken = joinToken
        }
    }

}

extension ConnectClientTypes.Attendee: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Attendee(attendeeId: \(Swift.String(describing: attendeeId)), joinToken: \"CONTENT_REDACTED\")"}
}

extension ConnectClientTypes {
    /// A set of endpoints used by clients to connect to the media service group for an Amazon Chime SDK meeting.
    public struct MediaPlacement {
        /// The audio fallback URL.
        public var audioFallbackUrl: Swift.String?
        /// The audio host URL.
        public var audioHostUrl: Swift.String?
        /// The event ingestion URL to which you send client meeting events.
        public var eventIngestionUrl: Swift.String?
        /// The signaling URL.
        public var signalingUrl: Swift.String?
        /// The turn control URL.
        public var turnControlUrl: Swift.String?

        public init(
            audioFallbackUrl: Swift.String? = nil,
            audioHostUrl: Swift.String? = nil,
            eventIngestionUrl: Swift.String? = nil,
            signalingUrl: Swift.String? = nil,
            turnControlUrl: Swift.String? = nil
        )
        {
            self.audioFallbackUrl = audioFallbackUrl
            self.audioHostUrl = audioHostUrl
            self.eventIngestionUrl = eventIngestionUrl
            self.signalingUrl = signalingUrl
            self.turnControlUrl = turnControlUrl
        }
    }

}

extension ConnectClientTypes {

    public enum MeetingFeatureStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case unavailable
        case sdkUnknown(Swift.String)

        public static var allCases: [MeetingFeatureStatus] {
            return [
                .available,
                .unavailable
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .unavailable: return "UNAVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// Has audio-specific configurations as the operating parameter for Echo Reduction.
    public struct AudioFeatures {
        /// Makes echo reduction available to clients who connect to the meeting.
        public var echoReduction: ConnectClientTypes.MeetingFeatureStatus?

        public init(
            echoReduction: ConnectClientTypes.MeetingFeatureStatus? = nil
        )
        {
            self.echoReduction = echoReduction
        }
    }

}

extension ConnectClientTypes {
    /// The configuration settings of the features available to a meeting.
    public struct MeetingFeaturesConfiguration {
        /// The configuration settings for the audio features available to a meeting.
        public var audio: ConnectClientTypes.AudioFeatures?

        public init(
            audio: ConnectClientTypes.AudioFeatures? = nil
        )
        {
            self.audio = audio
        }
    }

}

extension ConnectClientTypes {
    /// A meeting created using the Amazon Chime SDK.
    public struct Meeting {
        /// The media placement for the meeting.
        public var mediaPlacement: ConnectClientTypes.MediaPlacement?
        /// The Amazon Web Services Region in which you create the meeting.
        public var mediaRegion: Swift.String?
        /// The configuration settings of the features available to a meeting.
        public var meetingFeatures: ConnectClientTypes.MeetingFeaturesConfiguration?
        /// The Amazon Chime SDK meeting ID.
        public var meetingId: Swift.String?

        public init(
            mediaPlacement: ConnectClientTypes.MediaPlacement? = nil,
            mediaRegion: Swift.String? = nil,
            meetingFeatures: ConnectClientTypes.MeetingFeaturesConfiguration? = nil,
            meetingId: Swift.String? = nil
        )
        {
            self.mediaPlacement = mediaPlacement
            self.mediaRegion = mediaRegion
            self.meetingFeatures = meetingFeatures
            self.meetingId = meetingId
        }
    }

}

extension ConnectClientTypes {
    /// Information required to join the call.
    public struct ConnectionData {
        /// The attendee information, including attendee ID and join token.
        public var attendee: ConnectClientTypes.Attendee?
        /// A meeting created using the Amazon Chime SDK.
        public var meeting: ConnectClientTypes.Meeting?

        public init(
            attendee: ConnectClientTypes.Attendee? = nil,
            meeting: ConnectClientTypes.Meeting? = nil
        )
        {
            self.attendee = attendee
            self.meeting = meeting
        }
    }

}

public struct StartWebRTCContactOutput {
    /// Information required for the client application (mobile application or website) to connect to the call.
    public var connectionData: ConnectClientTypes.ConnectionData?
    /// The identifier of the contact in this instance of Amazon Connect.
    public var contactId: Swift.String?
    /// The identifier for a contact participant. The ParticipantId for a contact participant is the same throughout the contact lifecycle.
    public var participantId: Swift.String?
    /// The token used by the contact participant to call the [CreateParticipantConnection](https://docs.aws.amazon.com/connect-participant/latest/APIReference/API_CreateParticipantConnection.html) API. The participant token is valid for the lifetime of a contact participant.
    public var participantToken: Swift.String?

    public init(
        connectionData: ConnectClientTypes.ConnectionData? = nil,
        contactId: Swift.String? = nil,
        participantId: Swift.String? = nil,
        participantToken: Swift.String? = nil
    )
    {
        self.connectionData = connectionData
        self.contactId = contactId
        self.participantId = participantId
        self.participantToken = participantToken
    }
}

/// The contact with the specified ID is not active or does not exist. Applies to Voice calls only, not to Chat or Task contacts.
public struct ContactNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ContactNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ConnectClientTypes {
    /// Contains details about why a contact was disconnected. Only Amazon Connect outbound campaigns can provide this field.
    public struct DisconnectReason {
        /// A code that indicates how the contact was terminated.
        public var code: Swift.String?

        public init(
            code: Swift.String? = nil
        )
        {
            self.code = code
        }
    }

}

public struct StopContactInput {
    /// The ID of the contact.
    /// This member is required.
    public var contactId: Swift.String?
    /// The reason a contact can be disconnected. Only Amazon Connect outbound campaigns can provide this field.
    public var disconnectReason: ConnectClientTypes.DisconnectReason?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        contactId: Swift.String? = nil,
        disconnectReason: ConnectClientTypes.DisconnectReason? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.contactId = contactId
        self.disconnectReason = disconnectReason
        self.instanceId = instanceId
    }
}

public struct StopContactOutput {

    public init() { }
}

public struct StopContactRecordingInput {
    /// The identifier of the contact.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.
    /// This member is required.
    public var initialContactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        contactId: Swift.String? = nil,
        initialContactId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.contactId = contactId
        self.initialContactId = initialContactId
        self.instanceId = instanceId
    }
}

public struct StopContactRecordingOutput {

    public init() { }
}

public struct StopContactStreamingInput {
    /// The identifier of the contact. This is the identifier of the contact that is associated with the first interaction with the contact center.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the streaming configuration enabled.
    /// This member is required.
    public var streamingId: Swift.String?

    public init(
        contactId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        streamingId: Swift.String? = nil
    )
    {
        self.contactId = contactId
        self.instanceId = instanceId
        self.streamingId = streamingId
    }
}

public struct StopContactStreamingOutput {

    public init() { }
}

extension ConnectClientTypes {
    /// Information about input answers for a contact evaluation.
    public struct EvaluationAnswerInput {
        /// The value for an answer in a contact evaluation.
        public var value: ConnectClientTypes.EvaluationAnswerData?

        public init(
            value: ConnectClientTypes.EvaluationAnswerData? = nil
        )
        {
            self.value = value
        }
    }

}

public struct SubmitContactEvaluationInput {
    /// A map of question identifiers to answer value.
    public var answers: [Swift.String: ConnectClientTypes.EvaluationAnswerInput]?
    /// A unique identifier for the contact evaluation.
    /// This member is required.
    public var evaluationId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A map of question identifiers to note value.
    public var notes: [Swift.String: ConnectClientTypes.EvaluationNote]?

    public init(
        answers: [Swift.String: ConnectClientTypes.EvaluationAnswerInput]? = nil,
        evaluationId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        notes: [Swift.String: ConnectClientTypes.EvaluationNote]? = nil
    )
    {
        self.answers = answers
        self.evaluationId = evaluationId
        self.instanceId = instanceId
        self.notes = notes
    }
}

public struct SubmitContactEvaluationOutput {
    /// The Amazon Resource Name (ARN) for the contact evaluation resource.
    /// This member is required.
    public var evaluationArn: Swift.String?
    /// A unique identifier for the contact evaluation.
    /// This member is required.
    public var evaluationId: Swift.String?

    public init(
        evaluationArn: Swift.String? = nil,
        evaluationId: Swift.String? = nil
    )
    {
        self.evaluationArn = evaluationArn
        self.evaluationId = evaluationId
    }
}

public struct SuspendContactRecordingInput {
    /// The identifier of the contact.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.
    /// This member is required.
    public var initialContactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        contactId: Swift.String? = nil,
        initialContactId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.contactId = contactId
        self.initialContactId = initialContactId
        self.instanceId = instanceId
    }
}

public struct SuspendContactRecordingOutput {

    public init() { }
}

public struct TagContactInput {
    /// The identifier of the contact in this instance of Amazon Connect.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The tags to be assigned to the contact resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }. Authorization is not supported by this tag.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        contactId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.contactId = contactId
        self.instanceId = instanceId
        self.tags = tags
    }
}

public struct TagContactOutput {

    public init() { }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TransferContactInput {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The identifier of the flow.
    /// This member is required.
    public var contactFlowId: Swift.String?
    /// The identifier of the contact in this instance of Amazon Connect.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the queue.
    public var queueId: Swift.String?
    /// The identifier for the user. This can be the ID or the ARN of the user.
    public var userId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        contactFlowId: Swift.String? = nil,
        contactId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        queueId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.contactFlowId = contactFlowId
        self.contactId = contactId
        self.instanceId = instanceId
        self.queueId = queueId
        self.userId = userId
    }
}

public struct TransferContactOutput {
    /// The Amazon Resource Name (ARN) of the contact.
    public var contactArn: Swift.String?
    /// The identifier of the contact in this instance of Amazon Connect.
    public var contactId: Swift.String?

    public init(
        contactArn: Swift.String? = nil,
        contactId: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
        self.contactId = contactId
    }
}

public struct UntagContactInput {
    /// The identifier of the contact in this instance of Amazon Connect.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A list of tag keys. Existing tags on the contact whose keys are members of this list will be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        contactId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.contactId = contactId
        self.instanceId = instanceId
        self.tagKeys = tagKeys
    }
}

public struct UntagContactOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UpdateAgentStatusInput {
    /// The identifier of the agent status.
    /// This member is required.
    public var agentStatusId: Swift.String?
    /// The description of the agent status.
    public var description: Swift.String?
    /// The display order of the agent status.
    public var displayOrder: Swift.Int?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the agent status.
    public var name: Swift.String?
    /// A number indicating the reset order of the agent status.
    public var resetOrderNumber: Swift.Bool?
    /// The state of the agent status.
    public var state: ConnectClientTypes.AgentStatusState?

    public init(
        agentStatusId: Swift.String? = nil,
        description: Swift.String? = nil,
        displayOrder: Swift.Int? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        resetOrderNumber: Swift.Bool? = false,
        state: ConnectClientTypes.AgentStatusState? = nil
    )
    {
        self.agentStatusId = agentStatusId
        self.description = description
        self.displayOrder = displayOrder
        self.instanceId = instanceId
        self.name = name
        self.resetOrderNumber = resetOrderNumber
        self.state = state
    }
}

public struct UpdateAuthenticationProfileInput {
    /// A list of IP address range strings that are allowed to access the instance. For more information on how to configure IP addresses, see[Configure session timeouts](https://docs.aws.amazon.com/connect/latest/adminguide/authentication-profiles.html#configure-session-timeouts) in the Amazon Connect Administrator Guide.
    public var allowedIps: [Swift.String]?
    /// A unique identifier for the authentication profile.
    /// This member is required.
    public var authenticationProfileId: Swift.String?
    /// A list of IP address range strings that are blocked from accessing the instance. For more information on how to configure IP addresses, For more information on how to configure IP addresses, see [Configure IP-based access control](https://docs.aws.amazon.com/connect/latest/adminguide/authentication-profiles.html#configure-ip-based-ac) in the Amazon Connect Administrator Guide.
    public var blockedIps: [Swift.String]?
    /// The description for the authentication profile.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name for the authentication profile.
    public var name: Swift.String?
    /// The short lived session duration configuration for users logged in to Amazon Connect, in minutes. This value determines the maximum possible time before an agent is authenticated. For more information, For more information on how to configure IP addresses, see [Configure session timeouts](https://docs.aws.amazon.com/connect/latest/adminguide/authentication-profiles.html#configure-session-timeouts) in the Amazon Connect Administrator Guide.
    public var periodicSessionDuration: Swift.Int?

    public init(
        allowedIps: [Swift.String]? = nil,
        authenticationProfileId: Swift.String? = nil,
        blockedIps: [Swift.String]? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        periodicSessionDuration: Swift.Int? = nil
    )
    {
        self.allowedIps = allowedIps
        self.authenticationProfileId = authenticationProfileId
        self.blockedIps = blockedIps
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.periodicSessionDuration = periodicSessionDuration
    }
}

public struct UpdateContactInput {
    /// The identifier of the contact. This is the identifier of the contact associated with the first interaction with your contact center.
    /// This member is required.
    public var contactId: Swift.String?
    /// The description of the contact.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the contact.
    public var name: Swift.String?
    /// Well-formed data on contact, shown to agents on Contact Control Panel (CCP).
    public var references: [Swift.String: ConnectClientTypes.Reference]?

    public init(
        contactId: Swift.String? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        references: [Swift.String: ConnectClientTypes.Reference]? = nil
    )
    {
        self.contactId = contactId
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.references = references
    }
}

extension UpdateContactInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateContactInput(contactId: \(Swift.String(describing: contactId)), instanceId: \(Swift.String(describing: instanceId)), references: \(Swift.String(describing: references)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct UpdateContactOutput {

    public init() { }
}

public struct UpdateContactAttributesInput {
    /// The Amazon Connect attributes. These attributes can be accessed in flows just like any other contact attributes. You can have up to 32,768 UTF-8 bytes across all attributes for a contact. Attribute keys can include only alphanumeric, dash, and underscore characters. When the attributes for a contact exceed 32 KB, the contact is routed down the Error branch of the flow. As a mitigation, consider the following options:
    ///
    /// * Remove unnecessary attributes by setting their values to empty.
    ///
    /// * If the attributes are only used in one flow and don't need to be referred to outside of that flow (for example, by a Lambda or another flow), then use flow attributes. This way you aren't needlessly persisting the 32 KB of information from one flow to another. For more information, see [Flow block: Set contact attributes](https://docs.aws.amazon.com/connect/latest/adminguide/set-contact-attributes.html) in the Amazon Connect Administrator Guide.
    /// This member is required.
    public var attributes: [Swift.String: Swift.String]?
    /// The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.
    /// This member is required.
    public var initialContactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        attributes: [Swift.String: Swift.String]? = nil,
        initialContactId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.initialContactId = initialContactId
        self.instanceId = instanceId
    }
}

public struct UpdateContactAttributesOutput {

    public init() { }
}

public struct UpdateContactEvaluationInput {
    /// A map of question identifiers to answer value.
    public var answers: [Swift.String: ConnectClientTypes.EvaluationAnswerInput]?
    /// A unique identifier for the contact evaluation.
    /// This member is required.
    public var evaluationId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A map of question identifiers to note value.
    public var notes: [Swift.String: ConnectClientTypes.EvaluationNote]?

    public init(
        answers: [Swift.String: ConnectClientTypes.EvaluationAnswerInput]? = nil,
        evaluationId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        notes: [Swift.String: ConnectClientTypes.EvaluationNote]? = nil
    )
    {
        self.answers = answers
        self.evaluationId = evaluationId
        self.instanceId = instanceId
        self.notes = notes
    }
}

public struct UpdateContactEvaluationOutput {
    /// The Amazon Resource Name (ARN) for the contact evaluation resource.
    /// This member is required.
    public var evaluationArn: Swift.String?
    /// A unique identifier for the contact evaluation.
    /// This member is required.
    public var evaluationId: Swift.String?

    public init(
        evaluationArn: Swift.String? = nil,
        evaluationId: Swift.String? = nil
    )
    {
        self.evaluationArn = evaluationArn
        self.evaluationId = evaluationId
    }
}

public struct UpdateContactFlowContentInput {
    /// The identifier of the flow.
    /// This member is required.
    public var contactFlowId: Swift.String?
    /// The JSON string that represents the content of the flow. For an example, see [Example flow in Amazon Connect Flow language](https://docs.aws.amazon.com/connect/latest/APIReference/flow-language-example.html). Length Constraints: Minimum length of 1. Maximum length of 256000.
    /// This member is required.
    public var content: Swift.String?
    /// The identifier of the Amazon Connect instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        contactFlowId: Swift.String? = nil,
        content: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.contactFlowId = contactFlowId
        self.content = content
        self.instanceId = instanceId
    }
}

public struct UpdateContactFlowContentOutput {

    public init() { }
}

public struct UpdateContactFlowMetadataInput {
    /// The identifier of the flow.
    /// This member is required.
    public var contactFlowId: Swift.String?
    /// The state of flow.
    public var contactFlowState: ConnectClientTypes.ContactFlowState?
    /// The description of the flow.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the flow.
    public var name: Swift.String?

    public init(
        contactFlowId: Swift.String? = nil,
        contactFlowState: ConnectClientTypes.ContactFlowState? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.contactFlowId = contactFlowId
        self.contactFlowState = contactFlowState
        self.description = description
        self.instanceId = instanceId
        self.name = name
    }
}

public struct UpdateContactFlowMetadataOutput {

    public init() { }
}

public struct UpdateContactFlowModuleContentInput {
    /// The identifier of the flow module.
    /// This member is required.
    public var contactFlowModuleId: Swift.String?
    /// The JSON string that represents the content of the flow. For an example, see [Example flow in Amazon Connect Flow language](https://docs.aws.amazon.com/connect/latest/APIReference/flow-language-example.html).
    /// This member is required.
    public var content: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        contactFlowModuleId: Swift.String? = nil,
        content: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.contactFlowModuleId = contactFlowModuleId
        self.content = content
        self.instanceId = instanceId
    }
}

public struct UpdateContactFlowModuleContentOutput {

    public init() { }
}

public struct UpdateContactFlowModuleMetadataInput {
    /// The identifier of the flow module.
    /// This member is required.
    public var contactFlowModuleId: Swift.String?
    /// The description of the flow module.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the flow module.
    public var name: Swift.String?
    /// The state of flow module.
    public var state: ConnectClientTypes.ContactFlowModuleState?

    public init(
        contactFlowModuleId: Swift.String? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        state: ConnectClientTypes.ContactFlowModuleState? = nil
    )
    {
        self.contactFlowModuleId = contactFlowModuleId
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.state = state
    }
}

public struct UpdateContactFlowModuleMetadataOutput {

    public init() { }
}

public struct UpdateContactFlowNameInput {
    /// The identifier of the flow.
    /// This member is required.
    public var contactFlowId: Swift.String?
    /// The description of the flow.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the flow.
    public var name: Swift.String?

    public init(
        contactFlowId: Swift.String? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.contactFlowId = contactFlowId
        self.description = description
        self.instanceId = instanceId
        self.name = name
    }
}

public struct UpdateContactFlowNameOutput {

    public init() { }
}

extension ConnectClientTypes {
    /// Specify whether this routing criteria step should apply for only a limited amount of time,  or if it should never expire.
    public struct RoutingCriteriaInputStepExpiry {
        /// The number of seconds that the contact will be routed only to agents matching this routing  step, if expiry was configured for this routing step.
        public var durationInSeconds: Swift.Int?

        public init(
            durationInSeconds: Swift.Int? = nil
        )
        {
            self.durationInSeconds = durationInSeconds
        }
    }

}

public struct UpdateContactRoutingDataOutput {

    public init() { }
}

public struct UpdateContactScheduleInput {
    /// The identifier of the contact.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The timestamp, in Unix Epoch seconds format, at which to start running the inbound flow. The scheduled time cannot be in the past. It must be within up to 6 days in future.
    /// This member is required.
    public var scheduledTime: Foundation.Date?

    public init(
        contactId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        scheduledTime: Foundation.Date? = nil
    )
    {
        self.contactId = contactId
        self.instanceId = instanceId
        self.scheduledTime = scheduledTime
    }
}

public struct UpdateContactScheduleOutput {

    public init() { }
}

public struct UpdateEvaluationFormOutput {
    /// The Amazon Resource Name (ARN) for the contact evaluation resource.
    /// This member is required.
    public var evaluationFormArn: Swift.String?
    /// The unique identifier for the evaluation form.
    /// This member is required.
    public var evaluationFormId: Swift.String?
    /// The version of the updated evaluation form resource.
    /// This member is required.
    public var evaluationFormVersion: Swift.Int

    public init(
        evaluationFormArn: Swift.String? = nil,
        evaluationFormId: Swift.String? = nil,
        evaluationFormVersion: Swift.Int = 0
    )
    {
        self.evaluationFormArn = evaluationFormArn
        self.evaluationFormId = evaluationFormId
        self.evaluationFormVersion = evaluationFormVersion
    }
}

public struct UpdateHoursOfOperationInput {
    /// Configuration information of the hours of operation.
    public var config: [ConnectClientTypes.HoursOfOperationConfig]?
    /// The description of the hours of operation.
    public var description: Swift.String?
    /// The identifier of the hours of operation.
    /// This member is required.
    public var hoursOfOperationId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the hours of operation.
    public var name: Swift.String?
    /// The time zone of the hours of operation.
    public var timeZone: Swift.String?

    public init(
        config: [ConnectClientTypes.HoursOfOperationConfig]? = nil,
        description: Swift.String? = nil,
        hoursOfOperationId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        timeZone: Swift.String? = nil
    )
    {
        self.config = config
        self.description = description
        self.hoursOfOperationId = hoursOfOperationId
        self.instanceId = instanceId
        self.name = name
        self.timeZone = timeZone
    }
}

public struct UpdateInstanceAttributeInput {
    /// The type of attribute. Only allowlisted customers can consume USE_CUSTOM_TTS_VOICES. To access this feature, contact Amazon Web Services Support for allowlisting.
    /// This member is required.
    public var attributeType: ConnectClientTypes.InstanceAttributeType?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The value for the attribute. Maximum character limit is 100.
    /// This member is required.
    public var value: Swift.String?

    public init(
        attributeType: ConnectClientTypes.InstanceAttributeType? = nil,
        instanceId: Swift.String? = nil,
        value: Swift.String? = nil
    )
    {
        self.attributeType = attributeType
        self.instanceId = instanceId
        self.value = value
    }
}

public struct UpdateInstanceStorageConfigInput {
    /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
    /// This member is required.
    public var associationId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A valid resource type.
    /// This member is required.
    public var resourceType: ConnectClientTypes.InstanceStorageResourceType?
    /// The storage configuration for the instance.
    /// This member is required.
    public var storageConfig: ConnectClientTypes.InstanceStorageConfig?

    public init(
        associationId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        resourceType: ConnectClientTypes.InstanceStorageResourceType? = nil,
        storageConfig: ConnectClientTypes.InstanceStorageConfig? = nil
    )
    {
        self.associationId = associationId
        self.instanceId = instanceId
        self.resourceType = resourceType
        self.storageConfig = storageConfig
    }
}

extension ConnectClientTypes {

    public enum TimerEligibleParticipantRoles: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case agent
        case customer
        case sdkUnknown(Swift.String)

        public static var allCases: [TimerEligibleParticipantRoles] {
            return [
                .agent,
                .customer
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .agent: return "AGENT"
            case .customer: return "CUSTOMER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {

    public enum ParticipantTimerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disconnectNoncustomer
        case idle
        case sdkUnknown(Swift.String)

        public static var allCases: [ParticipantTimerType] {
            return [
                .disconnectNoncustomer,
                .idle
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disconnectNoncustomer: return "DISCONNECT_NONCUSTOMER"
            case .idle: return "IDLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {

    public enum ParticipantTimerAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case unset
        case sdkUnknown(Swift.String)

        public static var allCases: [ParticipantTimerAction] {
            return [
                .unset
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .unset: return "Unset"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectClientTypes {
    /// The value of the timer. Either the timer action (Unset to delete the timer), or the duration of the timer in minutes. Only one value can be set. For more information about how chat timeouts work, see [Set up chat timeouts for human participants](https://docs.aws.amazon.com/connect/latest/adminguide/setup-chat-timeouts.html).
    public enum ParticipantTimerValue {
        /// The timer action. Currently only one value is allowed: Unset. It deletes a timer.
        case participanttimeraction(ConnectClientTypes.ParticipantTimerAction)
        /// The duration of a timer, in minutes.
        case participanttimerdurationinminutes(Swift.Int)
        case sdkUnknown(Swift.String)
    }

}

extension ConnectClientTypes {
    /// Configuration information for the timer. After the timer configuration is set, it persists for the duration of the chat. It persists across new contacts in the chain, for example, transfer contacts. For more information about how chat timeouts work, see [Set up chat timeouts for human participants](https://docs.aws.amazon.com/connect/latest/adminguide/setup-chat-timeouts.html).
    public struct ParticipantTimerConfiguration {
        /// The role of the participant in the chat conversation.
        /// This member is required.
        public var participantRole: ConnectClientTypes.TimerEligibleParticipantRoles?
        /// The type of timer. IDLE indicates the timer applies for considering a human chat participant as idle. DISCONNECT_NONCUSTOMER indicates the timer applies to automatically disconnecting a chat participant due to idleness.
        /// This member is required.
        public var timerType: ConnectClientTypes.ParticipantTimerType?
        /// The value of the timer. Either the timer action (Unset to delete the timer), or the duration of the timer in minutes. Only one value can be set.
        /// This member is required.
        public var timerValue: ConnectClientTypes.ParticipantTimerValue?

        public init(
            participantRole: ConnectClientTypes.TimerEligibleParticipantRoles? = nil,
            timerType: ConnectClientTypes.ParticipantTimerType? = nil,
            timerValue: ConnectClientTypes.ParticipantTimerValue? = nil
        )
        {
            self.participantRole = participantRole
            self.timerType = timerType
            self.timerValue = timerValue
        }
    }

}

extension ConnectClientTypes {
    /// Configuration information for the chat participant role.
    public struct ChatParticipantRoleConfig {
        /// A list of participant timers. You can specify any unique combination of role and timer type. Duplicate entries error out the request with a 400.
        /// This member is required.
        public var participantTimerConfigList: [ConnectClientTypes.ParticipantTimerConfiguration]?

        public init(
            participantTimerConfigList: [ConnectClientTypes.ParticipantTimerConfiguration]? = nil
        )
        {
            self.participantTimerConfigList = participantTimerConfigList
        }
    }

}

extension ConnectClientTypes {
    /// Configuration information for the chat participant role.
    public enum UpdateParticipantRoleConfigChannelInfo {
        /// Configuration information for the chat participant role.
        case chat(ConnectClientTypes.ChatParticipantRoleConfig)
        case sdkUnknown(Swift.String)
    }

}

public struct UpdateParticipantRoleConfigInput {
    /// The Amazon Connect channel you want to configure.
    /// This member is required.
    public var channelConfiguration: ConnectClientTypes.UpdateParticipantRoleConfigChannelInfo?
    /// The identifier of the contact in this instance of Amazon Connect.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        channelConfiguration: ConnectClientTypes.UpdateParticipantRoleConfigChannelInfo? = nil,
        contactId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.channelConfiguration = channelConfiguration
        self.contactId = contactId
        self.instanceId = instanceId
    }
}

public struct UpdateParticipantRoleConfigOutput {

    public init() { }
}

public struct UpdatePhoneNumberInput {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The identifier of the Amazon Connect instance that phone numbers are claimed to. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance. You must enter InstanceId or TargetArn.
    public var instanceId: Swift.String?
    /// A unique identifier for the phone number.
    /// This member is required.
    public var phoneNumberId: Swift.String?
    /// The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone number inbound traffic is routed through. You must enter InstanceId or TargetArn.
    public var targetArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        phoneNumberId: Swift.String? = nil,
        targetArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.instanceId = instanceId
        self.phoneNumberId = phoneNumberId
        self.targetArn = targetArn
    }
}

public struct UpdatePhoneNumberOutput {
    /// The Amazon Resource Name (ARN) of the phone number.
    public var phoneNumberArn: Swift.String?
    /// A unique identifier for the phone number.
    public var phoneNumberId: Swift.String?

    public init(
        phoneNumberArn: Swift.String? = nil,
        phoneNumberId: Swift.String? = nil
    )
    {
        self.phoneNumberArn = phoneNumberArn
        self.phoneNumberId = phoneNumberId
    }
}

public struct UpdatePhoneNumberMetadataInput {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The description of the phone number.
    public var phoneNumberDescription: Swift.String?
    /// The Amazon Resource Name (ARN) or resource ID of the phone number.
    /// This member is required.
    public var phoneNumberId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        phoneNumberDescription: Swift.String? = nil,
        phoneNumberId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.phoneNumberDescription = phoneNumberDescription
        self.phoneNumberId = phoneNumberId
    }
}

public struct UpdatePredefinedAttributeInput {
    /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the predefined attribute.
    /// This member is required.
    public var name: Swift.String?
    /// The values of the predefined attribute.
    public var values: ConnectClientTypes.PredefinedAttributeValues?

    public init(
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        values: ConnectClientTypes.PredefinedAttributeValues? = nil
    )
    {
        self.instanceId = instanceId
        self.name = name
        self.values = values
    }
}

public struct UpdatePromptInput {
    /// A description of the prompt.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the prompt.
    public var name: Swift.String?
    /// A unique identifier for the prompt.
    /// This member is required.
    public var promptId: Swift.String?
    /// The URI for the S3 bucket where the prompt is stored. You can provide S3 pre-signed URLs returned by the [GetPromptFile](https://docs.aws.amazon.com/connect/latest/APIReference/API_GetPromptFile.html) API instead of providing S3 URIs.
    public var s3Uri: Swift.String?

    public init(
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        promptId: Swift.String? = nil,
        s3Uri: Swift.String? = nil
    )
    {
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.promptId = promptId
        self.s3Uri = s3Uri
    }
}

public struct UpdatePromptOutput {
    /// The Amazon Resource Name (ARN) of the prompt.
    public var promptARN: Swift.String?
    /// A unique identifier for the prompt.
    public var promptId: Swift.String?

    public init(
        promptARN: Swift.String? = nil,
        promptId: Swift.String? = nil
    )
    {
        self.promptARN = promptARN
        self.promptId = promptId
    }
}

public struct UpdateQueueHoursOfOperationInput {
    /// The identifier for the hours of operation.
    /// This member is required.
    public var hoursOfOperationId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the queue.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        hoursOfOperationId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.hoursOfOperationId = hoursOfOperationId
        self.instanceId = instanceId
        self.queueId = queueId
    }
}

public struct UpdateQueueMaxContactsInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of contacts that can be in the queue before it is considered full.
    public var maxContacts: Swift.Int?
    /// The identifier for the queue.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxContacts: Swift.Int? = 0,
        queueId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxContacts = maxContacts
        self.queueId = queueId
    }
}

public struct UpdateQueueNameInput {
    /// The description of the queue.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the queue.
    public var name: Swift.String?
    /// The identifier for the queue.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.queueId = queueId
    }
}

public struct UpdateQueueOutboundCallerConfigInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The outbound caller ID name, number, and outbound whisper flow.
    /// This member is required.
    public var outboundCallerConfig: ConnectClientTypes.OutboundCallerConfig?
    /// The identifier for the queue.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        outboundCallerConfig: ConnectClientTypes.OutboundCallerConfig? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.outboundCallerConfig = outboundCallerConfig
        self.queueId = queueId
    }
}

public struct UpdateQueueStatusInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the queue.
    /// This member is required.
    public var queueId: Swift.String?
    /// The status of the queue.
    /// This member is required.
    public var status: ConnectClientTypes.QueueStatus?

    public init(
        instanceId: Swift.String? = nil,
        queueId: Swift.String? = nil,
        status: ConnectClientTypes.QueueStatus? = nil
    )
    {
        self.instanceId = instanceId
        self.queueId = queueId
        self.status = status
    }
}

public struct UpdateQuickConnectConfigInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Information about the configuration settings for the quick connect.
    /// This member is required.
    public var quickConnectConfig: ConnectClientTypes.QuickConnectConfig?
    /// The identifier for the quick connect.
    /// This member is required.
    public var quickConnectId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        quickConnectConfig: ConnectClientTypes.QuickConnectConfig? = nil,
        quickConnectId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.quickConnectConfig = quickConnectConfig
        self.quickConnectId = quickConnectId
    }
}

public struct UpdateQuickConnectNameInput {
    /// The description of the quick connect.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the quick connect.
    public var name: Swift.String?
    /// The identifier for the quick connect.
    /// This member is required.
    public var quickConnectId: Swift.String?

    public init(
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        quickConnectId: Swift.String? = nil
    )
    {
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.quickConnectId = quickConnectId
    }
}

public struct UpdateRoutingProfileAgentAvailabilityTimerInput {
    /// Whether agents with this routing profile will have their routing order calculated based on time since their last inbound contact or longest idle time.
    /// This member is required.
    public var agentAvailabilityTimer: ConnectClientTypes.AgentAvailabilityTimer?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the routing profile.
    /// This member is required.
    public var routingProfileId: Swift.String?

    public init(
        agentAvailabilityTimer: ConnectClientTypes.AgentAvailabilityTimer? = nil,
        instanceId: Swift.String? = nil,
        routingProfileId: Swift.String? = nil
    )
    {
        self.agentAvailabilityTimer = agentAvailabilityTimer
        self.instanceId = instanceId
        self.routingProfileId = routingProfileId
    }
}

public struct UpdateRoutingProfileConcurrencyInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The channels that agents can handle in the Contact Control Panel (CCP).
    /// This member is required.
    public var mediaConcurrencies: [ConnectClientTypes.MediaConcurrency]?
    /// The identifier of the routing profile.
    /// This member is required.
    public var routingProfileId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        mediaConcurrencies: [ConnectClientTypes.MediaConcurrency]? = nil,
        routingProfileId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.mediaConcurrencies = mediaConcurrencies
        self.routingProfileId = routingProfileId
    }
}

public struct UpdateRoutingProfileDefaultOutboundQueueInput {
    /// The identifier for the default outbound queue.
    /// This member is required.
    public var defaultOutboundQueueId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the routing profile.
    /// This member is required.
    public var routingProfileId: Swift.String?

    public init(
        defaultOutboundQueueId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        routingProfileId: Swift.String? = nil
    )
    {
        self.defaultOutboundQueueId = defaultOutboundQueueId
        self.instanceId = instanceId
        self.routingProfileId = routingProfileId
    }
}

public struct UpdateRoutingProfileNameInput {
    /// The description of the routing profile. Must not be more than 250 characters.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the routing profile. Must not be more than 127 characters.
    public var name: Swift.String?
    /// The identifier of the routing profile.
    /// This member is required.
    public var routingProfileId: Swift.String?

    public init(
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        routingProfileId: Swift.String? = nil
    )
    {
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.routingProfileId = routingProfileId
    }
}

public struct UpdateRoutingProfileQueuesInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The queues to be updated for this routing profile. Queues must first be associated to the routing profile. You can do this using AssociateRoutingProfileQueues.
    /// This member is required.
    public var queueConfigs: [ConnectClientTypes.RoutingProfileQueueConfig]?
    /// The identifier of the routing profile.
    /// This member is required.
    public var routingProfileId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        queueConfigs: [ConnectClientTypes.RoutingProfileQueueConfig]? = nil,
        routingProfileId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.queueConfigs = queueConfigs
        self.routingProfileId = routingProfileId
    }
}

public struct UpdateRuleInput {
    /// A list of actions to be run when the rule is triggered.
    /// This member is required.
    public var actions: [ConnectClientTypes.RuleAction]?
    /// The conditions of the rule.
    /// This member is required.
    public var function: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the rule. You can change the name only if TriggerEventSource is one of the following values: OnZendeskTicketCreate | OnZendeskTicketStatusUpdate | OnSalesforceCaseCreate
    /// This member is required.
    public var name: Swift.String?
    /// The publish status of the rule.
    /// This member is required.
    public var publishStatus: ConnectClientTypes.RulePublishStatus?
    /// A unique identifier for the rule.
    /// This member is required.
    public var ruleId: Swift.String?

    public init(
        actions: [ConnectClientTypes.RuleAction]? = nil,
        function: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        publishStatus: ConnectClientTypes.RulePublishStatus? = nil,
        ruleId: Swift.String? = nil
    )
    {
        self.actions = actions
        self.function = function
        self.instanceId = instanceId
        self.name = name
        self.publishStatus = publishStatus
        self.ruleId = ruleId
    }
}

public struct UpdateSecurityProfileInput {
    /// The identifier of the hierarchy group that a security profile uses to restrict access to resources in Amazon Connect.
    public var allowedAccessControlHierarchyGroupId: Swift.String?
    /// The list of tags that a security profile uses to restrict access to resources in Amazon Connect.
    public var allowedAccessControlTags: [Swift.String: Swift.String]?
    /// A list of the third-party application's metadata.
    public var applications: [ConnectClientTypes.Application]?
    /// The description of the security profile.
    public var description: Swift.String?
    /// The list of resources that a security profile applies hierarchy restrictions to in Amazon Connect. Following are acceptable ResourceNames: User.
    public var hierarchyRestrictedResources: [Swift.String]?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The permissions granted to a security profile. For a list of valid permissions, see [List of security profile permissions](https://docs.aws.amazon.com/connect/latest/adminguide/security-profile-list.html).
    public var permissions: [Swift.String]?
    /// The identifier for the security profle.
    /// This member is required.
    public var securityProfileId: Swift.String?
    /// The list of resources that a security profile applies tag restrictions to in Amazon Connect.
    public var tagRestrictedResources: [Swift.String]?

    public init(
        allowedAccessControlHierarchyGroupId: Swift.String? = nil,
        allowedAccessControlTags: [Swift.String: Swift.String]? = nil,
        applications: [ConnectClientTypes.Application]? = nil,
        description: Swift.String? = nil,
        hierarchyRestrictedResources: [Swift.String]? = nil,
        instanceId: Swift.String? = nil,
        permissions: [Swift.String]? = nil,
        securityProfileId: Swift.String? = nil,
        tagRestrictedResources: [Swift.String]? = nil
    )
    {
        self.allowedAccessControlHierarchyGroupId = allowedAccessControlHierarchyGroupId
        self.allowedAccessControlTags = allowedAccessControlTags
        self.applications = applications
        self.description = description
        self.hierarchyRestrictedResources = hierarchyRestrictedResources
        self.instanceId = instanceId
        self.permissions = permissions
        self.securityProfileId = securityProfileId
        self.tagRestrictedResources = tagRestrictedResources
    }
}

public struct UpdateTaskTemplateInput {
    /// Constraints that are applicable to the fields listed.
    public var constraints: ConnectClientTypes.TaskTemplateConstraints?
    /// The identifier of the flow that runs by default when a task is created by referencing this template.
    public var contactFlowId: Swift.String?
    /// The default values for fields when a task is created by referencing this template.
    public var defaults: ConnectClientTypes.TaskTemplateDefaults?
    /// The description of the task template.
    public var description: Swift.String?
    /// Fields that are part of the template.
    public var fields: [ConnectClientTypes.TaskTemplateField]?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the task template.
    public var name: Swift.String?
    /// Marks a template as ACTIVE or INACTIVE for a task to refer to it. Tasks can only be created from ACTIVE templates. If a template is marked as INACTIVE, then a task that refers to this template cannot be created.
    public var status: ConnectClientTypes.TaskTemplateStatus?
    /// A unique identifier for the task template.
    /// This member is required.
    public var taskTemplateId: Swift.String?

    public init(
        constraints: ConnectClientTypes.TaskTemplateConstraints? = nil,
        contactFlowId: Swift.String? = nil,
        defaults: ConnectClientTypes.TaskTemplateDefaults? = nil,
        description: Swift.String? = nil,
        fields: [ConnectClientTypes.TaskTemplateField]? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        status: ConnectClientTypes.TaskTemplateStatus? = nil,
        taskTemplateId: Swift.String? = nil
    )
    {
        self.constraints = constraints
        self.contactFlowId = contactFlowId
        self.defaults = defaults
        self.description = description
        self.fields = fields
        self.instanceId = instanceId
        self.name = name
        self.status = status
        self.taskTemplateId = taskTemplateId
    }
}

public struct UpdateTaskTemplateOutput {
    /// The Amazon Resource Name (ARN) for the task template resource.
    public var arn: Swift.String?
    /// Constraints that are applicable to the fields listed.
    public var constraints: ConnectClientTypes.TaskTemplateConstraints?
    /// The identifier of the flow that runs by default when a task is created by referencing this template.
    public var contactFlowId: Swift.String?
    /// The timestamp when the task template was created.
    public var createdTime: Foundation.Date?
    /// The default values for fields when a task is created by referencing this template.
    public var defaults: ConnectClientTypes.TaskTemplateDefaults?
    /// The description of the task template.
    public var description: Swift.String?
    /// Fields that are part of the template.
    public var fields: [ConnectClientTypes.TaskTemplateField]?
    /// The identifier of the task template resource.
    public var id: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    public var instanceId: Swift.String?
    /// The timestamp when the task template was last modified.
    public var lastModifiedTime: Foundation.Date?
    /// The name of the task template.
    public var name: Swift.String?
    /// Marks a template as ACTIVE or INACTIVE for a task to refer to it. Tasks can only be created from ACTIVE templates. If a template is marked as INACTIVE, then a task that refers to this template cannot be created.
    public var status: ConnectClientTypes.TaskTemplateStatus?

    public init(
        arn: Swift.String? = nil,
        constraints: ConnectClientTypes.TaskTemplateConstraints? = nil,
        contactFlowId: Swift.String? = nil,
        createdTime: Foundation.Date? = nil,
        defaults: ConnectClientTypes.TaskTemplateDefaults? = nil,
        description: Swift.String? = nil,
        fields: [ConnectClientTypes.TaskTemplateField]? = nil,
        id: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        name: Swift.String? = nil,
        status: ConnectClientTypes.TaskTemplateStatus? = nil
    )
    {
        self.arn = arn
        self.constraints = constraints
        self.contactFlowId = contactFlowId
        self.createdTime = createdTime
        self.defaults = defaults
        self.description = description
        self.fields = fields
        self.id = id
        self.instanceId = instanceId
        self.lastModifiedTime = lastModifiedTime
        self.name = name
        self.status = status
    }
}

public struct UpdateTrafficDistributionInput {
    /// The distribution of agents between the instance and its replica(s).
    public var agentConfig: ConnectClientTypes.AgentConfig?
    /// The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.
    /// This member is required.
    public var id: Swift.String?
    /// The distribution that determines which Amazon Web Services Regions should be used to sign in agents in to both the instance and its replica(s).
    public var signInConfig: ConnectClientTypes.SignInConfig?
    /// The distribution of traffic between the instance and its replica(s).
    public var telephonyConfig: ConnectClientTypes.TelephonyConfig?

    public init(
        agentConfig: ConnectClientTypes.AgentConfig? = nil,
        id: Swift.String? = nil,
        signInConfig: ConnectClientTypes.SignInConfig? = nil,
        telephonyConfig: ConnectClientTypes.TelephonyConfig? = nil
    )
    {
        self.agentConfig = agentConfig
        self.id = id
        self.signInConfig = signInConfig
        self.telephonyConfig = telephonyConfig
    }
}

public struct UpdateTrafficDistributionOutput {

    public init() { }
}

public struct UpdateUserHierarchyInput {
    /// The identifier of the hierarchy group.
    public var hierarchyGroupId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the user account.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        hierarchyGroupId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.hierarchyGroupId = hierarchyGroupId
        self.instanceId = instanceId
        self.userId = userId
    }
}

public struct UpdateUserHierarchyGroupNameInput {
    /// The identifier of the hierarchy group.
    /// This member is required.
    public var hierarchyGroupId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the hierarchy group. Must not be more than 100 characters.
    /// This member is required.
    public var name: Swift.String?

    public init(
        hierarchyGroupId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.hierarchyGroupId = hierarchyGroupId
        self.instanceId = instanceId
        self.name = name
    }
}

extension ConnectClientTypes {
    /// Contains information about the hierarchy level to update.
    public struct HierarchyLevelUpdate {
        /// The name of the user hierarchy level. Must not be more than 50 characters.
        /// This member is required.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension ConnectClientTypes {
    /// Contains information about the level hierarchy to update.
    public struct HierarchyStructureUpdate {
        /// The update for level five.
        public var levelFive: ConnectClientTypes.HierarchyLevelUpdate?
        /// The update for level four.
        public var levelFour: ConnectClientTypes.HierarchyLevelUpdate?
        /// The update for level one.
        public var levelOne: ConnectClientTypes.HierarchyLevelUpdate?
        /// The update for level three.
        public var levelThree: ConnectClientTypes.HierarchyLevelUpdate?
        /// The update for level two.
        public var levelTwo: ConnectClientTypes.HierarchyLevelUpdate?

        public init(
            levelFive: ConnectClientTypes.HierarchyLevelUpdate? = nil,
            levelFour: ConnectClientTypes.HierarchyLevelUpdate? = nil,
            levelOne: ConnectClientTypes.HierarchyLevelUpdate? = nil,
            levelThree: ConnectClientTypes.HierarchyLevelUpdate? = nil,
            levelTwo: ConnectClientTypes.HierarchyLevelUpdate? = nil
        )
        {
            self.levelFive = levelFive
            self.levelFour = levelFour
            self.levelOne = levelOne
            self.levelThree = levelThree
            self.levelTwo = levelTwo
        }
    }

}

public struct UpdateUserHierarchyStructureInput {
    /// The hierarchy levels to update.
    /// This member is required.
    public var hierarchyStructure: ConnectClientTypes.HierarchyStructureUpdate?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        hierarchyStructure: ConnectClientTypes.HierarchyStructureUpdate? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.hierarchyStructure = hierarchyStructure
        self.instanceId = instanceId
    }
}

public struct UpdateUserIdentityInfoInput {
    /// The identity information for the user.
    /// This member is required.
    public var identityInfo: ConnectClientTypes.UserIdentityInfo?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the user account.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        identityInfo: ConnectClientTypes.UserIdentityInfo? = nil,
        instanceId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.identityInfo = identityInfo
        self.instanceId = instanceId
        self.userId = userId
    }
}

public struct UpdateUserPhoneConfigInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Information about phone configuration settings for the user.
    /// This member is required.
    public var phoneConfig: ConnectClientTypes.UserPhoneConfig?
    /// The identifier of the user account.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        phoneConfig: ConnectClientTypes.UserPhoneConfig? = nil,
        userId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.phoneConfig = phoneConfig
        self.userId = userId
    }
}

public struct UpdateUserProficienciesInput {
    /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the user account.
    /// This member is required.
    public var userId: Swift.String?
    /// The proficiencies to be updated for the user. Proficiencies must first be associated to the user. You can do this using AssociateUserProficiencies API.
    /// This member is required.
    public var userProficiencies: [ConnectClientTypes.UserProficiency]?

    public init(
        instanceId: Swift.String? = nil,
        userId: Swift.String? = nil,
        userProficiencies: [ConnectClientTypes.UserProficiency]? = nil
    )
    {
        self.instanceId = instanceId
        self.userId = userId
        self.userProficiencies = userProficiencies
    }
}

public struct UpdateUserRoutingProfileInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the routing profile for the user.
    /// This member is required.
    public var routingProfileId: Swift.String?
    /// The identifier of the user account.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        routingProfileId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.routingProfileId = routingProfileId
        self.userId = userId
    }
}

public struct UpdateUserSecurityProfilesInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifiers of the security profiles for the user.
    /// This member is required.
    public var securityProfileIds: [Swift.String]?
    /// The identifier of the user account.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        securityProfileIds: [Swift.String]? = nil,
        userId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.securityProfileIds = securityProfileIds
        self.userId = userId
    }
}

public struct UpdateViewContentInput {
    /// View content containing all content necessary to render a view except for runtime input data and the runtime input schema, which is auto-generated by this operation. The total uncompressed content has a maximum file size of 400kB.
    /// This member is required.
    public var content: ConnectClientTypes.ViewInputContent?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Indicates the view status as either SAVED or PUBLISHED. The PUBLISHED status will initiate validation on the content.
    /// This member is required.
    public var status: ConnectClientTypes.ViewStatus?
    /// The identifier of the view. Both ViewArn and ViewId can be used.
    /// This member is required.
    public var viewId: Swift.String?

    public init(
        content: ConnectClientTypes.ViewInputContent? = nil,
        instanceId: Swift.String? = nil,
        status: ConnectClientTypes.ViewStatus? = nil,
        viewId: Swift.String? = nil
    )
    {
        self.content = content
        self.instanceId = instanceId
        self.status = status
        self.viewId = viewId
    }
}

public struct UpdateViewContentOutput {
    /// A view resource object. Contains metadata and content necessary to render the view.
    public var view: ConnectClientTypes.View?

    public init(
        view: ConnectClientTypes.View? = nil
    )
    {
        self.view = view
    }
}

public struct UpdateViewMetadataInput {
    /// The description of the view.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the view.
    public var name: Swift.String?
    /// The identifier of the view. Both ViewArn and ViewId can be used.
    /// This member is required.
    public var viewId: Swift.String?

    public init(
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        viewId: Swift.String? = nil
    )
    {
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.viewId = viewId
    }
}

extension UpdateViewMetadataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateViewMetadataInput(description: \(Swift.String(describing: description)), instanceId: \(Swift.String(describing: instanceId)), viewId: \(Swift.String(describing: viewId)), name: \"CONTENT_REDACTED\")"}
}

public struct UpdateViewMetadataOutput {

    public init() { }
}

extension ConnectClientTypes {
    /// Information about an item from an evaluation form. The item must be either a section or a question.
    public indirect enum EvaluationFormItem {
        /// The information of the section.
        case section(ConnectClientTypes.EvaluationFormSection)
        /// The information of the question.
        case question(ConnectClientTypes.EvaluationFormQuestion)
        case sdkUnknown(Swift.String)
    }

}

extension ConnectClientTypes {
    /// Information about a section from an evaluation form. A section can contain sections and/or questions. Evaluation forms can only contain sections and subsections (two level nesting).
    public struct EvaluationFormSection {
        /// The instructions of the section.
        public var instructions: Swift.String?
        /// The items of the section.
        /// This member is required.
        public var items: [ConnectClientTypes.EvaluationFormItem]?
        /// The identifier of the section. An identifier must be unique within the evaluation form.
        /// This member is required.
        public var refId: Swift.String?
        /// The title of the section.
        /// This member is required.
        public var title: Swift.String?
        /// The scoring weight of the section.
        public var weight: Swift.Double

        public init(
            instructions: Swift.String? = nil,
            items: [ConnectClientTypes.EvaluationFormItem]? = nil,
            refId: Swift.String? = nil,
            title: Swift.String? = nil,
            weight: Swift.Double = 0.0
        )
        {
            self.instructions = instructions
            self.items = items
            self.refId = refId
            self.title = title
            self.weight = weight
        }
    }

}

extension ConnectClientTypes {
    /// The search criteria to be used to return agent statuses.
    public struct AgentStatusSearchCriteria {
        /// A leaf node condition which can be used to specify a string condition. The currently supported values for FieldName are name,   description, state, type, displayOrder,  and resourceID.
        public var andConditions: [ConnectClientTypes.AgentStatusSearchCriteria]?
        /// A list of conditions which would be applied together with an OR condition.
        public var orConditions: [ConnectClientTypes.AgentStatusSearchCriteria]?
        /// A leaf node condition which can be used to specify a string condition. The currently supported values for FieldName are name,   description, state, type, displayOrder,  and resourceID.
        public var stringCondition: ConnectClientTypes.StringCondition?

        public init(
            andConditions: [ConnectClientTypes.AgentStatusSearchCriteria]? = nil,
            orConditions: [ConnectClientTypes.AgentStatusSearchCriteria]? = nil,
            stringCondition: ConnectClientTypes.StringCondition? = nil
        )
        {
            self.andConditions = andConditions
            self.orConditions = orConditions
            self.stringCondition = stringCondition
        }
    }

}

extension ConnectClientTypes {
    /// The search criteria to be used to return flow modules.
    public struct ContactFlowModuleSearchCriteria {
        /// A list of conditions which would be applied together with an AND condition.
        public var andConditions: [ConnectClientTypes.ContactFlowModuleSearchCriteria]?
        /// A list of conditions which would be applied together with an OR condition.
        public var orConditions: [ConnectClientTypes.ContactFlowModuleSearchCriteria]?
        /// A leaf node condition which can be used to specify a string condition.
        public var stringCondition: ConnectClientTypes.StringCondition?

        public init(
            andConditions: [ConnectClientTypes.ContactFlowModuleSearchCriteria]? = nil,
            orConditions: [ConnectClientTypes.ContactFlowModuleSearchCriteria]? = nil,
            stringCondition: ConnectClientTypes.StringCondition? = nil
        )
        {
            self.andConditions = andConditions
            self.orConditions = orConditions
            self.stringCondition = stringCondition
        }
    }

}

extension ConnectClientTypes {
    /// The search criteria to be used to return contact flows.
    public struct ContactFlowSearchCriteria {
        /// A list of conditions which would be applied together with an AND condition.
        public var andConditions: [ConnectClientTypes.ContactFlowSearchCriteria]?
        /// A list of conditions which would be applied together with an OR condition.
        public var orConditions: [ConnectClientTypes.ContactFlowSearchCriteria]?
        /// The state of the flow.
        public var stateCondition: ConnectClientTypes.ContactFlowState?
        /// The status of the flow.
        public var statusCondition: ConnectClientTypes.ContactFlowStatus?
        /// A leaf node condition which can be used to specify a string condition.
        public var stringCondition: ConnectClientTypes.StringCondition?
        /// The type of flow.
        public var typeCondition: ConnectClientTypes.ContactFlowType?

        public init(
            andConditions: [ConnectClientTypes.ContactFlowSearchCriteria]? = nil,
            orConditions: [ConnectClientTypes.ContactFlowSearchCriteria]? = nil,
            stateCondition: ConnectClientTypes.ContactFlowState? = nil,
            statusCondition: ConnectClientTypes.ContactFlowStatus? = nil,
            stringCondition: ConnectClientTypes.StringCondition? = nil,
            typeCondition: ConnectClientTypes.ContactFlowType? = nil
        )
        {
            self.andConditions = andConditions
            self.orConditions = orConditions
            self.stateCondition = stateCondition
            self.statusCondition = statusCondition
            self.stringCondition = stringCondition
            self.typeCondition = typeCondition
        }
    }

}

extension ConnectClientTypes {
    /// Information about the evaluation form.
    public struct EvaluationForm {
        /// The Amazon Resource Name (ARN) of the user who created the evaluation form.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The timestamp for when the evaluation form was created.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// The description of the evaluation form.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) for the evaluation form resource.
        /// This member is required.
        public var evaluationFormArn: Swift.String?
        /// The unique identifier for the evaluation form.
        /// This member is required.
        public var evaluationFormId: Swift.String?
        /// A version of the evaluation form.
        /// This member is required.
        public var evaluationFormVersion: Swift.Int
        /// Items that are part of the evaluation form. The total number of sections and questions must not exceed 100 each. Questions must be contained in a section.
        /// This member is required.
        public var items: [ConnectClientTypes.EvaluationFormItem]?
        /// The Amazon Resource Name (ARN) of the user who last updated the evaluation form.
        /// This member is required.
        public var lastModifiedBy: Swift.String?
        /// The timestamp for when the evaluation form was last updated.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// The flag indicating whether the evaluation form is locked for changes.
        /// This member is required.
        public var locked: Swift.Bool
        /// A scoring strategy of the evaluation form.
        public var scoringStrategy: ConnectClientTypes.EvaluationFormScoringStrategy?
        /// The status of the evaluation form.
        /// This member is required.
        public var status: ConnectClientTypes.EvaluationFormVersionStatus?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public var tags: [Swift.String: Swift.String]?
        /// A title of the evaluation form.
        /// This member is required.
        public var title: Swift.String?

        public init(
            createdBy: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            evaluationFormArn: Swift.String? = nil,
            evaluationFormId: Swift.String? = nil,
            evaluationFormVersion: Swift.Int = 0,
            items: [ConnectClientTypes.EvaluationFormItem]? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            locked: Swift.Bool = false,
            scoringStrategy: ConnectClientTypes.EvaluationFormScoringStrategy? = nil,
            status: ConnectClientTypes.EvaluationFormVersionStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            title: Swift.String? = nil
        )
        {
            self.createdBy = createdBy
            self.createdTime = createdTime
            self.description = description
            self.evaluationFormArn = evaluationFormArn
            self.evaluationFormId = evaluationFormId
            self.evaluationFormVersion = evaluationFormVersion
            self.items = items
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.locked = locked
            self.scoringStrategy = scoringStrategy
            self.status = status
            self.tags = tags
            self.title = title
        }
    }

}

extension ConnectClientTypes {
    /// Information about an evaluation form used in a contact evaluation.
    public struct EvaluationFormContent {
        /// The description of the evaluation form.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) for the evaluation form resource.
        /// This member is required.
        public var evaluationFormArn: Swift.String?
        /// The unique identifier for the evaluation form.
        /// This member is required.
        public var evaluationFormId: Swift.String?
        /// A version of the evaluation form.
        /// This member is required.
        public var evaluationFormVersion: Swift.Int
        /// Items that are part of the evaluation form. The total number of sections and questions must not exceed 100 each. Questions must be contained in a section.
        /// This member is required.
        public var items: [ConnectClientTypes.EvaluationFormItem]?
        /// A scoring strategy of the evaluation form.
        public var scoringStrategy: ConnectClientTypes.EvaluationFormScoringStrategy?
        /// A title of the evaluation form.
        /// This member is required.
        public var title: Swift.String?

        public init(
            description: Swift.String? = nil,
            evaluationFormArn: Swift.String? = nil,
            evaluationFormId: Swift.String? = nil,
            evaluationFormVersion: Swift.Int = 0,
            items: [ConnectClientTypes.EvaluationFormItem]? = nil,
            scoringStrategy: ConnectClientTypes.EvaluationFormScoringStrategy? = nil,
            title: Swift.String? = nil
        )
        {
            self.description = description
            self.evaluationFormArn = evaluationFormArn
            self.evaluationFormId = evaluationFormId
            self.evaluationFormVersion = evaluationFormVersion
            self.items = items
            self.scoringStrategy = scoringStrategy
            self.title = title
        }
    }

}

extension ConnectClientTypes {
    /// A tagged union to specify expression for a routing step.
    public struct Expression {
        /// List of routing expressions which will be AND-ed together.
        public var andExpression: [ConnectClientTypes.Expression]?
        /// An object to specify the predefined attribute condition.
        public var attributeCondition: ConnectClientTypes.AttributeCondition?
        /// List of routing expressions which will be OR-ed together.
        public var orExpression: [ConnectClientTypes.Expression]?

        public init(
            andExpression: [ConnectClientTypes.Expression]? = nil,
            attributeCondition: ConnectClientTypes.AttributeCondition? = nil,
            orExpression: [ConnectClientTypes.Expression]? = nil
        )
        {
            self.andExpression = andExpression
            self.attributeCondition = attributeCondition
            self.orExpression = orExpression
        }
    }

}

extension ConnectClientTypes {
    /// The search criteria to be used to return hours of operations.
    public struct HoursOfOperationSearchCriteria {
        /// A list of conditions which would be applied together with an AND condition.
        public var andConditions: [ConnectClientTypes.HoursOfOperationSearchCriteria]?
        /// A list of conditions which would be applied together with an OR condition.
        public var orConditions: [ConnectClientTypes.HoursOfOperationSearchCriteria]?
        /// A leaf node condition which can be used to specify a string condition. The currently supported values for FieldName are name, description, timezone, and resourceID.
        public var stringCondition: ConnectClientTypes.StringCondition?

        public init(
            andConditions: [ConnectClientTypes.HoursOfOperationSearchCriteria]? = nil,
            orConditions: [ConnectClientTypes.HoursOfOperationSearchCriteria]? = nil,
            stringCondition: ConnectClientTypes.StringCondition? = nil
        )
        {
            self.andConditions = andConditions
            self.orConditions = orConditions
            self.stringCondition = stringCondition
        }
    }

}

extension ConnectClientTypes {
    /// The search criteria to be used to return predefined attributes.
    public struct PredefinedAttributeSearchCriteria {
        /// A list of conditions which would be applied together with an AND condition.
        public var andConditions: [ConnectClientTypes.PredefinedAttributeSearchCriteria]?
        /// A list of conditions which would be applied together with an OR condition.
        public var orConditions: [ConnectClientTypes.PredefinedAttributeSearchCriteria]?
        /// A leaf node condition which can be used to specify a string condition.
        public var stringCondition: ConnectClientTypes.StringCondition?

        public init(
            andConditions: [ConnectClientTypes.PredefinedAttributeSearchCriteria]? = nil,
            orConditions: [ConnectClientTypes.PredefinedAttributeSearchCriteria]? = nil,
            stringCondition: ConnectClientTypes.StringCondition? = nil
        )
        {
            self.andConditions = andConditions
            self.orConditions = orConditions
            self.stringCondition = stringCondition
        }
    }

}

extension ConnectClientTypes {
    /// The search criteria to be used to return prompts.
    public struct PromptSearchCriteria {
        /// A list of conditions which would be applied together with an AND condition.
        public var andConditions: [ConnectClientTypes.PromptSearchCriteria]?
        /// A list of conditions which would be applied together with an OR condition.
        public var orConditions: [ConnectClientTypes.PromptSearchCriteria]?
        /// A leaf node condition which can be used to specify a string condition. The currently supported values for FieldName are name, description, and resourceID.
        public var stringCondition: ConnectClientTypes.StringCondition?

        public init(
            andConditions: [ConnectClientTypes.PromptSearchCriteria]? = nil,
            orConditions: [ConnectClientTypes.PromptSearchCriteria]? = nil,
            stringCondition: ConnectClientTypes.StringCondition? = nil
        )
        {
            self.andConditions = andConditions
            self.orConditions = orConditions
            self.stringCondition = stringCondition
        }
    }

}

extension ConnectClientTypes {
    /// The search criteria to be used to return queues. The name and description fields support "contains" queries with a minimum of 2 characters and a maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results.
    public struct QueueSearchCriteria {
        /// A list of conditions which would be applied together with an AND condition.
        public var andConditions: [ConnectClientTypes.QueueSearchCriteria]?
        /// A list of conditions which would be applied together with an OR condition.
        public var orConditions: [ConnectClientTypes.QueueSearchCriteria]?
        /// The type of queue.
        public var queueTypeCondition: ConnectClientTypes.SearchableQueueType?
        /// A leaf node condition which can be used to specify a string condition. The currently supported values for FieldName are name, description, and resourceID.
        public var stringCondition: ConnectClientTypes.StringCondition?

        public init(
            andConditions: [ConnectClientTypes.QueueSearchCriteria]? = nil,
            orConditions: [ConnectClientTypes.QueueSearchCriteria]? = nil,
            queueTypeCondition: ConnectClientTypes.SearchableQueueType? = nil,
            stringCondition: ConnectClientTypes.StringCondition? = nil
        )
        {
            self.andConditions = andConditions
            self.orConditions = orConditions
            self.queueTypeCondition = queueTypeCondition
            self.stringCondition = stringCondition
        }
    }

}

extension ConnectClientTypes {
    /// The search criteria to be used to return quick connects.
    public struct QuickConnectSearchCriteria {
        /// A list of conditions which would be applied together with an AND condition.
        public var andConditions: [ConnectClientTypes.QuickConnectSearchCriteria]?
        /// A list of conditions which would be applied together with an OR condition.
        public var orConditions: [ConnectClientTypes.QuickConnectSearchCriteria]?
        /// A leaf node condition which can be used to specify a string condition. The currently supported values for FieldName are name, description, and resourceID.
        public var stringCondition: ConnectClientTypes.StringCondition?

        public init(
            andConditions: [ConnectClientTypes.QuickConnectSearchCriteria]? = nil,
            orConditions: [ConnectClientTypes.QuickConnectSearchCriteria]? = nil,
            stringCondition: ConnectClientTypes.StringCondition? = nil
        )
        {
            self.andConditions = andConditions
            self.orConditions = orConditions
            self.stringCondition = stringCondition
        }
    }

}

extension ConnectClientTypes {
    /// The search criteria to be used to return routing profiles. The name and description fields support "contains" queries with a minimum of 2 characters and a maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results.
    public struct RoutingProfileSearchCriteria {
        /// A list of conditions which would be applied together with an AND condition.
        public var andConditions: [ConnectClientTypes.RoutingProfileSearchCriteria]?
        /// A list of conditions which would be applied together with an OR condition.
        public var orConditions: [ConnectClientTypes.RoutingProfileSearchCriteria]?
        /// A leaf node condition which can be used to specify a string condition. The currently supported values for FieldName are associatedQueueIds, name, description, and resourceID.
        public var stringCondition: ConnectClientTypes.StringCondition?

        public init(
            andConditions: [ConnectClientTypes.RoutingProfileSearchCriteria]? = nil,
            orConditions: [ConnectClientTypes.RoutingProfileSearchCriteria]? = nil,
            stringCondition: ConnectClientTypes.StringCondition? = nil
        )
        {
            self.andConditions = andConditions
            self.orConditions = orConditions
            self.stringCondition = stringCondition
        }
    }

}

extension ConnectClientTypes {
    /// The search criteria to be used to return security profiles. The name field support "contains" queries with a minimum of 2 characters and maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results.
    public struct SecurityProfileSearchCriteria {
        /// A list of conditions which would be applied together with an AND condition.
        public var andConditions: [ConnectClientTypes.SecurityProfileSearchCriteria]?
        /// A list of conditions which would be applied together with an OR condition.
        public var orConditions: [ConnectClientTypes.SecurityProfileSearchCriteria]?
        /// A leaf node condition which can be used to specify a string condition.
        public var stringCondition: ConnectClientTypes.StringCondition?

        public init(
            andConditions: [ConnectClientTypes.SecurityProfileSearchCriteria]? = nil,
            orConditions: [ConnectClientTypes.SecurityProfileSearchCriteria]? = nil,
            stringCondition: ConnectClientTypes.StringCondition? = nil
        )
        {
            self.andConditions = andConditions
            self.orConditions = orConditions
            self.stringCondition = stringCondition
        }
    }

}

extension ConnectClientTypes {
    /// The search criteria to be used to return userHierarchyGroup.
    public struct UserHierarchyGroupSearchCriteria {
        /// A list of conditions which would be applied together with an AND condition.
        public var andConditions: [ConnectClientTypes.UserHierarchyGroupSearchCriteria]?
        /// A list of conditions which would be applied together with an OR condition.
        public var orConditions: [ConnectClientTypes.UserHierarchyGroupSearchCriteria]?
        /// A leaf node condition which can be used to specify a string condition. The currently supported values for FieldName are name,   parentId, levelId, and resourceID.
        public var stringCondition: ConnectClientTypes.StringCondition?

        public init(
            andConditions: [ConnectClientTypes.UserHierarchyGroupSearchCriteria]? = nil,
            orConditions: [ConnectClientTypes.UserHierarchyGroupSearchCriteria]? = nil,
            stringCondition: ConnectClientTypes.StringCondition? = nil
        )
        {
            self.andConditions = andConditions
            self.orConditions = orConditions
            self.stringCondition = stringCondition
        }
    }

}

extension ConnectClientTypes {
    /// The search criteria to be used to return users. The name and description fields support "contains" queries with a minimum of 2 characters and a maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results.
    public struct UserSearchCriteria {
        /// A list of conditions which would be applied together with an AND condition.
        public var andConditions: [ConnectClientTypes.UserSearchCriteria]?
        /// A leaf node condition which can be used to specify a hierarchy group condition.
        public var hierarchyGroupCondition: ConnectClientTypes.HierarchyGroupCondition?
        /// A leaf node condition which can be used to specify a List condition to search users with attributes included in Lists like Proficiencies.
        public var listCondition: ConnectClientTypes.ListCondition?
        /// A list of conditions which would be applied together with an OR condition.
        public var orConditions: [ConnectClientTypes.UserSearchCriteria]?
        /// A leaf node condition which can be used to specify a string condition. The currently supported values for FieldName are Username, FirstName, LastName, RoutingProfileId, SecurityProfileId, ResourceId.
        public var stringCondition: ConnectClientTypes.StringCondition?

        public init(
            andConditions: [ConnectClientTypes.UserSearchCriteria]? = nil,
            hierarchyGroupCondition: ConnectClientTypes.HierarchyGroupCondition? = nil,
            listCondition: ConnectClientTypes.ListCondition? = nil,
            orConditions: [ConnectClientTypes.UserSearchCriteria]? = nil,
            stringCondition: ConnectClientTypes.StringCondition? = nil
        )
        {
            self.andConditions = andConditions
            self.hierarchyGroupCondition = hierarchyGroupCondition
            self.listCondition = listCondition
            self.orConditions = orConditions
            self.stringCondition = stringCondition
        }
    }

}

public struct CreateEvaluationFormInput {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The description of the evaluation form.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Items that are part of the evaluation form. The total number of sections and questions must not exceed 100 each. Questions must be contained in a section.
    /// This member is required.
    public var items: [ConnectClientTypes.EvaluationFormItem]?
    /// A scoring strategy of the evaluation form.
    public var scoringStrategy: ConnectClientTypes.EvaluationFormScoringStrategy?
    /// A title of the evaluation form.
    /// This member is required.
    public var title: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        items: [ConnectClientTypes.EvaluationFormItem]? = nil,
        scoringStrategy: ConnectClientTypes.EvaluationFormScoringStrategy? = nil,
        title: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.instanceId = instanceId
        self.items = items
        self.scoringStrategy = scoringStrategy
        self.title = title
    }
}

public struct UpdateEvaluationFormInput {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// A flag indicating whether the operation must create a new version.
    public var createNewVersion: Swift.Bool?
    /// The description of the evaluation form.
    public var description: Swift.String?
    /// The unique identifier for the evaluation form.
    /// This member is required.
    public var evaluationFormId: Swift.String?
    /// A version of the evaluation form to update.
    /// This member is required.
    public var evaluationFormVersion: Swift.Int?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Items that are part of the evaluation form. The total number of sections and questions must not exceed 100 each. Questions must be contained in a section.
    /// This member is required.
    public var items: [ConnectClientTypes.EvaluationFormItem]?
    /// A scoring strategy of the evaluation form.
    public var scoringStrategy: ConnectClientTypes.EvaluationFormScoringStrategy?
    /// A title of the evaluation form.
    /// This member is required.
    public var title: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        createNewVersion: Swift.Bool? = false,
        description: Swift.String? = nil,
        evaluationFormId: Swift.String? = nil,
        evaluationFormVersion: Swift.Int? = 0,
        instanceId: Swift.String? = nil,
        items: [ConnectClientTypes.EvaluationFormItem]? = nil,
        scoringStrategy: ConnectClientTypes.EvaluationFormScoringStrategy? = nil,
        title: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.createNewVersion = createNewVersion
        self.description = description
        self.evaluationFormId = evaluationFormId
        self.evaluationFormVersion = evaluationFormVersion
        self.instanceId = instanceId
        self.items = items
        self.scoringStrategy = scoringStrategy
        self.title = title
    }
}

public struct DescribeContactEvaluationOutput {
    /// Information about the evaluation form completed for a specific contact.
    /// This member is required.
    public var evaluation: ConnectClientTypes.Evaluation?
    /// Information about the evaluation form.
    /// This member is required.
    public var evaluationForm: ConnectClientTypes.EvaluationFormContent?

    public init(
        evaluation: ConnectClientTypes.Evaluation? = nil,
        evaluationForm: ConnectClientTypes.EvaluationFormContent? = nil
    )
    {
        self.evaluation = evaluation
        self.evaluationForm = evaluationForm
    }
}

public struct DescribeEvaluationFormOutput {
    /// Information about the evaluation form.
    /// This member is required.
    public var evaluationForm: ConnectClientTypes.EvaluationForm?

    public init(
        evaluationForm: ConnectClientTypes.EvaluationForm? = nil
    )
    {
        self.evaluationForm = evaluationForm
    }
}

extension ConnectClientTypes {
    /// Step defines the list of agents to be routed or route based on the agent requirements such as ProficiencyLevel, Name, or Value.
    public struct RoutingCriteriaInputStep {
        /// An object to specify the expiration of a routing step.
        public var expiry: ConnectClientTypes.RoutingCriteriaInputStepExpiry?
        /// A tagged union to specify expression for a routing step.
        public var expression: ConnectClientTypes.Expression?

        public init(
            expiry: ConnectClientTypes.RoutingCriteriaInputStepExpiry? = nil,
            expression: ConnectClientTypes.Expression? = nil
        )
        {
            self.expiry = expiry
            self.expression = expression
        }
    }

}

extension ConnectClientTypes {
    /// Step signifies the criteria to be used for routing to an agent
    public struct Step {
        /// An object to specify the expiration of a routing step.
        public var expiry: ConnectClientTypes.Expiry?
        /// A tagged union to specify expression for a routing step.
        public var expression: ConnectClientTypes.Expression?
        /// Represents status of the Routing step.
        public var status: ConnectClientTypes.RoutingCriteriaStepStatus?

        public init(
            expiry: ConnectClientTypes.Expiry? = nil,
            expression: ConnectClientTypes.Expression? = nil,
            status: ConnectClientTypes.RoutingCriteriaStepStatus? = nil
        )
        {
            self.expiry = expiry
            self.expression = expression
            self.status = status
        }
    }

}

public struct SearchAgentStatusesInput {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The search criteria to be used to return agent statuses.
    public var searchCriteria: ConnectClientTypes.AgentStatusSearchCriteria?
    /// Filters to be applied to search results.
    public var searchFilter: ConnectClientTypes.AgentStatusSearchFilter?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchCriteria: ConnectClientTypes.AgentStatusSearchCriteria? = nil,
        searchFilter: ConnectClientTypes.AgentStatusSearchFilter? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchCriteria = searchCriteria
        self.searchFilter = searchFilter
    }
}

public struct SearchContactFlowModulesInput {
    /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The search criteria to be used to return contact flow modules. The name and description fields support "contains" queries with a minimum of 2 characters and a maximum of 25 characters. Any queries with character lengths outside of this range will result in invalid results.
    public var searchCriteria: ConnectClientTypes.ContactFlowModuleSearchCriteria?
    /// Filters to be applied to search results.
    public var searchFilter: ConnectClientTypes.ContactFlowModuleSearchFilter?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchCriteria: ConnectClientTypes.ContactFlowModuleSearchCriteria? = nil,
        searchFilter: ConnectClientTypes.ContactFlowModuleSearchFilter? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchCriteria = searchCriteria
        self.searchFilter = searchFilter
    }
}

public struct SearchContactFlowsInput {
    /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The search criteria to be used to return flows. The name and description fields support "contains" queries with a minimum of 2 characters and a maximum of 25 characters. Any queries with character lengths outside of this range will result in invalid results.
    public var searchCriteria: ConnectClientTypes.ContactFlowSearchCriteria?
    /// Filters to be applied to search results.
    public var searchFilter: ConnectClientTypes.ContactFlowSearchFilter?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchCriteria: ConnectClientTypes.ContactFlowSearchCriteria? = nil,
        searchFilter: ConnectClientTypes.ContactFlowSearchFilter? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchCriteria = searchCriteria
        self.searchFilter = searchFilter
    }
}

public struct SearchHoursOfOperationsInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The search criteria to be used to return hours of operations.
    public var searchCriteria: ConnectClientTypes.HoursOfOperationSearchCriteria?
    /// Filters to be applied to search results.
    public var searchFilter: ConnectClientTypes.HoursOfOperationSearchFilter?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchCriteria: ConnectClientTypes.HoursOfOperationSearchCriteria? = nil,
        searchFilter: ConnectClientTypes.HoursOfOperationSearchFilter? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchCriteria = searchCriteria
        self.searchFilter = searchFilter
    }
}

public struct SearchPredefinedAttributesInput {
    /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The search criteria to be used to return predefined attributes.
    public var searchCriteria: ConnectClientTypes.PredefinedAttributeSearchCriteria?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchCriteria: ConnectClientTypes.PredefinedAttributeSearchCriteria? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchCriteria = searchCriteria
    }
}

public struct SearchPromptsInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The search criteria to be used to return prompts.
    public var searchCriteria: ConnectClientTypes.PromptSearchCriteria?
    /// Filters to be applied to search results.
    public var searchFilter: ConnectClientTypes.PromptSearchFilter?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchCriteria: ConnectClientTypes.PromptSearchCriteria? = nil,
        searchFilter: ConnectClientTypes.PromptSearchFilter? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchCriteria = searchCriteria
        self.searchFilter = searchFilter
    }
}

public struct SearchQueuesInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The search criteria to be used to return queues. The name and description fields support "contains" queries with a minimum of 2 characters and a maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results.
    public var searchCriteria: ConnectClientTypes.QueueSearchCriteria?
    /// Filters to be applied to search results.
    public var searchFilter: ConnectClientTypes.QueueSearchFilter?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchCriteria: ConnectClientTypes.QueueSearchCriteria? = nil,
        searchFilter: ConnectClientTypes.QueueSearchFilter? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchCriteria = searchCriteria
        self.searchFilter = searchFilter
    }
}

public struct SearchQuickConnectsInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The search criteria to be used to return quick connects.
    public var searchCriteria: ConnectClientTypes.QuickConnectSearchCriteria?
    /// Filters to be applied to search results.
    public var searchFilter: ConnectClientTypes.QuickConnectSearchFilter?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchCriteria: ConnectClientTypes.QuickConnectSearchCriteria? = nil,
        searchFilter: ConnectClientTypes.QuickConnectSearchFilter? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchCriteria = searchCriteria
        self.searchFilter = searchFilter
    }
}

public struct SearchRoutingProfilesInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The search criteria to be used to return routing profiles. The name and description fields support "contains" queries with a minimum of 2 characters and a maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results.
    public var searchCriteria: ConnectClientTypes.RoutingProfileSearchCriteria?
    /// Filters to be applied to search results.
    public var searchFilter: ConnectClientTypes.RoutingProfileSearchFilter?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchCriteria: ConnectClientTypes.RoutingProfileSearchCriteria? = nil,
        searchFilter: ConnectClientTypes.RoutingProfileSearchFilter? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchCriteria = searchCriteria
        self.searchFilter = searchFilter
    }
}

public struct SearchSecurityProfilesInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The search criteria to be used to return security profiles. The name field support "contains" queries with a minimum of 2 characters and maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results. The currently supported value for FieldName: name
    public var searchCriteria: ConnectClientTypes.SecurityProfileSearchCriteria?
    /// Filters to be applied to search results.
    public var searchFilter: ConnectClientTypes.SecurityProfilesSearchFilter?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchCriteria: ConnectClientTypes.SecurityProfileSearchCriteria? = nil,
        searchFilter: ConnectClientTypes.SecurityProfilesSearchFilter? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchCriteria = searchCriteria
        self.searchFilter = searchFilter
    }
}

public struct SearchUserHierarchyGroupsInput {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The search criteria to be used to return UserHierarchyGroups.
    public var searchCriteria: ConnectClientTypes.UserHierarchyGroupSearchCriteria?
    /// Filters to be applied to search results.
    public var searchFilter: ConnectClientTypes.UserHierarchyGroupSearchFilter?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchCriteria: ConnectClientTypes.UserHierarchyGroupSearchCriteria? = nil,
        searchFilter: ConnectClientTypes.UserHierarchyGroupSearchFilter? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchCriteria = searchCriteria
        self.searchFilter = searchFilter
    }
}

public struct SearchUsersInput {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance. InstanceID is a required field. The "Required: No" below is incorrect.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The search criteria to be used to return users. The name and description fields support "contains" queries with a minimum of 2 characters and a maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results.
    public var searchCriteria: ConnectClientTypes.UserSearchCriteria?
    /// Filters to be applied to search results.
    public var searchFilter: ConnectClientTypes.UserSearchFilter?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchCriteria: ConnectClientTypes.UserSearchCriteria? = nil,
        searchFilter: ConnectClientTypes.UserSearchFilter? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchCriteria = searchCriteria
        self.searchFilter = searchFilter
    }
}

extension ConnectClientTypes {
    /// Latest routing criteria on the contact.
    public struct RoutingCriteria {
        /// The timestamp indicating when the routing criteria is set to active. A routing criteria is activated when contact is transferred to a queue. ActivationTimestamp will be set on routing criteria for contacts in agent queue even though Routing criteria is never activated for contacts in agent queue.
        public var activationTimestamp: Foundation.Date?
        /// Information about the index of the routing criteria.
        public var index: Swift.Int?
        /// List of routing steps. When Amazon Connect does not find an available agent meeting the requirements in a step for a given step duration, the routing criteria will move on to the next step sequentially until a join is completed with an agent. When all steps are exhausted, the contact will be offered to any agent in the queue.
        public var steps: [ConnectClientTypes.Step]?

        public init(
            activationTimestamp: Foundation.Date? = nil,
            index: Swift.Int? = nil,
            steps: [ConnectClientTypes.Step]? = nil
        )
        {
            self.activationTimestamp = activationTimestamp
            self.index = index
            self.steps = steps
        }
    }

}

extension ConnectClientTypes {
    /// An object to define the RoutingCriteria.
    public struct RoutingCriteriaInput {
        /// When Amazon Connect does not find an available agent meeting the requirements in a step for  a given step duration, the routing criteria will move on to the next step sequentially until a  join is completed with an agent. When all steps are exhausted, the contact will be offered to any agent in the queue.
        public var steps: [ConnectClientTypes.RoutingCriteriaInputStep]?

        public init(
            steps: [ConnectClientTypes.RoutingCriteriaInputStep]? = nil
        )
        {
            self.steps = steps
        }
    }

}

extension ConnectClientTypes {
    /// Contains information about a contact.
    public struct Contact {
        /// Information about the agent who accepted the contact.
        public var agentInfo: ConnectClientTypes.AgentInfo?
        /// Indicates how an [outbound campaign](https://docs.aws.amazon.com/connect/latest/adminguide/how-to-create-campaigns.html) call is actually disposed if the contact is connected to Amazon Connect.
        public var answeringMachineDetectionStatus: ConnectClientTypes.AnsweringMachineDetectionStatus?
        /// The Amazon Resource Name (ARN) for the contact.
        public var arn: Swift.String?
        /// Information associated with a campaign.
        public var campaign: ConnectClientTypes.Campaign?
        /// How the contact reached your contact center.
        public var channel: ConnectClientTypes.Channel?
        /// The timestamp when customer endpoint connected to Amazon Connect.
        public var connectedToSystemTimestamp: Foundation.Date?
        /// Information about the Customer on the contact.
        public var customer: ConnectClientTypes.Customer?
        /// Information about customer’s voice activity.
        public var customerVoiceActivity: ConnectClientTypes.CustomerVoiceActivity?
        /// The description of the contact.
        public var description: Swift.String?
        /// Information about the call disconnect experience.
        public var disconnectDetails: ConnectClientTypes.DisconnectDetails?
        /// The timestamp when the customer endpoint disconnected from Amazon Connect.
        public var disconnectTimestamp: Foundation.Date?
        /// The identifier for the contact.
        public var id: Swift.String?
        /// If this contact is related to other contacts, this is the ID of the initial contact.
        public var initialContactId: Swift.String?
        /// Indicates how the contact was initiated.
        public var initiationMethod: ConnectClientTypes.ContactInitiationMethod?
        /// The date and time this contact was initiated, in UTC time. For INBOUND, this is when the contact arrived. For OUTBOUND, this is when the agent began dialing. For CALLBACK, this is when the callback contact was created. For TRANSFER and QUEUE_TRANSFER, this is when the transfer was initiated. For API, this is when the request arrived. For EXTERNAL_OUTBOUND, this is when the agent started dialing the external participant. For MONITOR, this is when the supervisor started listening to a contact.
        public var initiationTimestamp: Foundation.Date?
        /// The timestamp when the contact was last paused.
        public var lastPausedTimestamp: Foundation.Date?
        /// The timestamp when the contact was last resumed.
        public var lastResumedTimestamp: Foundation.Date?
        /// The timestamp when contact was last updated.
        public var lastUpdateTimestamp: Foundation.Date?
        /// The name of the contact.
        public var name: Swift.String?
        /// If this contact is not the first contact, this is the ID of the previous contact.
        public var previousContactId: Swift.String?
        /// Information about the quality of the participant's media connection.
        public var qualityMetrics: ConnectClientTypes.QualityMetrics?
        /// If this contact was queued, this contains information about the queue.
        public var queueInfo: ConnectClientTypes.QueueInfo?
        /// An integer that represents the queue priority to be applied to the contact (lower priorities are routed preferentially). Cannot be specified if the QueueTimeAdjustmentSeconds is specified. Must be statically defined, must be larger than zero, and a valid integer value. Default Value is 5.
        public var queuePriority: Swift.Int?
        /// An integer that represents the queue time adjust to be applied to the contact, in seconds (longer / larger queue time are routed preferentially). Cannot be specified if the QueuePriority is specified. Must be statically defined and a valid integer value.
        public var queueTimeAdjustmentSeconds: Swift.Int?
        /// The contactId that is [related](https://docs.aws.amazon.com/connect/latest/adminguide/chat-persistence.html#relatedcontactid) to this contact.
        public var relatedContactId: Swift.String?
        /// Latest routing criteria on the contact.
        public var routingCriteria: ConnectClientTypes.RoutingCriteria?
        /// The timestamp, in Unix epoch time format, at which to start running the inbound flow.
        public var scheduledTimestamp: Foundation.Date?
        /// A set of system defined key-value pairs stored on individual contact segments using an attribute map. The attributes are standard Amazon Connect attributes and can be accessed in flows. Attribute keys can include only alphanumeric, -, and _ characters. This field can be used to show channel subtype. For example, connect:Guide or connect:SMS.
        public var segmentAttributes: [Swift.String: ConnectClientTypes.SegmentAttributeValue]?
        /// Tags associated with the contact. This contains both Amazon Web Services generated and user-defined tags.
        public var tags: [Swift.String: Swift.String]?
        /// Total pause count for a contact.
        public var totalPauseCount: Swift.Int?
        /// Total pause duration for a contact in seconds.
        public var totalPauseDurationInSeconds: Swift.Int?
        /// Information about Amazon Connect Wisdom.
        public var wisdomInfo: ConnectClientTypes.WisdomInfo?

        public init(
            agentInfo: ConnectClientTypes.AgentInfo? = nil,
            answeringMachineDetectionStatus: ConnectClientTypes.AnsweringMachineDetectionStatus? = nil,
            arn: Swift.String? = nil,
            campaign: ConnectClientTypes.Campaign? = nil,
            channel: ConnectClientTypes.Channel? = nil,
            connectedToSystemTimestamp: Foundation.Date? = nil,
            customer: ConnectClientTypes.Customer? = nil,
            customerVoiceActivity: ConnectClientTypes.CustomerVoiceActivity? = nil,
            description: Swift.String? = nil,
            disconnectDetails: ConnectClientTypes.DisconnectDetails? = nil,
            disconnectTimestamp: Foundation.Date? = nil,
            id: Swift.String? = nil,
            initialContactId: Swift.String? = nil,
            initiationMethod: ConnectClientTypes.ContactInitiationMethod? = nil,
            initiationTimestamp: Foundation.Date? = nil,
            lastPausedTimestamp: Foundation.Date? = nil,
            lastResumedTimestamp: Foundation.Date? = nil,
            lastUpdateTimestamp: Foundation.Date? = nil,
            name: Swift.String? = nil,
            previousContactId: Swift.String? = nil,
            qualityMetrics: ConnectClientTypes.QualityMetrics? = nil,
            queueInfo: ConnectClientTypes.QueueInfo? = nil,
            queuePriority: Swift.Int? = nil,
            queueTimeAdjustmentSeconds: Swift.Int? = nil,
            relatedContactId: Swift.String? = nil,
            routingCriteria: ConnectClientTypes.RoutingCriteria? = nil,
            scheduledTimestamp: Foundation.Date? = nil,
            segmentAttributes: [Swift.String: ConnectClientTypes.SegmentAttributeValue]? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            totalPauseCount: Swift.Int? = nil,
            totalPauseDurationInSeconds: Swift.Int? = nil,
            wisdomInfo: ConnectClientTypes.WisdomInfo? = nil
        )
        {
            self.agentInfo = agentInfo
            self.answeringMachineDetectionStatus = answeringMachineDetectionStatus
            self.arn = arn
            self.campaign = campaign
            self.channel = channel
            self.connectedToSystemTimestamp = connectedToSystemTimestamp
            self.customer = customer
            self.customerVoiceActivity = customerVoiceActivity
            self.description = description
            self.disconnectDetails = disconnectDetails
            self.disconnectTimestamp = disconnectTimestamp
            self.id = id
            self.initialContactId = initialContactId
            self.initiationMethod = initiationMethod
            self.initiationTimestamp = initiationTimestamp
            self.lastPausedTimestamp = lastPausedTimestamp
            self.lastResumedTimestamp = lastResumedTimestamp
            self.lastUpdateTimestamp = lastUpdateTimestamp
            self.name = name
            self.previousContactId = previousContactId
            self.qualityMetrics = qualityMetrics
            self.queueInfo = queueInfo
            self.queuePriority = queuePriority
            self.queueTimeAdjustmentSeconds = queueTimeAdjustmentSeconds
            self.relatedContactId = relatedContactId
            self.routingCriteria = routingCriteria
            self.scheduledTimestamp = scheduledTimestamp
            self.segmentAttributes = segmentAttributes
            self.tags = tags
            self.totalPauseCount = totalPauseCount
            self.totalPauseDurationInSeconds = totalPauseDurationInSeconds
            self.wisdomInfo = wisdomInfo
        }
    }

}

extension ConnectClientTypes.Contact: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Contact(agentInfo: \(Swift.String(describing: agentInfo)), answeringMachineDetectionStatus: \(Swift.String(describing: answeringMachineDetectionStatus)), arn: \(Swift.String(describing: arn)), campaign: \(Swift.String(describing: campaign)), channel: \(Swift.String(describing: channel)), connectedToSystemTimestamp: \(Swift.String(describing: connectedToSystemTimestamp)), customer: \(Swift.String(describing: customer)), customerVoiceActivity: \(Swift.String(describing: customerVoiceActivity)), disconnectDetails: \(Swift.String(describing: disconnectDetails)), disconnectTimestamp: \(Swift.String(describing: disconnectTimestamp)), id: \(Swift.String(describing: id)), initialContactId: \(Swift.String(describing: initialContactId)), initiationMethod: \(Swift.String(describing: initiationMethod)), initiationTimestamp: \(Swift.String(describing: initiationTimestamp)), lastPausedTimestamp: \(Swift.String(describing: lastPausedTimestamp)), lastResumedTimestamp: \(Swift.String(describing: lastResumedTimestamp)), lastUpdateTimestamp: \(Swift.String(describing: lastUpdateTimestamp)), previousContactId: \(Swift.String(describing: previousContactId)), qualityMetrics: \(Swift.String(describing: qualityMetrics)), queueInfo: \(Swift.String(describing: queueInfo)), queuePriority: \(Swift.String(describing: queuePriority)), queueTimeAdjustmentSeconds: \(Swift.String(describing: queueTimeAdjustmentSeconds)), relatedContactId: \(Swift.String(describing: relatedContactId)), routingCriteria: \(Swift.String(describing: routingCriteria)), scheduledTimestamp: \(Swift.String(describing: scheduledTimestamp)), segmentAttributes: \(Swift.String(describing: segmentAttributes)), tags: \(Swift.String(describing: tags)), totalPauseCount: \(Swift.String(describing: totalPauseCount)), totalPauseDurationInSeconds: \(Swift.String(describing: totalPauseDurationInSeconds)), wisdomInfo: \(Swift.String(describing: wisdomInfo)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct UpdateContactRoutingDataInput {
    /// The identifier of the contact in this instance of Amazon Connect.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Priority of the contact in the queue. The default priority for new contacts is 5. You can raise the priority of a contact compared to other contacts in the queue by assigning them a higher priority, such as 1 or 2.
    public var queuePriority: Swift.Int?
    /// The number of seconds to add or subtract from the contact's routing age. Contacts are routed to agents on a first-come, first-serve basis. This means that changing their amount of time in queue compared to others also changes their position in queue.
    public var queueTimeAdjustmentSeconds: Swift.Int?
    /// Updates the routing criteria on the contact. These properties can be used to change how a  contact is routed within the queue.
    public var routingCriteria: ConnectClientTypes.RoutingCriteriaInput?

    public init(
        contactId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        queuePriority: Swift.Int? = nil,
        queueTimeAdjustmentSeconds: Swift.Int? = nil,
        routingCriteria: ConnectClientTypes.RoutingCriteriaInput? = nil
    )
    {
        self.contactId = contactId
        self.instanceId = instanceId
        self.queuePriority = queuePriority
        self.queueTimeAdjustmentSeconds = queueTimeAdjustmentSeconds
        self.routingCriteria = routingCriteria
    }
}

public struct DescribeContactOutput {
    /// Information about the contact.
    public var contact: ConnectClientTypes.Contact?

    public init(
        contact: ConnectClientTypes.Contact? = nil
    )
    {
        self.contact = contact
    }
}

extension ActivateEvaluationFormInput {

    static func urlPathProvider(_ value: ActivateEvaluationFormInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let evaluationFormId = value.evaluationFormId else {
            return nil
        }
        return "/evaluation-forms/\(instanceId.urlPercentEncoding())/\(evaluationFormId.urlPercentEncoding())/activate"
    }
}

extension AssociateAnalyticsDataSetInput {

    static func urlPathProvider(_ value: AssociateAnalyticsDataSetInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/analytics-data/instance/\(instanceId.urlPercentEncoding())/association"
    }
}

extension AssociateApprovedOriginInput {

    static func urlPathProvider(_ value: AssociateApprovedOriginInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/approved-origin"
    }
}

extension AssociateBotInput {

    static func urlPathProvider(_ value: AssociateBotInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/bot"
    }
}

extension AssociateDefaultVocabularyInput {

    static func urlPathProvider(_ value: AssociateDefaultVocabularyInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let languageCode = value.languageCode else {
            return nil
        }
        return "/default-vocabulary/\(instanceId.urlPercentEncoding())/\(languageCode.rawValue.urlPercentEncoding())"
    }
}

extension AssociateFlowInput {

    static func urlPathProvider(_ value: AssociateFlowInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/flow-associations/\(instanceId.urlPercentEncoding())"
    }
}

extension AssociateInstanceStorageConfigInput {

    static func urlPathProvider(_ value: AssociateInstanceStorageConfigInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/storage-config"
    }
}

extension AssociateLambdaFunctionInput {

    static func urlPathProvider(_ value: AssociateLambdaFunctionInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/lambda-function"
    }
}

extension AssociateLexBotInput {

    static func urlPathProvider(_ value: AssociateLexBotInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/lex-bot"
    }
}

extension AssociatePhoneNumberContactFlowInput {

    static func urlPathProvider(_ value: AssociatePhoneNumberContactFlowInput) -> Swift.String? {
        guard let phoneNumberId = value.phoneNumberId else {
            return nil
        }
        return "/phone-number/\(phoneNumberId.urlPercentEncoding())/contact-flow"
    }
}

extension AssociateQueueQuickConnectsInput {

    static func urlPathProvider(_ value: AssociateQueueQuickConnectsInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        return "/queues/\(instanceId.urlPercentEncoding())/\(queueId.urlPercentEncoding())/associate-quick-connects"
    }
}

extension AssociateRoutingProfileQueuesInput {

    static func urlPathProvider(_ value: AssociateRoutingProfileQueuesInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let routingProfileId = value.routingProfileId else {
            return nil
        }
        return "/routing-profiles/\(instanceId.urlPercentEncoding())/\(routingProfileId.urlPercentEncoding())/associate-queues"
    }
}

extension AssociateSecurityKeyInput {

    static func urlPathProvider(_ value: AssociateSecurityKeyInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/security-key"
    }
}

extension AssociateTrafficDistributionGroupUserInput {

    static func urlPathProvider(_ value: AssociateTrafficDistributionGroupUserInput) -> Swift.String? {
        guard let trafficDistributionGroupId = value.trafficDistributionGroupId else {
            return nil
        }
        return "/traffic-distribution-group/\(trafficDistributionGroupId.urlPercentEncoding())/user"
    }
}

extension AssociateUserProficienciesInput {

    static func urlPathProvider(_ value: AssociateUserProficienciesInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let userId = value.userId else {
            return nil
        }
        return "/users/\(instanceId.urlPercentEncoding())/\(userId.urlPercentEncoding())/associate-proficiencies"
    }
}

extension BatchAssociateAnalyticsDataSetInput {

    static func urlPathProvider(_ value: BatchAssociateAnalyticsDataSetInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/analytics-data/instance/\(instanceId.urlPercentEncoding())/associations"
    }
}

extension BatchDisassociateAnalyticsDataSetInput {

    static func urlPathProvider(_ value: BatchDisassociateAnalyticsDataSetInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/analytics-data/instance/\(instanceId.urlPercentEncoding())/associations"
    }
}

extension BatchGetAttachedFileMetadataInput {

    static func urlPathProvider(_ value: BatchGetAttachedFileMetadataInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/attached-files/\(instanceId.urlPercentEncoding())"
    }
}

extension BatchGetAttachedFileMetadataInput {

    static func queryItemProvider(_ value: BatchGetAttachedFileMetadataInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let associatedResourceArn = value.associatedResourceArn else {
            let message = "Creating a URL Query Item failed. associatedResourceArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let associatedResourceArnQueryItem = Smithy.URIQueryItem(name: "associatedResourceArn".urlPercentEncoding(), value: Swift.String(associatedResourceArn).urlPercentEncoding())
        items.append(associatedResourceArnQueryItem)
        return items
    }
}

extension BatchGetFlowAssociationInput {

    static func urlPathProvider(_ value: BatchGetFlowAssociationInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/flow-associations-batch/\(instanceId.urlPercentEncoding())"
    }
}

extension BatchPutContactInput {

    static func urlPathProvider(_ value: BatchPutContactInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/contact/batch/\(instanceId.urlPercentEncoding())"
    }
}

extension ClaimPhoneNumberInput {

    static func urlPathProvider(_ value: ClaimPhoneNumberInput) -> Swift.String? {
        return "/phone-number/claim"
    }
}

extension CompleteAttachedFileUploadInput {

    static func urlPathProvider(_ value: CompleteAttachedFileUploadInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let fileId = value.fileId else {
            return nil
        }
        return "/attached-files/\(instanceId.urlPercentEncoding())/\(fileId.urlPercentEncoding())"
    }
}

extension CompleteAttachedFileUploadInput {

    static func queryItemProvider(_ value: CompleteAttachedFileUploadInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let associatedResourceArn = value.associatedResourceArn else {
            let message = "Creating a URL Query Item failed. associatedResourceArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let associatedResourceArnQueryItem = Smithy.URIQueryItem(name: "associatedResourceArn".urlPercentEncoding(), value: Swift.String(associatedResourceArn).urlPercentEncoding())
        items.append(associatedResourceArnQueryItem)
        return items
    }
}

extension CreateAgentStatusInput {

    static func urlPathProvider(_ value: CreateAgentStatusInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/agent-status/\(instanceId.urlPercentEncoding())"
    }
}

extension CreateContactFlowInput {

    static func urlPathProvider(_ value: CreateContactFlowInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/contact-flows/\(instanceId.urlPercentEncoding())"
    }
}

extension CreateContactFlowModuleInput {

    static func urlPathProvider(_ value: CreateContactFlowModuleInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/contact-flow-modules/\(instanceId.urlPercentEncoding())"
    }
}

extension CreateEvaluationFormInput {

    static func urlPathProvider(_ value: CreateEvaluationFormInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/evaluation-forms/\(instanceId.urlPercentEncoding())"
    }
}

extension CreateHoursOfOperationInput {

    static func urlPathProvider(_ value: CreateHoursOfOperationInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/hours-of-operations/\(instanceId.urlPercentEncoding())"
    }
}

extension CreateInstanceInput {

    static func urlPathProvider(_ value: CreateInstanceInput) -> Swift.String? {
        return "/instance"
    }
}

extension CreateIntegrationAssociationInput {

    static func urlPathProvider(_ value: CreateIntegrationAssociationInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/integration-associations"
    }
}

extension CreateParticipantInput {

    static func urlPathProvider(_ value: CreateParticipantInput) -> Swift.String? {
        return "/contact/create-participant"
    }
}

extension CreatePersistentContactAssociationInput {

    static func urlPathProvider(_ value: CreatePersistentContactAssociationInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let initialContactId = value.initialContactId else {
            return nil
        }
        return "/contact/persistent-contact-association/\(instanceId.urlPercentEncoding())/\(initialContactId.urlPercentEncoding())"
    }
}

extension CreatePredefinedAttributeInput {

    static func urlPathProvider(_ value: CreatePredefinedAttributeInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/predefined-attributes/\(instanceId.urlPercentEncoding())"
    }
}

extension CreatePromptInput {

    static func urlPathProvider(_ value: CreatePromptInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/prompts/\(instanceId.urlPercentEncoding())"
    }
}

extension CreateQueueInput {

    static func urlPathProvider(_ value: CreateQueueInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/queues/\(instanceId.urlPercentEncoding())"
    }
}

extension CreateQuickConnectInput {

    static func urlPathProvider(_ value: CreateQuickConnectInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/quick-connects/\(instanceId.urlPercentEncoding())"
    }
}

extension CreateRoutingProfileInput {

    static func urlPathProvider(_ value: CreateRoutingProfileInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/routing-profiles/\(instanceId.urlPercentEncoding())"
    }
}

extension CreateRuleInput {

    static func urlPathProvider(_ value: CreateRuleInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/rules/\(instanceId.urlPercentEncoding())"
    }
}

extension CreateSecurityProfileInput {

    static func urlPathProvider(_ value: CreateSecurityProfileInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/security-profiles/\(instanceId.urlPercentEncoding())"
    }
}

extension CreateTaskTemplateInput {

    static func urlPathProvider(_ value: CreateTaskTemplateInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/task/template"
    }
}

extension CreateTrafficDistributionGroupInput {

    static func urlPathProvider(_ value: CreateTrafficDistributionGroupInput) -> Swift.String? {
        return "/traffic-distribution-group"
    }
}

extension CreateUseCaseInput {

    static func urlPathProvider(_ value: CreateUseCaseInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let integrationAssociationId = value.integrationAssociationId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/integration-associations/\(integrationAssociationId.urlPercentEncoding())/use-cases"
    }
}

extension CreateUserInput {

    static func urlPathProvider(_ value: CreateUserInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/users/\(instanceId.urlPercentEncoding())"
    }
}

extension CreateUserHierarchyGroupInput {

    static func urlPathProvider(_ value: CreateUserHierarchyGroupInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/user-hierarchy-groups/\(instanceId.urlPercentEncoding())"
    }
}

extension CreateViewInput {

    static func urlPathProvider(_ value: CreateViewInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/views/\(instanceId.urlPercentEncoding())"
    }
}

extension CreateViewVersionInput {

    static func urlPathProvider(_ value: CreateViewVersionInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let viewId = value.viewId else {
            return nil
        }
        return "/views/\(instanceId.urlPercentEncoding())/\(viewId.urlPercentEncoding())/versions"
    }
}

extension CreateVocabularyInput {

    static func urlPathProvider(_ value: CreateVocabularyInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/vocabulary/\(instanceId.urlPercentEncoding())"
    }
}

extension DeactivateEvaluationFormInput {

    static func urlPathProvider(_ value: DeactivateEvaluationFormInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let evaluationFormId = value.evaluationFormId else {
            return nil
        }
        return "/evaluation-forms/\(instanceId.urlPercentEncoding())/\(evaluationFormId.urlPercentEncoding())/deactivate"
    }
}

extension DeleteAttachedFileInput {

    static func urlPathProvider(_ value: DeleteAttachedFileInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let fileId = value.fileId else {
            return nil
        }
        return "/attached-files/\(instanceId.urlPercentEncoding())/\(fileId.urlPercentEncoding())"
    }
}

extension DeleteAttachedFileInput {

    static func queryItemProvider(_ value: DeleteAttachedFileInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let associatedResourceArn = value.associatedResourceArn else {
            let message = "Creating a URL Query Item failed. associatedResourceArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let associatedResourceArnQueryItem = Smithy.URIQueryItem(name: "associatedResourceArn".urlPercentEncoding(), value: Swift.String(associatedResourceArn).urlPercentEncoding())
        items.append(associatedResourceArnQueryItem)
        return items
    }
}

extension DeleteContactEvaluationInput {

    static func urlPathProvider(_ value: DeleteContactEvaluationInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let evaluationId = value.evaluationId else {
            return nil
        }
        return "/contact-evaluations/\(instanceId.urlPercentEncoding())/\(evaluationId.urlPercentEncoding())"
    }
}

extension DeleteContactFlowInput {

    static func urlPathProvider(_ value: DeleteContactFlowInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let contactFlowId = value.contactFlowId else {
            return nil
        }
        return "/contact-flows/\(instanceId.urlPercentEncoding())/\(contactFlowId.urlPercentEncoding())"
    }
}

extension DeleteContactFlowModuleInput {

    static func urlPathProvider(_ value: DeleteContactFlowModuleInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let contactFlowModuleId = value.contactFlowModuleId else {
            return nil
        }
        return "/contact-flow-modules/\(instanceId.urlPercentEncoding())/\(contactFlowModuleId.urlPercentEncoding())"
    }
}

extension DeleteEvaluationFormInput {

    static func urlPathProvider(_ value: DeleteEvaluationFormInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let evaluationFormId = value.evaluationFormId else {
            return nil
        }
        return "/evaluation-forms/\(instanceId.urlPercentEncoding())/\(evaluationFormId.urlPercentEncoding())"
    }
}

extension DeleteEvaluationFormInput {

    static func queryItemProvider(_ value: DeleteEvaluationFormInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let evaluationFormVersion = value.evaluationFormVersion {
            let evaluationFormVersionQueryItem = Smithy.URIQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(evaluationFormVersion).urlPercentEncoding())
            items.append(evaluationFormVersionQueryItem)
        }
        return items
    }
}

extension DeleteHoursOfOperationInput {

    static func urlPathProvider(_ value: DeleteHoursOfOperationInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let hoursOfOperationId = value.hoursOfOperationId else {
            return nil
        }
        return "/hours-of-operations/\(instanceId.urlPercentEncoding())/\(hoursOfOperationId.urlPercentEncoding())"
    }
}

extension DeleteInstanceInput {

    static func urlPathProvider(_ value: DeleteInstanceInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())"
    }
}

extension DeleteIntegrationAssociationInput {

    static func urlPathProvider(_ value: DeleteIntegrationAssociationInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let integrationAssociationId = value.integrationAssociationId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/integration-associations/\(integrationAssociationId.urlPercentEncoding())"
    }
}

extension DeletePredefinedAttributeInput {

    static func urlPathProvider(_ value: DeletePredefinedAttributeInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/predefined-attributes/\(instanceId.urlPercentEncoding())/\(name.urlPercentEncoding())"
    }
}

extension DeletePromptInput {

    static func urlPathProvider(_ value: DeletePromptInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let promptId = value.promptId else {
            return nil
        }
        return "/prompts/\(instanceId.urlPercentEncoding())/\(promptId.urlPercentEncoding())"
    }
}

extension DeleteQueueInput {

    static func urlPathProvider(_ value: DeleteQueueInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        return "/queues/\(instanceId.urlPercentEncoding())/\(queueId.urlPercentEncoding())"
    }
}

extension DeleteQuickConnectInput {

    static func urlPathProvider(_ value: DeleteQuickConnectInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let quickConnectId = value.quickConnectId else {
            return nil
        }
        return "/quick-connects/\(instanceId.urlPercentEncoding())/\(quickConnectId.urlPercentEncoding())"
    }
}

extension DeleteRoutingProfileInput {

    static func urlPathProvider(_ value: DeleteRoutingProfileInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let routingProfileId = value.routingProfileId else {
            return nil
        }
        return "/routing-profiles/\(instanceId.urlPercentEncoding())/\(routingProfileId.urlPercentEncoding())"
    }
}

extension DeleteRuleInput {

    static func urlPathProvider(_ value: DeleteRuleInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let ruleId = value.ruleId else {
            return nil
        }
        return "/rules/\(instanceId.urlPercentEncoding())/\(ruleId.urlPercentEncoding())"
    }
}

extension DeleteSecurityProfileInput {

    static func urlPathProvider(_ value: DeleteSecurityProfileInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let securityProfileId = value.securityProfileId else {
            return nil
        }
        return "/security-profiles/\(instanceId.urlPercentEncoding())/\(securityProfileId.urlPercentEncoding())"
    }
}

extension DeleteTaskTemplateInput {

    static func urlPathProvider(_ value: DeleteTaskTemplateInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let taskTemplateId = value.taskTemplateId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/task/template/\(taskTemplateId.urlPercentEncoding())"
    }
}

extension DeleteTrafficDistributionGroupInput {

    static func urlPathProvider(_ value: DeleteTrafficDistributionGroupInput) -> Swift.String? {
        guard let trafficDistributionGroupId = value.trafficDistributionGroupId else {
            return nil
        }
        return "/traffic-distribution-group/\(trafficDistributionGroupId.urlPercentEncoding())"
    }
}

extension DeleteUseCaseInput {

    static func urlPathProvider(_ value: DeleteUseCaseInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let integrationAssociationId = value.integrationAssociationId else {
            return nil
        }
        guard let useCaseId = value.useCaseId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/integration-associations/\(integrationAssociationId.urlPercentEncoding())/use-cases/\(useCaseId.urlPercentEncoding())"
    }
}

extension DeleteUserInput {

    static func urlPathProvider(_ value: DeleteUserInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let userId = value.userId else {
            return nil
        }
        return "/users/\(instanceId.urlPercentEncoding())/\(userId.urlPercentEncoding())"
    }
}

extension DeleteUserHierarchyGroupInput {

    static func urlPathProvider(_ value: DeleteUserHierarchyGroupInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let hierarchyGroupId = value.hierarchyGroupId else {
            return nil
        }
        return "/user-hierarchy-groups/\(instanceId.urlPercentEncoding())/\(hierarchyGroupId.urlPercentEncoding())"
    }
}

extension DeleteViewInput {

    static func urlPathProvider(_ value: DeleteViewInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let viewId = value.viewId else {
            return nil
        }
        return "/views/\(instanceId.urlPercentEncoding())/\(viewId.urlPercentEncoding())"
    }
}

extension DeleteViewVersionInput {

    static func urlPathProvider(_ value: DeleteViewVersionInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let viewId = value.viewId else {
            return nil
        }
        guard let viewVersion = value.viewVersion else {
            return nil
        }
        return "/views/\(instanceId.urlPercentEncoding())/\(viewId.urlPercentEncoding())/versions/\(viewVersion)"
    }
}

extension DeleteVocabularyInput {

    static func urlPathProvider(_ value: DeleteVocabularyInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let vocabularyId = value.vocabularyId else {
            return nil
        }
        return "/vocabulary-remove/\(instanceId.urlPercentEncoding())/\(vocabularyId.urlPercentEncoding())"
    }
}

extension DescribeAgentStatusInput {

    static func urlPathProvider(_ value: DescribeAgentStatusInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let agentStatusId = value.agentStatusId else {
            return nil
        }
        return "/agent-status/\(instanceId.urlPercentEncoding())/\(agentStatusId.urlPercentEncoding())"
    }
}

extension DescribeAuthenticationProfileInput {

    static func urlPathProvider(_ value: DescribeAuthenticationProfileInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let authenticationProfileId = value.authenticationProfileId else {
            return nil
        }
        return "/authentication-profiles/\(instanceId.urlPercentEncoding())/\(authenticationProfileId.urlPercentEncoding())"
    }
}

extension DescribeContactInput {

    static func urlPathProvider(_ value: DescribeContactInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let contactId = value.contactId else {
            return nil
        }
        return "/contacts/\(instanceId.urlPercentEncoding())/\(contactId.urlPercentEncoding())"
    }
}

extension DescribeContactEvaluationInput {

    static func urlPathProvider(_ value: DescribeContactEvaluationInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let evaluationId = value.evaluationId else {
            return nil
        }
        return "/contact-evaluations/\(instanceId.urlPercentEncoding())/\(evaluationId.urlPercentEncoding())"
    }
}

extension DescribeContactFlowInput {

    static func urlPathProvider(_ value: DescribeContactFlowInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let contactFlowId = value.contactFlowId else {
            return nil
        }
        return "/contact-flows/\(instanceId.urlPercentEncoding())/\(contactFlowId.urlPercentEncoding())"
    }
}

extension DescribeContactFlowModuleInput {

    static func urlPathProvider(_ value: DescribeContactFlowModuleInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let contactFlowModuleId = value.contactFlowModuleId else {
            return nil
        }
        return "/contact-flow-modules/\(instanceId.urlPercentEncoding())/\(contactFlowModuleId.urlPercentEncoding())"
    }
}

extension DescribeEvaluationFormInput {

    static func urlPathProvider(_ value: DescribeEvaluationFormInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let evaluationFormId = value.evaluationFormId else {
            return nil
        }
        return "/evaluation-forms/\(instanceId.urlPercentEncoding())/\(evaluationFormId.urlPercentEncoding())"
    }
}

extension DescribeEvaluationFormInput {

    static func queryItemProvider(_ value: DescribeEvaluationFormInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let evaluationFormVersion = value.evaluationFormVersion {
            let evaluationFormVersionQueryItem = Smithy.URIQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(evaluationFormVersion).urlPercentEncoding())
            items.append(evaluationFormVersionQueryItem)
        }
        return items
    }
}

extension DescribeHoursOfOperationInput {

    static func urlPathProvider(_ value: DescribeHoursOfOperationInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let hoursOfOperationId = value.hoursOfOperationId else {
            return nil
        }
        return "/hours-of-operations/\(instanceId.urlPercentEncoding())/\(hoursOfOperationId.urlPercentEncoding())"
    }
}

extension DescribeInstanceInput {

    static func urlPathProvider(_ value: DescribeInstanceInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())"
    }
}

extension DescribeInstanceAttributeInput {

    static func urlPathProvider(_ value: DescribeInstanceAttributeInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let attributeType = value.attributeType else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/attribute/\(attributeType.rawValue.urlPercentEncoding())"
    }
}

extension DescribeInstanceStorageConfigInput {

    static func urlPathProvider(_ value: DescribeInstanceStorageConfigInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let associationId = value.associationId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/storage-config/\(associationId.urlPercentEncoding())"
    }
}

extension DescribeInstanceStorageConfigInput {

    static func queryItemProvider(_ value: DescribeInstanceStorageConfigInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let resourceType = value.resourceType else {
            let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceTypeQueryItem = Smithy.URIQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
        items.append(resourceTypeQueryItem)
        return items
    }
}

extension DescribePhoneNumberInput {

    static func urlPathProvider(_ value: DescribePhoneNumberInput) -> Swift.String? {
        guard let phoneNumberId = value.phoneNumberId else {
            return nil
        }
        return "/phone-number/\(phoneNumberId.urlPercentEncoding())"
    }
}

extension DescribePredefinedAttributeInput {

    static func urlPathProvider(_ value: DescribePredefinedAttributeInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/predefined-attributes/\(instanceId.urlPercentEncoding())/\(name.urlPercentEncoding())"
    }
}

extension DescribePromptInput {

    static func urlPathProvider(_ value: DescribePromptInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let promptId = value.promptId else {
            return nil
        }
        return "/prompts/\(instanceId.urlPercentEncoding())/\(promptId.urlPercentEncoding())"
    }
}

extension DescribeQueueInput {

    static func urlPathProvider(_ value: DescribeQueueInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        return "/queues/\(instanceId.urlPercentEncoding())/\(queueId.urlPercentEncoding())"
    }
}

extension DescribeQuickConnectInput {

    static func urlPathProvider(_ value: DescribeQuickConnectInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let quickConnectId = value.quickConnectId else {
            return nil
        }
        return "/quick-connects/\(instanceId.urlPercentEncoding())/\(quickConnectId.urlPercentEncoding())"
    }
}

extension DescribeRoutingProfileInput {

    static func urlPathProvider(_ value: DescribeRoutingProfileInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let routingProfileId = value.routingProfileId else {
            return nil
        }
        return "/routing-profiles/\(instanceId.urlPercentEncoding())/\(routingProfileId.urlPercentEncoding())"
    }
}

extension DescribeRuleInput {

    static func urlPathProvider(_ value: DescribeRuleInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let ruleId = value.ruleId else {
            return nil
        }
        return "/rules/\(instanceId.urlPercentEncoding())/\(ruleId.urlPercentEncoding())"
    }
}

extension DescribeSecurityProfileInput {

    static func urlPathProvider(_ value: DescribeSecurityProfileInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let securityProfileId = value.securityProfileId else {
            return nil
        }
        return "/security-profiles/\(instanceId.urlPercentEncoding())/\(securityProfileId.urlPercentEncoding())"
    }
}

extension DescribeTrafficDistributionGroupInput {

    static func urlPathProvider(_ value: DescribeTrafficDistributionGroupInput) -> Swift.String? {
        guard let trafficDistributionGroupId = value.trafficDistributionGroupId else {
            return nil
        }
        return "/traffic-distribution-group/\(trafficDistributionGroupId.urlPercentEncoding())"
    }
}

extension DescribeUserInput {

    static func urlPathProvider(_ value: DescribeUserInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let userId = value.userId else {
            return nil
        }
        return "/users/\(instanceId.urlPercentEncoding())/\(userId.urlPercentEncoding())"
    }
}

extension DescribeUserHierarchyGroupInput {

    static func urlPathProvider(_ value: DescribeUserHierarchyGroupInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let hierarchyGroupId = value.hierarchyGroupId else {
            return nil
        }
        return "/user-hierarchy-groups/\(instanceId.urlPercentEncoding())/\(hierarchyGroupId.urlPercentEncoding())"
    }
}

extension DescribeUserHierarchyStructureInput {

    static func urlPathProvider(_ value: DescribeUserHierarchyStructureInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/user-hierarchy-structure/\(instanceId.urlPercentEncoding())"
    }
}

extension DescribeViewInput {

    static func urlPathProvider(_ value: DescribeViewInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let viewId = value.viewId else {
            return nil
        }
        return "/views/\(instanceId.urlPercentEncoding())/\(viewId.urlPercentEncoding())"
    }
}

extension DescribeVocabularyInput {

    static func urlPathProvider(_ value: DescribeVocabularyInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let vocabularyId = value.vocabularyId else {
            return nil
        }
        return "/vocabulary/\(instanceId.urlPercentEncoding())/\(vocabularyId.urlPercentEncoding())"
    }
}

extension DisassociateAnalyticsDataSetInput {

    static func urlPathProvider(_ value: DisassociateAnalyticsDataSetInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/analytics-data/instance/\(instanceId.urlPercentEncoding())/association"
    }
}

extension DisassociateApprovedOriginInput {

    static func urlPathProvider(_ value: DisassociateApprovedOriginInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/approved-origin"
    }
}

extension DisassociateApprovedOriginInput {

    static func queryItemProvider(_ value: DisassociateApprovedOriginInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let origin = value.origin else {
            let message = "Creating a URL Query Item failed. origin is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let originQueryItem = Smithy.URIQueryItem(name: "origin".urlPercentEncoding(), value: Swift.String(origin).urlPercentEncoding())
        items.append(originQueryItem)
        return items
    }
}

extension DisassociateBotInput {

    static func urlPathProvider(_ value: DisassociateBotInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/bot"
    }
}

extension DisassociateFlowInput {

    static func urlPathProvider(_ value: DisassociateFlowInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let resourceId = value.resourceId else {
            return nil
        }
        guard let resourceType = value.resourceType else {
            return nil
        }
        return "/flow-associations/\(instanceId.urlPercentEncoding())/\(resourceId.urlPercentEncoding())/\(resourceType.rawValue.urlPercentEncoding())"
    }
}

extension DisassociateInstanceStorageConfigInput {

    static func urlPathProvider(_ value: DisassociateInstanceStorageConfigInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let associationId = value.associationId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/storage-config/\(associationId.urlPercentEncoding())"
    }
}

extension DisassociateInstanceStorageConfigInput {

    static func queryItemProvider(_ value: DisassociateInstanceStorageConfigInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let resourceType = value.resourceType else {
            let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceTypeQueryItem = Smithy.URIQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
        items.append(resourceTypeQueryItem)
        return items
    }
}

extension DisassociateLambdaFunctionInput {

    static func urlPathProvider(_ value: DisassociateLambdaFunctionInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/lambda-function"
    }
}

extension DisassociateLambdaFunctionInput {

    static func queryItemProvider(_ value: DisassociateLambdaFunctionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let functionArn = value.functionArn else {
            let message = "Creating a URL Query Item failed. functionArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let functionArnQueryItem = Smithy.URIQueryItem(name: "functionArn".urlPercentEncoding(), value: Swift.String(functionArn).urlPercentEncoding())
        items.append(functionArnQueryItem)
        return items
    }
}

extension DisassociateLexBotInput {

    static func urlPathProvider(_ value: DisassociateLexBotInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/lex-bot"
    }
}

extension DisassociateLexBotInput {

    static func queryItemProvider(_ value: DisassociateLexBotInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let lexRegion = value.lexRegion else {
            let message = "Creating a URL Query Item failed. lexRegion is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let lexRegionQueryItem = Smithy.URIQueryItem(name: "lexRegion".urlPercentEncoding(), value: Swift.String(lexRegion).urlPercentEncoding())
        items.append(lexRegionQueryItem)
        guard let botName = value.botName else {
            let message = "Creating a URL Query Item failed. botName is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let botNameQueryItem = Smithy.URIQueryItem(name: "botName".urlPercentEncoding(), value: Swift.String(botName).urlPercentEncoding())
        items.append(botNameQueryItem)
        return items
    }
}

extension DisassociatePhoneNumberContactFlowInput {

    static func urlPathProvider(_ value: DisassociatePhoneNumberContactFlowInput) -> Swift.String? {
        guard let phoneNumberId = value.phoneNumberId else {
            return nil
        }
        return "/phone-number/\(phoneNumberId.urlPercentEncoding())/contact-flow"
    }
}

extension DisassociatePhoneNumberContactFlowInput {

    static func queryItemProvider(_ value: DisassociatePhoneNumberContactFlowInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let instanceId = value.instanceId else {
            let message = "Creating a URL Query Item failed. instanceId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let instanceIdQueryItem = Smithy.URIQueryItem(name: "instanceId".urlPercentEncoding(), value: Swift.String(instanceId).urlPercentEncoding())
        items.append(instanceIdQueryItem)
        return items
    }
}

extension DisassociateQueueQuickConnectsInput {

    static func urlPathProvider(_ value: DisassociateQueueQuickConnectsInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        return "/queues/\(instanceId.urlPercentEncoding())/\(queueId.urlPercentEncoding())/disassociate-quick-connects"
    }
}

extension DisassociateRoutingProfileQueuesInput {

    static func urlPathProvider(_ value: DisassociateRoutingProfileQueuesInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let routingProfileId = value.routingProfileId else {
            return nil
        }
        return "/routing-profiles/\(instanceId.urlPercentEncoding())/\(routingProfileId.urlPercentEncoding())/disassociate-queues"
    }
}

extension DisassociateSecurityKeyInput {

    static func urlPathProvider(_ value: DisassociateSecurityKeyInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let associationId = value.associationId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/security-key/\(associationId.urlPercentEncoding())"
    }
}

extension DisassociateTrafficDistributionGroupUserInput {

    static func urlPathProvider(_ value: DisassociateTrafficDistributionGroupUserInput) -> Swift.String? {
        guard let trafficDistributionGroupId = value.trafficDistributionGroupId else {
            return nil
        }
        return "/traffic-distribution-group/\(trafficDistributionGroupId.urlPercentEncoding())/user"
    }
}

extension DisassociateTrafficDistributionGroupUserInput {

    static func queryItemProvider(_ value: DisassociateTrafficDistributionGroupUserInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let instanceId = value.instanceId else {
            let message = "Creating a URL Query Item failed. instanceId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let instanceIdQueryItem = Smithy.URIQueryItem(name: "InstanceId".urlPercentEncoding(), value: Swift.String(instanceId).urlPercentEncoding())
        items.append(instanceIdQueryItem)
        guard let userId = value.userId else {
            let message = "Creating a URL Query Item failed. userId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let userIdQueryItem = Smithy.URIQueryItem(name: "UserId".urlPercentEncoding(), value: Swift.String(userId).urlPercentEncoding())
        items.append(userIdQueryItem)
        return items
    }
}

extension DisassociateUserProficienciesInput {

    static func urlPathProvider(_ value: DisassociateUserProficienciesInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let userId = value.userId else {
            return nil
        }
        return "/users/\(instanceId.urlPercentEncoding())/\(userId.urlPercentEncoding())/disassociate-proficiencies"
    }
}

extension DismissUserContactInput {

    static func urlPathProvider(_ value: DismissUserContactInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let userId = value.userId else {
            return nil
        }
        return "/users/\(instanceId.urlPercentEncoding())/\(userId.urlPercentEncoding())/contact"
    }
}

extension GetAttachedFileInput {

    static func urlPathProvider(_ value: GetAttachedFileInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let fileId = value.fileId else {
            return nil
        }
        return "/attached-files/\(instanceId.urlPercentEncoding())/\(fileId.urlPercentEncoding())"
    }
}

extension GetAttachedFileInput {

    static func queryItemProvider(_ value: GetAttachedFileInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let urlExpiryInSeconds = value.urlExpiryInSeconds {
            let urlExpiryInSecondsQueryItem = Smithy.URIQueryItem(name: "urlExpiryInSeconds".urlPercentEncoding(), value: Swift.String(urlExpiryInSeconds).urlPercentEncoding())
            items.append(urlExpiryInSecondsQueryItem)
        }
        guard let associatedResourceArn = value.associatedResourceArn else {
            let message = "Creating a URL Query Item failed. associatedResourceArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let associatedResourceArnQueryItem = Smithy.URIQueryItem(name: "associatedResourceArn".urlPercentEncoding(), value: Swift.String(associatedResourceArn).urlPercentEncoding())
        items.append(associatedResourceArnQueryItem)
        return items
    }
}

extension GetContactAttributesInput {

    static func urlPathProvider(_ value: GetContactAttributesInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let initialContactId = value.initialContactId else {
            return nil
        }
        return "/contact/attributes/\(instanceId.urlPercentEncoding())/\(initialContactId.urlPercentEncoding())"
    }
}

extension GetCurrentMetricDataInput {

    static func urlPathProvider(_ value: GetCurrentMetricDataInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/metrics/current/\(instanceId.urlPercentEncoding())"
    }
}

extension GetCurrentUserDataInput {

    static func urlPathProvider(_ value: GetCurrentUserDataInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/metrics/userdata/\(instanceId.urlPercentEncoding())"
    }
}

extension GetFederationTokenInput {

    static func urlPathProvider(_ value: GetFederationTokenInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/user/federate/\(instanceId.urlPercentEncoding())"
    }
}

extension GetFlowAssociationInput {

    static func urlPathProvider(_ value: GetFlowAssociationInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let resourceId = value.resourceId else {
            return nil
        }
        guard let resourceType = value.resourceType else {
            return nil
        }
        return "/flow-associations/\(instanceId.urlPercentEncoding())/\(resourceId.urlPercentEncoding())/\(resourceType.rawValue.urlPercentEncoding())"
    }
}

extension GetMetricDataInput {

    static func urlPathProvider(_ value: GetMetricDataInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/metrics/historical/\(instanceId.urlPercentEncoding())"
    }
}

extension GetMetricDataV2Input {

    static func urlPathProvider(_ value: GetMetricDataV2Input) -> Swift.String? {
        return "/metrics/data"
    }
}

extension GetPromptFileInput {

    static func urlPathProvider(_ value: GetPromptFileInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let promptId = value.promptId else {
            return nil
        }
        return "/prompts/\(instanceId.urlPercentEncoding())/\(promptId.urlPercentEncoding())/file"
    }
}

extension GetTaskTemplateInput {

    static func urlPathProvider(_ value: GetTaskTemplateInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let taskTemplateId = value.taskTemplateId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/task/template/\(taskTemplateId.urlPercentEncoding())"
    }
}

extension GetTaskTemplateInput {

    static func queryItemProvider(_ value: GetTaskTemplateInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let snapshotVersion = value.snapshotVersion {
            let snapshotVersionQueryItem = Smithy.URIQueryItem(name: "snapshotVersion".urlPercentEncoding(), value: Swift.String(snapshotVersion).urlPercentEncoding())
            items.append(snapshotVersionQueryItem)
        }
        return items
    }
}

extension GetTrafficDistributionInput {

    static func urlPathProvider(_ value: GetTrafficDistributionInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/traffic-distribution/\(id.urlPercentEncoding())"
    }
}

extension ImportPhoneNumberInput {

    static func urlPathProvider(_ value: ImportPhoneNumberInput) -> Swift.String? {
        return "/phone-number/import"
    }
}

extension ListAgentStatusesInput {

    static func urlPathProvider(_ value: ListAgentStatusesInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/agent-status/\(instanceId.urlPercentEncoding())"
    }
}

extension ListAgentStatusesInput {

    static func queryItemProvider(_ value: ListAgentStatusesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let agentStatusTypes = value.agentStatusTypes {
            agentStatusTypes.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "AgentStatusTypes".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension ListAnalyticsDataAssociationsInput {

    static func urlPathProvider(_ value: ListAnalyticsDataAssociationsInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/analytics-data/instance/\(instanceId.urlPercentEncoding())/association"
    }
}

extension ListAnalyticsDataAssociationsInput {

    static func queryItemProvider(_ value: ListAnalyticsDataAssociationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let dataSetId = value.dataSetId {
            let dataSetIdQueryItem = Smithy.URIQueryItem(name: "DataSetId".urlPercentEncoding(), value: Swift.String(dataSetId).urlPercentEncoding())
            items.append(dataSetIdQueryItem)
        }
        return items
    }
}

extension ListApprovedOriginsInput {

    static func urlPathProvider(_ value: ListApprovedOriginsInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/approved-origins"
    }
}

extension ListApprovedOriginsInput {

    static func queryItemProvider(_ value: ListApprovedOriginsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListAuthenticationProfilesInput {

    static func urlPathProvider(_ value: ListAuthenticationProfilesInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/authentication-profiles-summary/\(instanceId.urlPercentEncoding())"
    }
}

extension ListAuthenticationProfilesInput {

    static func queryItemProvider(_ value: ListAuthenticationProfilesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListBotsInput {

    static func urlPathProvider(_ value: ListBotsInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/bots"
    }
}

extension ListBotsInput {

    static func queryItemProvider(_ value: ListBotsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let lexVersion = value.lexVersion else {
            let message = "Creating a URL Query Item failed. lexVersion is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let lexVersionQueryItem = Smithy.URIQueryItem(name: "lexVersion".urlPercentEncoding(), value: Swift.String(lexVersion.rawValue).urlPercentEncoding())
        items.append(lexVersionQueryItem)
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListContactEvaluationsInput {

    static func urlPathProvider(_ value: ListContactEvaluationsInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/contact-evaluations/\(instanceId.urlPercentEncoding())"
    }
}

extension ListContactEvaluationsInput {

    static func queryItemProvider(_ value: ListContactEvaluationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        guard let contactId = value.contactId else {
            let message = "Creating a URL Query Item failed. contactId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let contactIdQueryItem = Smithy.URIQueryItem(name: "contactId".urlPercentEncoding(), value: Swift.String(contactId).urlPercentEncoding())
        items.append(contactIdQueryItem)
        return items
    }
}

extension ListContactFlowModulesInput {

    static func urlPathProvider(_ value: ListContactFlowModulesInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/contact-flow-modules-summary/\(instanceId.urlPercentEncoding())"
    }
}

extension ListContactFlowModulesInput {

    static func queryItemProvider(_ value: ListContactFlowModulesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let contactFlowModuleState = value.contactFlowModuleState {
            let contactFlowModuleStateQueryItem = Smithy.URIQueryItem(name: "state".urlPercentEncoding(), value: Swift.String(contactFlowModuleState.rawValue).urlPercentEncoding())
            items.append(contactFlowModuleStateQueryItem)
        }
        return items
    }
}

extension ListContactFlowsInput {

    static func urlPathProvider(_ value: ListContactFlowsInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/contact-flows-summary/\(instanceId.urlPercentEncoding())"
    }
}

extension ListContactFlowsInput {

    static func queryItemProvider(_ value: ListContactFlowsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let contactFlowTypes = value.contactFlowTypes {
            contactFlowTypes.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "contactFlowTypes".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension ListContactReferencesInput {

    static func urlPathProvider(_ value: ListContactReferencesInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let contactId = value.contactId else {
            return nil
        }
        return "/contact/references/\(instanceId.urlPercentEncoding())/\(contactId.urlPercentEncoding())"
    }
}

extension ListContactReferencesInput {

    static func queryItemProvider(_ value: ListContactReferencesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let referenceTypes = value.referenceTypes else {
            let message = "Creating a URL Query Item failed. referenceTypes is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        referenceTypes.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "referenceTypes".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
            items.append(queryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListDefaultVocabulariesInput {

    static func urlPathProvider(_ value: ListDefaultVocabulariesInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/default-vocabulary-summary/\(instanceId.urlPercentEncoding())"
    }
}

extension ListEvaluationFormsInput {

    static func urlPathProvider(_ value: ListEvaluationFormsInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/evaluation-forms/\(instanceId.urlPercentEncoding())"
    }
}

extension ListEvaluationFormsInput {

    static func queryItemProvider(_ value: ListEvaluationFormsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListEvaluationFormVersionsInput {

    static func urlPathProvider(_ value: ListEvaluationFormVersionsInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let evaluationFormId = value.evaluationFormId else {
            return nil
        }
        return "/evaluation-forms/\(instanceId.urlPercentEncoding())/\(evaluationFormId.urlPercentEncoding())/versions"
    }
}

extension ListEvaluationFormVersionsInput {

    static func queryItemProvider(_ value: ListEvaluationFormVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListFlowAssociationsInput {

    static func urlPathProvider(_ value: ListFlowAssociationsInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/flow-associations-summary/\(instanceId.urlPercentEncoding())"
    }
}

extension ListFlowAssociationsInput {

    static func queryItemProvider(_ value: ListFlowAssociationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let resourceType = value.resourceType {
            let resourceTypeQueryItem = Smithy.URIQueryItem(name: "ResourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
        }
        return items
    }
}

extension ListHoursOfOperationsInput {

    static func urlPathProvider(_ value: ListHoursOfOperationsInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/hours-of-operations-summary/\(instanceId.urlPercentEncoding())"
    }
}

extension ListHoursOfOperationsInput {

    static func queryItemProvider(_ value: ListHoursOfOperationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListInstanceAttributesInput {

    static func urlPathProvider(_ value: ListInstanceAttributesInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/attributes"
    }
}

extension ListInstanceAttributesInput {

    static func queryItemProvider(_ value: ListInstanceAttributesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListInstancesInput {

    static func urlPathProvider(_ value: ListInstancesInput) -> Swift.String? {
        return "/instance"
    }
}

extension ListInstancesInput {

    static func queryItemProvider(_ value: ListInstancesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListInstanceStorageConfigsInput {

    static func urlPathProvider(_ value: ListInstanceStorageConfigsInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/storage-configs"
    }
}

extension ListInstanceStorageConfigsInput {

    static func queryItemProvider(_ value: ListInstanceStorageConfigsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        guard let resourceType = value.resourceType else {
            let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceTypeQueryItem = Smithy.URIQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
        items.append(resourceTypeQueryItem)
        return items
    }
}

extension ListIntegrationAssociationsInput {

    static func urlPathProvider(_ value: ListIntegrationAssociationsInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/integration-associations"
    }
}

extension ListIntegrationAssociationsInput {

    static func queryItemProvider(_ value: ListIntegrationAssociationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let integrationArn = value.integrationArn {
            let integrationArnQueryItem = Smithy.URIQueryItem(name: "integrationArn".urlPercentEncoding(), value: Swift.String(integrationArn).urlPercentEncoding())
            items.append(integrationArnQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let integrationType = value.integrationType {
            let integrationTypeQueryItem = Smithy.URIQueryItem(name: "integrationType".urlPercentEncoding(), value: Swift.String(integrationType.rawValue).urlPercentEncoding())
            items.append(integrationTypeQueryItem)
        }
        return items
    }
}

extension ListLambdaFunctionsInput {

    static func urlPathProvider(_ value: ListLambdaFunctionsInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/lambda-functions"
    }
}

extension ListLambdaFunctionsInput {

    static func queryItemProvider(_ value: ListLambdaFunctionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListLexBotsInput {

    static func urlPathProvider(_ value: ListLexBotsInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/lex-bots"
    }
}

extension ListLexBotsInput {

    static func queryItemProvider(_ value: ListLexBotsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListPhoneNumbersInput {

    static func urlPathProvider(_ value: ListPhoneNumbersInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/phone-numbers-summary/\(instanceId.urlPercentEncoding())"
    }
}

extension ListPhoneNumbersInput {

    static func queryItemProvider(_ value: ListPhoneNumbersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let phoneNumberTypes = value.phoneNumberTypes {
            phoneNumberTypes.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "phoneNumberTypes".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let phoneNumberCountryCodes = value.phoneNumberCountryCodes {
            phoneNumberCountryCodes.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "phoneNumberCountryCodes".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension ListPhoneNumbersV2Input {

    static func urlPathProvider(_ value: ListPhoneNumbersV2Input) -> Swift.String? {
        return "/phone-number/list"
    }
}

extension ListPredefinedAttributesInput {

    static func urlPathProvider(_ value: ListPredefinedAttributesInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/predefined-attributes/\(instanceId.urlPercentEncoding())"
    }
}

extension ListPredefinedAttributesInput {

    static func queryItemProvider(_ value: ListPredefinedAttributesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListPromptsInput {

    static func urlPathProvider(_ value: ListPromptsInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/prompts-summary/\(instanceId.urlPercentEncoding())"
    }
}

extension ListPromptsInput {

    static func queryItemProvider(_ value: ListPromptsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListQueueQuickConnectsInput {

    static func urlPathProvider(_ value: ListQueueQuickConnectsInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        return "/queues/\(instanceId.urlPercentEncoding())/\(queueId.urlPercentEncoding())/quick-connects"
    }
}

extension ListQueueQuickConnectsInput {

    static func queryItemProvider(_ value: ListQueueQuickConnectsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListQueuesInput {

    static func urlPathProvider(_ value: ListQueuesInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/queues-summary/\(instanceId.urlPercentEncoding())"
    }
}

extension ListQueuesInput {

    static func queryItemProvider(_ value: ListQueuesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let queueTypes = value.queueTypes {
            queueTypes.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "queueTypes".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension ListQuickConnectsInput {

    static func urlPathProvider(_ value: ListQuickConnectsInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/quick-connects/\(instanceId.urlPercentEncoding())"
    }
}

extension ListQuickConnectsInput {

    static func queryItemProvider(_ value: ListQuickConnectsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let quickConnectTypes = value.quickConnectTypes {
            quickConnectTypes.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "QuickConnectTypes".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListRealtimeContactAnalysisSegmentsV2Input {

    static func urlPathProvider(_ value: ListRealtimeContactAnalysisSegmentsV2Input) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let contactId = value.contactId else {
            return nil
        }
        return "/contact/list-real-time-analysis-segments-v2/\(instanceId.urlPercentEncoding())/\(contactId.urlPercentEncoding())"
    }
}

extension ListRoutingProfileQueuesInput {

    static func urlPathProvider(_ value: ListRoutingProfileQueuesInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let routingProfileId = value.routingProfileId else {
            return nil
        }
        return "/routing-profiles/\(instanceId.urlPercentEncoding())/\(routingProfileId.urlPercentEncoding())/queues"
    }
}

extension ListRoutingProfileQueuesInput {

    static func queryItemProvider(_ value: ListRoutingProfileQueuesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListRoutingProfilesInput {

    static func urlPathProvider(_ value: ListRoutingProfilesInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/routing-profiles-summary/\(instanceId.urlPercentEncoding())"
    }
}

extension ListRoutingProfilesInput {

    static func queryItemProvider(_ value: ListRoutingProfilesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListRulesInput {

    static func urlPathProvider(_ value: ListRulesInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/rules/\(instanceId.urlPercentEncoding())"
    }
}

extension ListRulesInput {

    static func queryItemProvider(_ value: ListRulesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let eventSourceName = value.eventSourceName {
            let eventSourceNameQueryItem = Smithy.URIQueryItem(name: "eventSourceName".urlPercentEncoding(), value: Swift.String(eventSourceName.rawValue).urlPercentEncoding())
            items.append(eventSourceNameQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let publishStatus = value.publishStatus {
            let publishStatusQueryItem = Smithy.URIQueryItem(name: "publishStatus".urlPercentEncoding(), value: Swift.String(publishStatus.rawValue).urlPercentEncoding())
            items.append(publishStatusQueryItem)
        }
        return items
    }
}

extension ListSecurityKeysInput {

    static func urlPathProvider(_ value: ListSecurityKeysInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/security-keys"
    }
}

extension ListSecurityKeysInput {

    static func queryItemProvider(_ value: ListSecurityKeysInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListSecurityProfileApplicationsInput {

    static func urlPathProvider(_ value: ListSecurityProfileApplicationsInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let securityProfileId = value.securityProfileId else {
            return nil
        }
        return "/security-profiles-applications/\(instanceId.urlPercentEncoding())/\(securityProfileId.urlPercentEncoding())"
    }
}

extension ListSecurityProfileApplicationsInput {

    static func queryItemProvider(_ value: ListSecurityProfileApplicationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListSecurityProfilePermissionsInput {

    static func urlPathProvider(_ value: ListSecurityProfilePermissionsInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let securityProfileId = value.securityProfileId else {
            return nil
        }
        return "/security-profiles-permissions/\(instanceId.urlPercentEncoding())/\(securityProfileId.urlPercentEncoding())"
    }
}

extension ListSecurityProfilePermissionsInput {

    static func queryItemProvider(_ value: ListSecurityProfilePermissionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListSecurityProfilesInput {

    static func urlPathProvider(_ value: ListSecurityProfilesInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/security-profiles-summary/\(instanceId.urlPercentEncoding())"
    }
}

extension ListSecurityProfilesInput {

    static func queryItemProvider(_ value: ListSecurityProfilesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension ListTaskTemplatesInput {

    static func urlPathProvider(_ value: ListTaskTemplatesInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/task/template"
    }
}

extension ListTaskTemplatesInput {

    static func queryItemProvider(_ value: ListTaskTemplatesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let name = value.name {
            let nameQueryItem = Smithy.URIQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
            items.append(nameQueryItem)
        }
        return items
    }
}

extension ListTrafficDistributionGroupsInput {

    static func urlPathProvider(_ value: ListTrafficDistributionGroupsInput) -> Swift.String? {
        return "/traffic-distribution-groups"
    }
}

extension ListTrafficDistributionGroupsInput {

    static func queryItemProvider(_ value: ListTrafficDistributionGroupsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let instanceId = value.instanceId {
            let instanceIdQueryItem = Smithy.URIQueryItem(name: "instanceId".urlPercentEncoding(), value: Swift.String(instanceId).urlPercentEncoding())
            items.append(instanceIdQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTrafficDistributionGroupUsersInput {

    static func urlPathProvider(_ value: ListTrafficDistributionGroupUsersInput) -> Swift.String? {
        guard let trafficDistributionGroupId = value.trafficDistributionGroupId else {
            return nil
        }
        return "/traffic-distribution-group/\(trafficDistributionGroupId.urlPercentEncoding())/user"
    }
}

extension ListTrafficDistributionGroupUsersInput {

    static func queryItemProvider(_ value: ListTrafficDistributionGroupUsersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListUseCasesInput {

    static func urlPathProvider(_ value: ListUseCasesInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let integrationAssociationId = value.integrationAssociationId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/integration-associations/\(integrationAssociationId.urlPercentEncoding())/use-cases"
    }
}

extension ListUseCasesInput {

    static func queryItemProvider(_ value: ListUseCasesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListUserHierarchyGroupsInput {

    static func urlPathProvider(_ value: ListUserHierarchyGroupsInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/user-hierarchy-groups-summary/\(instanceId.urlPercentEncoding())"
    }
}

extension ListUserHierarchyGroupsInput {

    static func queryItemProvider(_ value: ListUserHierarchyGroupsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListUserProficienciesInput {

    static func urlPathProvider(_ value: ListUserProficienciesInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let userId = value.userId else {
            return nil
        }
        return "/users/\(instanceId.urlPercentEncoding())/\(userId.urlPercentEncoding())/proficiencies"
    }
}

extension ListUserProficienciesInput {

    static func queryItemProvider(_ value: ListUserProficienciesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListUsersInput {

    static func urlPathProvider(_ value: ListUsersInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/users-summary/\(instanceId.urlPercentEncoding())"
    }
}

extension ListUsersInput {

    static func queryItemProvider(_ value: ListUsersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListViewsInput {

    static func urlPathProvider(_ value: ListViewsInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/views/\(instanceId.urlPercentEncoding())"
    }
}

extension ListViewsInput {

    static func queryItemProvider(_ value: ListViewsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let type = value.type {
            let typeQueryItem = Smithy.URIQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListViewVersionsInput {

    static func urlPathProvider(_ value: ListViewVersionsInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let viewId = value.viewId else {
            return nil
        }
        return "/views/\(instanceId.urlPercentEncoding())/\(viewId.urlPercentEncoding())/versions"
    }
}

extension ListViewVersionsInput {

    static func queryItemProvider(_ value: ListViewVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension MonitorContactInput {

    static func urlPathProvider(_ value: MonitorContactInput) -> Swift.String? {
        return "/contact/monitor"
    }
}

extension PauseContactInput {

    static func urlPathProvider(_ value: PauseContactInput) -> Swift.String? {
        return "/contact/pause"
    }
}

extension PutUserStatusInput {

    static func urlPathProvider(_ value: PutUserStatusInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let userId = value.userId else {
            return nil
        }
        return "/users/\(instanceId.urlPercentEncoding())/\(userId.urlPercentEncoding())/status"
    }
}

extension ReleasePhoneNumberInput {

    static func urlPathProvider(_ value: ReleasePhoneNumberInput) -> Swift.String? {
        guard let phoneNumberId = value.phoneNumberId else {
            return nil
        }
        return "/phone-number/\(phoneNumberId.urlPercentEncoding())"
    }
}

extension ReleasePhoneNumberInput {

    static func queryItemProvider(_ value: ReleasePhoneNumberInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension ReplicateInstanceInput {

    static func urlPathProvider(_ value: ReplicateInstanceInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/replicate"
    }
}

extension ResumeContactInput {

    static func urlPathProvider(_ value: ResumeContactInput) -> Swift.String? {
        return "/contact/resume"
    }
}

extension ResumeContactRecordingInput {

    static func urlPathProvider(_ value: ResumeContactRecordingInput) -> Swift.String? {
        return "/contact/resume-recording"
    }
}

extension SearchAgentStatusesInput {

    static func urlPathProvider(_ value: SearchAgentStatusesInput) -> Swift.String? {
        return "/search-agent-statuses"
    }
}

extension SearchAvailablePhoneNumbersInput {

    static func urlPathProvider(_ value: SearchAvailablePhoneNumbersInput) -> Swift.String? {
        return "/phone-number/search-available"
    }
}

extension SearchContactFlowModulesInput {

    static func urlPathProvider(_ value: SearchContactFlowModulesInput) -> Swift.String? {
        return "/search-contact-flow-modules"
    }
}

extension SearchContactFlowsInput {

    static func urlPathProvider(_ value: SearchContactFlowsInput) -> Swift.String? {
        return "/search-contact-flows"
    }
}

extension SearchContactsInput {

    static func urlPathProvider(_ value: SearchContactsInput) -> Swift.String? {
        return "/search-contacts"
    }
}

extension SearchHoursOfOperationsInput {

    static func urlPathProvider(_ value: SearchHoursOfOperationsInput) -> Swift.String? {
        return "/search-hours-of-operations"
    }
}

extension SearchPredefinedAttributesInput {

    static func urlPathProvider(_ value: SearchPredefinedAttributesInput) -> Swift.String? {
        return "/search-predefined-attributes"
    }
}

extension SearchPromptsInput {

    static func urlPathProvider(_ value: SearchPromptsInput) -> Swift.String? {
        return "/search-prompts"
    }
}

extension SearchQueuesInput {

    static func urlPathProvider(_ value: SearchQueuesInput) -> Swift.String? {
        return "/search-queues"
    }
}

extension SearchQuickConnectsInput {

    static func urlPathProvider(_ value: SearchQuickConnectsInput) -> Swift.String? {
        return "/search-quick-connects"
    }
}

extension SearchResourceTagsInput {

    static func urlPathProvider(_ value: SearchResourceTagsInput) -> Swift.String? {
        return "/search-resource-tags"
    }
}

extension SearchRoutingProfilesInput {

    static func urlPathProvider(_ value: SearchRoutingProfilesInput) -> Swift.String? {
        return "/search-routing-profiles"
    }
}

extension SearchSecurityProfilesInput {

    static func urlPathProvider(_ value: SearchSecurityProfilesInput) -> Swift.String? {
        return "/search-security-profiles"
    }
}

extension SearchUserHierarchyGroupsInput {

    static func urlPathProvider(_ value: SearchUserHierarchyGroupsInput) -> Swift.String? {
        return "/search-user-hierarchy-groups"
    }
}

extension SearchUsersInput {

    static func urlPathProvider(_ value: SearchUsersInput) -> Swift.String? {
        return "/search-users"
    }
}

extension SearchVocabulariesInput {

    static func urlPathProvider(_ value: SearchVocabulariesInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/vocabulary-summary/\(instanceId.urlPercentEncoding())"
    }
}

extension SendChatIntegrationEventInput {

    static func urlPathProvider(_ value: SendChatIntegrationEventInput) -> Swift.String? {
        return "/chat-integration-event"
    }
}

extension StartAttachedFileUploadInput {

    static func urlPathProvider(_ value: StartAttachedFileUploadInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/attached-files/\(instanceId.urlPercentEncoding())"
    }
}

extension StartAttachedFileUploadInput {

    static func queryItemProvider(_ value: StartAttachedFileUploadInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let associatedResourceArn = value.associatedResourceArn else {
            let message = "Creating a URL Query Item failed. associatedResourceArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let associatedResourceArnQueryItem = Smithy.URIQueryItem(name: "associatedResourceArn".urlPercentEncoding(), value: Swift.String(associatedResourceArn).urlPercentEncoding())
        items.append(associatedResourceArnQueryItem)
        return items
    }
}

extension StartChatContactInput {

    static func urlPathProvider(_ value: StartChatContactInput) -> Swift.String? {
        return "/contact/chat"
    }
}

extension StartContactEvaluationInput {

    static func urlPathProvider(_ value: StartContactEvaluationInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/contact-evaluations/\(instanceId.urlPercentEncoding())"
    }
}

extension StartContactRecordingInput {

    static func urlPathProvider(_ value: StartContactRecordingInput) -> Swift.String? {
        return "/contact/start-recording"
    }
}

extension StartContactStreamingInput {

    static func urlPathProvider(_ value: StartContactStreamingInput) -> Swift.String? {
        return "/contact/start-streaming"
    }
}

extension StartOutboundVoiceContactInput {

    static func urlPathProvider(_ value: StartOutboundVoiceContactInput) -> Swift.String? {
        return "/contact/outbound-voice"
    }
}

extension StartTaskContactInput {

    static func urlPathProvider(_ value: StartTaskContactInput) -> Swift.String? {
        return "/contact/task"
    }
}

extension StartWebRTCContactInput {

    static func urlPathProvider(_ value: StartWebRTCContactInput) -> Swift.String? {
        return "/contact/webrtc"
    }
}

extension StopContactInput {

    static func urlPathProvider(_ value: StopContactInput) -> Swift.String? {
        return "/contact/stop"
    }
}

extension StopContactRecordingInput {

    static func urlPathProvider(_ value: StopContactRecordingInput) -> Swift.String? {
        return "/contact/stop-recording"
    }
}

extension StopContactStreamingInput {

    static func urlPathProvider(_ value: StopContactStreamingInput) -> Swift.String? {
        return "/contact/stop-streaming"
    }
}

extension SubmitContactEvaluationInput {

    static func urlPathProvider(_ value: SubmitContactEvaluationInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let evaluationId = value.evaluationId else {
            return nil
        }
        return "/contact-evaluations/\(instanceId.urlPercentEncoding())/\(evaluationId.urlPercentEncoding())/submit"
    }
}

extension SuspendContactRecordingInput {

    static func urlPathProvider(_ value: SuspendContactRecordingInput) -> Swift.String? {
        return "/contact/suspend-recording"
    }
}

extension TagContactInput {

    static func urlPathProvider(_ value: TagContactInput) -> Swift.String? {
        return "/contact/tags"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension TransferContactInput {

    static func urlPathProvider(_ value: TransferContactInput) -> Swift.String? {
        return "/contact/transfer"
    }
}

extension UntagContactInput {

    static func urlPathProvider(_ value: UntagContactInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let contactId = value.contactId else {
            return nil
        }
        return "/contact/tags/\(instanceId.urlPercentEncoding())/\(contactId.urlPercentEncoding())"
    }
}

extension UntagContactInput {

    static func queryItemProvider(_ value: UntagContactInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "TagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateAgentStatusInput {

    static func urlPathProvider(_ value: UpdateAgentStatusInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let agentStatusId = value.agentStatusId else {
            return nil
        }
        return "/agent-status/\(instanceId.urlPercentEncoding())/\(agentStatusId.urlPercentEncoding())"
    }
}

extension UpdateAuthenticationProfileInput {

    static func urlPathProvider(_ value: UpdateAuthenticationProfileInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let authenticationProfileId = value.authenticationProfileId else {
            return nil
        }
        return "/authentication-profiles/\(instanceId.urlPercentEncoding())/\(authenticationProfileId.urlPercentEncoding())"
    }
}

extension UpdateContactInput {

    static func urlPathProvider(_ value: UpdateContactInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let contactId = value.contactId else {
            return nil
        }
        return "/contacts/\(instanceId.urlPercentEncoding())/\(contactId.urlPercentEncoding())"
    }
}

extension UpdateContactAttributesInput {

    static func urlPathProvider(_ value: UpdateContactAttributesInput) -> Swift.String? {
        return "/contact/attributes"
    }
}

extension UpdateContactEvaluationInput {

    static func urlPathProvider(_ value: UpdateContactEvaluationInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let evaluationId = value.evaluationId else {
            return nil
        }
        return "/contact-evaluations/\(instanceId.urlPercentEncoding())/\(evaluationId.urlPercentEncoding())"
    }
}

extension UpdateContactFlowContentInput {

    static func urlPathProvider(_ value: UpdateContactFlowContentInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let contactFlowId = value.contactFlowId else {
            return nil
        }
        return "/contact-flows/\(instanceId.urlPercentEncoding())/\(contactFlowId.urlPercentEncoding())/content"
    }
}

extension UpdateContactFlowMetadataInput {

    static func urlPathProvider(_ value: UpdateContactFlowMetadataInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let contactFlowId = value.contactFlowId else {
            return nil
        }
        return "/contact-flows/\(instanceId.urlPercentEncoding())/\(contactFlowId.urlPercentEncoding())/metadata"
    }
}

extension UpdateContactFlowModuleContentInput {

    static func urlPathProvider(_ value: UpdateContactFlowModuleContentInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let contactFlowModuleId = value.contactFlowModuleId else {
            return nil
        }
        return "/contact-flow-modules/\(instanceId.urlPercentEncoding())/\(contactFlowModuleId.urlPercentEncoding())/content"
    }
}

extension UpdateContactFlowModuleMetadataInput {

    static func urlPathProvider(_ value: UpdateContactFlowModuleMetadataInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let contactFlowModuleId = value.contactFlowModuleId else {
            return nil
        }
        return "/contact-flow-modules/\(instanceId.urlPercentEncoding())/\(contactFlowModuleId.urlPercentEncoding())/metadata"
    }
}

extension UpdateContactFlowNameInput {

    static func urlPathProvider(_ value: UpdateContactFlowNameInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let contactFlowId = value.contactFlowId else {
            return nil
        }
        return "/contact-flows/\(instanceId.urlPercentEncoding())/\(contactFlowId.urlPercentEncoding())/name"
    }
}

extension UpdateContactRoutingDataInput {

    static func urlPathProvider(_ value: UpdateContactRoutingDataInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let contactId = value.contactId else {
            return nil
        }
        return "/contacts/\(instanceId.urlPercentEncoding())/\(contactId.urlPercentEncoding())/routing-data"
    }
}

extension UpdateContactScheduleInput {

    static func urlPathProvider(_ value: UpdateContactScheduleInput) -> Swift.String? {
        return "/contact/schedule"
    }
}

extension UpdateEvaluationFormInput {

    static func urlPathProvider(_ value: UpdateEvaluationFormInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let evaluationFormId = value.evaluationFormId else {
            return nil
        }
        return "/evaluation-forms/\(instanceId.urlPercentEncoding())/\(evaluationFormId.urlPercentEncoding())"
    }
}

extension UpdateHoursOfOperationInput {

    static func urlPathProvider(_ value: UpdateHoursOfOperationInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let hoursOfOperationId = value.hoursOfOperationId else {
            return nil
        }
        return "/hours-of-operations/\(instanceId.urlPercentEncoding())/\(hoursOfOperationId.urlPercentEncoding())"
    }
}

extension UpdateInstanceAttributeInput {

    static func urlPathProvider(_ value: UpdateInstanceAttributeInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let attributeType = value.attributeType else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/attribute/\(attributeType.rawValue.urlPercentEncoding())"
    }
}

extension UpdateInstanceStorageConfigInput {

    static func urlPathProvider(_ value: UpdateInstanceStorageConfigInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let associationId = value.associationId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/storage-config/\(associationId.urlPercentEncoding())"
    }
}

extension UpdateInstanceStorageConfigInput {

    static func queryItemProvider(_ value: UpdateInstanceStorageConfigInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let resourceType = value.resourceType else {
            let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceTypeQueryItem = Smithy.URIQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
        items.append(resourceTypeQueryItem)
        return items
    }
}

extension UpdateParticipantRoleConfigInput {

    static func urlPathProvider(_ value: UpdateParticipantRoleConfigInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let contactId = value.contactId else {
            return nil
        }
        return "/contact/participant-role-config/\(instanceId.urlPercentEncoding())/\(contactId.urlPercentEncoding())"
    }
}

extension UpdatePhoneNumberInput {

    static func urlPathProvider(_ value: UpdatePhoneNumberInput) -> Swift.String? {
        guard let phoneNumberId = value.phoneNumberId else {
            return nil
        }
        return "/phone-number/\(phoneNumberId.urlPercentEncoding())"
    }
}

extension UpdatePhoneNumberMetadataInput {

    static func urlPathProvider(_ value: UpdatePhoneNumberMetadataInput) -> Swift.String? {
        guard let phoneNumberId = value.phoneNumberId else {
            return nil
        }
        return "/phone-number/\(phoneNumberId.urlPercentEncoding())/metadata"
    }
}

extension UpdatePredefinedAttributeInput {

    static func urlPathProvider(_ value: UpdatePredefinedAttributeInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/predefined-attributes/\(instanceId.urlPercentEncoding())/\(name.urlPercentEncoding())"
    }
}

extension UpdatePromptInput {

    static func urlPathProvider(_ value: UpdatePromptInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let promptId = value.promptId else {
            return nil
        }
        return "/prompts/\(instanceId.urlPercentEncoding())/\(promptId.urlPercentEncoding())"
    }
}

extension UpdateQueueHoursOfOperationInput {

    static func urlPathProvider(_ value: UpdateQueueHoursOfOperationInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        return "/queues/\(instanceId.urlPercentEncoding())/\(queueId.urlPercentEncoding())/hours-of-operation"
    }
}

extension UpdateQueueMaxContactsInput {

    static func urlPathProvider(_ value: UpdateQueueMaxContactsInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        return "/queues/\(instanceId.urlPercentEncoding())/\(queueId.urlPercentEncoding())/max-contacts"
    }
}

extension UpdateQueueNameInput {

    static func urlPathProvider(_ value: UpdateQueueNameInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        return "/queues/\(instanceId.urlPercentEncoding())/\(queueId.urlPercentEncoding())/name"
    }
}

extension UpdateQueueOutboundCallerConfigInput {

    static func urlPathProvider(_ value: UpdateQueueOutboundCallerConfigInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        return "/queues/\(instanceId.urlPercentEncoding())/\(queueId.urlPercentEncoding())/outbound-caller-config"
    }
}

extension UpdateQueueStatusInput {

    static func urlPathProvider(_ value: UpdateQueueStatusInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        return "/queues/\(instanceId.urlPercentEncoding())/\(queueId.urlPercentEncoding())/status"
    }
}

extension UpdateQuickConnectConfigInput {

    static func urlPathProvider(_ value: UpdateQuickConnectConfigInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let quickConnectId = value.quickConnectId else {
            return nil
        }
        return "/quick-connects/\(instanceId.urlPercentEncoding())/\(quickConnectId.urlPercentEncoding())/config"
    }
}

extension UpdateQuickConnectNameInput {

    static func urlPathProvider(_ value: UpdateQuickConnectNameInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let quickConnectId = value.quickConnectId else {
            return nil
        }
        return "/quick-connects/\(instanceId.urlPercentEncoding())/\(quickConnectId.urlPercentEncoding())/name"
    }
}

extension UpdateRoutingProfileAgentAvailabilityTimerInput {

    static func urlPathProvider(_ value: UpdateRoutingProfileAgentAvailabilityTimerInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let routingProfileId = value.routingProfileId else {
            return nil
        }
        return "/routing-profiles/\(instanceId.urlPercentEncoding())/\(routingProfileId.urlPercentEncoding())/agent-availability-timer"
    }
}

extension UpdateRoutingProfileConcurrencyInput {

    static func urlPathProvider(_ value: UpdateRoutingProfileConcurrencyInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let routingProfileId = value.routingProfileId else {
            return nil
        }
        return "/routing-profiles/\(instanceId.urlPercentEncoding())/\(routingProfileId.urlPercentEncoding())/concurrency"
    }
}

extension UpdateRoutingProfileDefaultOutboundQueueInput {

    static func urlPathProvider(_ value: UpdateRoutingProfileDefaultOutboundQueueInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let routingProfileId = value.routingProfileId else {
            return nil
        }
        return "/routing-profiles/\(instanceId.urlPercentEncoding())/\(routingProfileId.urlPercentEncoding())/default-outbound-queue"
    }
}

extension UpdateRoutingProfileNameInput {

    static func urlPathProvider(_ value: UpdateRoutingProfileNameInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let routingProfileId = value.routingProfileId else {
            return nil
        }
        return "/routing-profiles/\(instanceId.urlPercentEncoding())/\(routingProfileId.urlPercentEncoding())/name"
    }
}

extension UpdateRoutingProfileQueuesInput {

    static func urlPathProvider(_ value: UpdateRoutingProfileQueuesInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let routingProfileId = value.routingProfileId else {
            return nil
        }
        return "/routing-profiles/\(instanceId.urlPercentEncoding())/\(routingProfileId.urlPercentEncoding())/queues"
    }
}

extension UpdateRuleInput {

    static func urlPathProvider(_ value: UpdateRuleInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let ruleId = value.ruleId else {
            return nil
        }
        return "/rules/\(instanceId.urlPercentEncoding())/\(ruleId.urlPercentEncoding())"
    }
}

extension UpdateSecurityProfileInput {

    static func urlPathProvider(_ value: UpdateSecurityProfileInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let securityProfileId = value.securityProfileId else {
            return nil
        }
        return "/security-profiles/\(instanceId.urlPercentEncoding())/\(securityProfileId.urlPercentEncoding())"
    }
}

extension UpdateTaskTemplateInput {

    static func urlPathProvider(_ value: UpdateTaskTemplateInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let taskTemplateId = value.taskTemplateId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/task/template/\(taskTemplateId.urlPercentEncoding())"
    }
}

extension UpdateTrafficDistributionInput {

    static func urlPathProvider(_ value: UpdateTrafficDistributionInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/traffic-distribution/\(id.urlPercentEncoding())"
    }
}

extension UpdateUserHierarchyInput {

    static func urlPathProvider(_ value: UpdateUserHierarchyInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let userId = value.userId else {
            return nil
        }
        return "/users/\(instanceId.urlPercentEncoding())/\(userId.urlPercentEncoding())/hierarchy"
    }
}

extension UpdateUserHierarchyGroupNameInput {

    static func urlPathProvider(_ value: UpdateUserHierarchyGroupNameInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let hierarchyGroupId = value.hierarchyGroupId else {
            return nil
        }
        return "/user-hierarchy-groups/\(instanceId.urlPercentEncoding())/\(hierarchyGroupId.urlPercentEncoding())/name"
    }
}

extension UpdateUserHierarchyStructureInput {

    static func urlPathProvider(_ value: UpdateUserHierarchyStructureInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/user-hierarchy-structure/\(instanceId.urlPercentEncoding())"
    }
}

extension UpdateUserIdentityInfoInput {

    static func urlPathProvider(_ value: UpdateUserIdentityInfoInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let userId = value.userId else {
            return nil
        }
        return "/users/\(instanceId.urlPercentEncoding())/\(userId.urlPercentEncoding())/identity-info"
    }
}

extension UpdateUserPhoneConfigInput {

    static func urlPathProvider(_ value: UpdateUserPhoneConfigInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let userId = value.userId else {
            return nil
        }
        return "/users/\(instanceId.urlPercentEncoding())/\(userId.urlPercentEncoding())/phone-config"
    }
}

extension UpdateUserProficienciesInput {

    static func urlPathProvider(_ value: UpdateUserProficienciesInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let userId = value.userId else {
            return nil
        }
        return "/users/\(instanceId.urlPercentEncoding())/\(userId.urlPercentEncoding())/proficiencies"
    }
}

extension UpdateUserRoutingProfileInput {

    static func urlPathProvider(_ value: UpdateUserRoutingProfileInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let userId = value.userId else {
            return nil
        }
        return "/users/\(instanceId.urlPercentEncoding())/\(userId.urlPercentEncoding())/routing-profile"
    }
}

extension UpdateUserSecurityProfilesInput {

    static func urlPathProvider(_ value: UpdateUserSecurityProfilesInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let userId = value.userId else {
            return nil
        }
        return "/users/\(instanceId.urlPercentEncoding())/\(userId.urlPercentEncoding())/security-profiles"
    }
}

extension UpdateViewContentInput {

    static func urlPathProvider(_ value: UpdateViewContentInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let viewId = value.viewId else {
            return nil
        }
        return "/views/\(instanceId.urlPercentEncoding())/\(viewId.urlPercentEncoding())"
    }
}

extension UpdateViewMetadataInput {

    static func urlPathProvider(_ value: UpdateViewMetadataInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let viewId = value.viewId else {
            return nil
        }
        return "/views/\(instanceId.urlPercentEncoding())/\(viewId.urlPercentEncoding())/metadata"
    }
}

extension ActivateEvaluationFormInput {

    static func write(value: ActivateEvaluationFormInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EvaluationFormVersion"].write(value.evaluationFormVersion)
    }
}

extension AssociateAnalyticsDataSetInput {

    static func write(value: AssociateAnalyticsDataSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataSetId"].write(value.dataSetId)
        try writer["TargetAccountId"].write(value.targetAccountId)
    }
}

extension AssociateApprovedOriginInput {

    static func write(value: AssociateApprovedOriginInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Origin"].write(value.origin)
    }
}

extension AssociateBotInput {

    static func write(value: AssociateBotInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LexBot"].write(value.lexBot, with: ConnectClientTypes.LexBot.write(value:to:))
        try writer["LexV2Bot"].write(value.lexV2Bot, with: ConnectClientTypes.LexV2Bot.write(value:to:))
    }
}

extension AssociateDefaultVocabularyInput {

    static func write(value: AssociateDefaultVocabularyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["VocabularyId"].write(value.vocabularyId)
    }
}

extension AssociateFlowInput {

    static func write(value: AssociateFlowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FlowId"].write(value.flowId)
        try writer["ResourceId"].write(value.resourceId)
        try writer["ResourceType"].write(value.resourceType)
    }
}

extension AssociateInstanceStorageConfigInput {

    static func write(value: AssociateInstanceStorageConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceType"].write(value.resourceType)
        try writer["StorageConfig"].write(value.storageConfig, with: ConnectClientTypes.InstanceStorageConfig.write(value:to:))
    }
}

extension AssociateLambdaFunctionInput {

    static func write(value: AssociateLambdaFunctionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FunctionArn"].write(value.functionArn)
    }
}

extension AssociateLexBotInput {

    static func write(value: AssociateLexBotInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LexBot"].write(value.lexBot, with: ConnectClientTypes.LexBot.write(value:to:))
    }
}

extension AssociatePhoneNumberContactFlowInput {

    static func write(value: AssociatePhoneNumberContactFlowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactFlowId"].write(value.contactFlowId)
        try writer["InstanceId"].write(value.instanceId)
    }
}

extension AssociateQueueQuickConnectsInput {

    static func write(value: AssociateQueueQuickConnectsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["QuickConnectIds"].writeList(value.quickConnectIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension AssociateRoutingProfileQueuesInput {

    static func write(value: AssociateRoutingProfileQueuesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["QueueConfigs"].writeList(value.queueConfigs, memberWritingClosure: ConnectClientTypes.RoutingProfileQueueConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension AssociateSecurityKeyInput {

    static func write(value: AssociateSecurityKeyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
    }
}

extension AssociateTrafficDistributionGroupUserInput {

    static func write(value: AssociateTrafficDistributionGroupUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceId"].write(value.instanceId)
        try writer["UserId"].write(value.userId)
    }
}

extension AssociateUserProficienciesInput {

    static func write(value: AssociateUserProficienciesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["UserProficiencies"].writeList(value.userProficiencies, memberWritingClosure: ConnectClientTypes.UserProficiency.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchAssociateAnalyticsDataSetInput {

    static func write(value: BatchAssociateAnalyticsDataSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataSetIds"].writeList(value.dataSetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TargetAccountId"].write(value.targetAccountId)
    }
}

extension BatchDisassociateAnalyticsDataSetInput {

    static func write(value: BatchDisassociateAnalyticsDataSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataSetIds"].writeList(value.dataSetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TargetAccountId"].write(value.targetAccountId)
    }
}

extension BatchGetAttachedFileMetadataInput {

    static func write(value: BatchGetAttachedFileMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FileIds"].writeList(value.fileIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchGetFlowAssociationInput {

    static func write(value: BatchGetFlowAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceIds"].writeList(value.resourceIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceType"].write(value.resourceType)
    }
}

extension BatchPutContactInput {

    static func write(value: BatchPutContactInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["ContactDataRequestList"].writeList(value.contactDataRequestList, memberWritingClosure: ConnectClientTypes.ContactDataRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ClaimPhoneNumberInput {

    static func write(value: ClaimPhoneNumberInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["InstanceId"].write(value.instanceId)
        try writer["PhoneNumber"].write(value.phoneNumber)
        try writer["PhoneNumberDescription"].write(value.phoneNumberDescription)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["TargetArn"].write(value.targetArn)
    }
}

extension CreateAgentStatusInput {

    static func write(value: CreateAgentStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["DisplayOrder"].write(value.displayOrder)
        try writer["Name"].write(value.name)
        try writer["State"].write(value.state)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateContactFlowInput {

    static func write(value: CreateContactFlowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Content"].write(value.content)
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["Status"].write(value.status)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Type"].write(value.type)
    }
}

extension CreateContactFlowModuleInput {

    static func write(value: CreateContactFlowModuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["Content"].write(value.content)
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateEvaluationFormInput {

    static func write(value: CreateEvaluationFormInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["Description"].write(value.description)
        try writer["Items"].writeList(value.items, memberWritingClosure: ConnectClientTypes.EvaluationFormItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ScoringStrategy"].write(value.scoringStrategy, with: ConnectClientTypes.EvaluationFormScoringStrategy.write(value:to:))
        try writer["Title"].write(value.title)
    }
}

extension CreateHoursOfOperationInput {

    static func write(value: CreateHoursOfOperationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Config"].writeList(value.config, memberWritingClosure: ConnectClientTypes.HoursOfOperationConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["TimeZone"].write(value.timeZone)
    }
}

extension CreateInstanceInput {

    static func write(value: CreateInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["DirectoryId"].write(value.directoryId)
        try writer["IdentityManagementType"].write(value.identityManagementType)
        try writer["InboundCallsEnabled"].write(value.inboundCallsEnabled)
        try writer["InstanceAlias"].write(value.instanceAlias)
        try writer["OutboundCallsEnabled"].write(value.outboundCallsEnabled)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateIntegrationAssociationInput {

    static func write(value: CreateIntegrationAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IntegrationArn"].write(value.integrationArn)
        try writer["IntegrationType"].write(value.integrationType)
        try writer["SourceApplicationName"].write(value.sourceApplicationName)
        try writer["SourceApplicationUrl"].write(value.sourceApplicationUrl)
        try writer["SourceType"].write(value.sourceType)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateParticipantInput {

    static func write(value: CreateParticipantInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["ContactId"].write(value.contactId)
        try writer["InstanceId"].write(value.instanceId)
        try writer["ParticipantDetails"].write(value.participantDetails, with: ConnectClientTypes.ParticipantDetailsToAdd.write(value:to:))
    }
}

extension CreatePersistentContactAssociationInput {

    static func write(value: CreatePersistentContactAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["RehydrationType"].write(value.rehydrationType)
        try writer["SourceContactId"].write(value.sourceContactId)
    }
}

extension CreatePredefinedAttributeInput {

    static func write(value: CreatePredefinedAttributeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Values"].write(value.values, with: ConnectClientTypes.PredefinedAttributeValues.write(value:to:))
    }
}

extension CreatePromptInput {

    static func write(value: CreatePromptInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["S3Uri"].write(value.s3Uri)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateQueueInput {

    static func write(value: CreateQueueInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["HoursOfOperationId"].write(value.hoursOfOperationId)
        try writer["MaxContacts"].write(value.maxContacts)
        try writer["Name"].write(value.name)
        try writer["OutboundCallerConfig"].write(value.outboundCallerConfig, with: ConnectClientTypes.OutboundCallerConfig.write(value:to:))
        try writer["QuickConnectIds"].writeList(value.quickConnectIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateQuickConnectInput {

    static func write(value: CreateQuickConnectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["QuickConnectConfig"].write(value.quickConnectConfig, with: ConnectClientTypes.QuickConnectConfig.write(value:to:))
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateRoutingProfileInput {

    static func write(value: CreateRoutingProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AgentAvailabilityTimer"].write(value.agentAvailabilityTimer)
        try writer["DefaultOutboundQueueId"].write(value.defaultOutboundQueueId)
        try writer["Description"].write(value.description)
        try writer["MediaConcurrencies"].writeList(value.mediaConcurrencies, memberWritingClosure: ConnectClientTypes.MediaConcurrency.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["QueueConfigs"].writeList(value.queueConfigs, memberWritingClosure: ConnectClientTypes.RoutingProfileQueueConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateRuleInput {

    static func write(value: CreateRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Actions"].writeList(value.actions, memberWritingClosure: ConnectClientTypes.RuleAction.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ClientToken"].write(value.clientToken)
        try writer["Function"].write(value.function)
        try writer["Name"].write(value.name)
        try writer["PublishStatus"].write(value.publishStatus)
        try writer["TriggerEventSource"].write(value.triggerEventSource, with: ConnectClientTypes.RuleTriggerEventSource.write(value:to:))
    }
}

extension CreateSecurityProfileInput {

    static func write(value: CreateSecurityProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowedAccessControlHierarchyGroupId"].write(value.allowedAccessControlHierarchyGroupId)
        try writer["AllowedAccessControlTags"].writeMap(value.allowedAccessControlTags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Applications"].writeList(value.applications, memberWritingClosure: ConnectClientTypes.Application.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Description"].write(value.description)
        try writer["HierarchyRestrictedResources"].writeList(value.hierarchyRestrictedResources, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Permissions"].writeList(value.permissions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SecurityProfileName"].write(value.securityProfileName)
        try writer["TagRestrictedResources"].writeList(value.tagRestrictedResources, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateTaskTemplateInput {

    static func write(value: CreateTaskTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["Constraints"].write(value.constraints, with: ConnectClientTypes.TaskTemplateConstraints.write(value:to:))
        try writer["ContactFlowId"].write(value.contactFlowId)
        try writer["Defaults"].write(value.defaults, with: ConnectClientTypes.TaskTemplateDefaults.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["Fields"].writeList(value.fields, memberWritingClosure: ConnectClientTypes.TaskTemplateField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["Status"].write(value.status)
    }
}

extension CreateTrafficDistributionGroupInput {

    static func write(value: CreateTrafficDistributionGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["Description"].write(value.description)
        try writer["InstanceId"].write(value.instanceId)
        try writer["Name"].write(value.name)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateUseCaseInput {

    static func write(value: CreateUseCaseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["UseCaseType"].write(value.useCaseType)
    }
}

extension CreateUserInput {

    static func write(value: CreateUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DirectoryUserId"].write(value.directoryUserId)
        try writer["HierarchyGroupId"].write(value.hierarchyGroupId)
        try writer["IdentityInfo"].write(value.identityInfo, with: ConnectClientTypes.UserIdentityInfo.write(value:to:))
        try writer["Password"].write(value.password)
        try writer["PhoneConfig"].write(value.phoneConfig, with: ConnectClientTypes.UserPhoneConfig.write(value:to:))
        try writer["RoutingProfileId"].write(value.routingProfileId)
        try writer["SecurityProfileIds"].writeList(value.securityProfileIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Username"].write(value.username)
    }
}

extension CreateUserHierarchyGroupInput {

    static func write(value: CreateUserHierarchyGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["ParentGroupId"].write(value.parentGroupId)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateViewInput {

    static func write(value: CreateViewInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["Content"].write(value.content, with: ConnectClientTypes.ViewInputContent.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["Status"].write(value.status)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateViewVersionInput {

    static func write(value: CreateViewVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["VersionDescription"].write(value.versionDescription)
        try writer["ViewContentSha256"].write(value.viewContentSha256)
    }
}

extension CreateVocabularyInput {

    static func write(value: CreateVocabularyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["Content"].write(value.content)
        try writer["LanguageCode"].write(value.languageCode)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["VocabularyName"].write(value.vocabularyName)
    }
}

extension DeactivateEvaluationFormInput {

    static func write(value: DeactivateEvaluationFormInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EvaluationFormVersion"].write(value.evaluationFormVersion)
    }
}

extension DisassociateAnalyticsDataSetInput {

    static func write(value: DisassociateAnalyticsDataSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataSetId"].write(value.dataSetId)
        try writer["TargetAccountId"].write(value.targetAccountId)
    }
}

extension DisassociateBotInput {

    static func write(value: DisassociateBotInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LexBot"].write(value.lexBot, with: ConnectClientTypes.LexBot.write(value:to:))
        try writer["LexV2Bot"].write(value.lexV2Bot, with: ConnectClientTypes.LexV2Bot.write(value:to:))
    }
}

extension DisassociateQueueQuickConnectsInput {

    static func write(value: DisassociateQueueQuickConnectsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["QuickConnectIds"].writeList(value.quickConnectIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DisassociateRoutingProfileQueuesInput {

    static func write(value: DisassociateRoutingProfileQueuesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["QueueReferences"].writeList(value.queueReferences, memberWritingClosure: ConnectClientTypes.RoutingProfileQueueReference.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DisassociateUserProficienciesInput {

    static func write(value: DisassociateUserProficienciesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["UserProficiencies"].writeList(value.userProficiencies, memberWritingClosure: ConnectClientTypes.UserProficiencyDisassociate.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DismissUserContactInput {

    static func write(value: DismissUserContactInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactId"].write(value.contactId)
    }
}

extension GetCurrentMetricDataInput {

    static func write(value: GetCurrentMetricDataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CurrentMetrics"].writeList(value.currentMetrics, memberWritingClosure: ConnectClientTypes.CurrentMetric.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Filters"].write(value.filters, with: ConnectClientTypes.Filters.write(value:to:))
        try writer["Groupings"].writeList(value.groupings, memberWritingClosure: SmithyReadWrite.WritingClosureBox<ConnectClientTypes.Grouping>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SortCriteria"].writeList(value.sortCriteria, memberWritingClosure: ConnectClientTypes.CurrentMetricSortCriteria.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GetCurrentUserDataInput {

    static func write(value: GetCurrentUserDataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].write(value.filters, with: ConnectClientTypes.UserDataFilters.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension GetMetricDataInput {

    static func write(value: GetMetricDataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Filters"].write(value.filters, with: ConnectClientTypes.Filters.write(value:to:))
        try writer["Groupings"].writeList(value.groupings, memberWritingClosure: SmithyReadWrite.WritingClosureBox<ConnectClientTypes.Grouping>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["HistoricalMetrics"].writeList(value.historicalMetrics, memberWritingClosure: ConnectClientTypes.HistoricalMetric.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["StartTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension GetMetricDataV2Input {

    static func write(value: GetMetricDataV2Input?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Filters"].writeList(value.filters, memberWritingClosure: ConnectClientTypes.FilterV2.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Groupings"].writeList(value.groupings, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Interval"].write(value.interval, with: ConnectClientTypes.IntervalDetails.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["Metrics"].writeList(value.metrics, memberWritingClosure: ConnectClientTypes.MetricV2.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["StartTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension ImportPhoneNumberInput {

    static func write(value: ImportPhoneNumberInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["InstanceId"].write(value.instanceId)
        try writer["PhoneNumberDescription"].write(value.phoneNumberDescription)
        try writer["SourcePhoneNumberArn"].write(value.sourcePhoneNumberArn)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension ListDefaultVocabulariesInput {

    static func write(value: ListDefaultVocabulariesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LanguageCode"].write(value.languageCode)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListPhoneNumbersV2Input {

    static func write(value: ListPhoneNumbersV2Input?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceId"].write(value.instanceId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["PhoneNumberCountryCodes"].writeList(value.phoneNumberCountryCodes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<ConnectClientTypes.PhoneNumberCountryCode>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PhoneNumberPrefix"].write(value.phoneNumberPrefix)
        try writer["PhoneNumberTypes"].writeList(value.phoneNumberTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<ConnectClientTypes.PhoneNumberType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TargetArn"].write(value.targetArn)
    }
}

extension ListRealtimeContactAnalysisSegmentsV2Input {

    static func write(value: ListRealtimeContactAnalysisSegmentsV2Input?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["OutputType"].write(value.outputType)
        try writer["SegmentTypes"].writeList(value.segmentTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<ConnectClientTypes.RealTimeContactAnalysisSegmentType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension MonitorContactInput {

    static func write(value: MonitorContactInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowedMonitorCapabilities"].writeList(value.allowedMonitorCapabilities, memberWritingClosure: SmithyReadWrite.WritingClosureBox<ConnectClientTypes.MonitorCapability>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ClientToken"].write(value.clientToken)
        try writer["ContactId"].write(value.contactId)
        try writer["InstanceId"].write(value.instanceId)
        try writer["UserId"].write(value.userId)
    }
}

extension PauseContactInput {

    static func write(value: PauseContactInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactFlowId"].write(value.contactFlowId)
        try writer["ContactId"].write(value.contactId)
        try writer["InstanceId"].write(value.instanceId)
    }
}

extension PutUserStatusInput {

    static func write(value: PutUserStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AgentStatusId"].write(value.agentStatusId)
    }
}

extension ReplicateInstanceInput {

    static func write(value: ReplicateInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["ReplicaAlias"].write(value.replicaAlias)
        try writer["ReplicaRegion"].write(value.replicaRegion)
    }
}

extension ResumeContactInput {

    static func write(value: ResumeContactInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactFlowId"].write(value.contactFlowId)
        try writer["ContactId"].write(value.contactId)
        try writer["InstanceId"].write(value.instanceId)
    }
}

extension ResumeContactRecordingInput {

    static func write(value: ResumeContactRecordingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactId"].write(value.contactId)
        try writer["InitialContactId"].write(value.initialContactId)
        try writer["InstanceId"].write(value.instanceId)
    }
}

extension SearchAgentStatusesInput {

    static func write(value: SearchAgentStatusesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceId"].write(value.instanceId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SearchCriteria"].write(value.searchCriteria, with: ConnectClientTypes.AgentStatusSearchCriteria.write(value:to:))
        try writer["SearchFilter"].write(value.searchFilter, with: ConnectClientTypes.AgentStatusSearchFilter.write(value:to:))
    }
}

extension SearchAvailablePhoneNumbersInput {

    static func write(value: SearchAvailablePhoneNumbersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceId"].write(value.instanceId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["PhoneNumberCountryCode"].write(value.phoneNumberCountryCode)
        try writer["PhoneNumberPrefix"].write(value.phoneNumberPrefix)
        try writer["PhoneNumberType"].write(value.phoneNumberType)
        try writer["TargetArn"].write(value.targetArn)
    }
}

extension SearchContactFlowModulesInput {

    static func write(value: SearchContactFlowModulesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceId"].write(value.instanceId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SearchCriteria"].write(value.searchCriteria, with: ConnectClientTypes.ContactFlowModuleSearchCriteria.write(value:to:))
        try writer["SearchFilter"].write(value.searchFilter, with: ConnectClientTypes.ContactFlowModuleSearchFilter.write(value:to:))
    }
}

extension SearchContactFlowsInput {

    static func write(value: SearchContactFlowsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceId"].write(value.instanceId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SearchCriteria"].write(value.searchCriteria, with: ConnectClientTypes.ContactFlowSearchCriteria.write(value:to:))
        try writer["SearchFilter"].write(value.searchFilter, with: ConnectClientTypes.ContactFlowSearchFilter.write(value:to:))
    }
}

extension SearchContactsInput {

    static func write(value: SearchContactsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceId"].write(value.instanceId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SearchCriteria"].write(value.searchCriteria, with: ConnectClientTypes.SearchCriteria.write(value:to:))
        try writer["Sort"].write(value.sort, with: ConnectClientTypes.Sort.write(value:to:))
        try writer["TimeRange"].write(value.timeRange, with: ConnectClientTypes.SearchContactsTimeRange.write(value:to:))
    }
}

extension SearchHoursOfOperationsInput {

    static func write(value: SearchHoursOfOperationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceId"].write(value.instanceId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SearchCriteria"].write(value.searchCriteria, with: ConnectClientTypes.HoursOfOperationSearchCriteria.write(value:to:))
        try writer["SearchFilter"].write(value.searchFilter, with: ConnectClientTypes.HoursOfOperationSearchFilter.write(value:to:))
    }
}

extension SearchPredefinedAttributesInput {

    static func write(value: SearchPredefinedAttributesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceId"].write(value.instanceId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SearchCriteria"].write(value.searchCriteria, with: ConnectClientTypes.PredefinedAttributeSearchCriteria.write(value:to:))
    }
}

extension SearchPromptsInput {

    static func write(value: SearchPromptsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceId"].write(value.instanceId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SearchCriteria"].write(value.searchCriteria, with: ConnectClientTypes.PromptSearchCriteria.write(value:to:))
        try writer["SearchFilter"].write(value.searchFilter, with: ConnectClientTypes.PromptSearchFilter.write(value:to:))
    }
}

extension SearchQueuesInput {

    static func write(value: SearchQueuesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceId"].write(value.instanceId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SearchCriteria"].write(value.searchCriteria, with: ConnectClientTypes.QueueSearchCriteria.write(value:to:))
        try writer["SearchFilter"].write(value.searchFilter, with: ConnectClientTypes.QueueSearchFilter.write(value:to:))
    }
}

extension SearchQuickConnectsInput {

    static func write(value: SearchQuickConnectsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceId"].write(value.instanceId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SearchCriteria"].write(value.searchCriteria, with: ConnectClientTypes.QuickConnectSearchCriteria.write(value:to:))
        try writer["SearchFilter"].write(value.searchFilter, with: ConnectClientTypes.QuickConnectSearchFilter.write(value:to:))
    }
}

extension SearchResourceTagsInput {

    static func write(value: SearchResourceTagsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceId"].write(value.instanceId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceTypes"].writeList(value.resourceTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SearchCriteria"].write(value.searchCriteria, with: ConnectClientTypes.ResourceTagsSearchCriteria.write(value:to:))
    }
}

extension SearchRoutingProfilesInput {

    static func write(value: SearchRoutingProfilesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceId"].write(value.instanceId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SearchCriteria"].write(value.searchCriteria, with: ConnectClientTypes.RoutingProfileSearchCriteria.write(value:to:))
        try writer["SearchFilter"].write(value.searchFilter, with: ConnectClientTypes.RoutingProfileSearchFilter.write(value:to:))
    }
}

extension SearchSecurityProfilesInput {

    static func write(value: SearchSecurityProfilesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceId"].write(value.instanceId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SearchCriteria"].write(value.searchCriteria, with: ConnectClientTypes.SecurityProfileSearchCriteria.write(value:to:))
        try writer["SearchFilter"].write(value.searchFilter, with: ConnectClientTypes.SecurityProfilesSearchFilter.write(value:to:))
    }
}

extension SearchUserHierarchyGroupsInput {

    static func write(value: SearchUserHierarchyGroupsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceId"].write(value.instanceId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SearchCriteria"].write(value.searchCriteria, with: ConnectClientTypes.UserHierarchyGroupSearchCriteria.write(value:to:))
        try writer["SearchFilter"].write(value.searchFilter, with: ConnectClientTypes.UserHierarchyGroupSearchFilter.write(value:to:))
    }
}

extension SearchUsersInput {

    static func write(value: SearchUsersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceId"].write(value.instanceId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SearchCriteria"].write(value.searchCriteria, with: ConnectClientTypes.UserSearchCriteria.write(value:to:))
        try writer["SearchFilter"].write(value.searchFilter, with: ConnectClientTypes.UserSearchFilter.write(value:to:))
    }
}

extension SearchVocabulariesInput {

    static func write(value: SearchVocabulariesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LanguageCode"].write(value.languageCode)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NameStartsWith"].write(value.nameStartsWith)
        try writer["NextToken"].write(value.nextToken)
        try writer["State"].write(value.state)
    }
}

extension SendChatIntegrationEventInput {

    static func write(value: SendChatIntegrationEventInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationId"].write(value.destinationId)
        try writer["Event"].write(value.event, with: ConnectClientTypes.ChatEvent.write(value:to:))
        try writer["NewSessionDetails"].write(value.newSessionDetails, with: ConnectClientTypes.NewSessionDetails.write(value:to:))
        try writer["SourceId"].write(value.sourceId)
        try writer["Subtype"].write(value.subtype)
    }
}

extension StartAttachedFileUploadInput {

    static func write(value: StartAttachedFileUploadInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["CreatedBy"].write(value.createdBy, with: ConnectClientTypes.CreatedByInfo.write(value:to:))
        try writer["FileName"].write(value.fileName)
        try writer["FileSizeInBytes"].write(value.fileSizeInBytes)
        try writer["FileUseCaseType"].write(value.fileUseCaseType)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["UrlExpiryInSeconds"].write(value.urlExpiryInSeconds)
    }
}

extension StartChatContactInput {

    static func write(value: StartChatContactInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ChatDurationInMinutes"].write(value.chatDurationInMinutes)
        try writer["ClientToken"].write(value.clientToken)
        try writer["ContactFlowId"].write(value.contactFlowId)
        try writer["InitialMessage"].write(value.initialMessage, with: ConnectClientTypes.ChatMessage.write(value:to:))
        try writer["InstanceId"].write(value.instanceId)
        try writer["ParticipantDetails"].write(value.participantDetails, with: ConnectClientTypes.ParticipantDetails.write(value:to:))
        try writer["PersistentChat"].write(value.persistentChat, with: ConnectClientTypes.PersistentChat.write(value:to:))
        try writer["RelatedContactId"].write(value.relatedContactId)
        try writer["SegmentAttributes"].writeMap(value.segmentAttributes, valueWritingClosure: ConnectClientTypes.SegmentAttributeValue.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["SupportedMessagingContentTypes"].writeList(value.supportedMessagingContentTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension StartContactEvaluationInput {

    static func write(value: StartContactEvaluationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["ContactId"].write(value.contactId)
        try writer["EvaluationFormId"].write(value.evaluationFormId)
    }
}

extension StartContactRecordingInput {

    static func write(value: StartContactRecordingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactId"].write(value.contactId)
        try writer["InitialContactId"].write(value.initialContactId)
        try writer["InstanceId"].write(value.instanceId)
        try writer["VoiceRecordingConfiguration"].write(value.voiceRecordingConfiguration, with: ConnectClientTypes.VoiceRecordingConfiguration.write(value:to:))
    }
}

extension StartContactStreamingInput {

    static func write(value: StartContactStreamingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChatStreamingConfiguration"].write(value.chatStreamingConfiguration, with: ConnectClientTypes.ChatStreamingConfiguration.write(value:to:))
        try writer["ClientToken"].write(value.clientToken)
        try writer["ContactId"].write(value.contactId)
        try writer["InstanceId"].write(value.instanceId)
    }
}

extension StartOutboundVoiceContactInput {

    static func write(value: StartOutboundVoiceContactInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnswerMachineDetectionConfig"].write(value.answerMachineDetectionConfig, with: ConnectClientTypes.AnswerMachineDetectionConfig.write(value:to:))
        try writer["Attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["CampaignId"].write(value.campaignId)
        try writer["ClientToken"].write(value.clientToken)
        try writer["ContactFlowId"].write(value.contactFlowId)
        try writer["Description"].write(value.description)
        try writer["DestinationPhoneNumber"].write(value.destinationPhoneNumber)
        try writer["InstanceId"].write(value.instanceId)
        try writer["Name"].write(value.name)
        try writer["QueueId"].write(value.queueId)
        try writer["References"].writeMap(value.references, valueWritingClosure: ConnectClientTypes.Reference.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["RelatedContactId"].write(value.relatedContactId)
        try writer["SourcePhoneNumber"].write(value.sourcePhoneNumber)
        try writer["TrafficType"].write(value.trafficType)
    }
}

extension StartTaskContactInput {

    static func write(value: StartTaskContactInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ClientToken"].write(value.clientToken)
        try writer["ContactFlowId"].write(value.contactFlowId)
        try writer["Description"].write(value.description)
        try writer["InstanceId"].write(value.instanceId)
        try writer["Name"].write(value.name)
        try writer["PreviousContactId"].write(value.previousContactId)
        try writer["QuickConnectId"].write(value.quickConnectId)
        try writer["References"].writeMap(value.references, valueWritingClosure: ConnectClientTypes.Reference.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["RelatedContactId"].write(value.relatedContactId)
        try writer["ScheduledTime"].writeTimestamp(value.scheduledTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["TaskTemplateId"].write(value.taskTemplateId)
    }
}

extension StartWebRTCContactInput {

    static func write(value: StartWebRTCContactInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowedCapabilities"].write(value.allowedCapabilities, with: ConnectClientTypes.AllowedCapabilities.write(value:to:))
        try writer["Attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ClientToken"].write(value.clientToken)
        try writer["ContactFlowId"].write(value.contactFlowId)
        try writer["Description"].write(value.description)
        try writer["InstanceId"].write(value.instanceId)
        try writer["ParticipantDetails"].write(value.participantDetails, with: ConnectClientTypes.ParticipantDetails.write(value:to:))
        try writer["References"].writeMap(value.references, valueWritingClosure: ConnectClientTypes.Reference.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["RelatedContactId"].write(value.relatedContactId)
    }
}

extension StopContactInput {

    static func write(value: StopContactInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactId"].write(value.contactId)
        try writer["DisconnectReason"].write(value.disconnectReason, with: ConnectClientTypes.DisconnectReason.write(value:to:))
        try writer["InstanceId"].write(value.instanceId)
    }
}

extension StopContactRecordingInput {

    static func write(value: StopContactRecordingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactId"].write(value.contactId)
        try writer["InitialContactId"].write(value.initialContactId)
        try writer["InstanceId"].write(value.instanceId)
    }
}

extension StopContactStreamingInput {

    static func write(value: StopContactStreamingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactId"].write(value.contactId)
        try writer["InstanceId"].write(value.instanceId)
        try writer["StreamingId"].write(value.streamingId)
    }
}

extension SubmitContactEvaluationInput {

    static func write(value: SubmitContactEvaluationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Answers"].writeMap(value.answers, valueWritingClosure: ConnectClientTypes.EvaluationAnswerInput.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Notes"].writeMap(value.notes, valueWritingClosure: ConnectClientTypes.EvaluationNote.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension SuspendContactRecordingInput {

    static func write(value: SuspendContactRecordingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactId"].write(value.contactId)
        try writer["InitialContactId"].write(value.initialContactId)
        try writer["InstanceId"].write(value.instanceId)
    }
}

extension TagContactInput {

    static func write(value: TagContactInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactId"].write(value.contactId)
        try writer["InstanceId"].write(value.instanceId)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension TransferContactInput {

    static func write(value: TransferContactInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["ContactFlowId"].write(value.contactFlowId)
        try writer["ContactId"].write(value.contactId)
        try writer["InstanceId"].write(value.instanceId)
        try writer["QueueId"].write(value.queueId)
        try writer["UserId"].write(value.userId)
    }
}

extension UpdateAgentStatusInput {

    static func write(value: UpdateAgentStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["DisplayOrder"].write(value.displayOrder)
        try writer["Name"].write(value.name)
        try writer["ResetOrderNumber"].write(value.resetOrderNumber)
        try writer["State"].write(value.state)
    }
}

extension UpdateAuthenticationProfileInput {

    static func write(value: UpdateAuthenticationProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowedIps"].writeList(value.allowedIps, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["BlockedIps"].writeList(value.blockedIps, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["PeriodicSessionDuration"].write(value.periodicSessionDuration)
    }
}

extension UpdateContactInput {

    static func write(value: UpdateContactInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["References"].writeMap(value.references, valueWritingClosure: ConnectClientTypes.Reference.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateContactAttributesInput {

    static func write(value: UpdateContactAttributesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["InitialContactId"].write(value.initialContactId)
        try writer["InstanceId"].write(value.instanceId)
    }
}

extension UpdateContactEvaluationInput {

    static func write(value: UpdateContactEvaluationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Answers"].writeMap(value.answers, valueWritingClosure: ConnectClientTypes.EvaluationAnswerInput.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Notes"].writeMap(value.notes, valueWritingClosure: ConnectClientTypes.EvaluationNote.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateContactFlowContentInput {

    static func write(value: UpdateContactFlowContentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Content"].write(value.content)
    }
}

extension UpdateContactFlowMetadataInput {

    static func write(value: UpdateContactFlowMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactFlowState"].write(value.contactFlowState)
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
    }
}

extension UpdateContactFlowModuleContentInput {

    static func write(value: UpdateContactFlowModuleContentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Content"].write(value.content)
    }
}

extension UpdateContactFlowModuleMetadataInput {

    static func write(value: UpdateContactFlowModuleMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["State"].write(value.state)
    }
}

extension UpdateContactFlowNameInput {

    static func write(value: UpdateContactFlowNameInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
    }
}

extension UpdateContactRoutingDataInput {

    static func write(value: UpdateContactRoutingDataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["QueuePriority"].write(value.queuePriority)
        try writer["QueueTimeAdjustmentSeconds"].write(value.queueTimeAdjustmentSeconds)
        try writer["RoutingCriteria"].write(value.routingCriteria, with: ConnectClientTypes.RoutingCriteriaInput.write(value:to:))
    }
}

extension UpdateContactScheduleInput {

    static func write(value: UpdateContactScheduleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactId"].write(value.contactId)
        try writer["InstanceId"].write(value.instanceId)
        try writer["ScheduledTime"].writeTimestamp(value.scheduledTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension UpdateEvaluationFormInput {

    static func write(value: UpdateEvaluationFormInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["CreateNewVersion"].write(value.createNewVersion)
        try writer["Description"].write(value.description)
        try writer["EvaluationFormVersion"].write(value.evaluationFormVersion)
        try writer["Items"].writeList(value.items, memberWritingClosure: ConnectClientTypes.EvaluationFormItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ScoringStrategy"].write(value.scoringStrategy, with: ConnectClientTypes.EvaluationFormScoringStrategy.write(value:to:))
        try writer["Title"].write(value.title)
    }
}

extension UpdateHoursOfOperationInput {

    static func write(value: UpdateHoursOfOperationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Config"].writeList(value.config, memberWritingClosure: ConnectClientTypes.HoursOfOperationConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["TimeZone"].write(value.timeZone)
    }
}

extension UpdateInstanceAttributeInput {

    static func write(value: UpdateInstanceAttributeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Value"].write(value.value)
    }
}

extension UpdateInstanceStorageConfigInput {

    static func write(value: UpdateInstanceStorageConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StorageConfig"].write(value.storageConfig, with: ConnectClientTypes.InstanceStorageConfig.write(value:to:))
    }
}

extension UpdateParticipantRoleConfigInput {

    static func write(value: UpdateParticipantRoleConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChannelConfiguration"].write(value.channelConfiguration, with: ConnectClientTypes.UpdateParticipantRoleConfigChannelInfo.write(value:to:))
    }
}

extension UpdatePhoneNumberInput {

    static func write(value: UpdatePhoneNumberInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["InstanceId"].write(value.instanceId)
        try writer["TargetArn"].write(value.targetArn)
    }
}

extension UpdatePhoneNumberMetadataInput {

    static func write(value: UpdatePhoneNumberMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["PhoneNumberDescription"].write(value.phoneNumberDescription)
    }
}

extension UpdatePredefinedAttributeInput {

    static func write(value: UpdatePredefinedAttributeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Values"].write(value.values, with: ConnectClientTypes.PredefinedAttributeValues.write(value:to:))
    }
}

extension UpdatePromptInput {

    static func write(value: UpdatePromptInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["S3Uri"].write(value.s3Uri)
    }
}

extension UpdateQueueHoursOfOperationInput {

    static func write(value: UpdateQueueHoursOfOperationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HoursOfOperationId"].write(value.hoursOfOperationId)
    }
}

extension UpdateQueueMaxContactsInput {

    static func write(value: UpdateQueueMaxContactsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxContacts"].write(value.maxContacts)
    }
}

extension UpdateQueueNameInput {

    static func write(value: UpdateQueueNameInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
    }
}

extension UpdateQueueOutboundCallerConfigInput {

    static func write(value: UpdateQueueOutboundCallerConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OutboundCallerConfig"].write(value.outboundCallerConfig, with: ConnectClientTypes.OutboundCallerConfig.write(value:to:))
    }
}

extension UpdateQueueStatusInput {

    static func write(value: UpdateQueueStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Status"].write(value.status)
    }
}

extension UpdateQuickConnectConfigInput {

    static func write(value: UpdateQuickConnectConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["QuickConnectConfig"].write(value.quickConnectConfig, with: ConnectClientTypes.QuickConnectConfig.write(value:to:))
    }
}

extension UpdateQuickConnectNameInput {

    static func write(value: UpdateQuickConnectNameInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
    }
}

extension UpdateRoutingProfileAgentAvailabilityTimerInput {

    static func write(value: UpdateRoutingProfileAgentAvailabilityTimerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AgentAvailabilityTimer"].write(value.agentAvailabilityTimer)
    }
}

extension UpdateRoutingProfileConcurrencyInput {

    static func write(value: UpdateRoutingProfileConcurrencyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MediaConcurrencies"].writeList(value.mediaConcurrencies, memberWritingClosure: ConnectClientTypes.MediaConcurrency.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateRoutingProfileDefaultOutboundQueueInput {

    static func write(value: UpdateRoutingProfileDefaultOutboundQueueInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultOutboundQueueId"].write(value.defaultOutboundQueueId)
    }
}

extension UpdateRoutingProfileNameInput {

    static func write(value: UpdateRoutingProfileNameInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
    }
}

extension UpdateRoutingProfileQueuesInput {

    static func write(value: UpdateRoutingProfileQueuesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["QueueConfigs"].writeList(value.queueConfigs, memberWritingClosure: ConnectClientTypes.RoutingProfileQueueConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateRuleInput {

    static func write(value: UpdateRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Actions"].writeList(value.actions, memberWritingClosure: ConnectClientTypes.RuleAction.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Function"].write(value.function)
        try writer["Name"].write(value.name)
        try writer["PublishStatus"].write(value.publishStatus)
    }
}

extension UpdateSecurityProfileInput {

    static func write(value: UpdateSecurityProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowedAccessControlHierarchyGroupId"].write(value.allowedAccessControlHierarchyGroupId)
        try writer["AllowedAccessControlTags"].writeMap(value.allowedAccessControlTags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Applications"].writeList(value.applications, memberWritingClosure: ConnectClientTypes.Application.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Description"].write(value.description)
        try writer["HierarchyRestrictedResources"].writeList(value.hierarchyRestrictedResources, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Permissions"].writeList(value.permissions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TagRestrictedResources"].writeList(value.tagRestrictedResources, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateTaskTemplateInput {

    static func write(value: UpdateTaskTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Constraints"].write(value.constraints, with: ConnectClientTypes.TaskTemplateConstraints.write(value:to:))
        try writer["ContactFlowId"].write(value.contactFlowId)
        try writer["Defaults"].write(value.defaults, with: ConnectClientTypes.TaskTemplateDefaults.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["Fields"].writeList(value.fields, memberWritingClosure: ConnectClientTypes.TaskTemplateField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["Status"].write(value.status)
    }
}

extension UpdateTrafficDistributionInput {

    static func write(value: UpdateTrafficDistributionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AgentConfig"].write(value.agentConfig, with: ConnectClientTypes.AgentConfig.write(value:to:))
        try writer["SignInConfig"].write(value.signInConfig, with: ConnectClientTypes.SignInConfig.write(value:to:))
        try writer["TelephonyConfig"].write(value.telephonyConfig, with: ConnectClientTypes.TelephonyConfig.write(value:to:))
    }
}

extension UpdateUserHierarchyInput {

    static func write(value: UpdateUserHierarchyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HierarchyGroupId"].write(value.hierarchyGroupId)
    }
}

extension UpdateUserHierarchyGroupNameInput {

    static func write(value: UpdateUserHierarchyGroupNameInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension UpdateUserHierarchyStructureInput {

    static func write(value: UpdateUserHierarchyStructureInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HierarchyStructure"].write(value.hierarchyStructure, with: ConnectClientTypes.HierarchyStructureUpdate.write(value:to:))
    }
}

extension UpdateUserIdentityInfoInput {

    static func write(value: UpdateUserIdentityInfoInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IdentityInfo"].write(value.identityInfo, with: ConnectClientTypes.UserIdentityInfo.write(value:to:))
    }
}

extension UpdateUserPhoneConfigInput {

    static func write(value: UpdateUserPhoneConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PhoneConfig"].write(value.phoneConfig, with: ConnectClientTypes.UserPhoneConfig.write(value:to:))
    }
}

extension UpdateUserProficienciesInput {

    static func write(value: UpdateUserProficienciesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["UserProficiencies"].writeList(value.userProficiencies, memberWritingClosure: ConnectClientTypes.UserProficiency.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateUserRoutingProfileInput {

    static func write(value: UpdateUserRoutingProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RoutingProfileId"].write(value.routingProfileId)
    }
}

extension UpdateUserSecurityProfilesInput {

    static func write(value: UpdateUserSecurityProfilesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SecurityProfileIds"].writeList(value.securityProfileIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateViewContentInput {

    static func write(value: UpdateViewContentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Content"].write(value.content, with: ConnectClientTypes.ViewInputContent.write(value:to:))
        try writer["Status"].write(value.status)
    }
}

extension UpdateViewMetadataInput {

    static func write(value: UpdateViewMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
    }
}

extension ActivateEvaluationFormOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ActivateEvaluationFormOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ActivateEvaluationFormOutput()
        value.evaluationFormArn = try reader["EvaluationFormArn"].readIfPresent() ?? ""
        value.evaluationFormId = try reader["EvaluationFormId"].readIfPresent() ?? ""
        value.evaluationFormVersion = try reader["EvaluationFormVersion"].readIfPresent() ?? 0
        return value
    }
}

extension AssociateAnalyticsDataSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateAnalyticsDataSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateAnalyticsDataSetOutput()
        value.dataSetId = try reader["DataSetId"].readIfPresent()
        value.resourceShareArn = try reader["ResourceShareArn"].readIfPresent()
        value.resourceShareId = try reader["ResourceShareId"].readIfPresent()
        value.targetAccountId = try reader["TargetAccountId"].readIfPresent()
        return value
    }
}

extension AssociateApprovedOriginOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateApprovedOriginOutput {
        return AssociateApprovedOriginOutput()
    }
}

extension AssociateBotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateBotOutput {
        return AssociateBotOutput()
    }
}

extension AssociateDefaultVocabularyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateDefaultVocabularyOutput {
        return AssociateDefaultVocabularyOutput()
    }
}

extension AssociateFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateFlowOutput {
        return AssociateFlowOutput()
    }
}

extension AssociateInstanceStorageConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateInstanceStorageConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateInstanceStorageConfigOutput()
        value.associationId = try reader["AssociationId"].readIfPresent()
        return value
    }
}

extension AssociateLambdaFunctionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateLambdaFunctionOutput {
        return AssociateLambdaFunctionOutput()
    }
}

extension AssociateLexBotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateLexBotOutput {
        return AssociateLexBotOutput()
    }
}

extension AssociatePhoneNumberContactFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociatePhoneNumberContactFlowOutput {
        return AssociatePhoneNumberContactFlowOutput()
    }
}

extension AssociateQueueQuickConnectsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateQueueQuickConnectsOutput {
        return AssociateQueueQuickConnectsOutput()
    }
}

extension AssociateRoutingProfileQueuesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateRoutingProfileQueuesOutput {
        return AssociateRoutingProfileQueuesOutput()
    }
}

extension AssociateSecurityKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateSecurityKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateSecurityKeyOutput()
        value.associationId = try reader["AssociationId"].readIfPresent()
        return value
    }
}

extension AssociateTrafficDistributionGroupUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateTrafficDistributionGroupUserOutput {
        return AssociateTrafficDistributionGroupUserOutput()
    }
}

extension AssociateUserProficienciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateUserProficienciesOutput {
        return AssociateUserProficienciesOutput()
    }
}

extension BatchAssociateAnalyticsDataSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchAssociateAnalyticsDataSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchAssociateAnalyticsDataSetOutput()
        value.created = try reader["Created"].readListIfPresent(memberReadingClosure: ConnectClientTypes.AnalyticsDataAssociationResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: ConnectClientTypes.ErrorResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchDisassociateAnalyticsDataSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDisassociateAnalyticsDataSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDisassociateAnalyticsDataSetOutput()
        value.deleted = try reader["Deleted"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: ConnectClientTypes.ErrorResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchGetAttachedFileMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetAttachedFileMetadataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetAttachedFileMetadataOutput()
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: ConnectClientTypes.AttachedFileError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.files = try reader["Files"].readListIfPresent(memberReadingClosure: ConnectClientTypes.AttachedFile.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchGetFlowAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetFlowAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetFlowAssociationOutput()
        value.flowAssociationSummaryList = try reader["FlowAssociationSummaryList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.FlowAssociationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchPutContactOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchPutContactOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchPutContactOutput()
        value.failedRequestList = try reader["FailedRequestList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.FailedRequest.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.successfulRequestList = try reader["SuccessfulRequestList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.SuccessfulRequest.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ClaimPhoneNumberOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ClaimPhoneNumberOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ClaimPhoneNumberOutput()
        value.phoneNumberArn = try reader["PhoneNumberArn"].readIfPresent()
        value.phoneNumberId = try reader["PhoneNumberId"].readIfPresent()
        return value
    }
}

extension CompleteAttachedFileUploadOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CompleteAttachedFileUploadOutput {
        return CompleteAttachedFileUploadOutput()
    }
}

extension CreateAgentStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAgentStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAgentStatusOutput()
        value.agentStatusARN = try reader["AgentStatusARN"].readIfPresent()
        value.agentStatusId = try reader["AgentStatusId"].readIfPresent()
        return value
    }
}

extension CreateContactFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateContactFlowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateContactFlowOutput()
        value.contactFlowArn = try reader["ContactFlowArn"].readIfPresent()
        value.contactFlowId = try reader["ContactFlowId"].readIfPresent()
        return value
    }
}

extension CreateContactFlowModuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateContactFlowModuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateContactFlowModuleOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        return value
    }
}

extension CreateEvaluationFormOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateEvaluationFormOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEvaluationFormOutput()
        value.evaluationFormArn = try reader["EvaluationFormArn"].readIfPresent() ?? ""
        value.evaluationFormId = try reader["EvaluationFormId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateHoursOfOperationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateHoursOfOperationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateHoursOfOperationOutput()
        value.hoursOfOperationArn = try reader["HoursOfOperationArn"].readIfPresent()
        value.hoursOfOperationId = try reader["HoursOfOperationId"].readIfPresent()
        return value
    }
}

extension CreateInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateInstanceOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        return value
    }
}

extension CreateIntegrationAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateIntegrationAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateIntegrationAssociationOutput()
        value.integrationAssociationArn = try reader["IntegrationAssociationArn"].readIfPresent()
        value.integrationAssociationId = try reader["IntegrationAssociationId"].readIfPresent()
        return value
    }
}

extension CreateParticipantOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateParticipantOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateParticipantOutput()
        value.participantCredentials = try reader["ParticipantCredentials"].readIfPresent(with: ConnectClientTypes.ParticipantTokenCredentials.read(from:))
        value.participantId = try reader["ParticipantId"].readIfPresent()
        return value
    }
}

extension CreatePersistentContactAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePersistentContactAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePersistentContactAssociationOutput()
        value.continuedFromContactId = try reader["ContinuedFromContactId"].readIfPresent()
        return value
    }
}

extension CreatePredefinedAttributeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePredefinedAttributeOutput {
        return CreatePredefinedAttributeOutput()
    }
}

extension CreatePromptOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePromptOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePromptOutput()
        value.promptARN = try reader["PromptARN"].readIfPresent()
        value.promptId = try reader["PromptId"].readIfPresent()
        return value
    }
}

extension CreateQueueOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateQueueOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateQueueOutput()
        value.queueArn = try reader["QueueArn"].readIfPresent()
        value.queueId = try reader["QueueId"].readIfPresent()
        return value
    }
}

extension CreateQuickConnectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateQuickConnectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateQuickConnectOutput()
        value.quickConnectARN = try reader["QuickConnectARN"].readIfPresent()
        value.quickConnectId = try reader["QuickConnectId"].readIfPresent()
        return value
    }
}

extension CreateRoutingProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRoutingProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRoutingProfileOutput()
        value.routingProfileArn = try reader["RoutingProfileArn"].readIfPresent()
        value.routingProfileId = try reader["RoutingProfileId"].readIfPresent()
        return value
    }
}

extension CreateRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRuleOutput()
        value.ruleArn = try reader["RuleArn"].readIfPresent() ?? ""
        value.ruleId = try reader["RuleId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateSecurityProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSecurityProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSecurityProfileOutput()
        value.securityProfileArn = try reader["SecurityProfileArn"].readIfPresent()
        value.securityProfileId = try reader["SecurityProfileId"].readIfPresent()
        return value
    }
}

extension CreateTaskTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTaskTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTaskTemplateOutput()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.id = try reader["Id"].readIfPresent() ?? ""
        return value
    }
}

extension CreateTrafficDistributionGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTrafficDistributionGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTrafficDistributionGroupOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        return value
    }
}

extension CreateUseCaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateUseCaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateUseCaseOutput()
        value.useCaseArn = try reader["UseCaseArn"].readIfPresent()
        value.useCaseId = try reader["UseCaseId"].readIfPresent()
        return value
    }
}

extension CreateUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateUserOutput()
        value.userArn = try reader["UserArn"].readIfPresent()
        value.userId = try reader["UserId"].readIfPresent()
        return value
    }
}

extension CreateUserHierarchyGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateUserHierarchyGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateUserHierarchyGroupOutput()
        value.hierarchyGroupArn = try reader["HierarchyGroupArn"].readIfPresent()
        value.hierarchyGroupId = try reader["HierarchyGroupId"].readIfPresent()
        return value
    }
}

extension CreateViewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateViewOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateViewOutput()
        value.view = try reader["View"].readIfPresent(with: ConnectClientTypes.View.read(from:))
        return value
    }
}

extension CreateViewVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateViewVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateViewVersionOutput()
        value.view = try reader["View"].readIfPresent(with: ConnectClientTypes.View.read(from:))
        return value
    }
}

extension CreateVocabularyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateVocabularyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateVocabularyOutput()
        value.state = try reader["State"].readIfPresent() ?? .sdkUnknown("")
        value.vocabularyArn = try reader["VocabularyArn"].readIfPresent() ?? ""
        value.vocabularyId = try reader["VocabularyId"].readIfPresent() ?? ""
        return value
    }
}

extension DeactivateEvaluationFormOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeactivateEvaluationFormOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeactivateEvaluationFormOutput()
        value.evaluationFormArn = try reader["EvaluationFormArn"].readIfPresent() ?? ""
        value.evaluationFormId = try reader["EvaluationFormId"].readIfPresent() ?? ""
        value.evaluationFormVersion = try reader["EvaluationFormVersion"].readIfPresent() ?? 0
        return value
    }
}

extension DeleteAttachedFileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAttachedFileOutput {
        return DeleteAttachedFileOutput()
    }
}

extension DeleteContactEvaluationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteContactEvaluationOutput {
        return DeleteContactEvaluationOutput()
    }
}

extension DeleteContactFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteContactFlowOutput {
        return DeleteContactFlowOutput()
    }
}

extension DeleteContactFlowModuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteContactFlowModuleOutput {
        return DeleteContactFlowModuleOutput()
    }
}

extension DeleteEvaluationFormOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEvaluationFormOutput {
        return DeleteEvaluationFormOutput()
    }
}

extension DeleteHoursOfOperationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteHoursOfOperationOutput {
        return DeleteHoursOfOperationOutput()
    }
}

extension DeleteInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteInstanceOutput {
        return DeleteInstanceOutput()
    }
}

extension DeleteIntegrationAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteIntegrationAssociationOutput {
        return DeleteIntegrationAssociationOutput()
    }
}

extension DeletePredefinedAttributeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePredefinedAttributeOutput {
        return DeletePredefinedAttributeOutput()
    }
}

extension DeletePromptOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePromptOutput {
        return DeletePromptOutput()
    }
}

extension DeleteQueueOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteQueueOutput {
        return DeleteQueueOutput()
    }
}

extension DeleteQuickConnectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteQuickConnectOutput {
        return DeleteQuickConnectOutput()
    }
}

extension DeleteRoutingProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRoutingProfileOutput {
        return DeleteRoutingProfileOutput()
    }
}

extension DeleteRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRuleOutput {
        return DeleteRuleOutput()
    }
}

extension DeleteSecurityProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSecurityProfileOutput {
        return DeleteSecurityProfileOutput()
    }
}

extension DeleteTaskTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTaskTemplateOutput {
        return DeleteTaskTemplateOutput()
    }
}

extension DeleteTrafficDistributionGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTrafficDistributionGroupOutput {
        return DeleteTrafficDistributionGroupOutput()
    }
}

extension DeleteUseCaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteUseCaseOutput {
        return DeleteUseCaseOutput()
    }
}

extension DeleteUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteUserOutput {
        return DeleteUserOutput()
    }
}

extension DeleteUserHierarchyGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteUserHierarchyGroupOutput {
        return DeleteUserHierarchyGroupOutput()
    }
}

extension DeleteViewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteViewOutput {
        return DeleteViewOutput()
    }
}

extension DeleteViewVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteViewVersionOutput {
        return DeleteViewVersionOutput()
    }
}

extension DeleteVocabularyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVocabularyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteVocabularyOutput()
        value.state = try reader["State"].readIfPresent() ?? .sdkUnknown("")
        value.vocabularyArn = try reader["VocabularyArn"].readIfPresent() ?? ""
        value.vocabularyId = try reader["VocabularyId"].readIfPresent() ?? ""
        return value
    }
}

extension DescribeAgentStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAgentStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAgentStatusOutput()
        value.agentStatus = try reader["AgentStatus"].readIfPresent(with: ConnectClientTypes.AgentStatus.read(from:))
        return value
    }
}

extension DescribeAuthenticationProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAuthenticationProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAuthenticationProfileOutput()
        value.authenticationProfile = try reader["AuthenticationProfile"].readIfPresent(with: ConnectClientTypes.AuthenticationProfile.read(from:))
        return value
    }
}

extension DescribeContactOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeContactOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeContactOutput()
        value.contact = try reader["Contact"].readIfPresent(with: ConnectClientTypes.Contact.read(from:))
        return value
    }
}

extension DescribeContactEvaluationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeContactEvaluationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeContactEvaluationOutput()
        value.evaluation = try reader["Evaluation"].readIfPresent(with: ConnectClientTypes.Evaluation.read(from:))
        value.evaluationForm = try reader["EvaluationForm"].readIfPresent(with: ConnectClientTypes.EvaluationFormContent.read(from:))
        return value
    }
}

extension DescribeContactFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeContactFlowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeContactFlowOutput()
        value.contactFlow = try reader["ContactFlow"].readIfPresent(with: ConnectClientTypes.ContactFlow.read(from:))
        return value
    }
}

extension DescribeContactFlowModuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeContactFlowModuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeContactFlowModuleOutput()
        value.contactFlowModule = try reader["ContactFlowModule"].readIfPresent(with: ConnectClientTypes.ContactFlowModule.read(from:))
        return value
    }
}

extension DescribeEvaluationFormOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeEvaluationFormOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeEvaluationFormOutput()
        value.evaluationForm = try reader["EvaluationForm"].readIfPresent(with: ConnectClientTypes.EvaluationForm.read(from:))
        return value
    }
}

extension DescribeHoursOfOperationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeHoursOfOperationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeHoursOfOperationOutput()
        value.hoursOfOperation = try reader["HoursOfOperation"].readIfPresent(with: ConnectClientTypes.HoursOfOperation.read(from:))
        return value
    }
}

extension DescribeInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeInstanceOutput()
        value.instance = try reader["Instance"].readIfPresent(with: ConnectClientTypes.Instance.read(from:))
        value.replicationConfiguration = try reader["ReplicationConfiguration"].readIfPresent(with: ConnectClientTypes.ReplicationConfiguration.read(from:))
        return value
    }
}

extension DescribeInstanceAttributeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeInstanceAttributeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeInstanceAttributeOutput()
        value.attribute = try reader["Attribute"].readIfPresent(with: ConnectClientTypes.Attribute.read(from:))
        return value
    }
}

extension DescribeInstanceStorageConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeInstanceStorageConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeInstanceStorageConfigOutput()
        value.storageConfig = try reader["StorageConfig"].readIfPresent(with: ConnectClientTypes.InstanceStorageConfig.read(from:))
        return value
    }
}

extension DescribePhoneNumberOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribePhoneNumberOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribePhoneNumberOutput()
        value.claimedPhoneNumberSummary = try reader["ClaimedPhoneNumberSummary"].readIfPresent(with: ConnectClientTypes.ClaimedPhoneNumberSummary.read(from:))
        return value
    }
}

extension DescribePredefinedAttributeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribePredefinedAttributeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribePredefinedAttributeOutput()
        value.predefinedAttribute = try reader["PredefinedAttribute"].readIfPresent(with: ConnectClientTypes.PredefinedAttribute.read(from:))
        return value
    }
}

extension DescribePromptOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribePromptOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribePromptOutput()
        value.prompt = try reader["Prompt"].readIfPresent(with: ConnectClientTypes.Prompt.read(from:))
        return value
    }
}

extension DescribeQueueOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeQueueOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeQueueOutput()
        value.queue = try reader["Queue"].readIfPresent(with: ConnectClientTypes.Queue.read(from:))
        return value
    }
}

extension DescribeQuickConnectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeQuickConnectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeQuickConnectOutput()
        value.quickConnect = try reader["QuickConnect"].readIfPresent(with: ConnectClientTypes.QuickConnect.read(from:))
        return value
    }
}

extension DescribeRoutingProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeRoutingProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeRoutingProfileOutput()
        value.routingProfile = try reader["RoutingProfile"].readIfPresent(with: ConnectClientTypes.RoutingProfile.read(from:))
        return value
    }
}

extension DescribeRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeRuleOutput()
        value.rule = try reader["Rule"].readIfPresent(with: ConnectClientTypes.Rule.read(from:))
        return value
    }
}

extension DescribeSecurityProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeSecurityProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeSecurityProfileOutput()
        value.securityProfile = try reader["SecurityProfile"].readIfPresent(with: ConnectClientTypes.SecurityProfile.read(from:))
        return value
    }
}

extension DescribeTrafficDistributionGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeTrafficDistributionGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeTrafficDistributionGroupOutput()
        value.trafficDistributionGroup = try reader["TrafficDistributionGroup"].readIfPresent(with: ConnectClientTypes.TrafficDistributionGroup.read(from:))
        return value
    }
}

extension DescribeUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeUserOutput()
        value.user = try reader["User"].readIfPresent(with: ConnectClientTypes.User.read(from:))
        return value
    }
}

extension DescribeUserHierarchyGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeUserHierarchyGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeUserHierarchyGroupOutput()
        value.hierarchyGroup = try reader["HierarchyGroup"].readIfPresent(with: ConnectClientTypes.HierarchyGroup.read(from:))
        return value
    }
}

extension DescribeUserHierarchyStructureOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeUserHierarchyStructureOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeUserHierarchyStructureOutput()
        value.hierarchyStructure = try reader["HierarchyStructure"].readIfPresent(with: ConnectClientTypes.HierarchyStructure.read(from:))
        return value
    }
}

extension DescribeViewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeViewOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeViewOutput()
        value.view = try reader["View"].readIfPresent(with: ConnectClientTypes.View.read(from:))
        return value
    }
}

extension DescribeVocabularyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeVocabularyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeVocabularyOutput()
        value.vocabulary = try reader["Vocabulary"].readIfPresent(with: ConnectClientTypes.Vocabulary.read(from:))
        return value
    }
}

extension DisassociateAnalyticsDataSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateAnalyticsDataSetOutput {
        return DisassociateAnalyticsDataSetOutput()
    }
}

extension DisassociateApprovedOriginOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateApprovedOriginOutput {
        return DisassociateApprovedOriginOutput()
    }
}

extension DisassociateBotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateBotOutput {
        return DisassociateBotOutput()
    }
}

extension DisassociateFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateFlowOutput {
        return DisassociateFlowOutput()
    }
}

extension DisassociateInstanceStorageConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateInstanceStorageConfigOutput {
        return DisassociateInstanceStorageConfigOutput()
    }
}

extension DisassociateLambdaFunctionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateLambdaFunctionOutput {
        return DisassociateLambdaFunctionOutput()
    }
}

extension DisassociateLexBotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateLexBotOutput {
        return DisassociateLexBotOutput()
    }
}

extension DisassociatePhoneNumberContactFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociatePhoneNumberContactFlowOutput {
        return DisassociatePhoneNumberContactFlowOutput()
    }
}

extension DisassociateQueueQuickConnectsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateQueueQuickConnectsOutput {
        return DisassociateQueueQuickConnectsOutput()
    }
}

extension DisassociateRoutingProfileQueuesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateRoutingProfileQueuesOutput {
        return DisassociateRoutingProfileQueuesOutput()
    }
}

extension DisassociateSecurityKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateSecurityKeyOutput {
        return DisassociateSecurityKeyOutput()
    }
}

extension DisassociateTrafficDistributionGroupUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateTrafficDistributionGroupUserOutput {
        return DisassociateTrafficDistributionGroupUserOutput()
    }
}

extension DisassociateUserProficienciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateUserProficienciesOutput {
        return DisassociateUserProficienciesOutput()
    }
}

extension DismissUserContactOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DismissUserContactOutput {
        return DismissUserContactOutput()
    }
}

extension GetAttachedFileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAttachedFileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAttachedFileOutput()
        value.associatedResourceArn = try reader["AssociatedResourceArn"].readIfPresent()
        value.createdBy = try reader["CreatedBy"].readIfPresent(with: ConnectClientTypes.CreatedByInfo.read(from:))
        value.creationTime = try reader["CreationTime"].readIfPresent()
        value.downloadUrlMetadata = try reader["DownloadUrlMetadata"].readIfPresent(with: ConnectClientTypes.DownloadUrlMetadata.read(from:))
        value.fileArn = try reader["FileArn"].readIfPresent()
        value.fileId = try reader["FileId"].readIfPresent()
        value.fileName = try reader["FileName"].readIfPresent()
        value.fileSizeInBytes = try reader["FileSizeInBytes"].readIfPresent() ?? 0
        value.fileStatus = try reader["FileStatus"].readIfPresent()
        value.fileUseCaseType = try reader["FileUseCaseType"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetContactAttributesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetContactAttributesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetContactAttributesOutput()
        value.attributes = try reader["Attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetCurrentMetricDataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCurrentMetricDataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCurrentMetricDataOutput()
        value.approximateTotalCount = try reader["ApproximateTotalCount"].readIfPresent()
        value.dataSnapshotTime = try reader["DataSnapshotTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.metricResults = try reader["MetricResults"].readListIfPresent(memberReadingClosure: ConnectClientTypes.CurrentMetricResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetCurrentUserDataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCurrentUserDataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCurrentUserDataOutput()
        value.approximateTotalCount = try reader["ApproximateTotalCount"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.userDataList = try reader["UserDataList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.UserData.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetFederationTokenOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFederationTokenOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFederationTokenOutput()
        value.credentials = try reader["Credentials"].readIfPresent(with: ConnectClientTypes.Credentials.read(from:))
        value.signInUrl = try reader["SignInUrl"].readIfPresent()
        value.userArn = try reader["UserArn"].readIfPresent()
        value.userId = try reader["UserId"].readIfPresent()
        return value
    }
}

extension GetFlowAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFlowAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFlowAssociationOutput()
        value.flowId = try reader["FlowId"].readIfPresent()
        value.resourceId = try reader["ResourceId"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        return value
    }
}

extension GetMetricDataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMetricDataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMetricDataOutput()
        value.metricResults = try reader["MetricResults"].readListIfPresent(memberReadingClosure: ConnectClientTypes.HistoricalMetricResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetMetricDataV2Output {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMetricDataV2Output {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMetricDataV2Output()
        value.metricResults = try reader["MetricResults"].readListIfPresent(memberReadingClosure: ConnectClientTypes.MetricResultV2.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetPromptFileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPromptFileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPromptFileOutput()
        value.lastModifiedRegion = try reader["LastModifiedRegion"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.promptPresignedUrl = try reader["PromptPresignedUrl"].readIfPresent()
        return value
    }
}

extension GetTaskTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTaskTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTaskTemplateOutput()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.constraints = try reader["Constraints"].readIfPresent(with: ConnectClientTypes.TaskTemplateConstraints.read(from:))
        value.contactFlowId = try reader["ContactFlowId"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.defaults = try reader["Defaults"].readIfPresent(with: ConnectClientTypes.TaskTemplateDefaults.read(from:))
        value.description = try reader["Description"].readIfPresent()
        value.fields = try reader["Fields"].readListIfPresent(memberReadingClosure: ConnectClientTypes.TaskTemplateField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.instanceId = try reader["InstanceId"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetTrafficDistributionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTrafficDistributionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTrafficDistributionOutput()
        value.agentConfig = try reader["AgentConfig"].readIfPresent(with: ConnectClientTypes.AgentConfig.read(from:))
        value.arn = try reader["Arn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.signInConfig = try reader["SignInConfig"].readIfPresent(with: ConnectClientTypes.SignInConfig.read(from:))
        value.telephonyConfig = try reader["TelephonyConfig"].readIfPresent(with: ConnectClientTypes.TelephonyConfig.read(from:))
        return value
    }
}

extension ImportPhoneNumberOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ImportPhoneNumberOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ImportPhoneNumberOutput()
        value.phoneNumberArn = try reader["PhoneNumberArn"].readIfPresent()
        value.phoneNumberId = try reader["PhoneNumberId"].readIfPresent()
        return value
    }
}

extension ListAgentStatusesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAgentStatusesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAgentStatusesOutput()
        value.agentStatusSummaryList = try reader["AgentStatusSummaryList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.AgentStatusSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListAnalyticsDataAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAnalyticsDataAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAnalyticsDataAssociationsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.results = try reader["Results"].readListIfPresent(memberReadingClosure: ConnectClientTypes.AnalyticsDataAssociationResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListApprovedOriginsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListApprovedOriginsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListApprovedOriginsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.origins = try reader["Origins"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListAuthenticationProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAuthenticationProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAuthenticationProfilesOutput()
        value.authenticationProfileSummaryList = try reader["AuthenticationProfileSummaryList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.AuthenticationProfileSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListBotsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBotsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBotsOutput()
        value.lexBots = try reader["LexBots"].readListIfPresent(memberReadingClosure: ConnectClientTypes.LexBotConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListContactEvaluationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListContactEvaluationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListContactEvaluationsOutput()
        value.evaluationSummaryList = try reader["EvaluationSummaryList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.EvaluationSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListContactFlowModulesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListContactFlowModulesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListContactFlowModulesOutput()
        value.contactFlowModulesSummaryList = try reader["ContactFlowModulesSummaryList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.ContactFlowModuleSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListContactFlowsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListContactFlowsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListContactFlowsOutput()
        value.contactFlowSummaryList = try reader["ContactFlowSummaryList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.ContactFlowSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListContactReferencesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListContactReferencesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListContactReferencesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.referenceSummaryList = try reader["ReferenceSummaryList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.ReferenceSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListDefaultVocabulariesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDefaultVocabulariesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDefaultVocabulariesOutput()
        value.defaultVocabularyList = try reader["DefaultVocabularyList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.DefaultVocabulary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListEvaluationFormsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEvaluationFormsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEvaluationFormsOutput()
        value.evaluationFormSummaryList = try reader["EvaluationFormSummaryList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.EvaluationFormSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListEvaluationFormVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEvaluationFormVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEvaluationFormVersionsOutput()
        value.evaluationFormVersionSummaryList = try reader["EvaluationFormVersionSummaryList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.EvaluationFormVersionSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListFlowAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFlowAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFlowAssociationsOutput()
        value.flowAssociationSummaryList = try reader["FlowAssociationSummaryList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.FlowAssociationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListHoursOfOperationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListHoursOfOperationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListHoursOfOperationsOutput()
        value.hoursOfOperationSummaryList = try reader["HoursOfOperationSummaryList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.HoursOfOperationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListInstanceAttributesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListInstanceAttributesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListInstanceAttributesOutput()
        value.attributes = try reader["Attributes"].readListIfPresent(memberReadingClosure: ConnectClientTypes.Attribute.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListInstancesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListInstancesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListInstancesOutput()
        value.instanceSummaryList = try reader["InstanceSummaryList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.InstanceSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListInstanceStorageConfigsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListInstanceStorageConfigsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListInstanceStorageConfigsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.storageConfigs = try reader["StorageConfigs"].readListIfPresent(memberReadingClosure: ConnectClientTypes.InstanceStorageConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListIntegrationAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListIntegrationAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListIntegrationAssociationsOutput()
        value.integrationAssociationSummaryList = try reader["IntegrationAssociationSummaryList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.IntegrationAssociationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListLambdaFunctionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLambdaFunctionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLambdaFunctionsOutput()
        value.lambdaFunctions = try reader["LambdaFunctions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListLexBotsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLexBotsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLexBotsOutput()
        value.lexBots = try reader["LexBots"].readListIfPresent(memberReadingClosure: ConnectClientTypes.LexBot.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListPhoneNumbersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPhoneNumbersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPhoneNumbersOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.phoneNumberSummaryList = try reader["PhoneNumberSummaryList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.PhoneNumberSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListPhoneNumbersV2Output {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPhoneNumbersV2Output {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPhoneNumbersV2Output()
        value.listPhoneNumbersSummaryList = try reader["ListPhoneNumbersSummaryList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.ListPhoneNumbersSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListPredefinedAttributesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPredefinedAttributesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPredefinedAttributesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.predefinedAttributeSummaryList = try reader["PredefinedAttributeSummaryList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.PredefinedAttributeSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListPromptsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPromptsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPromptsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.promptSummaryList = try reader["PromptSummaryList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.PromptSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListQueueQuickConnectsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListQueueQuickConnectsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListQueueQuickConnectsOutput()
        value.lastModifiedRegion = try reader["LastModifiedRegion"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.quickConnectSummaryList = try reader["QuickConnectSummaryList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.QuickConnectSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListQueuesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListQueuesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListQueuesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.queueSummaryList = try reader["QueueSummaryList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.QueueSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListQuickConnectsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListQuickConnectsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListQuickConnectsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.quickConnectSummaryList = try reader["QuickConnectSummaryList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.QuickConnectSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListRealtimeContactAnalysisSegmentsV2Output {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRealtimeContactAnalysisSegmentsV2Output {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRealtimeContactAnalysisSegmentsV2Output()
        value.channel = try reader["Channel"].readIfPresent() ?? .sdkUnknown("")
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.segments = try reader["Segments"].readListIfPresent(memberReadingClosure: ConnectClientTypes.RealtimeContactAnalysisSegment.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ListRoutingProfileQueuesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRoutingProfileQueuesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRoutingProfileQueuesOutput()
        value.lastModifiedRegion = try reader["LastModifiedRegion"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.routingProfileQueueConfigSummaryList = try reader["RoutingProfileQueueConfigSummaryList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.RoutingProfileQueueConfigSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListRoutingProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRoutingProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRoutingProfilesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.routingProfileSummaryList = try reader["RoutingProfileSummaryList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.RoutingProfileSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListRulesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRulesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRulesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.ruleSummaryList = try reader["RuleSummaryList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.RuleSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListSecurityKeysOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSecurityKeysOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSecurityKeysOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.securityKeys = try reader["SecurityKeys"].readListIfPresent(memberReadingClosure: ConnectClientTypes.SecurityKey.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSecurityProfileApplicationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSecurityProfileApplicationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSecurityProfileApplicationsOutput()
        value.applications = try reader["Applications"].readListIfPresent(memberReadingClosure: ConnectClientTypes.Application.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastModifiedRegion = try reader["LastModifiedRegion"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListSecurityProfilePermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSecurityProfilePermissionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSecurityProfilePermissionsOutput()
        value.lastModifiedRegion = try reader["LastModifiedRegion"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.permissions = try reader["Permissions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSecurityProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSecurityProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSecurityProfilesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.securityProfileSummaryList = try reader["SecurityProfileSummaryList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.SecurityProfileSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListTaskTemplatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTaskTemplatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTaskTemplatesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.taskTemplates = try reader["TaskTemplates"].readListIfPresent(memberReadingClosure: ConnectClientTypes.TaskTemplateMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTrafficDistributionGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTrafficDistributionGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTrafficDistributionGroupsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.trafficDistributionGroupSummaryList = try reader["TrafficDistributionGroupSummaryList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.TrafficDistributionGroupSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTrafficDistributionGroupUsersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTrafficDistributionGroupUsersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTrafficDistributionGroupUsersOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.trafficDistributionGroupUserSummaryList = try reader["TrafficDistributionGroupUserSummaryList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.TrafficDistributionGroupUserSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListUseCasesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListUseCasesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListUseCasesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.useCaseSummaryList = try reader["UseCaseSummaryList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.UseCase.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListUserHierarchyGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListUserHierarchyGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListUserHierarchyGroupsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.userHierarchyGroupSummaryList = try reader["UserHierarchyGroupSummaryList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.HierarchyGroupSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListUserProficienciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListUserProficienciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListUserProficienciesOutput()
        value.lastModifiedRegion = try reader["LastModifiedRegion"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.userProficiencyList = try reader["UserProficiencyList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.UserProficiency.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListUsersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListUsersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListUsersOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.userSummaryList = try reader["UserSummaryList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.UserSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListViewsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListViewsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListViewsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.viewsSummaryList = try reader["ViewsSummaryList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.ViewSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListViewVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListViewVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListViewVersionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.viewVersionSummaryList = try reader["ViewVersionSummaryList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.ViewVersionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension MonitorContactOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> MonitorContactOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = MonitorContactOutput()
        value.contactArn = try reader["ContactArn"].readIfPresent()
        value.contactId = try reader["ContactId"].readIfPresent()
        return value
    }
}

extension PauseContactOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PauseContactOutput {
        return PauseContactOutput()
    }
}

extension PutUserStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutUserStatusOutput {
        return PutUserStatusOutput()
    }
}

extension ReleasePhoneNumberOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ReleasePhoneNumberOutput {
        return ReleasePhoneNumberOutput()
    }
}

extension ReplicateInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ReplicateInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ReplicateInstanceOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        return value
    }
}

extension ResumeContactOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ResumeContactOutput {
        return ResumeContactOutput()
    }
}

extension ResumeContactRecordingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ResumeContactRecordingOutput {
        return ResumeContactRecordingOutput()
    }
}

extension SearchAgentStatusesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchAgentStatusesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchAgentStatusesOutput()
        value.agentStatuses = try reader["AgentStatuses"].readListIfPresent(memberReadingClosure: ConnectClientTypes.AgentStatus.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.approximateTotalCount = try reader["ApproximateTotalCount"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension SearchAvailablePhoneNumbersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchAvailablePhoneNumbersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchAvailablePhoneNumbersOutput()
        value.availableNumbersList = try reader["AvailableNumbersList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.AvailableNumberSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension SearchContactFlowModulesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchContactFlowModulesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchContactFlowModulesOutput()
        value.approximateTotalCount = try reader["ApproximateTotalCount"].readIfPresent()
        value.contactFlowModules = try reader["ContactFlowModules"].readListIfPresent(memberReadingClosure: ConnectClientTypes.ContactFlowModule.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension SearchContactFlowsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchContactFlowsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchContactFlowsOutput()
        value.approximateTotalCount = try reader["ApproximateTotalCount"].readIfPresent()
        value.contactFlows = try reader["ContactFlows"].readListIfPresent(memberReadingClosure: ConnectClientTypes.ContactFlow.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension SearchContactsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchContactsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchContactsOutput()
        value.contacts = try reader["Contacts"].readListIfPresent(memberReadingClosure: ConnectClientTypes.ContactSearchSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.totalCount = try reader["TotalCount"].readIfPresent()
        return value
    }
}

extension SearchHoursOfOperationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchHoursOfOperationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchHoursOfOperationsOutput()
        value.approximateTotalCount = try reader["ApproximateTotalCount"].readIfPresent()
        value.hoursOfOperations = try reader["HoursOfOperations"].readListIfPresent(memberReadingClosure: ConnectClientTypes.HoursOfOperation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension SearchPredefinedAttributesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchPredefinedAttributesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchPredefinedAttributesOutput()
        value.approximateTotalCount = try reader["ApproximateTotalCount"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.predefinedAttributes = try reader["PredefinedAttributes"].readListIfPresent(memberReadingClosure: ConnectClientTypes.PredefinedAttribute.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SearchPromptsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchPromptsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchPromptsOutput()
        value.approximateTotalCount = try reader["ApproximateTotalCount"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.prompts = try reader["Prompts"].readListIfPresent(memberReadingClosure: ConnectClientTypes.Prompt.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SearchQueuesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchQueuesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchQueuesOutput()
        value.approximateTotalCount = try reader["ApproximateTotalCount"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.queues = try reader["Queues"].readListIfPresent(memberReadingClosure: ConnectClientTypes.Queue.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SearchQuickConnectsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchQuickConnectsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchQuickConnectsOutput()
        value.approximateTotalCount = try reader["ApproximateTotalCount"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.quickConnects = try reader["QuickConnects"].readListIfPresent(memberReadingClosure: ConnectClientTypes.QuickConnect.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SearchResourceTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchResourceTagsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchResourceTagsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: ConnectClientTypes.TagSet.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SearchRoutingProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchRoutingProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchRoutingProfilesOutput()
        value.approximateTotalCount = try reader["ApproximateTotalCount"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.routingProfiles = try reader["RoutingProfiles"].readListIfPresent(memberReadingClosure: ConnectClientTypes.RoutingProfile.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SearchSecurityProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchSecurityProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchSecurityProfilesOutput()
        value.approximateTotalCount = try reader["ApproximateTotalCount"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.securityProfiles = try reader["SecurityProfiles"].readListIfPresent(memberReadingClosure: ConnectClientTypes.SecurityProfileSearchSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SearchUserHierarchyGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchUserHierarchyGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchUserHierarchyGroupsOutput()
        value.approximateTotalCount = try reader["ApproximateTotalCount"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.userHierarchyGroups = try reader["UserHierarchyGroups"].readListIfPresent(memberReadingClosure: ConnectClientTypes.HierarchyGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SearchUsersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchUsersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchUsersOutput()
        value.approximateTotalCount = try reader["ApproximateTotalCount"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.users = try reader["Users"].readListIfPresent(memberReadingClosure: ConnectClientTypes.UserSearchSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SearchVocabulariesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchVocabulariesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchVocabulariesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.vocabularySummaryList = try reader["VocabularySummaryList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.VocabularySummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SendChatIntegrationEventOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SendChatIntegrationEventOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SendChatIntegrationEventOutput()
        value.initialContactId = try reader["InitialContactId"].readIfPresent()
        value.newChatCreated = try reader["NewChatCreated"].readIfPresent()
        return value
    }
}

extension StartAttachedFileUploadOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartAttachedFileUploadOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartAttachedFileUploadOutput()
        value.createdBy = try reader["CreatedBy"].readIfPresent(with: ConnectClientTypes.CreatedByInfo.read(from:))
        value.creationTime = try reader["CreationTime"].readIfPresent()
        value.fileArn = try reader["FileArn"].readIfPresent()
        value.fileId = try reader["FileId"].readIfPresent()
        value.fileStatus = try reader["FileStatus"].readIfPresent()
        value.uploadUrlMetadata = try reader["UploadUrlMetadata"].readIfPresent(with: ConnectClientTypes.UploadUrlMetadata.read(from:))
        return value
    }
}

extension StartChatContactOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartChatContactOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartChatContactOutput()
        value.contactId = try reader["ContactId"].readIfPresent()
        value.continuedFromContactId = try reader["ContinuedFromContactId"].readIfPresent()
        value.participantId = try reader["ParticipantId"].readIfPresent()
        value.participantToken = try reader["ParticipantToken"].readIfPresent()
        return value
    }
}

extension StartContactEvaluationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartContactEvaluationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartContactEvaluationOutput()
        value.evaluationArn = try reader["EvaluationArn"].readIfPresent() ?? ""
        value.evaluationId = try reader["EvaluationId"].readIfPresent() ?? ""
        return value
    }
}

extension StartContactRecordingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartContactRecordingOutput {
        return StartContactRecordingOutput()
    }
}

extension StartContactStreamingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartContactStreamingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartContactStreamingOutput()
        value.streamingId = try reader["StreamingId"].readIfPresent() ?? ""
        return value
    }
}

extension StartOutboundVoiceContactOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartOutboundVoiceContactOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartOutboundVoiceContactOutput()
        value.contactId = try reader["ContactId"].readIfPresent()
        return value
    }
}

extension StartTaskContactOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartTaskContactOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartTaskContactOutput()
        value.contactId = try reader["ContactId"].readIfPresent()
        return value
    }
}

extension StartWebRTCContactOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartWebRTCContactOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartWebRTCContactOutput()
        value.connectionData = try reader["ConnectionData"].readIfPresent(with: ConnectClientTypes.ConnectionData.read(from:))
        value.contactId = try reader["ContactId"].readIfPresent()
        value.participantId = try reader["ParticipantId"].readIfPresent()
        value.participantToken = try reader["ParticipantToken"].readIfPresent()
        return value
    }
}

extension StopContactOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopContactOutput {
        return StopContactOutput()
    }
}

extension StopContactRecordingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopContactRecordingOutput {
        return StopContactRecordingOutput()
    }
}

extension StopContactStreamingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopContactStreamingOutput {
        return StopContactStreamingOutput()
    }
}

extension SubmitContactEvaluationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SubmitContactEvaluationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SubmitContactEvaluationOutput()
        value.evaluationArn = try reader["EvaluationArn"].readIfPresent() ?? ""
        value.evaluationId = try reader["EvaluationId"].readIfPresent() ?? ""
        return value
    }
}

extension SuspendContactRecordingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SuspendContactRecordingOutput {
        return SuspendContactRecordingOutput()
    }
}

extension TagContactOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagContactOutput {
        return TagContactOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension TransferContactOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TransferContactOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = TransferContactOutput()
        value.contactArn = try reader["ContactArn"].readIfPresent()
        value.contactId = try reader["ContactId"].readIfPresent()
        return value
    }
}

extension UntagContactOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagContactOutput {
        return UntagContactOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateAgentStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAgentStatusOutput {
        return UpdateAgentStatusOutput()
    }
}

extension UpdateAuthenticationProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAuthenticationProfileOutput {
        return UpdateAuthenticationProfileOutput()
    }
}

extension UpdateContactOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateContactOutput {
        return UpdateContactOutput()
    }
}

extension UpdateContactAttributesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateContactAttributesOutput {
        return UpdateContactAttributesOutput()
    }
}

extension UpdateContactEvaluationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateContactEvaluationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateContactEvaluationOutput()
        value.evaluationArn = try reader["EvaluationArn"].readIfPresent() ?? ""
        value.evaluationId = try reader["EvaluationId"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateContactFlowContentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateContactFlowContentOutput {
        return UpdateContactFlowContentOutput()
    }
}

extension UpdateContactFlowMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateContactFlowMetadataOutput {
        return UpdateContactFlowMetadataOutput()
    }
}

extension UpdateContactFlowModuleContentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateContactFlowModuleContentOutput {
        return UpdateContactFlowModuleContentOutput()
    }
}

extension UpdateContactFlowModuleMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateContactFlowModuleMetadataOutput {
        return UpdateContactFlowModuleMetadataOutput()
    }
}

extension UpdateContactFlowNameOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateContactFlowNameOutput {
        return UpdateContactFlowNameOutput()
    }
}

extension UpdateContactRoutingDataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateContactRoutingDataOutput {
        return UpdateContactRoutingDataOutput()
    }
}

extension UpdateContactScheduleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateContactScheduleOutput {
        return UpdateContactScheduleOutput()
    }
}

extension UpdateEvaluationFormOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateEvaluationFormOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateEvaluationFormOutput()
        value.evaluationFormArn = try reader["EvaluationFormArn"].readIfPresent() ?? ""
        value.evaluationFormId = try reader["EvaluationFormId"].readIfPresent() ?? ""
        value.evaluationFormVersion = try reader["EvaluationFormVersion"].readIfPresent() ?? 0
        return value
    }
}

extension UpdateHoursOfOperationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateHoursOfOperationOutput {
        return UpdateHoursOfOperationOutput()
    }
}

extension UpdateInstanceAttributeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateInstanceAttributeOutput {
        return UpdateInstanceAttributeOutput()
    }
}

extension UpdateInstanceStorageConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateInstanceStorageConfigOutput {
        return UpdateInstanceStorageConfigOutput()
    }
}

extension UpdateParticipantRoleConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateParticipantRoleConfigOutput {
        return UpdateParticipantRoleConfigOutput()
    }
}

extension UpdatePhoneNumberOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePhoneNumberOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdatePhoneNumberOutput()
        value.phoneNumberArn = try reader["PhoneNumberArn"].readIfPresent()
        value.phoneNumberId = try reader["PhoneNumberId"].readIfPresent()
        return value
    }
}

extension UpdatePhoneNumberMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePhoneNumberMetadataOutput {
        return UpdatePhoneNumberMetadataOutput()
    }
}

extension UpdatePredefinedAttributeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePredefinedAttributeOutput {
        return UpdatePredefinedAttributeOutput()
    }
}

extension UpdatePromptOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePromptOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdatePromptOutput()
        value.promptARN = try reader["PromptARN"].readIfPresent()
        value.promptId = try reader["PromptId"].readIfPresent()
        return value
    }
}

extension UpdateQueueHoursOfOperationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateQueueHoursOfOperationOutput {
        return UpdateQueueHoursOfOperationOutput()
    }
}

extension UpdateQueueMaxContactsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateQueueMaxContactsOutput {
        return UpdateQueueMaxContactsOutput()
    }
}

extension UpdateQueueNameOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateQueueNameOutput {
        return UpdateQueueNameOutput()
    }
}

extension UpdateQueueOutboundCallerConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateQueueOutboundCallerConfigOutput {
        return UpdateQueueOutboundCallerConfigOutput()
    }
}

extension UpdateQueueStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateQueueStatusOutput {
        return UpdateQueueStatusOutput()
    }
}

extension UpdateQuickConnectConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateQuickConnectConfigOutput {
        return UpdateQuickConnectConfigOutput()
    }
}

extension UpdateQuickConnectNameOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateQuickConnectNameOutput {
        return UpdateQuickConnectNameOutput()
    }
}

extension UpdateRoutingProfileAgentAvailabilityTimerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRoutingProfileAgentAvailabilityTimerOutput {
        return UpdateRoutingProfileAgentAvailabilityTimerOutput()
    }
}

extension UpdateRoutingProfileConcurrencyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRoutingProfileConcurrencyOutput {
        return UpdateRoutingProfileConcurrencyOutput()
    }
}

extension UpdateRoutingProfileDefaultOutboundQueueOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRoutingProfileDefaultOutboundQueueOutput {
        return UpdateRoutingProfileDefaultOutboundQueueOutput()
    }
}

extension UpdateRoutingProfileNameOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRoutingProfileNameOutput {
        return UpdateRoutingProfileNameOutput()
    }
}

extension UpdateRoutingProfileQueuesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRoutingProfileQueuesOutput {
        return UpdateRoutingProfileQueuesOutput()
    }
}

extension UpdateRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRuleOutput {
        return UpdateRuleOutput()
    }
}

extension UpdateSecurityProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSecurityProfileOutput {
        return UpdateSecurityProfileOutput()
    }
}

extension UpdateTaskTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTaskTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateTaskTemplateOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.constraints = try reader["Constraints"].readIfPresent(with: ConnectClientTypes.TaskTemplateConstraints.read(from:))
        value.contactFlowId = try reader["ContactFlowId"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.defaults = try reader["Defaults"].readIfPresent(with: ConnectClientTypes.TaskTemplateDefaults.read(from:))
        value.description = try reader["Description"].readIfPresent()
        value.fields = try reader["Fields"].readListIfPresent(memberReadingClosure: ConnectClientTypes.TaskTemplateField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.id = try reader["Id"].readIfPresent()
        value.instanceId = try reader["InstanceId"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["Name"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension UpdateTrafficDistributionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTrafficDistributionOutput {
        return UpdateTrafficDistributionOutput()
    }
}

extension UpdateUserHierarchyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateUserHierarchyOutput {
        return UpdateUserHierarchyOutput()
    }
}

extension UpdateUserHierarchyGroupNameOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateUserHierarchyGroupNameOutput {
        return UpdateUserHierarchyGroupNameOutput()
    }
}

extension UpdateUserHierarchyStructureOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateUserHierarchyStructureOutput {
        return UpdateUserHierarchyStructureOutput()
    }
}

extension UpdateUserIdentityInfoOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateUserIdentityInfoOutput {
        return UpdateUserIdentityInfoOutput()
    }
}

extension UpdateUserPhoneConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateUserPhoneConfigOutput {
        return UpdateUserPhoneConfigOutput()
    }
}

extension UpdateUserProficienciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateUserProficienciesOutput {
        return UpdateUserProficienciesOutput()
    }
}

extension UpdateUserRoutingProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateUserRoutingProfileOutput {
        return UpdateUserRoutingProfileOutput()
    }
}

extension UpdateUserSecurityProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateUserSecurityProfilesOutput {
        return UpdateUserSecurityProfilesOutput()
    }
}

extension UpdateViewContentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateViewContentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateViewContentOutput()
        value.view = try reader["View"].readIfPresent(with: ConnectClientTypes.View.read(from:))
        return value
    }
}

extension UpdateViewMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateViewMetadataOutput {
        return UpdateViewMetadataOutput()
    }
}

enum ActivateEvaluationFormOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateAnalyticsDataSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateApprovedOriginOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateBotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateDefaultVocabularyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateInstanceStorageConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateLambdaFunctionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateLexBotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociatePhoneNumberContactFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateQueueQuickConnectsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateRoutingProfileQueuesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateSecurityKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateTrafficDistributionGroupUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateUserProficienciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchAssociateAnalyticsDataSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchDisassociateAnalyticsDataSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetAttachedFileMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetFlowAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchPutContactOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IdempotencyException": return try IdempotencyException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ClaimPhoneNumberOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IdempotencyException": return try IdempotencyException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CompleteAttachedFileUploadOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAgentStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateResourceException": return try DuplicateResourceException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateContactFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateResourceException": return try DuplicateResourceException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidContactFlowException": return try InvalidContactFlowException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateContactFlowModuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DuplicateResourceException": return try DuplicateResourceException.makeError(baseError: baseError)
            case "IdempotencyException": return try IdempotencyException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidContactFlowModuleException": return try InvalidContactFlowModuleException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateEvaluationFormOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateHoursOfOperationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateResourceException": return try DuplicateResourceException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateIntegrationAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateResourceException": return try DuplicateResourceException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateParticipantOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePersistentContactAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePredefinedAttributeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateResourceException": return try DuplicateResourceException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePromptOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateResourceException": return try DuplicateResourceException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateQueueOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateResourceException": return try DuplicateResourceException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateQuickConnectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateResourceException": return try DuplicateResourceException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRoutingProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateResourceException": return try DuplicateResourceException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSecurityProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateResourceException": return try DuplicateResourceException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTaskTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "PropertyValidationException": return try PropertyValidationException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTrafficDistributionGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceNotReadyException": return try ResourceNotReadyException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateUseCaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateResourceException": return try DuplicateResourceException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateResourceException": return try DuplicateResourceException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateUserHierarchyGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateResourceException": return try DuplicateResourceException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateViewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DuplicateResourceException": return try DuplicateResourceException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateViewVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateVocabularyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeactivateEvaluationFormOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAttachedFileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteContactEvaluationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteContactFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteContactFlowModuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEvaluationFormOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteHoursOfOperationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteIntegrationAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePredefinedAttributeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePromptOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteQueueOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteQuickConnectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRoutingProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSecurityProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTaskTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTrafficDistributionGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteUseCaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteUserHierarchyGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteViewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteViewVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVocabularyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAgentStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAuthenticationProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeContactOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeContactEvaluationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeContactFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ContactFlowNotPublishedException": return try ContactFlowNotPublishedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeContactFlowModuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeEvaluationFormOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeHoursOfOperationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeInstanceAttributeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeInstanceStorageConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribePhoneNumberOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribePredefinedAttributeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribePromptOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeQueueOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeQuickConnectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeRoutingProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeSecurityProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeTrafficDistributionGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeUserHierarchyGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeUserHierarchyStructureOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeViewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeVocabularyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateAnalyticsDataSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateApprovedOriginOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateBotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateInstanceStorageConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateLambdaFunctionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateLexBotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociatePhoneNumberContactFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateQueueQuickConnectsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateRoutingProfileQueuesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateSecurityKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateTrafficDistributionGroupUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateUserProficienciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DismissUserContactOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAttachedFileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetContactAttributesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCurrentMetricDataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCurrentUserDataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFederationTokenOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateResourceException": return try DuplicateResourceException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UserNotFoundException": return try UserNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFlowAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMetricDataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMetricDataV2OutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPromptFileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTaskTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTrafficDistributionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ImportPhoneNumberOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IdempotencyException": return try IdempotencyException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAgentStatusesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAnalyticsDataAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListApprovedOriginsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAuthenticationProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBotsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListContactEvaluationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListContactFlowModulesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListContactFlowsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListContactReferencesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDefaultVocabulariesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEvaluationFormsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEvaluationFormVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFlowAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListHoursOfOperationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListInstanceAttributesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListInstancesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListInstanceStorageConfigsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListIntegrationAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLambdaFunctionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLexBotsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPhoneNumbersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPhoneNumbersV2OutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPredefinedAttributesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPromptsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListQueueQuickConnectsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListQueuesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListQuickConnectsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRealtimeContactAnalysisSegmentsV2OutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "OutputTypeNotFoundException": return try OutputTypeNotFoundException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRoutingProfileQueuesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRoutingProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRulesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSecurityKeysOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSecurityProfileApplicationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSecurityProfilePermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSecurityProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTaskTemplatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTrafficDistributionGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTrafficDistributionGroupUsersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListUseCasesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListUserHierarchyGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListUserProficienciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListUsersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListViewsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListViewVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum MonitorContactOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IdempotencyException": return try IdempotencyException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PauseContactOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutUserStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ReleasePhoneNumberOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IdempotencyException": return try IdempotencyException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ReplicateInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceNotReadyException": return try ResourceNotReadyException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ResumeContactOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ResumeContactRecordingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchAgentStatusesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchAvailablePhoneNumbersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchContactFlowModulesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchContactFlowsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchContactsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchHoursOfOperationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchPredefinedAttributesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchPromptsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchQueuesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchQuickConnectsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchResourceTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "MaximumResultReturnedException": return try MaximumResultReturnedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchRoutingProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchSecurityProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchUserHierarchyGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchUsersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchVocabulariesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SendChatIntegrationEventOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartAttachedFileUploadOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartChatContactOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartContactEvaluationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartContactRecordingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartContactStreamingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartOutboundVoiceContactOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DestinationNotAllowedException": return try DestinationNotAllowedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "OutboundContactNotPermittedException": return try OutboundContactNotPermittedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartTaskContactOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartWebRTCContactOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopContactOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ContactNotFoundException": return try ContactNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopContactRecordingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopContactStreamingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SubmitContactEvaluationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SuspendContactRecordingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagContactOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TransferContactOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IdempotencyException": return try IdempotencyException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagContactOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAgentStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateResourceException": return try DuplicateResourceException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAuthenticationProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateContactOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateContactAttributesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateContactEvaluationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateContactFlowContentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidContactFlowException": return try InvalidContactFlowException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateContactFlowMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateResourceException": return try DuplicateResourceException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateContactFlowModuleContentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidContactFlowModuleException": return try InvalidContactFlowModuleException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateContactFlowModuleMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DuplicateResourceException": return try DuplicateResourceException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateContactFlowNameOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateResourceException": return try DuplicateResourceException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateContactRoutingDataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateContactScheduleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateEvaluationFormOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateHoursOfOperationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateResourceException": return try DuplicateResourceException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateInstanceAttributeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateInstanceStorageConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateParticipantRoleConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePhoneNumberOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IdempotencyException": return try IdempotencyException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePhoneNumberMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IdempotencyException": return try IdempotencyException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePredefinedAttributeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePromptOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateQueueHoursOfOperationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateQueueMaxContactsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateQueueNameOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateResourceException": return try DuplicateResourceException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateQueueOutboundCallerConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateQueueStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateQuickConnectConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateQuickConnectNameOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRoutingProfileAgentAvailabilityTimerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRoutingProfileConcurrencyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRoutingProfileDefaultOutboundQueueOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRoutingProfileNameOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateResourceException": return try DuplicateResourceException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRoutingProfileQueuesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSecurityProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTaskTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "PropertyValidationException": return try PropertyValidationException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTrafficDistributionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateUserHierarchyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateUserHierarchyGroupNameOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateResourceException": return try DuplicateResourceException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateUserHierarchyStructureOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateUserIdentityInfoOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateUserPhoneConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateUserProficienciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateUserRoutingProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateUserSecurityProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateViewContentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateViewMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DuplicateResourceException": return try DuplicateResourceException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServiceException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServiceException {
        let reader = baseError.errorBodyReader
        var value = InternalServiceException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidParameterException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidParameterException {
        let reader = baseError.errorBodyReader
        var value = InvalidParameterException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceConflictException {
        let reader = baseError.errorBodyReader
        var value = ResourceConflictException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidRequestException {
        let reader = baseError.errorBodyReader
        var value = InvalidRequestException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.reason = try reader["Reason"].readIfPresent(with: ConnectClientTypes.InvalidRequestExceptionReason.read(from:))
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IdempotencyException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> IdempotencyException {
        let reader = baseError.errorBodyReader
        var value = IdempotencyException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DuplicateResourceException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> DuplicateResourceException {
        let reader = baseError.errorBodyReader
        var value = DuplicateResourceException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidContactFlowException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidContactFlowException {
        let reader = baseError.errorBodyReader
        var value = InvalidContactFlowException()
        value.properties.problems = try reader["problems"].readListIfPresent(memberReadingClosure: ConnectClientTypes.ProblemDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidContactFlowModuleException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidContactFlowModuleException {
        let reader = baseError.errorBodyReader
        var value = InvalidContactFlowModuleException()
        value.properties.problems = try reader["Problems"].readListIfPresent(memberReadingClosure: ConnectClientTypes.ProblemDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PropertyValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> PropertyValidationException {
        let reader = baseError.errorBodyReader
        var value = PropertyValidationException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.propertyList = try reader["PropertyList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.PropertyValidationExceptionProperty.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotReadyException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotReadyException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotReadyException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyRequestsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyRequestsException {
        let reader = baseError.errorBodyReader
        var value = TooManyRequestsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceInUseException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceInUseException {
        let reader = baseError.errorBodyReader
        var value = ResourceInUseException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.resourceId = try reader["ResourceId"].readIfPresent()
        value.properties.resourceType = try reader["ResourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ContactFlowNotPublishedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ContactFlowNotPublishedException {
        let reader = baseError.errorBodyReader
        var value = ContactFlowNotPublishedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UserNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UserNotFoundException {
        let reader = baseError.errorBodyReader
        var value = UserNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OutputTypeNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> OutputTypeNotFoundException {
        let reader = baseError.errorBodyReader
        var value = OutputTypeNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MaximumResultReturnedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> MaximumResultReturnedException {
        let reader = baseError.errorBodyReader
        var value = MaximumResultReturnedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DestinationNotAllowedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> DestinationNotAllowedException {
        let reader = baseError.errorBodyReader
        var value = DestinationNotAllowedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OutboundContactNotPermittedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> OutboundContactNotPermittedException {
        let reader = baseError.errorBodyReader
        var value = OutboundContactNotPermittedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ContactNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ContactNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ContactNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConnectClientTypes.AnalyticsDataAssociationResult {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.AnalyticsDataAssociationResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.AnalyticsDataAssociationResult()
        value.dataSetId = try reader["DataSetId"].readIfPresent()
        value.targetAccountId = try reader["TargetAccountId"].readIfPresent()
        value.resourceShareId = try reader["ResourceShareId"].readIfPresent()
        value.resourceShareArn = try reader["ResourceShareArn"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.ErrorResult {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.ErrorResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.ErrorResult()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.AttachedFile {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.AttachedFile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.AttachedFile()
        value.creationTime = try reader["CreationTime"].readIfPresent() ?? ""
        value.fileArn = try reader["FileArn"].readIfPresent() ?? ""
        value.fileId = try reader["FileId"].readIfPresent() ?? ""
        value.fileName = try reader["FileName"].readIfPresent() ?? ""
        value.fileSizeInBytes = try reader["FileSizeInBytes"].readIfPresent() ?? 0
        value.fileStatus = try reader["FileStatus"].readIfPresent() ?? .sdkUnknown("")
        value.createdBy = try reader["CreatedBy"].readIfPresent(with: ConnectClientTypes.CreatedByInfo.read(from:))
        value.fileUseCaseType = try reader["FileUseCaseType"].readIfPresent()
        value.associatedResourceArn = try reader["AssociatedResourceArn"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ConnectClientTypes.CreatedByInfo {

    static func write(value: ConnectClientTypes.CreatedByInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .awsidentityarn(awsidentityarn):
                try writer["AWSIdentityArn"].write(awsidentityarn)
            case let .connectuserarn(connectuserarn):
                try writer["ConnectUserArn"].write(connectuserarn)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.CreatedByInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "ConnectUserArn":
                return .connectuserarn(try reader["ConnectUserArn"].read())
            case "AWSIdentityArn":
                return .awsidentityarn(try reader["AWSIdentityArn"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension ConnectClientTypes.AttachedFileError {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.AttachedFileError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.AttachedFileError()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.fileId = try reader["FileId"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.FlowAssociationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.FlowAssociationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.FlowAssociationSummary()
        value.resourceId = try reader["ResourceId"].readIfPresent()
        value.flowId = try reader["FlowId"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.SuccessfulRequest {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.SuccessfulRequest {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.SuccessfulRequest()
        value.requestIdentifier = try reader["RequestIdentifier"].readIfPresent()
        value.contactId = try reader["ContactId"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.FailedRequest {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.FailedRequest {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.FailedRequest()
        value.requestIdentifier = try reader["RequestIdentifier"].readIfPresent()
        value.failureReasonCode = try reader["FailureReasonCode"].readIfPresent()
        value.failureReasonMessage = try reader["FailureReasonMessage"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.ParticipantTokenCredentials {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.ParticipantTokenCredentials {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.ParticipantTokenCredentials()
        value.participantToken = try reader["ParticipantToken"].readIfPresent()
        value.expiry = try reader["Expiry"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.View {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.View {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.View()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.version = try reader["Version"].readIfPresent() ?? 0
        value.versionDescription = try reader["VersionDescription"].readIfPresent()
        value.content = try reader["Content"].readIfPresent(with: ConnectClientTypes.ViewContent.read(from:))
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.viewContentSha256 = try reader["ViewContentSha256"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.ViewContent {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.ViewContent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.ViewContent()
        value.inputSchema = try reader["InputSchema"].readIfPresent()
        value.template = try reader["Template"].readIfPresent()
        value.actions = try reader["Actions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ConnectClientTypes.AgentStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.AgentStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.AgentStatus()
        value.agentStatusARN = try reader["AgentStatusARN"].readIfPresent()
        value.agentStatusId = try reader["AgentStatusId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.displayOrder = try reader["DisplayOrder"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedRegion = try reader["LastModifiedRegion"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.AuthenticationProfile {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.AuthenticationProfile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.AuthenticationProfile()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.allowedIps = try reader["AllowedIps"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.blockedIps = try reader["BlockedIps"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.isDefault = try reader["IsDefault"].readIfPresent() ?? false
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedRegion = try reader["LastModifiedRegion"].readIfPresent()
        value.periodicSessionDuration = try reader["PeriodicSessionDuration"].readIfPresent()
        value.maxSessionDuration = try reader["MaxSessionDuration"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.Contact {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.Contact {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.Contact()
        value.arn = try reader["Arn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.initialContactId = try reader["InitialContactId"].readIfPresent()
        value.previousContactId = try reader["PreviousContactId"].readIfPresent()
        value.initiationMethod = try reader["InitiationMethod"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.channel = try reader["Channel"].readIfPresent()
        value.queueInfo = try reader["QueueInfo"].readIfPresent(with: ConnectClientTypes.QueueInfo.read(from:))
        value.agentInfo = try reader["AgentInfo"].readIfPresent(with: ConnectClientTypes.AgentInfo.read(from:))
        value.initiationTimestamp = try reader["InitiationTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.disconnectTimestamp = try reader["DisconnectTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdateTimestamp = try reader["LastUpdateTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastPausedTimestamp = try reader["LastPausedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastResumedTimestamp = try reader["LastResumedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.totalPauseCount = try reader["TotalPauseCount"].readIfPresent()
        value.totalPauseDurationInSeconds = try reader["TotalPauseDurationInSeconds"].readIfPresent()
        value.scheduledTimestamp = try reader["ScheduledTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.relatedContactId = try reader["RelatedContactId"].readIfPresent()
        value.wisdomInfo = try reader["WisdomInfo"].readIfPresent(with: ConnectClientTypes.WisdomInfo.read(from:))
        value.queueTimeAdjustmentSeconds = try reader["QueueTimeAdjustmentSeconds"].readIfPresent()
        value.queuePriority = try reader["QueuePriority"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.connectedToSystemTimestamp = try reader["ConnectedToSystemTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.routingCriteria = try reader["RoutingCriteria"].readIfPresent(with: ConnectClientTypes.RoutingCriteria.read(from:))
        value.customer = try reader["Customer"].readIfPresent(with: ConnectClientTypes.Customer.read(from:))
        value.campaign = try reader["Campaign"].readIfPresent(with: ConnectClientTypes.Campaign.read(from:))
        value.answeringMachineDetectionStatus = try reader["AnsweringMachineDetectionStatus"].readIfPresent()
        value.customerVoiceActivity = try reader["CustomerVoiceActivity"].readIfPresent(with: ConnectClientTypes.CustomerVoiceActivity.read(from:))
        value.qualityMetrics = try reader["QualityMetrics"].readIfPresent(with: ConnectClientTypes.QualityMetrics.read(from:))
        value.disconnectDetails = try reader["DisconnectDetails"].readIfPresent(with: ConnectClientTypes.DisconnectDetails.read(from:))
        value.segmentAttributes = try reader["SegmentAttributes"].readMapIfPresent(valueReadingClosure: ConnectClientTypes.SegmentAttributeValue.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ConnectClientTypes.SegmentAttributeValue {

    static func write(value: ConnectClientTypes.SegmentAttributeValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ValueString"].write(value.valueString)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.SegmentAttributeValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.SegmentAttributeValue()
        value.valueString = try reader["ValueString"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.DisconnectDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.DisconnectDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.DisconnectDetails()
        value.potentialDisconnectIssue = try reader["PotentialDisconnectIssue"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.QualityMetrics {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.QualityMetrics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.QualityMetrics()
        value.agent = try reader["Agent"].readIfPresent(with: ConnectClientTypes.AgentQualityMetrics.read(from:))
        value.customer = try reader["Customer"].readIfPresent(with: ConnectClientTypes.CustomerQualityMetrics.read(from:))
        return value
    }
}

extension ConnectClientTypes.CustomerQualityMetrics {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.CustomerQualityMetrics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.CustomerQualityMetrics()
        value.audio = try reader["Audio"].readIfPresent(with: ConnectClientTypes.AudioQualityMetricsInfo.read(from:))
        return value
    }
}

extension ConnectClientTypes.AudioQualityMetricsInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.AudioQualityMetricsInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.AudioQualityMetricsInfo()
        value.qualityScore = try reader["QualityScore"].readIfPresent() ?? 0
        value.potentialQualityIssues = try reader["PotentialQualityIssues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ConnectClientTypes.AgentQualityMetrics {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.AgentQualityMetrics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.AgentQualityMetrics()
        value.audio = try reader["Audio"].readIfPresent(with: ConnectClientTypes.AudioQualityMetricsInfo.read(from:))
        return value
    }
}

extension ConnectClientTypes.CustomerVoiceActivity {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.CustomerVoiceActivity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.CustomerVoiceActivity()
        value.greetingStartTimestamp = try reader["GreetingStartTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.greetingEndTimestamp = try reader["GreetingEndTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ConnectClientTypes.Campaign {

    static func write(value: ConnectClientTypes.Campaign?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CampaignId"].write(value.campaignId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.Campaign {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.Campaign()
        value.campaignId = try reader["CampaignId"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.Customer {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.Customer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.Customer()
        value.deviceInfo = try reader["DeviceInfo"].readIfPresent(with: ConnectClientTypes.DeviceInfo.read(from:))
        value.capabilities = try reader["Capabilities"].readIfPresent(with: ConnectClientTypes.ParticipantCapabilities.read(from:))
        return value
    }
}

extension ConnectClientTypes.ParticipantCapabilities {

    static func write(value: ConnectClientTypes.ParticipantCapabilities?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Video"].write(value.video)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.ParticipantCapabilities {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.ParticipantCapabilities()
        value.video = try reader["Video"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.DeviceInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.DeviceInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.DeviceInfo()
        value.platformName = try reader["PlatformName"].readIfPresent()
        value.platformVersion = try reader["PlatformVersion"].readIfPresent()
        value.operatingSystem = try reader["OperatingSystem"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.RoutingCriteria {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.RoutingCriteria {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.RoutingCriteria()
        value.steps = try reader["Steps"].readListIfPresent(memberReadingClosure: ConnectClientTypes.Step.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.activationTimestamp = try reader["ActivationTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.index = try reader["Index"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.Step {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.Step {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.Step()
        value.expiry = try reader["Expiry"].readIfPresent(with: ConnectClientTypes.Expiry.read(from:))
        value.expression = try reader["Expression"].readIfPresent(with: ConnectClientTypes.Expression.read(from:))
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.Expression {

    static func write(value: ConnectClientTypes.Expression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AndExpression"].writeList(value.andExpression, memberWritingClosure: ConnectClientTypes.Expression.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AttributeCondition"].write(value.attributeCondition, with: ConnectClientTypes.AttributeCondition.write(value:to:))
        try writer["OrExpression"].writeList(value.orExpression, memberWritingClosure: ConnectClientTypes.Expression.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.Expression {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.Expression()
        value.attributeCondition = try reader["AttributeCondition"].readIfPresent(with: ConnectClientTypes.AttributeCondition.read(from:))
        value.andExpression = try reader["AndExpression"].readListIfPresent(memberReadingClosure: ConnectClientTypes.Expression.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.orExpression = try reader["OrExpression"].readListIfPresent(memberReadingClosure: ConnectClientTypes.Expression.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ConnectClientTypes.AttributeCondition {

    static func write(value: ConnectClientTypes.AttributeCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComparisonOperator"].write(value.comparisonOperator)
        try writer["MatchCriteria"].write(value.matchCriteria, with: ConnectClientTypes.MatchCriteria.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["ProficiencyLevel"].write(value.proficiencyLevel)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.AttributeCondition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.AttributeCondition()
        value.name = try reader["Name"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        value.proficiencyLevel = try reader["ProficiencyLevel"].readIfPresent()
        value.matchCriteria = try reader["MatchCriteria"].readIfPresent(with: ConnectClientTypes.MatchCriteria.read(from:))
        value.comparisonOperator = try reader["ComparisonOperator"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.MatchCriteria {

    static func write(value: ConnectClientTypes.MatchCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AgentsCriteria"].write(value.agentsCriteria, with: ConnectClientTypes.AgentsCriteria.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.MatchCriteria {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.MatchCriteria()
        value.agentsCriteria = try reader["AgentsCriteria"].readIfPresent(with: ConnectClientTypes.AgentsCriteria.read(from:))
        return value
    }
}

extension ConnectClientTypes.AgentsCriteria {

    static func write(value: ConnectClientTypes.AgentsCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AgentIds"].writeList(value.agentIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.AgentsCriteria {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.AgentsCriteria()
        value.agentIds = try reader["AgentIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ConnectClientTypes.Expiry {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.Expiry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.Expiry()
        value.durationInSeconds = try reader["DurationInSeconds"].readIfPresent()
        value.expiryTimestamp = try reader["ExpiryTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ConnectClientTypes.WisdomInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.WisdomInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.WisdomInfo()
        value.sessionArn = try reader["SessionArn"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.AgentInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.AgentInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.AgentInfo()
        value.id = try reader["Id"].readIfPresent()
        value.connectedToAgentTimestamp = try reader["ConnectedToAgentTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.agentPauseDurationInSeconds = try reader["AgentPauseDurationInSeconds"].readIfPresent()
        value.hierarchyGroups = try reader["HierarchyGroups"].readIfPresent(with: ConnectClientTypes.HierarchyGroups.read(from:))
        value.deviceInfo = try reader["DeviceInfo"].readIfPresent(with: ConnectClientTypes.DeviceInfo.read(from:))
        value.capabilities = try reader["Capabilities"].readIfPresent(with: ConnectClientTypes.ParticipantCapabilities.read(from:))
        return value
    }
}

extension ConnectClientTypes.HierarchyGroups {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.HierarchyGroups {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.HierarchyGroups()
        value.level1 = try reader["Level1"].readIfPresent(with: ConnectClientTypes.AgentHierarchyGroup.read(from:))
        value.level2 = try reader["Level2"].readIfPresent(with: ConnectClientTypes.AgentHierarchyGroup.read(from:))
        value.level3 = try reader["Level3"].readIfPresent(with: ConnectClientTypes.AgentHierarchyGroup.read(from:))
        value.level4 = try reader["Level4"].readIfPresent(with: ConnectClientTypes.AgentHierarchyGroup.read(from:))
        value.level5 = try reader["Level5"].readIfPresent(with: ConnectClientTypes.AgentHierarchyGroup.read(from:))
        return value
    }
}

extension ConnectClientTypes.AgentHierarchyGroup {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.AgentHierarchyGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.AgentHierarchyGroup()
        value.arn = try reader["Arn"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.QueueInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.QueueInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.QueueInfo()
        value.id = try reader["Id"].readIfPresent()
        value.enqueueTimestamp = try reader["EnqueueTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ConnectClientTypes.Evaluation {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.Evaluation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.Evaluation()
        value.evaluationId = try reader["EvaluationId"].readIfPresent() ?? ""
        value.evaluationArn = try reader["EvaluationArn"].readIfPresent() ?? ""
        value.metadata = try reader["Metadata"].readIfPresent(with: ConnectClientTypes.EvaluationMetadata.read(from:))
        value.answers = try reader["Answers"].readMapIfPresent(valueReadingClosure: ConnectClientTypes.EvaluationAnswerOutput.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.notes = try reader["Notes"].readMapIfPresent(valueReadingClosure: ConnectClientTypes.EvaluationNote.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.scores = try reader["Scores"].readMapIfPresent(valueReadingClosure: ConnectClientTypes.EvaluationScore.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ConnectClientTypes.EvaluationScore {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.EvaluationScore {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.EvaluationScore()
        value.percentage = try reader["Percentage"].readIfPresent() ?? 0
        value.notApplicable = try reader["NotApplicable"].readIfPresent() ?? false
        value.automaticFail = try reader["AutomaticFail"].readIfPresent() ?? false
        return value
    }
}

extension ConnectClientTypes.EvaluationNote {

    static func write(value: ConnectClientTypes.EvaluationNote?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.EvaluationNote {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.EvaluationNote()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.EvaluationAnswerOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.EvaluationAnswerOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.EvaluationAnswerOutput()
        value.value = try reader["Value"].readIfPresent(with: ConnectClientTypes.EvaluationAnswerData.read(from:))
        value.systemSuggestedValue = try reader["SystemSuggestedValue"].readIfPresent(with: ConnectClientTypes.EvaluationAnswerData.read(from:))
        return value
    }
}

extension ConnectClientTypes.EvaluationAnswerData {

    static func write(value: ConnectClientTypes.EvaluationAnswerData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .notapplicable(notapplicable):
                try writer["NotApplicable"].write(notapplicable)
            case let .numericvalue(numericvalue):
                try writer["NumericValue"].write(numericvalue)
            case let .stringvalue(stringvalue):
                try writer["StringValue"].write(stringvalue)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.EvaluationAnswerData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "StringValue":
                return .stringvalue(try reader["StringValue"].read())
            case "NumericValue":
                return .numericvalue(try reader["NumericValue"].read() ?? 0)
            case "NotApplicable":
                return .notapplicable(try reader["NotApplicable"].read() ?? false)
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension ConnectClientTypes.EvaluationMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.EvaluationMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.EvaluationMetadata()
        value.contactId = try reader["ContactId"].readIfPresent() ?? ""
        value.evaluatorArn = try reader["EvaluatorArn"].readIfPresent() ?? ""
        value.contactAgentId = try reader["ContactAgentId"].readIfPresent()
        value.score = try reader["Score"].readIfPresent(with: ConnectClientTypes.EvaluationScore.read(from:))
        return value
    }
}

extension ConnectClientTypes.EvaluationFormContent {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.EvaluationFormContent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.EvaluationFormContent()
        value.evaluationFormVersion = try reader["EvaluationFormVersion"].readIfPresent() ?? 0
        value.evaluationFormId = try reader["EvaluationFormId"].readIfPresent() ?? ""
        value.evaluationFormArn = try reader["EvaluationFormArn"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.description = try reader["Description"].readIfPresent()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: ConnectClientTypes.EvaluationFormItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.scoringStrategy = try reader["ScoringStrategy"].readIfPresent(with: ConnectClientTypes.EvaluationFormScoringStrategy.read(from:))
        return value
    }
}

extension ConnectClientTypes.EvaluationFormScoringStrategy {

    static func write(value: ConnectClientTypes.EvaluationFormScoringStrategy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Mode"].write(value.mode)
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.EvaluationFormScoringStrategy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.EvaluationFormScoringStrategy()
        value.mode = try reader["Mode"].readIfPresent() ?? .sdkUnknown("")
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ConnectClientTypes.EvaluationFormItem {

    static func write(value: ConnectClientTypes.EvaluationFormItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .question(question):
                try writer["Question"].write(question, with: ConnectClientTypes.EvaluationFormQuestion.write(value:to:))
            case let .section(section):
                try writer["Section"].write(section, with: ConnectClientTypes.EvaluationFormSection.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.EvaluationFormItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "Section":
                return .section(try reader["Section"].read(with: ConnectClientTypes.EvaluationFormSection.read(from:)))
            case "Question":
                return .question(try reader["Question"].read(with: ConnectClientTypes.EvaluationFormQuestion.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension ConnectClientTypes.EvaluationFormQuestion {

    static func write(value: ConnectClientTypes.EvaluationFormQuestion?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Instructions"].write(value.instructions)
        try writer["NotApplicableEnabled"].write(value.notApplicableEnabled)
        try writer["QuestionType"].write(value.questionType)
        try writer["QuestionTypeProperties"].write(value.questionTypeProperties, with: ConnectClientTypes.EvaluationFormQuestionTypeProperties.write(value:to:))
        try writer["RefId"].write(value.refId)
        try writer["Title"].write(value.title)
        try writer["Weight"].write(value.weight)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.EvaluationFormQuestion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.EvaluationFormQuestion()
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.instructions = try reader["Instructions"].readIfPresent()
        value.refId = try reader["RefId"].readIfPresent() ?? ""
        value.notApplicableEnabled = try reader["NotApplicableEnabled"].readIfPresent() ?? false
        value.questionType = try reader["QuestionType"].readIfPresent() ?? .sdkUnknown("")
        value.questionTypeProperties = try reader["QuestionTypeProperties"].readIfPresent(with: ConnectClientTypes.EvaluationFormQuestionTypeProperties.read(from:))
        value.weight = try reader["Weight"].readIfPresent() ?? 0
        return value
    }
}

extension ConnectClientTypes.EvaluationFormQuestionTypeProperties {

    static func write(value: ConnectClientTypes.EvaluationFormQuestionTypeProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .numeric(numeric):
                try writer["Numeric"].write(numeric, with: ConnectClientTypes.EvaluationFormNumericQuestionProperties.write(value:to:))
            case let .singleselect(singleselect):
                try writer["SingleSelect"].write(singleselect, with: ConnectClientTypes.EvaluationFormSingleSelectQuestionProperties.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.EvaluationFormQuestionTypeProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "Numeric":
                return .numeric(try reader["Numeric"].read(with: ConnectClientTypes.EvaluationFormNumericQuestionProperties.read(from:)))
            case "SingleSelect":
                return .singleselect(try reader["SingleSelect"].read(with: ConnectClientTypes.EvaluationFormSingleSelectQuestionProperties.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension ConnectClientTypes.EvaluationFormSingleSelectQuestionProperties {

    static func write(value: ConnectClientTypes.EvaluationFormSingleSelectQuestionProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Automation"].write(value.automation, with: ConnectClientTypes.EvaluationFormSingleSelectQuestionAutomation.write(value:to:))
        try writer["DisplayAs"].write(value.displayAs)
        try writer["Options"].writeList(value.options, memberWritingClosure: ConnectClientTypes.EvaluationFormSingleSelectQuestionOption.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.EvaluationFormSingleSelectQuestionProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.EvaluationFormSingleSelectQuestionProperties()
        value.options = try reader["Options"].readListIfPresent(memberReadingClosure: ConnectClientTypes.EvaluationFormSingleSelectQuestionOption.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.displayAs = try reader["DisplayAs"].readIfPresent()
        value.automation = try reader["Automation"].readIfPresent(with: ConnectClientTypes.EvaluationFormSingleSelectQuestionAutomation.read(from:))
        return value
    }
}

extension ConnectClientTypes.EvaluationFormSingleSelectQuestionAutomation {

    static func write(value: ConnectClientTypes.EvaluationFormSingleSelectQuestionAutomation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultOptionRefId"].write(value.defaultOptionRefId)
        try writer["Options"].writeList(value.options, memberWritingClosure: ConnectClientTypes.EvaluationFormSingleSelectQuestionAutomationOption.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.EvaluationFormSingleSelectQuestionAutomation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.EvaluationFormSingleSelectQuestionAutomation()
        value.options = try reader["Options"].readListIfPresent(memberReadingClosure: ConnectClientTypes.EvaluationFormSingleSelectQuestionAutomationOption.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.defaultOptionRefId = try reader["DefaultOptionRefId"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.EvaluationFormSingleSelectQuestionAutomationOption {

    static func write(value: ConnectClientTypes.EvaluationFormSingleSelectQuestionAutomationOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .rulecategory(rulecategory):
                try writer["RuleCategory"].write(rulecategory, with: ConnectClientTypes.SingleSelectQuestionRuleCategoryAutomation.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.EvaluationFormSingleSelectQuestionAutomationOption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "RuleCategory":
                return .rulecategory(try reader["RuleCategory"].read(with: ConnectClientTypes.SingleSelectQuestionRuleCategoryAutomation.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension ConnectClientTypes.SingleSelectQuestionRuleCategoryAutomation {

    static func write(value: ConnectClientTypes.SingleSelectQuestionRuleCategoryAutomation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Category"].write(value.category)
        try writer["Condition"].write(value.condition)
        try writer["OptionRefId"].write(value.optionRefId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.SingleSelectQuestionRuleCategoryAutomation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.SingleSelectQuestionRuleCategoryAutomation()
        value.category = try reader["Category"].readIfPresent() ?? ""
        value.condition = try reader["Condition"].readIfPresent() ?? .sdkUnknown("")
        value.optionRefId = try reader["OptionRefId"].readIfPresent() ?? ""
        return value
    }
}

extension ConnectClientTypes.EvaluationFormSingleSelectQuestionOption {

    static func write(value: ConnectClientTypes.EvaluationFormSingleSelectQuestionOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutomaticFail"].write(value.automaticFail)
        try writer["RefId"].write(value.refId)
        try writer["Score"].write(value.score)
        try writer["Text"].write(value.text)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.EvaluationFormSingleSelectQuestionOption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.EvaluationFormSingleSelectQuestionOption()
        value.refId = try reader["RefId"].readIfPresent() ?? ""
        value.text = try reader["Text"].readIfPresent() ?? ""
        value.score = try reader["Score"].readIfPresent() ?? 0
        value.automaticFail = try reader["AutomaticFail"].readIfPresent() ?? false
        return value
    }
}

extension ConnectClientTypes.EvaluationFormNumericQuestionProperties {

    static func write(value: ConnectClientTypes.EvaluationFormNumericQuestionProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Automation"].write(value.automation, with: ConnectClientTypes.EvaluationFormNumericQuestionAutomation.write(value:to:))
        try writer["MaxValue"].write(value.maxValue)
        try writer["MinValue"].write(value.minValue)
        try writer["Options"].writeList(value.options, memberWritingClosure: ConnectClientTypes.EvaluationFormNumericQuestionOption.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.EvaluationFormNumericQuestionProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.EvaluationFormNumericQuestionProperties()
        value.minValue = try reader["MinValue"].readIfPresent() ?? 0
        value.maxValue = try reader["MaxValue"].readIfPresent() ?? 0
        value.options = try reader["Options"].readListIfPresent(memberReadingClosure: ConnectClientTypes.EvaluationFormNumericQuestionOption.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.automation = try reader["Automation"].readIfPresent(with: ConnectClientTypes.EvaluationFormNumericQuestionAutomation.read(from:))
        return value
    }
}

extension ConnectClientTypes.EvaluationFormNumericQuestionAutomation {

    static func write(value: ConnectClientTypes.EvaluationFormNumericQuestionAutomation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .propertyvalue(propertyvalue):
                try writer["PropertyValue"].write(propertyvalue, with: ConnectClientTypes.NumericQuestionPropertyValueAutomation.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.EvaluationFormNumericQuestionAutomation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "PropertyValue":
                return .propertyvalue(try reader["PropertyValue"].read(with: ConnectClientTypes.NumericQuestionPropertyValueAutomation.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension ConnectClientTypes.NumericQuestionPropertyValueAutomation {

    static func write(value: ConnectClientTypes.NumericQuestionPropertyValueAutomation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Label"].write(value.label)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.NumericQuestionPropertyValueAutomation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.NumericQuestionPropertyValueAutomation()
        value.label = try reader["Label"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ConnectClientTypes.EvaluationFormNumericQuestionOption {

    static func write(value: ConnectClientTypes.EvaluationFormNumericQuestionOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutomaticFail"].write(value.automaticFail)
        try writer["MaxValue"].write(value.maxValue)
        try writer["MinValue"].write(value.minValue)
        try writer["Score"].write(value.score)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.EvaluationFormNumericQuestionOption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.EvaluationFormNumericQuestionOption()
        value.minValue = try reader["MinValue"].readIfPresent() ?? 0
        value.maxValue = try reader["MaxValue"].readIfPresent() ?? 0
        value.score = try reader["Score"].readIfPresent() ?? 0
        value.automaticFail = try reader["AutomaticFail"].readIfPresent() ?? false
        return value
    }
}

extension ConnectClientTypes.EvaluationFormSection {

    static func write(value: ConnectClientTypes.EvaluationFormSection?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Instructions"].write(value.instructions)
        try writer["Items"].writeList(value.items, memberWritingClosure: ConnectClientTypes.EvaluationFormItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RefId"].write(value.refId)
        try writer["Title"].write(value.title)
        try writer["Weight"].write(value.weight)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.EvaluationFormSection {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.EvaluationFormSection()
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.refId = try reader["RefId"].readIfPresent() ?? ""
        value.instructions = try reader["Instructions"].readIfPresent()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: ConnectClientTypes.EvaluationFormItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.weight = try reader["Weight"].readIfPresent() ?? 0
        return value
    }
}

extension ConnectClientTypes.ContactFlow {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.ContactFlow {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.ContactFlow()
        value.arn = try reader["Arn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.content = try reader["Content"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ConnectClientTypes.ContactFlowModule {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.ContactFlowModule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.ContactFlowModule()
        value.arn = try reader["Arn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.content = try reader["Content"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ConnectClientTypes.EvaluationForm {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.EvaluationForm {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.EvaluationForm()
        value.evaluationFormId = try reader["EvaluationFormId"].readIfPresent() ?? ""
        value.evaluationFormVersion = try reader["EvaluationFormVersion"].readIfPresent() ?? 0
        value.locked = try reader["Locked"].readIfPresent() ?? false
        value.evaluationFormArn = try reader["EvaluationFormArn"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.description = try reader["Description"].readIfPresent()
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: ConnectClientTypes.EvaluationFormItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.scoringStrategy = try reader["ScoringStrategy"].readIfPresent(with: ConnectClientTypes.EvaluationFormScoringStrategy.read(from:))
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["CreatedBy"].readIfPresent() ?? ""
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedBy = try reader["LastModifiedBy"].readIfPresent() ?? ""
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ConnectClientTypes.HoursOfOperation {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.HoursOfOperation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.HoursOfOperation()
        value.hoursOfOperationId = try reader["HoursOfOperationId"].readIfPresent()
        value.hoursOfOperationArn = try reader["HoursOfOperationArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.timeZone = try reader["TimeZone"].readIfPresent()
        value.config = try reader["Config"].readListIfPresent(memberReadingClosure: ConnectClientTypes.HoursOfOperationConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedRegion = try reader["LastModifiedRegion"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.HoursOfOperationConfig {

    static func write(value: ConnectClientTypes.HoursOfOperationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Day"].write(value.day)
        try writer["EndTime"].write(value.endTime, with: ConnectClientTypes.HoursOfOperationTimeSlice.write(value:to:))
        try writer["StartTime"].write(value.startTime, with: ConnectClientTypes.HoursOfOperationTimeSlice.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.HoursOfOperationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.HoursOfOperationConfig()
        value.day = try reader["Day"].readIfPresent() ?? .sdkUnknown("")
        value.startTime = try reader["StartTime"].readIfPresent(with: ConnectClientTypes.HoursOfOperationTimeSlice.read(from:))
        value.endTime = try reader["EndTime"].readIfPresent(with: ConnectClientTypes.HoursOfOperationTimeSlice.read(from:))
        return value
    }
}

extension ConnectClientTypes.HoursOfOperationTimeSlice {

    static func write(value: ConnectClientTypes.HoursOfOperationTimeSlice?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Hours"].write(value.hours)
        try writer["Minutes"].write(value.minutes)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.HoursOfOperationTimeSlice {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.HoursOfOperationTimeSlice()
        value.hours = try reader["Hours"].readIfPresent()
        value.minutes = try reader["Minutes"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.Instance {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.Instance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.Instance()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.identityManagementType = try reader["IdentityManagementType"].readIfPresent()
        value.instanceAlias = try reader["InstanceAlias"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.serviceRole = try reader["ServiceRole"].readIfPresent()
        value.instanceStatus = try reader["InstanceStatus"].readIfPresent()
        value.statusReason = try reader["StatusReason"].readIfPresent(with: ConnectClientTypes.InstanceStatusReason.read(from:))
        value.inboundCallsEnabled = try reader["InboundCallsEnabled"].readIfPresent()
        value.outboundCallsEnabled = try reader["OutboundCallsEnabled"].readIfPresent()
        value.instanceAccessUrl = try reader["InstanceAccessUrl"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ConnectClientTypes.InstanceStatusReason {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.InstanceStatusReason {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.InstanceStatusReason()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.ReplicationConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.ReplicationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.ReplicationConfiguration()
        value.replicationStatusSummaryList = try reader["ReplicationStatusSummaryList"].readListIfPresent(memberReadingClosure: ConnectClientTypes.ReplicationStatusSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.sourceRegion = try reader["SourceRegion"].readIfPresent()
        value.globalSignInEndpoint = try reader["GlobalSignInEndpoint"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.ReplicationStatusSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.ReplicationStatusSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.ReplicationStatusSummary()
        value.region = try reader["Region"].readIfPresent()
        value.replicationStatus = try reader["ReplicationStatus"].readIfPresent()
        value.replicationStatusReason = try reader["ReplicationStatusReason"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.Attribute {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.Attribute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.Attribute()
        value.attributeType = try reader["AttributeType"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.InstanceStorageConfig {

    static func write(value: ConnectClientTypes.InstanceStorageConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssociationId"].write(value.associationId)
        try writer["KinesisFirehoseConfig"].write(value.kinesisFirehoseConfig, with: ConnectClientTypes.KinesisFirehoseConfig.write(value:to:))
        try writer["KinesisStreamConfig"].write(value.kinesisStreamConfig, with: ConnectClientTypes.KinesisStreamConfig.write(value:to:))
        try writer["KinesisVideoStreamConfig"].write(value.kinesisVideoStreamConfig, with: ConnectClientTypes.KinesisVideoStreamConfig.write(value:to:))
        try writer["S3Config"].write(value.s3Config, with: ConnectClientTypes.S3Config.write(value:to:))
        try writer["StorageType"].write(value.storageType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.InstanceStorageConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.InstanceStorageConfig()
        value.associationId = try reader["AssociationId"].readIfPresent()
        value.storageType = try reader["StorageType"].readIfPresent() ?? .sdkUnknown("")
        value.s3Config = try reader["S3Config"].readIfPresent(with: ConnectClientTypes.S3Config.read(from:))
        value.kinesisVideoStreamConfig = try reader["KinesisVideoStreamConfig"].readIfPresent(with: ConnectClientTypes.KinesisVideoStreamConfig.read(from:))
        value.kinesisStreamConfig = try reader["KinesisStreamConfig"].readIfPresent(with: ConnectClientTypes.KinesisStreamConfig.read(from:))
        value.kinesisFirehoseConfig = try reader["KinesisFirehoseConfig"].readIfPresent(with: ConnectClientTypes.KinesisFirehoseConfig.read(from:))
        return value
    }
}

extension ConnectClientTypes.KinesisFirehoseConfig {

    static func write(value: ConnectClientTypes.KinesisFirehoseConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FirehoseArn"].write(value.firehoseArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.KinesisFirehoseConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.KinesisFirehoseConfig()
        value.firehoseArn = try reader["FirehoseArn"].readIfPresent() ?? ""
        return value
    }
}

extension ConnectClientTypes.KinesisStreamConfig {

    static func write(value: ConnectClientTypes.KinesisStreamConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StreamArn"].write(value.streamArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.KinesisStreamConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.KinesisStreamConfig()
        value.streamArn = try reader["StreamArn"].readIfPresent() ?? ""
        return value
    }
}

extension ConnectClientTypes.KinesisVideoStreamConfig {

    static func write(value: ConnectClientTypes.KinesisVideoStreamConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EncryptionConfig"].write(value.encryptionConfig, with: ConnectClientTypes.EncryptionConfig.write(value:to:))
        try writer["Prefix"].write(value.`prefix`)
        try writer["RetentionPeriodHours"].write(value.retentionPeriodHours)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.KinesisVideoStreamConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.KinesisVideoStreamConfig()
        value.`prefix` = try reader["Prefix"].readIfPresent() ?? ""
        value.retentionPeriodHours = try reader["RetentionPeriodHours"].readIfPresent() ?? 0
        value.encryptionConfig = try reader["EncryptionConfig"].readIfPresent(with: ConnectClientTypes.EncryptionConfig.read(from:))
        return value
    }
}

extension ConnectClientTypes.EncryptionConfig {

    static func write(value: ConnectClientTypes.EncryptionConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EncryptionType"].write(value.encryptionType)
        try writer["KeyId"].write(value.keyId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.EncryptionConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.EncryptionConfig()
        value.encryptionType = try reader["EncryptionType"].readIfPresent() ?? .sdkUnknown("")
        value.keyId = try reader["KeyId"].readIfPresent() ?? ""
        return value
    }
}

extension ConnectClientTypes.S3Config {

    static func write(value: ConnectClientTypes.S3Config?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BucketName"].write(value.bucketName)
        try writer["BucketPrefix"].write(value.bucketPrefix)
        try writer["EncryptionConfig"].write(value.encryptionConfig, with: ConnectClientTypes.EncryptionConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.S3Config {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.S3Config()
        value.bucketName = try reader["BucketName"].readIfPresent() ?? ""
        value.bucketPrefix = try reader["BucketPrefix"].readIfPresent() ?? ""
        value.encryptionConfig = try reader["EncryptionConfig"].readIfPresent(with: ConnectClientTypes.EncryptionConfig.read(from:))
        return value
    }
}

extension ConnectClientTypes.ClaimedPhoneNumberSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.ClaimedPhoneNumberSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.ClaimedPhoneNumberSummary()
        value.phoneNumberId = try reader["PhoneNumberId"].readIfPresent()
        value.phoneNumberArn = try reader["PhoneNumberArn"].readIfPresent()
        value.phoneNumber = try reader["PhoneNumber"].readIfPresent()
        value.phoneNumberCountryCode = try reader["PhoneNumberCountryCode"].readIfPresent()
        value.phoneNumberType = try reader["PhoneNumberType"].readIfPresent()
        value.phoneNumberDescription = try reader["PhoneNumberDescription"].readIfPresent()
        value.targetArn = try reader["TargetArn"].readIfPresent()
        value.instanceId = try reader["InstanceId"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.phoneNumberStatus = try reader["PhoneNumberStatus"].readIfPresent(with: ConnectClientTypes.PhoneNumberStatus.read(from:))
        value.sourcePhoneNumberArn = try reader["SourcePhoneNumberArn"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.PhoneNumberStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.PhoneNumberStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.PhoneNumberStatus()
        value.status = try reader["Status"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.PredefinedAttribute {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.PredefinedAttribute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.PredefinedAttribute()
        value.name = try reader["Name"].readIfPresent()
        value.values = try reader["Values"].readIfPresent(with: ConnectClientTypes.PredefinedAttributeValues.read(from:))
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedRegion = try reader["LastModifiedRegion"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.PredefinedAttributeValues {

    static func write(value: ConnectClientTypes.PredefinedAttributeValues?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .stringlist(stringlist):
                try writer["StringList"].writeList(stringlist, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.PredefinedAttributeValues {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "StringList":
                return .stringlist(try reader["StringList"].readList(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension ConnectClientTypes.Prompt {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.Prompt {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.Prompt()
        value.promptARN = try reader["PromptARN"].readIfPresent()
        value.promptId = try reader["PromptId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedRegion = try reader["LastModifiedRegion"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.Queue {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.Queue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.Queue()
        value.name = try reader["Name"].readIfPresent()
        value.queueArn = try reader["QueueArn"].readIfPresent()
        value.queueId = try reader["QueueId"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.outboundCallerConfig = try reader["OutboundCallerConfig"].readIfPresent(with: ConnectClientTypes.OutboundCallerConfig.read(from:))
        value.hoursOfOperationId = try reader["HoursOfOperationId"].readIfPresent()
        value.maxContacts = try reader["MaxContacts"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedRegion = try reader["LastModifiedRegion"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.OutboundCallerConfig {

    static func write(value: ConnectClientTypes.OutboundCallerConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OutboundCallerIdName"].write(value.outboundCallerIdName)
        try writer["OutboundCallerIdNumberId"].write(value.outboundCallerIdNumberId)
        try writer["OutboundFlowId"].write(value.outboundFlowId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.OutboundCallerConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.OutboundCallerConfig()
        value.outboundCallerIdName = try reader["OutboundCallerIdName"].readIfPresent()
        value.outboundCallerIdNumberId = try reader["OutboundCallerIdNumberId"].readIfPresent()
        value.outboundFlowId = try reader["OutboundFlowId"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.QuickConnect {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.QuickConnect {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.QuickConnect()
        value.quickConnectARN = try reader["QuickConnectARN"].readIfPresent()
        value.quickConnectId = try reader["QuickConnectId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.quickConnectConfig = try reader["QuickConnectConfig"].readIfPresent(with: ConnectClientTypes.QuickConnectConfig.read(from:))
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedRegion = try reader["LastModifiedRegion"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.QuickConnectConfig {

    static func write(value: ConnectClientTypes.QuickConnectConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PhoneConfig"].write(value.phoneConfig, with: ConnectClientTypes.PhoneNumberQuickConnectConfig.write(value:to:))
        try writer["QueueConfig"].write(value.queueConfig, with: ConnectClientTypes.QueueQuickConnectConfig.write(value:to:))
        try writer["QuickConnectType"].write(value.quickConnectType)
        try writer["UserConfig"].write(value.userConfig, with: ConnectClientTypes.UserQuickConnectConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.QuickConnectConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.QuickConnectConfig()
        value.quickConnectType = try reader["QuickConnectType"].readIfPresent() ?? .sdkUnknown("")
        value.userConfig = try reader["UserConfig"].readIfPresent(with: ConnectClientTypes.UserQuickConnectConfig.read(from:))
        value.queueConfig = try reader["QueueConfig"].readIfPresent(with: ConnectClientTypes.QueueQuickConnectConfig.read(from:))
        value.phoneConfig = try reader["PhoneConfig"].readIfPresent(with: ConnectClientTypes.PhoneNumberQuickConnectConfig.read(from:))
        return value
    }
}

extension ConnectClientTypes.PhoneNumberQuickConnectConfig {

    static func write(value: ConnectClientTypes.PhoneNumberQuickConnectConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PhoneNumber"].write(value.phoneNumber)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.PhoneNumberQuickConnectConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.PhoneNumberQuickConnectConfig()
        value.phoneNumber = try reader["PhoneNumber"].readIfPresent() ?? ""
        return value
    }
}

extension ConnectClientTypes.QueueQuickConnectConfig {

    static func write(value: ConnectClientTypes.QueueQuickConnectConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactFlowId"].write(value.contactFlowId)
        try writer["QueueId"].write(value.queueId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.QueueQuickConnectConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.QueueQuickConnectConfig()
        value.queueId = try reader["QueueId"].readIfPresent() ?? ""
        value.contactFlowId = try reader["ContactFlowId"].readIfPresent() ?? ""
        return value
    }
}

extension ConnectClientTypes.UserQuickConnectConfig {

    static func write(value: ConnectClientTypes.UserQuickConnectConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactFlowId"].write(value.contactFlowId)
        try writer["UserId"].write(value.userId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.UserQuickConnectConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.UserQuickConnectConfig()
        value.userId = try reader["UserId"].readIfPresent() ?? ""
        value.contactFlowId = try reader["ContactFlowId"].readIfPresent() ?? ""
        return value
    }
}

extension ConnectClientTypes.RoutingProfile {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.RoutingProfile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.RoutingProfile()
        value.instanceId = try reader["InstanceId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.routingProfileArn = try reader["RoutingProfileArn"].readIfPresent()
        value.routingProfileId = try reader["RoutingProfileId"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.mediaConcurrencies = try reader["MediaConcurrencies"].readListIfPresent(memberReadingClosure: ConnectClientTypes.MediaConcurrency.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.defaultOutboundQueueId = try reader["DefaultOutboundQueueId"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.numberOfAssociatedQueues = try reader["NumberOfAssociatedQueues"].readIfPresent()
        value.numberOfAssociatedUsers = try reader["NumberOfAssociatedUsers"].readIfPresent()
        value.agentAvailabilityTimer = try reader["AgentAvailabilityTimer"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedRegion = try reader["LastModifiedRegion"].readIfPresent()
        value.isDefault = try reader["IsDefault"].readIfPresent() ?? false
        value.associatedQueueIds = try reader["AssociatedQueueIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ConnectClientTypes.MediaConcurrency {

    static func write(value: ConnectClientTypes.MediaConcurrency?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Channel"].write(value.channel)
        try writer["Concurrency"].write(value.concurrency)
        try writer["CrossChannelBehavior"].write(value.crossChannelBehavior, with: ConnectClientTypes.CrossChannelBehavior.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.MediaConcurrency {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.MediaConcurrency()
        value.channel = try reader["Channel"].readIfPresent() ?? .sdkUnknown("")
        value.concurrency = try reader["Concurrency"].readIfPresent() ?? 0
        value.crossChannelBehavior = try reader["CrossChannelBehavior"].readIfPresent(with: ConnectClientTypes.CrossChannelBehavior.read(from:))
        return value
    }
}

extension ConnectClientTypes.CrossChannelBehavior {

    static func write(value: ConnectClientTypes.CrossChannelBehavior?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BehaviorType"].write(value.behaviorType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.CrossChannelBehavior {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.CrossChannelBehavior()
        value.behaviorType = try reader["BehaviorType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ConnectClientTypes.Rule {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.Rule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.Rule()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.ruleId = try reader["RuleId"].readIfPresent() ?? ""
        value.ruleArn = try reader["RuleArn"].readIfPresent() ?? ""
        value.triggerEventSource = try reader["TriggerEventSource"].readIfPresent(with: ConnectClientTypes.RuleTriggerEventSource.read(from:))
        value.function = try reader["Function"].readIfPresent() ?? ""
        value.actions = try reader["Actions"].readListIfPresent(memberReadingClosure: ConnectClientTypes.RuleAction.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.publishStatus = try reader["PublishStatus"].readIfPresent() ?? .sdkUnknown("")
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedBy = try reader["LastUpdatedBy"].readIfPresent() ?? ""
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ConnectClientTypes.RuleAction {

    static func write(value: ConnectClientTypes.RuleAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ActionType"].write(value.actionType)
        try writer["AssignContactCategoryAction"].write(value.assignContactCategoryAction, with: ConnectClientTypes.AssignContactCategoryActionDefinition.write(value:to:))
        try writer["CreateCaseAction"].write(value.createCaseAction, with: ConnectClientTypes.CreateCaseActionDefinition.write(value:to:))
        try writer["EndAssociatedTasksAction"].write(value.endAssociatedTasksAction, with: ConnectClientTypes.EndAssociatedTasksActionDefinition.write(value:to:))
        try writer["EventBridgeAction"].write(value.eventBridgeAction, with: ConnectClientTypes.EventBridgeActionDefinition.write(value:to:))
        try writer["SendNotificationAction"].write(value.sendNotificationAction, with: ConnectClientTypes.SendNotificationActionDefinition.write(value:to:))
        try writer["SubmitAutoEvaluationAction"].write(value.submitAutoEvaluationAction, with: ConnectClientTypes.SubmitAutoEvaluationActionDefinition.write(value:to:))
        try writer["TaskAction"].write(value.taskAction, with: ConnectClientTypes.TaskActionDefinition.write(value:to:))
        try writer["UpdateCaseAction"].write(value.updateCaseAction, with: ConnectClientTypes.UpdateCaseActionDefinition.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.RuleAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.RuleAction()
        value.actionType = try reader["ActionType"].readIfPresent() ?? .sdkUnknown("")
        value.taskAction = try reader["TaskAction"].readIfPresent(with: ConnectClientTypes.TaskActionDefinition.read(from:))
        value.eventBridgeAction = try reader["EventBridgeAction"].readIfPresent(with: ConnectClientTypes.EventBridgeActionDefinition.read(from:))
        value.assignContactCategoryAction = try reader["AssignContactCategoryAction"].readIfPresent(with: ConnectClientTypes.AssignContactCategoryActionDefinition.read(from:))
        value.sendNotificationAction = try reader["SendNotificationAction"].readIfPresent(with: ConnectClientTypes.SendNotificationActionDefinition.read(from:))
        value.createCaseAction = try reader["CreateCaseAction"].readIfPresent(with: ConnectClientTypes.CreateCaseActionDefinition.read(from:))
        value.updateCaseAction = try reader["UpdateCaseAction"].readIfPresent(with: ConnectClientTypes.UpdateCaseActionDefinition.read(from:))
        value.endAssociatedTasksAction = try reader["EndAssociatedTasksAction"].readIfPresent(with: ConnectClientTypes.EndAssociatedTasksActionDefinition.read(from:))
        value.submitAutoEvaluationAction = try reader["SubmitAutoEvaluationAction"].readIfPresent(with: ConnectClientTypes.SubmitAutoEvaluationActionDefinition.read(from:))
        return value
    }
}

extension ConnectClientTypes.SubmitAutoEvaluationActionDefinition {

    static func write(value: ConnectClientTypes.SubmitAutoEvaluationActionDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EvaluationFormId"].write(value.evaluationFormId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.SubmitAutoEvaluationActionDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.SubmitAutoEvaluationActionDefinition()
        value.evaluationFormId = try reader["EvaluationFormId"].readIfPresent() ?? ""
        return value
    }
}

extension ConnectClientTypes.EndAssociatedTasksActionDefinition {

    static func write(value: ConnectClientTypes.EndAssociatedTasksActionDefinition?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.EndAssociatedTasksActionDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return ConnectClientTypes.EndAssociatedTasksActionDefinition()
    }
}

extension ConnectClientTypes.UpdateCaseActionDefinition {

    static func write(value: ConnectClientTypes.UpdateCaseActionDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Fields"].writeList(value.fields, memberWritingClosure: ConnectClientTypes.FieldValue.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.UpdateCaseActionDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.UpdateCaseActionDefinition()
        value.fields = try reader["Fields"].readListIfPresent(memberReadingClosure: ConnectClientTypes.FieldValue.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ConnectClientTypes.FieldValue {

    static func write(value: ConnectClientTypes.FieldValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id)
        try writer["Value"].write(value.value, with: ConnectClientTypes.FieldValueUnion.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.FieldValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.FieldValue()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent(with: ConnectClientTypes.FieldValueUnion.read(from:))
        return value
    }
}

extension ConnectClientTypes.FieldValueUnion {

    static func write(value: ConnectClientTypes.FieldValueUnion?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BooleanValue"].write(value.booleanValue)
        try writer["DoubleValue"].write(value.doubleValue)
        try writer["EmptyValue"].write(value.emptyValue, with: ConnectClientTypes.EmptyFieldValue.write(value:to:))
        try writer["StringValue"].write(value.stringValue)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.FieldValueUnion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.FieldValueUnion()
        value.booleanValue = try reader["BooleanValue"].readIfPresent() ?? false
        value.doubleValue = try reader["DoubleValue"].readIfPresent()
        value.emptyValue = try reader["EmptyValue"].readIfPresent(with: ConnectClientTypes.EmptyFieldValue.read(from:))
        value.stringValue = try reader["StringValue"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.EmptyFieldValue {

    static func write(value: ConnectClientTypes.EmptyFieldValue?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.EmptyFieldValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return ConnectClientTypes.EmptyFieldValue()
    }
}

extension ConnectClientTypes.CreateCaseActionDefinition {

    static func write(value: ConnectClientTypes.CreateCaseActionDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Fields"].writeList(value.fields, memberWritingClosure: ConnectClientTypes.FieldValue.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TemplateId"].write(value.templateId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.CreateCaseActionDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.CreateCaseActionDefinition()
        value.fields = try reader["Fields"].readListIfPresent(memberReadingClosure: ConnectClientTypes.FieldValue.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.templateId = try reader["TemplateId"].readIfPresent() ?? ""
        return value
    }
}

extension ConnectClientTypes.SendNotificationActionDefinition {

    static func write(value: ConnectClientTypes.SendNotificationActionDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Content"].write(value.content)
        try writer["ContentType"].write(value.contentType)
        try writer["DeliveryMethod"].write(value.deliveryMethod)
        try writer["Recipient"].write(value.recipient, with: ConnectClientTypes.NotificationRecipientType.write(value:to:))
        try writer["Subject"].write(value.subject)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.SendNotificationActionDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.SendNotificationActionDefinition()
        value.deliveryMethod = try reader["DeliveryMethod"].readIfPresent() ?? .sdkUnknown("")
        value.subject = try reader["Subject"].readIfPresent()
        value.content = try reader["Content"].readIfPresent() ?? ""
        value.contentType = try reader["ContentType"].readIfPresent() ?? .sdkUnknown("")
        value.recipient = try reader["Recipient"].readIfPresent(with: ConnectClientTypes.NotificationRecipientType.read(from:))
        return value
    }
}

extension ConnectClientTypes.NotificationRecipientType {

    static func write(value: ConnectClientTypes.NotificationRecipientType?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["UserIds"].writeList(value.userIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UserTags"].writeMap(value.userTags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.NotificationRecipientType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.NotificationRecipientType()
        value.userTags = try reader["UserTags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.userIds = try reader["UserIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ConnectClientTypes.AssignContactCategoryActionDefinition {

    static func write(value: ConnectClientTypes.AssignContactCategoryActionDefinition?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.AssignContactCategoryActionDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return ConnectClientTypes.AssignContactCategoryActionDefinition()
    }
}

extension ConnectClientTypes.EventBridgeActionDefinition {

    static func write(value: ConnectClientTypes.EventBridgeActionDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.EventBridgeActionDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.EventBridgeActionDefinition()
        value.name = try reader["Name"].readIfPresent() ?? ""
        return value
    }
}

extension ConnectClientTypes.TaskActionDefinition {

    static func write(value: ConnectClientTypes.TaskActionDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactFlowId"].write(value.contactFlowId)
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["References"].writeMap(value.references, valueWritingClosure: ConnectClientTypes.Reference.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.TaskActionDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.TaskActionDefinition()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.description = try reader["Description"].readIfPresent()
        value.contactFlowId = try reader["ContactFlowId"].readIfPresent() ?? ""
        value.references = try reader["References"].readMapIfPresent(valueReadingClosure: ConnectClientTypes.Reference.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ConnectClientTypes.Reference {

    static func write(value: ConnectClientTypes.Reference?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Type"].write(value.type)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.Reference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.Reference()
        value.value = try reader["Value"].readIfPresent() ?? ""
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ConnectClientTypes.RuleTriggerEventSource {

    static func write(value: ConnectClientTypes.RuleTriggerEventSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EventSourceName"].write(value.eventSourceName)
        try writer["IntegrationAssociationId"].write(value.integrationAssociationId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.RuleTriggerEventSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.RuleTriggerEventSource()
        value.eventSourceName = try reader["EventSourceName"].readIfPresent() ?? .sdkUnknown("")
        value.integrationAssociationId = try reader["IntegrationAssociationId"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.SecurityProfile {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.SecurityProfile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.SecurityProfile()
        value.id = try reader["Id"].readIfPresent()
        value.organizationResourceId = try reader["OrganizationResourceId"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.securityProfileName = try reader["SecurityProfileName"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.allowedAccessControlTags = try reader["AllowedAccessControlTags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.tagRestrictedResources = try reader["TagRestrictedResources"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedRegion = try reader["LastModifiedRegion"].readIfPresent()
        value.hierarchyRestrictedResources = try reader["HierarchyRestrictedResources"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.allowedAccessControlHierarchyGroupId = try reader["AllowedAccessControlHierarchyGroupId"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.TrafficDistributionGroup {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.TrafficDistributionGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.TrafficDistributionGroup()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.instanceArn = try reader["InstanceArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.isDefault = try reader["IsDefault"].readIfPresent() ?? false
        return value
    }
}

extension ConnectClientTypes.User {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.User {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.User()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.username = try reader["Username"].readIfPresent()
        value.identityInfo = try reader["IdentityInfo"].readIfPresent(with: ConnectClientTypes.UserIdentityInfo.read(from:))
        value.phoneConfig = try reader["PhoneConfig"].readIfPresent(with: ConnectClientTypes.UserPhoneConfig.read(from:))
        value.directoryUserId = try reader["DirectoryUserId"].readIfPresent()
        value.securityProfileIds = try reader["SecurityProfileIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.routingProfileId = try reader["RoutingProfileId"].readIfPresent()
        value.hierarchyGroupId = try reader["HierarchyGroupId"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedRegion = try reader["LastModifiedRegion"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.UserPhoneConfig {

    static func write(value: ConnectClientTypes.UserPhoneConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AfterContactWorkTimeLimit"].write(value.afterContactWorkTimeLimit)
        try writer["AutoAccept"].write(value.autoAccept)
        try writer["DeskPhoneNumber"].write(value.deskPhoneNumber)
        try writer["PhoneType"].write(value.phoneType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.UserPhoneConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.UserPhoneConfig()
        value.phoneType = try reader["PhoneType"].readIfPresent() ?? .sdkUnknown("")
        value.autoAccept = try reader["AutoAccept"].readIfPresent() ?? false
        value.afterContactWorkTimeLimit = try reader["AfterContactWorkTimeLimit"].readIfPresent() ?? 0
        value.deskPhoneNumber = try reader["DeskPhoneNumber"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.UserIdentityInfo {

    static func write(value: ConnectClientTypes.UserIdentityInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Email"].write(value.email)
        try writer["FirstName"].write(value.firstName)
        try writer["LastName"].write(value.lastName)
        try writer["Mobile"].write(value.mobile)
        try writer["SecondaryEmail"].write(value.secondaryEmail)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.UserIdentityInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.UserIdentityInfo()
        value.firstName = try reader["FirstName"].readIfPresent()
        value.lastName = try reader["LastName"].readIfPresent()
        value.email = try reader["Email"].readIfPresent()
        value.secondaryEmail = try reader["SecondaryEmail"].readIfPresent()
        value.mobile = try reader["Mobile"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.HierarchyGroup {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.HierarchyGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.HierarchyGroup()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.levelId = try reader["LevelId"].readIfPresent()
        value.hierarchyPath = try reader["HierarchyPath"].readIfPresent(with: ConnectClientTypes.HierarchyPath.read(from:))
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedRegion = try reader["LastModifiedRegion"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.HierarchyPath {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.HierarchyPath {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.HierarchyPath()
        value.levelOne = try reader["LevelOne"].readIfPresent(with: ConnectClientTypes.HierarchyGroupSummary.read(from:))
        value.levelTwo = try reader["LevelTwo"].readIfPresent(with: ConnectClientTypes.HierarchyGroupSummary.read(from:))
        value.levelThree = try reader["LevelThree"].readIfPresent(with: ConnectClientTypes.HierarchyGroupSummary.read(from:))
        value.levelFour = try reader["LevelFour"].readIfPresent(with: ConnectClientTypes.HierarchyGroupSummary.read(from:))
        value.levelFive = try reader["LevelFive"].readIfPresent(with: ConnectClientTypes.HierarchyGroupSummary.read(from:))
        return value
    }
}

extension ConnectClientTypes.HierarchyGroupSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.HierarchyGroupSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.HierarchyGroupSummary()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedRegion = try reader["LastModifiedRegion"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.HierarchyStructure {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.HierarchyStructure {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.HierarchyStructure()
        value.levelOne = try reader["LevelOne"].readIfPresent(with: ConnectClientTypes.HierarchyLevel.read(from:))
        value.levelTwo = try reader["LevelTwo"].readIfPresent(with: ConnectClientTypes.HierarchyLevel.read(from:))
        value.levelThree = try reader["LevelThree"].readIfPresent(with: ConnectClientTypes.HierarchyLevel.read(from:))
        value.levelFour = try reader["LevelFour"].readIfPresent(with: ConnectClientTypes.HierarchyLevel.read(from:))
        value.levelFive = try reader["LevelFive"].readIfPresent(with: ConnectClientTypes.HierarchyLevel.read(from:))
        return value
    }
}

extension ConnectClientTypes.HierarchyLevel {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.HierarchyLevel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.HierarchyLevel()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedRegion = try reader["LastModifiedRegion"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.Vocabulary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.Vocabulary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.Vocabulary()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.languageCode = try reader["LanguageCode"].readIfPresent() ?? .sdkUnknown("")
        value.state = try reader["State"].readIfPresent() ?? .sdkUnknown("")
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.failureReason = try reader["FailureReason"].readIfPresent()
        value.content = try reader["Content"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ConnectClientTypes.DownloadUrlMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.DownloadUrlMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.DownloadUrlMetadata()
        value.url = try reader["Url"].readIfPresent()
        value.urlExpiry = try reader["UrlExpiry"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.CurrentMetricResult {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.CurrentMetricResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.CurrentMetricResult()
        value.dimensions = try reader["Dimensions"].readIfPresent(with: ConnectClientTypes.Dimensions.read(from:))
        value.collections = try reader["Collections"].readListIfPresent(memberReadingClosure: ConnectClientTypes.CurrentMetricData.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ConnectClientTypes.CurrentMetricData {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.CurrentMetricData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.CurrentMetricData()
        value.metric = try reader["Metric"].readIfPresent(with: ConnectClientTypes.CurrentMetric.read(from:))
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.CurrentMetric {

    static func write(value: ConnectClientTypes.CurrentMetric?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Unit"].write(value.unit)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.CurrentMetric {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.CurrentMetric()
        value.name = try reader["Name"].readIfPresent()
        value.unit = try reader["Unit"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.Dimensions {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.Dimensions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.Dimensions()
        value.queue = try reader["Queue"].readIfPresent(with: ConnectClientTypes.QueueReference.read(from:))
        value.channel = try reader["Channel"].readIfPresent()
        value.routingProfile = try reader["RoutingProfile"].readIfPresent(with: ConnectClientTypes.RoutingProfileReference.read(from:))
        value.routingStepExpression = try reader["RoutingStepExpression"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.RoutingProfileReference {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.RoutingProfileReference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.RoutingProfileReference()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.QueueReference {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.QueueReference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.QueueReference()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.UserData {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.UserData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.UserData()
        value.user = try reader["User"].readIfPresent(with: ConnectClientTypes.UserReference.read(from:))
        value.routingProfile = try reader["RoutingProfile"].readIfPresent(with: ConnectClientTypes.RoutingProfileReference.read(from:))
        value.hierarchyPath = try reader["HierarchyPath"].readIfPresent(with: ConnectClientTypes.HierarchyPathReference.read(from:))
        value.status = try reader["Status"].readIfPresent(with: ConnectClientTypes.AgentStatusReference.read(from:))
        value.availableSlotsByChannel = try reader["AvailableSlotsByChannel"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.maxSlotsByChannel = try reader["MaxSlotsByChannel"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.activeSlotsByChannel = try reader["ActiveSlotsByChannel"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.contacts = try reader["Contacts"].readListIfPresent(memberReadingClosure: ConnectClientTypes.AgentContactReference.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextStatus = try reader["NextStatus"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.AgentContactReference {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.AgentContactReference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.AgentContactReference()
        value.contactId = try reader["ContactId"].readIfPresent()
        value.channel = try reader["Channel"].readIfPresent()
        value.initiationMethod = try reader["InitiationMethod"].readIfPresent()
        value.agentContactState = try reader["AgentContactState"].readIfPresent()
        value.stateStartTimestamp = try reader["StateStartTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.connectedToAgentTimestamp = try reader["ConnectedToAgentTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.queue = try reader["Queue"].readIfPresent(with: ConnectClientTypes.QueueReference.read(from:))
        return value
    }
}

extension ConnectClientTypes.AgentStatusReference {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.AgentStatusReference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.AgentStatusReference()
        value.statusStartTimestamp = try reader["StatusStartTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.statusArn = try reader["StatusArn"].readIfPresent()
        value.statusName = try reader["StatusName"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.HierarchyPathReference {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.HierarchyPathReference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.HierarchyPathReference()
        value.levelOne = try reader["LevelOne"].readIfPresent(with: ConnectClientTypes.HierarchyGroupSummaryReference.read(from:))
        value.levelTwo = try reader["LevelTwo"].readIfPresent(with: ConnectClientTypes.HierarchyGroupSummaryReference.read(from:))
        value.levelThree = try reader["LevelThree"].readIfPresent(with: ConnectClientTypes.HierarchyGroupSummaryReference.read(from:))
        value.levelFour = try reader["LevelFour"].readIfPresent(with: ConnectClientTypes.HierarchyGroupSummaryReference.read(from:))
        value.levelFive = try reader["LevelFive"].readIfPresent(with: ConnectClientTypes.HierarchyGroupSummaryReference.read(from:))
        return value
    }
}

extension ConnectClientTypes.HierarchyGroupSummaryReference {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.HierarchyGroupSummaryReference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.HierarchyGroupSummaryReference()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.UserReference {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.UserReference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.UserReference()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.Credentials {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.Credentials {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.Credentials()
        value.accessToken = try reader["AccessToken"].readIfPresent()
        value.accessTokenExpiration = try reader["AccessTokenExpiration"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.refreshToken = try reader["RefreshToken"].readIfPresent()
        value.refreshTokenExpiration = try reader["RefreshTokenExpiration"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ConnectClientTypes.HistoricalMetricResult {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.HistoricalMetricResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.HistoricalMetricResult()
        value.dimensions = try reader["Dimensions"].readIfPresent(with: ConnectClientTypes.Dimensions.read(from:))
        value.collections = try reader["Collections"].readListIfPresent(memberReadingClosure: ConnectClientTypes.HistoricalMetricData.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ConnectClientTypes.HistoricalMetricData {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.HistoricalMetricData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.HistoricalMetricData()
        value.metric = try reader["Metric"].readIfPresent(with: ConnectClientTypes.HistoricalMetric.read(from:))
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.HistoricalMetric {

    static func write(value: ConnectClientTypes.HistoricalMetric?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Statistic"].write(value.statistic)
        try writer["Threshold"].write(value.threshold, with: ConnectClientTypes.Threshold.write(value:to:))
        try writer["Unit"].write(value.unit)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.HistoricalMetric {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.HistoricalMetric()
        value.name = try reader["Name"].readIfPresent()
        value.threshold = try reader["Threshold"].readIfPresent(with: ConnectClientTypes.Threshold.read(from:))
        value.statistic = try reader["Statistic"].readIfPresent()
        value.unit = try reader["Unit"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.Threshold {

    static func write(value: ConnectClientTypes.Threshold?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Comparison"].write(value.comparison)
        try writer["ThresholdValue"].write(value.thresholdValue)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.Threshold {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.Threshold()
        value.comparison = try reader["Comparison"].readIfPresent()
        value.thresholdValue = try reader["ThresholdValue"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.MetricResultV2 {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.MetricResultV2 {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.MetricResultV2()
        value.dimensions = try reader["Dimensions"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.metricInterval = try reader["MetricInterval"].readIfPresent(with: ConnectClientTypes.MetricInterval.read(from:))
        value.collections = try reader["Collections"].readListIfPresent(memberReadingClosure: ConnectClientTypes.MetricDataV2.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ConnectClientTypes.MetricDataV2 {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.MetricDataV2 {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.MetricDataV2()
        value.metric = try reader["Metric"].readIfPresent(with: ConnectClientTypes.MetricV2.read(from:))
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.MetricV2 {

    static func write(value: ConnectClientTypes.MetricV2?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MetricFilters"].writeList(value.metricFilters, memberWritingClosure: ConnectClientTypes.MetricFilterV2.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["Threshold"].writeList(value.threshold, memberWritingClosure: ConnectClientTypes.ThresholdV2.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.MetricV2 {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.MetricV2()
        value.name = try reader["Name"].readIfPresent()
        value.threshold = try reader["Threshold"].readListIfPresent(memberReadingClosure: ConnectClientTypes.ThresholdV2.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.metricFilters = try reader["MetricFilters"].readListIfPresent(memberReadingClosure: ConnectClientTypes.MetricFilterV2.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ConnectClientTypes.MetricFilterV2 {

    static func write(value: ConnectClientTypes.MetricFilterV2?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MetricFilterKey"].write(value.metricFilterKey)
        try writer["MetricFilterValues"].writeList(value.metricFilterValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Negate"].write(value.negate)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.MetricFilterV2 {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.MetricFilterV2()
        value.metricFilterKey = try reader["MetricFilterKey"].readIfPresent()
        value.metricFilterValues = try reader["MetricFilterValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.negate = try reader["Negate"].readIfPresent() ?? false
        return value
    }
}

extension ConnectClientTypes.ThresholdV2 {

    static func write(value: ConnectClientTypes.ThresholdV2?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Comparison"].write(value.comparison)
        try writer["ThresholdValue"].write(value.thresholdValue)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.ThresholdV2 {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.ThresholdV2()
        value.comparison = try reader["Comparison"].readIfPresent()
        value.thresholdValue = try reader["ThresholdValue"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.MetricInterval {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.MetricInterval {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.MetricInterval()
        value.interval = try reader["Interval"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ConnectClientTypes.TaskTemplateConstraints {

    static func write(value: ConnectClientTypes.TaskTemplateConstraints?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InvisibleFields"].writeList(value.invisibleFields, memberWritingClosure: ConnectClientTypes.InvisibleFieldInfo.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ReadOnlyFields"].writeList(value.readOnlyFields, memberWritingClosure: ConnectClientTypes.ReadOnlyFieldInfo.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RequiredFields"].writeList(value.requiredFields, memberWritingClosure: ConnectClientTypes.RequiredFieldInfo.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.TaskTemplateConstraints {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.TaskTemplateConstraints()
        value.requiredFields = try reader["RequiredFields"].readListIfPresent(memberReadingClosure: ConnectClientTypes.RequiredFieldInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.readOnlyFields = try reader["ReadOnlyFields"].readListIfPresent(memberReadingClosure: ConnectClientTypes.ReadOnlyFieldInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.invisibleFields = try reader["InvisibleFields"].readListIfPresent(memberReadingClosure: ConnectClientTypes.InvisibleFieldInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ConnectClientTypes.InvisibleFieldInfo {

    static func write(value: ConnectClientTypes.InvisibleFieldInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id, with: ConnectClientTypes.TaskTemplateFieldIdentifier.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.InvisibleFieldInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.InvisibleFieldInfo()
        value.id = try reader["Id"].readIfPresent(with: ConnectClientTypes.TaskTemplateFieldIdentifier.read(from:))
        return value
    }
}

extension ConnectClientTypes.TaskTemplateFieldIdentifier {

    static func write(value: ConnectClientTypes.TaskTemplateFieldIdentifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.TaskTemplateFieldIdentifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.TaskTemplateFieldIdentifier()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.ReadOnlyFieldInfo {

    static func write(value: ConnectClientTypes.ReadOnlyFieldInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id, with: ConnectClientTypes.TaskTemplateFieldIdentifier.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.ReadOnlyFieldInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.ReadOnlyFieldInfo()
        value.id = try reader["Id"].readIfPresent(with: ConnectClientTypes.TaskTemplateFieldIdentifier.read(from:))
        return value
    }
}

extension ConnectClientTypes.RequiredFieldInfo {

    static func write(value: ConnectClientTypes.RequiredFieldInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id, with: ConnectClientTypes.TaskTemplateFieldIdentifier.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.RequiredFieldInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.RequiredFieldInfo()
        value.id = try reader["Id"].readIfPresent(with: ConnectClientTypes.TaskTemplateFieldIdentifier.read(from:))
        return value
    }
}

extension ConnectClientTypes.TaskTemplateDefaults {

    static func write(value: ConnectClientTypes.TaskTemplateDefaults?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultFieldValues"].writeList(value.defaultFieldValues, memberWritingClosure: ConnectClientTypes.TaskTemplateDefaultFieldValue.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.TaskTemplateDefaults {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.TaskTemplateDefaults()
        value.defaultFieldValues = try reader["DefaultFieldValues"].readListIfPresent(memberReadingClosure: ConnectClientTypes.TaskTemplateDefaultFieldValue.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ConnectClientTypes.TaskTemplateDefaultFieldValue {

    static func write(value: ConnectClientTypes.TaskTemplateDefaultFieldValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultValue"].write(value.defaultValue)
        try writer["Id"].write(value.id, with: ConnectClientTypes.TaskTemplateFieldIdentifier.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.TaskTemplateDefaultFieldValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.TaskTemplateDefaultFieldValue()
        value.id = try reader["Id"].readIfPresent(with: ConnectClientTypes.TaskTemplateFieldIdentifier.read(from:))
        value.defaultValue = try reader["DefaultValue"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.TaskTemplateField {

    static func write(value: ConnectClientTypes.TaskTemplateField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Id"].write(value.id, with: ConnectClientTypes.TaskTemplateFieldIdentifier.write(value:to:))
        try writer["SingleSelectOptions"].writeList(value.singleSelectOptions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.TaskTemplateField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.TaskTemplateField()
        value.id = try reader["Id"].readIfPresent(with: ConnectClientTypes.TaskTemplateFieldIdentifier.read(from:))
        value.description = try reader["Description"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.singleSelectOptions = try reader["SingleSelectOptions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ConnectClientTypes.TelephonyConfig {

    static func write(value: ConnectClientTypes.TelephonyConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Distributions"].writeList(value.distributions, memberWritingClosure: ConnectClientTypes.Distribution.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.TelephonyConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.TelephonyConfig()
        value.distributions = try reader["Distributions"].readListIfPresent(memberReadingClosure: ConnectClientTypes.Distribution.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ConnectClientTypes.Distribution {

    static func write(value: ConnectClientTypes.Distribution?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Percentage"].write(value.percentage)
        try writer["Region"].write(value.region)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.Distribution {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.Distribution()
        value.region = try reader["Region"].readIfPresent() ?? ""
        value.percentage = try reader["Percentage"].readIfPresent() ?? 0
        return value
    }
}

extension ConnectClientTypes.SignInConfig {

    static func write(value: ConnectClientTypes.SignInConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Distributions"].writeList(value.distributions, memberWritingClosure: ConnectClientTypes.SignInDistribution.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.SignInConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.SignInConfig()
        value.distributions = try reader["Distributions"].readListIfPresent(memberReadingClosure: ConnectClientTypes.SignInDistribution.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ConnectClientTypes.SignInDistribution {

    static func write(value: ConnectClientTypes.SignInDistribution?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
        try writer["Region"].write(value.region)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.SignInDistribution {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.SignInDistribution()
        value.region = try reader["Region"].readIfPresent() ?? ""
        value.enabled = try reader["Enabled"].readIfPresent() ?? false
        return value
    }
}

extension ConnectClientTypes.AgentConfig {

    static func write(value: ConnectClientTypes.AgentConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Distributions"].writeList(value.distributions, memberWritingClosure: ConnectClientTypes.Distribution.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.AgentConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.AgentConfig()
        value.distributions = try reader["Distributions"].readListIfPresent(memberReadingClosure: ConnectClientTypes.Distribution.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ConnectClientTypes.AgentStatusSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.AgentStatusSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.AgentStatusSummary()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedRegion = try reader["LastModifiedRegion"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.AuthenticationProfileSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.AuthenticationProfileSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.AuthenticationProfileSummary()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.isDefault = try reader["IsDefault"].readIfPresent() ?? false
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedRegion = try reader["LastModifiedRegion"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.LexBotConfig {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.LexBotConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.LexBotConfig()
        value.lexBot = try reader["LexBot"].readIfPresent(with: ConnectClientTypes.LexBot.read(from:))
        value.lexV2Bot = try reader["LexV2Bot"].readIfPresent(with: ConnectClientTypes.LexV2Bot.read(from:))
        return value
    }
}

extension ConnectClientTypes.LexV2Bot {

    static func write(value: ConnectClientTypes.LexV2Bot?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AliasArn"].write(value.aliasArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.LexV2Bot {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.LexV2Bot()
        value.aliasArn = try reader["AliasArn"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.LexBot {

    static func write(value: ConnectClientTypes.LexBot?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LexRegion"].write(value.lexRegion)
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.LexBot {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.LexBot()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.lexRegion = try reader["LexRegion"].readIfPresent() ?? ""
        return value
    }
}

extension ConnectClientTypes.EvaluationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.EvaluationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.EvaluationSummary()
        value.evaluationId = try reader["EvaluationId"].readIfPresent() ?? ""
        value.evaluationArn = try reader["EvaluationArn"].readIfPresent() ?? ""
        value.evaluationFormTitle = try reader["EvaluationFormTitle"].readIfPresent() ?? ""
        value.evaluationFormId = try reader["EvaluationFormId"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.evaluatorArn = try reader["EvaluatorArn"].readIfPresent() ?? ""
        value.score = try reader["Score"].readIfPresent(with: ConnectClientTypes.EvaluationScore.read(from:))
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension ConnectClientTypes.ContactFlowModuleSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.ContactFlowModuleSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.ContactFlowModuleSummary()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.ContactFlowSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.ContactFlowSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.ContactFlowSummary()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.contactFlowType = try reader["ContactFlowType"].readIfPresent()
        value.contactFlowState = try reader["ContactFlowState"].readIfPresent()
        value.contactFlowStatus = try reader["ContactFlowStatus"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.ReferenceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.ReferenceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "Url":
                return .url(try reader["Url"].read(with: ConnectClientTypes.UrlReference.read(from:)))
            case "Attachment":
                return .attachment(try reader["Attachment"].read(with: ConnectClientTypes.AttachmentReference.read(from:)))
            case "String":
                return .string(try reader["String"].read(with: ConnectClientTypes.StringReference.read(from:)))
            case "Number":
                return .number(try reader["Number"].read(with: ConnectClientTypes.NumberReference.read(from:)))
            case "Date":
                return .date(try reader["Date"].read(with: ConnectClientTypes.DateReference.read(from:)))
            case "Email":
                return .email(try reader["Email"].read(with: ConnectClientTypes.EmailReference.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension ConnectClientTypes.EmailReference {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.EmailReference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.EmailReference()
        value.name = try reader["Name"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.DateReference {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.DateReference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.DateReference()
        value.name = try reader["Name"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.NumberReference {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.NumberReference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.NumberReference()
        value.name = try reader["Name"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.StringReference {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.StringReference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.StringReference()
        value.name = try reader["Name"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.AttachmentReference {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.AttachmentReference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.AttachmentReference()
        value.name = try reader["Name"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.UrlReference {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.UrlReference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.UrlReference()
        value.name = try reader["Name"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.DefaultVocabulary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.DefaultVocabulary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.DefaultVocabulary()
        value.instanceId = try reader["InstanceId"].readIfPresent() ?? ""
        value.languageCode = try reader["LanguageCode"].readIfPresent() ?? .sdkUnknown("")
        value.vocabularyId = try reader["VocabularyId"].readIfPresent() ?? ""
        value.vocabularyName = try reader["VocabularyName"].readIfPresent() ?? ""
        return value
    }
}

extension ConnectClientTypes.EvaluationFormSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.EvaluationFormSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.EvaluationFormSummary()
        value.evaluationFormId = try reader["EvaluationFormId"].readIfPresent() ?? ""
        value.evaluationFormArn = try reader["EvaluationFormArn"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["CreatedBy"].readIfPresent() ?? ""
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedBy = try reader["LastModifiedBy"].readIfPresent() ?? ""
        value.lastActivatedTime = try reader["LastActivatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastActivatedBy = try reader["LastActivatedBy"].readIfPresent()
        value.latestVersion = try reader["LatestVersion"].readIfPresent() ?? 0
        value.activeVersion = try reader["ActiveVersion"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.EvaluationFormVersionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.EvaluationFormVersionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.EvaluationFormVersionSummary()
        value.evaluationFormArn = try reader["EvaluationFormArn"].readIfPresent() ?? ""
        value.evaluationFormId = try reader["EvaluationFormId"].readIfPresent() ?? ""
        value.evaluationFormVersion = try reader["EvaluationFormVersion"].readIfPresent() ?? 0
        value.locked = try reader["Locked"].readIfPresent() ?? false
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["CreatedBy"].readIfPresent() ?? ""
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedBy = try reader["LastModifiedBy"].readIfPresent() ?? ""
        return value
    }
}

extension ConnectClientTypes.HoursOfOperationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.HoursOfOperationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.HoursOfOperationSummary()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedRegion = try reader["LastModifiedRegion"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.InstanceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.InstanceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.InstanceSummary()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.identityManagementType = try reader["IdentityManagementType"].readIfPresent()
        value.instanceAlias = try reader["InstanceAlias"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.serviceRole = try reader["ServiceRole"].readIfPresent()
        value.instanceStatus = try reader["InstanceStatus"].readIfPresent()
        value.inboundCallsEnabled = try reader["InboundCallsEnabled"].readIfPresent()
        value.outboundCallsEnabled = try reader["OutboundCallsEnabled"].readIfPresent()
        value.instanceAccessUrl = try reader["InstanceAccessUrl"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.IntegrationAssociationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.IntegrationAssociationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.IntegrationAssociationSummary()
        value.integrationAssociationId = try reader["IntegrationAssociationId"].readIfPresent()
        value.integrationAssociationArn = try reader["IntegrationAssociationArn"].readIfPresent()
        value.instanceId = try reader["InstanceId"].readIfPresent()
        value.integrationType = try reader["IntegrationType"].readIfPresent()
        value.integrationArn = try reader["IntegrationArn"].readIfPresent()
        value.sourceApplicationUrl = try reader["SourceApplicationUrl"].readIfPresent()
        value.sourceApplicationName = try reader["SourceApplicationName"].readIfPresent()
        value.sourceType = try reader["SourceType"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.PhoneNumberSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.PhoneNumberSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.PhoneNumberSummary()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.phoneNumber = try reader["PhoneNumber"].readIfPresent()
        value.phoneNumberType = try reader["PhoneNumberType"].readIfPresent()
        value.phoneNumberCountryCode = try reader["PhoneNumberCountryCode"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.ListPhoneNumbersSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.ListPhoneNumbersSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.ListPhoneNumbersSummary()
        value.phoneNumberId = try reader["PhoneNumberId"].readIfPresent()
        value.phoneNumberArn = try reader["PhoneNumberArn"].readIfPresent()
        value.phoneNumber = try reader["PhoneNumber"].readIfPresent()
        value.phoneNumberCountryCode = try reader["PhoneNumberCountryCode"].readIfPresent()
        value.phoneNumberType = try reader["PhoneNumberType"].readIfPresent()
        value.targetArn = try reader["TargetArn"].readIfPresent()
        value.instanceId = try reader["InstanceId"].readIfPresent()
        value.phoneNumberDescription = try reader["PhoneNumberDescription"].readIfPresent()
        value.sourcePhoneNumberArn = try reader["SourcePhoneNumberArn"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.PredefinedAttributeSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.PredefinedAttributeSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.PredefinedAttributeSummary()
        value.name = try reader["Name"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedRegion = try reader["LastModifiedRegion"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.PromptSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.PromptSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.PromptSummary()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedRegion = try reader["LastModifiedRegion"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.QuickConnectSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.QuickConnectSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.QuickConnectSummary()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.quickConnectType = try reader["QuickConnectType"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedRegion = try reader["LastModifiedRegion"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.QueueSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.QueueSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.QueueSummary()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.queueType = try reader["QueueType"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedRegion = try reader["LastModifiedRegion"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.RealtimeContactAnalysisSegment {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.RealtimeContactAnalysisSegment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "Transcript":
                return .transcript(try reader["Transcript"].read(with: ConnectClientTypes.RealTimeContactAnalysisSegmentTranscript.read(from:)))
            case "Categories":
                return .categories(try reader["Categories"].read(with: ConnectClientTypes.RealTimeContactAnalysisSegmentCategories.read(from:)))
            case "Issues":
                return .issues(try reader["Issues"].read(with: ConnectClientTypes.RealTimeContactAnalysisSegmentIssues.read(from:)))
            case "Event":
                return .event(try reader["Event"].read(with: ConnectClientTypes.RealTimeContactAnalysisSegmentEvent.read(from:)))
            case "Attachments":
                return .attachments(try reader["Attachments"].read(with: ConnectClientTypes.RealTimeContactAnalysisSegmentAttachments.read(from:)))
            case "PostContactSummary":
                return .postcontactsummary(try reader["PostContactSummary"].read(with: ConnectClientTypes.RealTimeContactAnalysisSegmentPostContactSummary.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension ConnectClientTypes.RealTimeContactAnalysisSegmentPostContactSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.RealTimeContactAnalysisSegmentPostContactSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.RealTimeContactAnalysisSegmentPostContactSummary()
        value.content = try reader["Content"].readIfPresent()
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.failureCode = try reader["FailureCode"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.RealTimeContactAnalysisSegmentAttachments {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.RealTimeContactAnalysisSegmentAttachments {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.RealTimeContactAnalysisSegmentAttachments()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.participantId = try reader["ParticipantId"].readIfPresent() ?? ""
        value.participantRole = try reader["ParticipantRole"].readIfPresent() ?? .sdkUnknown("")
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.attachments = try reader["Attachments"].readListIfPresent(memberReadingClosure: ConnectClientTypes.RealTimeContactAnalysisAttachment.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.time = try reader["Time"].readIfPresent(with: ConnectClientTypes.RealTimeContactAnalysisTimeData.read(from:))
        return value
    }
}

extension ConnectClientTypes.RealTimeContactAnalysisTimeData {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.RealTimeContactAnalysisTimeData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "AbsoluteTime":
                return .absolutetime(try reader["AbsoluteTime"].readTimestamp(format: SmithyTimestamps.TimestampFormat.dateTime))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension ConnectClientTypes.RealTimeContactAnalysisAttachment {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.RealTimeContactAnalysisAttachment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.RealTimeContactAnalysisAttachment()
        value.attachmentName = try reader["AttachmentName"].readIfPresent() ?? ""
        value.contentType = try reader["ContentType"].readIfPresent()
        value.attachmentId = try reader["AttachmentId"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.RealTimeContactAnalysisSegmentEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.RealTimeContactAnalysisSegmentEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.RealTimeContactAnalysisSegmentEvent()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.participantId = try reader["ParticipantId"].readIfPresent()
        value.participantRole = try reader["ParticipantRole"].readIfPresent()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.eventType = try reader["EventType"].readIfPresent() ?? ""
        value.time = try reader["Time"].readIfPresent(with: ConnectClientTypes.RealTimeContactAnalysisTimeData.read(from:))
        return value
    }
}

extension ConnectClientTypes.RealTimeContactAnalysisSegmentIssues {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.RealTimeContactAnalysisSegmentIssues {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.RealTimeContactAnalysisSegmentIssues()
        value.issuesDetected = try reader["IssuesDetected"].readListIfPresent(memberReadingClosure: ConnectClientTypes.RealTimeContactAnalysisIssueDetected.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ConnectClientTypes.RealTimeContactAnalysisIssueDetected {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.RealTimeContactAnalysisIssueDetected {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.RealTimeContactAnalysisIssueDetected()
        value.transcriptItems = try reader["TranscriptItems"].readListIfPresent(memberReadingClosure: ConnectClientTypes.RealTimeContactAnalysisTranscriptItemWithContent.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ConnectClientTypes.RealTimeContactAnalysisTranscriptItemWithContent {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.RealTimeContactAnalysisTranscriptItemWithContent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.RealTimeContactAnalysisTranscriptItemWithContent()
        value.content = try reader["Content"].readIfPresent()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.characterOffsets = try reader["CharacterOffsets"].readIfPresent(with: ConnectClientTypes.RealTimeContactAnalysisCharacterInterval.read(from:))
        return value
    }
}

extension ConnectClientTypes.RealTimeContactAnalysisCharacterInterval {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.RealTimeContactAnalysisCharacterInterval {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.RealTimeContactAnalysisCharacterInterval()
        value.beginOffsetChar = try reader["BeginOffsetChar"].readIfPresent() ?? 0
        value.endOffsetChar = try reader["EndOffsetChar"].readIfPresent() ?? 0
        return value
    }
}

extension ConnectClientTypes.RealTimeContactAnalysisSegmentCategories {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.RealTimeContactAnalysisSegmentCategories {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.RealTimeContactAnalysisSegmentCategories()
        value.matchedDetails = try reader["MatchedDetails"].readMapIfPresent(valueReadingClosure: ConnectClientTypes.RealTimeContactAnalysisCategoryDetails.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension ConnectClientTypes.RealTimeContactAnalysisCategoryDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.RealTimeContactAnalysisCategoryDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.RealTimeContactAnalysisCategoryDetails()
        value.pointsOfInterest = try reader["PointsOfInterest"].readListIfPresent(memberReadingClosure: ConnectClientTypes.RealTimeContactAnalysisPointOfInterest.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ConnectClientTypes.RealTimeContactAnalysisPointOfInterest {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.RealTimeContactAnalysisPointOfInterest {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.RealTimeContactAnalysisPointOfInterest()
        value.transcriptItems = try reader["TranscriptItems"].readListIfPresent(memberReadingClosure: ConnectClientTypes.RealTimeContactAnalysisTranscriptItemWithCharacterOffsets.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ConnectClientTypes.RealTimeContactAnalysisTranscriptItemWithCharacterOffsets {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.RealTimeContactAnalysisTranscriptItemWithCharacterOffsets {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.RealTimeContactAnalysisTranscriptItemWithCharacterOffsets()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.characterOffsets = try reader["CharacterOffsets"].readIfPresent(with: ConnectClientTypes.RealTimeContactAnalysisCharacterInterval.read(from:))
        return value
    }
}

extension ConnectClientTypes.RealTimeContactAnalysisSegmentTranscript {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.RealTimeContactAnalysisSegmentTranscript {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.RealTimeContactAnalysisSegmentTranscript()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.participantId = try reader["ParticipantId"].readIfPresent() ?? ""
        value.participantRole = try reader["ParticipantRole"].readIfPresent() ?? .sdkUnknown("")
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.content = try reader["Content"].readIfPresent() ?? ""
        value.contentType = try reader["ContentType"].readIfPresent()
        value.time = try reader["Time"].readIfPresent(with: ConnectClientTypes.RealTimeContactAnalysisTimeData.read(from:))
        value.redaction = try reader["Redaction"].readIfPresent(with: ConnectClientTypes.RealTimeContactAnalysisTranscriptItemRedaction.read(from:))
        value.sentiment = try reader["Sentiment"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.RealTimeContactAnalysisTranscriptItemRedaction {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.RealTimeContactAnalysisTranscriptItemRedaction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.RealTimeContactAnalysisTranscriptItemRedaction()
        value.characterOffsets = try reader["CharacterOffsets"].readListIfPresent(memberReadingClosure: ConnectClientTypes.RealTimeContactAnalysisCharacterInterval.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ConnectClientTypes.RoutingProfileQueueConfigSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.RoutingProfileQueueConfigSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.RoutingProfileQueueConfigSummary()
        value.queueId = try reader["QueueId"].readIfPresent() ?? ""
        value.queueArn = try reader["QueueArn"].readIfPresent() ?? ""
        value.queueName = try reader["QueueName"].readIfPresent() ?? ""
        value.priority = try reader["Priority"].readIfPresent() ?? 0
        value.delay = try reader["Delay"].readIfPresent() ?? 0
        value.channel = try reader["Channel"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ConnectClientTypes.RoutingProfileSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.RoutingProfileSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.RoutingProfileSummary()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedRegion = try reader["LastModifiedRegion"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.RuleSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.RuleSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.RuleSummary()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.ruleId = try reader["RuleId"].readIfPresent() ?? ""
        value.ruleArn = try reader["RuleArn"].readIfPresent() ?? ""
        value.eventSourceName = try reader["EventSourceName"].readIfPresent() ?? .sdkUnknown("")
        value.publishStatus = try reader["PublishStatus"].readIfPresent() ?? .sdkUnknown("")
        value.actionSummaries = try reader["ActionSummaries"].readListIfPresent(memberReadingClosure: ConnectClientTypes.ActionSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension ConnectClientTypes.ActionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.ActionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.ActionSummary()
        value.actionType = try reader["ActionType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ConnectClientTypes.SecurityKey {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.SecurityKey {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.SecurityKey()
        value.associationId = try reader["AssociationId"].readIfPresent()
        value.key = try reader["Key"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ConnectClientTypes.Application {

    static func write(value: ConnectClientTypes.Application?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationPermissions"].writeList(value.applicationPermissions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Namespace"].write(value.namespace)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.Application {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.Application()
        value.namespace = try reader["Namespace"].readIfPresent()
        value.applicationPermissions = try reader["ApplicationPermissions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ConnectClientTypes.SecurityProfileSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.SecurityProfileSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.SecurityProfileSummary()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedRegion = try reader["LastModifiedRegion"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.TaskTemplateMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.TaskTemplateMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.TaskTemplateMetadata()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ConnectClientTypes.TrafficDistributionGroupSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.TrafficDistributionGroupSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.TrafficDistributionGroupSummary()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.instanceArn = try reader["InstanceArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.isDefault = try reader["IsDefault"].readIfPresent() ?? false
        return value
    }
}

extension ConnectClientTypes.TrafficDistributionGroupUserSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.TrafficDistributionGroupUserSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.TrafficDistributionGroupUserSummary()
        value.userId = try reader["UserId"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.UseCase {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.UseCase {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.UseCase()
        value.useCaseId = try reader["UseCaseId"].readIfPresent()
        value.useCaseArn = try reader["UseCaseArn"].readIfPresent()
        value.useCaseType = try reader["UseCaseType"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.UserProficiency {

    static func write(value: ConnectClientTypes.UserProficiency?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributeName"].write(value.attributeName)
        try writer["AttributeValue"].write(value.attributeValue)
        try writer["Level"].write(value.level)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.UserProficiency {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.UserProficiency()
        value.attributeName = try reader["AttributeName"].readIfPresent() ?? ""
        value.attributeValue = try reader["AttributeValue"].readIfPresent() ?? ""
        value.level = try reader["Level"].readIfPresent() ?? 1
        return value
    }
}

extension ConnectClientTypes.UserSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.UserSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.UserSummary()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.username = try reader["Username"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedRegion = try reader["LastModifiedRegion"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.ViewSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.ViewSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.ViewSummary()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.ViewVersionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.ViewVersionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.ViewVersionSummary()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.version = try reader["Version"].readIfPresent() ?? 0
        value.versionDescription = try reader["VersionDescription"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.AvailableNumberSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.AvailableNumberSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.AvailableNumberSummary()
        value.phoneNumber = try reader["PhoneNumber"].readIfPresent()
        value.phoneNumberCountryCode = try reader["PhoneNumberCountryCode"].readIfPresent()
        value.phoneNumberType = try reader["PhoneNumberType"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.ContactSearchSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.ContactSearchSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.ContactSearchSummary()
        value.arn = try reader["Arn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.initialContactId = try reader["InitialContactId"].readIfPresent()
        value.previousContactId = try reader["PreviousContactId"].readIfPresent()
        value.initiationMethod = try reader["InitiationMethod"].readIfPresent()
        value.channel = try reader["Channel"].readIfPresent()
        value.queueInfo = try reader["QueueInfo"].readIfPresent(with: ConnectClientTypes.ContactSearchSummaryQueueInfo.read(from:))
        value.agentInfo = try reader["AgentInfo"].readIfPresent(with: ConnectClientTypes.ContactSearchSummaryAgentInfo.read(from:))
        value.initiationTimestamp = try reader["InitiationTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.disconnectTimestamp = try reader["DisconnectTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.scheduledTimestamp = try reader["ScheduledTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ConnectClientTypes.ContactSearchSummaryAgentInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.ContactSearchSummaryAgentInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.ContactSearchSummaryAgentInfo()
        value.id = try reader["Id"].readIfPresent()
        value.connectedToAgentTimestamp = try reader["ConnectedToAgentTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ConnectClientTypes.ContactSearchSummaryQueueInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.ContactSearchSummaryQueueInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.ContactSearchSummaryQueueInfo()
        value.id = try reader["Id"].readIfPresent()
        value.enqueueTimestamp = try reader["EnqueueTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ConnectClientTypes.TagSet {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.TagSet {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.TagSet()
        value.key = try reader["key"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.SecurityProfileSearchSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.SecurityProfileSearchSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.SecurityProfileSearchSummary()
        value.id = try reader["Id"].readIfPresent()
        value.organizationResourceId = try reader["OrganizationResourceId"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.securityProfileName = try reader["SecurityProfileName"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ConnectClientTypes.UserSearchSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.UserSearchSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.UserSearchSummary()
        value.arn = try reader["Arn"].readIfPresent()
        value.directoryUserId = try reader["DirectoryUserId"].readIfPresent()
        value.hierarchyGroupId = try reader["HierarchyGroupId"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.identityInfo = try reader["IdentityInfo"].readIfPresent(with: ConnectClientTypes.UserIdentityInfoLite.read(from:))
        value.phoneConfig = try reader["PhoneConfig"].readIfPresent(with: ConnectClientTypes.UserPhoneConfig.read(from:))
        value.routingProfileId = try reader["RoutingProfileId"].readIfPresent()
        value.securityProfileIds = try reader["SecurityProfileIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.username = try reader["Username"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.UserIdentityInfoLite {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.UserIdentityInfoLite {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.UserIdentityInfoLite()
        value.firstName = try reader["FirstName"].readIfPresent()
        value.lastName = try reader["LastName"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.VocabularySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.VocabularySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.VocabularySummary()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.languageCode = try reader["LanguageCode"].readIfPresent() ?? .sdkUnknown("")
        value.state = try reader["State"].readIfPresent() ?? .sdkUnknown("")
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.failureReason = try reader["FailureReason"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.UploadUrlMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.UploadUrlMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.UploadUrlMetadata()
        value.url = try reader["Url"].readIfPresent()
        value.urlExpiry = try reader["UrlExpiry"].readIfPresent()
        value.headersToInclude = try reader["HeadersToInclude"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ConnectClientTypes.ConnectionData {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.ConnectionData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.ConnectionData()
        value.attendee = try reader["Attendee"].readIfPresent(with: ConnectClientTypes.Attendee.read(from:))
        value.meeting = try reader["Meeting"].readIfPresent(with: ConnectClientTypes.Meeting.read(from:))
        return value
    }
}

extension ConnectClientTypes.Meeting {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.Meeting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.Meeting()
        value.mediaRegion = try reader["MediaRegion"].readIfPresent()
        value.mediaPlacement = try reader["MediaPlacement"].readIfPresent(with: ConnectClientTypes.MediaPlacement.read(from:))
        value.meetingFeatures = try reader["MeetingFeatures"].readIfPresent(with: ConnectClientTypes.MeetingFeaturesConfiguration.read(from:))
        value.meetingId = try reader["MeetingId"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.MeetingFeaturesConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.MeetingFeaturesConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.MeetingFeaturesConfiguration()
        value.audio = try reader["Audio"].readIfPresent(with: ConnectClientTypes.AudioFeatures.read(from:))
        return value
    }
}

extension ConnectClientTypes.AudioFeatures {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.AudioFeatures {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.AudioFeatures()
        value.echoReduction = try reader["EchoReduction"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.MediaPlacement {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.MediaPlacement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.MediaPlacement()
        value.audioHostUrl = try reader["AudioHostUrl"].readIfPresent()
        value.audioFallbackUrl = try reader["AudioFallbackUrl"].readIfPresent()
        value.signalingUrl = try reader["SignalingUrl"].readIfPresent()
        value.turnControlUrl = try reader["TurnControlUrl"].readIfPresent()
        value.eventIngestionUrl = try reader["EventIngestionUrl"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.Attendee {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.Attendee {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.Attendee()
        value.attendeeId = try reader["AttendeeId"].readIfPresent()
        value.joinToken = try reader["JoinToken"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.InvalidRequestExceptionReason {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.InvalidRequestExceptionReason {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "AttachedFileInvalidRequestExceptionReason":
                return .attachedfileinvalidrequestexceptionreason(try reader["AttachedFileInvalidRequestExceptionReason"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension ConnectClientTypes.ProblemDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.ProblemDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.ProblemDetail()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension ConnectClientTypes.PropertyValidationExceptionProperty {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectClientTypes.PropertyValidationExceptionProperty {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectClientTypes.PropertyValidationExceptionProperty()
        value.propertyPath = try reader["PropertyPath"].readIfPresent() ?? ""
        value.reason = try reader["Reason"].readIfPresent() ?? .sdkUnknown("")
        value.message = try reader["Message"].readIfPresent() ?? ""
        return value
    }
}

extension ConnectClientTypes.RoutingProfileQueueConfig {

    static func write(value: ConnectClientTypes.RoutingProfileQueueConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Delay"].write(value.delay)
        try writer["Priority"].write(value.priority)
        try writer["QueueReference"].write(value.queueReference, with: ConnectClientTypes.RoutingProfileQueueReference.write(value:to:))
    }
}

extension ConnectClientTypes.RoutingProfileQueueReference {

    static func write(value: ConnectClientTypes.RoutingProfileQueueReference?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Channel"].write(value.channel)
        try writer["QueueId"].write(value.queueId)
    }
}

extension ConnectClientTypes.ContactDataRequest {

    static func write(value: ConnectClientTypes.ContactDataRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Campaign"].write(value.campaign, with: ConnectClientTypes.Campaign.write(value:to:))
        try writer["CustomerEndpoint"].write(value.customerEndpoint, with: ConnectClientTypes.Endpoint.write(value:to:))
        try writer["QueueId"].write(value.queueId)
        try writer["RequestIdentifier"].write(value.requestIdentifier)
        try writer["SystemEndpoint"].write(value.systemEndpoint, with: ConnectClientTypes.Endpoint.write(value:to:))
    }
}

extension ConnectClientTypes.Endpoint {

    static func write(value: ConnectClientTypes.Endpoint?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Address"].write(value.address)
        try writer["Type"].write(value.type)
    }
}

extension ConnectClientTypes.ParticipantDetailsToAdd {

    static func write(value: ConnectClientTypes.ParticipantDetailsToAdd?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DisplayName"].write(value.displayName)
        try writer["ParticipantRole"].write(value.participantRole)
    }
}

extension ConnectClientTypes.ViewInputContent {

    static func write(value: ConnectClientTypes.ViewInputContent?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Actions"].writeList(value.actions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Template"].write(value.template)
    }
}

extension ConnectClientTypes.UserProficiencyDisassociate {

    static func write(value: ConnectClientTypes.UserProficiencyDisassociate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributeName"].write(value.attributeName)
        try writer["AttributeValue"].write(value.attributeValue)
    }
}

extension ConnectClientTypes.Filters {

    static func write(value: ConnectClientTypes.Filters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Channels"].writeList(value.channels, memberWritingClosure: SmithyReadWrite.WritingClosureBox<ConnectClientTypes.Channel>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Queues"].writeList(value.queues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RoutingProfiles"].writeList(value.routingProfiles, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RoutingStepExpressions"].writeList(value.routingStepExpressions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ConnectClientTypes.CurrentMetricSortCriteria {

    static func write(value: ConnectClientTypes.CurrentMetricSortCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SortByMetric"].write(value.sortByMetric)
        try writer["SortOrder"].write(value.sortOrder)
    }
}

extension ConnectClientTypes.UserDataFilters {

    static func write(value: ConnectClientTypes.UserDataFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Agents"].writeList(value.agents, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ContactFilter"].write(value.contactFilter, with: ConnectClientTypes.ContactFilter.write(value:to:))
        try writer["Queues"].writeList(value.queues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RoutingProfiles"].writeList(value.routingProfiles, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UserHierarchyGroups"].writeList(value.userHierarchyGroups, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ConnectClientTypes.ContactFilter {

    static func write(value: ConnectClientTypes.ContactFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactStates"].writeList(value.contactStates, memberWritingClosure: SmithyReadWrite.WritingClosureBox<ConnectClientTypes.ContactState>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ConnectClientTypes.IntervalDetails {

    static func write(value: ConnectClientTypes.IntervalDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IntervalPeriod"].write(value.intervalPeriod)
        try writer["TimeZone"].write(value.timeZone)
    }
}

extension ConnectClientTypes.FilterV2 {

    static func write(value: ConnectClientTypes.FilterV2?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FilterKey"].write(value.filterKey)
        try writer["FilterValues"].writeList(value.filterValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ConnectClientTypes.AgentStatusSearchFilter {

    static func write(value: ConnectClientTypes.AgentStatusSearchFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributeFilter"].write(value.attributeFilter, with: ConnectClientTypes.ControlPlaneAttributeFilter.write(value:to:))
    }
}

extension ConnectClientTypes.ControlPlaneAttributeFilter {

    static func write(value: ConnectClientTypes.ControlPlaneAttributeFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AndCondition"].write(value.andCondition, with: ConnectClientTypes.CommonAttributeAndCondition.write(value:to:))
        try writer["OrConditions"].writeList(value.orConditions, memberWritingClosure: ConnectClientTypes.CommonAttributeAndCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TagCondition"].write(value.tagCondition, with: ConnectClientTypes.TagCondition.write(value:to:))
    }
}

extension ConnectClientTypes.TagCondition {

    static func write(value: ConnectClientTypes.TagCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TagKey"].write(value.tagKey)
        try writer["TagValue"].write(value.tagValue)
    }
}

extension ConnectClientTypes.CommonAttributeAndCondition {

    static func write(value: ConnectClientTypes.CommonAttributeAndCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TagConditions"].writeList(value.tagConditions, memberWritingClosure: ConnectClientTypes.TagCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ConnectClientTypes.AgentStatusSearchCriteria {

    static func write(value: ConnectClientTypes.AgentStatusSearchCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AndConditions"].writeList(value.andConditions, memberWritingClosure: ConnectClientTypes.AgentStatusSearchCriteria.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OrConditions"].writeList(value.orConditions, memberWritingClosure: ConnectClientTypes.AgentStatusSearchCriteria.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StringCondition"].write(value.stringCondition, with: ConnectClientTypes.StringCondition.write(value:to:))
    }
}

extension ConnectClientTypes.StringCondition {

    static func write(value: ConnectClientTypes.StringCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComparisonType"].write(value.comparisonType)
        try writer["FieldName"].write(value.fieldName)
        try writer["Value"].write(value.value)
    }
}

extension ConnectClientTypes.ContactFlowModuleSearchFilter {

    static func write(value: ConnectClientTypes.ContactFlowModuleSearchFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TagFilter"].write(value.tagFilter, with: ConnectClientTypes.ControlPlaneTagFilter.write(value:to:))
    }
}

extension ConnectClientTypes.ControlPlaneTagFilter {

    static func write(value: ConnectClientTypes.ControlPlaneTagFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AndConditions"].writeList(value.andConditions, memberWritingClosure: ConnectClientTypes.TagCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OrConditions"].writeList(value.orConditions, memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: ConnectClientTypes.TagCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        try writer["TagCondition"].write(value.tagCondition, with: ConnectClientTypes.TagCondition.write(value:to:))
    }
}

extension ConnectClientTypes.ContactFlowModuleSearchCriteria {

    static func write(value: ConnectClientTypes.ContactFlowModuleSearchCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AndConditions"].writeList(value.andConditions, memberWritingClosure: ConnectClientTypes.ContactFlowModuleSearchCriteria.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OrConditions"].writeList(value.orConditions, memberWritingClosure: ConnectClientTypes.ContactFlowModuleSearchCriteria.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StringCondition"].write(value.stringCondition, with: ConnectClientTypes.StringCondition.write(value:to:))
    }
}

extension ConnectClientTypes.ContactFlowSearchFilter {

    static func write(value: ConnectClientTypes.ContactFlowSearchFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TagFilter"].write(value.tagFilter, with: ConnectClientTypes.ControlPlaneTagFilter.write(value:to:))
    }
}

extension ConnectClientTypes.ContactFlowSearchCriteria {

    static func write(value: ConnectClientTypes.ContactFlowSearchCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AndConditions"].writeList(value.andConditions, memberWritingClosure: ConnectClientTypes.ContactFlowSearchCriteria.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OrConditions"].writeList(value.orConditions, memberWritingClosure: ConnectClientTypes.ContactFlowSearchCriteria.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StateCondition"].write(value.stateCondition)
        try writer["StatusCondition"].write(value.statusCondition)
        try writer["StringCondition"].write(value.stringCondition, with: ConnectClientTypes.StringCondition.write(value:to:))
        try writer["TypeCondition"].write(value.typeCondition)
    }
}

extension ConnectClientTypes.SearchContactsTimeRange {

    static func write(value: ConnectClientTypes.SearchContactsTimeRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["StartTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Type"].write(value.type)
    }
}

extension ConnectClientTypes.SearchCriteria {

    static func write(value: ConnectClientTypes.SearchCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AgentHierarchyGroups"].write(value.agentHierarchyGroups, with: ConnectClientTypes.AgentHierarchyGroups.write(value:to:))
        try writer["AgentIds"].writeList(value.agentIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Channels"].writeList(value.channels, memberWritingClosure: SmithyReadWrite.WritingClosureBox<ConnectClientTypes.Channel>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ContactAnalysis"].write(value.contactAnalysis, with: ConnectClientTypes.ContactAnalysis.write(value:to:))
        try writer["InitiationMethods"].writeList(value.initiationMethods, memberWritingClosure: SmithyReadWrite.WritingClosureBox<ConnectClientTypes.ContactInitiationMethod>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["QueueIds"].writeList(value.queueIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SearchableContactAttributes"].write(value.searchableContactAttributes, with: ConnectClientTypes.SearchableContactAttributes.write(value:to:))
    }
}

extension ConnectClientTypes.SearchableContactAttributes {

    static func write(value: ConnectClientTypes.SearchableContactAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Criteria"].writeList(value.criteria, memberWritingClosure: ConnectClientTypes.SearchableContactAttributesCriteria.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MatchType"].write(value.matchType)
    }
}

extension ConnectClientTypes.SearchableContactAttributesCriteria {

    static func write(value: ConnectClientTypes.SearchableContactAttributesCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ConnectClientTypes.ContactAnalysis {

    static func write(value: ConnectClientTypes.ContactAnalysis?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Transcript"].write(value.transcript, with: ConnectClientTypes.Transcript.write(value:to:))
    }
}

extension ConnectClientTypes.Transcript {

    static func write(value: ConnectClientTypes.Transcript?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Criteria"].writeList(value.criteria, memberWritingClosure: ConnectClientTypes.TranscriptCriteria.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MatchType"].write(value.matchType)
    }
}

extension ConnectClientTypes.TranscriptCriteria {

    static func write(value: ConnectClientTypes.TranscriptCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MatchType"].write(value.matchType)
        try writer["ParticipantRole"].write(value.participantRole)
        try writer["SearchText"].writeList(value.searchText, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ConnectClientTypes.AgentHierarchyGroups {

    static func write(value: ConnectClientTypes.AgentHierarchyGroups?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["L1Ids"].writeList(value.l1Ids, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["L2Ids"].writeList(value.l2Ids, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["L3Ids"].writeList(value.l3Ids, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["L4Ids"].writeList(value.l4Ids, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["L5Ids"].writeList(value.l5Ids, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ConnectClientTypes.Sort {

    static func write(value: ConnectClientTypes.Sort?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FieldName"].write(value.fieldName)
        try writer["Order"].write(value.order)
    }
}

extension ConnectClientTypes.HoursOfOperationSearchFilter {

    static func write(value: ConnectClientTypes.HoursOfOperationSearchFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TagFilter"].write(value.tagFilter, with: ConnectClientTypes.ControlPlaneTagFilter.write(value:to:))
    }
}

extension ConnectClientTypes.HoursOfOperationSearchCriteria {

    static func write(value: ConnectClientTypes.HoursOfOperationSearchCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AndConditions"].writeList(value.andConditions, memberWritingClosure: ConnectClientTypes.HoursOfOperationSearchCriteria.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OrConditions"].writeList(value.orConditions, memberWritingClosure: ConnectClientTypes.HoursOfOperationSearchCriteria.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StringCondition"].write(value.stringCondition, with: ConnectClientTypes.StringCondition.write(value:to:))
    }
}

extension ConnectClientTypes.PredefinedAttributeSearchCriteria {

    static func write(value: ConnectClientTypes.PredefinedAttributeSearchCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AndConditions"].writeList(value.andConditions, memberWritingClosure: ConnectClientTypes.PredefinedAttributeSearchCriteria.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OrConditions"].writeList(value.orConditions, memberWritingClosure: ConnectClientTypes.PredefinedAttributeSearchCriteria.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StringCondition"].write(value.stringCondition, with: ConnectClientTypes.StringCondition.write(value:to:))
    }
}

extension ConnectClientTypes.PromptSearchFilter {

    static func write(value: ConnectClientTypes.PromptSearchFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TagFilter"].write(value.tagFilter, with: ConnectClientTypes.ControlPlaneTagFilter.write(value:to:))
    }
}

extension ConnectClientTypes.PromptSearchCriteria {

    static func write(value: ConnectClientTypes.PromptSearchCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AndConditions"].writeList(value.andConditions, memberWritingClosure: ConnectClientTypes.PromptSearchCriteria.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OrConditions"].writeList(value.orConditions, memberWritingClosure: ConnectClientTypes.PromptSearchCriteria.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StringCondition"].write(value.stringCondition, with: ConnectClientTypes.StringCondition.write(value:to:))
    }
}

extension ConnectClientTypes.QueueSearchFilter {

    static func write(value: ConnectClientTypes.QueueSearchFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TagFilter"].write(value.tagFilter, with: ConnectClientTypes.ControlPlaneTagFilter.write(value:to:))
    }
}

extension ConnectClientTypes.QueueSearchCriteria {

    static func write(value: ConnectClientTypes.QueueSearchCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AndConditions"].writeList(value.andConditions, memberWritingClosure: ConnectClientTypes.QueueSearchCriteria.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OrConditions"].writeList(value.orConditions, memberWritingClosure: ConnectClientTypes.QueueSearchCriteria.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["QueueTypeCondition"].write(value.queueTypeCondition)
        try writer["StringCondition"].write(value.stringCondition, with: ConnectClientTypes.StringCondition.write(value:to:))
    }
}

extension ConnectClientTypes.QuickConnectSearchFilter {

    static func write(value: ConnectClientTypes.QuickConnectSearchFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TagFilter"].write(value.tagFilter, with: ConnectClientTypes.ControlPlaneTagFilter.write(value:to:))
    }
}

extension ConnectClientTypes.QuickConnectSearchCriteria {

    static func write(value: ConnectClientTypes.QuickConnectSearchCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AndConditions"].writeList(value.andConditions, memberWritingClosure: ConnectClientTypes.QuickConnectSearchCriteria.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OrConditions"].writeList(value.orConditions, memberWritingClosure: ConnectClientTypes.QuickConnectSearchCriteria.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StringCondition"].write(value.stringCondition, with: ConnectClientTypes.StringCondition.write(value:to:))
    }
}

extension ConnectClientTypes.ResourceTagsSearchCriteria {

    static func write(value: ConnectClientTypes.ResourceTagsSearchCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TagSearchCondition"].write(value.tagSearchCondition, with: ConnectClientTypes.TagSearchCondition.write(value:to:))
    }
}

extension ConnectClientTypes.TagSearchCondition {

    static func write(value: ConnectClientTypes.TagSearchCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tagKey"].write(value.tagKey)
        try writer["tagKeyComparisonType"].write(value.tagKeyComparisonType)
        try writer["tagValue"].write(value.tagValue)
        try writer["tagValueComparisonType"].write(value.tagValueComparisonType)
    }
}

extension ConnectClientTypes.RoutingProfileSearchFilter {

    static func write(value: ConnectClientTypes.RoutingProfileSearchFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TagFilter"].write(value.tagFilter, with: ConnectClientTypes.ControlPlaneTagFilter.write(value:to:))
    }
}

extension ConnectClientTypes.RoutingProfileSearchCriteria {

    static func write(value: ConnectClientTypes.RoutingProfileSearchCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AndConditions"].writeList(value.andConditions, memberWritingClosure: ConnectClientTypes.RoutingProfileSearchCriteria.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OrConditions"].writeList(value.orConditions, memberWritingClosure: ConnectClientTypes.RoutingProfileSearchCriteria.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StringCondition"].write(value.stringCondition, with: ConnectClientTypes.StringCondition.write(value:to:))
    }
}

extension ConnectClientTypes.SecurityProfileSearchCriteria {

    static func write(value: ConnectClientTypes.SecurityProfileSearchCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AndConditions"].writeList(value.andConditions, memberWritingClosure: ConnectClientTypes.SecurityProfileSearchCriteria.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OrConditions"].writeList(value.orConditions, memberWritingClosure: ConnectClientTypes.SecurityProfileSearchCriteria.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StringCondition"].write(value.stringCondition, with: ConnectClientTypes.StringCondition.write(value:to:))
    }
}

extension ConnectClientTypes.SecurityProfilesSearchFilter {

    static func write(value: ConnectClientTypes.SecurityProfilesSearchFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TagFilter"].write(value.tagFilter, with: ConnectClientTypes.ControlPlaneTagFilter.write(value:to:))
    }
}

extension ConnectClientTypes.UserHierarchyGroupSearchFilter {

    static func write(value: ConnectClientTypes.UserHierarchyGroupSearchFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributeFilter"].write(value.attributeFilter, with: ConnectClientTypes.ControlPlaneAttributeFilter.write(value:to:))
    }
}

extension ConnectClientTypes.UserHierarchyGroupSearchCriteria {

    static func write(value: ConnectClientTypes.UserHierarchyGroupSearchCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AndConditions"].writeList(value.andConditions, memberWritingClosure: ConnectClientTypes.UserHierarchyGroupSearchCriteria.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OrConditions"].writeList(value.orConditions, memberWritingClosure: ConnectClientTypes.UserHierarchyGroupSearchCriteria.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StringCondition"].write(value.stringCondition, with: ConnectClientTypes.StringCondition.write(value:to:))
    }
}

extension ConnectClientTypes.UserSearchFilter {

    static func write(value: ConnectClientTypes.UserSearchFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TagFilter"].write(value.tagFilter, with: ConnectClientTypes.ControlPlaneTagFilter.write(value:to:))
        try writer["UserAttributeFilter"].write(value.userAttributeFilter, with: ConnectClientTypes.ControlPlaneUserAttributeFilter.write(value:to:))
    }
}

extension ConnectClientTypes.ControlPlaneUserAttributeFilter {

    static func write(value: ConnectClientTypes.ControlPlaneUserAttributeFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AndCondition"].write(value.andCondition, with: ConnectClientTypes.AttributeAndCondition.write(value:to:))
        try writer["HierarchyGroupCondition"].write(value.hierarchyGroupCondition, with: ConnectClientTypes.HierarchyGroupCondition.write(value:to:))
        try writer["OrConditions"].writeList(value.orConditions, memberWritingClosure: ConnectClientTypes.AttributeAndCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TagCondition"].write(value.tagCondition, with: ConnectClientTypes.TagCondition.write(value:to:))
    }
}

extension ConnectClientTypes.HierarchyGroupCondition {

    static func write(value: ConnectClientTypes.HierarchyGroupCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HierarchyGroupMatchType"].write(value.hierarchyGroupMatchType)
        try writer["Value"].write(value.value)
    }
}

extension ConnectClientTypes.AttributeAndCondition {

    static func write(value: ConnectClientTypes.AttributeAndCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HierarchyGroupCondition"].write(value.hierarchyGroupCondition, with: ConnectClientTypes.HierarchyGroupCondition.write(value:to:))
        try writer["TagConditions"].writeList(value.tagConditions, memberWritingClosure: ConnectClientTypes.TagCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ConnectClientTypes.UserSearchCriteria {

    static func write(value: ConnectClientTypes.UserSearchCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AndConditions"].writeList(value.andConditions, memberWritingClosure: ConnectClientTypes.UserSearchCriteria.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["HierarchyGroupCondition"].write(value.hierarchyGroupCondition, with: ConnectClientTypes.HierarchyGroupCondition.write(value:to:))
        try writer["ListCondition"].write(value.listCondition, with: ConnectClientTypes.ListCondition.write(value:to:))
        try writer["OrConditions"].writeList(value.orConditions, memberWritingClosure: ConnectClientTypes.UserSearchCriteria.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StringCondition"].write(value.stringCondition, with: ConnectClientTypes.StringCondition.write(value:to:))
    }
}

extension ConnectClientTypes.ListCondition {

    static func write(value: ConnectClientTypes.ListCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Conditions"].writeList(value.conditions, memberWritingClosure: ConnectClientTypes.Condition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TargetListType"].write(value.targetListType)
    }
}

extension ConnectClientTypes.Condition {

    static func write(value: ConnectClientTypes.Condition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NumberCondition"].write(value.numberCondition, with: ConnectClientTypes.NumberCondition.write(value:to:))
        try writer["StringCondition"].write(value.stringCondition, with: ConnectClientTypes.StringCondition.write(value:to:))
    }
}

extension ConnectClientTypes.NumberCondition {

    static func write(value: ConnectClientTypes.NumberCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComparisonType"].write(value.comparisonType)
        try writer["FieldName"].write(value.fieldName)
        try writer["MaxValue"].write(value.maxValue)
        try writer["MinValue"].write(value.minValue)
    }
}

extension ConnectClientTypes.ChatEvent {

    static func write(value: ConnectClientTypes.ChatEvent?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Content"].write(value.content)
        try writer["ContentType"].write(value.contentType)
        try writer["Type"].write(value.type)
    }
}

extension ConnectClientTypes.NewSessionDetails {

    static func write(value: ConnectClientTypes.NewSessionDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ParticipantDetails"].write(value.participantDetails, with: ConnectClientTypes.ParticipantDetails.write(value:to:))
        try writer["StreamingConfiguration"].write(value.streamingConfiguration, with: ConnectClientTypes.ChatStreamingConfiguration.write(value:to:))
        try writer["SupportedMessagingContentTypes"].writeList(value.supportedMessagingContentTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ConnectClientTypes.ChatStreamingConfiguration {

    static func write(value: ConnectClientTypes.ChatStreamingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StreamingEndpointArn"].write(value.streamingEndpointArn)
    }
}

extension ConnectClientTypes.ParticipantDetails {

    static func write(value: ConnectClientTypes.ParticipantDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DisplayName"].write(value.displayName)
    }
}

extension ConnectClientTypes.ChatMessage {

    static func write(value: ConnectClientTypes.ChatMessage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Content"].write(value.content)
        try writer["ContentType"].write(value.contentType)
    }
}

extension ConnectClientTypes.PersistentChat {

    static func write(value: ConnectClientTypes.PersistentChat?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RehydrationType"].write(value.rehydrationType)
        try writer["SourceContactId"].write(value.sourceContactId)
    }
}

extension ConnectClientTypes.VoiceRecordingConfiguration {

    static func write(value: ConnectClientTypes.VoiceRecordingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["VoiceRecordingTrack"].write(value.voiceRecordingTrack)
    }
}

extension ConnectClientTypes.AnswerMachineDetectionConfig {

    static func write(value: ConnectClientTypes.AnswerMachineDetectionConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AwaitAnswerMachinePrompt"].write(value.awaitAnswerMachinePrompt)
        try writer["EnableAnswerMachineDetection"].write(value.enableAnswerMachineDetection)
    }
}

extension ConnectClientTypes.AllowedCapabilities {

    static func write(value: ConnectClientTypes.AllowedCapabilities?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Agent"].write(value.agent, with: ConnectClientTypes.ParticipantCapabilities.write(value:to:))
        try writer["Customer"].write(value.customer, with: ConnectClientTypes.ParticipantCapabilities.write(value:to:))
    }
}

extension ConnectClientTypes.DisconnectReason {

    static func write(value: ConnectClientTypes.DisconnectReason?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Code"].write(value.code)
    }
}

extension ConnectClientTypes.EvaluationAnswerInput {

    static func write(value: ConnectClientTypes.EvaluationAnswerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Value"].write(value.value, with: ConnectClientTypes.EvaluationAnswerData.write(value:to:))
    }
}

extension ConnectClientTypes.RoutingCriteriaInput {

    static func write(value: ConnectClientTypes.RoutingCriteriaInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Steps"].writeList(value.steps, memberWritingClosure: ConnectClientTypes.RoutingCriteriaInputStep.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ConnectClientTypes.RoutingCriteriaInputStep {

    static func write(value: ConnectClientTypes.RoutingCriteriaInputStep?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Expiry"].write(value.expiry, with: ConnectClientTypes.RoutingCriteriaInputStepExpiry.write(value:to:))
        try writer["Expression"].write(value.expression, with: ConnectClientTypes.Expression.write(value:to:))
    }
}

extension ConnectClientTypes.RoutingCriteriaInputStepExpiry {

    static func write(value: ConnectClientTypes.RoutingCriteriaInputStepExpiry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DurationInSeconds"].write(value.durationInSeconds)
    }
}

extension ConnectClientTypes.UpdateParticipantRoleConfigChannelInfo {

    static func write(value: ConnectClientTypes.UpdateParticipantRoleConfigChannelInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .chat(chat):
                try writer["Chat"].write(chat, with: ConnectClientTypes.ChatParticipantRoleConfig.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension ConnectClientTypes.ChatParticipantRoleConfig {

    static func write(value: ConnectClientTypes.ChatParticipantRoleConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ParticipantTimerConfigList"].writeList(value.participantTimerConfigList, memberWritingClosure: ConnectClientTypes.ParticipantTimerConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ConnectClientTypes.ParticipantTimerConfiguration {

    static func write(value: ConnectClientTypes.ParticipantTimerConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ParticipantRole"].write(value.participantRole)
        try writer["TimerType"].write(value.timerType)
        try writer["TimerValue"].write(value.timerValue, with: ConnectClientTypes.ParticipantTimerValue.write(value:to:))
    }
}

extension ConnectClientTypes.ParticipantTimerValue {

    static func write(value: ConnectClientTypes.ParticipantTimerValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .participanttimeraction(participanttimeraction):
                try writer["ParticipantTimerAction"].write(participanttimeraction)
            case let .participanttimerdurationinminutes(participanttimerdurationinminutes):
                try writer["ParticipantTimerDurationInMinutes"].write(participanttimerdurationinminutes)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension ConnectClientTypes.HierarchyStructureUpdate {

    static func write(value: ConnectClientTypes.HierarchyStructureUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LevelFive"].write(value.levelFive, with: ConnectClientTypes.HierarchyLevelUpdate.write(value:to:))
        try writer["LevelFour"].write(value.levelFour, with: ConnectClientTypes.HierarchyLevelUpdate.write(value:to:))
        try writer["LevelOne"].write(value.levelOne, with: ConnectClientTypes.HierarchyLevelUpdate.write(value:to:))
        try writer["LevelThree"].write(value.levelThree, with: ConnectClientTypes.HierarchyLevelUpdate.write(value:to:))
        try writer["LevelTwo"].write(value.levelTwo, with: ConnectClientTypes.HierarchyLevelUpdate.write(value:to:))
    }
}

extension ConnectClientTypes.HierarchyLevelUpdate {

    static func write(value: ConnectClientTypes.HierarchyLevelUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

public enum ConnectClientTypes {}
