// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient permissions to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectClientTypes.ActionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionType = "ActionType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionType = self.actionType {
            try encodeContainer.encode(actionType.rawValue, forKey: .actionType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ActionType.self, forKey: .actionType)
        actionType = actionTypeDecoded
    }
}

extension ConnectClientTypes {
    /// Information about an action.
    public struct ActionSummary: Swift.Equatable {
        /// The action type.
        /// This member is required.
        public var actionType: ConnectClientTypes.ActionType?

        public init(
            actionType: ConnectClientTypes.ActionType? = nil
        )
        {
            self.actionType = actionType
        }
    }

}

extension ConnectClientTypes {
    public enum ActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case assignContactCategory
        case createCase
        case createTask
        case endAssociatedTasks
        case generateEventbridgeEvent
        case sendNotification
        case updateCase
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionType] {
            return [
                .assignContactCategory,
                .createCase,
                .createTask,
                .endAssociatedTasks,
                .generateEventbridgeEvent,
                .sendNotification,
                .updateCase,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .assignContactCategory: return "ASSIGN_CONTACT_CATEGORY"
            case .createCase: return "CREATE_CASE"
            case .createTask: return "CREATE_TASK"
            case .endAssociatedTasks: return "END_ASSOCIATED_TASKS"
            case .generateEventbridgeEvent: return "GENERATE_EVENTBRIDGE_EVENT"
            case .sendNotification: return "SEND_NOTIFICATION"
            case .updateCase: return "UPDATE_CASE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActionType(rawValue: rawValue) ?? ActionType.sdkUnknown(rawValue)
        }
    }
}

extension ActivateEvaluationFormInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationFormVersion = "EvaluationFormVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evaluationFormVersion = self.evaluationFormVersion {
            try encodeContainer.encode(evaluationFormVersion, forKey: .evaluationFormVersion)
        }
    }
}

extension ActivateEvaluationFormInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let evaluationFormId = evaluationFormId else {
            return nil
        }
        return "/evaluation-forms/\(instanceId.urlPercentEncoding())/\(evaluationFormId.urlPercentEncoding())/activate"
    }
}

public struct ActivateEvaluationFormInput: Swift.Equatable {
    /// The unique identifier for the evaluation form.
    /// This member is required.
    public var evaluationFormId: Swift.String?
    /// The version of the evaluation form to activate. If the version property is not provided, the latest version of the evaluation form is activated.
    /// This member is required.
    public var evaluationFormVersion: Swift.Int?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        evaluationFormId: Swift.String? = nil,
        evaluationFormVersion: Swift.Int? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.evaluationFormId = evaluationFormId
        self.evaluationFormVersion = evaluationFormVersion
        self.instanceId = instanceId
    }
}

struct ActivateEvaluationFormInputBody: Swift.Equatable {
    let evaluationFormVersion: Swift.Int?
}

extension ActivateEvaluationFormInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationFormVersion = "EvaluationFormVersion"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationFormVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .evaluationFormVersion)
        evaluationFormVersion = evaluationFormVersionDecoded
    }
}

extension ActivateEvaluationFormOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ActivateEvaluationFormOutputBody = try responseDecoder.decode(responseBody: data)
            self.evaluationFormArn = output.evaluationFormArn
            self.evaluationFormId = output.evaluationFormId
            self.evaluationFormVersion = output.evaluationFormVersion
        } else {
            self.evaluationFormArn = nil
            self.evaluationFormId = nil
            self.evaluationFormVersion = 0
        }
    }
}

public struct ActivateEvaluationFormOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the evaluation form resource.
    /// This member is required.
    public var evaluationFormArn: Swift.String?
    /// The unique identifier for the evaluation form.
    /// This member is required.
    public var evaluationFormId: Swift.String?
    /// A version of the evaluation form.
    /// This member is required.
    public var evaluationFormVersion: Swift.Int

    public init(
        evaluationFormArn: Swift.String? = nil,
        evaluationFormId: Swift.String? = nil,
        evaluationFormVersion: Swift.Int = 0
    )
    {
        self.evaluationFormArn = evaluationFormArn
        self.evaluationFormId = evaluationFormId
        self.evaluationFormVersion = evaluationFormVersion
    }
}

struct ActivateEvaluationFormOutputBody: Swift.Equatable {
    let evaluationFormId: Swift.String?
    let evaluationFormArn: Swift.String?
    let evaluationFormVersion: Swift.Int
}

extension ActivateEvaluationFormOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationFormArn = "EvaluationFormArn"
        case evaluationFormId = "EvaluationFormId"
        case evaluationFormVersion = "EvaluationFormVersion"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationFormIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationFormId)
        evaluationFormId = evaluationFormIdDecoded
        let evaluationFormArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationFormArn)
        evaluationFormArn = evaluationFormArnDecoded
        let evaluationFormVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .evaluationFormVersion) ?? 0
        evaluationFormVersion = evaluationFormVersionDecoded
    }
}

enum ActivateEvaluationFormOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectClientTypes {
    public enum AgentAvailabilityTimer: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case timeSinceLastActivity
        case timeSinceLastInbound
        case sdkUnknown(Swift.String)

        public static var allCases: [AgentAvailabilityTimer] {
            return [
                .timeSinceLastActivity,
                .timeSinceLastInbound,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .timeSinceLastActivity: return "TIME_SINCE_LAST_ACTIVITY"
            case .timeSinceLastInbound: return "TIME_SINCE_LAST_INBOUND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AgentAvailabilityTimer(rawValue: rawValue) ?? AgentAvailabilityTimer.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.AgentConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributions = "Distributions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let distributions = distributions {
            var distributionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .distributions)
            for distribution0 in distributions {
                try distributionsContainer.encode(distribution0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.Distribution?].self, forKey: .distributions)
        var distributionsDecoded0:[ConnectClientTypes.Distribution]? = nil
        if let distributionsContainer = distributionsContainer {
            distributionsDecoded0 = [ConnectClientTypes.Distribution]()
            for structure0 in distributionsContainer {
                if let structure0 = structure0 {
                    distributionsDecoded0?.append(structure0)
                }
            }
        }
        distributions = distributionsDecoded0
    }
}

extension ConnectClientTypes {
    /// The distribution of agents between the instance and its replica(s).
    public struct AgentConfig: Swift.Equatable {
        /// Information about traffic distributions.
        /// This member is required.
        public var distributions: [ConnectClientTypes.Distribution]?

        public init(
            distributions: [ConnectClientTypes.Distribution]? = nil
        )
        {
            self.distributions = distributions
        }
    }

}

extension ConnectClientTypes.AgentContactReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentContactState = "AgentContactState"
        case channel = "Channel"
        case connectedToAgentTimestamp = "ConnectedToAgentTimestamp"
        case contactId = "ContactId"
        case initiationMethod = "InitiationMethod"
        case queue = "Queue"
        case stateStartTimestamp = "StateStartTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentContactState = self.agentContactState {
            try encodeContainer.encode(agentContactState.rawValue, forKey: .agentContactState)
        }
        if let channel = self.channel {
            try encodeContainer.encode(channel.rawValue, forKey: .channel)
        }
        if let connectedToAgentTimestamp = self.connectedToAgentTimestamp {
            try encodeContainer.encodeTimestamp(connectedToAgentTimestamp, format: .epochSeconds, forKey: .connectedToAgentTimestamp)
        }
        if let contactId = self.contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let initiationMethod = self.initiationMethod {
            try encodeContainer.encode(initiationMethod.rawValue, forKey: .initiationMethod)
        }
        if let queue = self.queue {
            try encodeContainer.encode(queue, forKey: .queue)
        }
        if let stateStartTimestamp = self.stateStartTimestamp {
            try encodeContainer.encodeTimestamp(stateStartTimestamp, format: .epochSeconds, forKey: .stateStartTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let channelDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Channel.self, forKey: .channel)
        channel = channelDecoded
        let initiationMethodDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ContactInitiationMethod.self, forKey: .initiationMethod)
        initiationMethod = initiationMethodDecoded
        let agentContactStateDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ContactState.self, forKey: .agentContactState)
        agentContactState = agentContactStateDecoded
        let stateStartTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .stateStartTimestamp)
        stateStartTimestamp = stateStartTimestampDecoded
        let connectedToAgentTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .connectedToAgentTimestamp)
        connectedToAgentTimestamp = connectedToAgentTimestampDecoded
        let queueDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.QueueReference.self, forKey: .queue)
        queue = queueDecoded
    }
}

extension ConnectClientTypes {
    /// Information about the [contact](https://docs.aws.amazon.com/connect/latest/APIReference/API_Contact.html) associated to the user.
    public struct AgentContactReference: Swift.Equatable {
        /// The [state of the contact](https://docs.aws.amazon.com/connect/latest/adminguide/about-contact-states.html).
        public var agentContactState: ConnectClientTypes.ContactState?
        /// The channel of the contact.
        public var channel: ConnectClientTypes.Channel?
        /// The time at which the contact was connected to an agent.
        public var connectedToAgentTimestamp: ClientRuntime.Date?
        /// The identifier of the contact in this instance of Amazon Connect.
        public var contactId: Swift.String?
        /// How the contact was initiated.
        public var initiationMethod: ConnectClientTypes.ContactInitiationMethod?
        /// Contains information about a queue resource for which metrics are returned.
        public var queue: ConnectClientTypes.QueueReference?
        /// The epoch timestamp when the contact state started.
        public var stateStartTimestamp: ClientRuntime.Date?

        public init(
            agentContactState: ConnectClientTypes.ContactState? = nil,
            channel: ConnectClientTypes.Channel? = nil,
            connectedToAgentTimestamp: ClientRuntime.Date? = nil,
            contactId: Swift.String? = nil,
            initiationMethod: ConnectClientTypes.ContactInitiationMethod? = nil,
            queue: ConnectClientTypes.QueueReference? = nil,
            stateStartTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.agentContactState = agentContactState
            self.channel = channel
            self.connectedToAgentTimestamp = connectedToAgentTimestamp
            self.contactId = contactId
            self.initiationMethod = initiationMethod
            self.queue = queue
            self.stateStartTimestamp = stateStartTimestamp
        }
    }

}

extension ConnectClientTypes.AgentInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentPauseDurationInSeconds = "AgentPauseDurationInSeconds"
        case connectedToAgentTimestamp = "ConnectedToAgentTimestamp"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentPauseDurationInSeconds = self.agentPauseDurationInSeconds {
            try encodeContainer.encode(agentPauseDurationInSeconds, forKey: .agentPauseDurationInSeconds)
        }
        if let connectedToAgentTimestamp = self.connectedToAgentTimestamp {
            try encodeContainer.encodeTimestamp(connectedToAgentTimestamp, format: .epochSeconds, forKey: .connectedToAgentTimestamp)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let connectedToAgentTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .connectedToAgentTimestamp)
        connectedToAgentTimestamp = connectedToAgentTimestampDecoded
        let agentPauseDurationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .agentPauseDurationInSeconds)
        agentPauseDurationInSeconds = agentPauseDurationInSecondsDecoded
    }
}

extension ConnectClientTypes {
    /// Information about the agent who accepted the contact.
    public struct AgentInfo: Swift.Equatable {
        /// Agent pause duration for a contact in seconds.
        public var agentPauseDurationInSeconds: Swift.Int?
        /// The timestamp when the contact was connected to the agent.
        public var connectedToAgentTimestamp: ClientRuntime.Date?
        /// The identifier of the agent who accepted the contact.
        public var id: Swift.String?

        public init(
            agentPauseDurationInSeconds: Swift.Int? = nil,
            connectedToAgentTimestamp: ClientRuntime.Date? = nil,
            id: Swift.String? = nil
        )
        {
            self.agentPauseDurationInSeconds = agentPauseDurationInSeconds
            self.connectedToAgentTimestamp = connectedToAgentTimestamp
            self.id = id
        }
    }

}

extension ConnectClientTypes.AgentStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentStatusARN = "AgentStatusARN"
        case agentStatusId = "AgentStatusId"
        case description = "Description"
        case displayOrder = "DisplayOrder"
        case lastModifiedRegion = "LastModifiedRegion"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case state = "State"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentStatusARN = self.agentStatusARN {
            try encodeContainer.encode(agentStatusARN, forKey: .agentStatusARN)
        }
        if let agentStatusId = self.agentStatusId {
            try encodeContainer.encode(agentStatusId, forKey: .agentStatusId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayOrder = self.displayOrder {
            try encodeContainer.encode(displayOrder, forKey: .displayOrder)
        }
        if let lastModifiedRegion = self.lastModifiedRegion {
            try encodeContainer.encode(lastModifiedRegion, forKey: .lastModifiedRegion)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentStatusARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentStatusARN)
        agentStatusARN = agentStatusARNDecoded
        let agentStatusIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentStatusId)
        agentStatusId = agentStatusIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.AgentStatusType.self, forKey: .type)
        type = typeDecoded
        let displayOrderDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .displayOrder)
        displayOrder = displayOrderDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.AgentStatusState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastModifiedRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedRegion)
        lastModifiedRegion = lastModifiedRegionDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about an agent status.
    public struct AgentStatus: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the agent status.
        public var agentStatusARN: Swift.String?
        /// The identifier of the agent status.
        public var agentStatusId: Swift.String?
        /// The description of the agent status.
        public var description: Swift.String?
        /// The display order of the agent status.
        public var displayOrder: Swift.Int?
        /// The Amazon Web Services Region where this resource was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when this resource was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name of the agent status.
        public var name: Swift.String?
        /// The state of the agent status.
        public var state: ConnectClientTypes.AgentStatusState?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public var tags: [Swift.String:Swift.String]?
        /// The type of agent status.
        public var type: ConnectClientTypes.AgentStatusType?

        public init(
            agentStatusARN: Swift.String? = nil,
            agentStatusId: Swift.String? = nil,
            description: Swift.String? = nil,
            displayOrder: Swift.Int? = nil,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            state: ConnectClientTypes.AgentStatusState? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: ConnectClientTypes.AgentStatusType? = nil
        )
        {
            self.agentStatusARN = agentStatusARN
            self.agentStatusId = agentStatusId
            self.description = description
            self.displayOrder = displayOrder
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.state = state
            self.tags = tags
            self.type = type
        }
    }

}

extension ConnectClientTypes.AgentStatusReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statusArn = "StatusArn"
        case statusName = "StatusName"
        case statusStartTimestamp = "StatusStartTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statusArn = self.statusArn {
            try encodeContainer.encode(statusArn, forKey: .statusArn)
        }
        if let statusName = self.statusName {
            try encodeContainer.encode(statusName, forKey: .statusName)
        }
        if let statusStartTimestamp = self.statusStartTimestamp {
            try encodeContainer.encodeTimestamp(statusStartTimestamp, format: .epochSeconds, forKey: .statusStartTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusStartTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .statusStartTimestamp)
        statusStartTimestamp = statusStartTimestampDecoded
        let statusArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusArn)
        statusArn = statusArnDecoded
        let statusNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusName)
        statusName = statusNameDecoded
    }
}

extension ConnectClientTypes {
    /// Information about the agent's status.
    public struct AgentStatusReference: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the agent's status.
        public var statusArn: Swift.String?
        /// The name of the agent status.
        public var statusName: Swift.String?
        /// The start timestamp of the agent's status.
        public var statusStartTimestamp: ClientRuntime.Date?

        public init(
            statusArn: Swift.String? = nil,
            statusName: Swift.String? = nil,
            statusStartTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.statusArn = statusArn
            self.statusName = statusName
            self.statusStartTimestamp = statusStartTimestamp
        }
    }

}

extension ConnectClientTypes {
    public enum AgentStatusState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AgentStatusState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AgentStatusState(rawValue: rawValue) ?? AgentStatusState.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.AgentStatusSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case lastModifiedRegion = "LastModifiedRegion"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastModifiedRegion = self.lastModifiedRegion {
            try encodeContainer.encode(lastModifiedRegion, forKey: .lastModifiedRegion)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.AgentStatusType.self, forKey: .type)
        type = typeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastModifiedRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedRegion)
        lastModifiedRegion = lastModifiedRegionDecoded
    }
}

extension ConnectClientTypes {
    /// Summary information for an agent status.
    public struct AgentStatusSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the agent status.
        public var arn: Swift.String?
        /// The identifier for an agent status.
        public var id: Swift.String?
        /// The Amazon Web Services Region where this resource was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when this resource was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name of the agent status.
        public var name: Swift.String?
        /// The type of the agent status.
        public var type: ConnectClientTypes.AgentStatusType?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            type: ConnectClientTypes.AgentStatusType? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.type = type
        }
    }

}

extension ConnectClientTypes {
    public enum AgentStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case offline
        case routable
        case sdkUnknown(Swift.String)

        public static var allCases: [AgentStatusType] {
            return [
                .custom,
                .offline,
                .routable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "CUSTOM"
            case .offline: return "OFFLINE"
            case .routable: return "ROUTABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AgentStatusType(rawValue: rawValue) ?? AgentStatusType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.AllowedCapabilities: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agent = "Agent"
        case customer = "Customer"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agent = self.agent {
            try encodeContainer.encode(agent, forKey: .agent)
        }
        if let customer = self.customer {
            try encodeContainer.encode(customer, forKey: .customer)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ParticipantCapabilities.self, forKey: .customer)
        customer = customerDecoded
        let agentDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ParticipantCapabilities.self, forKey: .agent)
        agent = agentDecoded
    }
}

extension ConnectClientTypes {
    /// Information about the capabilities enabled for participants of the contact.
    public struct AllowedCapabilities: Swift.Equatable {
        /// Information about the agent's video sharing capabilities.
        public var agent: ConnectClientTypes.ParticipantCapabilities?
        /// Information about the customer's video sharing capabilities.
        public var customer: ConnectClientTypes.ParticipantCapabilities?

        public init(
            agent: ConnectClientTypes.ParticipantCapabilities? = nil,
            customer: ConnectClientTypes.ParticipantCapabilities? = nil
        )
        {
            self.agent = agent
            self.customer = customer
        }
    }

}

extension ConnectClientTypes.AnalyticsDataAssociationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSetId = "DataSetId"
        case resourceShareArn = "ResourceShareArn"
        case resourceShareId = "ResourceShareId"
        case targetAccountId = "TargetAccountId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSetId = self.dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let resourceShareArn = self.resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
        if let resourceShareId = self.resourceShareId {
            try encodeContainer.encode(resourceShareId, forKey: .resourceShareId)
        }
        if let targetAccountId = self.targetAccountId {
            try encodeContainer.encode(targetAccountId, forKey: .targetAccountId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let targetAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetAccountId)
        targetAccountId = targetAccountIdDecoded
        let resourceShareIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareId)
        resourceShareId = resourceShareIdDecoded
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
    }
}

extension ConnectClientTypes {
    /// This API is in preview release for Amazon Connect and is subject to change. Information about associations that are successfully created: DataSetId, TargetAccountId, ResourceShareId, ResourceShareArn.
    public struct AnalyticsDataAssociationResult: Swift.Equatable {
        /// The identifier of the dataset.
        public var dataSetId: Swift.String?
        /// The Amazon Resource Name (ARN) of the Resource Access Manager share.
        public var resourceShareArn: Swift.String?
        /// The Resource Access Manager share ID.
        public var resourceShareId: Swift.String?
        /// The identifier of the target account.
        public var targetAccountId: Swift.String?

        public init(
            dataSetId: Swift.String? = nil,
            resourceShareArn: Swift.String? = nil,
            resourceShareId: Swift.String? = nil,
            targetAccountId: Swift.String? = nil
        )
        {
            self.dataSetId = dataSetId
            self.resourceShareArn = resourceShareArn
            self.resourceShareId = resourceShareId
            self.targetAccountId = targetAccountId
        }
    }

}

extension ConnectClientTypes.AnswerMachineDetectionConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awaitAnswerMachinePrompt = "AwaitAnswerMachinePrompt"
        case enableAnswerMachineDetection = "EnableAnswerMachineDetection"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if awaitAnswerMachinePrompt != false {
            try encodeContainer.encode(awaitAnswerMachinePrompt, forKey: .awaitAnswerMachinePrompt)
        }
        if enableAnswerMachineDetection != false {
            try encodeContainer.encode(enableAnswerMachineDetection, forKey: .enableAnswerMachineDetection)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableAnswerMachineDetectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableAnswerMachineDetection) ?? false
        enableAnswerMachineDetection = enableAnswerMachineDetectionDecoded
        let awaitAnswerMachinePromptDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .awaitAnswerMachinePrompt) ?? false
        awaitAnswerMachinePrompt = awaitAnswerMachinePromptDecoded
    }
}

extension ConnectClientTypes {
    /// Configuration of the answering machine detection.
    public struct AnswerMachineDetectionConfig: Swift.Equatable {
        /// Wait for the answering machine prompt.
        public var awaitAnswerMachinePrompt: Swift.Bool
        /// The flag to indicate if answer machine detection analysis needs to be performed for a voice call. If set to true, TrafficType must be set as CAMPAIGN.
        public var enableAnswerMachineDetection: Swift.Bool

        public init(
            awaitAnswerMachinePrompt: Swift.Bool = false,
            enableAnswerMachineDetection: Swift.Bool = false
        )
        {
            self.awaitAnswerMachinePrompt = awaitAnswerMachinePrompt
            self.enableAnswerMachineDetection = enableAnswerMachineDetection
        }
    }

}

extension ConnectClientTypes.Application: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationPermissions = "ApplicationPermissions"
        case namespace = "Namespace"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationPermissions = applicationPermissions {
            var applicationPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applicationPermissions)
            for permission0 in applicationPermissions {
                try applicationPermissionsContainer.encode(permission0)
            }
        }
        if let namespace = self.namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let applicationPermissionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .applicationPermissions)
        var applicationPermissionsDecoded0:[Swift.String]? = nil
        if let applicationPermissionsContainer = applicationPermissionsContainer {
            applicationPermissionsDecoded0 = [Swift.String]()
            for string0 in applicationPermissionsContainer {
                if let string0 = string0 {
                    applicationPermissionsDecoded0?.append(string0)
                }
            }
        }
        applicationPermissions = applicationPermissionsDecoded0
    }
}

extension ConnectClientTypes {
    /// This API is in preview release for Amazon Connect and is subject to change. A third-party application's metadata.
    public struct Application: Swift.Equatable {
        /// The permissions that the agent is granted on the application. Only the ACCESS permission is supported.
        public var applicationPermissions: [Swift.String]?
        /// Namespace of the application that you want to give access to.
        public var namespace: Swift.String?

        public init(
            applicationPermissions: [Swift.String]? = nil,
            namespace: Swift.String? = nil
        )
        {
            self.applicationPermissions = applicationPermissions
            self.namespace = namespace
        }
    }

}

extension ConnectClientTypes {
    public enum ArtifactStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case approved
        case inProgress
        case rejected
        case sdkUnknown(Swift.String)

        public static var allCases: [ArtifactStatus] {
            return [
                .approved,
                .inProgress,
                .rejected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .approved: return "APPROVED"
            case .inProgress: return "IN_PROGRESS"
            case .rejected: return "REJECTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ArtifactStatus(rawValue: rawValue) ?? ArtifactStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.AssignContactCategoryActionDefinition: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ConnectClientTypes {
    /// This action must be set if TriggerEventSource is one of the following values: OnPostCallAnalysisAvailable | OnRealTimeCallAnalysisAvailable | OnRealTimeChatAnalysisAvailable | OnPostChatAnalysisAvailable. Contact is categorized using the rule name. RuleName is used as ContactCategory.
    public struct AssignContactCategoryActionDefinition: Swift.Equatable {

        public init() { }
    }

}

extension AssociateAnalyticsDataSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSetId = "DataSetId"
        case targetAccountId = "TargetAccountId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSetId = self.dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let targetAccountId = self.targetAccountId {
            try encodeContainer.encode(targetAccountId, forKey: .targetAccountId)
        }
    }
}

extension AssociateAnalyticsDataSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/analytics-data/instance/\(instanceId.urlPercentEncoding())/association"
    }
}

public struct AssociateAnalyticsDataSetInput: Swift.Equatable {
    /// The identifier of the dataset to associate with the target account.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the target account. Use to associate a dataset to a different account than the one containing the Amazon Connect instance. If not specified, by default this value is the Amazon Web Services account that has the Amazon Connect instance.
    public var targetAccountId: Swift.String?

    public init(
        dataSetId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        targetAccountId: Swift.String? = nil
    )
    {
        self.dataSetId = dataSetId
        self.instanceId = instanceId
        self.targetAccountId = targetAccountId
    }
}

struct AssociateAnalyticsDataSetInputBody: Swift.Equatable {
    let dataSetId: Swift.String?
    let targetAccountId: Swift.String?
}

extension AssociateAnalyticsDataSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSetId = "DataSetId"
        case targetAccountId = "TargetAccountId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let targetAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetAccountId)
        targetAccountId = targetAccountIdDecoded
    }
}

extension AssociateAnalyticsDataSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateAnalyticsDataSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataSetId = output.dataSetId
            self.resourceShareArn = output.resourceShareArn
            self.resourceShareId = output.resourceShareId
            self.targetAccountId = output.targetAccountId
        } else {
            self.dataSetId = nil
            self.resourceShareArn = nil
            self.resourceShareId = nil
            self.targetAccountId = nil
        }
    }
}

public struct AssociateAnalyticsDataSetOutput: Swift.Equatable {
    /// The identifier of the dataset that was associated.
    public var dataSetId: Swift.String?
    /// The Amazon Resource Name (ARN) of the Resource Access Manager share.
    public var resourceShareArn: Swift.String?
    /// The Resource Access Manager share ID that is generated.
    public var resourceShareId: Swift.String?
    /// The identifier of the target account.
    public var targetAccountId: Swift.String?

    public init(
        dataSetId: Swift.String? = nil,
        resourceShareArn: Swift.String? = nil,
        resourceShareId: Swift.String? = nil,
        targetAccountId: Swift.String? = nil
    )
    {
        self.dataSetId = dataSetId
        self.resourceShareArn = resourceShareArn
        self.resourceShareId = resourceShareId
        self.targetAccountId = targetAccountId
    }
}

struct AssociateAnalyticsDataSetOutputBody: Swift.Equatable {
    let dataSetId: Swift.String?
    let targetAccountId: Swift.String?
    let resourceShareId: Swift.String?
    let resourceShareArn: Swift.String?
}

extension AssociateAnalyticsDataSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSetId = "DataSetId"
        case resourceShareArn = "ResourceShareArn"
        case resourceShareId = "ResourceShareId"
        case targetAccountId = "TargetAccountId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let targetAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetAccountId)
        targetAccountId = targetAccountIdDecoded
        let resourceShareIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareId)
        resourceShareId = resourceShareIdDecoded
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
    }
}

enum AssociateAnalyticsDataSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateApprovedOriginInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case origin = "Origin"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let origin = self.origin {
            try encodeContainer.encode(origin, forKey: .origin)
        }
    }
}

extension AssociateApprovedOriginInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/approved-origin"
    }
}

public struct AssociateApprovedOriginInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The domain to add to your allow list.
    /// This member is required.
    public var origin: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        origin: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.origin = origin
    }
}

struct AssociateApprovedOriginInputBody: Swift.Equatable {
    let origin: Swift.String?
}

extension AssociateApprovedOriginInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case origin = "Origin"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .origin)
        origin = originDecoded
    }
}

extension AssociateApprovedOriginOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateApprovedOriginOutput: Swift.Equatable {

    public init() { }
}

enum AssociateApprovedOriginOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateBotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lexBot = "LexBot"
        case lexV2Bot = "LexV2Bot"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lexBot = self.lexBot {
            try encodeContainer.encode(lexBot, forKey: .lexBot)
        }
        if let lexV2Bot = self.lexV2Bot {
            try encodeContainer.encode(lexV2Bot, forKey: .lexV2Bot)
        }
    }
}

extension AssociateBotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/bot"
    }
}

public struct AssociateBotInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Configuration information of an Amazon Lex bot.
    public var lexBot: ConnectClientTypes.LexBot?
    /// The Amazon Lex V2 bot to associate with the instance.
    public var lexV2Bot: ConnectClientTypes.LexV2Bot?

    public init(
        instanceId: Swift.String? = nil,
        lexBot: ConnectClientTypes.LexBot? = nil,
        lexV2Bot: ConnectClientTypes.LexV2Bot? = nil
    )
    {
        self.instanceId = instanceId
        self.lexBot = lexBot
        self.lexV2Bot = lexV2Bot
    }
}

struct AssociateBotInputBody: Swift.Equatable {
    let lexBot: ConnectClientTypes.LexBot?
    let lexV2Bot: ConnectClientTypes.LexV2Bot?
}

extension AssociateBotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lexBot = "LexBot"
        case lexV2Bot = "LexV2Bot"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lexBotDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.LexBot.self, forKey: .lexBot)
        lexBot = lexBotDecoded
        let lexV2BotDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.LexV2Bot.self, forKey: .lexV2Bot)
        lexV2Bot = lexV2BotDecoded
    }
}

extension AssociateBotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateBotOutput: Swift.Equatable {

    public init() { }
}

enum AssociateBotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateDefaultVocabularyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vocabularyId = "VocabularyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vocabularyId = self.vocabularyId {
            try encodeContainer.encode(vocabularyId, forKey: .vocabularyId)
        }
    }
}

extension AssociateDefaultVocabularyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let languageCode = languageCode else {
            return nil
        }
        return "/default-vocabulary/\(instanceId.urlPercentEncoding())/\(languageCode.rawValue.urlPercentEncoding())"
    }
}

public struct AssociateDefaultVocabularyInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see [What is Amazon Transcribe?](https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html)
    /// This member is required.
    public var languageCode: ConnectClientTypes.VocabularyLanguageCode?
    /// The identifier of the custom vocabulary. If this is empty, the default is set to none.
    public var vocabularyId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        languageCode: ConnectClientTypes.VocabularyLanguageCode? = nil,
        vocabularyId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.languageCode = languageCode
        self.vocabularyId = vocabularyId
    }
}

struct AssociateDefaultVocabularyInputBody: Swift.Equatable {
    let vocabularyId: Swift.String?
}

extension AssociateDefaultVocabularyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vocabularyId = "VocabularyId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vocabularyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyId)
        vocabularyId = vocabularyIdDecoded
    }
}

extension AssociateDefaultVocabularyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateDefaultVocabularyOutput: Swift.Equatable {

    public init() { }
}

enum AssociateDefaultVocabularyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateFlowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowId = "FlowId"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowId = self.flowId {
            try encodeContainer.encode(flowId, forKey: .flowId)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }
}

extension AssociateFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/flow-associations/\(instanceId.urlPercentEncoding())"
    }
}

public struct AssociateFlowInput: Swift.Equatable {
    /// The identifier of the flow.
    /// This member is required.
    public var flowId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// A valid resource type.
    /// This member is required.
    public var resourceType: ConnectClientTypes.FlowAssociationResourceType?

    public init(
        flowId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: ConnectClientTypes.FlowAssociationResourceType? = nil
    )
    {
        self.flowId = flowId
        self.instanceId = instanceId
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct AssociateFlowInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let flowId: Swift.String?
    let resourceType: ConnectClientTypes.FlowAssociationResourceType?
}

extension AssociateFlowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowId = "FlowId"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let flowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowId)
        flowId = flowIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.FlowAssociationResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension AssociateFlowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateFlowOutput: Swift.Equatable {

    public init() { }
}

enum AssociateFlowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateInstanceStorageConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceType = "ResourceType"
        case storageConfig = "StorageConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let storageConfig = self.storageConfig {
            try encodeContainer.encode(storageConfig, forKey: .storageConfig)
        }
    }
}

extension AssociateInstanceStorageConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/storage-config"
    }
}

public struct AssociateInstanceStorageConfigInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A valid resource type.
    /// This member is required.
    public var resourceType: ConnectClientTypes.InstanceStorageResourceType?
    /// A valid storage type.
    /// This member is required.
    public var storageConfig: ConnectClientTypes.InstanceStorageConfig?

    public init(
        instanceId: Swift.String? = nil,
        resourceType: ConnectClientTypes.InstanceStorageResourceType? = nil,
        storageConfig: ConnectClientTypes.InstanceStorageConfig? = nil
    )
    {
        self.instanceId = instanceId
        self.resourceType = resourceType
        self.storageConfig = storageConfig
    }
}

struct AssociateInstanceStorageConfigInputBody: Swift.Equatable {
    let resourceType: ConnectClientTypes.InstanceStorageResourceType?
    let storageConfig: ConnectClientTypes.InstanceStorageConfig?
}

extension AssociateInstanceStorageConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceType = "ResourceType"
        case storageConfig = "StorageConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.InstanceStorageResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let storageConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.InstanceStorageConfig.self, forKey: .storageConfig)
        storageConfig = storageConfigDecoded
    }
}

extension AssociateInstanceStorageConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateInstanceStorageConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.associationId = output.associationId
        } else {
            self.associationId = nil
        }
    }
}

public struct AssociateInstanceStorageConfigOutput: Swift.Equatable {
    /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
    public var associationId: Swift.String?

    public init(
        associationId: Swift.String? = nil
    )
    {
        self.associationId = associationId
    }
}

struct AssociateInstanceStorageConfigOutputBody: Swift.Equatable {
    let associationId: Swift.String?
}

extension AssociateInstanceStorageConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
    }
}

enum AssociateInstanceStorageConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateLambdaFunctionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionArn = "FunctionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let functionArn = self.functionArn {
            try encodeContainer.encode(functionArn, forKey: .functionArn)
        }
    }
}

extension AssociateLambdaFunctionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/lambda-function"
    }
}

public struct AssociateLambdaFunctionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the Lambda function being associated. Maximum number of characters allowed is 140.
    /// This member is required.
    public var functionArn: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        functionArn: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.functionArn = functionArn
        self.instanceId = instanceId
    }
}

struct AssociateLambdaFunctionInputBody: Swift.Equatable {
    let functionArn: Swift.String?
}

extension AssociateLambdaFunctionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionArn = "FunctionArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
    }
}

extension AssociateLambdaFunctionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateLambdaFunctionOutput: Swift.Equatable {

    public init() { }
}

enum AssociateLambdaFunctionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateLexBotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lexBot = "LexBot"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lexBot = self.lexBot {
            try encodeContainer.encode(lexBot, forKey: .lexBot)
        }
    }
}

extension AssociateLexBotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/lex-bot"
    }
}

public struct AssociateLexBotInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The Amazon Lex bot to associate with the instance.
    /// This member is required.
    public var lexBot: ConnectClientTypes.LexBot?

    public init(
        instanceId: Swift.String? = nil,
        lexBot: ConnectClientTypes.LexBot? = nil
    )
    {
        self.instanceId = instanceId
        self.lexBot = lexBot
    }
}

struct AssociateLexBotInputBody: Swift.Equatable {
    let lexBot: ConnectClientTypes.LexBot?
}

extension AssociateLexBotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lexBot = "LexBot"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lexBotDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.LexBot.self, forKey: .lexBot)
        lexBot = lexBotDecoded
    }
}

extension AssociateLexBotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateLexBotOutput: Swift.Equatable {

    public init() { }
}

enum AssociateLexBotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociatePhoneNumberContactFlowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactFlowId = "ContactFlowId"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactFlowId = self.contactFlowId {
            try encodeContainer.encode(contactFlowId, forKey: .contactFlowId)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

extension AssociatePhoneNumberContactFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let phoneNumberId = phoneNumberId else {
            return nil
        }
        return "/phone-number/\(phoneNumberId.urlPercentEncoding())/contact-flow"
    }
}

public struct AssociatePhoneNumberContactFlowInput: Swift.Equatable {
    /// The identifier of the flow.
    /// This member is required.
    public var contactFlowId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A unique identifier for the phone number.
    /// This member is required.
    public var phoneNumberId: Swift.String?

    public init(
        contactFlowId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        phoneNumberId: Swift.String? = nil
    )
    {
        self.contactFlowId = contactFlowId
        self.instanceId = instanceId
        self.phoneNumberId = phoneNumberId
    }
}

struct AssociatePhoneNumberContactFlowInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let contactFlowId: Swift.String?
}

extension AssociatePhoneNumberContactFlowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactFlowId = "ContactFlowId"
        case instanceId = "InstanceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let contactFlowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactFlowId)
        contactFlowId = contactFlowIdDecoded
    }
}

extension AssociatePhoneNumberContactFlowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociatePhoneNumberContactFlowOutput: Swift.Equatable {

    public init() { }
}

enum AssociatePhoneNumberContactFlowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateQueueQuickConnectsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quickConnectIds = "QuickConnectIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let quickConnectIds = quickConnectIds {
            var quickConnectIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .quickConnectIds)
            for quickconnectid0 in quickConnectIds {
                try quickConnectIdsContainer.encode(quickconnectid0)
            }
        }
    }
}

extension AssociateQueueQuickConnectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let queueId = queueId else {
            return nil
        }
        return "/queues/\(instanceId.urlPercentEncoding())/\(queueId.urlPercentEncoding())/associate-quick-connects"
    }
}

public struct AssociateQueueQuickConnectsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the queue.
    /// This member is required.
    public var queueId: Swift.String?
    /// The quick connects to associate with this queue.
    /// This member is required.
    public var quickConnectIds: [Swift.String]?

    public init(
        instanceId: Swift.String? = nil,
        queueId: Swift.String? = nil,
        quickConnectIds: [Swift.String]? = nil
    )
    {
        self.instanceId = instanceId
        self.queueId = queueId
        self.quickConnectIds = quickConnectIds
    }
}

struct AssociateQueueQuickConnectsInputBody: Swift.Equatable {
    let quickConnectIds: [Swift.String]?
}

extension AssociateQueueQuickConnectsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quickConnectIds = "QuickConnectIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quickConnectIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .quickConnectIds)
        var quickConnectIdsDecoded0:[Swift.String]? = nil
        if let quickConnectIdsContainer = quickConnectIdsContainer {
            quickConnectIdsDecoded0 = [Swift.String]()
            for string0 in quickConnectIdsContainer {
                if let string0 = string0 {
                    quickConnectIdsDecoded0?.append(string0)
                }
            }
        }
        quickConnectIds = quickConnectIdsDecoded0
    }
}

extension AssociateQueueQuickConnectsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateQueueQuickConnectsOutput: Swift.Equatable {

    public init() { }
}

enum AssociateQueueQuickConnectsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateRoutingProfileQueuesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queueConfigs = "QueueConfigs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queueConfigs = queueConfigs {
            var queueConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queueConfigs)
            for routingprofilequeueconfig0 in queueConfigs {
                try queueConfigsContainer.encode(routingprofilequeueconfig0)
            }
        }
    }
}

extension AssociateRoutingProfileQueuesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let routingProfileId = routingProfileId else {
            return nil
        }
        return "/routing-profiles/\(instanceId.urlPercentEncoding())/\(routingProfileId.urlPercentEncoding())/associate-queues"
    }
}

public struct AssociateRoutingProfileQueuesInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The queues to associate with this routing profile.
    /// This member is required.
    public var queueConfigs: [ConnectClientTypes.RoutingProfileQueueConfig]?
    /// The identifier of the routing profile.
    /// This member is required.
    public var routingProfileId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        queueConfigs: [ConnectClientTypes.RoutingProfileQueueConfig]? = nil,
        routingProfileId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.queueConfigs = queueConfigs
        self.routingProfileId = routingProfileId
    }
}

struct AssociateRoutingProfileQueuesInputBody: Swift.Equatable {
    let queueConfigs: [ConnectClientTypes.RoutingProfileQueueConfig]?
}

extension AssociateRoutingProfileQueuesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queueConfigs = "QueueConfigs"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueConfigsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.RoutingProfileQueueConfig?].self, forKey: .queueConfigs)
        var queueConfigsDecoded0:[ConnectClientTypes.RoutingProfileQueueConfig]? = nil
        if let queueConfigsContainer = queueConfigsContainer {
            queueConfigsDecoded0 = [ConnectClientTypes.RoutingProfileQueueConfig]()
            for structure0 in queueConfigsContainer {
                if let structure0 = structure0 {
                    queueConfigsDecoded0?.append(structure0)
                }
            }
        }
        queueConfigs = queueConfigsDecoded0
    }
}

extension AssociateRoutingProfileQueuesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateRoutingProfileQueuesOutput: Swift.Equatable {

    public init() { }
}

enum AssociateRoutingProfileQueuesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateSecurityKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }
}

extension AssociateSecurityKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/security-key"
    }
}

public struct AssociateSecurityKeyInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A valid security key in PEM format.
    /// This member is required.
    public var key: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        key: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.key = key
    }
}

struct AssociateSecurityKeyInputBody: Swift.Equatable {
    let key: Swift.String?
}

extension AssociateSecurityKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
    }
}

extension AssociateSecurityKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateSecurityKeyOutputBody = try responseDecoder.decode(responseBody: data)
            self.associationId = output.associationId
        } else {
            self.associationId = nil
        }
    }
}

public struct AssociateSecurityKeyOutput: Swift.Equatable {
    /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
    public var associationId: Swift.String?

    public init(
        associationId: Swift.String? = nil
    )
    {
        self.associationId = associationId
    }
}

struct AssociateSecurityKeyOutputBody: Swift.Equatable {
    let associationId: Swift.String?
}

extension AssociateSecurityKeyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
    }
}

enum AssociateSecurityKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateTrafficDistributionGroupUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension AssociateTrafficDistributionGroupUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trafficDistributionGroupId = trafficDistributionGroupId else {
            return nil
        }
        return "/traffic-distribution-group/\(trafficDistributionGroupId.urlPercentEncoding())/user"
    }
}

public struct AssociateTrafficDistributionGroupUserInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.
    /// This member is required.
    public var trafficDistributionGroupId: Swift.String?
    /// The identifier of the user account. This can be the ID or the ARN of the user.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        trafficDistributionGroupId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.trafficDistributionGroupId = trafficDistributionGroupId
        self.userId = userId
    }
}

struct AssociateTrafficDistributionGroupUserInputBody: Swift.Equatable {
    let userId: Swift.String?
    let instanceId: Swift.String?
}

extension AssociateTrafficDistributionGroupUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case userId = "UserId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension AssociateTrafficDistributionGroupUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateTrafficDistributionGroupUserOutput: Swift.Equatable {

    public init() { }
}

enum AssociateTrafficDistributionGroupUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectClientTypes.AttachmentReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case status = "Status"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ReferenceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ConnectClientTypes {
    /// Information about a reference when the referenceType is ATTACHMENT. Otherwise, null.
    public struct AttachmentReference: Swift.Equatable {
        /// Identifier of the attachment reference.
        public var name: Swift.String?
        /// Status of the attachment reference type.
        public var status: ConnectClientTypes.ReferenceStatus?
        /// The location path of the attachment reference.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            status: ConnectClientTypes.ReferenceStatus? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.status = status
            self.value = value
        }
    }

}

extension ConnectClientTypes.Attendee: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendeeId = "AttendeeId"
        case joinToken = "JoinToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attendeeId = self.attendeeId {
            try encodeContainer.encode(attendeeId, forKey: .attendeeId)
        }
        if let joinToken = self.joinToken {
            try encodeContainer.encode(joinToken, forKey: .joinToken)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attendeeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attendeeId)
        attendeeId = attendeeIdDecoded
        let joinTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .joinToken)
        joinToken = joinTokenDecoded
    }
}

extension ConnectClientTypes.Attendee: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Attendee(attendeeId: \(Swift.String(describing: attendeeId)), joinToken: \"CONTENT_REDACTED\")"}
}

extension ConnectClientTypes {
    /// The attendee information, including attendee ID and join token.
    public struct Attendee: Swift.Equatable {
        /// The Amazon Chime SDK attendee ID.
        public var attendeeId: Swift.String?
        /// The join token used by the Amazon Chime SDK attendee.
        public var joinToken: Swift.String?

        public init(
            attendeeId: Swift.String? = nil,
            joinToken: Swift.String? = nil
        )
        {
            self.attendeeId = attendeeId
            self.joinToken = joinToken
        }
    }

}

extension ConnectClientTypes.Attribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeType = "AttributeType"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeType = self.attributeType {
            try encodeContainer.encode(attributeType.rawValue, forKey: .attributeType)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.InstanceAttributeType.self, forKey: .attributeType)
        attributeType = attributeTypeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ConnectClientTypes {
    /// A toggle for an individual feature at the instance level.
    public struct Attribute: Swift.Equatable {
        /// The type of attribute.
        public var attributeType: ConnectClientTypes.InstanceAttributeType?
        /// The value of the attribute.
        public var value: Swift.String?

        public init(
            attributeType: ConnectClientTypes.InstanceAttributeType? = nil,
            value: Swift.String? = nil
        )
        {
            self.attributeType = attributeType
            self.value = value
        }
    }

}

extension ConnectClientTypes.AudioFeatures: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case echoReduction = "EchoReduction"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let echoReduction = self.echoReduction {
            try encodeContainer.encode(echoReduction.rawValue, forKey: .echoReduction)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let echoReductionDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.MeetingFeatureStatus.self, forKey: .echoReduction)
        echoReduction = echoReductionDecoded
    }
}

extension ConnectClientTypes {
    /// Has audio-specific configurations as the operating parameter for Echo Reduction.
    public struct AudioFeatures: Swift.Equatable {
        /// Makes echo reduction available to clients who connect to the meeting.
        public var echoReduction: ConnectClientTypes.MeetingFeatureStatus?

        public init(
            echoReduction: ConnectClientTypes.MeetingFeatureStatus? = nil
        )
        {
            self.echoReduction = echoReduction
        }
    }

}

extension ConnectClientTypes.AvailableNumberSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumber = "PhoneNumber"
        case phoneNumberCountryCode = "PhoneNumberCountryCode"
        case phoneNumberType = "PhoneNumberType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let phoneNumber = self.phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let phoneNumberCountryCode = self.phoneNumberCountryCode {
            try encodeContainer.encode(phoneNumberCountryCode.rawValue, forKey: .phoneNumberCountryCode)
        }
        if let phoneNumberType = self.phoneNumberType {
            try encodeContainer.encode(phoneNumberType.rawValue, forKey: .phoneNumberType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let phoneNumberCountryCodeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.PhoneNumberCountryCode.self, forKey: .phoneNumberCountryCode)
        phoneNumberCountryCode = phoneNumberCountryCodeDecoded
        let phoneNumberTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.PhoneNumberType.self, forKey: .phoneNumberType)
        phoneNumberType = phoneNumberTypeDecoded
    }
}

extension ConnectClientTypes {
    /// Information about available phone numbers.
    public struct AvailableNumberSummary: Swift.Equatable {
        /// The phone number. Phone numbers are formatted [+] [country code] [subscriber number including area code].
        public var phoneNumber: Swift.String?
        /// The ISO country code.
        public var phoneNumberCountryCode: ConnectClientTypes.PhoneNumberCountryCode?
        /// The type of phone number.
        public var phoneNumberType: ConnectClientTypes.PhoneNumberType?

        public init(
            phoneNumber: Swift.String? = nil,
            phoneNumberCountryCode: ConnectClientTypes.PhoneNumberCountryCode? = nil,
            phoneNumberType: ConnectClientTypes.PhoneNumberType? = nil
        )
        {
            self.phoneNumber = phoneNumber
            self.phoneNumberCountryCode = phoneNumberCountryCode
            self.phoneNumberType = phoneNumberType
        }
    }

}

extension BatchAssociateAnalyticsDataSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSetIds = "DataSetIds"
        case targetAccountId = "TargetAccountId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSetIds = dataSetIds {
            var dataSetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSetIds)
            for datasetid0 in dataSetIds {
                try dataSetIdsContainer.encode(datasetid0)
            }
        }
        if let targetAccountId = self.targetAccountId {
            try encodeContainer.encode(targetAccountId, forKey: .targetAccountId)
        }
    }
}

extension BatchAssociateAnalyticsDataSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/analytics-data/instance/\(instanceId.urlPercentEncoding())/associations"
    }
}

public struct BatchAssociateAnalyticsDataSetInput: Swift.Equatable {
    /// An array of dataset identifiers to associate.
    /// This member is required.
    public var dataSetIds: [Swift.String]?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the target account. Use to associate a dataset to a different account than the one containing the Amazon Connect instance. If not specified, by default this value is the Amazon Web Services account that has the Amazon Connect instance.
    public var targetAccountId: Swift.String?

    public init(
        dataSetIds: [Swift.String]? = nil,
        instanceId: Swift.String? = nil,
        targetAccountId: Swift.String? = nil
    )
    {
        self.dataSetIds = dataSetIds
        self.instanceId = instanceId
        self.targetAccountId = targetAccountId
    }
}

struct BatchAssociateAnalyticsDataSetInputBody: Swift.Equatable {
    let dataSetIds: [Swift.String]?
    let targetAccountId: Swift.String?
}

extension BatchAssociateAnalyticsDataSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSetIds = "DataSetIds"
        case targetAccountId = "TargetAccountId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dataSetIds)
        var dataSetIdsDecoded0:[Swift.String]? = nil
        if let dataSetIdsContainer = dataSetIdsContainer {
            dataSetIdsDecoded0 = [Swift.String]()
            for string0 in dataSetIdsContainer {
                if let string0 = string0 {
                    dataSetIdsDecoded0?.append(string0)
                }
            }
        }
        dataSetIds = dataSetIdsDecoded0
        let targetAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetAccountId)
        targetAccountId = targetAccountIdDecoded
    }
}

extension BatchAssociateAnalyticsDataSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchAssociateAnalyticsDataSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.created = output.created
            self.errors = output.errors
        } else {
            self.created = nil
            self.errors = nil
        }
    }
}

public struct BatchAssociateAnalyticsDataSetOutput: Swift.Equatable {
    /// Information about associations that are successfully created: DataSetId, TargetAccountId, ResourceShareId, ResourceShareArn.
    public var created: [ConnectClientTypes.AnalyticsDataAssociationResult]?
    /// A list of errors for datasets that aren't successfully associated with the target account.
    public var errors: [ConnectClientTypes.ErrorResult]?

    public init(
        created: [ConnectClientTypes.AnalyticsDataAssociationResult]? = nil,
        errors: [ConnectClientTypes.ErrorResult]? = nil
    )
    {
        self.created = created
        self.errors = errors
    }
}

struct BatchAssociateAnalyticsDataSetOutputBody: Swift.Equatable {
    let created: [ConnectClientTypes.AnalyticsDataAssociationResult]?
    let errors: [ConnectClientTypes.ErrorResult]?
}

extension BatchAssociateAnalyticsDataSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case created = "Created"
        case errors = "Errors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdContainer = try containerValues.decodeIfPresent([ConnectClientTypes.AnalyticsDataAssociationResult?].self, forKey: .created)
        var createdDecoded0:[ConnectClientTypes.AnalyticsDataAssociationResult]? = nil
        if let createdContainer = createdContainer {
            createdDecoded0 = [ConnectClientTypes.AnalyticsDataAssociationResult]()
            for structure0 in createdContainer {
                if let structure0 = structure0 {
                    createdDecoded0?.append(structure0)
                }
            }
        }
        created = createdDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.ErrorResult?].self, forKey: .errors)
        var errorsDecoded0:[ConnectClientTypes.ErrorResult]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [ConnectClientTypes.ErrorResult]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchAssociateAnalyticsDataSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchDisassociateAnalyticsDataSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSetIds = "DataSetIds"
        case targetAccountId = "TargetAccountId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSetIds = dataSetIds {
            var dataSetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSetIds)
            for datasetid0 in dataSetIds {
                try dataSetIdsContainer.encode(datasetid0)
            }
        }
        if let targetAccountId = self.targetAccountId {
            try encodeContainer.encode(targetAccountId, forKey: .targetAccountId)
        }
    }
}

extension BatchDisassociateAnalyticsDataSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/analytics-data/instance/\(instanceId.urlPercentEncoding())/associations"
    }
}

public struct BatchDisassociateAnalyticsDataSetInput: Swift.Equatable {
    /// An array of associated dataset identifiers to remove.
    /// This member is required.
    public var dataSetIds: [Swift.String]?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the target account. Use to disassociate a dataset from a different account than the one containing the Amazon Connect instance. If not specified, by default this value is the Amazon Web Services account that has the Amazon Connect instance.
    public var targetAccountId: Swift.String?

    public init(
        dataSetIds: [Swift.String]? = nil,
        instanceId: Swift.String? = nil,
        targetAccountId: Swift.String? = nil
    )
    {
        self.dataSetIds = dataSetIds
        self.instanceId = instanceId
        self.targetAccountId = targetAccountId
    }
}

struct BatchDisassociateAnalyticsDataSetInputBody: Swift.Equatable {
    let dataSetIds: [Swift.String]?
    let targetAccountId: Swift.String?
}

extension BatchDisassociateAnalyticsDataSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSetIds = "DataSetIds"
        case targetAccountId = "TargetAccountId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dataSetIds)
        var dataSetIdsDecoded0:[Swift.String]? = nil
        if let dataSetIdsContainer = dataSetIdsContainer {
            dataSetIdsDecoded0 = [Swift.String]()
            for string0 in dataSetIdsContainer {
                if let string0 = string0 {
                    dataSetIdsDecoded0?.append(string0)
                }
            }
        }
        dataSetIds = dataSetIdsDecoded0
        let targetAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetAccountId)
        targetAccountId = targetAccountIdDecoded
    }
}

extension BatchDisassociateAnalyticsDataSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchDisassociateAnalyticsDataSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.deleted = output.deleted
            self.errors = output.errors
        } else {
            self.deleted = nil
            self.errors = nil
        }
    }
}

public struct BatchDisassociateAnalyticsDataSetOutput: Swift.Equatable {
    /// An array of successfully disassociated dataset identifiers.
    public var deleted: [Swift.String]?
    /// A list of errors for any datasets not successfully removed.
    public var errors: [ConnectClientTypes.ErrorResult]?

    public init(
        deleted: [Swift.String]? = nil,
        errors: [ConnectClientTypes.ErrorResult]? = nil
    )
    {
        self.deleted = deleted
        self.errors = errors
    }
}

struct BatchDisassociateAnalyticsDataSetOutputBody: Swift.Equatable {
    let deleted: [Swift.String]?
    let errors: [ConnectClientTypes.ErrorResult]?
}

extension BatchDisassociateAnalyticsDataSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleted = "Deleted"
        case errors = "Errors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deletedContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deleted)
        var deletedDecoded0:[Swift.String]? = nil
        if let deletedContainer = deletedContainer {
            deletedDecoded0 = [Swift.String]()
            for string0 in deletedContainer {
                if let string0 = string0 {
                    deletedDecoded0?.append(string0)
                }
            }
        }
        deleted = deletedDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.ErrorResult?].self, forKey: .errors)
        var errorsDecoded0:[ConnectClientTypes.ErrorResult]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [ConnectClientTypes.ErrorResult]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchDisassociateAnalyticsDataSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchGetFlowAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceIds = "ResourceIds"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceIds = resourceIds {
            var resourceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceIds)
            for arn0 in resourceIds {
                try resourceIdsContainer.encode(arn0)
            }
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }
}

extension BatchGetFlowAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/flow-associations-batch/\(instanceId.urlPercentEncoding())"
    }
}

public struct BatchGetFlowAssociationInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A list of resource identifiers to retrieve flow associations.
    /// This member is required.
    public var resourceIds: [Swift.String]?
    /// The type of resource association.
    public var resourceType: ConnectClientTypes.ListFlowAssociationResourceType?

    public init(
        instanceId: Swift.String? = nil,
        resourceIds: [Swift.String]? = nil,
        resourceType: ConnectClientTypes.ListFlowAssociationResourceType? = nil
    )
    {
        self.instanceId = instanceId
        self.resourceIds = resourceIds
        self.resourceType = resourceType
    }
}

struct BatchGetFlowAssociationInputBody: Swift.Equatable {
    let resourceIds: [Swift.String]?
    let resourceType: ConnectClientTypes.ListFlowAssociationResourceType?
}

extension BatchGetFlowAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceIds = "ResourceIds"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceIds)
        var resourceIdsDecoded0:[Swift.String]? = nil
        if let resourceIdsContainer = resourceIdsContainer {
            resourceIdsDecoded0 = [Swift.String]()
            for string0 in resourceIdsContainer {
                if let string0 = string0 {
                    resourceIdsDecoded0?.append(string0)
                }
            }
        }
        resourceIds = resourceIdsDecoded0
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ListFlowAssociationResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension BatchGetFlowAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchGetFlowAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.flowAssociationSummaryList = output.flowAssociationSummaryList
        } else {
            self.flowAssociationSummaryList = nil
        }
    }
}

public struct BatchGetFlowAssociationOutput: Swift.Equatable {
    /// Information about flow associations.
    public var flowAssociationSummaryList: [ConnectClientTypes.FlowAssociationSummary]?

    public init(
        flowAssociationSummaryList: [ConnectClientTypes.FlowAssociationSummary]? = nil
    )
    {
        self.flowAssociationSummaryList = flowAssociationSummaryList
    }
}

struct BatchGetFlowAssociationOutputBody: Swift.Equatable {
    let flowAssociationSummaryList: [ConnectClientTypes.FlowAssociationSummary]?
}

extension BatchGetFlowAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowAssociationSummaryList = "FlowAssociationSummaryList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowAssociationSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.FlowAssociationSummary?].self, forKey: .flowAssociationSummaryList)
        var flowAssociationSummaryListDecoded0:[ConnectClientTypes.FlowAssociationSummary]? = nil
        if let flowAssociationSummaryListContainer = flowAssociationSummaryListContainer {
            flowAssociationSummaryListDecoded0 = [ConnectClientTypes.FlowAssociationSummary]()
            for structure0 in flowAssociationSummaryListContainer {
                if let structure0 = structure0 {
                    flowAssociationSummaryListDecoded0?.append(structure0)
                }
            }
        }
        flowAssociationSummaryList = flowAssociationSummaryListDecoded0
    }
}

enum BatchGetFlowAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchPutContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case contactDataRequestList = "ContactDataRequestList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let contactDataRequestList = contactDataRequestList {
            var contactDataRequestListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .contactDataRequestList)
            for contactdatarequest0 in contactDataRequestList {
                try contactDataRequestListContainer.encode(contactdatarequest0)
            }
        }
    }
}

extension BatchPutContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/contact/batch/\(instanceId.urlPercentEncoding())"
    }
}

public struct BatchPutContactInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// List of individual contact requests.
    /// This member is required.
    public var contactDataRequestList: [ConnectClientTypes.ContactDataRequest]?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        contactDataRequestList: [ConnectClientTypes.ContactDataRequest]? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.contactDataRequestList = contactDataRequestList
        self.instanceId = instanceId
    }
}

struct BatchPutContactInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let contactDataRequestList: [ConnectClientTypes.ContactDataRequest]?
}

extension BatchPutContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case contactDataRequestList = "ContactDataRequestList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let contactDataRequestListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.ContactDataRequest?].self, forKey: .contactDataRequestList)
        var contactDataRequestListDecoded0:[ConnectClientTypes.ContactDataRequest]? = nil
        if let contactDataRequestListContainer = contactDataRequestListContainer {
            contactDataRequestListDecoded0 = [ConnectClientTypes.ContactDataRequest]()
            for structure0 in contactDataRequestListContainer {
                if let structure0 = structure0 {
                    contactDataRequestListDecoded0?.append(structure0)
                }
            }
        }
        contactDataRequestList = contactDataRequestListDecoded0
    }
}

extension BatchPutContactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchPutContactOutputBody = try responseDecoder.decode(responseBody: data)
            self.failedRequestList = output.failedRequestList
            self.successfulRequestList = output.successfulRequestList
        } else {
            self.failedRequestList = nil
            self.successfulRequestList = nil
        }
    }
}

public struct BatchPutContactOutput: Swift.Equatable {
    /// List of requests for which contact creation failed.
    public var failedRequestList: [ConnectClientTypes.FailedRequest]?
    /// List of requests for which contact was successfully created.
    public var successfulRequestList: [ConnectClientTypes.SuccessfulRequest]?

    public init(
        failedRequestList: [ConnectClientTypes.FailedRequest]? = nil,
        successfulRequestList: [ConnectClientTypes.SuccessfulRequest]? = nil
    )
    {
        self.failedRequestList = failedRequestList
        self.successfulRequestList = successfulRequestList
    }
}

struct BatchPutContactOutputBody: Swift.Equatable {
    let successfulRequestList: [ConnectClientTypes.SuccessfulRequest]?
    let failedRequestList: [ConnectClientTypes.FailedRequest]?
}

extension BatchPutContactOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedRequestList = "FailedRequestList"
        case successfulRequestList = "SuccessfulRequestList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulRequestListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.SuccessfulRequest?].self, forKey: .successfulRequestList)
        var successfulRequestListDecoded0:[ConnectClientTypes.SuccessfulRequest]? = nil
        if let successfulRequestListContainer = successfulRequestListContainer {
            successfulRequestListDecoded0 = [ConnectClientTypes.SuccessfulRequest]()
            for structure0 in successfulRequestListContainer {
                if let structure0 = structure0 {
                    successfulRequestListDecoded0?.append(structure0)
                }
            }
        }
        successfulRequestList = successfulRequestListDecoded0
        let failedRequestListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.FailedRequest?].self, forKey: .failedRequestList)
        var failedRequestListDecoded0:[ConnectClientTypes.FailedRequest]? = nil
        if let failedRequestListContainer = failedRequestListContainer {
            failedRequestListDecoded0 = [ConnectClientTypes.FailedRequest]()
            for structure0 in failedRequestListContainer {
                if let structure0 = structure0 {
                    failedRequestListDecoded0?.append(structure0)
                }
            }
        }
        failedRequestList = failedRequestListDecoded0
    }
}

enum BatchPutContactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IdempotencyException": return try await IdempotencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectClientTypes {
    public enum BehaviorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case routeAnyChannel
        case routeCurrentChannelOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [BehaviorType] {
            return [
                .routeAnyChannel,
                .routeCurrentChannelOnly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .routeAnyChannel: return "ROUTE_ANY_CHANNEL"
            case .routeCurrentChannelOnly: return "ROUTE_CURRENT_CHANNEL_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BehaviorType(rawValue: rawValue) ?? BehaviorType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.Campaign: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignId = "CampaignId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignId = self.campaignId {
            try encodeContainer.encode(campaignId, forKey: .campaignId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .campaignId)
        campaignId = campaignIdDecoded
    }
}

extension ConnectClientTypes {
    /// Information associated with a campaign.
    public struct Campaign: Swift.Equatable {
        /// A unique identifier for a campaign.
        public var campaignId: Swift.String?

        public init(
            campaignId: Swift.String? = nil
        )
        {
            self.campaignId = campaignId
        }
    }

}

extension ConnectClientTypes {
    public enum Channel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case chat
        case task
        case voice
        case sdkUnknown(Swift.String)

        public static var allCases: [Channel] {
            return [
                .chat,
                .task,
                .voice,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .chat: return "CHAT"
            case .task: return "TASK"
            case .voice: return "VOICE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Channel(rawValue: rawValue) ?? Channel.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.ChatEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case contentType = "ContentType"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ChatEventType.self, forKey: .type)
        type = typeDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
    }
}

extension ConnectClientTypes {
    /// Chat integration event containing payload to perform different chat actions such as:
    ///
    /// * Sending a chat message
    ///
    /// * Sending a chat event, such as typing
    ///
    /// * Disconnecting from a chat
    public struct ChatEvent: Swift.Equatable {
        /// Content of the message or event. This is required when Type is MESSAGE and for certain ContentTypes when Type is EVENT.
        ///
        /// * For allowed message content, see the Content parameter in the [SendMessage](https://docs.aws.amazon.com/connect-participant/latest/APIReference/API_SendMessage.html) topic in the Amazon Connect Participant Service API Reference.
        ///
        /// * For allowed event content, see the Content parameter in the [SendEvent](https://docs.aws.amazon.com/connect-participant/latest/APIReference/API_SendEvent.html) topic in the Amazon Connect Participant Service API Reference.
        public var content: Swift.String?
        /// Type of content. This is required when Type is MESSAGE or EVENT.
        ///
        /// * For allowed message content types, see the ContentType parameter in the [SendMessage](https://docs.aws.amazon.com/connect-participant/latest/APIReference/API_SendMessage.html) topic in the Amazon Connect Participant Service API Reference.
        ///
        /// * For allowed event content types, see the ContentType parameter in the [SendEvent](https://docs.aws.amazon.com/connect-participant/latest/APIReference/API_SendEvent.html) topic in the Amazon Connect Participant Service API Reference.
        public var contentType: Swift.String?
        /// Type of chat integration event.
        /// This member is required.
        public var type: ConnectClientTypes.ChatEventType?

        public init(
            content: Swift.String? = nil,
            contentType: Swift.String? = nil,
            type: ConnectClientTypes.ChatEventType? = nil
        )
        {
            self.content = content
            self.contentType = contentType
            self.type = type
        }
    }

}

extension ConnectClientTypes {
    public enum ChatEventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disconnect
        case event
        case message
        case sdkUnknown(Swift.String)

        public static var allCases: [ChatEventType] {
            return [
                .disconnect,
                .event,
                .message,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disconnect: return "DISCONNECT"
            case .event: return "EVENT"
            case .message: return "MESSAGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChatEventType(rawValue: rawValue) ?? ChatEventType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.ChatMessage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case contentType = "ContentType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
    }
}

extension ConnectClientTypes {
    /// A chat message.
    public struct ChatMessage: Swift.Equatable {
        /// The content of the chat message.
        ///
        /// * For text/plain and text/markdown, the Length Constraints are Minimum of 1, Maximum of 1024.
        ///
        /// * For application/json, the Length Constraints are Minimum of 1, Maximum of 12000.
        ///
        /// * For application/vnd.amazonaws.connect.message.interactive.response, the Length Constraints are Minimum of 1, Maximum of 12288.
        /// This member is required.
        public var content: Swift.String?
        /// The type of the content. Supported types are text/plain, text/markdown, application/json, and application/vnd.amazonaws.connect.message.interactive.response.
        /// This member is required.
        public var contentType: Swift.String?

        public init(
            content: Swift.String? = nil,
            contentType: Swift.String? = nil
        )
        {
            self.content = content
            self.contentType = contentType
        }
    }

}

extension ConnectClientTypes.ChatParticipantRoleConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case participantTimerConfigList = "ParticipantTimerConfigList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let participantTimerConfigList = participantTimerConfigList {
            var participantTimerConfigListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .participantTimerConfigList)
            for participanttimerconfiguration0 in participantTimerConfigList {
                try participantTimerConfigListContainer.encode(participanttimerconfiguration0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let participantTimerConfigListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.ParticipantTimerConfiguration?].self, forKey: .participantTimerConfigList)
        var participantTimerConfigListDecoded0:[ConnectClientTypes.ParticipantTimerConfiguration]? = nil
        if let participantTimerConfigListContainer = participantTimerConfigListContainer {
            participantTimerConfigListDecoded0 = [ConnectClientTypes.ParticipantTimerConfiguration]()
            for structure0 in participantTimerConfigListContainer {
                if let structure0 = structure0 {
                    participantTimerConfigListDecoded0?.append(structure0)
                }
            }
        }
        participantTimerConfigList = participantTimerConfigListDecoded0
    }
}

extension ConnectClientTypes {
    /// Configuration information for the chat participant role.
    public struct ChatParticipantRoleConfig: Swift.Equatable {
        /// A list of participant timers. You can specify any unique combination of role and timer type. Duplicate entries error out the request with a 400.
        /// This member is required.
        public var participantTimerConfigList: [ConnectClientTypes.ParticipantTimerConfiguration]?

        public init(
            participantTimerConfigList: [ConnectClientTypes.ParticipantTimerConfiguration]? = nil
        )
        {
            self.participantTimerConfigList = participantTimerConfigList
        }
    }

}

extension ConnectClientTypes.ChatStreamingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingEndpointArn = "StreamingEndpointArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamingEndpointArn = self.streamingEndpointArn {
            try encodeContainer.encode(streamingEndpointArn, forKey: .streamingEndpointArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingEndpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamingEndpointArn)
        streamingEndpointArn = streamingEndpointArnDecoded
    }
}

extension ConnectClientTypes {
    /// The streaming configuration, such as the Amazon SNS streaming endpoint.
    public struct ChatStreamingConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the standard Amazon SNS topic. The Amazon Resource Name (ARN) of the streaming endpoint that is used to publish real-time message streaming for chat conversations.
        /// This member is required.
        public var streamingEndpointArn: Swift.String?

        public init(
            streamingEndpointArn: Swift.String? = nil
        )
        {
            self.streamingEndpointArn = streamingEndpointArn
        }
    }

}

extension ClaimPhoneNumberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case instanceId = "InstanceId"
        case phoneNumber = "PhoneNumber"
        case phoneNumberDescription = "PhoneNumberDescription"
        case tags = "Tags"
        case targetArn = "TargetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let phoneNumber = self.phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let phoneNumberDescription = self.phoneNumberDescription {
            try encodeContainer.encode(phoneNumberDescription, forKey: .phoneNumberDescription)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targetArn = self.targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }
}

extension ClaimPhoneNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/phone-number/claim"
    }
}

public struct ClaimPhoneNumberInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/). Pattern: ^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$
    public var clientToken: Swift.String?
    /// The identifier of the Amazon Connect instance that phone numbers are claimed to. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance. You must enter InstanceId or TargetArn.
    public var instanceId: Swift.String?
    /// The phone number you want to claim. Phone numbers are formatted [+] [country code] [subscriber number including area code].
    /// This member is required.
    public var phoneNumber: Swift.String?
    /// The description of the phone number.
    public var phoneNumberDescription: Swift.String?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String:Swift.String]?
    /// The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone number inbound traffic is routed through. You must enter InstanceId or TargetArn.
    public var targetArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        phoneNumber: Swift.String? = nil,
        phoneNumberDescription: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        targetArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.instanceId = instanceId
        self.phoneNumber = phoneNumber
        self.phoneNumberDescription = phoneNumberDescription
        self.tags = tags
        self.targetArn = targetArn
    }
}

struct ClaimPhoneNumberInputBody: Swift.Equatable {
    let targetArn: Swift.String?
    let instanceId: Swift.String?
    let phoneNumber: Swift.String?
    let phoneNumberDescription: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension ClaimPhoneNumberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case instanceId = "InstanceId"
        case phoneNumber = "PhoneNumber"
        case phoneNumberDescription = "PhoneNumberDescription"
        case tags = "Tags"
        case targetArn = "TargetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let phoneNumberDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberDescription)
        phoneNumberDescription = phoneNumberDescriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension ClaimPhoneNumberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ClaimPhoneNumberOutputBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberArn = output.phoneNumberArn
            self.phoneNumberId = output.phoneNumberId
        } else {
            self.phoneNumberArn = nil
            self.phoneNumberId = nil
        }
    }
}

public struct ClaimPhoneNumberOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the phone number.
    public var phoneNumberArn: Swift.String?
    /// A unique identifier for the phone number.
    public var phoneNumberId: Swift.String?

    public init(
        phoneNumberArn: Swift.String? = nil,
        phoneNumberId: Swift.String? = nil
    )
    {
        self.phoneNumberArn = phoneNumberArn
        self.phoneNumberId = phoneNumberId
    }
}

struct ClaimPhoneNumberOutputBody: Swift.Equatable {
    let phoneNumberId: Swift.String?
    let phoneNumberArn: Swift.String?
}

extension ClaimPhoneNumberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberArn = "PhoneNumberArn"
        case phoneNumberId = "PhoneNumberId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberId)
        phoneNumberId = phoneNumberIdDecoded
        let phoneNumberArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberArn)
        phoneNumberArn = phoneNumberArnDecoded
    }
}

enum ClaimPhoneNumberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IdempotencyException": return try await IdempotencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectClientTypes.ClaimedPhoneNumberSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case phoneNumber = "PhoneNumber"
        case phoneNumberArn = "PhoneNumberArn"
        case phoneNumberCountryCode = "PhoneNumberCountryCode"
        case phoneNumberDescription = "PhoneNumberDescription"
        case phoneNumberId = "PhoneNumberId"
        case phoneNumberStatus = "PhoneNumberStatus"
        case phoneNumberType = "PhoneNumberType"
        case sourcePhoneNumberArn = "SourcePhoneNumberArn"
        case tags = "Tags"
        case targetArn = "TargetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let phoneNumber = self.phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let phoneNumberArn = self.phoneNumberArn {
            try encodeContainer.encode(phoneNumberArn, forKey: .phoneNumberArn)
        }
        if let phoneNumberCountryCode = self.phoneNumberCountryCode {
            try encodeContainer.encode(phoneNumberCountryCode.rawValue, forKey: .phoneNumberCountryCode)
        }
        if let phoneNumberDescription = self.phoneNumberDescription {
            try encodeContainer.encode(phoneNumberDescription, forKey: .phoneNumberDescription)
        }
        if let phoneNumberId = self.phoneNumberId {
            try encodeContainer.encode(phoneNumberId, forKey: .phoneNumberId)
        }
        if let phoneNumberStatus = self.phoneNumberStatus {
            try encodeContainer.encode(phoneNumberStatus, forKey: .phoneNumberStatus)
        }
        if let phoneNumberType = self.phoneNumberType {
            try encodeContainer.encode(phoneNumberType.rawValue, forKey: .phoneNumberType)
        }
        if let sourcePhoneNumberArn = self.sourcePhoneNumberArn {
            try encodeContainer.encode(sourcePhoneNumberArn, forKey: .sourcePhoneNumberArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targetArn = self.targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberId)
        phoneNumberId = phoneNumberIdDecoded
        let phoneNumberArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberArn)
        phoneNumberArn = phoneNumberArnDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let phoneNumberCountryCodeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.PhoneNumberCountryCode.self, forKey: .phoneNumberCountryCode)
        phoneNumberCountryCode = phoneNumberCountryCodeDecoded
        let phoneNumberTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.PhoneNumberType.self, forKey: .phoneNumberType)
        phoneNumberType = phoneNumberTypeDecoded
        let phoneNumberDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberDescription)
        phoneNumberDescription = phoneNumberDescriptionDecoded
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let phoneNumberStatusDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.PhoneNumberStatus.self, forKey: .phoneNumberStatus)
        phoneNumberStatus = phoneNumberStatusDecoded
        let sourcePhoneNumberArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourcePhoneNumberArn)
        sourcePhoneNumberArn = sourcePhoneNumberArnDecoded
    }
}

extension ConnectClientTypes {
    /// Information about a phone number that has been claimed to your Amazon Connect instance or traffic distribution group.
    public struct ClaimedPhoneNumberSummary: Swift.Equatable {
        /// The identifier of the Amazon Connect instance that phone numbers are claimed to. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
        public var instanceId: Swift.String?
        /// The phone number. Phone numbers are formatted [+] [country code] [subscriber number including area code].
        public var phoneNumber: Swift.String?
        /// The Amazon Resource Name (ARN) of the phone number.
        public var phoneNumberArn: Swift.String?
        /// The ISO country code.
        public var phoneNumberCountryCode: ConnectClientTypes.PhoneNumberCountryCode?
        /// The description of the phone number.
        public var phoneNumberDescription: Swift.String?
        /// A unique identifier for the phone number.
        public var phoneNumberId: Swift.String?
        /// The status of the phone number.
        ///
        /// * CLAIMED means the previous [ClaimPhoneNumber](https://docs.aws.amazon.com/connect/latest/APIReference/API_ClaimPhoneNumber.html) or [UpdatePhoneNumber](https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumber.html) operation succeeded.
        ///
        /// * IN_PROGRESS means a [ClaimPhoneNumber](https://docs.aws.amazon.com/connect/latest/APIReference/API_ClaimPhoneNumber.html), [UpdatePhoneNumber](https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumber.html), or [UpdatePhoneNumberMetadata](https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumberMetadata.html) operation is still in progress and has not yet completed. You can call [DescribePhoneNumber](https://docs.aws.amazon.com/connect/latest/APIReference/API_DescribePhoneNumber.html) at a later time to verify if the previous operation has completed.
        ///
        /// * FAILED indicates that the previous [ClaimPhoneNumber](https://docs.aws.amazon.com/connect/latest/APIReference/API_ClaimPhoneNumber.html) or [UpdatePhoneNumber](https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumber.html) operation has failed. It will include a message indicating the failure reason. A common reason for a failure may be that the TargetArn value you are claiming or updating a phone number to has reached its limit of total claimed numbers. If you received a FAILED status from a ClaimPhoneNumber API call, you have one day to retry claiming the phone number before the number is released back to the inventory for other customers to claim.
        ///
        ///
        /// You will not be billed for the phone number during the 1-day period if number claiming fails.
        public var phoneNumberStatus: ConnectClientTypes.PhoneNumberStatus?
        /// The type of phone number.
        public var phoneNumberType: ConnectClientTypes.PhoneNumberType?
        /// The claimed phone number ARN that was previously imported from the external service, such as Amazon Pinpoint. If it is from Amazon Pinpoint, it looks like the ARN of the phone number that was imported from Amazon Pinpoint.
        public var sourcePhoneNumberArn: Swift.String?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public var tags: [Swift.String:Swift.String]?
        /// The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone number inbound traffic is routed through.
        public var targetArn: Swift.String?

        public init(
            instanceId: Swift.String? = nil,
            phoneNumber: Swift.String? = nil,
            phoneNumberArn: Swift.String? = nil,
            phoneNumberCountryCode: ConnectClientTypes.PhoneNumberCountryCode? = nil,
            phoneNumberDescription: Swift.String? = nil,
            phoneNumberId: Swift.String? = nil,
            phoneNumberStatus: ConnectClientTypes.PhoneNumberStatus? = nil,
            phoneNumberType: ConnectClientTypes.PhoneNumberType? = nil,
            sourcePhoneNumberArn: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            targetArn: Swift.String? = nil
        )
        {
            self.instanceId = instanceId
            self.phoneNumber = phoneNumber
            self.phoneNumberArn = phoneNumberArn
            self.phoneNumberCountryCode = phoneNumberCountryCode
            self.phoneNumberDescription = phoneNumberDescription
            self.phoneNumberId = phoneNumberId
            self.phoneNumberStatus = phoneNumberStatus
            self.phoneNumberType = phoneNumberType
            self.sourcePhoneNumberArn = sourcePhoneNumberArn
            self.tags = tags
            self.targetArn = targetArn
        }
    }

}

extension ConnectClientTypes {
    public enum Comparison: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lt
        case sdkUnknown(Swift.String)

        public static var allCases: [Comparison] {
            return [
                .lt,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lt: return "LT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Comparison(rawValue: rawValue) ?? Comparison.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Operation cannot be performed at this time as there is a conflict with another operation or contact state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectClientTypes.ConnectionData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendee = "Attendee"
        case meeting = "Meeting"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attendee = self.attendee {
            try encodeContainer.encode(attendee, forKey: .attendee)
        }
        if let meeting = self.meeting {
            try encodeContainer.encode(meeting, forKey: .meeting)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attendeeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Attendee.self, forKey: .attendee)
        attendee = attendeeDecoded
        let meetingDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Meeting.self, forKey: .meeting)
        meeting = meetingDecoded
    }
}

extension ConnectClientTypes {
    /// Information required to join the call.
    public struct ConnectionData: Swift.Equatable {
        /// The attendee information, including attendee ID and join token.
        public var attendee: ConnectClientTypes.Attendee?
        /// A meeting created using the Amazon Chime SDK.
        public var meeting: ConnectClientTypes.Meeting?

        public init(
            attendee: ConnectClientTypes.Attendee? = nil,
            meeting: ConnectClientTypes.Meeting? = nil
        )
        {
            self.attendee = attendee
            self.meeting = meeting
        }
    }

}

extension ConnectClientTypes.Contact: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentInfo = "AgentInfo"
        case arn = "Arn"
        case channel = "Channel"
        case description = "Description"
        case disconnectTimestamp = "DisconnectTimestamp"
        case id = "Id"
        case initialContactId = "InitialContactId"
        case initiationMethod = "InitiationMethod"
        case initiationTimestamp = "InitiationTimestamp"
        case lastPausedTimestamp = "LastPausedTimestamp"
        case lastResumedTimestamp = "LastResumedTimestamp"
        case lastUpdateTimestamp = "LastUpdateTimestamp"
        case name = "Name"
        case previousContactId = "PreviousContactId"
        case queueInfo = "QueueInfo"
        case relatedContactId = "RelatedContactId"
        case scheduledTimestamp = "ScheduledTimestamp"
        case tags = "Tags"
        case totalPauseCount = "TotalPauseCount"
        case totalPauseDurationInSeconds = "TotalPauseDurationInSeconds"
        case wisdomInfo = "WisdomInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentInfo = self.agentInfo {
            try encodeContainer.encode(agentInfo, forKey: .agentInfo)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let channel = self.channel {
            try encodeContainer.encode(channel.rawValue, forKey: .channel)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let disconnectTimestamp = self.disconnectTimestamp {
            try encodeContainer.encodeTimestamp(disconnectTimestamp, format: .epochSeconds, forKey: .disconnectTimestamp)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let initialContactId = self.initialContactId {
            try encodeContainer.encode(initialContactId, forKey: .initialContactId)
        }
        if let initiationMethod = self.initiationMethod {
            try encodeContainer.encode(initiationMethod.rawValue, forKey: .initiationMethod)
        }
        if let initiationTimestamp = self.initiationTimestamp {
            try encodeContainer.encodeTimestamp(initiationTimestamp, format: .epochSeconds, forKey: .initiationTimestamp)
        }
        if let lastPausedTimestamp = self.lastPausedTimestamp {
            try encodeContainer.encodeTimestamp(lastPausedTimestamp, format: .epochSeconds, forKey: .lastPausedTimestamp)
        }
        if let lastResumedTimestamp = self.lastResumedTimestamp {
            try encodeContainer.encodeTimestamp(lastResumedTimestamp, format: .epochSeconds, forKey: .lastResumedTimestamp)
        }
        if let lastUpdateTimestamp = self.lastUpdateTimestamp {
            try encodeContainer.encodeTimestamp(lastUpdateTimestamp, format: .epochSeconds, forKey: .lastUpdateTimestamp)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let previousContactId = self.previousContactId {
            try encodeContainer.encode(previousContactId, forKey: .previousContactId)
        }
        if let queueInfo = self.queueInfo {
            try encodeContainer.encode(queueInfo, forKey: .queueInfo)
        }
        if let relatedContactId = self.relatedContactId {
            try encodeContainer.encode(relatedContactId, forKey: .relatedContactId)
        }
        if let scheduledTimestamp = self.scheduledTimestamp {
            try encodeContainer.encodeTimestamp(scheduledTimestamp, format: .epochSeconds, forKey: .scheduledTimestamp)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, contactTagMap0) in tags {
                try tagsContainer.encode(contactTagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let totalPauseCount = self.totalPauseCount {
            try encodeContainer.encode(totalPauseCount, forKey: .totalPauseCount)
        }
        if let totalPauseDurationInSeconds = self.totalPauseDurationInSeconds {
            try encodeContainer.encode(totalPauseDurationInSeconds, forKey: .totalPauseDurationInSeconds)
        }
        if let wisdomInfo = self.wisdomInfo {
            try encodeContainer.encode(wisdomInfo, forKey: .wisdomInfo)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let initialContactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initialContactId)
        initialContactId = initialContactIdDecoded
        let previousContactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .previousContactId)
        previousContactId = previousContactIdDecoded
        let initiationMethodDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ContactInitiationMethod.self, forKey: .initiationMethod)
        initiationMethod = initiationMethodDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let channelDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Channel.self, forKey: .channel)
        channel = channelDecoded
        let queueInfoDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.QueueInfo.self, forKey: .queueInfo)
        queueInfo = queueInfoDecoded
        let agentInfoDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.AgentInfo.self, forKey: .agentInfo)
        agentInfo = agentInfoDecoded
        let initiationTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .initiationTimestamp)
        initiationTimestamp = initiationTimestampDecoded
        let disconnectTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .disconnectTimestamp)
        disconnectTimestamp = disconnectTimestampDecoded
        let lastUpdateTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateTimestamp)
        lastUpdateTimestamp = lastUpdateTimestampDecoded
        let lastPausedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastPausedTimestamp)
        lastPausedTimestamp = lastPausedTimestampDecoded
        let lastResumedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastResumedTimestamp)
        lastResumedTimestamp = lastResumedTimestampDecoded
        let totalPauseCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalPauseCount)
        totalPauseCount = totalPauseCountDecoded
        let totalPauseDurationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalPauseDurationInSeconds)
        totalPauseDurationInSeconds = totalPauseDurationInSecondsDecoded
        let scheduledTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .scheduledTimestamp)
        scheduledTimestamp = scheduledTimestampDecoded
        let relatedContactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relatedContactId)
        relatedContactId = relatedContactIdDecoded
        let wisdomInfoDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.WisdomInfo.self, forKey: .wisdomInfo)
        wisdomInfo = wisdomInfoDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, contacttagvalue0) in tagsContainer {
                if let contacttagvalue0 = contacttagvalue0 {
                    tagsDecoded0?[key0] = contacttagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ConnectClientTypes {
    /// Contains information about a contact.
    public struct Contact: Swift.Equatable {
        /// Information about the agent who accepted the contact.
        public var agentInfo: ConnectClientTypes.AgentInfo?
        /// The Amazon Resource Name (ARN) for the contact.
        public var arn: Swift.String?
        /// How the contact reached your contact center.
        public var channel: ConnectClientTypes.Channel?
        /// The description of the contact.
        public var description: Swift.String?
        /// The timestamp when the customer endpoint disconnected from Amazon Connect.
        public var disconnectTimestamp: ClientRuntime.Date?
        /// The identifier for the contact.
        public var id: Swift.String?
        /// If this contact is related to other contacts, this is the ID of the initial contact.
        public var initialContactId: Swift.String?
        /// Indicates how the contact was initiated.
        public var initiationMethod: ConnectClientTypes.ContactInitiationMethod?
        /// The date and time this contact was initiated, in UTC time. For INBOUND, this is when the contact arrived. For OUTBOUND, this is when the agent began dialing. For CALLBACK, this is when the callback contact was created. For TRANSFER and QUEUE_TRANSFER, this is when the transfer was initiated. For API, this is when the request arrived. For EXTERNAL_OUTBOUND, this is when the agent started dialing the external participant. For MONITOR, this is when the supervisor started listening to a contact.
        public var initiationTimestamp: ClientRuntime.Date?
        /// The timestamp when the contact was last paused.
        public var lastPausedTimestamp: ClientRuntime.Date?
        /// The timestamp when the contact was last resumed.
        public var lastResumedTimestamp: ClientRuntime.Date?
        /// The timestamp when contact was last updated.
        public var lastUpdateTimestamp: ClientRuntime.Date?
        /// The name of the contact.
        public var name: Swift.String?
        /// If this contact is not the first contact, this is the ID of the previous contact.
        public var previousContactId: Swift.String?
        /// If this contact was queued, this contains information about the queue.
        public var queueInfo: ConnectClientTypes.QueueInfo?
        /// The contactId that is [related](https://docs.aws.amazon.com/connect/latest/adminguide/chat-persistence.html#relatedcontactid) to this contact.
        public var relatedContactId: Swift.String?
        /// The timestamp, in Unix epoch time format, at which to start running the inbound flow.
        public var scheduledTimestamp: ClientRuntime.Date?
        /// Tags associated with the contact. This contains both Amazon Web Services generated and user-defined tags.
        public var tags: [Swift.String:Swift.String]?
        /// Total pause count for a contact.
        public var totalPauseCount: Swift.Int?
        /// Total pause duration for a contact in seconds.
        public var totalPauseDurationInSeconds: Swift.Int?
        /// Information about Amazon Connect Wisdom.
        public var wisdomInfo: ConnectClientTypes.WisdomInfo?

        public init(
            agentInfo: ConnectClientTypes.AgentInfo? = nil,
            arn: Swift.String? = nil,
            channel: ConnectClientTypes.Channel? = nil,
            description: Swift.String? = nil,
            disconnectTimestamp: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            initialContactId: Swift.String? = nil,
            initiationMethod: ConnectClientTypes.ContactInitiationMethod? = nil,
            initiationTimestamp: ClientRuntime.Date? = nil,
            lastPausedTimestamp: ClientRuntime.Date? = nil,
            lastResumedTimestamp: ClientRuntime.Date? = nil,
            lastUpdateTimestamp: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            previousContactId: Swift.String? = nil,
            queueInfo: ConnectClientTypes.QueueInfo? = nil,
            relatedContactId: Swift.String? = nil,
            scheduledTimestamp: ClientRuntime.Date? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            totalPauseCount: Swift.Int? = nil,
            totalPauseDurationInSeconds: Swift.Int? = nil,
            wisdomInfo: ConnectClientTypes.WisdomInfo? = nil
        )
        {
            self.agentInfo = agentInfo
            self.arn = arn
            self.channel = channel
            self.description = description
            self.disconnectTimestamp = disconnectTimestamp
            self.id = id
            self.initialContactId = initialContactId
            self.initiationMethod = initiationMethod
            self.initiationTimestamp = initiationTimestamp
            self.lastPausedTimestamp = lastPausedTimestamp
            self.lastResumedTimestamp = lastResumedTimestamp
            self.lastUpdateTimestamp = lastUpdateTimestamp
            self.name = name
            self.previousContactId = previousContactId
            self.queueInfo = queueInfo
            self.relatedContactId = relatedContactId
            self.scheduledTimestamp = scheduledTimestamp
            self.tags = tags
            self.totalPauseCount = totalPauseCount
            self.totalPauseDurationInSeconds = totalPauseDurationInSeconds
            self.wisdomInfo = wisdomInfo
        }
    }

}

extension ConnectClientTypes.ContactDataRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case campaign = "Campaign"
        case customerEndpoint = "CustomerEndpoint"
        case queueId = "QueueId"
        case requestIdentifier = "RequestIdentifier"
        case systemEndpoint = "SystemEndpoint"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let campaign = self.campaign {
            try encodeContainer.encode(campaign, forKey: .campaign)
        }
        if let customerEndpoint = self.customerEndpoint {
            try encodeContainer.encode(customerEndpoint, forKey: .customerEndpoint)
        }
        if let queueId = self.queueId {
            try encodeContainer.encode(queueId, forKey: .queueId)
        }
        if let requestIdentifier = self.requestIdentifier {
            try encodeContainer.encode(requestIdentifier, forKey: .requestIdentifier)
        }
        if let systemEndpoint = self.systemEndpoint {
            try encodeContainer.encode(systemEndpoint, forKey: .systemEndpoint)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let systemEndpointDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Endpoint.self, forKey: .systemEndpoint)
        systemEndpoint = systemEndpointDecoded
        let customerEndpointDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Endpoint.self, forKey: .customerEndpoint)
        customerEndpoint = customerEndpointDecoded
        let requestIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestIdentifier)
        requestIdentifier = requestIdentifierDecoded
        let queueIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueId)
        queueId = queueIdDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let campaignDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Campaign.self, forKey: .campaign)
        campaign = campaignDecoded
    }
}

extension ConnectClientTypes {
    /// Request object with information to create a contact.
    public struct ContactDataRequest: Swift.Equatable {
        /// List of attributes to be stored in a contact.
        public var attributes: [Swift.String:Swift.String]?
        /// Structure to store information associated with a campaign.
        public var campaign: ConnectClientTypes.Campaign?
        /// Endpoint of the customer for which contact will be initiated.
        public var customerEndpoint: ConnectClientTypes.Endpoint?
        /// The identifier of the queue associated with the Amazon Connect instance in which contacts that are created will be queued.
        public var queueId: Swift.String?
        /// Identifier to uniquely identify individual requests in the batch.
        public var requestIdentifier: Swift.String?
        /// Endpoint associated with the Amazon Connect instance from which outbound contact will be initiated for the campaign.
        public var systemEndpoint: ConnectClientTypes.Endpoint?

        public init(
            attributes: [Swift.String:Swift.String]? = nil,
            campaign: ConnectClientTypes.Campaign? = nil,
            customerEndpoint: ConnectClientTypes.Endpoint? = nil,
            queueId: Swift.String? = nil,
            requestIdentifier: Swift.String? = nil,
            systemEndpoint: ConnectClientTypes.Endpoint? = nil
        )
        {
            self.attributes = attributes
            self.campaign = campaign
            self.customerEndpoint = customerEndpoint
            self.queueId = queueId
            self.requestIdentifier = requestIdentifier
            self.systemEndpoint = systemEndpoint
        }
    }

}

extension ConnectClientTypes.ContactFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactStates = "ContactStates"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactStates = contactStates {
            var contactStatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .contactStates)
            for contactstate0 in contactStates {
                try contactStatesContainer.encode(contactstate0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactStatesContainer = try containerValues.decodeIfPresent([ConnectClientTypes.ContactState?].self, forKey: .contactStates)
        var contactStatesDecoded0:[ConnectClientTypes.ContactState]? = nil
        if let contactStatesContainer = contactStatesContainer {
            contactStatesDecoded0 = [ConnectClientTypes.ContactState]()
            for enum0 in contactStatesContainer {
                if let enum0 = enum0 {
                    contactStatesDecoded0?.append(enum0)
                }
            }
        }
        contactStates = contactStatesDecoded0
    }
}

extension ConnectClientTypes {
    /// Filters user data based on the contact information that is associated to the users. It contains a list of [contact states](https://docs.aws.amazon.com/connect/latest/adminguide/about-contact-states.html).
    public struct ContactFilter: Swift.Equatable {
        /// A list of up to 9 [contact states](https://docs.aws.amazon.com/connect/latest/adminguide/about-contact-states.html).
        public var contactStates: [ConnectClientTypes.ContactState]?

        public init(
            contactStates: [ConnectClientTypes.ContactState]? = nil
        )
        {
            self.contactStates = contactStates
        }
    }

}

extension ConnectClientTypes.ContactFlow: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case content = "Content"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case state = "State"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ContactFlowType.self, forKey: .type)
        type = typeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ContactFlowState.self, forKey: .state)
        state = stateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ConnectClientTypes {
    /// Contains information about a flow.
    public struct ContactFlow: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the flow.
        public var arn: Swift.String?
        /// The JSON string that represents the content of the flow. For an example, see [Example flow in Amazon Connect Flow language](https://docs.aws.amazon.com/connect/latest/APIReference/flow-language-example.html). Length Constraints: Minimum length of 1. Maximum length of 256000.
        public var content: Swift.String?
        /// The description of the flow.
        public var description: Swift.String?
        /// The identifier of the flow.
        public var id: Swift.String?
        /// The name of the flow.
        public var name: Swift.String?
        /// The type of flow.
        public var state: ConnectClientTypes.ContactFlowState?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public var tags: [Swift.String:Swift.String]?
        /// The type of the flow. For descriptions of the available types, see [Choose a flow type](https://docs.aws.amazon.com/connect/latest/adminguide/create-contact-flow.html#contact-flow-types) in the Amazon Connect Administrator Guide.
        public var type: ConnectClientTypes.ContactFlowType?

        public init(
            arn: Swift.String? = nil,
            content: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            state: ConnectClientTypes.ContactFlowState? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: ConnectClientTypes.ContactFlowType? = nil
        )
        {
            self.arn = arn
            self.content = content
            self.description = description
            self.id = id
            self.name = name
            self.state = state
            self.tags = tags
            self.type = type
        }
    }

}

extension ConnectClientTypes.ContactFlowModule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case content = "Content"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case state = "State"
        case status = "Status"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ContactFlowModuleState.self, forKey: .state)
        state = stateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ContactFlowModuleStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ConnectClientTypes {
    /// Contains information about a flow module.
    public struct ContactFlowModule: Swift.Equatable {
        /// The Amazon Resource Name (ARN).
        public var arn: Swift.String?
        /// The JSON string that represents the content of the flow. For an example, see [Example flow in Amazon Connect Flow language](https://docs.aws.amazon.com/connect/latest/APIReference/flow-language-example.html).
        public var content: Swift.String?
        /// The description of the flow module.
        public var description: Swift.String?
        /// The identifier of the flow module.
        public var id: Swift.String?
        /// The name of the flow module.
        public var name: Swift.String?
        /// The type of flow module.
        public var state: ConnectClientTypes.ContactFlowModuleState?
        /// The status of the flow module.
        public var status: ConnectClientTypes.ContactFlowModuleStatus?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            content: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            state: ConnectClientTypes.ContactFlowModuleState? = nil,
            status: ConnectClientTypes.ContactFlowModuleStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.content = content
            self.description = description
            self.id = id
            self.name = name
            self.state = state
            self.status = status
            self.tags = tags
        }
    }

}

extension ConnectClientTypes {
    public enum ContactFlowModuleState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case archived
        case sdkUnknown(Swift.String)

        public static var allCases: [ContactFlowModuleState] {
            return [
                .active,
                .archived,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .archived: return "ARCHIVED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContactFlowModuleState(rawValue: rawValue) ?? ContactFlowModuleState.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes {
    public enum ContactFlowModuleStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case published
        case saved
        case sdkUnknown(Swift.String)

        public static var allCases: [ContactFlowModuleStatus] {
            return [
                .published,
                .saved,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .published: return "PUBLISHED"
            case .saved: return "SAVED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContactFlowModuleStatus(rawValue: rawValue) ?? ContactFlowModuleStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.ContactFlowModuleSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ContactFlowModuleState.self, forKey: .state)
        state = stateDecoded
    }
}

extension ConnectClientTypes {
    /// Contains summary information about a flow.
    public struct ContactFlowModuleSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the flow module.
        public var arn: Swift.String?
        /// The identifier of the flow module.
        public var id: Swift.String?
        /// The name of the flow module.
        public var name: Swift.String?
        /// The type of flow module.
        public var state: ConnectClientTypes.ContactFlowModuleState?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            state: ConnectClientTypes.ContactFlowModuleState? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.name = name
            self.state = state
        }
    }

}

extension ContactFlowNotPublishedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ContactFlowNotPublishedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The flow has not been published.
public struct ContactFlowNotPublishedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ContactFlowNotPublishedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ContactFlowNotPublishedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ContactFlowNotPublishedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectClientTypes {
    public enum ContactFlowState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case archived
        case sdkUnknown(Swift.String)

        public static var allCases: [ContactFlowState] {
            return [
                .active,
                .archived,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .archived: return "ARCHIVED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContactFlowState(rawValue: rawValue) ?? ContactFlowState.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.ContactFlowSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case contactFlowState = "ContactFlowState"
        case contactFlowType = "ContactFlowType"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let contactFlowState = self.contactFlowState {
            try encodeContainer.encode(contactFlowState.rawValue, forKey: .contactFlowState)
        }
        if let contactFlowType = self.contactFlowType {
            try encodeContainer.encode(contactFlowType.rawValue, forKey: .contactFlowType)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let contactFlowTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ContactFlowType.self, forKey: .contactFlowType)
        contactFlowType = contactFlowTypeDecoded
        let contactFlowStateDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ContactFlowState.self, forKey: .contactFlowState)
        contactFlowState = contactFlowStateDecoded
    }
}

extension ConnectClientTypes {
    /// Contains summary information about a flow. You can also create and update flows using the [Amazon Connect Flow language](https://docs.aws.amazon.com/connect/latest/APIReference/flow-language.html).
    public struct ContactFlowSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the flow.
        public var arn: Swift.String?
        /// The type of flow.
        public var contactFlowState: ConnectClientTypes.ContactFlowState?
        /// The type of flow.
        public var contactFlowType: ConnectClientTypes.ContactFlowType?
        /// The identifier of the flow.
        public var id: Swift.String?
        /// The name of the flow.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            contactFlowState: ConnectClientTypes.ContactFlowState? = nil,
            contactFlowType: ConnectClientTypes.ContactFlowType? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.contactFlowState = contactFlowState
            self.contactFlowType = contactFlowType
            self.id = id
            self.name = name
        }
    }

}

extension ConnectClientTypes {
    public enum ContactFlowType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case agentHold
        case agentTransfer
        case agentWhisper
        case contactFlow
        case customerHold
        case customerQueue
        case customerWhisper
        case outboundWhisper
        case queueTransfer
        case sdkUnknown(Swift.String)

        public static var allCases: [ContactFlowType] {
            return [
                .agentHold,
                .agentTransfer,
                .agentWhisper,
                .contactFlow,
                .customerHold,
                .customerQueue,
                .customerWhisper,
                .outboundWhisper,
                .queueTransfer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agentHold: return "AGENT_HOLD"
            case .agentTransfer: return "AGENT_TRANSFER"
            case .agentWhisper: return "AGENT_WHISPER"
            case .contactFlow: return "CONTACT_FLOW"
            case .customerHold: return "CUSTOMER_HOLD"
            case .customerQueue: return "CUSTOMER_QUEUE"
            case .customerWhisper: return "CUSTOMER_WHISPER"
            case .outboundWhisper: return "OUTBOUND_WHISPER"
            case .queueTransfer: return "QUEUE_TRANSFER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContactFlowType(rawValue: rawValue) ?? ContactFlowType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes {
    public enum ContactInitiationMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case api
        case callback
        case disconnect
        case externalOutbound
        case inbound
        case monitor
        case outbound
        case queueTransfer
        case transfer
        case sdkUnknown(Swift.String)

        public static var allCases: [ContactInitiationMethod] {
            return [
                .api,
                .callback,
                .disconnect,
                .externalOutbound,
                .inbound,
                .monitor,
                .outbound,
                .queueTransfer,
                .transfer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .api: return "API"
            case .callback: return "CALLBACK"
            case .disconnect: return "DISCONNECT"
            case .externalOutbound: return "EXTERNAL_OUTBOUND"
            case .inbound: return "INBOUND"
            case .monitor: return "MONITOR"
            case .outbound: return "OUTBOUND"
            case .queueTransfer: return "QUEUE_TRANSFER"
            case .transfer: return "TRANSFER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContactInitiationMethod(rawValue: rawValue) ?? ContactInitiationMethod.sdkUnknown(rawValue)
        }
    }
}

extension ContactNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ContactNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The contact with the specified ID is not active or does not exist. Applies to Voice calls only, not to Chat or Task contacts.
public struct ContactNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ContactNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ContactNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ContactNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectClientTypes {
    public enum ContactState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connected
        case connectedOnhold
        case connecting
        case ended
        case error
        case incoming
        case missed
        case pending
        case rejected
        case sdkUnknown(Swift.String)

        public static var allCases: [ContactState] {
            return [
                .connected,
                .connectedOnhold,
                .connecting,
                .ended,
                .error,
                .incoming,
                .missed,
                .pending,
                .rejected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connected: return "CONNECTED"
            case .connectedOnhold: return "CONNECTED_ONHOLD"
            case .connecting: return "CONNECTING"
            case .ended: return "ENDED"
            case .error: return "ERROR"
            case .incoming: return "INCOMING"
            case .missed: return "MISSED"
            case .pending: return "PENDING"
            case .rejected: return "REJECTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContactState(rawValue: rawValue) ?? ContactState.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.ControlPlaneTagFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case andConditions = "AndConditions"
        case orConditions = "OrConditions"
        case tagCondition = "TagCondition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let andConditions = andConditions {
            var andConditionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .andConditions)
            for tagcondition0 in andConditions {
                try andConditionsContainer.encode(tagcondition0)
            }
        }
        if let orConditions = orConditions {
            var orConditionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .orConditions)
            for tagandconditionlist0 in orConditions {
                var tagandconditionlist0Container = orConditionsContainer.nestedUnkeyedContainer()
                for tagcondition1 in tagandconditionlist0 {
                    try tagandconditionlist0Container.encode(tagcondition1)
                }
            }
        }
        if let tagCondition = self.tagCondition {
            try encodeContainer.encode(tagCondition, forKey: .tagCondition)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orConditionsContainer = try containerValues.decodeIfPresent([[ConnectClientTypes.TagCondition?]?].self, forKey: .orConditions)
        var orConditionsDecoded0:[[ConnectClientTypes.TagCondition]]? = nil
        if let orConditionsContainer = orConditionsContainer {
            orConditionsDecoded0 = [[ConnectClientTypes.TagCondition]]()
            for list0 in orConditionsContainer {
                var list0Decoded0: [ConnectClientTypes.TagCondition]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [ConnectClientTypes.TagCondition]()
                    for structure1 in list0 {
                        if let structure1 = structure1 {
                            list0Decoded0?.append(structure1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    orConditionsDecoded0?.append(list0Decoded0)
                }
            }
        }
        orConditions = orConditionsDecoded0
        let andConditionsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.TagCondition?].self, forKey: .andConditions)
        var andConditionsDecoded0:[ConnectClientTypes.TagCondition]? = nil
        if let andConditionsContainer = andConditionsContainer {
            andConditionsDecoded0 = [ConnectClientTypes.TagCondition]()
            for structure0 in andConditionsContainer {
                if let structure0 = structure0 {
                    andConditionsDecoded0?.append(structure0)
                }
            }
        }
        andConditions = andConditionsDecoded0
        let tagConditionDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.TagCondition.self, forKey: .tagCondition)
        tagCondition = tagConditionDecoded
    }
}

extension ConnectClientTypes {
    /// An object that can be used to specify Tag conditions inside the SearchFilter. This accepts an OR of AND (List of List) input where:
    ///
    /// * Top level list specifies conditions that need to be applied with OR operator
    ///
    /// * Inner list specifies conditions that need to be applied with AND operator.
    public struct ControlPlaneTagFilter: Swift.Equatable {
        /// A list of conditions which would be applied together with an AND condition.
        public var andConditions: [ConnectClientTypes.TagCondition]?
        /// A list of conditions which would be applied together with an OR condition.
        public var orConditions: [[ConnectClientTypes.TagCondition]]?
        /// A leaf node condition which can be used to specify a tag condition.
        public var tagCondition: ConnectClientTypes.TagCondition?

        public init(
            andConditions: [ConnectClientTypes.TagCondition]? = nil,
            orConditions: [[ConnectClientTypes.TagCondition]]? = nil,
            tagCondition: ConnectClientTypes.TagCondition? = nil
        )
        {
            self.andConditions = andConditions
            self.orConditions = orConditions
            self.tagCondition = tagCondition
        }
    }

}

extension CreateAgentStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case displayOrder = "DisplayOrder"
        case name = "Name"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayOrder = self.displayOrder {
            try encodeContainer.encode(displayOrder, forKey: .displayOrder)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateAgentStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/agent-status/\(instanceId.urlPercentEncoding())"
    }
}

public struct CreateAgentStatusInput: Swift.Equatable {
    /// The description of the status.
    public var description: Swift.String?
    /// The display order of the status.
    public var displayOrder: Swift.Int?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the status.
    /// This member is required.
    public var name: Swift.String?
    /// The state of the status.
    /// This member is required.
    public var state: ConnectClientTypes.AgentStatusState?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String:Swift.String]?

    public init(
        description: Swift.String? = nil,
        displayOrder: Swift.Int? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        state: ConnectClientTypes.AgentStatusState? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.displayOrder = displayOrder
        self.instanceId = instanceId
        self.name = name
        self.state = state
        self.tags = tags
    }
}

struct CreateAgentStatusInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let state: ConnectClientTypes.AgentStatusState?
    let displayOrder: Swift.Int?
    let tags: [Swift.String:Swift.String]?
}

extension CreateAgentStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case displayOrder = "DisplayOrder"
        case name = "Name"
        case state = "State"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.AgentStatusState.self, forKey: .state)
        state = stateDecoded
        let displayOrderDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .displayOrder)
        displayOrder = displayOrderDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAgentStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAgentStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentStatusARN = output.agentStatusARN
            self.agentStatusId = output.agentStatusId
        } else {
            self.agentStatusARN = nil
            self.agentStatusId = nil
        }
    }
}

public struct CreateAgentStatusOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the agent status.
    public var agentStatusARN: Swift.String?
    /// The identifier of the agent status.
    public var agentStatusId: Swift.String?

    public init(
        agentStatusARN: Swift.String? = nil,
        agentStatusId: Swift.String? = nil
    )
    {
        self.agentStatusARN = agentStatusARN
        self.agentStatusId = agentStatusId
    }
}

struct CreateAgentStatusOutputBody: Swift.Equatable {
    let agentStatusARN: Swift.String?
    let agentStatusId: Swift.String?
}

extension CreateAgentStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentStatusARN = "AgentStatusARN"
        case agentStatusId = "AgentStatusId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentStatusARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentStatusARN)
        agentStatusARN = agentStatusARNDecoded
        let agentStatusIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentStatusId)
        agentStatusId = agentStatusIdDecoded
    }
}

enum CreateAgentStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DuplicateResourceException": return try await DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectClientTypes.CreateCaseActionDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields = "Fields"
        case templateId = "TemplateId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fields = fields {
            var fieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fields)
            for fieldvalue0 in fields {
                try fieldsContainer.encode(fieldvalue0)
            }
        }
        if let templateId = self.templateId {
            try encodeContainer.encode(templateId, forKey: .templateId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.FieldValue?].self, forKey: .fields)
        var fieldsDecoded0:[ConnectClientTypes.FieldValue]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [ConnectClientTypes.FieldValue]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
    }
}

extension ConnectClientTypes {
    /// The CreateCase action definition.
    public struct CreateCaseActionDefinition: Swift.Equatable {
        /// An array of objects with Field ID and Value data.
        /// This member is required.
        public var fields: [ConnectClientTypes.FieldValue]?
        /// A unique identifier of a template.
        /// This member is required.
        public var templateId: Swift.String?

        public init(
            fields: [ConnectClientTypes.FieldValue]? = nil,
            templateId: Swift.String? = nil
        )
        {
            self.fields = fields
            self.templateId = templateId
        }
    }

}

extension CreateContactFlowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateContactFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/contact-flows/\(instanceId.urlPercentEncoding())"
    }
}

public struct CreateContactFlowInput: Swift.Equatable {
    /// The JSON string that represents the content of the flow. For an example, see [Example flow in Amazon Connect Flow language](https://docs.aws.amazon.com/connect/latest/APIReference/flow-language-example.html). Length Constraints: Minimum length of 1. Maximum length of 256000.
    /// This member is required.
    public var content: Swift.String?
    /// The description of the flow.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the flow.
    /// This member is required.
    public var name: Swift.String?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String:Swift.String]?
    /// The type of the flow. For descriptions of the available types, see [Choose a flow type](https://docs.aws.amazon.com/connect/latest/adminguide/create-contact-flow.html#contact-flow-types) in the Amazon Connect Administrator Guide.
    /// This member is required.
    public var type: ConnectClientTypes.ContactFlowType?

    public init(
        content: Swift.String? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: ConnectClientTypes.ContactFlowType? = nil
    )
    {
        self.content = content
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.tags = tags
        self.type = type
    }
}

struct CreateContactFlowInputBody: Swift.Equatable {
    let name: Swift.String?
    let type: ConnectClientTypes.ContactFlowType?
    let description: Swift.String?
    let content: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateContactFlowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ContactFlowType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateContactFlowModuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case content = "Content"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateContactFlowModuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/contact-flow-modules/\(instanceId.urlPercentEncoding())"
    }
}

public struct CreateContactFlowModuleInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The JSON string that represents the content of the flow. For an example, see [Example flow in Amazon Connect Flow language](https://docs.aws.amazon.com/connect/latest/APIReference/flow-language-example.html).
    /// This member is required.
    public var content: Swift.String?
    /// The description of the flow module.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the flow module.
    /// This member is required.
    public var name: Swift.String?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        content: Swift.String? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.content = content
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.tags = tags
    }
}

struct CreateContactFlowModuleInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let content: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension CreateContactFlowModuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case content = "Content"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateContactFlowModuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateContactFlowModuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateContactFlowModuleOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the flow module.
    public var arn: Swift.String?
    /// The identifier of the flow module.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateContactFlowModuleOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
}

extension CreateContactFlowModuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum CreateContactFlowModuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DuplicateResourceException": return try await DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IdempotencyException": return try await IdempotencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidContactFlowModuleException": return try await InvalidContactFlowModuleException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateContactFlowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateContactFlowOutputBody = try responseDecoder.decode(responseBody: data)
            self.contactFlowArn = output.contactFlowArn
            self.contactFlowId = output.contactFlowId
        } else {
            self.contactFlowArn = nil
            self.contactFlowId = nil
        }
    }
}

public struct CreateContactFlowOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the flow.
    public var contactFlowArn: Swift.String?
    /// The identifier of the flow.
    public var contactFlowId: Swift.String?

    public init(
        contactFlowArn: Swift.String? = nil,
        contactFlowId: Swift.String? = nil
    )
    {
        self.contactFlowArn = contactFlowArn
        self.contactFlowId = contactFlowId
    }
}

struct CreateContactFlowOutputBody: Swift.Equatable {
    let contactFlowId: Swift.String?
    let contactFlowArn: Swift.String?
}

extension CreateContactFlowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactFlowArn = "ContactFlowArn"
        case contactFlowId = "ContactFlowId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactFlowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactFlowId)
        contactFlowId = contactFlowIdDecoded
        let contactFlowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactFlowArn)
        contactFlowArn = contactFlowArnDecoded
    }
}

enum CreateContactFlowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DuplicateResourceException": return try await DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidContactFlowException": return try await InvalidContactFlowException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateEvaluationFormInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case items = "Items"
        case scoringStrategy = "ScoringStrategy"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for evaluationformitem0 in items {
                try itemsContainer.encode(evaluationformitem0)
            }
        }
        if let scoringStrategy = self.scoringStrategy {
            try encodeContainer.encode(scoringStrategy, forKey: .scoringStrategy)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }
}

extension CreateEvaluationFormInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/evaluation-forms/\(instanceId.urlPercentEncoding())"
    }
}

public struct CreateEvaluationFormInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The description of the evaluation form.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Items that are part of the evaluation form. The total number of sections and questions must not exceed 100 each. Questions must be contained in a section.
    /// This member is required.
    public var items: [ConnectClientTypes.EvaluationFormItem]?
    /// A scoring strategy of the evaluation form.
    public var scoringStrategy: ConnectClientTypes.EvaluationFormScoringStrategy?
    /// A title of the evaluation form.
    /// This member is required.
    public var title: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        items: [ConnectClientTypes.EvaluationFormItem]? = nil,
        scoringStrategy: ConnectClientTypes.EvaluationFormScoringStrategy? = nil,
        title: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.instanceId = instanceId
        self.items = items
        self.scoringStrategy = scoringStrategy
        self.title = title
    }
}

struct CreateEvaluationFormInputBody: Swift.Equatable {
    let title: Swift.String?
    let description: Swift.String?
    let items: [ConnectClientTypes.EvaluationFormItem]?
    let scoringStrategy: ConnectClientTypes.EvaluationFormScoringStrategy?
    let clientToken: Swift.String?
}

extension CreateEvaluationFormInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case items = "Items"
        case scoringStrategy = "ScoringStrategy"
        case title = "Title"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let itemsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.EvaluationFormItem?].self, forKey: .items)
        var itemsDecoded0:[ConnectClientTypes.EvaluationFormItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ConnectClientTypes.EvaluationFormItem]()
            for union0 in itemsContainer {
                if let union0 = union0 {
                    itemsDecoded0?.append(union0)
                }
            }
        }
        items = itemsDecoded0
        let scoringStrategyDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.EvaluationFormScoringStrategy.self, forKey: .scoringStrategy)
        scoringStrategy = scoringStrategyDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateEvaluationFormOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateEvaluationFormOutputBody = try responseDecoder.decode(responseBody: data)
            self.evaluationFormArn = output.evaluationFormArn
            self.evaluationFormId = output.evaluationFormId
        } else {
            self.evaluationFormArn = nil
            self.evaluationFormId = nil
        }
    }
}

public struct CreateEvaluationFormOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the evaluation form resource.
    /// This member is required.
    public var evaluationFormArn: Swift.String?
    /// The unique identifier for the evaluation form.
    /// This member is required.
    public var evaluationFormId: Swift.String?

    public init(
        evaluationFormArn: Swift.String? = nil,
        evaluationFormId: Swift.String? = nil
    )
    {
        self.evaluationFormArn = evaluationFormArn
        self.evaluationFormId = evaluationFormId
    }
}

struct CreateEvaluationFormOutputBody: Swift.Equatable {
    let evaluationFormId: Swift.String?
    let evaluationFormArn: Swift.String?
}

extension CreateEvaluationFormOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationFormArn = "EvaluationFormArn"
        case evaluationFormId = "EvaluationFormId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationFormIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationFormId)
        evaluationFormId = evaluationFormIdDecoded
        let evaluationFormArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationFormArn)
        evaluationFormArn = evaluationFormArnDecoded
    }
}

enum CreateEvaluationFormOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateHoursOfOperationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case config = "Config"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
        case timeZone = "TimeZone"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let config = config {
            var configContainer = encodeContainer.nestedUnkeyedContainer(forKey: .config)
            for hoursofoperationconfig0 in config {
                try configContainer.encode(hoursofoperationconfig0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let timeZone = self.timeZone {
            try encodeContainer.encode(timeZone, forKey: .timeZone)
        }
    }
}

extension CreateHoursOfOperationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/hours-of-operations/\(instanceId.urlPercentEncoding())"
    }
}

public struct CreateHoursOfOperationInput: Swift.Equatable {
    /// Configuration information for the hours of operation: day, start time, and end time.
    /// This member is required.
    public var config: [ConnectClientTypes.HoursOfOperationConfig]?
    /// The description of the hours of operation.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the hours of operation.
    /// This member is required.
    public var name: Swift.String?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String:Swift.String]?
    /// The time zone of the hours of operation.
    /// This member is required.
    public var timeZone: Swift.String?

    public init(
        config: [ConnectClientTypes.HoursOfOperationConfig]? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        timeZone: Swift.String? = nil
    )
    {
        self.config = config
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.tags = tags
        self.timeZone = timeZone
    }
}

struct CreateHoursOfOperationInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let timeZone: Swift.String?
    let config: [ConnectClientTypes.HoursOfOperationConfig]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateHoursOfOperationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case config = "Config"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
        case timeZone = "TimeZone"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let timeZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeZone)
        timeZone = timeZoneDecoded
        let configContainer = try containerValues.decodeIfPresent([ConnectClientTypes.HoursOfOperationConfig?].self, forKey: .config)
        var configDecoded0:[ConnectClientTypes.HoursOfOperationConfig]? = nil
        if let configContainer = configContainer {
            configDecoded0 = [ConnectClientTypes.HoursOfOperationConfig]()
            for structure0 in configContainer {
                if let structure0 = structure0 {
                    configDecoded0?.append(structure0)
                }
            }
        }
        config = configDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateHoursOfOperationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateHoursOfOperationOutputBody = try responseDecoder.decode(responseBody: data)
            self.hoursOfOperationArn = output.hoursOfOperationArn
            self.hoursOfOperationId = output.hoursOfOperationId
        } else {
            self.hoursOfOperationArn = nil
            self.hoursOfOperationId = nil
        }
    }
}

public struct CreateHoursOfOperationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the hours of operation.
    public var hoursOfOperationArn: Swift.String?
    /// The identifier for the hours of operation.
    public var hoursOfOperationId: Swift.String?

    public init(
        hoursOfOperationArn: Swift.String? = nil,
        hoursOfOperationId: Swift.String? = nil
    )
    {
        self.hoursOfOperationArn = hoursOfOperationArn
        self.hoursOfOperationId = hoursOfOperationId
    }
}

struct CreateHoursOfOperationOutputBody: Swift.Equatable {
    let hoursOfOperationId: Swift.String?
    let hoursOfOperationArn: Swift.String?
}

extension CreateHoursOfOperationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hoursOfOperationArn = "HoursOfOperationArn"
        case hoursOfOperationId = "HoursOfOperationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hoursOfOperationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hoursOfOperationId)
        hoursOfOperationId = hoursOfOperationIdDecoded
        let hoursOfOperationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hoursOfOperationArn)
        hoursOfOperationArn = hoursOfOperationArnDecoded
    }
}

enum CreateHoursOfOperationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DuplicateResourceException": return try await DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateInstanceInput(clientToken: \(Swift.String(describing: clientToken)), directoryId: \(Swift.String(describing: directoryId)), identityManagementType: \(Swift.String(describing: identityManagementType)), inboundCallsEnabled: \(Swift.String(describing: inboundCallsEnabled)), outboundCallsEnabled: \(Swift.String(describing: outboundCallsEnabled)), tags: \(Swift.String(describing: tags)), instanceAlias: \"CONTENT_REDACTED\")"}
}

extension CreateInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case directoryId = "DirectoryId"
        case identityManagementType = "IdentityManagementType"
        case inboundCallsEnabled = "InboundCallsEnabled"
        case instanceAlias = "InstanceAlias"
        case outboundCallsEnabled = "OutboundCallsEnabled"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let identityManagementType = self.identityManagementType {
            try encodeContainer.encode(identityManagementType.rawValue, forKey: .identityManagementType)
        }
        if let inboundCallsEnabled = self.inboundCallsEnabled {
            try encodeContainer.encode(inboundCallsEnabled, forKey: .inboundCallsEnabled)
        }
        if let instanceAlias = self.instanceAlias {
            try encodeContainer.encode(instanceAlias, forKey: .instanceAlias)
        }
        if let outboundCallsEnabled = self.outboundCallsEnabled {
            try encodeContainer.encode(outboundCallsEnabled, forKey: .outboundCallsEnabled)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/instance"
    }
}

public struct CreateInstanceInput: Swift.Equatable {
    /// The idempotency token.
    public var clientToken: Swift.String?
    /// The identifier for the directory.
    public var directoryId: Swift.String?
    /// The type of identity management for your Amazon Connect users.
    /// This member is required.
    public var identityManagementType: ConnectClientTypes.DirectoryType?
    /// Your contact center handles incoming contacts.
    /// This member is required.
    public var inboundCallsEnabled: Swift.Bool?
    /// The name for your instance.
    public var instanceAlias: Swift.String?
    /// Your contact center allows outbound calls.
    /// This member is required.
    public var outboundCallsEnabled: Swift.Bool?
    /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        directoryId: Swift.String? = nil,
        identityManagementType: ConnectClientTypes.DirectoryType? = nil,
        inboundCallsEnabled: Swift.Bool? = nil,
        instanceAlias: Swift.String? = nil,
        outboundCallsEnabled: Swift.Bool? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.directoryId = directoryId
        self.identityManagementType = identityManagementType
        self.inboundCallsEnabled = inboundCallsEnabled
        self.instanceAlias = instanceAlias
        self.outboundCallsEnabled = outboundCallsEnabled
        self.tags = tags
    }
}

struct CreateInstanceInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let identityManagementType: ConnectClientTypes.DirectoryType?
    let instanceAlias: Swift.String?
    let directoryId: Swift.String?
    let inboundCallsEnabled: Swift.Bool?
    let outboundCallsEnabled: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
}

extension CreateInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case directoryId = "DirectoryId"
        case identityManagementType = "IdentityManagementType"
        case inboundCallsEnabled = "InboundCallsEnabled"
        case instanceAlias = "InstanceAlias"
        case outboundCallsEnabled = "OutboundCallsEnabled"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let identityManagementTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.DirectoryType.self, forKey: .identityManagementType)
        identityManagementType = identityManagementTypeDecoded
        let instanceAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceAlias)
        instanceAlias = instanceAliasDecoded
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let inboundCallsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .inboundCallsEnabled)
        inboundCallsEnabled = inboundCallsEnabledDecoded
        let outboundCallsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .outboundCallsEnabled)
        outboundCallsEnabled = outboundCallsEnabledDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateInstanceOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the instance.
    public var arn: Swift.String?
    /// The identifier for the instance.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateInstanceOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
}

extension CreateInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum CreateInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateIntegrationAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case integrationArn = "IntegrationArn"
        case integrationType = "IntegrationType"
        case sourceApplicationName = "SourceApplicationName"
        case sourceApplicationUrl = "SourceApplicationUrl"
        case sourceType = "SourceType"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let integrationArn = self.integrationArn {
            try encodeContainer.encode(integrationArn, forKey: .integrationArn)
        }
        if let integrationType = self.integrationType {
            try encodeContainer.encode(integrationType.rawValue, forKey: .integrationType)
        }
        if let sourceApplicationName = self.sourceApplicationName {
            try encodeContainer.encode(sourceApplicationName, forKey: .sourceApplicationName)
        }
        if let sourceApplicationUrl = self.sourceApplicationUrl {
            try encodeContainer.encode(sourceApplicationUrl, forKey: .sourceApplicationUrl)
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateIntegrationAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/integration-associations"
    }
}

public struct CreateIntegrationAssociationInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The Amazon Resource Name (ARN) of the integration. When integrating with Amazon Pinpoint, the Amazon Connect and Amazon Pinpoint instances must be in the same account.
    /// This member is required.
    public var integrationArn: Swift.String?
    /// The type of information to be ingested.
    /// This member is required.
    public var integrationType: ConnectClientTypes.IntegrationType?
    /// The name of the external application. This field is only required for the EVENT integration type.
    public var sourceApplicationName: Swift.String?
    /// The URL for the external application. This field is only required for the EVENT integration type.
    public var sourceApplicationUrl: Swift.String?
    /// The type of the data source. This field is only required for the EVENT integration type.
    public var sourceType: ConnectClientTypes.SourceType?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String:Swift.String]?

    public init(
        instanceId: Swift.String? = nil,
        integrationArn: Swift.String? = nil,
        integrationType: ConnectClientTypes.IntegrationType? = nil,
        sourceApplicationName: Swift.String? = nil,
        sourceApplicationUrl: Swift.String? = nil,
        sourceType: ConnectClientTypes.SourceType? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.instanceId = instanceId
        self.integrationArn = integrationArn
        self.integrationType = integrationType
        self.sourceApplicationName = sourceApplicationName
        self.sourceApplicationUrl = sourceApplicationUrl
        self.sourceType = sourceType
        self.tags = tags
    }
}

struct CreateIntegrationAssociationInputBody: Swift.Equatable {
    let integrationType: ConnectClientTypes.IntegrationType?
    let integrationArn: Swift.String?
    let sourceApplicationUrl: Swift.String?
    let sourceApplicationName: Swift.String?
    let sourceType: ConnectClientTypes.SourceType?
    let tags: [Swift.String:Swift.String]?
}

extension CreateIntegrationAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case integrationArn = "IntegrationArn"
        case integrationType = "IntegrationType"
        case sourceApplicationName = "SourceApplicationName"
        case sourceApplicationUrl = "SourceApplicationUrl"
        case sourceType = "SourceType"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let integrationTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.IntegrationType.self, forKey: .integrationType)
        integrationType = integrationTypeDecoded
        let integrationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationArn)
        integrationArn = integrationArnDecoded
        let sourceApplicationUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceApplicationUrl)
        sourceApplicationUrl = sourceApplicationUrlDecoded
        let sourceApplicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceApplicationName)
        sourceApplicationName = sourceApplicationNameDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateIntegrationAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateIntegrationAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.integrationAssociationArn = output.integrationAssociationArn
            self.integrationAssociationId = output.integrationAssociationId
        } else {
            self.integrationAssociationArn = nil
            self.integrationAssociationId = nil
        }
    }
}

public struct CreateIntegrationAssociationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the association.
    public var integrationAssociationArn: Swift.String?
    /// The identifier for the integration association.
    public var integrationAssociationId: Swift.String?

    public init(
        integrationAssociationArn: Swift.String? = nil,
        integrationAssociationId: Swift.String? = nil
    )
    {
        self.integrationAssociationArn = integrationAssociationArn
        self.integrationAssociationId = integrationAssociationId
    }
}

struct CreateIntegrationAssociationOutputBody: Swift.Equatable {
    let integrationAssociationId: Swift.String?
    let integrationAssociationArn: Swift.String?
}

extension CreateIntegrationAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case integrationAssociationArn = "IntegrationAssociationArn"
        case integrationAssociationId = "IntegrationAssociationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let integrationAssociationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationAssociationId)
        integrationAssociationId = integrationAssociationIdDecoded
        let integrationAssociationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationAssociationArn)
        integrationAssociationArn = integrationAssociationArnDecoded
    }
}

enum CreateIntegrationAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DuplicateResourceException": return try await DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateParticipantInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case contactId = "ContactId"
        case instanceId = "InstanceId"
        case participantDetails = "ParticipantDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let contactId = self.contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let participantDetails = self.participantDetails {
            try encodeContainer.encode(participantDetails, forKey: .participantDetails)
        }
    }
}

extension CreateParticipantInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/contact/create-participant"
    }
}

public struct CreateParticipantInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The identifier of the contact in this instance of Amazon Connect. Only contacts in the CHAT channel are supported.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Information identifying the participant. The only Valid value for ParticipantRole is CUSTOM_BOT. DisplayName is Required.
    /// This member is required.
    public var participantDetails: ConnectClientTypes.ParticipantDetailsToAdd?

    public init(
        clientToken: Swift.String? = nil,
        contactId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        participantDetails: ConnectClientTypes.ParticipantDetailsToAdd? = nil
    )
    {
        self.clientToken = clientToken
        self.contactId = contactId
        self.instanceId = instanceId
        self.participantDetails = participantDetails
    }
}

struct CreateParticipantInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let contactId: Swift.String?
    let clientToken: Swift.String?
    let participantDetails: ConnectClientTypes.ParticipantDetailsToAdd?
}

extension CreateParticipantInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case contactId = "ContactId"
        case instanceId = "InstanceId"
        case participantDetails = "ParticipantDetails"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let participantDetailsDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ParticipantDetailsToAdd.self, forKey: .participantDetails)
        participantDetails = participantDetailsDecoded
    }
}

extension CreateParticipantOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateParticipantOutputBody = try responseDecoder.decode(responseBody: data)
            self.participantCredentials = output.participantCredentials
            self.participantId = output.participantId
        } else {
            self.participantCredentials = nil
            self.participantId = nil
        }
    }
}

public struct CreateParticipantOutput: Swift.Equatable {
    /// The token used by the chat participant to call CreateParticipantConnection. The participant token is valid for the lifetime of a chat participant.
    public var participantCredentials: ConnectClientTypes.ParticipantTokenCredentials?
    /// The identifier for a chat participant. The participantId for a chat participant is the same throughout the chat lifecycle.
    public var participantId: Swift.String?

    public init(
        participantCredentials: ConnectClientTypes.ParticipantTokenCredentials? = nil,
        participantId: Swift.String? = nil
    )
    {
        self.participantCredentials = participantCredentials
        self.participantId = participantId
    }
}

struct CreateParticipantOutputBody: Swift.Equatable {
    let participantCredentials: ConnectClientTypes.ParticipantTokenCredentials?
    let participantId: Swift.String?
}

extension CreateParticipantOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case participantCredentials = "ParticipantCredentials"
        case participantId = "ParticipantId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let participantCredentialsDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ParticipantTokenCredentials.self, forKey: .participantCredentials)
        participantCredentials = participantCredentialsDecoded
        let participantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .participantId)
        participantId = participantIdDecoded
    }
}

enum CreateParticipantOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePersistentContactAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case rehydrationType = "RehydrationType"
        case sourceContactId = "SourceContactId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let rehydrationType = self.rehydrationType {
            try encodeContainer.encode(rehydrationType.rawValue, forKey: .rehydrationType)
        }
        if let sourceContactId = self.sourceContactId {
            try encodeContainer.encode(sourceContactId, forKey: .sourceContactId)
        }
    }
}

extension CreatePersistentContactAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let initialContactId = initialContactId else {
            return nil
        }
        return "/contact/persistent-contact-association/\(instanceId.urlPercentEncoding())/\(initialContactId.urlPercentEncoding())"
    }
}

public struct CreatePersistentContactAssociationInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// This is the contactId of the current contact that the CreatePersistentContactAssociation API is being called from.
    /// This member is required.
    public var initialContactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The contactId chosen for rehydration depends on the type chosen.
    ///
    /// * ENTIRE_PAST_SESSION: Rehydrates a chat from the most recently terminated past chat contact of the specified past ended chat session. To use this type, provide the initialContactId of the past ended chat session in the sourceContactId field. In this type, Amazon Connect determines what the most recent chat contact on the past ended chat session and uses it to start a persistent chat.
    ///
    /// * FROM_SEGMENT: Rehydrates a chat from the specified past chat contact provided in the sourceContactId field.
    ///
    ///
    /// The actual contactId used for rehydration is provided in the response of this API. To illustrate how to use rehydration type, consider the following example: A customer starts a chat session. Agent a1 accepts the chat and a conversation starts between the customer and Agent a1. This first contact creates a contact ID C1. Agent a1 then transfers the chat to Agent a2. This creates another contact ID C2. At this point Agent a2 ends the chat. The customer is forwarded to the disconnect flow for a post chat survey that creates another contact ID C3. After the chat survey, the chat session ends. Later, the customer returns and wants to resume their past chat session. At this point, the customer can have following use cases:
    ///
    /// * Use Case 1: The customer wants to continue the past chat session but they want to hide the post chat survey. For this they will use the following configuration:
    ///
    /// * Configuration
    ///
    /// * SourceContactId = "C2"
    ///
    /// * RehydrationType = "FROM_SEGMENT"
    ///
    ///
    ///
    ///
    /// * Expected behavior
    ///
    /// * This starts a persistent chat session from the specified past ended contact (C2). Transcripts of past chat sessions C2 and C1 are accessible in the current persistent chat session. Note that chat segment C3 is dropped from the persistent chat session.
    ///
    ///
    ///
    ///
    ///
    ///
    ///
    /// * Use Case 2: The customer wants to continue the past chat session and see the transcript of the entire past engagement, including the post chat survey. For this they will use the following configuration:
    ///
    /// * Configuration
    ///
    /// * SourceContactId = "C1"
    ///
    /// * RehydrationType = "ENTIRE_PAST_SESSION"
    ///
    ///
    ///
    ///
    /// * Expected behavior
    ///
    /// * This starts a persistent chat session from the most recently ended chat contact (C3). Transcripts of past chat sessions C3, C2 and C1 are accessible in the current persistent chat session.
    /// This member is required.
    public var rehydrationType: ConnectClientTypes.RehydrationType?
    /// The contactId from which a persistent chat session must be started.
    /// This member is required.
    public var sourceContactId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        initialContactId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        rehydrationType: ConnectClientTypes.RehydrationType? = nil,
        sourceContactId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.initialContactId = initialContactId
        self.instanceId = instanceId
        self.rehydrationType = rehydrationType
        self.sourceContactId = sourceContactId
    }
}

struct CreatePersistentContactAssociationInputBody: Swift.Equatable {
    let rehydrationType: ConnectClientTypes.RehydrationType?
    let sourceContactId: Swift.String?
    let clientToken: Swift.String?
}

extension CreatePersistentContactAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case rehydrationType = "RehydrationType"
        case sourceContactId = "SourceContactId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rehydrationTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.RehydrationType.self, forKey: .rehydrationType)
        rehydrationType = rehydrationTypeDecoded
        let sourceContactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceContactId)
        sourceContactId = sourceContactIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreatePersistentContactAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePersistentContactAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.continuedFromContactId = output.continuedFromContactId
        } else {
            self.continuedFromContactId = nil
        }
    }
}

public struct CreatePersistentContactAssociationOutput: Swift.Equatable {
    /// The contactId from which a persistent chat session is started. This field is populated only for persistent chat.
    public var continuedFromContactId: Swift.String?

    public init(
        continuedFromContactId: Swift.String? = nil
    )
    {
        self.continuedFromContactId = continuedFromContactId
    }
}

struct CreatePersistentContactAssociationOutputBody: Swift.Equatable {
    let continuedFromContactId: Swift.String?
}

extension CreatePersistentContactAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case continuedFromContactId = "ContinuedFromContactId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let continuedFromContactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .continuedFromContactId)
        continuedFromContactId = continuedFromContactIdDecoded
    }
}

enum CreatePersistentContactAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePromptInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case s3Uri = "S3Uri"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let s3Uri = self.s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreatePromptInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/prompts/\(instanceId.urlPercentEncoding())"
    }
}

public struct CreatePromptInput: Swift.Equatable {
    /// The description of the prompt.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the prompt.
    /// This member is required.
    public var name: Swift.String?
    /// The URI for the S3 bucket where the prompt is stored. You can provide S3 pre-signed URLs returned by the [GetPromptFile](https://docs.aws.amazon.com/connect/latest/APIReference/API_GetPromptFile.html) API instead of providing S3 URIs.
    /// This member is required.
    public var s3Uri: Swift.String?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String:Swift.String]?

    public init(
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        s3Uri: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.s3Uri = s3Uri
        self.tags = tags
    }
}

struct CreatePromptInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let s3Uri: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreatePromptInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case s3Uri = "S3Uri"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let s3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePromptOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePromptOutputBody = try responseDecoder.decode(responseBody: data)
            self.promptARN = output.promptARN
            self.promptId = output.promptId
        } else {
            self.promptARN = nil
            self.promptId = nil
        }
    }
}

public struct CreatePromptOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the prompt.
    public var promptARN: Swift.String?
    /// A unique identifier for the prompt.
    public var promptId: Swift.String?

    public init(
        promptARN: Swift.String? = nil,
        promptId: Swift.String? = nil
    )
    {
        self.promptARN = promptARN
        self.promptId = promptId
    }
}

struct CreatePromptOutputBody: Swift.Equatable {
    let promptARN: Swift.String?
    let promptId: Swift.String?
}

extension CreatePromptOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case promptARN = "PromptARN"
        case promptId = "PromptId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let promptARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .promptARN)
        promptARN = promptARNDecoded
        let promptIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .promptId)
        promptId = promptIdDecoded
    }
}

enum CreatePromptOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DuplicateResourceException": return try await DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateQueueInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case hoursOfOperationId = "HoursOfOperationId"
        case maxContacts = "MaxContacts"
        case name = "Name"
        case outboundCallerConfig = "OutboundCallerConfig"
        case quickConnectIds = "QuickConnectIds"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let hoursOfOperationId = self.hoursOfOperationId {
            try encodeContainer.encode(hoursOfOperationId, forKey: .hoursOfOperationId)
        }
        if let maxContacts = self.maxContacts {
            try encodeContainer.encode(maxContacts, forKey: .maxContacts)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outboundCallerConfig = self.outboundCallerConfig {
            try encodeContainer.encode(outboundCallerConfig, forKey: .outboundCallerConfig)
        }
        if let quickConnectIds = quickConnectIds {
            var quickConnectIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .quickConnectIds)
            for quickconnectid0 in quickConnectIds {
                try quickConnectIdsContainer.encode(quickconnectid0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateQueueInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/queues/\(instanceId.urlPercentEncoding())"
    }
}

public struct CreateQueueInput: Swift.Equatable {
    /// The description of the queue.
    public var description: Swift.String?
    /// The identifier for the hours of operation.
    /// This member is required.
    public var hoursOfOperationId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of contacts that can be in the queue before it is considered full.
    public var maxContacts: Swift.Int?
    /// The name of the queue.
    /// This member is required.
    public var name: Swift.String?
    /// The outbound caller ID name, number, and outbound whisper flow.
    public var outboundCallerConfig: ConnectClientTypes.OutboundCallerConfig?
    /// The quick connects available to agents who are working the queue.
    public var quickConnectIds: [Swift.String]?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String:Swift.String]?

    public init(
        description: Swift.String? = nil,
        hoursOfOperationId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        maxContacts: Swift.Int? = nil,
        name: Swift.String? = nil,
        outboundCallerConfig: ConnectClientTypes.OutboundCallerConfig? = nil,
        quickConnectIds: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.hoursOfOperationId = hoursOfOperationId
        self.instanceId = instanceId
        self.maxContacts = maxContacts
        self.name = name
        self.outboundCallerConfig = outboundCallerConfig
        self.quickConnectIds = quickConnectIds
        self.tags = tags
    }
}

struct CreateQueueInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let outboundCallerConfig: ConnectClientTypes.OutboundCallerConfig?
    let hoursOfOperationId: Swift.String?
    let maxContacts: Swift.Int?
    let quickConnectIds: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateQueueInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case hoursOfOperationId = "HoursOfOperationId"
        case maxContacts = "MaxContacts"
        case name = "Name"
        case outboundCallerConfig = "OutboundCallerConfig"
        case quickConnectIds = "QuickConnectIds"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let outboundCallerConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.OutboundCallerConfig.self, forKey: .outboundCallerConfig)
        outboundCallerConfig = outboundCallerConfigDecoded
        let hoursOfOperationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hoursOfOperationId)
        hoursOfOperationId = hoursOfOperationIdDecoded
        let maxContactsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxContacts)
        maxContacts = maxContactsDecoded
        let quickConnectIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .quickConnectIds)
        var quickConnectIdsDecoded0:[Swift.String]? = nil
        if let quickConnectIdsContainer = quickConnectIdsContainer {
            quickConnectIdsDecoded0 = [Swift.String]()
            for string0 in quickConnectIdsContainer {
                if let string0 = string0 {
                    quickConnectIdsDecoded0?.append(string0)
                }
            }
        }
        quickConnectIds = quickConnectIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateQueueOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateQueueOutputBody = try responseDecoder.decode(responseBody: data)
            self.queueArn = output.queueArn
            self.queueId = output.queueId
        } else {
            self.queueArn = nil
            self.queueId = nil
        }
    }
}

public struct CreateQueueOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the queue.
    public var queueArn: Swift.String?
    /// The identifier for the queue.
    public var queueId: Swift.String?

    public init(
        queueArn: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.queueArn = queueArn
        self.queueId = queueId
    }
}

struct CreateQueueOutputBody: Swift.Equatable {
    let queueArn: Swift.String?
    let queueId: Swift.String?
}

extension CreateQueueOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queueArn = "QueueArn"
        case queueId = "QueueId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueArn)
        queueArn = queueArnDecoded
        let queueIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueId)
        queueId = queueIdDecoded
    }
}

enum CreateQueueOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DuplicateResourceException": return try await DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateQuickConnectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case quickConnectConfig = "QuickConnectConfig"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let quickConnectConfig = self.quickConnectConfig {
            try encodeContainer.encode(quickConnectConfig, forKey: .quickConnectConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateQuickConnectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/quick-connects/\(instanceId.urlPercentEncoding())"
    }
}

public struct CreateQuickConnectInput: Swift.Equatable {
    /// The description of the quick connect.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A unique name of the quick connect.
    /// This member is required.
    public var name: Swift.String?
    /// Configuration settings for the quick connect.
    /// This member is required.
    public var quickConnectConfig: ConnectClientTypes.QuickConnectConfig?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String:Swift.String]?

    public init(
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        quickConnectConfig: ConnectClientTypes.QuickConnectConfig? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.quickConnectConfig = quickConnectConfig
        self.tags = tags
    }
}

struct CreateQuickConnectInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let quickConnectConfig: ConnectClientTypes.QuickConnectConfig?
    let tags: [Swift.String:Swift.String]?
}

extension CreateQuickConnectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case quickConnectConfig = "QuickConnectConfig"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let quickConnectConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.QuickConnectConfig.self, forKey: .quickConnectConfig)
        quickConnectConfig = quickConnectConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateQuickConnectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateQuickConnectOutputBody = try responseDecoder.decode(responseBody: data)
            self.quickConnectARN = output.quickConnectARN
            self.quickConnectId = output.quickConnectId
        } else {
            self.quickConnectARN = nil
            self.quickConnectId = nil
        }
    }
}

public struct CreateQuickConnectOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the quick connect.
    public var quickConnectARN: Swift.String?
    /// The identifier for the quick connect.
    public var quickConnectId: Swift.String?

    public init(
        quickConnectARN: Swift.String? = nil,
        quickConnectId: Swift.String? = nil
    )
    {
        self.quickConnectARN = quickConnectARN
        self.quickConnectId = quickConnectId
    }
}

struct CreateQuickConnectOutputBody: Swift.Equatable {
    let quickConnectARN: Swift.String?
    let quickConnectId: Swift.String?
}

extension CreateQuickConnectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quickConnectARN = "QuickConnectARN"
        case quickConnectId = "QuickConnectId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quickConnectARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quickConnectARN)
        quickConnectARN = quickConnectARNDecoded
        let quickConnectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quickConnectId)
        quickConnectId = quickConnectIdDecoded
    }
}

enum CreateQuickConnectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DuplicateResourceException": return try await DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateRoutingProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentAvailabilityTimer = "AgentAvailabilityTimer"
        case defaultOutboundQueueId = "DefaultOutboundQueueId"
        case description = "Description"
        case mediaConcurrencies = "MediaConcurrencies"
        case name = "Name"
        case queueConfigs = "QueueConfigs"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentAvailabilityTimer = self.agentAvailabilityTimer {
            try encodeContainer.encode(agentAvailabilityTimer.rawValue, forKey: .agentAvailabilityTimer)
        }
        if let defaultOutboundQueueId = self.defaultOutboundQueueId {
            try encodeContainer.encode(defaultOutboundQueueId, forKey: .defaultOutboundQueueId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let mediaConcurrencies = mediaConcurrencies {
            var mediaConcurrenciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mediaConcurrencies)
            for mediaconcurrency0 in mediaConcurrencies {
                try mediaConcurrenciesContainer.encode(mediaconcurrency0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let queueConfigs = queueConfigs {
            var queueConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queueConfigs)
            for routingprofilequeueconfig0 in queueConfigs {
                try queueConfigsContainer.encode(routingprofilequeueconfig0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateRoutingProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/routing-profiles/\(instanceId.urlPercentEncoding())"
    }
}

public struct CreateRoutingProfileInput: Swift.Equatable {
    /// Whether agents with this routing profile will have their routing order calculated based on longest idle time or time since their last inbound contact.
    public var agentAvailabilityTimer: ConnectClientTypes.AgentAvailabilityTimer?
    /// The default outbound queue for the routing profile.
    /// This member is required.
    public var defaultOutboundQueueId: Swift.String?
    /// Description of the routing profile. Must not be more than 250 characters.
    /// This member is required.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The channels that agents can handle in the Contact Control Panel (CCP) for this routing profile.
    /// This member is required.
    public var mediaConcurrencies: [ConnectClientTypes.MediaConcurrency]?
    /// The name of the routing profile. Must not be more than 127 characters.
    /// This member is required.
    public var name: Swift.String?
    /// The inbound queues associated with the routing profile. If no queue is added, the agent can make only outbound calls. The limit of 10 array members applies to the maximum number of RoutingProfileQueueConfig objects that can be passed during a CreateRoutingProfile API request. It is different from the quota of 50 queues per routing profile per instance that is listed in [Amazon Connect service quotas](https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html).
    public var queueConfigs: [ConnectClientTypes.RoutingProfileQueueConfig]?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String:Swift.String]?

    public init(
        agentAvailabilityTimer: ConnectClientTypes.AgentAvailabilityTimer? = nil,
        defaultOutboundQueueId: Swift.String? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        mediaConcurrencies: [ConnectClientTypes.MediaConcurrency]? = nil,
        name: Swift.String? = nil,
        queueConfigs: [ConnectClientTypes.RoutingProfileQueueConfig]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.agentAvailabilityTimer = agentAvailabilityTimer
        self.defaultOutboundQueueId = defaultOutboundQueueId
        self.description = description
        self.instanceId = instanceId
        self.mediaConcurrencies = mediaConcurrencies
        self.name = name
        self.queueConfigs = queueConfigs
        self.tags = tags
    }
}

struct CreateRoutingProfileInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let defaultOutboundQueueId: Swift.String?
    let queueConfigs: [ConnectClientTypes.RoutingProfileQueueConfig]?
    let mediaConcurrencies: [ConnectClientTypes.MediaConcurrency]?
    let tags: [Swift.String:Swift.String]?
    let agentAvailabilityTimer: ConnectClientTypes.AgentAvailabilityTimer?
}

extension CreateRoutingProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentAvailabilityTimer = "AgentAvailabilityTimer"
        case defaultOutboundQueueId = "DefaultOutboundQueueId"
        case description = "Description"
        case mediaConcurrencies = "MediaConcurrencies"
        case name = "Name"
        case queueConfigs = "QueueConfigs"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let defaultOutboundQueueIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultOutboundQueueId)
        defaultOutboundQueueId = defaultOutboundQueueIdDecoded
        let queueConfigsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.RoutingProfileQueueConfig?].self, forKey: .queueConfigs)
        var queueConfigsDecoded0:[ConnectClientTypes.RoutingProfileQueueConfig]? = nil
        if let queueConfigsContainer = queueConfigsContainer {
            queueConfigsDecoded0 = [ConnectClientTypes.RoutingProfileQueueConfig]()
            for structure0 in queueConfigsContainer {
                if let structure0 = structure0 {
                    queueConfigsDecoded0?.append(structure0)
                }
            }
        }
        queueConfigs = queueConfigsDecoded0
        let mediaConcurrenciesContainer = try containerValues.decodeIfPresent([ConnectClientTypes.MediaConcurrency?].self, forKey: .mediaConcurrencies)
        var mediaConcurrenciesDecoded0:[ConnectClientTypes.MediaConcurrency]? = nil
        if let mediaConcurrenciesContainer = mediaConcurrenciesContainer {
            mediaConcurrenciesDecoded0 = [ConnectClientTypes.MediaConcurrency]()
            for structure0 in mediaConcurrenciesContainer {
                if let structure0 = structure0 {
                    mediaConcurrenciesDecoded0?.append(structure0)
                }
            }
        }
        mediaConcurrencies = mediaConcurrenciesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let agentAvailabilityTimerDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.AgentAvailabilityTimer.self, forKey: .agentAvailabilityTimer)
        agentAvailabilityTimer = agentAvailabilityTimerDecoded
    }
}

extension CreateRoutingProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRoutingProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.routingProfileArn = output.routingProfileArn
            self.routingProfileId = output.routingProfileId
        } else {
            self.routingProfileArn = nil
            self.routingProfileId = nil
        }
    }
}

public struct CreateRoutingProfileOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the routing profile.
    public var routingProfileArn: Swift.String?
    /// The identifier of the routing profile.
    public var routingProfileId: Swift.String?

    public init(
        routingProfileArn: Swift.String? = nil,
        routingProfileId: Swift.String? = nil
    )
    {
        self.routingProfileArn = routingProfileArn
        self.routingProfileId = routingProfileId
    }
}

struct CreateRoutingProfileOutputBody: Swift.Equatable {
    let routingProfileArn: Swift.String?
    let routingProfileId: Swift.String?
}

extension CreateRoutingProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routingProfileArn = "RoutingProfileArn"
        case routingProfileId = "RoutingProfileId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routingProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routingProfileArn)
        routingProfileArn = routingProfileArnDecoded
        let routingProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routingProfileId)
        routingProfileId = routingProfileIdDecoded
    }
}

enum CreateRoutingProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DuplicateResourceException": return try await DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case clientToken = "ClientToken"
        case function = "Function"
        case name = "Name"
        case publishStatus = "PublishStatus"
        case triggerEventSource = "TriggerEventSource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for ruleaction0 in actions {
                try actionsContainer.encode(ruleaction0)
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let function = self.function {
            try encodeContainer.encode(function, forKey: .function)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let publishStatus = self.publishStatus {
            try encodeContainer.encode(publishStatus.rawValue, forKey: .publishStatus)
        }
        if let triggerEventSource = self.triggerEventSource {
            try encodeContainer.encode(triggerEventSource, forKey: .triggerEventSource)
        }
    }
}

extension CreateRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/rules/\(instanceId.urlPercentEncoding())"
    }
}

public struct CreateRuleInput: Swift.Equatable {
    /// A list of actions to be run when the rule is triggered.
    /// This member is required.
    public var actions: [ConnectClientTypes.RuleAction]?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The conditions of the rule.
    /// This member is required.
    public var function: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A unique name for the rule.
    /// This member is required.
    public var name: Swift.String?
    /// The publish status of the rule.
    /// This member is required.
    public var publishStatus: ConnectClientTypes.RulePublishStatus?
    /// The event source to trigger the rule.
    /// This member is required.
    public var triggerEventSource: ConnectClientTypes.RuleTriggerEventSource?

    public init(
        actions: [ConnectClientTypes.RuleAction]? = nil,
        clientToken: Swift.String? = nil,
        function: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        publishStatus: ConnectClientTypes.RulePublishStatus? = nil,
        triggerEventSource: ConnectClientTypes.RuleTriggerEventSource? = nil
    )
    {
        self.actions = actions
        self.clientToken = clientToken
        self.function = function
        self.instanceId = instanceId
        self.name = name
        self.publishStatus = publishStatus
        self.triggerEventSource = triggerEventSource
    }
}

struct CreateRuleInputBody: Swift.Equatable {
    let name: Swift.String?
    let triggerEventSource: ConnectClientTypes.RuleTriggerEventSource?
    let function: Swift.String?
    let actions: [ConnectClientTypes.RuleAction]?
    let publishStatus: ConnectClientTypes.RulePublishStatus?
    let clientToken: Swift.String?
}

extension CreateRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case clientToken = "ClientToken"
        case function = "Function"
        case name = "Name"
        case publishStatus = "PublishStatus"
        case triggerEventSource = "TriggerEventSource"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let triggerEventSourceDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.RuleTriggerEventSource.self, forKey: .triggerEventSource)
        triggerEventSource = triggerEventSourceDecoded
        let functionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .function)
        function = functionDecoded
        let actionsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.RuleAction?].self, forKey: .actions)
        var actionsDecoded0:[ConnectClientTypes.RuleAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [ConnectClientTypes.RuleAction]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let publishStatusDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.RulePublishStatus.self, forKey: .publishStatus)
        publishStatus = publishStatusDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.ruleArn = output.ruleArn
            self.ruleId = output.ruleId
        } else {
            self.ruleArn = nil
            self.ruleId = nil
        }
    }
}

public struct CreateRuleOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the rule.
    /// This member is required.
    public var ruleArn: Swift.String?
    /// A unique identifier for the rule.
    /// This member is required.
    public var ruleId: Swift.String?

    public init(
        ruleArn: Swift.String? = nil,
        ruleId: Swift.String? = nil
    )
    {
        self.ruleArn = ruleArn
        self.ruleId = ruleId
    }
}

struct CreateRuleOutputBody: Swift.Equatable {
    let ruleArn: Swift.String?
    let ruleId: Swift.String?
}

extension CreateRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ruleArn = "RuleArn"
        case ruleId = "RuleId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleArn)
        ruleArn = ruleArnDecoded
        let ruleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
    }
}

enum CreateRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSecurityProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedAccessControlTags = "AllowedAccessControlTags"
        case applications = "Applications"
        case description = "Description"
        case permissions = "Permissions"
        case securityProfileName = "SecurityProfileName"
        case tagRestrictedResources = "TagRestrictedResources"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedAccessControlTags = allowedAccessControlTags {
            var allowedAccessControlTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .allowedAccessControlTags)
            for (dictKey0, allowedAccessControlTags0) in allowedAccessControlTags {
                try allowedAccessControlTagsContainer.encode(allowedAccessControlTags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let applications = applications {
            var applicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applications)
            for application0 in applications {
                try applicationsContainer.encode(application0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for securityprofilepermission0 in permissions {
                try permissionsContainer.encode(securityprofilepermission0)
            }
        }
        if let securityProfileName = self.securityProfileName {
            try encodeContainer.encode(securityProfileName, forKey: .securityProfileName)
        }
        if let tagRestrictedResources = tagRestrictedResources {
            var tagRestrictedResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagRestrictedResources)
            for tagrestrictedresourcename0 in tagRestrictedResources {
                try tagRestrictedResourcesContainer.encode(tagrestrictedresourcename0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateSecurityProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/security-profiles/\(instanceId.urlPercentEncoding())"
    }
}

public struct CreateSecurityProfileInput: Swift.Equatable {
    /// The list of tags that a security profile uses to restrict access to resources in Amazon Connect.
    public var allowedAccessControlTags: [Swift.String:Swift.String]?
    /// This API is in preview release for Amazon Connect and is subject to change. A list of third-party applications that the security profile will give access to.
    public var applications: [ConnectClientTypes.Application]?
    /// The description of the security profile.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Permissions assigned to the security profile. For a list of valid permissions, see [List of security profile permissions](https://docs.aws.amazon.com/connect/latest/adminguide/security-profile-list.html).
    public var permissions: [Swift.String]?
    /// The name of the security profile.
    /// This member is required.
    public var securityProfileName: Swift.String?
    /// The list of resources that a security profile applies tag restrictions to in Amazon Connect. Following are acceptable ResourceNames: User | SecurityProfile | Queue | RoutingProfile
    public var tagRestrictedResources: [Swift.String]?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String:Swift.String]?

    public init(
        allowedAccessControlTags: [Swift.String:Swift.String]? = nil,
        applications: [ConnectClientTypes.Application]? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        permissions: [Swift.String]? = nil,
        securityProfileName: Swift.String? = nil,
        tagRestrictedResources: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.allowedAccessControlTags = allowedAccessControlTags
        self.applications = applications
        self.description = description
        self.instanceId = instanceId
        self.permissions = permissions
        self.securityProfileName = securityProfileName
        self.tagRestrictedResources = tagRestrictedResources
        self.tags = tags
    }
}

struct CreateSecurityProfileInputBody: Swift.Equatable {
    let securityProfileName: Swift.String?
    let description: Swift.String?
    let permissions: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
    let allowedAccessControlTags: [Swift.String:Swift.String]?
    let tagRestrictedResources: [Swift.String]?
    let applications: [ConnectClientTypes.Application]?
}

extension CreateSecurityProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedAccessControlTags = "AllowedAccessControlTags"
        case applications = "Applications"
        case description = "Description"
        case permissions = "Permissions"
        case securityProfileName = "SecurityProfileName"
        case tagRestrictedResources = "TagRestrictedResources"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityProfileName)
        securityProfileName = securityProfileNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .permissions)
        var permissionsDecoded0:[Swift.String]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [Swift.String]()
            for string0 in permissionsContainer {
                if let string0 = string0 {
                    permissionsDecoded0?.append(string0)
                }
            }
        }
        permissions = permissionsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let allowedAccessControlTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .allowedAccessControlTags)
        var allowedAccessControlTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let allowedAccessControlTagsContainer = allowedAccessControlTagsContainer {
            allowedAccessControlTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, securityprofilepolicyvalue0) in allowedAccessControlTagsContainer {
                if let securityprofilepolicyvalue0 = securityprofilepolicyvalue0 {
                    allowedAccessControlTagsDecoded0?[key0] = securityprofilepolicyvalue0
                }
            }
        }
        allowedAccessControlTags = allowedAccessControlTagsDecoded0
        let tagRestrictedResourcesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagRestrictedResources)
        var tagRestrictedResourcesDecoded0:[Swift.String]? = nil
        if let tagRestrictedResourcesContainer = tagRestrictedResourcesContainer {
            tagRestrictedResourcesDecoded0 = [Swift.String]()
            for string0 in tagRestrictedResourcesContainer {
                if let string0 = string0 {
                    tagRestrictedResourcesDecoded0?.append(string0)
                }
            }
        }
        tagRestrictedResources = tagRestrictedResourcesDecoded0
        let applicationsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.Application?].self, forKey: .applications)
        var applicationsDecoded0:[ConnectClientTypes.Application]? = nil
        if let applicationsContainer = applicationsContainer {
            applicationsDecoded0 = [ConnectClientTypes.Application]()
            for structure0 in applicationsContainer {
                if let structure0 = structure0 {
                    applicationsDecoded0?.append(structure0)
                }
            }
        }
        applications = applicationsDecoded0
    }
}

extension CreateSecurityProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSecurityProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.securityProfileArn = output.securityProfileArn
            self.securityProfileId = output.securityProfileId
        } else {
            self.securityProfileArn = nil
            self.securityProfileId = nil
        }
    }
}

public struct CreateSecurityProfileOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the security profile.
    public var securityProfileArn: Swift.String?
    /// The identifier for the security profle.
    public var securityProfileId: Swift.String?

    public init(
        securityProfileArn: Swift.String? = nil,
        securityProfileId: Swift.String? = nil
    )
    {
        self.securityProfileArn = securityProfileArn
        self.securityProfileId = securityProfileId
    }
}

struct CreateSecurityProfileOutputBody: Swift.Equatable {
    let securityProfileId: Swift.String?
    let securityProfileArn: Swift.String?
}

extension CreateSecurityProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityProfileArn = "SecurityProfileArn"
        case securityProfileId = "SecurityProfileId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityProfileId)
        securityProfileId = securityProfileIdDecoded
        let securityProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityProfileArn)
        securityProfileArn = securityProfileArnDecoded
    }
}

enum CreateSecurityProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DuplicateResourceException": return try await DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateTaskTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case constraints = "Constraints"
        case contactFlowId = "ContactFlowId"
        case defaults = "Defaults"
        case description = "Description"
        case fields = "Fields"
        case name = "Name"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let constraints = self.constraints {
            try encodeContainer.encode(constraints, forKey: .constraints)
        }
        if let contactFlowId = self.contactFlowId {
            try encodeContainer.encode(contactFlowId, forKey: .contactFlowId)
        }
        if let defaults = self.defaults {
            try encodeContainer.encode(defaults, forKey: .defaults)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let fields = fields {
            var fieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fields)
            for tasktemplatefield0 in fields {
                try fieldsContainer.encode(tasktemplatefield0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension CreateTaskTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/task/template"
    }
}

public struct CreateTaskTemplateInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// Constraints that are applicable to the fields listed.
    public var constraints: ConnectClientTypes.TaskTemplateConstraints?
    /// The identifier of the flow that runs by default when a task is created by referencing this template.
    public var contactFlowId: Swift.String?
    /// The default values for fields when a task is created by referencing this template.
    public var defaults: ConnectClientTypes.TaskTemplateDefaults?
    /// The description of the task template.
    public var description: Swift.String?
    /// Fields that are part of the template.
    /// This member is required.
    public var fields: [ConnectClientTypes.TaskTemplateField]?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the task template.
    /// This member is required.
    public var name: Swift.String?
    /// Marks a template as ACTIVE or INACTIVE for a task to refer to it. Tasks can only be created from ACTIVE templates. If a template is marked as INACTIVE, then a task that refers to this template cannot be created.
    public var status: ConnectClientTypes.TaskTemplateStatus?

    public init(
        clientToken: Swift.String? = nil,
        constraints: ConnectClientTypes.TaskTemplateConstraints? = nil,
        contactFlowId: Swift.String? = nil,
        defaults: ConnectClientTypes.TaskTemplateDefaults? = nil,
        description: Swift.String? = nil,
        fields: [ConnectClientTypes.TaskTemplateField]? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        status: ConnectClientTypes.TaskTemplateStatus? = nil
    )
    {
        self.clientToken = clientToken
        self.constraints = constraints
        self.contactFlowId = contactFlowId
        self.defaults = defaults
        self.description = description
        self.fields = fields
        self.instanceId = instanceId
        self.name = name
        self.status = status
    }
}

struct CreateTaskTemplateInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let contactFlowId: Swift.String?
    let constraints: ConnectClientTypes.TaskTemplateConstraints?
    let defaults: ConnectClientTypes.TaskTemplateDefaults?
    let status: ConnectClientTypes.TaskTemplateStatus?
    let fields: [ConnectClientTypes.TaskTemplateField]?
    let clientToken: Swift.String?
}

extension CreateTaskTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case constraints = "Constraints"
        case contactFlowId = "ContactFlowId"
        case defaults = "Defaults"
        case description = "Description"
        case fields = "Fields"
        case name = "Name"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let contactFlowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactFlowId)
        contactFlowId = contactFlowIdDecoded
        let constraintsDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.TaskTemplateConstraints.self, forKey: .constraints)
        constraints = constraintsDecoded
        let defaultsDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.TaskTemplateDefaults.self, forKey: .defaults)
        defaults = defaultsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.TaskTemplateStatus.self, forKey: .status)
        status = statusDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.TaskTemplateField?].self, forKey: .fields)
        var fieldsDecoded0:[ConnectClientTypes.TaskTemplateField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [ConnectClientTypes.TaskTemplateField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateTaskTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateTaskTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateTaskTemplateOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the task template resource.
    /// This member is required.
    public var arn: Swift.String?
    /// The identifier of the task template resource.
    /// This member is required.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateTaskTemplateOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
}

extension CreateTaskTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum CreateTaskTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PropertyValidationException": return try await PropertyValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateTrafficDistributionGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case instanceId = "InstanceId"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateTrafficDistributionGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/traffic-distribution-group"
    }
}

public struct CreateTrafficDistributionGroupInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// A description for the traffic distribution group.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance that has been replicated. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name for the traffic distribution group.
    /// This member is required.
    public var name: Swift.String?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.tags = tags
    }
}

struct CreateTrafficDistributionGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let instanceId: Swift.String?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateTrafficDistributionGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case instanceId = "InstanceId"
        case name = "Name"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateTrafficDistributionGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateTrafficDistributionGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateTrafficDistributionGroupOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the traffic distribution group.
    public var arn: Swift.String?
    /// The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateTrafficDistributionGroupOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
}

extension CreateTrafficDistributionGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum CreateTrafficDistributionGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotReadyException": return try await ResourceNotReadyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateUseCaseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
        case useCaseType = "UseCaseType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let useCaseType = self.useCaseType {
            try encodeContainer.encode(useCaseType.rawValue, forKey: .useCaseType)
        }
    }
}

extension CreateUseCaseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let integrationAssociationId = integrationAssociationId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/integration-associations/\(integrationAssociationId.urlPercentEncoding())/use-cases"
    }
}

public struct CreateUseCaseInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the integration association.
    /// This member is required.
    public var integrationAssociationId: Swift.String?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String:Swift.String]?
    /// The type of use case to associate to the integration association. Each integration association can have only one of each use case type.
    /// This member is required.
    public var useCaseType: ConnectClientTypes.UseCaseType?

    public init(
        instanceId: Swift.String? = nil,
        integrationAssociationId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        useCaseType: ConnectClientTypes.UseCaseType? = nil
    )
    {
        self.instanceId = instanceId
        self.integrationAssociationId = integrationAssociationId
        self.tags = tags
        self.useCaseType = useCaseType
    }
}

struct CreateUseCaseInputBody: Swift.Equatable {
    let useCaseType: ConnectClientTypes.UseCaseType?
    let tags: [Swift.String:Swift.String]?
}

extension CreateUseCaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
        case useCaseType = "UseCaseType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let useCaseTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.UseCaseType.self, forKey: .useCaseType)
        useCaseType = useCaseTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateUseCaseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateUseCaseOutputBody = try responseDecoder.decode(responseBody: data)
            self.useCaseArn = output.useCaseArn
            self.useCaseId = output.useCaseId
        } else {
            self.useCaseArn = nil
            self.useCaseId = nil
        }
    }
}

public struct CreateUseCaseOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the use case.
    public var useCaseArn: Swift.String?
    /// The identifier of the use case.
    public var useCaseId: Swift.String?

    public init(
        useCaseArn: Swift.String? = nil,
        useCaseId: Swift.String? = nil
    )
    {
        self.useCaseArn = useCaseArn
        self.useCaseId = useCaseId
    }
}

struct CreateUseCaseOutputBody: Swift.Equatable {
    let useCaseId: Swift.String?
    let useCaseArn: Swift.String?
}

extension CreateUseCaseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case useCaseArn = "UseCaseArn"
        case useCaseId = "UseCaseId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let useCaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .useCaseId)
        useCaseId = useCaseIdDecoded
        let useCaseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .useCaseArn)
        useCaseArn = useCaseArnDecoded
    }
}

enum CreateUseCaseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DuplicateResourceException": return try await DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateUserHierarchyGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case parentGroupId = "ParentGroupId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parentGroupId = self.parentGroupId {
            try encodeContainer.encode(parentGroupId, forKey: .parentGroupId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateUserHierarchyGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/user-hierarchy-groups/\(instanceId.urlPercentEncoding())"
    }
}

public struct CreateUserHierarchyGroupInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the user hierarchy group. Must not be more than 100 characters.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier for the parent hierarchy group. The user hierarchy is created at level one if the parent group ID is null.
    public var parentGroupId: Swift.String?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String:Swift.String]?

    public init(
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        parentGroupId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.instanceId = instanceId
        self.name = name
        self.parentGroupId = parentGroupId
        self.tags = tags
    }
}

struct CreateUserHierarchyGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let parentGroupId: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateUserHierarchyGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case parentGroupId = "ParentGroupId"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let parentGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentGroupId)
        parentGroupId = parentGroupIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateUserHierarchyGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateUserHierarchyGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.hierarchyGroupArn = output.hierarchyGroupArn
            self.hierarchyGroupId = output.hierarchyGroupId
        } else {
            self.hierarchyGroupArn = nil
            self.hierarchyGroupId = nil
        }
    }
}

public struct CreateUserHierarchyGroupOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the hierarchy group.
    public var hierarchyGroupArn: Swift.String?
    /// The identifier of the hierarchy group.
    public var hierarchyGroupId: Swift.String?

    public init(
        hierarchyGroupArn: Swift.String? = nil,
        hierarchyGroupId: Swift.String? = nil
    )
    {
        self.hierarchyGroupArn = hierarchyGroupArn
        self.hierarchyGroupId = hierarchyGroupId
    }
}

struct CreateUserHierarchyGroupOutputBody: Swift.Equatable {
    let hierarchyGroupId: Swift.String?
    let hierarchyGroupArn: Swift.String?
}

extension CreateUserHierarchyGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hierarchyGroupArn = "HierarchyGroupArn"
        case hierarchyGroupId = "HierarchyGroupId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hierarchyGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hierarchyGroupId)
        hierarchyGroupId = hierarchyGroupIdDecoded
        let hierarchyGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hierarchyGroupArn)
        hierarchyGroupArn = hierarchyGroupArnDecoded
    }
}

enum CreateUserHierarchyGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DuplicateResourceException": return try await DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryUserId = "DirectoryUserId"
        case hierarchyGroupId = "HierarchyGroupId"
        case identityInfo = "IdentityInfo"
        case password = "Password"
        case phoneConfig = "PhoneConfig"
        case routingProfileId = "RoutingProfileId"
        case securityProfileIds = "SecurityProfileIds"
        case tags = "Tags"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryUserId = self.directoryUserId {
            try encodeContainer.encode(directoryUserId, forKey: .directoryUserId)
        }
        if let hierarchyGroupId = self.hierarchyGroupId {
            try encodeContainer.encode(hierarchyGroupId, forKey: .hierarchyGroupId)
        }
        if let identityInfo = self.identityInfo {
            try encodeContainer.encode(identityInfo, forKey: .identityInfo)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let phoneConfig = self.phoneConfig {
            try encodeContainer.encode(phoneConfig, forKey: .phoneConfig)
        }
        if let routingProfileId = self.routingProfileId {
            try encodeContainer.encode(routingProfileId, forKey: .routingProfileId)
        }
        if let securityProfileIds = securityProfileIds {
            var securityProfileIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityProfileIds)
            for securityprofileid0 in securityProfileIds {
                try securityProfileIdsContainer.encode(securityprofileid0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

extension CreateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/users/\(instanceId.urlPercentEncoding())"
    }
}

public struct CreateUserInput: Swift.Equatable {
    /// The identifier of the user account in the directory used for identity management. If Amazon Connect cannot access the directory, you can specify this identifier to authenticate users. If you include the identifier, we assume that Amazon Connect cannot access the directory. Otherwise, the identity information is used to authenticate users from your directory. This parameter is required if you are using an existing directory for identity management in Amazon Connect when Amazon Connect cannot access your directory to authenticate users. If you are using SAML for identity management and include this parameter, an error is returned.
    public var directoryUserId: Swift.String?
    /// The identifier of the hierarchy group for the user.
    public var hierarchyGroupId: Swift.String?
    /// The information about the identity of the user.
    public var identityInfo: ConnectClientTypes.UserIdentityInfo?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The password for the user account. A password is required if you are using Amazon Connect for identity management. Otherwise, it is an error to include a password.
    public var password: Swift.String?
    /// The phone settings for the user.
    /// This member is required.
    public var phoneConfig: ConnectClientTypes.UserPhoneConfig?
    /// The identifier of the routing profile for the user.
    /// This member is required.
    public var routingProfileId: Swift.String?
    /// The identifier of the security profile for the user.
    /// This member is required.
    public var securityProfileIds: [Swift.String]?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String:Swift.String]?
    /// The user name for the account. For instances not using SAML for identity management, the user name can include up to 20 characters. If you are using SAML for identity management, the user name can include up to 64 characters from [a-zA-Z0-9_-.\@]+.
    /// This member is required.
    public var username: Swift.String?

    public init(
        directoryUserId: Swift.String? = nil,
        hierarchyGroupId: Swift.String? = nil,
        identityInfo: ConnectClientTypes.UserIdentityInfo? = nil,
        instanceId: Swift.String? = nil,
        password: Swift.String? = nil,
        phoneConfig: ConnectClientTypes.UserPhoneConfig? = nil,
        routingProfileId: Swift.String? = nil,
        securityProfileIds: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        username: Swift.String? = nil
    )
    {
        self.directoryUserId = directoryUserId
        self.hierarchyGroupId = hierarchyGroupId
        self.identityInfo = identityInfo
        self.instanceId = instanceId
        self.password = password
        self.phoneConfig = phoneConfig
        self.routingProfileId = routingProfileId
        self.securityProfileIds = securityProfileIds
        self.tags = tags
        self.username = username
    }
}

struct CreateUserInputBody: Swift.Equatable {
    let username: Swift.String?
    let password: Swift.String?
    let identityInfo: ConnectClientTypes.UserIdentityInfo?
    let phoneConfig: ConnectClientTypes.UserPhoneConfig?
    let directoryUserId: Swift.String?
    let securityProfileIds: [Swift.String]?
    let routingProfileId: Swift.String?
    let hierarchyGroupId: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryUserId = "DirectoryUserId"
        case hierarchyGroupId = "HierarchyGroupId"
        case identityInfo = "IdentityInfo"
        case password = "Password"
        case phoneConfig = "PhoneConfig"
        case routingProfileId = "RoutingProfileId"
        case securityProfileIds = "SecurityProfileIds"
        case tags = "Tags"
        case username = "Username"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let identityInfoDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.UserIdentityInfo.self, forKey: .identityInfo)
        identityInfo = identityInfoDecoded
        let phoneConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.UserPhoneConfig.self, forKey: .phoneConfig)
        phoneConfig = phoneConfigDecoded
        let directoryUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryUserId)
        directoryUserId = directoryUserIdDecoded
        let securityProfileIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityProfileIds)
        var securityProfileIdsDecoded0:[Swift.String]? = nil
        if let securityProfileIdsContainer = securityProfileIdsContainer {
            securityProfileIdsDecoded0 = [Swift.String]()
            for string0 in securityProfileIdsContainer {
                if let string0 = string0 {
                    securityProfileIdsDecoded0?.append(string0)
                }
            }
        }
        securityProfileIds = securityProfileIdsDecoded0
        let routingProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routingProfileId)
        routingProfileId = routingProfileIdDecoded
        let hierarchyGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hierarchyGroupId)
        hierarchyGroupId = hierarchyGroupIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.userArn = output.userArn
            self.userId = output.userId
        } else {
            self.userArn = nil
            self.userId = nil
        }
    }
}

public struct CreateUserOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the user account.
    public var userArn: Swift.String?
    /// The identifier of the user account.
    public var userId: Swift.String?

    public init(
        userArn: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.userArn = userArn
        self.userId = userId
    }
}

struct CreateUserOutputBody: Swift.Equatable {
    let userId: Swift.String?
    let userArn: Swift.String?
}

extension CreateUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userArn = "UserArn"
        case userId = "UserId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
    }
}

enum CreateUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DuplicateResourceException": return try await DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateViewInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateViewInput(clientToken: \(Swift.String(describing: clientToken)), content: \(Swift.String(describing: content)), description: \(Swift.String(describing: description)), instanceId: \(Swift.String(describing: instanceId)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), name: \"CONTENT_REDACTED\")"}
}

extension CreateViewInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case content = "Content"
        case description = "Description"
        case name = "Name"
        case status = "Status"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateViewInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/views/\(instanceId.urlPercentEncoding())"
    }
}

public struct CreateViewInput: Swift.Equatable {
    /// A unique Id for each create view request to avoid duplicate view creation. For example, the view is idempotent ClientToken is provided.
    public var clientToken: Swift.String?
    /// View content containing all content necessary to render a view except for runtime input data. The total uncompressed content has a maximum file size of 400kB.
    /// This member is required.
    public var content: ConnectClientTypes.ViewInputContent?
    /// The description of the view.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the view.
    /// This member is required.
    public var name: Swift.String?
    /// Indicates the view status as either SAVED or PUBLISHED. The PUBLISHED status will initiate validation on the content.
    /// This member is required.
    public var status: ConnectClientTypes.ViewStatus?
    /// The tags associated with the view resource (not specific to view version).These tags can be used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        content: ConnectClientTypes.ViewInputContent? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        status: ConnectClientTypes.ViewStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.content = content
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.status = status
        self.tags = tags
    }
}

struct CreateViewInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let status: ConnectClientTypes.ViewStatus?
    let content: ConnectClientTypes.ViewInputContent?
    let description: Swift.String?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateViewInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case content = "Content"
        case description = "Description"
        case name = "Name"
        case status = "Status"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ViewStatus.self, forKey: .status)
        status = statusDecoded
        let contentDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ViewInputContent.self, forKey: .content)
        content = contentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateViewOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateViewOutputBody = try responseDecoder.decode(responseBody: data)
            self.view = output.view
        } else {
            self.view = nil
        }
    }
}

public struct CreateViewOutput: Swift.Equatable {
    /// A view resource object. Contains metadata and content necessary to render the view.
    public var view: ConnectClientTypes.View?

    public init(
        view: ConnectClientTypes.View? = nil
    )
    {
        self.view = view
    }
}

struct CreateViewOutputBody: Swift.Equatable {
    let view: ConnectClientTypes.View?
}

extension CreateViewOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case view = "View"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let viewDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.View.self, forKey: .view)
        view = viewDecoded
    }
}

enum CreateViewOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DuplicateResourceException": return try await DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateViewVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case versionDescription = "VersionDescription"
        case viewContentSha256 = "ViewContentSha256"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let versionDescription = self.versionDescription {
            try encodeContainer.encode(versionDescription, forKey: .versionDescription)
        }
        if let viewContentSha256 = self.viewContentSha256 {
            try encodeContainer.encode(viewContentSha256, forKey: .viewContentSha256)
        }
    }
}

extension CreateViewVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let viewId = viewId else {
            return nil
        }
        return "/views/\(instanceId.urlPercentEncoding())/\(viewId.urlPercentEncoding())/versions"
    }
}

public struct CreateViewVersionInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The description for the version being published.
    public var versionDescription: Swift.String?
    /// Indicates the checksum value of the latest published view content.
    public var viewContentSha256: Swift.String?
    /// The identifier of the view. Both ViewArn and ViewId can be used.
    /// This member is required.
    public var viewId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        versionDescription: Swift.String? = nil,
        viewContentSha256: Swift.String? = nil,
        viewId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.versionDescription = versionDescription
        self.viewContentSha256 = viewContentSha256
        self.viewId = viewId
    }
}

struct CreateViewVersionInputBody: Swift.Equatable {
    let versionDescription: Swift.String?
    let viewContentSha256: Swift.String?
}

extension CreateViewVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case versionDescription = "VersionDescription"
        case viewContentSha256 = "ViewContentSha256"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionDescription)
        versionDescription = versionDescriptionDecoded
        let viewContentSha256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .viewContentSha256)
        viewContentSha256 = viewContentSha256Decoded
    }
}

extension CreateViewVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateViewVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.view = output.view
        } else {
            self.view = nil
        }
    }
}

public struct CreateViewVersionOutput: Swift.Equatable {
    /// All view data is contained within the View object.
    public var view: ConnectClientTypes.View?

    public init(
        view: ConnectClientTypes.View? = nil
    )
    {
        self.view = view
    }
}

struct CreateViewVersionOutputBody: Swift.Equatable {
    let view: ConnectClientTypes.View?
}

extension CreateViewVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case view = "View"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let viewDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.View.self, forKey: .view)
        view = viewDecoded
    }
}

enum CreateViewVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateVocabularyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case content = "Content"
        case languageCode = "LanguageCode"
        case tags = "Tags"
        case vocabularyName = "VocabularyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vocabularyName = self.vocabularyName {
            try encodeContainer.encode(vocabularyName, forKey: .vocabularyName)
        }
    }
}

extension CreateVocabularyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/vocabulary/\(instanceId.urlPercentEncoding())"
    }
}

public struct CreateVocabularyInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/). If a create request is received more than once with same client token, subsequent requests return the previous response without creating a vocabulary again.
    public var clientToken: Swift.String?
    /// The content of the custom vocabulary in plain-text format with a table of values. Each row in the table represents a word or a phrase, described with Phrase, IPA, SoundsLike, and DisplayAs fields. Separate the fields with TAB characters. The size limit is 50KB. For more information, see [Create a custom vocabulary using a table](https://docs.aws.amazon.com/transcribe/latest/dg/custom-vocabulary.html#create-vocabulary-table).
    /// This member is required.
    public var content: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see [What is Amazon Transcribe?](https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html)
    /// This member is required.
    public var languageCode: ConnectClientTypes.VocabularyLanguageCode?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String:Swift.String]?
    /// A unique name of the custom vocabulary.
    /// This member is required.
    public var vocabularyName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        content: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        languageCode: ConnectClientTypes.VocabularyLanguageCode? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vocabularyName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.content = content
        self.instanceId = instanceId
        self.languageCode = languageCode
        self.tags = tags
        self.vocabularyName = vocabularyName
    }
}

struct CreateVocabularyInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let vocabularyName: Swift.String?
    let languageCode: ConnectClientTypes.VocabularyLanguageCode?
    let content: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateVocabularyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case content = "Content"
        case languageCode = "LanguageCode"
        case tags = "Tags"
        case vocabularyName = "VocabularyName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let vocabularyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyName)
        vocabularyName = vocabularyNameDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.VocabularyLanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateVocabularyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateVocabularyOutputBody = try responseDecoder.decode(responseBody: data)
            self.state = output.state
            self.vocabularyArn = output.vocabularyArn
            self.vocabularyId = output.vocabularyId
        } else {
            self.state = nil
            self.vocabularyArn = nil
            self.vocabularyId = nil
        }
    }
}

public struct CreateVocabularyOutput: Swift.Equatable {
    /// The current state of the custom vocabulary.
    /// This member is required.
    public var state: ConnectClientTypes.VocabularyState?
    /// The Amazon Resource Name (ARN) of the custom vocabulary.
    /// This member is required.
    public var vocabularyArn: Swift.String?
    /// The identifier of the custom vocabulary.
    /// This member is required.
    public var vocabularyId: Swift.String?

    public init(
        state: ConnectClientTypes.VocabularyState? = nil,
        vocabularyArn: Swift.String? = nil,
        vocabularyId: Swift.String? = nil
    )
    {
        self.state = state
        self.vocabularyArn = vocabularyArn
        self.vocabularyId = vocabularyId
    }
}

struct CreateVocabularyOutputBody: Swift.Equatable {
    let vocabularyArn: Swift.String?
    let vocabularyId: Swift.String?
    let state: ConnectClientTypes.VocabularyState?
}

extension CreateVocabularyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state = "State"
        case vocabularyArn = "VocabularyArn"
        case vocabularyId = "VocabularyId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vocabularyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyArn)
        vocabularyArn = vocabularyArnDecoded
        let vocabularyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyId)
        vocabularyId = vocabularyIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.VocabularyState.self, forKey: .state)
        state = stateDecoded
    }
}

enum CreateVocabularyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectClientTypes.Credentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken = "AccessToken"
        case accessTokenExpiration = "AccessTokenExpiration"
        case refreshToken = "RefreshToken"
        case refreshTokenExpiration = "RefreshTokenExpiration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = self.accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let accessTokenExpiration = self.accessTokenExpiration {
            try encodeContainer.encodeTimestamp(accessTokenExpiration, format: .epochSeconds, forKey: .accessTokenExpiration)
        }
        if let refreshToken = self.refreshToken {
            try encodeContainer.encode(refreshToken, forKey: .refreshToken)
        }
        if let refreshTokenExpiration = self.refreshTokenExpiration {
            try encodeContainer.encodeTimestamp(refreshTokenExpiration, format: .epochSeconds, forKey: .refreshTokenExpiration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let accessTokenExpirationDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .accessTokenExpiration)
        accessTokenExpiration = accessTokenExpirationDecoded
        let refreshTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .refreshToken)
        refreshToken = refreshTokenDecoded
        let refreshTokenExpirationDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .refreshTokenExpiration)
        refreshTokenExpiration = refreshTokenExpirationDecoded
    }
}

extension ConnectClientTypes.Credentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Credentials(accessTokenExpiration: \(Swift.String(describing: accessTokenExpiration)), refreshTokenExpiration: \(Swift.String(describing: refreshTokenExpiration)), accessToken: \"CONTENT_REDACTED\", refreshToken: \"CONTENT_REDACTED\")"}
}

extension ConnectClientTypes {
    /// Contains credentials to use for federation.
    public struct Credentials: Swift.Equatable {
        /// An access token generated for a federated user to access Amazon Connect.
        public var accessToken: Swift.String?
        /// A token generated with an expiration time for the session a user is logged in to Amazon Connect.
        public var accessTokenExpiration: ClientRuntime.Date?
        /// Renews a token generated for a user to access the Amazon Connect instance.
        public var refreshToken: Swift.String?
        /// Renews the expiration timer for a generated token.
        public var refreshTokenExpiration: ClientRuntime.Date?

        public init(
            accessToken: Swift.String? = nil,
            accessTokenExpiration: ClientRuntime.Date? = nil,
            refreshToken: Swift.String? = nil,
            refreshTokenExpiration: ClientRuntime.Date? = nil
        )
        {
            self.accessToken = accessToken
            self.accessTokenExpiration = accessTokenExpiration
            self.refreshToken = refreshToken
            self.refreshTokenExpiration = refreshTokenExpiration
        }
    }

}

extension ConnectClientTypes.CrossChannelBehavior: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case behaviorType = "BehaviorType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let behaviorType = self.behaviorType {
            try encodeContainer.encode(behaviorType.rawValue, forKey: .behaviorType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let behaviorTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.BehaviorType.self, forKey: .behaviorType)
        behaviorType = behaviorTypeDecoded
    }
}

extension ConnectClientTypes {
    /// Defines the cross-channel routing behavior that allows an agent working on a contact in one channel to be offered a contact from a different channel.
    public struct CrossChannelBehavior: Swift.Equatable {
        /// Specifies the other channels that can be routed to an agent handling their current channel.
        /// This member is required.
        public var behaviorType: ConnectClientTypes.BehaviorType?

        public init(
            behaviorType: ConnectClientTypes.BehaviorType? = nil
        )
        {
            self.behaviorType = behaviorType
        }
    }

}

extension ConnectClientTypes.CurrentMetric: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case unit = "Unit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.CurrentMetricName.self, forKey: .name)
        name = nameDecoded
        let unitDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Unit.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about a real-time metric. For a description of each metric, see [Real-time Metrics Definitions](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html) in the Amazon Connect Administrator Guide.
    public struct CurrentMetric: Swift.Equatable {
        /// The name of the metric.
        public var name: ConnectClientTypes.CurrentMetricName?
        /// The unit for the metric.
        public var unit: ConnectClientTypes.Unit?

        public init(
            name: ConnectClientTypes.CurrentMetricName? = nil,
            unit: ConnectClientTypes.Unit? = nil
        )
        {
            self.name = name
            self.unit = unit
        }
    }

}

extension ConnectClientTypes.CurrentMetricData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metric = "Metric"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metric = self.metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.CurrentMetric.self, forKey: .metric)
        metric = metricDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
    }
}

extension ConnectClientTypes {
    /// Contains the data for a real-time metric.
    public struct CurrentMetricData: Swift.Equatable {
        /// Information about the metric.
        public var metric: ConnectClientTypes.CurrentMetric?
        /// The value of the metric.
        public var value: Swift.Double?

        public init(
            metric: ConnectClientTypes.CurrentMetric? = nil,
            value: Swift.Double? = nil
        )
        {
            self.metric = metric
            self.value = value
        }
    }

}

extension ConnectClientTypes {
    /// The current metric names.
    public enum CurrentMetricName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case agentsAfterContactWork
        case agentsAvailable
        case agentsError
        case agentsNonProductive
        case agentsOnline
        case agentsOnCall
        case agentsOnContact
        case agentsStaffed
        case contactsInQueue
        case contactsScheduled
        case oldestContactAge
        case slotsActive
        case slotsAvailable
        case sdkUnknown(Swift.String)

        public static var allCases: [CurrentMetricName] {
            return [
                .agentsAfterContactWork,
                .agentsAvailable,
                .agentsError,
                .agentsNonProductive,
                .agentsOnline,
                .agentsOnCall,
                .agentsOnContact,
                .agentsStaffed,
                .contactsInQueue,
                .contactsScheduled,
                .oldestContactAge,
                .slotsActive,
                .slotsAvailable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agentsAfterContactWork: return "AGENTS_AFTER_CONTACT_WORK"
            case .agentsAvailable: return "AGENTS_AVAILABLE"
            case .agentsError: return "AGENTS_ERROR"
            case .agentsNonProductive: return "AGENTS_NON_PRODUCTIVE"
            case .agentsOnline: return "AGENTS_ONLINE"
            case .agentsOnCall: return "AGENTS_ON_CALL"
            case .agentsOnContact: return "AGENTS_ON_CONTACT"
            case .agentsStaffed: return "AGENTS_STAFFED"
            case .contactsInQueue: return "CONTACTS_IN_QUEUE"
            case .contactsScheduled: return "CONTACTS_SCHEDULED"
            case .oldestContactAge: return "OLDEST_CONTACT_AGE"
            case .slotsActive: return "SLOTS_ACTIVE"
            case .slotsAvailable: return "SLOTS_AVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CurrentMetricName(rawValue: rawValue) ?? CurrentMetricName.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.CurrentMetricResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collections = "Collections"
        case dimensions = "Dimensions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let collections = collections {
            var collectionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .collections)
            for currentmetricdata0 in collections {
                try collectionsContainer.encode(currentmetricdata0)
            }
        }
        if let dimensions = self.dimensions {
            try encodeContainer.encode(dimensions, forKey: .dimensions)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionsDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Dimensions.self, forKey: .dimensions)
        dimensions = dimensionsDecoded
        let collectionsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.CurrentMetricData?].self, forKey: .collections)
        var collectionsDecoded0:[ConnectClientTypes.CurrentMetricData]? = nil
        if let collectionsContainer = collectionsContainer {
            collectionsDecoded0 = [ConnectClientTypes.CurrentMetricData]()
            for structure0 in collectionsContainer {
                if let structure0 = structure0 {
                    collectionsDecoded0?.append(structure0)
                }
            }
        }
        collections = collectionsDecoded0
    }
}

extension ConnectClientTypes {
    /// Contains information about a set of real-time metrics.
    public struct CurrentMetricResult: Swift.Equatable {
        /// The set of metrics.
        public var collections: [ConnectClientTypes.CurrentMetricData]?
        /// The dimensions for the metrics.
        public var dimensions: ConnectClientTypes.Dimensions?

        public init(
            collections: [ConnectClientTypes.CurrentMetricData]? = nil,
            dimensions: ConnectClientTypes.Dimensions? = nil
        )
        {
            self.collections = collections
            self.dimensions = dimensions
        }
    }

}

extension ConnectClientTypes.CurrentMetricSortCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sortByMetric = "SortByMetric"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sortByMetric = self.sortByMetric {
            try encodeContainer.encode(sortByMetric.rawValue, forKey: .sortByMetric)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortByMetricDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.CurrentMetricName.self, forKey: .sortByMetric)
        sortByMetric = sortByMetricDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension ConnectClientTypes {
    /// The way to sort the resulting response based on metrics. By default resources are sorted based on AGENTS_ONLINE, DESCENDING. The metric collection is sorted based on the input metrics.
    public struct CurrentMetricSortCriteria: Swift.Equatable {
        /// The current metric names.
        public var sortByMetric: ConnectClientTypes.CurrentMetricName?
        /// The way to sort.
        public var sortOrder: ConnectClientTypes.SortOrder?

        public init(
            sortByMetric: ConnectClientTypes.CurrentMetricName? = nil,
            sortOrder: ConnectClientTypes.SortOrder? = nil
        )
        {
            self.sortByMetric = sortByMetric
            self.sortOrder = sortOrder
        }
    }

}

extension ConnectClientTypes.DateReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ConnectClientTypes {
    /// Information about a reference when the referenceType is DATE. Otherwise, null.
    public struct DateReference: Swift.Equatable {
        /// Identifier of the date reference.
        public var name: Swift.String?
        /// A valid date.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension DeactivateEvaluationFormInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationFormVersion = "EvaluationFormVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evaluationFormVersion = self.evaluationFormVersion {
            try encodeContainer.encode(evaluationFormVersion, forKey: .evaluationFormVersion)
        }
    }
}

extension DeactivateEvaluationFormInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let evaluationFormId = evaluationFormId else {
            return nil
        }
        return "/evaluation-forms/\(instanceId.urlPercentEncoding())/\(evaluationFormId.urlPercentEncoding())/deactivate"
    }
}

public struct DeactivateEvaluationFormInput: Swift.Equatable {
    /// The unique identifier for the evaluation form.
    /// This member is required.
    public var evaluationFormId: Swift.String?
    /// A version of the evaluation form. If the version property is not provided, the latest version of the evaluation form is deactivated.
    /// This member is required.
    public var evaluationFormVersion: Swift.Int?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        evaluationFormId: Swift.String? = nil,
        evaluationFormVersion: Swift.Int? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.evaluationFormId = evaluationFormId
        self.evaluationFormVersion = evaluationFormVersion
        self.instanceId = instanceId
    }
}

struct DeactivateEvaluationFormInputBody: Swift.Equatable {
    let evaluationFormVersion: Swift.Int?
}

extension DeactivateEvaluationFormInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationFormVersion = "EvaluationFormVersion"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationFormVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .evaluationFormVersion)
        evaluationFormVersion = evaluationFormVersionDecoded
    }
}

extension DeactivateEvaluationFormOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeactivateEvaluationFormOutputBody = try responseDecoder.decode(responseBody: data)
            self.evaluationFormArn = output.evaluationFormArn
            self.evaluationFormId = output.evaluationFormId
            self.evaluationFormVersion = output.evaluationFormVersion
        } else {
            self.evaluationFormArn = nil
            self.evaluationFormId = nil
            self.evaluationFormVersion = 0
        }
    }
}

public struct DeactivateEvaluationFormOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the evaluation form resource.
    /// This member is required.
    public var evaluationFormArn: Swift.String?
    /// The unique identifier for the evaluation form.
    /// This member is required.
    public var evaluationFormId: Swift.String?
    /// The version of the deactivated evaluation form resource.
    /// This member is required.
    public var evaluationFormVersion: Swift.Int

    public init(
        evaluationFormArn: Swift.String? = nil,
        evaluationFormId: Swift.String? = nil,
        evaluationFormVersion: Swift.Int = 0
    )
    {
        self.evaluationFormArn = evaluationFormArn
        self.evaluationFormId = evaluationFormId
        self.evaluationFormVersion = evaluationFormVersion
    }
}

struct DeactivateEvaluationFormOutputBody: Swift.Equatable {
    let evaluationFormId: Swift.String?
    let evaluationFormArn: Swift.String?
    let evaluationFormVersion: Swift.Int
}

extension DeactivateEvaluationFormOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationFormArn = "EvaluationFormArn"
        case evaluationFormId = "EvaluationFormId"
        case evaluationFormVersion = "EvaluationFormVersion"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationFormIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationFormId)
        evaluationFormId = evaluationFormIdDecoded
        let evaluationFormArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationFormArn)
        evaluationFormArn = evaluationFormArnDecoded
        let evaluationFormVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .evaluationFormVersion) ?? 0
        evaluationFormVersion = evaluationFormVersionDecoded
    }
}

enum DeactivateEvaluationFormOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectClientTypes.DefaultVocabulary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case languageCode = "LanguageCode"
        case vocabularyId = "VocabularyId"
        case vocabularyName = "VocabularyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let vocabularyId = self.vocabularyId {
            try encodeContainer.encode(vocabularyId, forKey: .vocabularyId)
        }
        if let vocabularyName = self.vocabularyName {
            try encodeContainer.encode(vocabularyName, forKey: .vocabularyName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.VocabularyLanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let vocabularyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyId)
        vocabularyId = vocabularyIdDecoded
        let vocabularyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyName)
        vocabularyName = vocabularyNameDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about a default vocabulary.
    public struct DefaultVocabulary: Swift.Equatable {
        /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
        /// This member is required.
        public var instanceId: Swift.String?
        /// The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see [What is Amazon Transcribe?](https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html)
        /// This member is required.
        public var languageCode: ConnectClientTypes.VocabularyLanguageCode?
        /// The identifier of the custom vocabulary.
        /// This member is required.
        public var vocabularyId: Swift.String?
        /// A unique name of the custom vocabulary.
        /// This member is required.
        public var vocabularyName: Swift.String?

        public init(
            instanceId: Swift.String? = nil,
            languageCode: ConnectClientTypes.VocabularyLanguageCode? = nil,
            vocabularyId: Swift.String? = nil,
            vocabularyName: Swift.String? = nil
        )
        {
            self.instanceId = instanceId
            self.languageCode = languageCode
            self.vocabularyId = vocabularyId
            self.vocabularyName = vocabularyName
        }
    }

}

extension DeleteContactEvaluationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let evaluationId = evaluationId else {
            return nil
        }
        return "/contact-evaluations/\(instanceId.urlPercentEncoding())/\(evaluationId.urlPercentEncoding())"
    }
}

public struct DeleteContactEvaluationInput: Swift.Equatable {
    /// A unique identifier for the contact evaluation.
    /// This member is required.
    public var evaluationId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        evaluationId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.evaluationId = evaluationId
        self.instanceId = instanceId
    }
}

struct DeleteContactEvaluationInputBody: Swift.Equatable {
}

extension DeleteContactEvaluationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteContactEvaluationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteContactEvaluationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteContactEvaluationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteContactFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let contactFlowId = contactFlowId else {
            return nil
        }
        return "/contact-flows/\(instanceId.urlPercentEncoding())/\(contactFlowId.urlPercentEncoding())"
    }
}

public struct DeleteContactFlowInput: Swift.Equatable {
    /// The identifier of the flow.
    /// This member is required.
    public var contactFlowId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        contactFlowId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.contactFlowId = contactFlowId
        self.instanceId = instanceId
    }
}

struct DeleteContactFlowInputBody: Swift.Equatable {
}

extension DeleteContactFlowInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteContactFlowModuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let contactFlowModuleId = contactFlowModuleId else {
            return nil
        }
        return "/contact-flow-modules/\(instanceId.urlPercentEncoding())/\(contactFlowModuleId.urlPercentEncoding())"
    }
}

public struct DeleteContactFlowModuleInput: Swift.Equatable {
    /// The identifier of the flow module.
    /// This member is required.
    public var contactFlowModuleId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        contactFlowModuleId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.contactFlowModuleId = contactFlowModuleId
        self.instanceId = instanceId
    }
}

struct DeleteContactFlowModuleInputBody: Swift.Equatable {
}

extension DeleteContactFlowModuleInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteContactFlowModuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteContactFlowModuleOutput: Swift.Equatable {

    public init() { }
}

enum DeleteContactFlowModuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteContactFlowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteContactFlowOutput: Swift.Equatable {

    public init() { }
}

enum DeleteContactFlowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEvaluationFormInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let evaluationFormVersion = evaluationFormVersion {
                let evaluationFormVersionQueryItem = ClientRuntime.URLQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(evaluationFormVersion).urlPercentEncoding())
                items.append(evaluationFormVersionQueryItem)
            }
            return items
        }
    }
}

extension DeleteEvaluationFormInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let evaluationFormId = evaluationFormId else {
            return nil
        }
        return "/evaluation-forms/\(instanceId.urlPercentEncoding())/\(evaluationFormId.urlPercentEncoding())"
    }
}

public struct DeleteEvaluationFormInput: Swift.Equatable {
    /// The unique identifier for the evaluation form.
    /// This member is required.
    public var evaluationFormId: Swift.String?
    /// The unique identifier for the evaluation form.
    public var evaluationFormVersion: Swift.Int?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        evaluationFormId: Swift.String? = nil,
        evaluationFormVersion: Swift.Int? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.evaluationFormId = evaluationFormId
        self.evaluationFormVersion = evaluationFormVersion
        self.instanceId = instanceId
    }
}

struct DeleteEvaluationFormInputBody: Swift.Equatable {
}

extension DeleteEvaluationFormInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteEvaluationFormOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteEvaluationFormOutput: Swift.Equatable {

    public init() { }
}

enum DeleteEvaluationFormOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteHoursOfOperationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let hoursOfOperationId = hoursOfOperationId else {
            return nil
        }
        return "/hours-of-operations/\(instanceId.urlPercentEncoding())/\(hoursOfOperationId.urlPercentEncoding())"
    }
}

public struct DeleteHoursOfOperationInput: Swift.Equatable {
    /// The identifier for the hours of operation.
    /// This member is required.
    public var hoursOfOperationId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        hoursOfOperationId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.hoursOfOperationId = hoursOfOperationId
        self.instanceId = instanceId
    }
}

struct DeleteHoursOfOperationInputBody: Swift.Equatable {
}

extension DeleteHoursOfOperationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteHoursOfOperationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteHoursOfOperationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteHoursOfOperationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())"
    }
}

public struct DeleteInstanceInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        instanceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

struct DeleteInstanceInputBody: Swift.Equatable {
}

extension DeleteInstanceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteInstanceOutput: Swift.Equatable {

    public init() { }
}

enum DeleteInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteIntegrationAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let integrationAssociationId = integrationAssociationId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/integration-associations/\(integrationAssociationId.urlPercentEncoding())"
    }
}

public struct DeleteIntegrationAssociationInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the integration association.
    /// This member is required.
    public var integrationAssociationId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        integrationAssociationId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.integrationAssociationId = integrationAssociationId
    }
}

struct DeleteIntegrationAssociationInputBody: Swift.Equatable {
}

extension DeleteIntegrationAssociationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteIntegrationAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteIntegrationAssociationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteIntegrationAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePromptInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let promptId = promptId else {
            return nil
        }
        return "/prompts/\(instanceId.urlPercentEncoding())/\(promptId.urlPercentEncoding())"
    }
}

public struct DeletePromptInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A unique identifier for the prompt.
    /// This member is required.
    public var promptId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        promptId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.promptId = promptId
    }
}

struct DeletePromptInputBody: Swift.Equatable {
}

extension DeletePromptInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeletePromptOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeletePromptOutput: Swift.Equatable {

    public init() { }
}

enum DeletePromptOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteQueueInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let queueId = queueId else {
            return nil
        }
        return "/queues/\(instanceId.urlPercentEncoding())/\(queueId.urlPercentEncoding())"
    }
}

public struct DeleteQueueInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the queue.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.queueId = queueId
    }
}

struct DeleteQueueInputBody: Swift.Equatable {
}

extension DeleteQueueInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteQueueOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteQueueOutput: Swift.Equatable {

    public init() { }
}

enum DeleteQueueOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteQuickConnectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let quickConnectId = quickConnectId else {
            return nil
        }
        return "/quick-connects/\(instanceId.urlPercentEncoding())/\(quickConnectId.urlPercentEncoding())"
    }
}

public struct DeleteQuickConnectInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the quick connect.
    /// This member is required.
    public var quickConnectId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        quickConnectId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.quickConnectId = quickConnectId
    }
}

struct DeleteQuickConnectInputBody: Swift.Equatable {
}

extension DeleteQuickConnectInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteQuickConnectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteQuickConnectOutput: Swift.Equatable {

    public init() { }
}

enum DeleteQuickConnectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRoutingProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let routingProfileId = routingProfileId else {
            return nil
        }
        return "/routing-profiles/\(instanceId.urlPercentEncoding())/\(routingProfileId.urlPercentEncoding())"
    }
}

public struct DeleteRoutingProfileInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the routing profile.
    /// This member is required.
    public var routingProfileId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        routingProfileId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.routingProfileId = routingProfileId
    }
}

struct DeleteRoutingProfileInputBody: Swift.Equatable {
}

extension DeleteRoutingProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRoutingProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteRoutingProfileOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRoutingProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let ruleId = ruleId else {
            return nil
        }
        return "/rules/\(instanceId.urlPercentEncoding())/\(ruleId.urlPercentEncoding())"
    }
}

public struct DeleteRuleInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A unique identifier for the rule.
    /// This member is required.
    public var ruleId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        ruleId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.ruleId = ruleId
    }
}

struct DeleteRuleInputBody: Swift.Equatable {
}

extension DeleteRuleInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteRuleOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSecurityProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let securityProfileId = securityProfileId else {
            return nil
        }
        return "/security-profiles/\(instanceId.urlPercentEncoding())/\(securityProfileId.urlPercentEncoding())"
    }
}

public struct DeleteSecurityProfileInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the security profle.
    /// This member is required.
    public var securityProfileId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        securityProfileId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.securityProfileId = securityProfileId
    }
}

struct DeleteSecurityProfileInputBody: Swift.Equatable {
}

extension DeleteSecurityProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSecurityProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSecurityProfileOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSecurityProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteTaskTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let taskTemplateId = taskTemplateId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/task/template/\(taskTemplateId.urlPercentEncoding())"
    }
}

public struct DeleteTaskTemplateInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A unique identifier for the task template.
    /// This member is required.
    public var taskTemplateId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        taskTemplateId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.taskTemplateId = taskTemplateId
    }
}

struct DeleteTaskTemplateInputBody: Swift.Equatable {
}

extension DeleteTaskTemplateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTaskTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteTaskTemplateOutput: Swift.Equatable {

    public init() { }
}

enum DeleteTaskTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteTrafficDistributionGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trafficDistributionGroupId = trafficDistributionGroupId else {
            return nil
        }
        return "/traffic-distribution-group/\(trafficDistributionGroupId.urlPercentEncoding())"
    }
}

public struct DeleteTrafficDistributionGroupInput: Swift.Equatable {
    /// The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.
    /// This member is required.
    public var trafficDistributionGroupId: Swift.String?

    public init(
        trafficDistributionGroupId: Swift.String? = nil
    )
    {
        self.trafficDistributionGroupId = trafficDistributionGroupId
    }
}

struct DeleteTrafficDistributionGroupInputBody: Swift.Equatable {
}

extension DeleteTrafficDistributionGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTrafficDistributionGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteTrafficDistributionGroupOutput: Swift.Equatable {

    public init() { }
}

enum DeleteTrafficDistributionGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteUseCaseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let integrationAssociationId = integrationAssociationId else {
            return nil
        }
        guard let useCaseId = useCaseId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/integration-associations/\(integrationAssociationId.urlPercentEncoding())/use-cases/\(useCaseId.urlPercentEncoding())"
    }
}

public struct DeleteUseCaseInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the integration association.
    /// This member is required.
    public var integrationAssociationId: Swift.String?
    /// The identifier for the use case.
    /// This member is required.
    public var useCaseId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        integrationAssociationId: Swift.String? = nil,
        useCaseId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.integrationAssociationId = integrationAssociationId
        self.useCaseId = useCaseId
    }
}

struct DeleteUseCaseInputBody: Swift.Equatable {
}

extension DeleteUseCaseInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteUseCaseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteUseCaseOutput: Swift.Equatable {

    public init() { }
}

enum DeleteUseCaseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteUserHierarchyGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let hierarchyGroupId = hierarchyGroupId else {
            return nil
        }
        return "/user-hierarchy-groups/\(instanceId.urlPercentEncoding())/\(hierarchyGroupId.urlPercentEncoding())"
    }
}

public struct DeleteUserHierarchyGroupInput: Swift.Equatable {
    /// The identifier of the hierarchy group.
    /// This member is required.
    public var hierarchyGroupId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        hierarchyGroupId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.hierarchyGroupId = hierarchyGroupId
        self.instanceId = instanceId
    }
}

struct DeleteUserHierarchyGroupInputBody: Swift.Equatable {
}

extension DeleteUserHierarchyGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteUserHierarchyGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteUserHierarchyGroupOutput: Swift.Equatable {

    public init() { }
}

enum DeleteUserHierarchyGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let userId = userId else {
            return nil
        }
        return "/users/\(instanceId.urlPercentEncoding())/\(userId.urlPercentEncoding())"
    }
}

public struct DeleteUserInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the user.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.userId = userId
    }
}

struct DeleteUserInputBody: Swift.Equatable {
}

extension DeleteUserInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteUserOutput: Swift.Equatable {

    public init() { }
}

enum DeleteUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteViewInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let viewId = viewId else {
            return nil
        }
        return "/views/\(instanceId.urlPercentEncoding())/\(viewId.urlPercentEncoding())"
    }
}

public struct DeleteViewInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the view. Both ViewArn and ViewId can be used.
    /// This member is required.
    public var viewId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        viewId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.viewId = viewId
    }
}

struct DeleteViewInputBody: Swift.Equatable {
}

extension DeleteViewInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteViewOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteViewOutput: Swift.Equatable {

    public init() { }
}

enum DeleteViewOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteViewVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let viewId = viewId else {
            return nil
        }
        guard let viewVersion = viewVersion else {
            return nil
        }
        return "/views/\(instanceId.urlPercentEncoding())/\(viewId.urlPercentEncoding())/versions/\(viewVersion)"
    }
}

public struct DeleteViewVersionInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the view. Both ViewArn and ViewId can be used.
    /// This member is required.
    public var viewId: Swift.String?
    /// The version number of the view.
    /// This member is required.
    public var viewVersion: Swift.Int?

    public init(
        instanceId: Swift.String? = nil,
        viewId: Swift.String? = nil,
        viewVersion: Swift.Int? = nil
    )
    {
        self.instanceId = instanceId
        self.viewId = viewId
        self.viewVersion = viewVersion
    }
}

struct DeleteViewVersionInputBody: Swift.Equatable {
}

extension DeleteViewVersionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteViewVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteViewVersionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteViewVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVocabularyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let vocabularyId = vocabularyId else {
            return nil
        }
        return "/vocabulary-remove/\(instanceId.urlPercentEncoding())/\(vocabularyId.urlPercentEncoding())"
    }
}

public struct DeleteVocabularyInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the custom vocabulary.
    /// This member is required.
    public var vocabularyId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        vocabularyId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.vocabularyId = vocabularyId
    }
}

struct DeleteVocabularyInputBody: Swift.Equatable {
}

extension DeleteVocabularyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVocabularyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteVocabularyOutputBody = try responseDecoder.decode(responseBody: data)
            self.state = output.state
            self.vocabularyArn = output.vocabularyArn
            self.vocabularyId = output.vocabularyId
        } else {
            self.state = nil
            self.vocabularyArn = nil
            self.vocabularyId = nil
        }
    }
}

public struct DeleteVocabularyOutput: Swift.Equatable {
    /// The current state of the custom vocabulary.
    /// This member is required.
    public var state: ConnectClientTypes.VocabularyState?
    /// The Amazon Resource Name (ARN) of the custom vocabulary.
    /// This member is required.
    public var vocabularyArn: Swift.String?
    /// The identifier of the custom vocabulary.
    /// This member is required.
    public var vocabularyId: Swift.String?

    public init(
        state: ConnectClientTypes.VocabularyState? = nil,
        vocabularyArn: Swift.String? = nil,
        vocabularyId: Swift.String? = nil
    )
    {
        self.state = state
        self.vocabularyArn = vocabularyArn
        self.vocabularyId = vocabularyId
    }
}

struct DeleteVocabularyOutputBody: Swift.Equatable {
    let vocabularyArn: Swift.String?
    let vocabularyId: Swift.String?
    let state: ConnectClientTypes.VocabularyState?
}

extension DeleteVocabularyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state = "State"
        case vocabularyArn = "VocabularyArn"
        case vocabularyId = "VocabularyId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vocabularyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyArn)
        vocabularyArn = vocabularyArnDecoded
        let vocabularyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyId)
        vocabularyId = vocabularyIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.VocabularyState.self, forKey: .state)
        state = stateDecoded
    }
}

enum DeleteVocabularyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAgentStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let agentStatusId = agentStatusId else {
            return nil
        }
        return "/agent-status/\(instanceId.urlPercentEncoding())/\(agentStatusId.urlPercentEncoding())"
    }
}

public struct DescribeAgentStatusInput: Swift.Equatable {
    /// The identifier for the agent status.
    /// This member is required.
    public var agentStatusId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        agentStatusId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.agentStatusId = agentStatusId
        self.instanceId = instanceId
    }
}

struct DescribeAgentStatusInputBody: Swift.Equatable {
}

extension DescribeAgentStatusInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAgentStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAgentStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentStatus = output.agentStatus
        } else {
            self.agentStatus = nil
        }
    }
}

public struct DescribeAgentStatusOutput: Swift.Equatable {
    /// The agent status.
    public var agentStatus: ConnectClientTypes.AgentStatus?

    public init(
        agentStatus: ConnectClientTypes.AgentStatus? = nil
    )
    {
        self.agentStatus = agentStatus
    }
}

struct DescribeAgentStatusOutputBody: Swift.Equatable {
    let agentStatus: ConnectClientTypes.AgentStatus?
}

extension DescribeAgentStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentStatus = "AgentStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentStatusDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.AgentStatus.self, forKey: .agentStatus)
        agentStatus = agentStatusDecoded
    }
}

enum DescribeAgentStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeContactEvaluationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let evaluationId = evaluationId else {
            return nil
        }
        return "/contact-evaluations/\(instanceId.urlPercentEncoding())/\(evaluationId.urlPercentEncoding())"
    }
}

public struct DescribeContactEvaluationInput: Swift.Equatable {
    /// A unique identifier for the contact evaluation.
    /// This member is required.
    public var evaluationId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        evaluationId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.evaluationId = evaluationId
        self.instanceId = instanceId
    }
}

struct DescribeContactEvaluationInputBody: Swift.Equatable {
}

extension DescribeContactEvaluationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeContactEvaluationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeContactEvaluationOutputBody = try responseDecoder.decode(responseBody: data)
            self.evaluation = output.evaluation
            self.evaluationForm = output.evaluationForm
        } else {
            self.evaluation = nil
            self.evaluationForm = nil
        }
    }
}

public struct DescribeContactEvaluationOutput: Swift.Equatable {
    /// Information about the evaluation form completed for a specific contact.
    /// This member is required.
    public var evaluation: ConnectClientTypes.Evaluation?
    /// Information about the evaluation form.
    /// This member is required.
    public var evaluationForm: ConnectClientTypes.EvaluationFormContent?

    public init(
        evaluation: ConnectClientTypes.Evaluation? = nil,
        evaluationForm: ConnectClientTypes.EvaluationFormContent? = nil
    )
    {
        self.evaluation = evaluation
        self.evaluationForm = evaluationForm
    }
}

struct DescribeContactEvaluationOutputBody: Swift.Equatable {
    let evaluation: ConnectClientTypes.Evaluation?
    let evaluationForm: ConnectClientTypes.EvaluationFormContent?
}

extension DescribeContactEvaluationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluation = "Evaluation"
        case evaluationForm = "EvaluationForm"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Evaluation.self, forKey: .evaluation)
        evaluation = evaluationDecoded
        let evaluationFormDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.EvaluationFormContent.self, forKey: .evaluationForm)
        evaluationForm = evaluationFormDecoded
    }
}

enum DescribeContactEvaluationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeContactFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let contactFlowId = contactFlowId else {
            return nil
        }
        return "/contact-flows/\(instanceId.urlPercentEncoding())/\(contactFlowId.urlPercentEncoding())"
    }
}

public struct DescribeContactFlowInput: Swift.Equatable {
    /// The identifier of the flow.
    /// This member is required.
    public var contactFlowId: Swift.String?
    /// The identifier of the Amazon Connect instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        contactFlowId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.contactFlowId = contactFlowId
        self.instanceId = instanceId
    }
}

struct DescribeContactFlowInputBody: Swift.Equatable {
}

extension DescribeContactFlowInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeContactFlowModuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let contactFlowModuleId = contactFlowModuleId else {
            return nil
        }
        return "/contact-flow-modules/\(instanceId.urlPercentEncoding())/\(contactFlowModuleId.urlPercentEncoding())"
    }
}

public struct DescribeContactFlowModuleInput: Swift.Equatable {
    /// The identifier of the flow module.
    /// This member is required.
    public var contactFlowModuleId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        contactFlowModuleId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.contactFlowModuleId = contactFlowModuleId
        self.instanceId = instanceId
    }
}

struct DescribeContactFlowModuleInputBody: Swift.Equatable {
}

extension DescribeContactFlowModuleInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeContactFlowModuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeContactFlowModuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.contactFlowModule = output.contactFlowModule
        } else {
            self.contactFlowModule = nil
        }
    }
}

public struct DescribeContactFlowModuleOutput: Swift.Equatable {
    /// Information about the flow module.
    public var contactFlowModule: ConnectClientTypes.ContactFlowModule?

    public init(
        contactFlowModule: ConnectClientTypes.ContactFlowModule? = nil
    )
    {
        self.contactFlowModule = contactFlowModule
    }
}

struct DescribeContactFlowModuleOutputBody: Swift.Equatable {
    let contactFlowModule: ConnectClientTypes.ContactFlowModule?
}

extension DescribeContactFlowModuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactFlowModule = "ContactFlowModule"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactFlowModuleDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ContactFlowModule.self, forKey: .contactFlowModule)
        contactFlowModule = contactFlowModuleDecoded
    }
}

enum DescribeContactFlowModuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeContactFlowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeContactFlowOutputBody = try responseDecoder.decode(responseBody: data)
            self.contactFlow = output.contactFlow
        } else {
            self.contactFlow = nil
        }
    }
}

public struct DescribeContactFlowOutput: Swift.Equatable {
    /// Information about the flow.
    public var contactFlow: ConnectClientTypes.ContactFlow?

    public init(
        contactFlow: ConnectClientTypes.ContactFlow? = nil
    )
    {
        self.contactFlow = contactFlow
    }
}

struct DescribeContactFlowOutputBody: Swift.Equatable {
    let contactFlow: ConnectClientTypes.ContactFlow?
}

extension DescribeContactFlowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactFlow = "ContactFlow"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactFlowDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ContactFlow.self, forKey: .contactFlow)
        contactFlow = contactFlowDecoded
    }
}

enum DescribeContactFlowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ContactFlowNotPublishedException": return try await ContactFlowNotPublishedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let contactId = contactId else {
            return nil
        }
        return "/contacts/\(instanceId.urlPercentEncoding())/\(contactId.urlPercentEncoding())"
    }
}

public struct DescribeContactInput: Swift.Equatable {
    /// The identifier of the contact.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        contactId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.contactId = contactId
        self.instanceId = instanceId
    }
}

struct DescribeContactInputBody: Swift.Equatable {
}

extension DescribeContactInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeContactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeContactOutputBody = try responseDecoder.decode(responseBody: data)
            self.contact = output.contact
        } else {
            self.contact = nil
        }
    }
}

public struct DescribeContactOutput: Swift.Equatable {
    /// Information about the contact.
    public var contact: ConnectClientTypes.Contact?

    public init(
        contact: ConnectClientTypes.Contact? = nil
    )
    {
        self.contact = contact
    }
}

struct DescribeContactOutputBody: Swift.Equatable {
    let contact: ConnectClientTypes.Contact?
}

extension DescribeContactOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contact = "Contact"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Contact.self, forKey: .contact)
        contact = contactDecoded
    }
}

enum DescribeContactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeEvaluationFormInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let evaluationFormVersion = evaluationFormVersion {
                let evaluationFormVersionQueryItem = ClientRuntime.URLQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(evaluationFormVersion).urlPercentEncoding())
                items.append(evaluationFormVersionQueryItem)
            }
            return items
        }
    }
}

extension DescribeEvaluationFormInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let evaluationFormId = evaluationFormId else {
            return nil
        }
        return "/evaluation-forms/\(instanceId.urlPercentEncoding())/\(evaluationFormId.urlPercentEncoding())"
    }
}

public struct DescribeEvaluationFormInput: Swift.Equatable {
    /// A unique identifier for the contact evaluation.
    /// This member is required.
    public var evaluationFormId: Swift.String?
    /// A version of the evaluation form.
    public var evaluationFormVersion: Swift.Int?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        evaluationFormId: Swift.String? = nil,
        evaluationFormVersion: Swift.Int? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.evaluationFormId = evaluationFormId
        self.evaluationFormVersion = evaluationFormVersion
        self.instanceId = instanceId
    }
}

struct DescribeEvaluationFormInputBody: Swift.Equatable {
}

extension DescribeEvaluationFormInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeEvaluationFormOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeEvaluationFormOutputBody = try responseDecoder.decode(responseBody: data)
            self.evaluationForm = output.evaluationForm
        } else {
            self.evaluationForm = nil
        }
    }
}

public struct DescribeEvaluationFormOutput: Swift.Equatable {
    /// Information about the evaluation form.
    /// This member is required.
    public var evaluationForm: ConnectClientTypes.EvaluationForm?

    public init(
        evaluationForm: ConnectClientTypes.EvaluationForm? = nil
    )
    {
        self.evaluationForm = evaluationForm
    }
}

struct DescribeEvaluationFormOutputBody: Swift.Equatable {
    let evaluationForm: ConnectClientTypes.EvaluationForm?
}

extension DescribeEvaluationFormOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationForm = "EvaluationForm"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationFormDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.EvaluationForm.self, forKey: .evaluationForm)
        evaluationForm = evaluationFormDecoded
    }
}

enum DescribeEvaluationFormOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeHoursOfOperationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let hoursOfOperationId = hoursOfOperationId else {
            return nil
        }
        return "/hours-of-operations/\(instanceId.urlPercentEncoding())/\(hoursOfOperationId.urlPercentEncoding())"
    }
}

public struct DescribeHoursOfOperationInput: Swift.Equatable {
    /// The identifier for the hours of operation.
    /// This member is required.
    public var hoursOfOperationId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        hoursOfOperationId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.hoursOfOperationId = hoursOfOperationId
        self.instanceId = instanceId
    }
}

struct DescribeHoursOfOperationInputBody: Swift.Equatable {
}

extension DescribeHoursOfOperationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeHoursOfOperationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeHoursOfOperationOutputBody = try responseDecoder.decode(responseBody: data)
            self.hoursOfOperation = output.hoursOfOperation
        } else {
            self.hoursOfOperation = nil
        }
    }
}

public struct DescribeHoursOfOperationOutput: Swift.Equatable {
    /// The hours of operation.
    public var hoursOfOperation: ConnectClientTypes.HoursOfOperation?

    public init(
        hoursOfOperation: ConnectClientTypes.HoursOfOperation? = nil
    )
    {
        self.hoursOfOperation = hoursOfOperation
    }
}

struct DescribeHoursOfOperationOutputBody: Swift.Equatable {
    let hoursOfOperation: ConnectClientTypes.HoursOfOperation?
}

extension DescribeHoursOfOperationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hoursOfOperation = "HoursOfOperation"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hoursOfOperationDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HoursOfOperation.self, forKey: .hoursOfOperation)
        hoursOfOperation = hoursOfOperationDecoded
    }
}

enum DescribeHoursOfOperationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeInstanceAttributeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let attributeType = attributeType else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/attribute/\(attributeType.rawValue.urlPercentEncoding())"
    }
}

public struct DescribeInstanceAttributeInput: Swift.Equatable {
    /// The type of attribute.
    /// This member is required.
    public var attributeType: ConnectClientTypes.InstanceAttributeType?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        attributeType: ConnectClientTypes.InstanceAttributeType? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.attributeType = attributeType
        self.instanceId = instanceId
    }
}

struct DescribeInstanceAttributeInputBody: Swift.Equatable {
}

extension DescribeInstanceAttributeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeInstanceAttributeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeInstanceAttributeOutputBody = try responseDecoder.decode(responseBody: data)
            self.attribute = output.attribute
        } else {
            self.attribute = nil
        }
    }
}

public struct DescribeInstanceAttributeOutput: Swift.Equatable {
    /// The type of attribute.
    public var attribute: ConnectClientTypes.Attribute?

    public init(
        attribute: ConnectClientTypes.Attribute? = nil
    )
    {
        self.attribute = attribute
    }
}

struct DescribeInstanceAttributeOutputBody: Swift.Equatable {
    let attribute: ConnectClientTypes.Attribute?
}

extension DescribeInstanceAttributeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute = "Attribute"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Attribute.self, forKey: .attribute)
        attribute = attributeDecoded
    }
}

enum DescribeInstanceAttributeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())"
    }
}

public struct DescribeInstanceInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        instanceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

struct DescribeInstanceInputBody: Swift.Equatable {
}

extension DescribeInstanceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.instance = output.instance
        } else {
            self.instance = nil
        }
    }
}

public struct DescribeInstanceOutput: Swift.Equatable {
    /// The name of the instance.
    public var instance: ConnectClientTypes.Instance?

    public init(
        instance: ConnectClientTypes.Instance? = nil
    )
    {
        self.instance = instance
    }
}

struct DescribeInstanceOutputBody: Swift.Equatable {
    let instance: ConnectClientTypes.Instance?
}

extension DescribeInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instance = "Instance"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Instance.self, forKey: .instance)
        instance = instanceDecoded
    }
}

enum DescribeInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeInstanceStorageConfigInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceType = resourceType else {
                let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
            return items
        }
    }
}

extension DescribeInstanceStorageConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let associationId = associationId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/storage-config/\(associationId.urlPercentEncoding())"
    }
}

public struct DescribeInstanceStorageConfigInput: Swift.Equatable {
    /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
    /// This member is required.
    public var associationId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A valid resource type.
    /// This member is required.
    public var resourceType: ConnectClientTypes.InstanceStorageResourceType?

    public init(
        associationId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        resourceType: ConnectClientTypes.InstanceStorageResourceType? = nil
    )
    {
        self.associationId = associationId
        self.instanceId = instanceId
        self.resourceType = resourceType
    }
}

struct DescribeInstanceStorageConfigInputBody: Swift.Equatable {
}

extension DescribeInstanceStorageConfigInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeInstanceStorageConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeInstanceStorageConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.storageConfig = output.storageConfig
        } else {
            self.storageConfig = nil
        }
    }
}

public struct DescribeInstanceStorageConfigOutput: Swift.Equatable {
    /// A valid storage type.
    public var storageConfig: ConnectClientTypes.InstanceStorageConfig?

    public init(
        storageConfig: ConnectClientTypes.InstanceStorageConfig? = nil
    )
    {
        self.storageConfig = storageConfig
    }
}

struct DescribeInstanceStorageConfigOutputBody: Swift.Equatable {
    let storageConfig: ConnectClientTypes.InstanceStorageConfig?
}

extension DescribeInstanceStorageConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case storageConfig = "StorageConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.InstanceStorageConfig.self, forKey: .storageConfig)
        storageConfig = storageConfigDecoded
    }
}

enum DescribeInstanceStorageConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribePhoneNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let phoneNumberId = phoneNumberId else {
            return nil
        }
        return "/phone-number/\(phoneNumberId.urlPercentEncoding())"
    }
}

public struct DescribePhoneNumberInput: Swift.Equatable {
    /// A unique identifier for the phone number.
    /// This member is required.
    public var phoneNumberId: Swift.String?

    public init(
        phoneNumberId: Swift.String? = nil
    )
    {
        self.phoneNumberId = phoneNumberId
    }
}

struct DescribePhoneNumberInputBody: Swift.Equatable {
}

extension DescribePhoneNumberInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribePhoneNumberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribePhoneNumberOutputBody = try responseDecoder.decode(responseBody: data)
            self.claimedPhoneNumberSummary = output.claimedPhoneNumberSummary
        } else {
            self.claimedPhoneNumberSummary = nil
        }
    }
}

public struct DescribePhoneNumberOutput: Swift.Equatable {
    /// Information about a phone number that's been claimed to your Amazon Connect instance or traffic distribution group.
    public var claimedPhoneNumberSummary: ConnectClientTypes.ClaimedPhoneNumberSummary?

    public init(
        claimedPhoneNumberSummary: ConnectClientTypes.ClaimedPhoneNumberSummary? = nil
    )
    {
        self.claimedPhoneNumberSummary = claimedPhoneNumberSummary
    }
}

struct DescribePhoneNumberOutputBody: Swift.Equatable {
    let claimedPhoneNumberSummary: ConnectClientTypes.ClaimedPhoneNumberSummary?
}

extension DescribePhoneNumberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case claimedPhoneNumberSummary = "ClaimedPhoneNumberSummary"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let claimedPhoneNumberSummaryDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ClaimedPhoneNumberSummary.self, forKey: .claimedPhoneNumberSummary)
        claimedPhoneNumberSummary = claimedPhoneNumberSummaryDecoded
    }
}

enum DescribePhoneNumberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribePromptInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let promptId = promptId else {
            return nil
        }
        return "/prompts/\(instanceId.urlPercentEncoding())/\(promptId.urlPercentEncoding())"
    }
}

public struct DescribePromptInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A unique identifier for the prompt.
    /// This member is required.
    public var promptId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        promptId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.promptId = promptId
    }
}

struct DescribePromptInputBody: Swift.Equatable {
}

extension DescribePromptInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribePromptOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribePromptOutputBody = try responseDecoder.decode(responseBody: data)
            self.prompt = output.prompt
        } else {
            self.prompt = nil
        }
    }
}

public struct DescribePromptOutput: Swift.Equatable {
    /// Information about the prompt.
    public var prompt: ConnectClientTypes.Prompt?

    public init(
        prompt: ConnectClientTypes.Prompt? = nil
    )
    {
        self.prompt = prompt
    }
}

struct DescribePromptOutputBody: Swift.Equatable {
    let prompt: ConnectClientTypes.Prompt?
}

extension DescribePromptOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case prompt = "Prompt"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let promptDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Prompt.self, forKey: .prompt)
        prompt = promptDecoded
    }
}

enum DescribePromptOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeQueueInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let queueId = queueId else {
            return nil
        }
        return "/queues/\(instanceId.urlPercentEncoding())/\(queueId.urlPercentEncoding())"
    }
}

public struct DescribeQueueInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the queue.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.queueId = queueId
    }
}

struct DescribeQueueInputBody: Swift.Equatable {
}

extension DescribeQueueInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeQueueOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeQueueOutputBody = try responseDecoder.decode(responseBody: data)
            self.queue = output.queue
        } else {
            self.queue = nil
        }
    }
}

public struct DescribeQueueOutput: Swift.Equatable {
    /// The name of the queue.
    public var queue: ConnectClientTypes.Queue?

    public init(
        queue: ConnectClientTypes.Queue? = nil
    )
    {
        self.queue = queue
    }
}

struct DescribeQueueOutputBody: Swift.Equatable {
    let queue: ConnectClientTypes.Queue?
}

extension DescribeQueueOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queue = "Queue"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Queue.self, forKey: .queue)
        queue = queueDecoded
    }
}

enum DescribeQueueOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeQuickConnectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let quickConnectId = quickConnectId else {
            return nil
        }
        return "/quick-connects/\(instanceId.urlPercentEncoding())/\(quickConnectId.urlPercentEncoding())"
    }
}

public struct DescribeQuickConnectInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the quick connect.
    /// This member is required.
    public var quickConnectId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        quickConnectId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.quickConnectId = quickConnectId
    }
}

struct DescribeQuickConnectInputBody: Swift.Equatable {
}

extension DescribeQuickConnectInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeQuickConnectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeQuickConnectOutputBody = try responseDecoder.decode(responseBody: data)
            self.quickConnect = output.quickConnect
        } else {
            self.quickConnect = nil
        }
    }
}

public struct DescribeQuickConnectOutput: Swift.Equatable {
    /// Information about the quick connect.
    public var quickConnect: ConnectClientTypes.QuickConnect?

    public init(
        quickConnect: ConnectClientTypes.QuickConnect? = nil
    )
    {
        self.quickConnect = quickConnect
    }
}

struct DescribeQuickConnectOutputBody: Swift.Equatable {
    let quickConnect: ConnectClientTypes.QuickConnect?
}

extension DescribeQuickConnectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quickConnect = "QuickConnect"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quickConnectDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.QuickConnect.self, forKey: .quickConnect)
        quickConnect = quickConnectDecoded
    }
}

enum DescribeQuickConnectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeRoutingProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let routingProfileId = routingProfileId else {
            return nil
        }
        return "/routing-profiles/\(instanceId.urlPercentEncoding())/\(routingProfileId.urlPercentEncoding())"
    }
}

public struct DescribeRoutingProfileInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the routing profile.
    /// This member is required.
    public var routingProfileId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        routingProfileId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.routingProfileId = routingProfileId
    }
}

struct DescribeRoutingProfileInputBody: Swift.Equatable {
}

extension DescribeRoutingProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeRoutingProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeRoutingProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.routingProfile = output.routingProfile
        } else {
            self.routingProfile = nil
        }
    }
}

public struct DescribeRoutingProfileOutput: Swift.Equatable {
    /// The routing profile.
    public var routingProfile: ConnectClientTypes.RoutingProfile?

    public init(
        routingProfile: ConnectClientTypes.RoutingProfile? = nil
    )
    {
        self.routingProfile = routingProfile
    }
}

struct DescribeRoutingProfileOutputBody: Swift.Equatable {
    let routingProfile: ConnectClientTypes.RoutingProfile?
}

extension DescribeRoutingProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routingProfile = "RoutingProfile"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routingProfileDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.RoutingProfile.self, forKey: .routingProfile)
        routingProfile = routingProfileDecoded
    }
}

enum DescribeRoutingProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let ruleId = ruleId else {
            return nil
        }
        return "/rules/\(instanceId.urlPercentEncoding())/\(ruleId.urlPercentEncoding())"
    }
}

public struct DescribeRuleInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A unique identifier for the rule.
    /// This member is required.
    public var ruleId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        ruleId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.ruleId = ruleId
    }
}

struct DescribeRuleInputBody: Swift.Equatable {
}

extension DescribeRuleInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.rule = output.rule
        } else {
            self.rule = nil
        }
    }
}

public struct DescribeRuleOutput: Swift.Equatable {
    /// Information about the rule.
    /// This member is required.
    public var rule: ConnectClientTypes.Rule?

    public init(
        rule: ConnectClientTypes.Rule? = nil
    )
    {
        self.rule = rule
    }
}

struct DescribeRuleOutputBody: Swift.Equatable {
    let rule: ConnectClientTypes.Rule?
}

extension DescribeRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rule = "Rule"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Rule.self, forKey: .rule)
        rule = ruleDecoded
    }
}

enum DescribeRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeSecurityProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let securityProfileId = securityProfileId else {
            return nil
        }
        return "/security-profiles/\(instanceId.urlPercentEncoding())/\(securityProfileId.urlPercentEncoding())"
    }
}

public struct DescribeSecurityProfileInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the security profle.
    /// This member is required.
    public var securityProfileId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        securityProfileId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.securityProfileId = securityProfileId
    }
}

struct DescribeSecurityProfileInputBody: Swift.Equatable {
}

extension DescribeSecurityProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeSecurityProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSecurityProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.securityProfile = output.securityProfile
        } else {
            self.securityProfile = nil
        }
    }
}

public struct DescribeSecurityProfileOutput: Swift.Equatable {
    /// The security profile.
    public var securityProfile: ConnectClientTypes.SecurityProfile?

    public init(
        securityProfile: ConnectClientTypes.SecurityProfile? = nil
    )
    {
        self.securityProfile = securityProfile
    }
}

struct DescribeSecurityProfileOutputBody: Swift.Equatable {
    let securityProfile: ConnectClientTypes.SecurityProfile?
}

extension DescribeSecurityProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityProfile = "SecurityProfile"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityProfileDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.SecurityProfile.self, forKey: .securityProfile)
        securityProfile = securityProfileDecoded
    }
}

enum DescribeSecurityProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeTrafficDistributionGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trafficDistributionGroupId = trafficDistributionGroupId else {
            return nil
        }
        return "/traffic-distribution-group/\(trafficDistributionGroupId.urlPercentEncoding())"
    }
}

public struct DescribeTrafficDistributionGroupInput: Swift.Equatable {
    /// The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.
    /// This member is required.
    public var trafficDistributionGroupId: Swift.String?

    public init(
        trafficDistributionGroupId: Swift.String? = nil
    )
    {
        self.trafficDistributionGroupId = trafficDistributionGroupId
    }
}

struct DescribeTrafficDistributionGroupInputBody: Swift.Equatable {
}

extension DescribeTrafficDistributionGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeTrafficDistributionGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeTrafficDistributionGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.trafficDistributionGroup = output.trafficDistributionGroup
        } else {
            self.trafficDistributionGroup = nil
        }
    }
}

public struct DescribeTrafficDistributionGroupOutput: Swift.Equatable {
    /// Information about the traffic distribution group.
    public var trafficDistributionGroup: ConnectClientTypes.TrafficDistributionGroup?

    public init(
        trafficDistributionGroup: ConnectClientTypes.TrafficDistributionGroup? = nil
    )
    {
        self.trafficDistributionGroup = trafficDistributionGroup
    }
}

struct DescribeTrafficDistributionGroupOutputBody: Swift.Equatable {
    let trafficDistributionGroup: ConnectClientTypes.TrafficDistributionGroup?
}

extension DescribeTrafficDistributionGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trafficDistributionGroup = "TrafficDistributionGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trafficDistributionGroupDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.TrafficDistributionGroup.self, forKey: .trafficDistributionGroup)
        trafficDistributionGroup = trafficDistributionGroupDecoded
    }
}

enum DescribeTrafficDistributionGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeUserHierarchyGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let hierarchyGroupId = hierarchyGroupId else {
            return nil
        }
        return "/user-hierarchy-groups/\(instanceId.urlPercentEncoding())/\(hierarchyGroupId.urlPercentEncoding())"
    }
}

public struct DescribeUserHierarchyGroupInput: Swift.Equatable {
    /// The identifier of the hierarchy group.
    /// This member is required.
    public var hierarchyGroupId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        hierarchyGroupId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.hierarchyGroupId = hierarchyGroupId
        self.instanceId = instanceId
    }
}

struct DescribeUserHierarchyGroupInputBody: Swift.Equatable {
}

extension DescribeUserHierarchyGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeUserHierarchyGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeUserHierarchyGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.hierarchyGroup = output.hierarchyGroup
        } else {
            self.hierarchyGroup = nil
        }
    }
}

public struct DescribeUserHierarchyGroupOutput: Swift.Equatable {
    /// Information about the hierarchy group.
    public var hierarchyGroup: ConnectClientTypes.HierarchyGroup?

    public init(
        hierarchyGroup: ConnectClientTypes.HierarchyGroup? = nil
    )
    {
        self.hierarchyGroup = hierarchyGroup
    }
}

struct DescribeUserHierarchyGroupOutputBody: Swift.Equatable {
    let hierarchyGroup: ConnectClientTypes.HierarchyGroup?
}

extension DescribeUserHierarchyGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hierarchyGroup = "HierarchyGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hierarchyGroupDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyGroup.self, forKey: .hierarchyGroup)
        hierarchyGroup = hierarchyGroupDecoded
    }
}

enum DescribeUserHierarchyGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeUserHierarchyStructureInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/user-hierarchy-structure/\(instanceId.urlPercentEncoding())"
    }
}

public struct DescribeUserHierarchyStructureInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        instanceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

struct DescribeUserHierarchyStructureInputBody: Swift.Equatable {
}

extension DescribeUserHierarchyStructureInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeUserHierarchyStructureOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeUserHierarchyStructureOutputBody = try responseDecoder.decode(responseBody: data)
            self.hierarchyStructure = output.hierarchyStructure
        } else {
            self.hierarchyStructure = nil
        }
    }
}

public struct DescribeUserHierarchyStructureOutput: Swift.Equatable {
    /// Information about the hierarchy structure.
    public var hierarchyStructure: ConnectClientTypes.HierarchyStructure?

    public init(
        hierarchyStructure: ConnectClientTypes.HierarchyStructure? = nil
    )
    {
        self.hierarchyStructure = hierarchyStructure
    }
}

struct DescribeUserHierarchyStructureOutputBody: Swift.Equatable {
    let hierarchyStructure: ConnectClientTypes.HierarchyStructure?
}

extension DescribeUserHierarchyStructureOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hierarchyStructure = "HierarchyStructure"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hierarchyStructureDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyStructure.self, forKey: .hierarchyStructure)
        hierarchyStructure = hierarchyStructureDecoded
    }
}

enum DescribeUserHierarchyStructureOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let userId = userId else {
            return nil
        }
        return "/users/\(instanceId.urlPercentEncoding())/\(userId.urlPercentEncoding())"
    }
}

public struct DescribeUserInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the user account.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.userId = userId
    }
}

struct DescribeUserInputBody: Swift.Equatable {
}

extension DescribeUserInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.user = output.user
        } else {
            self.user = nil
        }
    }
}

public struct DescribeUserOutput: Swift.Equatable {
    /// Information about the user account and configuration settings.
    public var user: ConnectClientTypes.User?

    public init(
        user: ConnectClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

struct DescribeUserOutputBody: Swift.Equatable {
    let user: ConnectClientTypes.User?
}

extension DescribeUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case user = "User"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.User.self, forKey: .user)
        user = userDecoded
    }
}

enum DescribeUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeViewInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let viewId = viewId else {
            return nil
        }
        return "/views/\(instanceId.urlPercentEncoding())/\(viewId.urlPercentEncoding())"
    }
}

public struct DescribeViewInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The ViewId of the view. This must be an ARN for Amazon Web Services managed views.
    /// This member is required.
    public var viewId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        viewId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.viewId = viewId
    }
}

struct DescribeViewInputBody: Swift.Equatable {
}

extension DescribeViewInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeViewOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeViewOutputBody = try responseDecoder.decode(responseBody: data)
            self.view = output.view
        } else {
            self.view = nil
        }
    }
}

public struct DescribeViewOutput: Swift.Equatable {
    /// All view data is contained within the View object.
    public var view: ConnectClientTypes.View?

    public init(
        view: ConnectClientTypes.View? = nil
    )
    {
        self.view = view
    }
}

struct DescribeViewOutputBody: Swift.Equatable {
    let view: ConnectClientTypes.View?
}

extension DescribeViewOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case view = "View"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let viewDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.View.self, forKey: .view)
        view = viewDecoded
    }
}

enum DescribeViewOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeVocabularyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let vocabularyId = vocabularyId else {
            return nil
        }
        return "/vocabulary/\(instanceId.urlPercentEncoding())/\(vocabularyId.urlPercentEncoding())"
    }
}

public struct DescribeVocabularyInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the custom vocabulary.
    /// This member is required.
    public var vocabularyId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        vocabularyId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.vocabularyId = vocabularyId
    }
}

struct DescribeVocabularyInputBody: Swift.Equatable {
}

extension DescribeVocabularyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeVocabularyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeVocabularyOutputBody = try responseDecoder.decode(responseBody: data)
            self.vocabulary = output.vocabulary
        } else {
            self.vocabulary = nil
        }
    }
}

public struct DescribeVocabularyOutput: Swift.Equatable {
    /// A list of specific words that you want Contact Lens for Amazon Connect to recognize in your audio input. They are generally domain-specific words and phrases, words that Contact Lens is not recognizing, or proper nouns.
    /// This member is required.
    public var vocabulary: ConnectClientTypes.Vocabulary?

    public init(
        vocabulary: ConnectClientTypes.Vocabulary? = nil
    )
    {
        self.vocabulary = vocabulary
    }
}

struct DescribeVocabularyOutputBody: Swift.Equatable {
    let vocabulary: ConnectClientTypes.Vocabulary?
}

extension DescribeVocabularyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vocabulary = "Vocabulary"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vocabularyDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Vocabulary.self, forKey: .vocabulary)
        vocabulary = vocabularyDecoded
    }
}

enum DescribeVocabularyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DestinationNotAllowedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DestinationNotAllowedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Outbound calls to the destination number are not allowed.
public struct DestinationNotAllowedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message about the outbound calls.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DestinationNotAllowedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DestinationNotAllowedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DestinationNotAllowedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectClientTypes.Dimensions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel = "Channel"
        case queue = "Queue"
        case routingProfile = "RoutingProfile"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channel = self.channel {
            try encodeContainer.encode(channel.rawValue, forKey: .channel)
        }
        if let queue = self.queue {
            try encodeContainer.encode(queue, forKey: .queue)
        }
        if let routingProfile = self.routingProfile {
            try encodeContainer.encode(routingProfile, forKey: .routingProfile)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.QueueReference.self, forKey: .queue)
        queue = queueDecoded
        let channelDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Channel.self, forKey: .channel)
        channel = channelDecoded
        let routingProfileDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.RoutingProfileReference.self, forKey: .routingProfile)
        routingProfile = routingProfileDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about the dimensions for a set of metrics.
    public struct Dimensions: Swift.Equatable {
        /// The channel used for grouping and filters.
        public var channel: ConnectClientTypes.Channel?
        /// Information about the queue for which metrics are returned.
        public var queue: ConnectClientTypes.QueueReference?
        /// Information about the routing profile assigned to the user.
        public var routingProfile: ConnectClientTypes.RoutingProfileReference?

        public init(
            channel: ConnectClientTypes.Channel? = nil,
            queue: ConnectClientTypes.QueueReference? = nil,
            routingProfile: ConnectClientTypes.RoutingProfileReference? = nil
        )
        {
            self.channel = channel
            self.queue = queue
            self.routingProfile = routingProfile
        }
    }

}

extension ConnectClientTypes {
    public enum DirectoryType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connectManaged
        case existingDirectory
        case saml
        case sdkUnknown(Swift.String)

        public static var allCases: [DirectoryType] {
            return [
                .connectManaged,
                .existingDirectory,
                .saml,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connectManaged: return "CONNECT_MANAGED"
            case .existingDirectory: return "EXISTING_DIRECTORY"
            case .saml: return "SAML"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DirectoryType(rawValue: rawValue) ?? DirectoryType.sdkUnknown(rawValue)
        }
    }
}

extension DisassociateAnalyticsDataSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSetId = "DataSetId"
        case targetAccountId = "TargetAccountId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSetId = self.dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let targetAccountId = self.targetAccountId {
            try encodeContainer.encode(targetAccountId, forKey: .targetAccountId)
        }
    }
}

extension DisassociateAnalyticsDataSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/analytics-data/instance/\(instanceId.urlPercentEncoding())/association"
    }
}

public struct DisassociateAnalyticsDataSetInput: Swift.Equatable {
    /// The identifier of the dataset to remove.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the target account. Use to associate a dataset to a different account than the one containing the Amazon Connect instance. If not specified, by default this value is the Amazon Web Services account that has the Amazon Connect instance.
    public var targetAccountId: Swift.String?

    public init(
        dataSetId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        targetAccountId: Swift.String? = nil
    )
    {
        self.dataSetId = dataSetId
        self.instanceId = instanceId
        self.targetAccountId = targetAccountId
    }
}

struct DisassociateAnalyticsDataSetInputBody: Swift.Equatable {
    let dataSetId: Swift.String?
    let targetAccountId: Swift.String?
}

extension DisassociateAnalyticsDataSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSetId = "DataSetId"
        case targetAccountId = "TargetAccountId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let targetAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetAccountId)
        targetAccountId = targetAccountIdDecoded
    }
}

extension DisassociateAnalyticsDataSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateAnalyticsDataSetOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateAnalyticsDataSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateApprovedOriginInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let origin = origin else {
                let message = "Creating a URL Query Item failed. origin is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let originQueryItem = ClientRuntime.URLQueryItem(name: "origin".urlPercentEncoding(), value: Swift.String(origin).urlPercentEncoding())
            items.append(originQueryItem)
            return items
        }
    }
}

extension DisassociateApprovedOriginInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/approved-origin"
    }
}

public struct DisassociateApprovedOriginInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The domain URL of the integrated application.
    /// This member is required.
    public var origin: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        origin: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.origin = origin
    }
}

struct DisassociateApprovedOriginInputBody: Swift.Equatable {
}

extension DisassociateApprovedOriginInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateApprovedOriginOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateApprovedOriginOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateApprovedOriginOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateBotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lexBot = "LexBot"
        case lexV2Bot = "LexV2Bot"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lexBot = self.lexBot {
            try encodeContainer.encode(lexBot, forKey: .lexBot)
        }
        if let lexV2Bot = self.lexV2Bot {
            try encodeContainer.encode(lexV2Bot, forKey: .lexV2Bot)
        }
    }
}

extension DisassociateBotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/bot"
    }
}

public struct DisassociateBotInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Configuration information of an Amazon Lex bot.
    public var lexBot: ConnectClientTypes.LexBot?
    /// The Amazon Lex V2 bot to disassociate from the instance.
    public var lexV2Bot: ConnectClientTypes.LexV2Bot?

    public init(
        instanceId: Swift.String? = nil,
        lexBot: ConnectClientTypes.LexBot? = nil,
        lexV2Bot: ConnectClientTypes.LexV2Bot? = nil
    )
    {
        self.instanceId = instanceId
        self.lexBot = lexBot
        self.lexV2Bot = lexV2Bot
    }
}

struct DisassociateBotInputBody: Swift.Equatable {
    let lexBot: ConnectClientTypes.LexBot?
    let lexV2Bot: ConnectClientTypes.LexV2Bot?
}

extension DisassociateBotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lexBot = "LexBot"
        case lexV2Bot = "LexV2Bot"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lexBotDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.LexBot.self, forKey: .lexBot)
        lexBot = lexBotDecoded
        let lexV2BotDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.LexV2Bot.self, forKey: .lexV2Bot)
        lexV2Bot = lexV2BotDecoded
    }
}

extension DisassociateBotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateBotOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateBotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        guard let resourceType = resourceType else {
            return nil
        }
        return "/flow-associations/\(instanceId.urlPercentEncoding())/\(resourceId.urlPercentEncoding())/\(resourceType.rawValue.urlPercentEncoding())"
    }
}

public struct DisassociateFlowInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// A valid resource type.
    /// This member is required.
    public var resourceType: ConnectClientTypes.FlowAssociationResourceType?

    public init(
        instanceId: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: ConnectClientTypes.FlowAssociationResourceType? = nil
    )
    {
        self.instanceId = instanceId
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct DisassociateFlowInputBody: Swift.Equatable {
}

extension DisassociateFlowInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateFlowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateFlowOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateFlowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateInstanceStorageConfigInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceType = resourceType else {
                let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
            return items
        }
    }
}

extension DisassociateInstanceStorageConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let associationId = associationId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/storage-config/\(associationId.urlPercentEncoding())"
    }
}

public struct DisassociateInstanceStorageConfigInput: Swift.Equatable {
    /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
    /// This member is required.
    public var associationId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A valid resource type.
    /// This member is required.
    public var resourceType: ConnectClientTypes.InstanceStorageResourceType?

    public init(
        associationId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        resourceType: ConnectClientTypes.InstanceStorageResourceType? = nil
    )
    {
        self.associationId = associationId
        self.instanceId = instanceId
        self.resourceType = resourceType
    }
}

struct DisassociateInstanceStorageConfigInputBody: Swift.Equatable {
}

extension DisassociateInstanceStorageConfigInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateInstanceStorageConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateInstanceStorageConfigOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateInstanceStorageConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateLambdaFunctionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let functionArn = functionArn else {
                let message = "Creating a URL Query Item failed. functionArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let functionArnQueryItem = ClientRuntime.URLQueryItem(name: "functionArn".urlPercentEncoding(), value: Swift.String(functionArn).urlPercentEncoding())
            items.append(functionArnQueryItem)
            return items
        }
    }
}

extension DisassociateLambdaFunctionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/lambda-function"
    }
}

public struct DisassociateLambdaFunctionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Lambda function being disassociated.
    /// This member is required.
    public var functionArn: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance..
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        functionArn: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.functionArn = functionArn
        self.instanceId = instanceId
    }
}

struct DisassociateLambdaFunctionInputBody: Swift.Equatable {
}

extension DisassociateLambdaFunctionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateLambdaFunctionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateLambdaFunctionOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateLambdaFunctionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateLexBotInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let lexRegion = lexRegion else {
                let message = "Creating a URL Query Item failed. lexRegion is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let lexRegionQueryItem = ClientRuntime.URLQueryItem(name: "lexRegion".urlPercentEncoding(), value: Swift.String(lexRegion).urlPercentEncoding())
            items.append(lexRegionQueryItem)
            guard let botName = botName else {
                let message = "Creating a URL Query Item failed. botName is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let botNameQueryItem = ClientRuntime.URLQueryItem(name: "botName".urlPercentEncoding(), value: Swift.String(botName).urlPercentEncoding())
            items.append(botNameQueryItem)
            return items
        }
    }
}

extension DisassociateLexBotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/lex-bot"
    }
}

public struct DisassociateLexBotInput: Swift.Equatable {
    /// The name of the Amazon Lex bot. Maximum character limit of 50.
    /// This member is required.
    public var botName: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The Amazon Web Services Region in which the Amazon Lex bot has been created.
    /// This member is required.
    public var lexRegion: Swift.String?

    public init(
        botName: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        lexRegion: Swift.String? = nil
    )
    {
        self.botName = botName
        self.instanceId = instanceId
        self.lexRegion = lexRegion
    }
}

struct DisassociateLexBotInputBody: Swift.Equatable {
}

extension DisassociateLexBotInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateLexBotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateLexBotOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateLexBotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociatePhoneNumberContactFlowInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let instanceId = instanceId else {
                let message = "Creating a URL Query Item failed. instanceId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let instanceIdQueryItem = ClientRuntime.URLQueryItem(name: "instanceId".urlPercentEncoding(), value: Swift.String(instanceId).urlPercentEncoding())
            items.append(instanceIdQueryItem)
            return items
        }
    }
}

extension DisassociatePhoneNumberContactFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let phoneNumberId = phoneNumberId else {
            return nil
        }
        return "/phone-number/\(phoneNumberId.urlPercentEncoding())/contact-flow"
    }
}

public struct DisassociatePhoneNumberContactFlowInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A unique identifier for the phone number.
    /// This member is required.
    public var phoneNumberId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        phoneNumberId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.phoneNumberId = phoneNumberId
    }
}

struct DisassociatePhoneNumberContactFlowInputBody: Swift.Equatable {
}

extension DisassociatePhoneNumberContactFlowInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociatePhoneNumberContactFlowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociatePhoneNumberContactFlowOutput: Swift.Equatable {

    public init() { }
}

enum DisassociatePhoneNumberContactFlowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateQueueQuickConnectsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quickConnectIds = "QuickConnectIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let quickConnectIds = quickConnectIds {
            var quickConnectIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .quickConnectIds)
            for quickconnectid0 in quickConnectIds {
                try quickConnectIdsContainer.encode(quickconnectid0)
            }
        }
    }
}

extension DisassociateQueueQuickConnectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let queueId = queueId else {
            return nil
        }
        return "/queues/\(instanceId.urlPercentEncoding())/\(queueId.urlPercentEncoding())/disassociate-quick-connects"
    }
}

public struct DisassociateQueueQuickConnectsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the queue.
    /// This member is required.
    public var queueId: Swift.String?
    /// The quick connects to disassociate from the queue.
    /// This member is required.
    public var quickConnectIds: [Swift.String]?

    public init(
        instanceId: Swift.String? = nil,
        queueId: Swift.String? = nil,
        quickConnectIds: [Swift.String]? = nil
    )
    {
        self.instanceId = instanceId
        self.queueId = queueId
        self.quickConnectIds = quickConnectIds
    }
}

struct DisassociateQueueQuickConnectsInputBody: Swift.Equatable {
    let quickConnectIds: [Swift.String]?
}

extension DisassociateQueueQuickConnectsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quickConnectIds = "QuickConnectIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quickConnectIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .quickConnectIds)
        var quickConnectIdsDecoded0:[Swift.String]? = nil
        if let quickConnectIdsContainer = quickConnectIdsContainer {
            quickConnectIdsDecoded0 = [Swift.String]()
            for string0 in quickConnectIdsContainer {
                if let string0 = string0 {
                    quickConnectIdsDecoded0?.append(string0)
                }
            }
        }
        quickConnectIds = quickConnectIdsDecoded0
    }
}

extension DisassociateQueueQuickConnectsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateQueueQuickConnectsOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateQueueQuickConnectsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateRoutingProfileQueuesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queueReferences = "QueueReferences"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queueReferences = queueReferences {
            var queueReferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queueReferences)
            for routingprofilequeuereference0 in queueReferences {
                try queueReferencesContainer.encode(routingprofilequeuereference0)
            }
        }
    }
}

extension DisassociateRoutingProfileQueuesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let routingProfileId = routingProfileId else {
            return nil
        }
        return "/routing-profiles/\(instanceId.urlPercentEncoding())/\(routingProfileId.urlPercentEncoding())/disassociate-queues"
    }
}

public struct DisassociateRoutingProfileQueuesInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The queues to disassociate from this routing profile.
    /// This member is required.
    public var queueReferences: [ConnectClientTypes.RoutingProfileQueueReference]?
    /// The identifier of the routing profile.
    /// This member is required.
    public var routingProfileId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        queueReferences: [ConnectClientTypes.RoutingProfileQueueReference]? = nil,
        routingProfileId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.queueReferences = queueReferences
        self.routingProfileId = routingProfileId
    }
}

struct DisassociateRoutingProfileQueuesInputBody: Swift.Equatable {
    let queueReferences: [ConnectClientTypes.RoutingProfileQueueReference]?
}

extension DisassociateRoutingProfileQueuesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queueReferences = "QueueReferences"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueReferencesContainer = try containerValues.decodeIfPresent([ConnectClientTypes.RoutingProfileQueueReference?].self, forKey: .queueReferences)
        var queueReferencesDecoded0:[ConnectClientTypes.RoutingProfileQueueReference]? = nil
        if let queueReferencesContainer = queueReferencesContainer {
            queueReferencesDecoded0 = [ConnectClientTypes.RoutingProfileQueueReference]()
            for structure0 in queueReferencesContainer {
                if let structure0 = structure0 {
                    queueReferencesDecoded0?.append(structure0)
                }
            }
        }
        queueReferences = queueReferencesDecoded0
    }
}

extension DisassociateRoutingProfileQueuesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateRoutingProfileQueuesOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateRoutingProfileQueuesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateSecurityKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let associationId = associationId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/security-key/\(associationId.urlPercentEncoding())"
    }
}

public struct DisassociateSecurityKeyInput: Swift.Equatable {
    /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
    /// This member is required.
    public var associationId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        associationId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.associationId = associationId
        self.instanceId = instanceId
    }
}

struct DisassociateSecurityKeyInputBody: Swift.Equatable {
}

extension DisassociateSecurityKeyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateSecurityKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateSecurityKeyOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateSecurityKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateTrafficDistributionGroupUserInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let instanceId = instanceId else {
                let message = "Creating a URL Query Item failed. instanceId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let instanceIdQueryItem = ClientRuntime.URLQueryItem(name: "InstanceId".urlPercentEncoding(), value: Swift.String(instanceId).urlPercentEncoding())
            items.append(instanceIdQueryItem)
            guard let userId = userId else {
                let message = "Creating a URL Query Item failed. userId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let userIdQueryItem = ClientRuntime.URLQueryItem(name: "UserId".urlPercentEncoding(), value: Swift.String(userId).urlPercentEncoding())
            items.append(userIdQueryItem)
            return items
        }
    }
}

extension DisassociateTrafficDistributionGroupUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trafficDistributionGroupId = trafficDistributionGroupId else {
            return nil
        }
        return "/traffic-distribution-group/\(trafficDistributionGroupId.urlPercentEncoding())/user"
    }
}

public struct DisassociateTrafficDistributionGroupUserInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.
    /// This member is required.
    public var trafficDistributionGroupId: Swift.String?
    /// The identifier for the user. This can be the ID or the ARN of the user.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        trafficDistributionGroupId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.trafficDistributionGroupId = trafficDistributionGroupId
        self.userId = userId
    }
}

struct DisassociateTrafficDistributionGroupUserInputBody: Swift.Equatable {
}

extension DisassociateTrafficDistributionGroupUserInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateTrafficDistributionGroupUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateTrafficDistributionGroupUserOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateTrafficDistributionGroupUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectClientTypes.DisconnectReason: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension ConnectClientTypes {
    /// Contains details about why a contact was disconnected. Only Amazon Connect outbound campaigns can provide this field.
    public struct DisconnectReason: Swift.Equatable {
        /// A code that indicates how the contact was terminated.
        public var code: Swift.String?

        public init(
            code: Swift.String? = nil
        )
        {
            self.code = code
        }
    }

}

extension DismissUserContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = self.contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
    }
}

extension DismissUserContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let userId = userId else {
            return nil
        }
        return "/users/\(instanceId.urlPercentEncoding())/\(userId.urlPercentEncoding())/contact"
    }
}

public struct DismissUserContactInput: Swift.Equatable {
    /// The identifier of the contact.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the user account.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        contactId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.contactId = contactId
        self.instanceId = instanceId
        self.userId = userId
    }
}

struct DismissUserContactInputBody: Swift.Equatable {
    let contactId: Swift.String?
}

extension DismissUserContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
    }
}

extension DismissUserContactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DismissUserContactOutput: Swift.Equatable {

    public init() { }
}

enum DismissUserContactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectClientTypes.Distribution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case percentage = "Percentage"
        case region = "Region"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if percentage != 0 {
            try encodeContainer.encode(percentage, forKey: .percentage)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let percentageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .percentage) ?? 0
        percentage = percentageDecoded
    }
}

extension ConnectClientTypes {
    /// Information about a traffic distribution.
    public struct Distribution: Swift.Equatable {
        /// The percentage of the traffic that is distributed, in increments of 10.
        /// This member is required.
        public var percentage: Swift.Int
        /// The Amazon Web Services Region where the traffic is distributed.
        /// This member is required.
        public var region: Swift.String?

        public init(
            percentage: Swift.Int = 0,
            region: Swift.String? = nil
        )
        {
            self.percentage = percentage
            self.region = region
        }
    }

}

extension DuplicateResourceException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DuplicateResourceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A resource with the specified name already exists.
public struct DuplicateResourceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DuplicateResourceException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DuplicateResourceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DuplicateResourceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectClientTypes.EmailReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ConnectClientTypes {
    /// Information about a reference when the referenceType is EMAIL. Otherwise, null.
    public struct EmailReference: Swift.Equatable {
        /// Identifier of the email reference.
        public var name: Swift.String?
        /// A valid email address.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension ConnectClientTypes.EmptyFieldValue: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ConnectClientTypes {
    /// An empty value.
    public struct EmptyFieldValue: Swift.Equatable {

        public init() { }
    }

}

extension ConnectClientTypes.EncryptionConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionType = "EncryptionType"
        case keyId = "KeyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionType = self.encryptionType {
            try encodeContainer.encode(encryptionType.rawValue, forKey: .encryptionType)
        }
        if let keyId = self.keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let keyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyId)
        keyId = keyIdDecoded
    }
}

extension ConnectClientTypes {
    /// The encryption configuration.
    public struct EncryptionConfig: Swift.Equatable {
        /// The type of encryption.
        /// This member is required.
        public var encryptionType: ConnectClientTypes.EncryptionType?
        /// The full ARN of the encryption key. Be sure to provide the full ARN of the encryption key, not just the ID. Amazon Connect supports only KMS keys with the default key spec of [SYMMETRIC_DEFAULT](https://docs.aws.amazon.com/kms/latest/developerguide/asymmetric-key-specs.html#key-spec-symmetric-default).
        /// This member is required.
        public var keyId: Swift.String?

        public init(
            encryptionType: ConnectClientTypes.EncryptionType? = nil,
            keyId: Swift.String? = nil
        )
        {
            self.encryptionType = encryptionType
            self.keyId = keyId
        }
    }

}

extension ConnectClientTypes {
    public enum EncryptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case kms
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionType] {
            return [
                .kms,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .kms: return "KMS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionType(rawValue: rawValue) ?? EncryptionType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.EndAssociatedTasksActionDefinition: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ConnectClientTypes {
    /// End associated tasks related to a case.
    public struct EndAssociatedTasksActionDefinition: Swift.Equatable {

        public init() { }
    }

}

extension ConnectClientTypes.Endpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = self.address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.EndpointType.self, forKey: .type)
        type = typeDecoded
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
    }
}

extension ConnectClientTypes {
    /// Information about the endpoint.
    public struct Endpoint: Swift.Equatable {
        /// Address of the endpoint.
        public var address: Swift.String?
        /// Type of the endpoint.
        public var type: ConnectClientTypes.EndpointType?

        public init(
            address: Swift.String? = nil,
            type: ConnectClientTypes.EndpointType? = nil
        )
        {
            self.address = address
            self.type = type
        }
    }

}

extension ConnectClientTypes {
    public enum EndpointType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case contactFlow
        case telephoneNumber
        case voip
        case sdkUnknown(Swift.String)

        public static var allCases: [EndpointType] {
            return [
                .contactFlow,
                .telephoneNumber,
                .voip,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contactFlow: return "CONTACT_FLOW"
            case .telephoneNumber: return "TELEPHONE_NUMBER"
            case .voip: return "VOIP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EndpointType(rawValue: rawValue) ?? EndpointType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.ErrorResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension ConnectClientTypes {
    /// This API is in preview release for Amazon Connect and is subject to change. List of errors for dataset association failures.
    public struct ErrorResult: Swift.Equatable {
        /// The error code.
        public var errorCode: Swift.String?
        /// The corresponding error message for the error code.
        public var errorMessage: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension ConnectClientTypes.Evaluation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case answers = "Answers"
        case createdTime = "CreatedTime"
        case evaluationArn = "EvaluationArn"
        case evaluationId = "EvaluationId"
        case lastModifiedTime = "LastModifiedTime"
        case metadata = "Metadata"
        case notes = "Notes"
        case scores = "Scores"
        case status = "Status"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let answers = answers {
            var answersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .answers)
            for (dictKey0, evaluationAnswersOutputMap0) in answers {
                try answersContainer.encode(evaluationAnswersOutputMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let evaluationArn = self.evaluationArn {
            try encodeContainer.encode(evaluationArn, forKey: .evaluationArn)
        }
        if let evaluationId = self.evaluationId {
            try encodeContainer.encode(evaluationId, forKey: .evaluationId)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let notes = notes {
            var notesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .notes)
            for (dictKey0, evaluationNotesMap0) in notes {
                try notesContainer.encode(evaluationNotesMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let scores = scores {
            var scoresContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .scores)
            for (dictKey0, evaluationScoresMap0) in scores {
                try scoresContainer.encode(evaluationScoresMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationId)
        evaluationId = evaluationIdDecoded
        let evaluationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationArn)
        evaluationArn = evaluationArnDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.EvaluationMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let answersContainer = try containerValues.decodeIfPresent([Swift.String: ConnectClientTypes.EvaluationAnswerOutput?].self, forKey: .answers)
        var answersDecoded0: [Swift.String:ConnectClientTypes.EvaluationAnswerOutput]? = nil
        if let answersContainer = answersContainer {
            answersDecoded0 = [Swift.String:ConnectClientTypes.EvaluationAnswerOutput]()
            for (key0, evaluationansweroutput0) in answersContainer {
                if let evaluationansweroutput0 = evaluationansweroutput0 {
                    answersDecoded0?[key0] = evaluationansweroutput0
                }
            }
        }
        answers = answersDecoded0
        let notesContainer = try containerValues.decodeIfPresent([Swift.String: ConnectClientTypes.EvaluationNote?].self, forKey: .notes)
        var notesDecoded0: [Swift.String:ConnectClientTypes.EvaluationNote]? = nil
        if let notesContainer = notesContainer {
            notesDecoded0 = [Swift.String:ConnectClientTypes.EvaluationNote]()
            for (key0, evaluationnote0) in notesContainer {
                if let evaluationnote0 = evaluationnote0 {
                    notesDecoded0?[key0] = evaluationnote0
                }
            }
        }
        notes = notesDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.EvaluationStatus.self, forKey: .status)
        status = statusDecoded
        let scoresContainer = try containerValues.decodeIfPresent([Swift.String: ConnectClientTypes.EvaluationScore?].self, forKey: .scores)
        var scoresDecoded0: [Swift.String:ConnectClientTypes.EvaluationScore]? = nil
        if let scoresContainer = scoresContainer {
            scoresDecoded0 = [Swift.String:ConnectClientTypes.EvaluationScore]()
            for (key0, evaluationscore0) in scoresContainer {
                if let evaluationscore0 = evaluationscore0 {
                    scoresDecoded0?[key0] = evaluationscore0
                }
            }
        }
        scores = scoresDecoded0
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ConnectClientTypes {
    /// Information about a contact evaluation.
    public struct Evaluation: Swift.Equatable {
        /// A map of question identifiers to answer value.
        /// This member is required.
        public var answers: [Swift.String:ConnectClientTypes.EvaluationAnswerOutput]?
        /// The timestamp for when the evaluation was created.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) for the contact evaluation resource.
        /// This member is required.
        public var evaluationArn: Swift.String?
        /// A unique identifier for the contact evaluation.
        /// This member is required.
        public var evaluationId: Swift.String?
        /// The timestamp for when the evaluation was last updated.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// Metadata about the contact evaluation.
        /// This member is required.
        public var metadata: ConnectClientTypes.EvaluationMetadata?
        /// A map of question identifiers to note value.
        /// This member is required.
        public var notes: [Swift.String:ConnectClientTypes.EvaluationNote]?
        /// A map of item (section or question) identifiers to score value.
        public var scores: [Swift.String:ConnectClientTypes.EvaluationScore]?
        /// The status of the contact evaluation.
        /// This member is required.
        public var status: ConnectClientTypes.EvaluationStatus?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public var tags: [Swift.String:Swift.String]?

        public init(
            answers: [Swift.String:ConnectClientTypes.EvaluationAnswerOutput]? = nil,
            createdTime: ClientRuntime.Date? = nil,
            evaluationArn: Swift.String? = nil,
            evaluationId: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            metadata: ConnectClientTypes.EvaluationMetadata? = nil,
            notes: [Swift.String:ConnectClientTypes.EvaluationNote]? = nil,
            scores: [Swift.String:ConnectClientTypes.EvaluationScore]? = nil,
            status: ConnectClientTypes.EvaluationStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.answers = answers
            self.createdTime = createdTime
            self.evaluationArn = evaluationArn
            self.evaluationId = evaluationId
            self.lastModifiedTime = lastModifiedTime
            self.metadata = metadata
            self.notes = notes
            self.scores = scores
            self.status = status
            self.tags = tags
        }
    }

}

extension ConnectClientTypes.EvaluationAnswerData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notapplicable = "NotApplicable"
        case numericvalue = "NumericValue"
        case stringvalue = "StringValue"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .notapplicable(notapplicable):
                try container.encode(notapplicable, forKey: .notapplicable)
            case let .numericvalue(numericvalue):
                try container.encode(numericvalue, forKey: .numericvalue)
            case let .stringvalue(stringvalue):
                try container.encode(stringvalue, forKey: .stringvalue)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let stringvalueDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .stringvalue)
        if let stringvalue = stringvalueDecoded {
            self = .stringvalue(stringvalue)
            return
        }
        let numericvalueDecoded = try values.decodeIfPresent(Swift.Double.self, forKey: .numericvalue)
        if let numericvalue = numericvalueDecoded {
            self = .numericvalue(numericvalue)
            return
        }
        let notapplicableDecoded = try values.decodeIfPresent(Swift.Bool.self, forKey: .notapplicable)
        if let notapplicable = notapplicableDecoded {
            self = .notapplicable(notapplicable)
            return
        }
        self = .sdkUnknown("")
    }
}

extension ConnectClientTypes {
    /// Information about answer data for a contact evaluation. Answer data must be either string, numeric, or not applicable.
    public enum EvaluationAnswerData: Swift.Equatable {
        /// The string value for an answer in a contact evaluation.
        case stringvalue(Swift.String)
        /// The numeric value for an answer in a contact evaluation.
        case numericvalue(Swift.Double)
        /// The flag to mark the question as not applicable.
        case notapplicable(Swift.Bool)
        case sdkUnknown(Swift.String)
    }

}

extension ConnectClientTypes.EvaluationAnswerInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.EvaluationAnswerData.self, forKey: .value)
        value = valueDecoded
    }
}

extension ConnectClientTypes {
    /// Information about input answers for a contact evaluation.
    public struct EvaluationAnswerInput: Swift.Equatable {
        /// The value for an answer in a contact evaluation.
        public var value: ConnectClientTypes.EvaluationAnswerData?

        public init(
            value: ConnectClientTypes.EvaluationAnswerData? = nil
        )
        {
            self.value = value
        }
    }

}

extension ConnectClientTypes.EvaluationAnswerOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case systemSuggestedValue = "SystemSuggestedValue"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let systemSuggestedValue = self.systemSuggestedValue {
            try encodeContainer.encode(systemSuggestedValue, forKey: .systemSuggestedValue)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.EvaluationAnswerData.self, forKey: .value)
        value = valueDecoded
        let systemSuggestedValueDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.EvaluationAnswerData.self, forKey: .systemSuggestedValue)
        systemSuggestedValue = systemSuggestedValueDecoded
    }
}

extension ConnectClientTypes {
    /// Information about output answers for a contact evaluation.
    public struct EvaluationAnswerOutput: Swift.Equatable {
        /// The system suggested value for an answer in a contact evaluation.
        public var systemSuggestedValue: ConnectClientTypes.EvaluationAnswerData?
        /// The value for an answer in a contact evaluation.
        public var value: ConnectClientTypes.EvaluationAnswerData?

        public init(
            systemSuggestedValue: ConnectClientTypes.EvaluationAnswerData? = nil,
            value: ConnectClientTypes.EvaluationAnswerData? = nil
        )
        {
            self.systemSuggestedValue = systemSuggestedValue
            self.value = value
        }
    }

}

extension ConnectClientTypes.EvaluationForm: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdBy = "CreatedBy"
        case createdTime = "CreatedTime"
        case description = "Description"
        case evaluationFormArn = "EvaluationFormArn"
        case evaluationFormId = "EvaluationFormId"
        case evaluationFormVersion = "EvaluationFormVersion"
        case items = "Items"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedTime = "LastModifiedTime"
        case locked = "Locked"
        case scoringStrategy = "ScoringStrategy"
        case status = "Status"
        case tags = "Tags"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let evaluationFormArn = self.evaluationFormArn {
            try encodeContainer.encode(evaluationFormArn, forKey: .evaluationFormArn)
        }
        if let evaluationFormId = self.evaluationFormId {
            try encodeContainer.encode(evaluationFormId, forKey: .evaluationFormId)
        }
        if evaluationFormVersion != 0 {
            try encodeContainer.encode(evaluationFormVersion, forKey: .evaluationFormVersion)
        }
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for evaluationformitem0 in items {
                try itemsContainer.encode(evaluationformitem0)
            }
        }
        if let lastModifiedBy = self.lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if locked != false {
            try encodeContainer.encode(locked, forKey: .locked)
        }
        if let scoringStrategy = self.scoringStrategy {
            try encodeContainer.encode(scoringStrategy, forKey: .scoringStrategy)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationFormIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationFormId)
        evaluationFormId = evaluationFormIdDecoded
        let evaluationFormVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .evaluationFormVersion) ?? 0
        evaluationFormVersion = evaluationFormVersionDecoded
        let lockedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .locked) ?? false
        locked = lockedDecoded
        let evaluationFormArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationFormArn)
        evaluationFormArn = evaluationFormArnDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.EvaluationFormVersionStatus.self, forKey: .status)
        status = statusDecoded
        let itemsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.EvaluationFormItem?].self, forKey: .items)
        var itemsDecoded0:[ConnectClientTypes.EvaluationFormItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ConnectClientTypes.EvaluationFormItem]()
            for union0 in itemsContainer {
                if let union0 = union0 {
                    itemsDecoded0?.append(union0)
                }
            }
        }
        items = itemsDecoded0
        let scoringStrategyDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.EvaluationFormScoringStrategy.self, forKey: .scoringStrategy)
        scoringStrategy = scoringStrategyDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ConnectClientTypes {
    /// Information about the evaluation form.
    public struct EvaluationForm: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the user who created the evaluation form.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The timestamp for when the evaluation form was created.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// The description of the evaluation form.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) for the evaluation form resource.
        /// This member is required.
        public var evaluationFormArn: Swift.String?
        /// The unique identifier for the evaluation form.
        /// This member is required.
        public var evaluationFormId: Swift.String?
        /// A version of the evaluation form.
        /// This member is required.
        public var evaluationFormVersion: Swift.Int
        /// Items that are part of the evaluation form. The total number of sections and questions must not exceed 100 each. Questions must be contained in a section.
        /// This member is required.
        public var items: [ConnectClientTypes.EvaluationFormItem]?
        /// The Amazon Resource Name (ARN) of the user who last updated the evaluation form.
        /// This member is required.
        public var lastModifiedBy: Swift.String?
        /// The timestamp for when the evaluation form was last updated.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The flag indicating whether the evaluation form is locked for changes.
        /// This member is required.
        public var locked: Swift.Bool
        /// A scoring strategy of the evaluation form.
        public var scoringStrategy: ConnectClientTypes.EvaluationFormScoringStrategy?
        /// The status of the evaluation form.
        /// This member is required.
        public var status: ConnectClientTypes.EvaluationFormVersionStatus?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public var tags: [Swift.String:Swift.String]?
        /// A title of the evaluation form.
        /// This member is required.
        public var title: Swift.String?

        public init(
            createdBy: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            evaluationFormArn: Swift.String? = nil,
            evaluationFormId: Swift.String? = nil,
            evaluationFormVersion: Swift.Int = 0,
            items: [ConnectClientTypes.EvaluationFormItem]? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            locked: Swift.Bool = false,
            scoringStrategy: ConnectClientTypes.EvaluationFormScoringStrategy? = nil,
            status: ConnectClientTypes.EvaluationFormVersionStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            title: Swift.String? = nil
        )
        {
            self.createdBy = createdBy
            self.createdTime = createdTime
            self.description = description
            self.evaluationFormArn = evaluationFormArn
            self.evaluationFormId = evaluationFormId
            self.evaluationFormVersion = evaluationFormVersion
            self.items = items
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.locked = locked
            self.scoringStrategy = scoringStrategy
            self.status = status
            self.tags = tags
            self.title = title
        }
    }

}

extension ConnectClientTypes.EvaluationFormContent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case evaluationFormArn = "EvaluationFormArn"
        case evaluationFormId = "EvaluationFormId"
        case evaluationFormVersion = "EvaluationFormVersion"
        case items = "Items"
        case scoringStrategy = "ScoringStrategy"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let evaluationFormArn = self.evaluationFormArn {
            try encodeContainer.encode(evaluationFormArn, forKey: .evaluationFormArn)
        }
        if let evaluationFormId = self.evaluationFormId {
            try encodeContainer.encode(evaluationFormId, forKey: .evaluationFormId)
        }
        if evaluationFormVersion != 0 {
            try encodeContainer.encode(evaluationFormVersion, forKey: .evaluationFormVersion)
        }
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for evaluationformitem0 in items {
                try itemsContainer.encode(evaluationformitem0)
            }
        }
        if let scoringStrategy = self.scoringStrategy {
            try encodeContainer.encode(scoringStrategy, forKey: .scoringStrategy)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationFormVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .evaluationFormVersion) ?? 0
        evaluationFormVersion = evaluationFormVersionDecoded
        let evaluationFormIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationFormId)
        evaluationFormId = evaluationFormIdDecoded
        let evaluationFormArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationFormArn)
        evaluationFormArn = evaluationFormArnDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let itemsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.EvaluationFormItem?].self, forKey: .items)
        var itemsDecoded0:[ConnectClientTypes.EvaluationFormItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ConnectClientTypes.EvaluationFormItem]()
            for union0 in itemsContainer {
                if let union0 = union0 {
                    itemsDecoded0?.append(union0)
                }
            }
        }
        items = itemsDecoded0
        let scoringStrategyDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.EvaluationFormScoringStrategy.self, forKey: .scoringStrategy)
        scoringStrategy = scoringStrategyDecoded
    }
}

extension ConnectClientTypes {
    /// Information about an evaluation form used in a contact evaluation.
    public struct EvaluationFormContent: Swift.Equatable {
        /// The description of the evaluation form.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) for the evaluation form resource.
        /// This member is required.
        public var evaluationFormArn: Swift.String?
        /// The unique identifier for the evaluation form.
        /// This member is required.
        public var evaluationFormId: Swift.String?
        /// A version of the evaluation form.
        /// This member is required.
        public var evaluationFormVersion: Swift.Int
        /// Items that are part of the evaluation form. The total number of sections and questions must not exceed 100 each. Questions must be contained in a section.
        /// This member is required.
        public var items: [ConnectClientTypes.EvaluationFormItem]?
        /// A scoring strategy of the evaluation form.
        public var scoringStrategy: ConnectClientTypes.EvaluationFormScoringStrategy?
        /// A title of the evaluation form.
        /// This member is required.
        public var title: Swift.String?

        public init(
            description: Swift.String? = nil,
            evaluationFormArn: Swift.String? = nil,
            evaluationFormId: Swift.String? = nil,
            evaluationFormVersion: Swift.Int = 0,
            items: [ConnectClientTypes.EvaluationFormItem]? = nil,
            scoringStrategy: ConnectClientTypes.EvaluationFormScoringStrategy? = nil,
            title: Swift.String? = nil
        )
        {
            self.description = description
            self.evaluationFormArn = evaluationFormArn
            self.evaluationFormId = evaluationFormId
            self.evaluationFormVersion = evaluationFormVersion
            self.items = items
            self.scoringStrategy = scoringStrategy
            self.title = title
        }
    }

}

extension ConnectClientTypes.EvaluationFormItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case question = "Question"
        case section = "Section"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .question(question):
                try container.encode(question, forKey: .question)
            case let .section(section):
                try container.encode(section, forKey: .section)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let sectionDecoded = try values.decodeIfPresent(ConnectClientTypes.EvaluationFormSection.self, forKey: .section)
        if let section = sectionDecoded {
            self = .section(section)
            return
        }
        let questionDecoded = try values.decodeIfPresent(ConnectClientTypes.EvaluationFormQuestion.self, forKey: .question)
        if let question = questionDecoded {
            self = .question(question)
            return
        }
        self = .sdkUnknown("")
    }
}

extension ConnectClientTypes {
    /// Information about an item from an evaluation form. The item must be either a section or a question.
    public indirect enum EvaluationFormItem: Swift.Equatable {
        /// The information of the section.
        case section(ConnectClientTypes.EvaluationFormSection)
        /// The information of the question.
        case question(ConnectClientTypes.EvaluationFormQuestion)
        case sdkUnknown(Swift.String)
    }

}

extension ConnectClientTypes.EvaluationFormNumericQuestionAutomation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case propertyvalue = "PropertyValue"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .propertyvalue(propertyvalue):
                try container.encode(propertyvalue, forKey: .propertyvalue)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let propertyvalueDecoded = try values.decodeIfPresent(ConnectClientTypes.NumericQuestionPropertyValueAutomation.self, forKey: .propertyvalue)
        if let propertyvalue = propertyvalueDecoded {
            self = .propertyvalue(propertyvalue)
            return
        }
        self = .sdkUnknown("")
    }
}

extension ConnectClientTypes {
    /// Information about the automation configuration in numeric questions.
    public enum EvaluationFormNumericQuestionAutomation: Swift.Equatable {
        /// The property value of the automation.
        case propertyvalue(ConnectClientTypes.NumericQuestionPropertyValueAutomation)
        case sdkUnknown(Swift.String)
    }

}

extension ConnectClientTypes.EvaluationFormNumericQuestionOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automaticFail = "AutomaticFail"
        case maxValue = "MaxValue"
        case minValue = "MinValue"
        case score = "Score"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if automaticFail != false {
            try encodeContainer.encode(automaticFail, forKey: .automaticFail)
        }
        if maxValue != 0 {
            try encodeContainer.encode(maxValue, forKey: .maxValue)
        }
        if minValue != 0 {
            try encodeContainer.encode(minValue, forKey: .minValue)
        }
        if score != 0 {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minValue) ?? 0
        minValue = minValueDecoded
        let maxValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxValue) ?? 0
        maxValue = maxValueDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .score) ?? 0
        score = scoreDecoded
        let automaticFailDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .automaticFail) ?? false
        automaticFail = automaticFailDecoded
    }
}

extension ConnectClientTypes {
    /// Information about the option range used for scoring in numeric questions.
    public struct EvaluationFormNumericQuestionOption: Swift.Equatable {
        /// The flag to mark the option as automatic fail. If an automatic fail answer is provided, the overall evaluation gets a score of 0.
        public var automaticFail: Swift.Bool
        /// The maximum answer value of the range option.
        /// This member is required.
        public var maxValue: Swift.Int
        /// The minimum answer value of the range option.
        /// This member is required.
        public var minValue: Swift.Int
        /// The score assigned to answer values within the range option.
        public var score: Swift.Int

        public init(
            automaticFail: Swift.Bool = false,
            maxValue: Swift.Int = 0,
            minValue: Swift.Int = 0,
            score: Swift.Int = 0
        )
        {
            self.automaticFail = automaticFail
            self.maxValue = maxValue
            self.minValue = minValue
            self.score = score
        }
    }

}

extension ConnectClientTypes.EvaluationFormNumericQuestionProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automation = "Automation"
        case maxValue = "MaxValue"
        case minValue = "MinValue"
        case options = "Options"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let automation = self.automation {
            try encodeContainer.encode(automation, forKey: .automation)
        }
        if maxValue != 0 {
            try encodeContainer.encode(maxValue, forKey: .maxValue)
        }
        if minValue != 0 {
            try encodeContainer.encode(minValue, forKey: .minValue)
        }
        if let options = options {
            var optionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .options)
            for evaluationformnumericquestionoption0 in options {
                try optionsContainer.encode(evaluationformnumericquestionoption0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minValue) ?? 0
        minValue = minValueDecoded
        let maxValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxValue) ?? 0
        maxValue = maxValueDecoded
        let optionsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.EvaluationFormNumericQuestionOption?].self, forKey: .options)
        var optionsDecoded0:[ConnectClientTypes.EvaluationFormNumericQuestionOption]? = nil
        if let optionsContainer = optionsContainer {
            optionsDecoded0 = [ConnectClientTypes.EvaluationFormNumericQuestionOption]()
            for structure0 in optionsContainer {
                if let structure0 = structure0 {
                    optionsDecoded0?.append(structure0)
                }
            }
        }
        options = optionsDecoded0
        let automationDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.EvaluationFormNumericQuestionAutomation.self, forKey: .automation)
        automation = automationDecoded
    }
}

extension ConnectClientTypes {
    /// Information about properties for a numeric question in an evaluation form.
    public struct EvaluationFormNumericQuestionProperties: Swift.Equatable {
        /// The automation properties of the numeric question.
        public var automation: ConnectClientTypes.EvaluationFormNumericQuestionAutomation?
        /// The maximum answer value.
        /// This member is required.
        public var maxValue: Swift.Int
        /// The minimum answer value.
        /// This member is required.
        public var minValue: Swift.Int
        /// The scoring options of the numeric question.
        public var options: [ConnectClientTypes.EvaluationFormNumericQuestionOption]?

        public init(
            automation: ConnectClientTypes.EvaluationFormNumericQuestionAutomation? = nil,
            maxValue: Swift.Int = 0,
            minValue: Swift.Int = 0,
            options: [ConnectClientTypes.EvaluationFormNumericQuestionOption]? = nil
        )
        {
            self.automation = automation
            self.maxValue = maxValue
            self.minValue = minValue
            self.options = options
        }
    }

}

extension ConnectClientTypes.EvaluationFormQuestion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instructions = "Instructions"
        case notApplicableEnabled = "NotApplicableEnabled"
        case questionType = "QuestionType"
        case questionTypeProperties = "QuestionTypeProperties"
        case refId = "RefId"
        case title = "Title"
        case weight = "Weight"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instructions = self.instructions {
            try encodeContainer.encode(instructions, forKey: .instructions)
        }
        if notApplicableEnabled != false {
            try encodeContainer.encode(notApplicableEnabled, forKey: .notApplicableEnabled)
        }
        if let questionType = self.questionType {
            try encodeContainer.encode(questionType.rawValue, forKey: .questionType)
        }
        if let questionTypeProperties = self.questionTypeProperties {
            try encodeContainer.encode(questionTypeProperties, forKey: .questionTypeProperties)
        }
        if let refId = self.refId {
            try encodeContainer.encode(refId, forKey: .refId)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if weight != 0.0 {
            try encodeContainer.encode(weight, forKey: .weight)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let instructionsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instructions)
        instructions = instructionsDecoded
        let refIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .refId)
        refId = refIdDecoded
        let notApplicableEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .notApplicableEnabled) ?? false
        notApplicableEnabled = notApplicableEnabledDecoded
        let questionTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.EvaluationFormQuestionType.self, forKey: .questionType)
        questionType = questionTypeDecoded
        let questionTypePropertiesDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.EvaluationFormQuestionTypeProperties.self, forKey: .questionTypeProperties)
        questionTypeProperties = questionTypePropertiesDecoded
        let weightDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .weight) ?? 0.0
        weight = weightDecoded
    }
}

extension ConnectClientTypes {
    /// Information about a question from an evaluation form.
    public struct EvaluationFormQuestion: Swift.Equatable {
        /// The instructions of the section.
        public var instructions: Swift.String?
        /// The flag to enable not applicable answers to the question.
        public var notApplicableEnabled: Swift.Bool
        /// The type of the question.
        /// This member is required.
        public var questionType: ConnectClientTypes.EvaluationFormQuestionType?
        /// The properties of the type of question. Text questions do not have to define question type properties.
        public var questionTypeProperties: ConnectClientTypes.EvaluationFormQuestionTypeProperties?
        /// The identifier of the question. An identifier must be unique within the evaluation form.
        /// This member is required.
        public var refId: Swift.String?
        /// The title of the question.
        /// This member is required.
        public var title: Swift.String?
        /// The scoring weight of the section.
        public var weight: Swift.Double

        public init(
            instructions: Swift.String? = nil,
            notApplicableEnabled: Swift.Bool = false,
            questionType: ConnectClientTypes.EvaluationFormQuestionType? = nil,
            questionTypeProperties: ConnectClientTypes.EvaluationFormQuestionTypeProperties? = nil,
            refId: Swift.String? = nil,
            title: Swift.String? = nil,
            weight: Swift.Double = 0.0
        )
        {
            self.instructions = instructions
            self.notApplicableEnabled = notApplicableEnabled
            self.questionType = questionType
            self.questionTypeProperties = questionTypeProperties
            self.refId = refId
            self.title = title
            self.weight = weight
        }
    }

}

extension ConnectClientTypes {
    public enum EvaluationFormQuestionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case numeric
        case singleselect
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [EvaluationFormQuestionType] {
            return [
                .numeric,
                .singleselect,
                .text,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .numeric: return "NUMERIC"
            case .singleselect: return "SINGLESELECT"
            case .text: return "TEXT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EvaluationFormQuestionType(rawValue: rawValue) ?? EvaluationFormQuestionType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.EvaluationFormQuestionTypeProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case numeric = "Numeric"
        case singleselect = "SingleSelect"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .numeric(numeric):
                try container.encode(numeric, forKey: .numeric)
            case let .singleselect(singleselect):
                try container.encode(singleselect, forKey: .singleselect)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let numericDecoded = try values.decodeIfPresent(ConnectClientTypes.EvaluationFormNumericQuestionProperties.self, forKey: .numeric)
        if let numeric = numericDecoded {
            self = .numeric(numeric)
            return
        }
        let singleselectDecoded = try values.decodeIfPresent(ConnectClientTypes.EvaluationFormSingleSelectQuestionProperties.self, forKey: .singleselect)
        if let singleselect = singleselectDecoded {
            self = .singleselect(singleselect)
            return
        }
        self = .sdkUnknown("")
    }
}

extension ConnectClientTypes {
    /// Information about properties for a question in an evaluation form. The question type properties must be either for a numeric question or a single select question.
    public enum EvaluationFormQuestionTypeProperties: Swift.Equatable {
        /// The properties of the numeric question.
        case numeric(ConnectClientTypes.EvaluationFormNumericQuestionProperties)
        /// The properties of the numeric question.
        case singleselect(ConnectClientTypes.EvaluationFormSingleSelectQuestionProperties)
        case sdkUnknown(Swift.String)
    }

}

extension ConnectClientTypes {
    public enum EvaluationFormScoringMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case questionOnly
        case sectionOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [EvaluationFormScoringMode] {
            return [
                .questionOnly,
                .sectionOnly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .questionOnly: return "QUESTION_ONLY"
            case .sectionOnly: return "SECTION_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EvaluationFormScoringMode(rawValue: rawValue) ?? EvaluationFormScoringMode.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes {
    public enum EvaluationFormScoringStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [EvaluationFormScoringStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EvaluationFormScoringStatus(rawValue: rawValue) ?? EvaluationFormScoringStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.EvaluationFormScoringStrategy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mode = "Mode"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mode = self.mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.EvaluationFormScoringMode.self, forKey: .mode)
        mode = modeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.EvaluationFormScoringStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ConnectClientTypes {
    /// Information about scoring strategy for an evaluation form.
    public struct EvaluationFormScoringStrategy: Swift.Equatable {
        /// The scoring mode of the evaluation form.
        /// This member is required.
        public var mode: ConnectClientTypes.EvaluationFormScoringMode?
        /// The scoring status of the evaluation form.
        /// This member is required.
        public var status: ConnectClientTypes.EvaluationFormScoringStatus?

        public init(
            mode: ConnectClientTypes.EvaluationFormScoringMode? = nil,
            status: ConnectClientTypes.EvaluationFormScoringStatus? = nil
        )
        {
            self.mode = mode
            self.status = status
        }
    }

}

extension ConnectClientTypes.EvaluationFormSection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instructions = "Instructions"
        case items = "Items"
        case refId = "RefId"
        case title = "Title"
        case weight = "Weight"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instructions = self.instructions {
            try encodeContainer.encode(instructions, forKey: .instructions)
        }
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for evaluationformitem0 in items {
                try itemsContainer.encode(evaluationformitem0)
            }
        }
        if let refId = self.refId {
            try encodeContainer.encode(refId, forKey: .refId)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if weight != 0.0 {
            try encodeContainer.encode(weight, forKey: .weight)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let refIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .refId)
        refId = refIdDecoded
        let instructionsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instructions)
        instructions = instructionsDecoded
        let itemsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.EvaluationFormItem?].self, forKey: .items)
        var itemsDecoded0:[ConnectClientTypes.EvaluationFormItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ConnectClientTypes.EvaluationFormItem]()
            for union0 in itemsContainer {
                if let union0 = union0 {
                    itemsDecoded0?.append(union0)
                }
            }
        }
        items = itemsDecoded0
        let weightDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .weight) ?? 0.0
        weight = weightDecoded
    }
}

extension ConnectClientTypes {
    /// Information about a section from an evaluation form. A section can contain sections and/or questions. Evaluation forms can only contain sections and subsections (two level nesting).
    public struct EvaluationFormSection: Swift.Equatable {
        /// The instructions of the section.
        public var instructions: Swift.String?
        /// The items of the section.
        /// This member is required.
        public var items: [ConnectClientTypes.EvaluationFormItem]?
        /// The identifier of the section. An identifier must be unique within the evaluation form.
        /// This member is required.
        public var refId: Swift.String?
        /// The title of the section.
        /// This member is required.
        public var title: Swift.String?
        /// The scoring weight of the section.
        public var weight: Swift.Double

        public init(
            instructions: Swift.String? = nil,
            items: [ConnectClientTypes.EvaluationFormItem]? = nil,
            refId: Swift.String? = nil,
            title: Swift.String? = nil,
            weight: Swift.Double = 0.0
        )
        {
            self.instructions = instructions
            self.items = items
            self.refId = refId
            self.title = title
            self.weight = weight
        }
    }

}

extension ConnectClientTypes.EvaluationFormSingleSelectQuestionAutomation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultOptionRefId = "DefaultOptionRefId"
        case options = "Options"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultOptionRefId = self.defaultOptionRefId {
            try encodeContainer.encode(defaultOptionRefId, forKey: .defaultOptionRefId)
        }
        if let options = options {
            var optionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .options)
            for evaluationformsingleselectquestionautomationoption0 in options {
                try optionsContainer.encode(evaluationformsingleselectquestionautomationoption0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.EvaluationFormSingleSelectQuestionAutomationOption?].self, forKey: .options)
        var optionsDecoded0:[ConnectClientTypes.EvaluationFormSingleSelectQuestionAutomationOption]? = nil
        if let optionsContainer = optionsContainer {
            optionsDecoded0 = [ConnectClientTypes.EvaluationFormSingleSelectQuestionAutomationOption]()
            for union0 in optionsContainer {
                if let union0 = union0 {
                    optionsDecoded0?.append(union0)
                }
            }
        }
        options = optionsDecoded0
        let defaultOptionRefIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultOptionRefId)
        defaultOptionRefId = defaultOptionRefIdDecoded
    }
}

extension ConnectClientTypes {
    /// Information about the automation configuration in single select questions. Automation options are evaluated in order, and the first matched option is applied. If no automation option matches, and there is a default option, then the default option is applied.
    public struct EvaluationFormSingleSelectQuestionAutomation: Swift.Equatable {
        /// The identifier of the default answer option, when none of the automation options match the criteria.
        public var defaultOptionRefId: Swift.String?
        /// The automation options of the single select question.
        /// This member is required.
        public var options: [ConnectClientTypes.EvaluationFormSingleSelectQuestionAutomationOption]?

        public init(
            defaultOptionRefId: Swift.String? = nil,
            options: [ConnectClientTypes.EvaluationFormSingleSelectQuestionAutomationOption]? = nil
        )
        {
            self.defaultOptionRefId = defaultOptionRefId
            self.options = options
        }
    }

}

extension ConnectClientTypes.EvaluationFormSingleSelectQuestionAutomationOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rulecategory = "RuleCategory"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .rulecategory(rulecategory):
                try container.encode(rulecategory, forKey: .rulecategory)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let rulecategoryDecoded = try values.decodeIfPresent(ConnectClientTypes.SingleSelectQuestionRuleCategoryAutomation.self, forKey: .rulecategory)
        if let rulecategory = rulecategoryDecoded {
            self = .rulecategory(rulecategory)
            return
        }
        self = .sdkUnknown("")
    }
}

extension ConnectClientTypes {
    /// Information about the automation option of a single select question.
    public enum EvaluationFormSingleSelectQuestionAutomationOption: Swift.Equatable {
        /// The automation option based on a rule category for the single select question.
        case rulecategory(ConnectClientTypes.SingleSelectQuestionRuleCategoryAutomation)
        case sdkUnknown(Swift.String)
    }

}

extension ConnectClientTypes {
    public enum EvaluationFormSingleSelectQuestionDisplayMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dropdown
        case radio
        case sdkUnknown(Swift.String)

        public static var allCases: [EvaluationFormSingleSelectQuestionDisplayMode] {
            return [
                .dropdown,
                .radio,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dropdown: return "DROPDOWN"
            case .radio: return "RADIO"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EvaluationFormSingleSelectQuestionDisplayMode(rawValue: rawValue) ?? EvaluationFormSingleSelectQuestionDisplayMode.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.EvaluationFormSingleSelectQuestionOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automaticFail = "AutomaticFail"
        case refId = "RefId"
        case score = "Score"
        case text = "Text"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if automaticFail != false {
            try encodeContainer.encode(automaticFail, forKey: .automaticFail)
        }
        if let refId = self.refId {
            try encodeContainer.encode(refId, forKey: .refId)
        }
        if score != 0 {
            try encodeContainer.encode(score, forKey: .score)
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let refIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .refId)
        refId = refIdDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .score) ?? 0
        score = scoreDecoded
        let automaticFailDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .automaticFail) ?? false
        automaticFail = automaticFailDecoded
    }
}

extension ConnectClientTypes {
    /// Information about the automation configuration in single select questions.
    public struct EvaluationFormSingleSelectQuestionOption: Swift.Equatable {
        /// The flag to mark the option as automatic fail. If an automatic fail answer is provided, the overall evaluation gets a score of 0.
        public var automaticFail: Swift.Bool
        /// The identifier of the answer option. An identifier must be unique within the question.
        /// This member is required.
        public var refId: Swift.String?
        /// The score assigned to the answer option.
        public var score: Swift.Int
        /// The title of the answer option.
        /// This member is required.
        public var text: Swift.String?

        public init(
            automaticFail: Swift.Bool = false,
            refId: Swift.String? = nil,
            score: Swift.Int = 0,
            text: Swift.String? = nil
        )
        {
            self.automaticFail = automaticFail
            self.refId = refId
            self.score = score
            self.text = text
        }
    }

}

extension ConnectClientTypes.EvaluationFormSingleSelectQuestionProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automation = "Automation"
        case displayAs = "DisplayAs"
        case options = "Options"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let automation = self.automation {
            try encodeContainer.encode(automation, forKey: .automation)
        }
        if let displayAs = self.displayAs {
            try encodeContainer.encode(displayAs.rawValue, forKey: .displayAs)
        }
        if let options = options {
            var optionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .options)
            for evaluationformsingleselectquestionoption0 in options {
                try optionsContainer.encode(evaluationformsingleselectquestionoption0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.EvaluationFormSingleSelectQuestionOption?].self, forKey: .options)
        var optionsDecoded0:[ConnectClientTypes.EvaluationFormSingleSelectQuestionOption]? = nil
        if let optionsContainer = optionsContainer {
            optionsDecoded0 = [ConnectClientTypes.EvaluationFormSingleSelectQuestionOption]()
            for structure0 in optionsContainer {
                if let structure0 = structure0 {
                    optionsDecoded0?.append(structure0)
                }
            }
        }
        options = optionsDecoded0
        let displayAsDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.EvaluationFormSingleSelectQuestionDisplayMode.self, forKey: .displayAs)
        displayAs = displayAsDecoded
        let automationDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.EvaluationFormSingleSelectQuestionAutomation.self, forKey: .automation)
        automation = automationDecoded
    }
}

extension ConnectClientTypes {
    /// Information about the options in single select questions.
    public struct EvaluationFormSingleSelectQuestionProperties: Swift.Equatable {
        /// The display mode of the single select question.
        public var automation: ConnectClientTypes.EvaluationFormSingleSelectQuestionAutomation?
        /// The display mode of the single select question.
        public var displayAs: ConnectClientTypes.EvaluationFormSingleSelectQuestionDisplayMode?
        /// The answer options of the single select question.
        /// This member is required.
        public var options: [ConnectClientTypes.EvaluationFormSingleSelectQuestionOption]?

        public init(
            automation: ConnectClientTypes.EvaluationFormSingleSelectQuestionAutomation? = nil,
            displayAs: ConnectClientTypes.EvaluationFormSingleSelectQuestionDisplayMode? = nil,
            options: [ConnectClientTypes.EvaluationFormSingleSelectQuestionOption]? = nil
        )
        {
            self.automation = automation
            self.displayAs = displayAs
            self.options = options
        }
    }

}

extension ConnectClientTypes.EvaluationFormSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeVersion = "ActiveVersion"
        case createdBy = "CreatedBy"
        case createdTime = "CreatedTime"
        case evaluationFormArn = "EvaluationFormArn"
        case evaluationFormId = "EvaluationFormId"
        case lastActivatedBy = "LastActivatedBy"
        case lastActivatedTime = "LastActivatedTime"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedTime = "LastModifiedTime"
        case latestVersion = "LatestVersion"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeVersion = self.activeVersion {
            try encodeContainer.encode(activeVersion, forKey: .activeVersion)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let evaluationFormArn = self.evaluationFormArn {
            try encodeContainer.encode(evaluationFormArn, forKey: .evaluationFormArn)
        }
        if let evaluationFormId = self.evaluationFormId {
            try encodeContainer.encode(evaluationFormId, forKey: .evaluationFormId)
        }
        if let lastActivatedBy = self.lastActivatedBy {
            try encodeContainer.encode(lastActivatedBy, forKey: .lastActivatedBy)
        }
        if let lastActivatedTime = self.lastActivatedTime {
            try encodeContainer.encodeTimestamp(lastActivatedTime, format: .epochSeconds, forKey: .lastActivatedTime)
        }
        if let lastModifiedBy = self.lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if latestVersion != 0 {
            try encodeContainer.encode(latestVersion, forKey: .latestVersion)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationFormIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationFormId)
        evaluationFormId = evaluationFormIdDecoded
        let evaluationFormArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationFormArn)
        evaluationFormArn = evaluationFormArnDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let lastActivatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastActivatedTime)
        lastActivatedTime = lastActivatedTimeDecoded
        let lastActivatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastActivatedBy)
        lastActivatedBy = lastActivatedByDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .latestVersion) ?? 0
        latestVersion = latestVersionDecoded
        let activeVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .activeVersion)
        activeVersion = activeVersionDecoded
    }
}

extension ConnectClientTypes {
    /// Summary information about an evaluation form.
    public struct EvaluationFormSummary: Swift.Equatable {
        /// The version of the active evaluation form version.
        public var activeVersion: Swift.Int?
        /// The Amazon Resource Name (ARN) of the user who created the evaluation form.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The timestamp for when the evaluation form was created.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) for the evaluation form resource.
        /// This member is required.
        public var evaluationFormArn: Swift.String?
        /// The unique identifier for the evaluation form.
        /// This member is required.
        public var evaluationFormId: Swift.String?
        /// The Amazon Resource Name (ARN) of the user who last activated the evaluation form.
        public var lastActivatedBy: Swift.String?
        /// The timestamp for when the evaluation form was last activated.
        public var lastActivatedTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the user who last updated the evaluation form.
        /// This member is required.
        public var lastModifiedBy: Swift.String?
        /// The timestamp for when the evaluation form was last updated.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The version number of the latest evaluation form version.
        /// This member is required.
        public var latestVersion: Swift.Int
        /// A title of the evaluation form.
        /// This member is required.
        public var title: Swift.String?

        public init(
            activeVersion: Swift.Int? = nil,
            createdBy: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            evaluationFormArn: Swift.String? = nil,
            evaluationFormId: Swift.String? = nil,
            lastActivatedBy: Swift.String? = nil,
            lastActivatedTime: ClientRuntime.Date? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            latestVersion: Swift.Int = 0,
            title: Swift.String? = nil
        )
        {
            self.activeVersion = activeVersion
            self.createdBy = createdBy
            self.createdTime = createdTime
            self.evaluationFormArn = evaluationFormArn
            self.evaluationFormId = evaluationFormId
            self.lastActivatedBy = lastActivatedBy
            self.lastActivatedTime = lastActivatedTime
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.latestVersion = latestVersion
            self.title = title
        }
    }

}

extension ConnectClientTypes {
    public enum EvaluationFormVersionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case draft
        case sdkUnknown(Swift.String)

        public static var allCases: [EvaluationFormVersionStatus] {
            return [
                .active,
                .draft,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .draft: return "DRAFT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EvaluationFormVersionStatus(rawValue: rawValue) ?? EvaluationFormVersionStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.EvaluationFormVersionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdBy = "CreatedBy"
        case createdTime = "CreatedTime"
        case evaluationFormArn = "EvaluationFormArn"
        case evaluationFormId = "EvaluationFormId"
        case evaluationFormVersion = "EvaluationFormVersion"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedTime = "LastModifiedTime"
        case locked = "Locked"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let evaluationFormArn = self.evaluationFormArn {
            try encodeContainer.encode(evaluationFormArn, forKey: .evaluationFormArn)
        }
        if let evaluationFormId = self.evaluationFormId {
            try encodeContainer.encode(evaluationFormId, forKey: .evaluationFormId)
        }
        if evaluationFormVersion != 0 {
            try encodeContainer.encode(evaluationFormVersion, forKey: .evaluationFormVersion)
        }
        if let lastModifiedBy = self.lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if locked != false {
            try encodeContainer.encode(locked, forKey: .locked)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationFormArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationFormArn)
        evaluationFormArn = evaluationFormArnDecoded
        let evaluationFormIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationFormId)
        evaluationFormId = evaluationFormIdDecoded
        let evaluationFormVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .evaluationFormVersion) ?? 0
        evaluationFormVersion = evaluationFormVersionDecoded
        let lockedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .locked) ?? false
        locked = lockedDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.EvaluationFormVersionStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
    }
}

extension ConnectClientTypes {
    /// Summary information about an evaluation form.
    public struct EvaluationFormVersionSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the user who created the evaluation form.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The timestamp for when the evaluation form was created.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) for the evaluation form resource.
        /// This member is required.
        public var evaluationFormArn: Swift.String?
        /// The unique identifier for the evaluation form.
        /// This member is required.
        public var evaluationFormId: Swift.String?
        /// A version of the evaluation form.
        /// This member is required.
        public var evaluationFormVersion: Swift.Int
        /// The Amazon Resource Name (ARN) of the user who last updated the evaluation form.
        /// This member is required.
        public var lastModifiedBy: Swift.String?
        /// The timestamp for when the evaluation form was last updated.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The flag indicating whether the evaluation form is locked for changes.
        /// This member is required.
        public var locked: Swift.Bool
        /// The status of the evaluation form.
        /// This member is required.
        public var status: ConnectClientTypes.EvaluationFormVersionStatus?

        public init(
            createdBy: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            evaluationFormArn: Swift.String? = nil,
            evaluationFormId: Swift.String? = nil,
            evaluationFormVersion: Swift.Int = 0,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            locked: Swift.Bool = false,
            status: ConnectClientTypes.EvaluationFormVersionStatus? = nil
        )
        {
            self.createdBy = createdBy
            self.createdTime = createdTime
            self.evaluationFormArn = evaluationFormArn
            self.evaluationFormId = evaluationFormId
            self.evaluationFormVersion = evaluationFormVersion
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.locked = locked
            self.status = status
        }
    }

}

extension ConnectClientTypes.EvaluationMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactAgentId = "ContactAgentId"
        case contactId = "ContactId"
        case evaluatorArn = "EvaluatorArn"
        case score = "Score"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactAgentId = self.contactAgentId {
            try encodeContainer.encode(contactAgentId, forKey: .contactAgentId)
        }
        if let contactId = self.contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let evaluatorArn = self.evaluatorArn {
            try encodeContainer.encode(evaluatorArn, forKey: .evaluatorArn)
        }
        if let score = self.score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let evaluatorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluatorArn)
        evaluatorArn = evaluatorArnDecoded
        let contactAgentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactAgentId)
        contactAgentId = contactAgentIdDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.EvaluationScore.self, forKey: .score)
        score = scoreDecoded
    }
}

extension ConnectClientTypes {
    /// Metadata information about a contact evaluation.
    public struct EvaluationMetadata: Swift.Equatable {
        /// The identifier of the agent who performed the contact.
        public var contactAgentId: Swift.String?
        /// The identifier of the contact in this instance of Amazon Connect.
        /// This member is required.
        public var contactId: Swift.String?
        /// The Amazon Resource Name (ARN) of the user who last updated the evaluation.
        /// This member is required.
        public var evaluatorArn: Swift.String?
        /// The overall score of the contact evaluation.
        public var score: ConnectClientTypes.EvaluationScore?

        public init(
            contactAgentId: Swift.String? = nil,
            contactId: Swift.String? = nil,
            evaluatorArn: Swift.String? = nil,
            score: ConnectClientTypes.EvaluationScore? = nil
        )
        {
            self.contactAgentId = contactAgentId
            self.contactId = contactId
            self.evaluatorArn = evaluatorArn
            self.score = score
        }
    }

}

extension ConnectClientTypes.EvaluationNote: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ConnectClientTypes {
    /// Information about notes for a contact evaluation.
    public struct EvaluationNote: Swift.Equatable {
        /// The note for an item (section or question) in a contact evaluation.
        public var value: Swift.String?

        public init(
            value: Swift.String? = nil
        )
        {
            self.value = value
        }
    }

}

extension ConnectClientTypes.EvaluationScore: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automaticFail = "AutomaticFail"
        case notApplicable = "NotApplicable"
        case percentage = "Percentage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if automaticFail != false {
            try encodeContainer.encode(automaticFail, forKey: .automaticFail)
        }
        if notApplicable != false {
            try encodeContainer.encode(notApplicable, forKey: .notApplicable)
        }
        if percentage != 0.0 {
            try encodeContainer.encode(percentage, forKey: .percentage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let percentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .percentage) ?? 0.0
        percentage = percentageDecoded
        let notApplicableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .notApplicable) ?? false
        notApplicable = notApplicableDecoded
        let automaticFailDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .automaticFail) ?? false
        automaticFail = automaticFailDecoded
    }
}

extension ConnectClientTypes {
    /// Information about scores of a contact evaluation item (section or question).
    public struct EvaluationScore: Swift.Equatable {
        /// The flag that marks the item as automatic fail. If the item or a child item gets an automatic fail answer, this flag will be true.
        public var automaticFail: Swift.Bool
        /// The flag to mark the item as not applicable for scoring.
        public var notApplicable: Swift.Bool
        /// The score percentage for an item in a contact evaluation.
        public var percentage: Swift.Double

        public init(
            automaticFail: Swift.Bool = false,
            notApplicable: Swift.Bool = false,
            percentage: Swift.Double = 0.0
        )
        {
            self.automaticFail = automaticFail
            self.notApplicable = notApplicable
            self.percentage = percentage
        }
    }

}

extension ConnectClientTypes {
    public enum EvaluationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case draft
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [EvaluationStatus] {
            return [
                .draft,
                .submitted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .draft: return "DRAFT"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EvaluationStatus(rawValue: rawValue) ?? EvaluationStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.EvaluationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case evaluationArn = "EvaluationArn"
        case evaluationFormId = "EvaluationFormId"
        case evaluationFormTitle = "EvaluationFormTitle"
        case evaluationId = "EvaluationId"
        case evaluatorArn = "EvaluatorArn"
        case lastModifiedTime = "LastModifiedTime"
        case score = "Score"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let evaluationArn = self.evaluationArn {
            try encodeContainer.encode(evaluationArn, forKey: .evaluationArn)
        }
        if let evaluationFormId = self.evaluationFormId {
            try encodeContainer.encode(evaluationFormId, forKey: .evaluationFormId)
        }
        if let evaluationFormTitle = self.evaluationFormTitle {
            try encodeContainer.encode(evaluationFormTitle, forKey: .evaluationFormTitle)
        }
        if let evaluationId = self.evaluationId {
            try encodeContainer.encode(evaluationId, forKey: .evaluationId)
        }
        if let evaluatorArn = self.evaluatorArn {
            try encodeContainer.encode(evaluatorArn, forKey: .evaluatorArn)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let score = self.score {
            try encodeContainer.encode(score, forKey: .score)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationId)
        evaluationId = evaluationIdDecoded
        let evaluationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationArn)
        evaluationArn = evaluationArnDecoded
        let evaluationFormTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationFormTitle)
        evaluationFormTitle = evaluationFormTitleDecoded
        let evaluationFormIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationFormId)
        evaluationFormId = evaluationFormIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.EvaluationStatus.self, forKey: .status)
        status = statusDecoded
        let evaluatorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluatorArn)
        evaluatorArn = evaluatorArnDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.EvaluationScore.self, forKey: .score)
        score = scoreDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension ConnectClientTypes {
    /// Summary information about a contact evaluation.
    public struct EvaluationSummary: Swift.Equatable {
        /// The timestamp for when the evaluation was created.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) for the contact evaluation resource.
        /// This member is required.
        public var evaluationArn: Swift.String?
        /// The unique identifier for the evaluation form.
        /// This member is required.
        public var evaluationFormId: Swift.String?
        /// A title of the evaluation form.
        /// This member is required.
        public var evaluationFormTitle: Swift.String?
        /// A unique identifier for the contact evaluation.
        /// This member is required.
        public var evaluationId: Swift.String?
        /// The Amazon Resource Name (ARN) of the user who last updated the evaluation.
        /// This member is required.
        public var evaluatorArn: Swift.String?
        /// The timestamp for when the evaluation was last updated.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The overall score of the contact evaluation.
        public var score: ConnectClientTypes.EvaluationScore?
        /// The status of the contact evaluation.
        /// This member is required.
        public var status: ConnectClientTypes.EvaluationStatus?

        public init(
            createdTime: ClientRuntime.Date? = nil,
            evaluationArn: Swift.String? = nil,
            evaluationFormId: Swift.String? = nil,
            evaluationFormTitle: Swift.String? = nil,
            evaluationId: Swift.String? = nil,
            evaluatorArn: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            score: ConnectClientTypes.EvaluationScore? = nil,
            status: ConnectClientTypes.EvaluationStatus? = nil
        )
        {
            self.createdTime = createdTime
            self.evaluationArn = evaluationArn
            self.evaluationFormId = evaluationFormId
            self.evaluationFormTitle = evaluationFormTitle
            self.evaluationId = evaluationId
            self.evaluatorArn = evaluatorArn
            self.lastModifiedTime = lastModifiedTime
            self.score = score
            self.status = status
        }
    }

}

extension ConnectClientTypes.EventBridgeActionDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ConnectClientTypes {
    /// The EventBridge action definition.
    public struct EventBridgeActionDefinition: Swift.Equatable {
        /// The name.
        /// This member is required.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension ConnectClientTypes {
    public enum EventSourceName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case oncasecreate
        case oncaseupdate
        case oncontactevaluationsubmit
        case onmetricdataupdate
        case onpostcallanalysisavailable
        case onpostchatanalysisavailable
        case onrealtimecallanalysisavailable
        case onrealtimechatanalysisavailable
        case onsalesforcecasecreate
        case onzendeskticketcreate
        case onzendeskticketstatusupdate
        case sdkUnknown(Swift.String)

        public static var allCases: [EventSourceName] {
            return [
                .oncasecreate,
                .oncaseupdate,
                .oncontactevaluationsubmit,
                .onmetricdataupdate,
                .onpostcallanalysisavailable,
                .onpostchatanalysisavailable,
                .onrealtimecallanalysisavailable,
                .onrealtimechatanalysisavailable,
                .onsalesforcecasecreate,
                .onzendeskticketcreate,
                .onzendeskticketstatusupdate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .oncasecreate: return "OnCaseCreate"
            case .oncaseupdate: return "OnCaseUpdate"
            case .oncontactevaluationsubmit: return "OnContactEvaluationSubmit"
            case .onmetricdataupdate: return "OnMetricDataUpdate"
            case .onpostcallanalysisavailable: return "OnPostCallAnalysisAvailable"
            case .onpostchatanalysisavailable: return "OnPostChatAnalysisAvailable"
            case .onrealtimecallanalysisavailable: return "OnRealTimeCallAnalysisAvailable"
            case .onrealtimechatanalysisavailable: return "OnRealTimeChatAnalysisAvailable"
            case .onsalesforcecasecreate: return "OnSalesforceCaseCreate"
            case .onzendeskticketcreate: return "OnZendeskTicketCreate"
            case .onzendeskticketstatusupdate: return "OnZendeskTicketStatusUpdate"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventSourceName(rawValue: rawValue) ?? EventSourceName.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.FailedRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureReasonCode = "FailureReasonCode"
        case failureReasonMessage = "FailureReasonMessage"
        case requestIdentifier = "RequestIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureReasonCode = self.failureReasonCode {
            try encodeContainer.encode(failureReasonCode.rawValue, forKey: .failureReasonCode)
        }
        if let failureReasonMessage = self.failureReasonMessage {
            try encodeContainer.encode(failureReasonMessage, forKey: .failureReasonMessage)
        }
        if let requestIdentifier = self.requestIdentifier {
            try encodeContainer.encode(requestIdentifier, forKey: .requestIdentifier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestIdentifier)
        requestIdentifier = requestIdentifierDecoded
        let failureReasonCodeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.FailureReasonCode.self, forKey: .failureReasonCode)
        failureReasonCode = failureReasonCodeDecoded
        let failureReasonMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReasonMessage)
        failureReasonMessage = failureReasonMessageDecoded
    }
}

extension ConnectClientTypes {
    /// Request for which contact failed to be generated.
    public struct FailedRequest: Swift.Equatable {
        /// Reason code for the failure.
        public var failureReasonCode: ConnectClientTypes.FailureReasonCode?
        /// Why the request to create a contact failed.
        public var failureReasonMessage: Swift.String?
        /// Request identifier provided in the API call in the ContactDataRequest to create a contact.
        public var requestIdentifier: Swift.String?

        public init(
            failureReasonCode: ConnectClientTypes.FailureReasonCode? = nil,
            failureReasonMessage: Swift.String? = nil,
            requestIdentifier: Swift.String? = nil
        )
        {
            self.failureReasonCode = failureReasonCode
            self.failureReasonMessage = failureReasonMessage
            self.requestIdentifier = requestIdentifier
        }
    }

}

extension ConnectClientTypes {
    public enum FailureReasonCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case idempotencyException
        case internalError
        case invalidAttributeKey
        case invalidCustomerEndpoint
        case invalidQueue
        case invalidSystemEndpoint
        case missingCampaign
        case missingCustomerEndpoint
        case missingQueueIdAndSystemEndpoint
        case requestThrottled
        case sdkUnknown(Swift.String)

        public static var allCases: [FailureReasonCode] {
            return [
                .idempotencyException,
                .internalError,
                .invalidAttributeKey,
                .invalidCustomerEndpoint,
                .invalidQueue,
                .invalidSystemEndpoint,
                .missingCampaign,
                .missingCustomerEndpoint,
                .missingQueueIdAndSystemEndpoint,
                .requestThrottled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .idempotencyException: return "IDEMPOTENCY_EXCEPTION"
            case .internalError: return "INTERNAL_ERROR"
            case .invalidAttributeKey: return "INVALID_ATTRIBUTE_KEY"
            case .invalidCustomerEndpoint: return "INVALID_CUSTOMER_ENDPOINT"
            case .invalidQueue: return "INVALID_QUEUE"
            case .invalidSystemEndpoint: return "INVALID_SYSTEM_ENDPOINT"
            case .missingCampaign: return "MISSING_CAMPAIGN"
            case .missingCustomerEndpoint: return "MISSING_CUSTOMER_ENDPOINT"
            case .missingQueueIdAndSystemEndpoint: return "MISSING_QUEUE_ID_AND_SYSTEM_ENDPOINT"
            case .requestThrottled: return "REQUEST_THROTTLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FailureReasonCode(rawValue: rawValue) ?? FailureReasonCode.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.FieldValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let valueDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.FieldValueUnion.self, forKey: .value)
        value = valueDecoded
    }
}

extension ConnectClientTypes {
    /// Object for case field values.
    public struct FieldValue: Swift.Equatable {
        /// Unique identifier of a field.
        /// This member is required.
        public var id: Swift.String?
        /// Union of potential field value types.
        /// This member is required.
        public var value: ConnectClientTypes.FieldValueUnion?

        public init(
            id: Swift.String? = nil,
            value: ConnectClientTypes.FieldValueUnion? = nil
        )
        {
            self.id = id
            self.value = value
        }
    }

}

extension ConnectClientTypes.FieldValueUnion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case booleanValue = "BooleanValue"
        case doubleValue = "DoubleValue"
        case emptyValue = "EmptyValue"
        case stringValue = "StringValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if booleanValue != false {
            try encodeContainer.encode(booleanValue, forKey: .booleanValue)
        }
        if let doubleValue = self.doubleValue {
            try encodeContainer.encode(doubleValue, forKey: .doubleValue)
        }
        if let emptyValue = self.emptyValue {
            try encodeContainer.encode(emptyValue, forKey: .emptyValue)
        }
        if let stringValue = self.stringValue {
            try encodeContainer.encode(stringValue, forKey: .stringValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let booleanValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .booleanValue) ?? false
        booleanValue = booleanValueDecoded
        let doubleValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .doubleValue)
        doubleValue = doubleValueDecoded
        let emptyValueDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.EmptyFieldValue.self, forKey: .emptyValue)
        emptyValue = emptyValueDecoded
        let stringValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stringValue)
        stringValue = stringValueDecoded
    }
}

extension ConnectClientTypes {
    /// Object to store union of Field values.
    public struct FieldValueUnion: Swift.Equatable {
        /// A Boolean number value type.
        public var booleanValue: Swift.Bool
        /// a Double number value type.
        public var doubleValue: Swift.Double?
        /// An empty value.
        public var emptyValue: ConnectClientTypes.EmptyFieldValue?
        /// String value type.
        public var stringValue: Swift.String?

        public init(
            booleanValue: Swift.Bool = false,
            doubleValue: Swift.Double? = nil,
            emptyValue: ConnectClientTypes.EmptyFieldValue? = nil,
            stringValue: Swift.String? = nil
        )
        {
            self.booleanValue = booleanValue
            self.doubleValue = doubleValue
            self.emptyValue = emptyValue
            self.stringValue = stringValue
        }
    }

}

extension ConnectClientTypes.FilterV2: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterKey = "FilterKey"
        case filterValues = "FilterValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterKey = self.filterKey {
            try encodeContainer.encode(filterKey, forKey: .filterKey)
        }
        if let filterValues = filterValues {
            var filterValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterValues)
            for resourcearnorid0 in filterValues {
                try filterValuesContainer.encode(resourcearnorid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterKey)
        filterKey = filterKeyDecoded
        let filterValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .filterValues)
        var filterValuesDecoded0:[Swift.String]? = nil
        if let filterValuesContainer = filterValuesContainer {
            filterValuesDecoded0 = [Swift.String]()
            for string0 in filterValuesContainer {
                if let string0 = string0 {
                    filterValuesDecoded0?.append(string0)
                }
            }
        }
        filterValues = filterValuesDecoded0
    }
}

extension ConnectClientTypes {
    /// Contains the filter to apply when retrieving metrics with the [GetMetricDataV2](https://docs.aws.amazon.com/connect/latest/APIReference/API_GetMetricDataV2.html) API.
    public struct FilterV2: Swift.Equatable {
        /// The key to use for filtering data. For example, QUEUE, ROUTING_PROFILE, AGENT, CHANNEL, AGENT_HIERARCHY_LEVEL_ONE, AGENT_HIERARCHY_LEVEL_TWO, AGENT_HIERARCHY_LEVEL_THREE, AGENT_HIERARCHY_LEVEL_FOUR, AGENT_HIERARCHY_LEVEL_FIVE. There must be at least 1 key and a maximum 5 keys.
        public var filterKey: Swift.String?
        /// The identifiers to use for filtering data. For example, if you have a filter key of QUEUE, you would add queue IDs or ARNs in FilterValues.
        public var filterValues: [Swift.String]?

        public init(
            filterKey: Swift.String? = nil,
            filterValues: [Swift.String]? = nil
        )
        {
            self.filterKey = filterKey
            self.filterValues = filterValues
        }
    }

}

extension ConnectClientTypes.Filters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels = "Channels"
        case queues = "Queues"
        case routingProfiles = "RoutingProfiles"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channels = channels {
            var channelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .channels)
            for channel0 in channels {
                try channelsContainer.encode(channel0.rawValue)
            }
        }
        if let queues = queues {
            var queuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queues)
            for queueid0 in queues {
                try queuesContainer.encode(queueid0)
            }
        }
        if let routingProfiles = routingProfiles {
            var routingProfilesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .routingProfiles)
            for routingprofileid0 in routingProfiles {
                try routingProfilesContainer.encode(routingprofileid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .queues)
        var queuesDecoded0:[Swift.String]? = nil
        if let queuesContainer = queuesContainer {
            queuesDecoded0 = [Swift.String]()
            for string0 in queuesContainer {
                if let string0 = string0 {
                    queuesDecoded0?.append(string0)
                }
            }
        }
        queues = queuesDecoded0
        let channelsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.Channel?].self, forKey: .channels)
        var channelsDecoded0:[ConnectClientTypes.Channel]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [ConnectClientTypes.Channel]()
            for enum0 in channelsContainer {
                if let enum0 = enum0 {
                    channelsDecoded0?.append(enum0)
                }
            }
        }
        channels = channelsDecoded0
        let routingProfilesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .routingProfiles)
        var routingProfilesDecoded0:[Swift.String]? = nil
        if let routingProfilesContainer = routingProfilesContainer {
            routingProfilesDecoded0 = [Swift.String]()
            for string0 in routingProfilesContainer {
                if let string0 = string0 {
                    routingProfilesDecoded0?.append(string0)
                }
            }
        }
        routingProfiles = routingProfilesDecoded0
    }
}

extension ConnectClientTypes {
    /// Contains the filter to apply when retrieving metrics.
    public struct Filters: Swift.Equatable {
        /// The channel to use to filter the metrics.
        public var channels: [ConnectClientTypes.Channel]?
        /// The queues to use to filter the metrics. You should specify at least one queue, and can specify up to 100 queues per request. The GetCurrentMetricsData API in particular requires a queue when you include a Filter in your request.
        public var queues: [Swift.String]?
        /// A list of up to 100 routing profile IDs or ARNs.
        public var routingProfiles: [Swift.String]?

        public init(
            channels: [ConnectClientTypes.Channel]? = nil,
            queues: [Swift.String]? = nil,
            routingProfiles: [Swift.String]? = nil
        )
        {
            self.channels = channels
            self.queues = queues
            self.routingProfiles = routingProfiles
        }
    }

}

extension ConnectClientTypes {
    public enum FlowAssociationResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case smsPhoneNumber
        case sdkUnknown(Swift.String)

        public static var allCases: [FlowAssociationResourceType] {
            return [
                .smsPhoneNumber,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .smsPhoneNumber: return "SMS_PHONE_NUMBER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FlowAssociationResourceType(rawValue: rawValue) ?? FlowAssociationResourceType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.FlowAssociationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowId = "FlowId"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowId = self.flowId {
            try encodeContainer.encode(flowId, forKey: .flowId)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let flowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowId)
        flowId = flowIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ListFlowAssociationResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ConnectClientTypes {
    /// Information about flow associations.
    public struct FlowAssociationSummary: Swift.Equatable {
        /// The identifier of the flow.
        public var flowId: Swift.String?
        /// The identifier of the resource.
        public var resourceId: Swift.String?
        /// The type of resource association.
        public var resourceType: ConnectClientTypes.ListFlowAssociationResourceType?

        public init(
            flowId: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceType: ConnectClientTypes.ListFlowAssociationResourceType? = nil
        )
        {
            self.flowId = flowId
            self.resourceId = resourceId
            self.resourceType = resourceType
        }
    }

}

extension GetContactAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let initialContactId = initialContactId else {
            return nil
        }
        return "/contact/attributes/\(instanceId.urlPercentEncoding())/\(initialContactId.urlPercentEncoding())"
    }
}

public struct GetContactAttributesInput: Swift.Equatable {
    /// The identifier of the initial contact.
    /// This member is required.
    public var initialContactId: Swift.String?
    /// The identifier of the Amazon Connect instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        initialContactId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.initialContactId = initialContactId
        self.instanceId = instanceId
    }
}

struct GetContactAttributesInputBody: Swift.Equatable {
}

extension GetContactAttributesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetContactAttributesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetContactAttributesOutputBody = try responseDecoder.decode(responseBody: data)
            self.attributes = output.attributes
        } else {
            self.attributes = nil
        }
    }
}

public struct GetContactAttributesOutput: Swift.Equatable {
    /// Information about the attributes.
    public var attributes: [Swift.String:Swift.String]?

    public init(
        attributes: [Swift.String:Swift.String]? = nil
    )
    {
        self.attributes = attributes
    }
}

struct GetContactAttributesOutputBody: Swift.Equatable {
    let attributes: [Swift.String:Swift.String]?
}

extension GetContactAttributesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

enum GetContactAttributesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCurrentMetricDataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentMetrics = "CurrentMetrics"
        case filters = "Filters"
        case groupings = "Groupings"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentMetrics = currentMetrics {
            var currentMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .currentMetrics)
            for currentmetric0 in currentMetrics {
                try currentMetricsContainer.encode(currentmetric0)
            }
        }
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let groupings = groupings {
            var groupingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupings)
            for grouping0 in groupings {
                try groupingsContainer.encode(grouping0.rawValue)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = sortCriteria {
            var sortCriteriaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortCriteria)
            for currentmetricsortcriteria0 in sortCriteria {
                try sortCriteriaContainer.encode(currentmetricsortcriteria0)
            }
        }
    }
}

extension GetCurrentMetricDataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/metrics/current/\(instanceId.urlPercentEncoding())"
    }
}

public struct GetCurrentMetricDataInput: Swift.Equatable {
    /// The metrics to retrieve. Specify the name and unit for each metric. The following metrics are available. For a description of all the metrics, see [Real-time Metrics Definitions](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html) in the Amazon Connect Administrator Guide. AGENTS_AFTER_CONTACT_WORK Unit: COUNT Name in real-time metrics report: [ACW](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#aftercallwork-real-time) AGENTS_AVAILABLE Unit: COUNT Name in real-time metrics report: [Available](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#available-real-time) AGENTS_ERROR Unit: COUNT Name in real-time metrics report: [Error](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#error-real-time) AGENTS_NON_PRODUCTIVE Unit: COUNT Name in real-time metrics report: [NPT (Non-Productive Time)](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#non-productive-time-real-time) AGENTS_ON_CALL Unit: COUNT Name in real-time metrics report: [On contact](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#on-call-real-time) AGENTS_ON_CONTACT Unit: COUNT Name in real-time metrics report: [On contact](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#on-call-real-time) AGENTS_ONLINE Unit: COUNT Name in real-time metrics report: [Online](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#online-real-time) AGENTS_STAFFED Unit: COUNT Name in real-time metrics report: [Staffed](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#staffed-real-time) CONTACTS_IN_QUEUE Unit: COUNT Name in real-time metrics report: [In queue](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#in-queue-real-time) CONTACTS_SCHEDULED Unit: COUNT Name in real-time metrics report: [Scheduled](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#scheduled-real-time) OLDEST_CONTACT_AGE Unit: SECONDS When you use groupings, Unit says SECONDS and the Value is returned in SECONDS. When you do not use groupings, Unit says SECONDS but the Value is returned in MILLISECONDS. For example, if you get a response like this: { "Metric": { "Name": "OLDEST_CONTACT_AGE", "Unit": "SECONDS" }, "Value": 24113.0 } The actual OLDEST_CONTACT_AGE is 24 seconds. Name in real-time metrics report: [Oldest](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#oldest-real-time) SLOTS_ACTIVE Unit: COUNT Name in real-time metrics report: [Active](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#active-real-time) SLOTS_AVAILABLE Unit: COUNT Name in real-time metrics report: [Availability](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#availability-real-time)
    /// This member is required.
    public var currentMetrics: [ConnectClientTypes.CurrentMetric]?
    /// The filters to apply to returned metrics. You can filter up to the following limits:
    ///
    /// * Queues: 100
    ///
    /// * Routing profiles: 100
    ///
    /// * Channels: 3 (VOICE, CHAT, and TASK channels are supported.)
    ///
    ///
    /// Metric data is retrieved only for the resources associated with the queues or routing profiles, and by any channels included in the filter. (You cannot filter by both queue AND routing profile.) You can include both resource IDs and resource ARNs in the same request. Currently tagging is only supported on the resources that are passed in the filter.
    /// This member is required.
    public var filters: ConnectClientTypes.Filters?
    /// The grouping applied to the metrics returned. For example, when grouped by QUEUE, the metrics returned apply to each queue rather than aggregated for all queues.
    ///
    /// * If you group by CHANNEL, you should include a Channels filter. VOICE, CHAT, and TASK channels are supported.
    ///
    /// * If you group by ROUTING_PROFILE, you must include either a queue or routing profile filter. In addition, a routing profile filter is required for metrics CONTACTS_SCHEDULED, CONTACTS_IN_QUEUE, and  OLDEST_CONTACT_AGE.
    ///
    /// * If no Grouping is included in the request, a summary of metrics is returned.
    public var groupings: [ConnectClientTypes.Grouping]?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. The token expires after 5 minutes from the time it is created. Subsequent requests that use the token must use the same request parameters as the request that generated the token.
    public var nextToken: Swift.String?
    /// The way to sort the resulting response based on metrics. You can enter one sort criteria. By default resources are sorted based on AGENTS_ONLINE, DESCENDING. The metric collection is sorted based on the input metrics. Note the following:
    ///
    /// * Sorting on SLOTS_ACTIVE and SLOTS_AVAILABLE is not supported.
    public var sortCriteria: [ConnectClientTypes.CurrentMetricSortCriteria]?

    public init(
        currentMetrics: [ConnectClientTypes.CurrentMetric]? = nil,
        filters: ConnectClientTypes.Filters? = nil,
        groupings: [ConnectClientTypes.Grouping]? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortCriteria: [ConnectClientTypes.CurrentMetricSortCriteria]? = nil
    )
    {
        self.currentMetrics = currentMetrics
        self.filters = filters
        self.groupings = groupings
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct GetCurrentMetricDataInputBody: Swift.Equatable {
    let filters: ConnectClientTypes.Filters?
    let groupings: [ConnectClientTypes.Grouping]?
    let currentMetrics: [ConnectClientTypes.CurrentMetric]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let sortCriteria: [ConnectClientTypes.CurrentMetricSortCriteria]?
}

extension GetCurrentMetricDataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentMetrics = "CurrentMetrics"
        case filters = "Filters"
        case groupings = "Groupings"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Filters.self, forKey: .filters)
        filters = filtersDecoded
        let groupingsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.Grouping?].self, forKey: .groupings)
        var groupingsDecoded0:[ConnectClientTypes.Grouping]? = nil
        if let groupingsContainer = groupingsContainer {
            groupingsDecoded0 = [ConnectClientTypes.Grouping]()
            for enum0 in groupingsContainer {
                if let enum0 = enum0 {
                    groupingsDecoded0?.append(enum0)
                }
            }
        }
        groupings = groupingsDecoded0
        let currentMetricsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.CurrentMetric?].self, forKey: .currentMetrics)
        var currentMetricsDecoded0:[ConnectClientTypes.CurrentMetric]? = nil
        if let currentMetricsContainer = currentMetricsContainer {
            currentMetricsDecoded0 = [ConnectClientTypes.CurrentMetric]()
            for structure0 in currentMetricsContainer {
                if let structure0 = structure0 {
                    currentMetricsDecoded0?.append(structure0)
                }
            }
        }
        currentMetrics = currentMetricsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let sortCriteriaContainer = try containerValues.decodeIfPresent([ConnectClientTypes.CurrentMetricSortCriteria?].self, forKey: .sortCriteria)
        var sortCriteriaDecoded0:[ConnectClientTypes.CurrentMetricSortCriteria]? = nil
        if let sortCriteriaContainer = sortCriteriaContainer {
            sortCriteriaDecoded0 = [ConnectClientTypes.CurrentMetricSortCriteria]()
            for structure0 in sortCriteriaContainer {
                if let structure0 = structure0 {
                    sortCriteriaDecoded0?.append(structure0)
                }
            }
        }
        sortCriteria = sortCriteriaDecoded0
    }
}

extension GetCurrentMetricDataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCurrentMetricDataOutputBody = try responseDecoder.decode(responseBody: data)
            self.approximateTotalCount = output.approximateTotalCount
            self.dataSnapshotTime = output.dataSnapshotTime
            self.metricResults = output.metricResults
            self.nextToken = output.nextToken
        } else {
            self.approximateTotalCount = nil
            self.dataSnapshotTime = nil
            self.metricResults = nil
            self.nextToken = nil
        }
    }
}

public struct GetCurrentMetricDataOutput: Swift.Equatable {
    /// The total count of the result, regardless of the current page size.
    public var approximateTotalCount: Swift.Int?
    /// The time at which the metrics were retrieved and cached for pagination.
    public var dataSnapshotTime: ClientRuntime.Date?
    /// Information about the real-time metrics.
    public var metricResults: [ConnectClientTypes.CurrentMetricResult]?
    /// If there are additional results, this is the token for the next set of results. The token expires after 5 minutes from the time it is created. Subsequent requests that use the token must use the same request parameters as the request that generated the token.
    public var nextToken: Swift.String?

    public init(
        approximateTotalCount: Swift.Int? = nil,
        dataSnapshotTime: ClientRuntime.Date? = nil,
        metricResults: [ConnectClientTypes.CurrentMetricResult]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.approximateTotalCount = approximateTotalCount
        self.dataSnapshotTime = dataSnapshotTime
        self.metricResults = metricResults
        self.nextToken = nextToken
    }
}

struct GetCurrentMetricDataOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let metricResults: [ConnectClientTypes.CurrentMetricResult]?
    let dataSnapshotTime: ClientRuntime.Date?
    let approximateTotalCount: Swift.Int?
}

extension GetCurrentMetricDataOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approximateTotalCount = "ApproximateTotalCount"
        case dataSnapshotTime = "DataSnapshotTime"
        case metricResults = "MetricResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let metricResultsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.CurrentMetricResult?].self, forKey: .metricResults)
        var metricResultsDecoded0:[ConnectClientTypes.CurrentMetricResult]? = nil
        if let metricResultsContainer = metricResultsContainer {
            metricResultsDecoded0 = [ConnectClientTypes.CurrentMetricResult]()
            for structure0 in metricResultsContainer {
                if let structure0 = structure0 {
                    metricResultsDecoded0?.append(structure0)
                }
            }
        }
        metricResults = metricResultsDecoded0
        let dataSnapshotTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dataSnapshotTime)
        dataSnapshotTime = dataSnapshotTimeDecoded
        let approximateTotalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .approximateTotalCount)
        approximateTotalCount = approximateTotalCountDecoded
    }
}

enum GetCurrentMetricDataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCurrentUserDataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetCurrentUserDataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/metrics/userdata/\(instanceId.urlPercentEncoding())"
    }
}

public struct GetCurrentUserDataInput: Swift.Equatable {
    /// The filters to apply to returned user data. You can filter up to the following limits:
    ///
    /// * Queues: 100
    ///
    /// * Routing profiles: 100
    ///
    /// * Agents: 100
    ///
    /// * Contact states: 9
    ///
    /// * User hierarchy groups: 1
    ///
    ///
    /// The user data is retrieved for only the specified values/resources in the filter. A maximum of one filter can be passed from queues, routing profiles, agents, and user hierarchy groups. Currently tagging is only supported on the resources that are passed in the filter.
    /// This member is required.
    public var filters: ConnectClientTypes.UserDataFilters?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: ConnectClientTypes.UserDataFilters? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetCurrentUserDataInputBody: Swift.Equatable {
    let filters: ConnectClientTypes.UserDataFilters?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetCurrentUserDataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.UserDataFilters.self, forKey: .filters)
        filters = filtersDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetCurrentUserDataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCurrentUserDataOutputBody = try responseDecoder.decode(responseBody: data)
            self.approximateTotalCount = output.approximateTotalCount
            self.nextToken = output.nextToken
            self.userDataList = output.userDataList
        } else {
            self.approximateTotalCount = nil
            self.nextToken = nil
            self.userDataList = nil
        }
    }
}

public struct GetCurrentUserDataOutput: Swift.Equatable {
    /// The total count of the result, regardless of the current page size.
    public var approximateTotalCount: Swift.Int?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// A list of the user data that is returned.
    public var userDataList: [ConnectClientTypes.UserData]?

    public init(
        approximateTotalCount: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        userDataList: [ConnectClientTypes.UserData]? = nil
    )
    {
        self.approximateTotalCount = approximateTotalCount
        self.nextToken = nextToken
        self.userDataList = userDataList
    }
}

struct GetCurrentUserDataOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let userDataList: [ConnectClientTypes.UserData]?
    let approximateTotalCount: Swift.Int?
}

extension GetCurrentUserDataOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approximateTotalCount = "ApproximateTotalCount"
        case nextToken = "NextToken"
        case userDataList = "UserDataList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let userDataListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.UserData?].self, forKey: .userDataList)
        var userDataListDecoded0:[ConnectClientTypes.UserData]? = nil
        if let userDataListContainer = userDataListContainer {
            userDataListDecoded0 = [ConnectClientTypes.UserData]()
            for structure0 in userDataListContainer {
                if let structure0 = structure0 {
                    userDataListDecoded0?.append(structure0)
                }
            }
        }
        userDataList = userDataListDecoded0
        let approximateTotalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .approximateTotalCount)
        approximateTotalCount = approximateTotalCountDecoded
    }
}

enum GetCurrentUserDataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetFederationTokenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/user/federate/\(instanceId.urlPercentEncoding())"
    }
}

public struct GetFederationTokenInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        instanceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

struct GetFederationTokenInputBody: Swift.Equatable {
}

extension GetFederationTokenInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetFederationTokenOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFederationTokenOutputBody = try responseDecoder.decode(responseBody: data)
            self.credentials = output.credentials
            self.signInUrl = output.signInUrl
            self.userArn = output.userArn
            self.userId = output.userId
        } else {
            self.credentials = nil
            self.signInUrl = nil
            self.userArn = nil
            self.userId = nil
        }
    }
}

public struct GetFederationTokenOutput: Swift.Equatable {
    /// The credentials to use for federation.
    public var credentials: ConnectClientTypes.Credentials?
    /// The URL to sign into the user's instance.
    public var signInUrl: Swift.String?
    /// The Amazon Resource Name (ARN) of the user.
    public var userArn: Swift.String?
    /// The identifier for the user. This can be the ID or the ARN of the user.
    public var userId: Swift.String?

    public init(
        credentials: ConnectClientTypes.Credentials? = nil,
        signInUrl: Swift.String? = nil,
        userArn: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.credentials = credentials
        self.signInUrl = signInUrl
        self.userArn = userArn
        self.userId = userId
    }
}

struct GetFederationTokenOutputBody: Swift.Equatable {
    let credentials: ConnectClientTypes.Credentials?
    let signInUrl: Swift.String?
    let userArn: Swift.String?
    let userId: Swift.String?
}

extension GetFederationTokenOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials = "Credentials"
        case signInUrl = "SignInUrl"
        case userArn = "UserArn"
        case userId = "UserId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let credentialsDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Credentials.self, forKey: .credentials)
        credentials = credentialsDecoded
        let signInUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signInUrl)
        signInUrl = signInUrlDecoded
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

enum GetFederationTokenOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DuplicateResourceException": return try await DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UserNotFoundException": return try await UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetFlowAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        guard let resourceType = resourceType else {
            return nil
        }
        return "/flow-associations/\(instanceId.urlPercentEncoding())/\(resourceId.urlPercentEncoding())/\(resourceType.rawValue.urlPercentEncoding())"
    }
}

public struct GetFlowAssociationInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// A valid resource type.
    /// This member is required.
    public var resourceType: ConnectClientTypes.FlowAssociationResourceType?

    public init(
        instanceId: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: ConnectClientTypes.FlowAssociationResourceType? = nil
    )
    {
        self.instanceId = instanceId
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct GetFlowAssociationInputBody: Swift.Equatable {
}

extension GetFlowAssociationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetFlowAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFlowAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.flowId = output.flowId
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.flowId = nil
            self.resourceId = nil
            self.resourceType = nil
        }
    }
}

public struct GetFlowAssociationOutput: Swift.Equatable {
    /// The identifier of the flow.
    public var flowId: Swift.String?
    /// The identifier of the resource.
    public var resourceId: Swift.String?
    /// A valid resource type.
    public var resourceType: ConnectClientTypes.FlowAssociationResourceType?

    public init(
        flowId: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: ConnectClientTypes.FlowAssociationResourceType? = nil
    )
    {
        self.flowId = flowId
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct GetFlowAssociationOutputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let flowId: Swift.String?
    let resourceType: ConnectClientTypes.FlowAssociationResourceType?
}

extension GetFlowAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowId = "FlowId"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let flowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowId)
        flowId = flowIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.FlowAssociationResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

enum GetFlowAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMetricDataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case filters = "Filters"
        case groupings = "Groupings"
        case historicalMetrics = "HistoricalMetrics"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let groupings = groupings {
            var groupingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupings)
            for grouping0 in groupings {
                try groupingsContainer.encode(grouping0.rawValue)
            }
        }
        if let historicalMetrics = historicalMetrics {
            var historicalMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .historicalMetrics)
            for historicalmetric0 in historicalMetrics {
                try historicalMetricsContainer.encode(historicalmetric0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }
}

extension GetMetricDataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/metrics/historical/\(instanceId.urlPercentEncoding())"
    }
}

public struct GetMetricDataInput: Swift.Equatable {
    /// The timestamp, in UNIX Epoch time format, at which to end the reporting interval for the retrieval of historical metrics data. The time must be specified using an interval of 5 minutes, such as 11:00, 11:05, 11:10, and must be later than the start time timestamp. The time range between the start and end time must be less than 24 hours.
    /// This member is required.
    public var endTime: ClientRuntime.Date?
    /// The queues, up to 100, or channels, to use to filter the metrics returned. Metric data is retrieved only for the resources associated with the queues or channels included in the filter. You can include both queue IDs and queue ARNs in the same request. VOICE, CHAT, and TASK channels are supported. To filter by Queues, enter the queue ID/ARN, not the name of the queue.
    /// This member is required.
    public var filters: ConnectClientTypes.Filters?
    /// The grouping applied to the metrics returned. For example, when results are grouped by queue, the metrics returned are grouped by queue. The values returned apply to the metrics for each queue rather than aggregated for all queues. If no grouping is specified, a summary of metrics for all queues is returned.
    public var groupings: [ConnectClientTypes.Grouping]?
    /// The metrics to retrieve. Specify the name, unit, and statistic for each metric. The following historical metrics are available. For a description of each metric, see [Historical Metrics Definitions](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html) in the Amazon Connect Administrator Guide. This API does not support a contacts incoming metric (there's no CONTACTS_INCOMING metric missing from the documented list). ABANDON_TIME Unit: SECONDS Statistic: AVG AFTER_CONTACT_WORK_TIME Unit: SECONDS Statistic: AVG API_CONTACTS_HANDLED Unit: COUNT Statistic: SUM CALLBACK_CONTACTS_HANDLED Unit: COUNT Statistic: SUM CONTACTS_ABANDONED Unit: COUNT Statistic: SUM CONTACTS_AGENT_HUNG_UP_FIRST Unit: COUNT Statistic: SUM CONTACTS_CONSULTED Unit: COUNT Statistic: SUM CONTACTS_HANDLED Unit: COUNT Statistic: SUM CONTACTS_HANDLED_INCOMING Unit: COUNT Statistic: SUM CONTACTS_HANDLED_OUTBOUND Unit: COUNT Statistic: SUM CONTACTS_HOLD_ABANDONS Unit: COUNT Statistic: SUM CONTACTS_MISSED Unit: COUNT Statistic: SUM CONTACTS_QUEUED Unit: COUNT Statistic: SUM CONTACTS_TRANSFERRED_IN Unit: COUNT Statistic: SUM CONTACTS_TRANSFERRED_IN_FROM_QUEUE Unit: COUNT Statistic: SUM CONTACTS_TRANSFERRED_OUT Unit: COUNT Statistic: SUM CONTACTS_TRANSFERRED_OUT_FROM_QUEUE Unit: COUNT Statistic: SUM HANDLE_TIME Unit: SECONDS Statistic: AVG HOLD_TIME Unit: SECONDS Statistic: AVG INTERACTION_AND_HOLD_TIME Unit: SECONDS Statistic: AVG INTERACTION_TIME Unit: SECONDS Statistic: AVG OCCUPANCY Unit: PERCENT Statistic: AVG QUEUE_ANSWER_TIME Unit: SECONDS Statistic: AVG QUEUED_TIME Unit: SECONDS Statistic: MAX SERVICE_LEVEL You can include up to 20 SERVICE_LEVEL metrics in a request. Unit: PERCENT Statistic: AVG Threshold: For ThresholdValue, enter any whole number from 1 to 604800 (inclusive), in seconds. For Comparison, you must enter LT (for "Less than").
    /// This member is required.
    public var historicalMetrics: [ConnectClientTypes.HistoricalMetric]?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The timestamp, in UNIX Epoch time format, at which to start the reporting interval for the retrieval of historical metrics data. The time must be specified using a multiple of 5 minutes, such as 10:05, 10:10, 10:15. The start time cannot be earlier than 24 hours before the time of the request. Historical metrics are available only for 24 hours.
    /// This member is required.
    public var startTime: ClientRuntime.Date?

    public init(
        endTime: ClientRuntime.Date? = nil,
        filters: ConnectClientTypes.Filters? = nil,
        groupings: [ConnectClientTypes.Grouping]? = nil,
        historicalMetrics: [ConnectClientTypes.HistoricalMetric]? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.filters = filters
        self.groupings = groupings
        self.historicalMetrics = historicalMetrics
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
    }
}

struct GetMetricDataInputBody: Swift.Equatable {
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let filters: ConnectClientTypes.Filters?
    let groupings: [ConnectClientTypes.Grouping]?
    let historicalMetrics: [ConnectClientTypes.HistoricalMetric]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetMetricDataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case filters = "Filters"
        case groupings = "Groupings"
        case historicalMetrics = "HistoricalMetrics"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTime = "StartTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Filters.self, forKey: .filters)
        filters = filtersDecoded
        let groupingsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.Grouping?].self, forKey: .groupings)
        var groupingsDecoded0:[ConnectClientTypes.Grouping]? = nil
        if let groupingsContainer = groupingsContainer {
            groupingsDecoded0 = [ConnectClientTypes.Grouping]()
            for enum0 in groupingsContainer {
                if let enum0 = enum0 {
                    groupingsDecoded0?.append(enum0)
                }
            }
        }
        groupings = groupingsDecoded0
        let historicalMetricsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.HistoricalMetric?].self, forKey: .historicalMetrics)
        var historicalMetricsDecoded0:[ConnectClientTypes.HistoricalMetric]? = nil
        if let historicalMetricsContainer = historicalMetricsContainer {
            historicalMetricsDecoded0 = [ConnectClientTypes.HistoricalMetric]()
            for structure0 in historicalMetricsContainer {
                if let structure0 = structure0 {
                    historicalMetricsDecoded0?.append(structure0)
                }
            }
        }
        historicalMetrics = historicalMetricsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetMetricDataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMetricDataOutputBody = try responseDecoder.decode(responseBody: data)
            self.metricResults = output.metricResults
            self.nextToken = output.nextToken
        } else {
            self.metricResults = nil
            self.nextToken = nil
        }
    }
}

public struct GetMetricDataOutput: Swift.Equatable {
    /// Information about the historical metrics. If no grouping is specified, a summary of metric data is returned.
    public var metricResults: [ConnectClientTypes.HistoricalMetricResult]?
    /// If there are additional results, this is the token for the next set of results. The token expires after 5 minutes from the time it is created. Subsequent requests that use the token must use the same request parameters as the request that generated the token.
    public var nextToken: Swift.String?

    public init(
        metricResults: [ConnectClientTypes.HistoricalMetricResult]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.metricResults = metricResults
        self.nextToken = nextToken
    }
}

struct GetMetricDataOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let metricResults: [ConnectClientTypes.HistoricalMetricResult]?
}

extension GetMetricDataOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricResults = "MetricResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let metricResultsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.HistoricalMetricResult?].self, forKey: .metricResults)
        var metricResultsDecoded0:[ConnectClientTypes.HistoricalMetricResult]? = nil
        if let metricResultsContainer = metricResultsContainer {
            metricResultsDecoded0 = [ConnectClientTypes.HistoricalMetricResult]()
            for structure0 in metricResultsContainer {
                if let structure0 = structure0 {
                    metricResultsDecoded0?.append(structure0)
                }
            }
        }
        metricResults = metricResultsDecoded0
    }
}

enum GetMetricDataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMetricDataV2Input: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case filters = "Filters"
        case groupings = "Groupings"
        case interval = "Interval"
        case maxResults = "MaxResults"
        case metrics = "Metrics"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterv20 in filters {
                try filtersContainer.encode(filterv20)
            }
        }
        if let groupings = groupings {
            var groupingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupings)
            for groupingv20 in groupings {
                try groupingsContainer.encode(groupingv20)
            }
        }
        if let interval = self.interval {
            try encodeContainer.encode(interval, forKey: .interval)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let metrics = metrics {
            var metricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metrics)
            for metricv20 in metrics {
                try metricsContainer.encode(metricv20)
            }
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }
}

extension GetMetricDataV2Input: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/metrics/data"
    }
}

public struct GetMetricDataV2Input: Swift.Equatable {
    /// The timestamp, in UNIX Epoch time format, at which to end the reporting interval for the retrieval of historical metrics data. The time must be later than the start time timestamp. It cannot be later than the current timestamp.
    /// This member is required.
    public var endTime: ClientRuntime.Date?
    /// The filters to apply to returned metrics. You can filter on the following resources:
    ///
    /// * Queues
    ///
    /// * Routing profiles
    ///
    /// * Agents
    ///
    /// * Channels
    ///
    /// * User hierarchy groups
    ///
    /// * Feature
    ///
    ///
    /// At least one filter must be passed from queues, routing profiles, agents, or user hierarchy groups. To filter by phone number, see [Create a historical metrics report](https://docs.aws.amazon.com/connect/latest/adminguide/create-historical-metrics-report.html) in the Amazon Connect Administrator's Guide. Note the following limits:
    ///
    /// * Filter keys: A maximum of 5 filter keys are supported in a single request. Valid filter keys: QUEUE | ROUTING_PROFILE | AGENT | CHANNEL | AGENT_HIERARCHY_LEVEL_ONE | AGENT_HIERARCHY_LEVEL_TWO | AGENT_HIERARCHY_LEVEL_THREE | AGENT_HIERARCHY_LEVEL_FOUR | AGENT_HIERARCHY_LEVEL_FIVE | FEATURE | contact/segmentAttributes/connect:Subtype
    ///
    /// * Filter values: A maximum of 100 filter values are supported in a single request. VOICE, CHAT, and TASK are valid filterValue for the CHANNEL filter key. They do not count towards limitation of 100 filter values. For example, a GetMetricDataV2 request can filter by 50 queues, 35 agents, and 15 routing profiles for a total of 100 filter values, along with 3 channel filters. contact_lens_conversational_analytics is a valid filterValue for the FEATURE filter key. It is available only to contacts analyzed by Contact Lens conversational analytics. connect:Chat, connect:SMS, connect:Telephony, and connect:WebRTC are valid filterValue examples (not exhaustive) for the contact/segmentAttributes/connect:Subtype filter key.
    /// This member is required.
    public var filters: [ConnectClientTypes.FilterV2]?
    /// The grouping applied to the metrics that are returned. For example, when results are grouped by queue, the metrics returned are grouped by queue. The values that are returned apply to the metrics for each queue. They are not aggregated for all queues. If no grouping is specified, a summary of all metrics is returned. Valid grouping keys: QUEUE | ROUTING_PROFILE | AGENT | CHANNEL | AGENT_HIERARCHY_LEVEL_ONE | AGENT_HIERARCHY_LEVEL_TWO | AGENT_HIERARCHY_LEVEL_THREE | AGENT_HIERARCHY_LEVEL_FOUR | AGENT_HIERARCHY_LEVEL_FIVE, contact/segmentAttributes/connect:Subtype
    public var groupings: [Swift.String]?
    /// The interval period and timezone to apply to returned metrics.
    ///
    /// * IntervalPeriod: An aggregated grouping applied to request metrics. Valid IntervalPeriod values are: FIFTEEN_MIN | THIRTY_MIN | HOUR | DAY | WEEK | TOTAL. For example, if IntervalPeriod is selected THIRTY_MIN, StartTime and EndTime differs by 1 day, then Amazon Connect returns 48 results in the response. Each result is aggregated by the THIRTY_MIN period. By default Amazon Connect aggregates results based on the TOTAL interval period. The following list describes restrictions on StartTime and EndTime based on which IntervalPeriod is requested.
    ///
    /// * FIFTEEN_MIN: The difference between StartTime and EndTime must be less than 3 days.
    ///
    /// * THIRTY_MIN: The difference between StartTime and EndTime must be less than 3 days.
    ///
    /// * HOUR: The difference between StartTime and EndTime must be less than 3 days.
    ///
    /// * DAY: The difference between StartTime and EndTime must be less than 35 days.
    ///
    /// * WEEK: The difference between StartTime and EndTime must be less than 35 days.
    ///
    /// * TOTAL: The difference between StartTime and EndTime must be less than 35 days.
    ///
    ///
    ///
    ///
    /// * TimeZone: The timezone applied to requested metrics.
    public var interval: ConnectClientTypes.IntervalDetails?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The metrics to retrieve. Specify the name, groupings, and filters for each metric. The following historical metrics are available. For a description of each metric, see [Historical metrics definitions](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html) in the Amazon Connect Administrator's Guide. ABANDONMENT_RATE Unit: Percent Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Feature, contact/segmentAttributes/connect:Subtype AGENT_ADHERENT_TIME This metric is available only in Amazon Web Services Regions where [Forecasting, capacity planning, and scheduling](https://docs.aws.amazon.com/connect/latest/adminguide/regions.html#optimization_region) is available. Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy AGENT_ANSWER_RATE Unit: Percent Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy AGENT_NON_ADHERENT_TIME Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy AGENT_NON_RESPONSE Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy AGENT_NON_RESPONSE_WITHOUT_CUSTOMER_ABANDONS Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy Data for this metric is available starting from October 1, 2023 0:00:00 GMT. AGENT_OCCUPANCY Unit: Percentage Valid groupings and filters: Routing Profile, Agent, Agent Hierarchy AGENT_SCHEDULE_ADHERENCE This metric is available only in Amazon Web Services Regions where [Forecasting, capacity planning, and scheduling](https://docs.aws.amazon.com/connect/latest/adminguide/regions.html#optimization_region) is available. Unit: Percent Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy AGENT_SCHEDULED_TIME This metric is available only in Amazon Web Services Regions where [Forecasting, capacity planning, and scheduling](https://docs.aws.amazon.com/connect/latest/adminguide/regions.html#optimization_region) is available. Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy AVG_ABANDON_TIME Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Feature, contact/segmentAttributes/connect:Subtype AVG_ACTIVE_TIME Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy AVG_AFTER_CONTACT_WORK_TIME Unit: Seconds Valid metric filter key: INITIATION_METHOD Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Feature, contact/segmentAttributes/connect:Subtype Feature is a valid filter but not a valid grouping. AVG_AGENT_CONNECTING_TIME Unit: Seconds Valid metric filter key: INITIATION_METHOD. For now, this metric only supports the following as INITIATION_METHOD: INBOUND | OUTBOUND | CALLBACK | API Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy The Negate key in Metric Level Filters is not applicable for this metric. AVG_AGENT_PAUSE_TIME Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy AVG_CONTACT_DURATION Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Feature, contact/segmentAttributes/connect:Subtype Feature is a valid filter but not a valid grouping. AVG_CONVERSATION_DURATION Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Feature, contact/segmentAttributes/connect:Subtype AVG_GREETING_TIME_AGENT This metric is available only for contacts analyzed by Contact Lens conversational analytics. Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype AVG_HANDLE_TIME Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Feature, contact/segmentAttributes/connect:Subtype Feature is a valid filter but not a valid grouping. AVG_HOLD_TIME Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Feature, contact/segmentAttributes/connect:Subtype Feature is a valid filter but not a valid grouping. AVG_HOLD_TIME_ALL_CONTACTS Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype AVG_HOLDS Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Feature, contact/segmentAttributes/connect:Subtype Feature is a valid filter but not a valid grouping. AVG_INTERACTION_AND_HOLD_TIME Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype AVG_INTERACTION_TIME Unit: Seconds Valid metric filter key: INITIATION_METHOD Valid groupings and filters: Queue, Channel, Routing Profile, Feature, contact/segmentAttributes/connect:Subtype Feature is a valid filter but not a valid grouping. AVG_INTERRUPTIONS_AGENT This metric is available only for contacts analyzed by Contact Lens conversational analytics. Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype AVG_INTERRUPTION_TIME_AGENT This metric is available only for contacts analyzed by Contact Lens conversational analytics. Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype AVG_NON_TALK_TIME This metric is available only for contacts analyzed by Contact Lens conversational analytics. Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype AVG_QUEUE_ANSWER_TIME Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Feature, contact/segmentAttributes/connect:Subtype Feature is a valid filter but not a valid grouping. AVG_RESOLUTION_TIME Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, contact/segmentAttributes/connect:Subtype AVG_TALK_TIME This metric is available only for contacts analyzed by Contact Lens conversational analytics. Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype AVG_TALK_TIME_AGENT This metric is available only for contacts analyzed by Contact Lens conversational analytics. Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype AVG_TALK_TIME_CUSTOMER This metric is available only for contacts analyzed by Contact Lens conversational analytics. Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype CONTACTS_ABANDONED Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype CONTACTS_CREATED Unit: Count Valid metric filter key: INITIATION_METHOD Valid groupings and filters: Queue, Channel, Routing Profile, Feature, contact/segmentAttributes/connect:Subtype Feature is a valid filter but not a valid grouping. CONTACTS_HANDLED Unit: Count Valid metric filter key: INITIATION_METHOD, DISCONNECT_REASON Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Feature, contact/segmentAttributes/connect:Subtype Feature is a valid filter but not a valid grouping. CONTACTS_HOLD_ABANDONS Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype CONTACTS_ON_HOLD_AGENT_DISCONNECT Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy CONTACTS_ON_HOLD_CUSTOMER_DISCONNECT Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy CONTACTS_PUT_ON_HOLD Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy CONTACTS_TRANSFERRED_OUT_EXTERNAL Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy CONTACTS_TRANSFERRED_OUT_INTERNAL Unit: Percent Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy CONTACTS_QUEUED Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype CONTACTS_RESOLVED_IN_X Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, contact/segmentAttributes/connect:Subtype Threshold: For ThresholdValue enter any whole number from 1 to 604800 (inclusive), in seconds. For Comparison, you must enter LT (for "Less than"). CONTACTS_TRANSFERRED_OUT Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Feature, contact/segmentAttributes/connect:Subtype Feature is a valid filter but not a valid grouping. CONTACTS_TRANSFERRED_OUT_BY_AGENT Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype CONTACTS_TRANSFERRED_OUT_FROM_QUEUE Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype MAX_QUEUED_TIME Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype PERCENT_NON_TALK_TIME This metric is available only for contacts analyzed by Contact Lens conversational analytics. Unit: Percentage Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype PERCENT_TALK_TIME This metric is available only for contacts analyzed by Contact Lens conversational analytics. Unit: Percentage Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype PERCENT_TALK_TIME_AGENT This metric is available only for contacts analyzed by Contact Lens conversational analytics. Unit: Percentage Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype PERCENT_TALK_TIME_CUSTOMER This metric is available only for contacts analyzed by Contact Lens conversational analytics. Unit: Percentage Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype SERVICE_LEVEL You can include up to 20 SERVICE_LEVEL metrics in a request. Unit: Percent Valid groupings and filters: Queue, Channel, Routing Profile Threshold: For ThresholdValue, enter any whole number from 1 to 604800 (inclusive), in seconds. For Comparison, you must enter LT (for "Less than"). SUM_AFTER_CONTACT_WORK_TIME Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy SUM_CONNECTING_TIME_AGENT Unit: Seconds Valid metric filter key: INITIATION_METHOD. This metric only supports the following filter keys as INITIATION_METHOD: INBOUND | OUTBOUND | CALLBACK | API Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy The Negate key in Metric Level Filters is not applicable for this metric. SUM_CONTACT_FLOW_TIME Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy SUM_CONTACT_TIME_AGENT Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy SUM_CONTACTS_ANSWERED_IN_X Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, contact/segmentAttributes/connect:Subtype Threshold: For ThresholdValue, enter any whole number from 1 to 604800 (inclusive), in seconds. For Comparison, you must enter LT (for "Less than"). SUM_CONTACTS_ABANDONED_IN_X Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, contact/segmentAttributes/connect:Subtype Threshold: For ThresholdValue, enter any whole number from 1 to 604800 (inclusive), in seconds. For Comparison, you must enter LT (for "Less than"). SUM_CONTACTS_DISCONNECTED Valid metric filter key: DISCONNECT_REASON Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype SUM_ERROR_STATUS_TIME_AGENT Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy SUM_HANDLE_TIME Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy SUM_HOLD_TIME Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy SUM_IDLE_TIME_AGENT Unit: Seconds Valid groupings and filters: Routing Profile, Agent, Agent Hierarchy SUM_INTERACTION_AND_HOLD_TIME Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy SUM_INTERACTION_TIME Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy SUM_NON_PRODUCTIVE_TIME_AGENT Unit: Seconds Valid groupings and filters: Routing Profile, Agent, Agent Hierarchy SUM_ONLINE_TIME_AGENT Unit: Seconds Valid groupings and filters: Routing Profile, Agent, Agent Hierarchy SUM_RETRY_CALLBACK_ATTEMPTS Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, contact/segmentAttributes/connect:Subtype
    /// This member is required.
    public var metrics: [ConnectClientTypes.MetricV2]?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource. This includes the instanceId an Amazon Connect instance.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The timestamp, in UNIX Epoch time format, at which to start the reporting interval for the retrieval of historical metrics data. The time must be before the end time timestamp. The start and end time depends on the IntervalPeriod selected. By default the time range between start and end time is 35 days. Historical metrics are available for 3 months.
    /// This member is required.
    public var startTime: ClientRuntime.Date?

    public init(
        endTime: ClientRuntime.Date? = nil,
        filters: [ConnectClientTypes.FilterV2]? = nil,
        groupings: [Swift.String]? = nil,
        interval: ConnectClientTypes.IntervalDetails? = nil,
        maxResults: Swift.Int? = nil,
        metrics: [ConnectClientTypes.MetricV2]? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.filters = filters
        self.groupings = groupings
        self.interval = interval
        self.maxResults = maxResults
        self.metrics = metrics
        self.nextToken = nextToken
        self.resourceArn = resourceArn
        self.startTime = startTime
    }
}

struct GetMetricDataV2InputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let interval: ConnectClientTypes.IntervalDetails?
    let filters: [ConnectClientTypes.FilterV2]?
    let groupings: [Swift.String]?
    let metrics: [ConnectClientTypes.MetricV2]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetMetricDataV2InputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case filters = "Filters"
        case groupings = "Groupings"
        case interval = "Interval"
        case maxResults = "MaxResults"
        case metrics = "Metrics"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
        case startTime = "StartTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let intervalDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.IntervalDetails.self, forKey: .interval)
        interval = intervalDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ConnectClientTypes.FilterV2?].self, forKey: .filters)
        var filtersDecoded0:[ConnectClientTypes.FilterV2]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ConnectClientTypes.FilterV2]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let groupingsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groupings)
        var groupingsDecoded0:[Swift.String]? = nil
        if let groupingsContainer = groupingsContainer {
            groupingsDecoded0 = [Swift.String]()
            for string0 in groupingsContainer {
                if let string0 = string0 {
                    groupingsDecoded0?.append(string0)
                }
            }
        }
        groupings = groupingsDecoded0
        let metricsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.MetricV2?].self, forKey: .metrics)
        var metricsDecoded0:[ConnectClientTypes.MetricV2]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [ConnectClientTypes.MetricV2]()
            for structure0 in metricsContainer {
                if let structure0 = structure0 {
                    metricsDecoded0?.append(structure0)
                }
            }
        }
        metrics = metricsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetMetricDataV2Output: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMetricDataV2OutputBody = try responseDecoder.decode(responseBody: data)
            self.metricResults = output.metricResults
            self.nextToken = output.nextToken
        } else {
            self.metricResults = nil
            self.nextToken = nil
        }
    }
}

public struct GetMetricDataV2Output: Swift.Equatable {
    /// Information about the metrics requested in the API request If no grouping is specified, a summary of metric data is returned.
    public var metricResults: [ConnectClientTypes.MetricResultV2]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        metricResults: [ConnectClientTypes.MetricResultV2]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.metricResults = metricResults
        self.nextToken = nextToken
    }
}

struct GetMetricDataV2OutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let metricResults: [ConnectClientTypes.MetricResultV2]?
}

extension GetMetricDataV2OutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricResults = "MetricResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let metricResultsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.MetricResultV2?].self, forKey: .metricResults)
        var metricResultsDecoded0:[ConnectClientTypes.MetricResultV2]? = nil
        if let metricResultsContainer = metricResultsContainer {
            metricResultsDecoded0 = [ConnectClientTypes.MetricResultV2]()
            for structure0 in metricResultsContainer {
                if let structure0 = structure0 {
                    metricResultsDecoded0?.append(structure0)
                }
            }
        }
        metricResults = metricResultsDecoded0
    }
}

enum GetMetricDataV2OutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPromptFileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let promptId = promptId else {
            return nil
        }
        return "/prompts/\(instanceId.urlPercentEncoding())/\(promptId.urlPercentEncoding())/file"
    }
}

public struct GetPromptFileInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A unique identifier for the prompt.
    /// This member is required.
    public var promptId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        promptId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.promptId = promptId
    }
}

struct GetPromptFileInputBody: Swift.Equatable {
}

extension GetPromptFileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPromptFileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPromptFileOutputBody = try responseDecoder.decode(responseBody: data)
            self.lastModifiedRegion = output.lastModifiedRegion
            self.lastModifiedTime = output.lastModifiedTime
            self.promptPresignedUrl = output.promptPresignedUrl
        } else {
            self.lastModifiedRegion = nil
            self.lastModifiedTime = nil
            self.promptPresignedUrl = nil
        }
    }
}

public struct GetPromptFileOutput: Swift.Equatable {
    /// The Amazon Web Services Region where this resource was last modified.
    public var lastModifiedRegion: Swift.String?
    /// The timestamp when this resource was last modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// A generated URL to the prompt that can be given to an unauthorized user so they can access the prompt in S3.
    public var promptPresignedUrl: Swift.String?

    public init(
        lastModifiedRegion: Swift.String? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        promptPresignedUrl: Swift.String? = nil
    )
    {
        self.lastModifiedRegion = lastModifiedRegion
        self.lastModifiedTime = lastModifiedTime
        self.promptPresignedUrl = promptPresignedUrl
    }
}

struct GetPromptFileOutputBody: Swift.Equatable {
    let promptPresignedUrl: Swift.String?
    let lastModifiedTime: ClientRuntime.Date?
    let lastModifiedRegion: Swift.String?
}

extension GetPromptFileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastModifiedRegion = "LastModifiedRegion"
        case lastModifiedTime = "LastModifiedTime"
        case promptPresignedUrl = "PromptPresignedUrl"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let promptPresignedUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .promptPresignedUrl)
        promptPresignedUrl = promptPresignedUrlDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastModifiedRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedRegion)
        lastModifiedRegion = lastModifiedRegionDecoded
    }
}

enum GetPromptFileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTaskTemplateInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let snapshotVersion = snapshotVersion {
                let snapshotVersionQueryItem = ClientRuntime.URLQueryItem(name: "snapshotVersion".urlPercentEncoding(), value: Swift.String(snapshotVersion).urlPercentEncoding())
                items.append(snapshotVersionQueryItem)
            }
            return items
        }
    }
}

extension GetTaskTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let taskTemplateId = taskTemplateId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/task/template/\(taskTemplateId.urlPercentEncoding())"
    }
}

public struct GetTaskTemplateInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The system generated version of a task template that is associated with a task, when the task is created.
    public var snapshotVersion: Swift.String?
    /// A unique identifier for the task template.
    /// This member is required.
    public var taskTemplateId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        snapshotVersion: Swift.String? = nil,
        taskTemplateId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.snapshotVersion = snapshotVersion
        self.taskTemplateId = taskTemplateId
    }
}

struct GetTaskTemplateInputBody: Swift.Equatable {
}

extension GetTaskTemplateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetTaskTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTaskTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.constraints = output.constraints
            self.contactFlowId = output.contactFlowId
            self.createdTime = output.createdTime
            self.defaults = output.defaults
            self.description = output.description
            self.fields = output.fields
            self.id = output.id
            self.instanceId = output.instanceId
            self.lastModifiedTime = output.lastModifiedTime
            self.name = output.name
            self.status = output.status
            self.tags = output.tags
        } else {
            self.arn = nil
            self.constraints = nil
            self.contactFlowId = nil
            self.createdTime = nil
            self.defaults = nil
            self.description = nil
            self.fields = nil
            self.id = nil
            self.instanceId = nil
            self.lastModifiedTime = nil
            self.name = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct GetTaskTemplateOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN).
    /// This member is required.
    public var arn: Swift.String?
    /// Constraints that are applicable to the fields listed.
    public var constraints: ConnectClientTypes.TaskTemplateConstraints?
    /// The identifier of the flow that runs by default when a task is created by referencing this template.
    public var contactFlowId: Swift.String?
    /// The timestamp when the task template was created.
    public var createdTime: ClientRuntime.Date?
    /// The default values for fields when a task is created by referencing this template.
    public var defaults: ConnectClientTypes.TaskTemplateDefaults?
    /// The description of the task template.
    public var description: Swift.String?
    /// Fields that are part of the template.
    public var fields: [ConnectClientTypes.TaskTemplateField]?
    /// A unique identifier for the task template.
    /// This member is required.
    public var id: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    public var instanceId: Swift.String?
    /// The timestamp when the task template was last modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The name of the task template.
    /// This member is required.
    public var name: Swift.String?
    /// Marks a template as ACTIVE or INACTIVE for a task to refer to it. Tasks can only be created from ACTIVE templates. If a template is marked as INACTIVE, then a task that refers to this template cannot be created.
    public var status: ConnectClientTypes.TaskTemplateStatus?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        constraints: ConnectClientTypes.TaskTemplateConstraints? = nil,
        contactFlowId: Swift.String? = nil,
        createdTime: ClientRuntime.Date? = nil,
        defaults: ConnectClientTypes.TaskTemplateDefaults? = nil,
        description: Swift.String? = nil,
        fields: [ConnectClientTypes.TaskTemplateField]? = nil,
        id: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        status: ConnectClientTypes.TaskTemplateStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.constraints = constraints
        self.contactFlowId = contactFlowId
        self.createdTime = createdTime
        self.defaults = defaults
        self.description = description
        self.fields = fields
        self.id = id
        self.instanceId = instanceId
        self.lastModifiedTime = lastModifiedTime
        self.name = name
        self.status = status
        self.tags = tags
    }
}

struct GetTaskTemplateOutputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let id: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let contactFlowId: Swift.String?
    let constraints: ConnectClientTypes.TaskTemplateConstraints?
    let defaults: ConnectClientTypes.TaskTemplateDefaults?
    let fields: [ConnectClientTypes.TaskTemplateField]?
    let status: ConnectClientTypes.TaskTemplateStatus?
    let lastModifiedTime: ClientRuntime.Date?
    let createdTime: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension GetTaskTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case constraints = "Constraints"
        case contactFlowId = "ContactFlowId"
        case createdTime = "CreatedTime"
        case defaults = "Defaults"
        case description = "Description"
        case fields = "Fields"
        case id = "Id"
        case instanceId = "InstanceId"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case status = "Status"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let contactFlowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactFlowId)
        contactFlowId = contactFlowIdDecoded
        let constraintsDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.TaskTemplateConstraints.self, forKey: .constraints)
        constraints = constraintsDecoded
        let defaultsDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.TaskTemplateDefaults.self, forKey: .defaults)
        defaults = defaultsDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.TaskTemplateField?].self, forKey: .fields)
        var fieldsDecoded0:[ConnectClientTypes.TaskTemplateField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [ConnectClientTypes.TaskTemplateField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.TaskTemplateStatus.self, forKey: .status)
        status = statusDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetTaskTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTrafficDistributionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/traffic-distribution/\(id.urlPercentEncoding())"
    }
}

public struct GetTrafficDistributionInput: Swift.Equatable {
    /// The identifier of the traffic distribution group.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetTrafficDistributionInputBody: Swift.Equatable {
}

extension GetTrafficDistributionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetTrafficDistributionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTrafficDistributionOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentConfig = output.agentConfig
            self.arn = output.arn
            self.id = output.id
            self.signInConfig = output.signInConfig
            self.telephonyConfig = output.telephonyConfig
        } else {
            self.agentConfig = nil
            self.arn = nil
            self.id = nil
            self.signInConfig = nil
            self.telephonyConfig = nil
        }
    }
}

public struct GetTrafficDistributionOutput: Swift.Equatable {
    /// The distribution of agents between the instance and its replica(s).
    public var agentConfig: ConnectClientTypes.AgentConfig?
    /// The Amazon Resource Name (ARN) of the traffic distribution group.
    public var arn: Swift.String?
    /// The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.
    public var id: Swift.String?
    /// The distribution that determines which Amazon Web Services Regions should be used to sign in agents in to both the instance and its replica(s).
    public var signInConfig: ConnectClientTypes.SignInConfig?
    /// The distribution of traffic between the instance and its replicas.
    public var telephonyConfig: ConnectClientTypes.TelephonyConfig?

    public init(
        agentConfig: ConnectClientTypes.AgentConfig? = nil,
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        signInConfig: ConnectClientTypes.SignInConfig? = nil,
        telephonyConfig: ConnectClientTypes.TelephonyConfig? = nil
    )
    {
        self.agentConfig = agentConfig
        self.arn = arn
        self.id = id
        self.signInConfig = signInConfig
        self.telephonyConfig = telephonyConfig
    }
}

struct GetTrafficDistributionOutputBody: Swift.Equatable {
    let telephonyConfig: ConnectClientTypes.TelephonyConfig?
    let id: Swift.String?
    let arn: Swift.String?
    let signInConfig: ConnectClientTypes.SignInConfig?
    let agentConfig: ConnectClientTypes.AgentConfig?
}

extension GetTrafficDistributionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentConfig = "AgentConfig"
        case arn = "Arn"
        case id = "Id"
        case signInConfig = "SignInConfig"
        case telephonyConfig = "TelephonyConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let telephonyConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.TelephonyConfig.self, forKey: .telephonyConfig)
        telephonyConfig = telephonyConfigDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let signInConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.SignInConfig.self, forKey: .signInConfig)
        signInConfig = signInConfigDecoded
        let agentConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.AgentConfig.self, forKey: .agentConfig)
        agentConfig = agentConfigDecoded
    }
}

enum GetTrafficDistributionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectClientTypes {
    public enum Grouping: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case channel
        case queue
        case routingProfile
        case sdkUnknown(Swift.String)

        public static var allCases: [Grouping] {
            return [
                .channel,
                .queue,
                .routingProfile,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .channel: return "CHANNEL"
            case .queue: return "QUEUE"
            case .routingProfile: return "ROUTING_PROFILE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Grouping(rawValue: rawValue) ?? Grouping.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.HierarchyGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case hierarchyPath = "HierarchyPath"
        case id = "Id"
        case lastModifiedRegion = "LastModifiedRegion"
        case lastModifiedTime = "LastModifiedTime"
        case levelId = "LevelId"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let hierarchyPath = self.hierarchyPath {
            try encodeContainer.encode(hierarchyPath, forKey: .hierarchyPath)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastModifiedRegion = self.lastModifiedRegion {
            try encodeContainer.encode(lastModifiedRegion, forKey: .lastModifiedRegion)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let levelId = self.levelId {
            try encodeContainer.encode(levelId, forKey: .levelId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let levelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .levelId)
        levelId = levelIdDecoded
        let hierarchyPathDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyPath.self, forKey: .hierarchyPath)
        hierarchyPath = hierarchyPathDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastModifiedRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedRegion)
        lastModifiedRegion = lastModifiedRegionDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about a hierarchy group.
    public struct HierarchyGroup: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the hierarchy group.
        public var arn: Swift.String?
        /// Information about the levels in the hierarchy group.
        public var hierarchyPath: ConnectClientTypes.HierarchyPath?
        /// The identifier of the hierarchy group.
        public var id: Swift.String?
        /// The Amazon Web Services Region where this resource was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when this resource was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The identifier of the level in the hierarchy group.
        public var levelId: Swift.String?
        /// The name of the hierarchy group.
        public var name: Swift.String?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            hierarchyPath: ConnectClientTypes.HierarchyPath? = nil,
            id: Swift.String? = nil,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            levelId: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.hierarchyPath = hierarchyPath
            self.id = id
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.levelId = levelId
            self.name = name
            self.tags = tags
        }
    }

}

extension ConnectClientTypes.HierarchyGroupCondition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hierarchyGroupMatchType = "HierarchyGroupMatchType"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hierarchyGroupMatchType = self.hierarchyGroupMatchType {
            try encodeContainer.encode(hierarchyGroupMatchType.rawValue, forKey: .hierarchyGroupMatchType)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let hierarchyGroupMatchTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyGroupMatchType.self, forKey: .hierarchyGroupMatchType)
        hierarchyGroupMatchType = hierarchyGroupMatchTypeDecoded
    }
}

extension ConnectClientTypes {
    /// A leaf node condition which can be used to specify a hierarchy group condition.
    public struct HierarchyGroupCondition: Swift.Equatable {
        /// The type of hierarchy group match.
        public var hierarchyGroupMatchType: ConnectClientTypes.HierarchyGroupMatchType?
        /// The value in the hierarchy group condition.
        public var value: Swift.String?

        public init(
            hierarchyGroupMatchType: ConnectClientTypes.HierarchyGroupMatchType? = nil,
            value: Swift.String? = nil
        )
        {
            self.hierarchyGroupMatchType = hierarchyGroupMatchType
            self.value = value
        }
    }

}

extension ConnectClientTypes {
    public enum HierarchyGroupMatchType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case exact
        case withChildGroups
        case sdkUnknown(Swift.String)

        public static var allCases: [HierarchyGroupMatchType] {
            return [
                .exact,
                .withChildGroups,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .exact: return "EXACT"
            case .withChildGroups: return "WITH_CHILD_GROUPS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HierarchyGroupMatchType(rawValue: rawValue) ?? HierarchyGroupMatchType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.HierarchyGroupSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case lastModifiedRegion = "LastModifiedRegion"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastModifiedRegion = self.lastModifiedRegion {
            try encodeContainer.encode(lastModifiedRegion, forKey: .lastModifiedRegion)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastModifiedRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedRegion)
        lastModifiedRegion = lastModifiedRegionDecoded
    }
}

extension ConnectClientTypes {
    /// Contains summary information about a hierarchy group.
    public struct HierarchyGroupSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the hierarchy group.
        public var arn: Swift.String?
        /// The identifier of the hierarchy group.
        public var id: Swift.String?
        /// The Amazon Web Services Region where this resource was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when this resource was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name of the hierarchy group.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
        }
    }

}

extension ConnectClientTypes.HierarchyGroupSummaryReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension ConnectClientTypes {
    /// Information about the hierarchy group.
    public struct HierarchyGroupSummaryReference: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the hierarchy group.
        public var arn: Swift.String?
        /// The unique identifier for the hierarchy group.
        public var id: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
        }
    }

}

extension ConnectClientTypes.HierarchyLevel: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case lastModifiedRegion = "LastModifiedRegion"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastModifiedRegion = self.lastModifiedRegion {
            try encodeContainer.encode(lastModifiedRegion, forKey: .lastModifiedRegion)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastModifiedRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedRegion)
        lastModifiedRegion = lastModifiedRegionDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about a hierarchy level.
    public struct HierarchyLevel: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the hierarchy level.
        public var arn: Swift.String?
        /// The identifier of the hierarchy level.
        public var id: Swift.String?
        /// The Amazon Web Services Region where this resource was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when this resource was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name of the hierarchy level.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
        }
    }

}

extension ConnectClientTypes.HierarchyLevelUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about the hierarchy level to update.
    public struct HierarchyLevelUpdate: Swift.Equatable {
        /// The name of the user hierarchy level. Must not be more than 50 characters.
        /// This member is required.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension ConnectClientTypes.HierarchyPath: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case levelFive = "LevelFive"
        case levelFour = "LevelFour"
        case levelOne = "LevelOne"
        case levelThree = "LevelThree"
        case levelTwo = "LevelTwo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let levelFive = self.levelFive {
            try encodeContainer.encode(levelFive, forKey: .levelFive)
        }
        if let levelFour = self.levelFour {
            try encodeContainer.encode(levelFour, forKey: .levelFour)
        }
        if let levelOne = self.levelOne {
            try encodeContainer.encode(levelOne, forKey: .levelOne)
        }
        if let levelThree = self.levelThree {
            try encodeContainer.encode(levelThree, forKey: .levelThree)
        }
        if let levelTwo = self.levelTwo {
            try encodeContainer.encode(levelTwo, forKey: .levelTwo)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let levelOneDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyGroupSummary.self, forKey: .levelOne)
        levelOne = levelOneDecoded
        let levelTwoDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyGroupSummary.self, forKey: .levelTwo)
        levelTwo = levelTwoDecoded
        let levelThreeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyGroupSummary.self, forKey: .levelThree)
        levelThree = levelThreeDecoded
        let levelFourDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyGroupSummary.self, forKey: .levelFour)
        levelFour = levelFourDecoded
        let levelFiveDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyGroupSummary.self, forKey: .levelFive)
        levelFive = levelFiveDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about the levels of a hierarchy group.
    public struct HierarchyPath: Swift.Equatable {
        /// Information about level five.
        public var levelFive: ConnectClientTypes.HierarchyGroupSummary?
        /// Information about level four.
        public var levelFour: ConnectClientTypes.HierarchyGroupSummary?
        /// Information about level one.
        public var levelOne: ConnectClientTypes.HierarchyGroupSummary?
        /// Information about level three.
        public var levelThree: ConnectClientTypes.HierarchyGroupSummary?
        /// Information about level two.
        public var levelTwo: ConnectClientTypes.HierarchyGroupSummary?

        public init(
            levelFive: ConnectClientTypes.HierarchyGroupSummary? = nil,
            levelFour: ConnectClientTypes.HierarchyGroupSummary? = nil,
            levelOne: ConnectClientTypes.HierarchyGroupSummary? = nil,
            levelThree: ConnectClientTypes.HierarchyGroupSummary? = nil,
            levelTwo: ConnectClientTypes.HierarchyGroupSummary? = nil
        )
        {
            self.levelFive = levelFive
            self.levelFour = levelFour
            self.levelOne = levelOne
            self.levelThree = levelThree
            self.levelTwo = levelTwo
        }
    }

}

extension ConnectClientTypes.HierarchyPathReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case levelFive = "LevelFive"
        case levelFour = "LevelFour"
        case levelOne = "LevelOne"
        case levelThree = "LevelThree"
        case levelTwo = "LevelTwo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let levelFive = self.levelFive {
            try encodeContainer.encode(levelFive, forKey: .levelFive)
        }
        if let levelFour = self.levelFour {
            try encodeContainer.encode(levelFour, forKey: .levelFour)
        }
        if let levelOne = self.levelOne {
            try encodeContainer.encode(levelOne, forKey: .levelOne)
        }
        if let levelThree = self.levelThree {
            try encodeContainer.encode(levelThree, forKey: .levelThree)
        }
        if let levelTwo = self.levelTwo {
            try encodeContainer.encode(levelTwo, forKey: .levelTwo)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let levelOneDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyGroupSummaryReference.self, forKey: .levelOne)
        levelOne = levelOneDecoded
        let levelTwoDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyGroupSummaryReference.self, forKey: .levelTwo)
        levelTwo = levelTwoDecoded
        let levelThreeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyGroupSummaryReference.self, forKey: .levelThree)
        levelThree = levelThreeDecoded
        let levelFourDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyGroupSummaryReference.self, forKey: .levelFour)
        levelFour = levelFourDecoded
        let levelFiveDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyGroupSummaryReference.self, forKey: .levelFive)
        levelFive = levelFiveDecoded
    }
}

extension ConnectClientTypes {
    /// Information about the levels in the hierarchy group.
    public struct HierarchyPathReference: Swift.Equatable {
        /// Information about level five.
        public var levelFive: ConnectClientTypes.HierarchyGroupSummaryReference?
        /// Information about level four.
        public var levelFour: ConnectClientTypes.HierarchyGroupSummaryReference?
        /// Information about level one.
        public var levelOne: ConnectClientTypes.HierarchyGroupSummaryReference?
        /// Information about level three.
        public var levelThree: ConnectClientTypes.HierarchyGroupSummaryReference?
        /// Information about level two.
        public var levelTwo: ConnectClientTypes.HierarchyGroupSummaryReference?

        public init(
            levelFive: ConnectClientTypes.HierarchyGroupSummaryReference? = nil,
            levelFour: ConnectClientTypes.HierarchyGroupSummaryReference? = nil,
            levelOne: ConnectClientTypes.HierarchyGroupSummaryReference? = nil,
            levelThree: ConnectClientTypes.HierarchyGroupSummaryReference? = nil,
            levelTwo: ConnectClientTypes.HierarchyGroupSummaryReference? = nil
        )
        {
            self.levelFive = levelFive
            self.levelFour = levelFour
            self.levelOne = levelOne
            self.levelThree = levelThree
            self.levelTwo = levelTwo
        }
    }

}

extension ConnectClientTypes.HierarchyStructure: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case levelFive = "LevelFive"
        case levelFour = "LevelFour"
        case levelOne = "LevelOne"
        case levelThree = "LevelThree"
        case levelTwo = "LevelTwo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let levelFive = self.levelFive {
            try encodeContainer.encode(levelFive, forKey: .levelFive)
        }
        if let levelFour = self.levelFour {
            try encodeContainer.encode(levelFour, forKey: .levelFour)
        }
        if let levelOne = self.levelOne {
            try encodeContainer.encode(levelOne, forKey: .levelOne)
        }
        if let levelThree = self.levelThree {
            try encodeContainer.encode(levelThree, forKey: .levelThree)
        }
        if let levelTwo = self.levelTwo {
            try encodeContainer.encode(levelTwo, forKey: .levelTwo)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let levelOneDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyLevel.self, forKey: .levelOne)
        levelOne = levelOneDecoded
        let levelTwoDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyLevel.self, forKey: .levelTwo)
        levelTwo = levelTwoDecoded
        let levelThreeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyLevel.self, forKey: .levelThree)
        levelThree = levelThreeDecoded
        let levelFourDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyLevel.self, forKey: .levelFour)
        levelFour = levelFourDecoded
        let levelFiveDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyLevel.self, forKey: .levelFive)
        levelFive = levelFiveDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about a hierarchy structure.
    public struct HierarchyStructure: Swift.Equatable {
        /// Information about level five.
        public var levelFive: ConnectClientTypes.HierarchyLevel?
        /// Information about level four.
        public var levelFour: ConnectClientTypes.HierarchyLevel?
        /// Information about level one.
        public var levelOne: ConnectClientTypes.HierarchyLevel?
        /// Information about level three.
        public var levelThree: ConnectClientTypes.HierarchyLevel?
        /// Information about level two.
        public var levelTwo: ConnectClientTypes.HierarchyLevel?

        public init(
            levelFive: ConnectClientTypes.HierarchyLevel? = nil,
            levelFour: ConnectClientTypes.HierarchyLevel? = nil,
            levelOne: ConnectClientTypes.HierarchyLevel? = nil,
            levelThree: ConnectClientTypes.HierarchyLevel? = nil,
            levelTwo: ConnectClientTypes.HierarchyLevel? = nil
        )
        {
            self.levelFive = levelFive
            self.levelFour = levelFour
            self.levelOne = levelOne
            self.levelThree = levelThree
            self.levelTwo = levelTwo
        }
    }

}

extension ConnectClientTypes.HierarchyStructureUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case levelFive = "LevelFive"
        case levelFour = "LevelFour"
        case levelOne = "LevelOne"
        case levelThree = "LevelThree"
        case levelTwo = "LevelTwo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let levelFive = self.levelFive {
            try encodeContainer.encode(levelFive, forKey: .levelFive)
        }
        if let levelFour = self.levelFour {
            try encodeContainer.encode(levelFour, forKey: .levelFour)
        }
        if let levelOne = self.levelOne {
            try encodeContainer.encode(levelOne, forKey: .levelOne)
        }
        if let levelThree = self.levelThree {
            try encodeContainer.encode(levelThree, forKey: .levelThree)
        }
        if let levelTwo = self.levelTwo {
            try encodeContainer.encode(levelTwo, forKey: .levelTwo)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let levelOneDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyLevelUpdate.self, forKey: .levelOne)
        levelOne = levelOneDecoded
        let levelTwoDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyLevelUpdate.self, forKey: .levelTwo)
        levelTwo = levelTwoDecoded
        let levelThreeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyLevelUpdate.self, forKey: .levelThree)
        levelThree = levelThreeDecoded
        let levelFourDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyLevelUpdate.self, forKey: .levelFour)
        levelFour = levelFourDecoded
        let levelFiveDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyLevelUpdate.self, forKey: .levelFive)
        levelFive = levelFiveDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about the level hierarchy to update.
    public struct HierarchyStructureUpdate: Swift.Equatable {
        /// The update for level five.
        public var levelFive: ConnectClientTypes.HierarchyLevelUpdate?
        /// The update for level four.
        public var levelFour: ConnectClientTypes.HierarchyLevelUpdate?
        /// The update for level one.
        public var levelOne: ConnectClientTypes.HierarchyLevelUpdate?
        /// The update for level three.
        public var levelThree: ConnectClientTypes.HierarchyLevelUpdate?
        /// The update for level two.
        public var levelTwo: ConnectClientTypes.HierarchyLevelUpdate?

        public init(
            levelFive: ConnectClientTypes.HierarchyLevelUpdate? = nil,
            levelFour: ConnectClientTypes.HierarchyLevelUpdate? = nil,
            levelOne: ConnectClientTypes.HierarchyLevelUpdate? = nil,
            levelThree: ConnectClientTypes.HierarchyLevelUpdate? = nil,
            levelTwo: ConnectClientTypes.HierarchyLevelUpdate? = nil
        )
        {
            self.levelFive = levelFive
            self.levelFour = levelFour
            self.levelOne = levelOne
            self.levelThree = levelThree
            self.levelTwo = levelTwo
        }
    }

}

extension ConnectClientTypes.HistoricalMetric: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case statistic = "Statistic"
        case threshold = "Threshold"
        case unit = "Unit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let statistic = self.statistic {
            try encodeContainer.encode(statistic.rawValue, forKey: .statistic)
        }
        if let threshold = self.threshold {
            try encodeContainer.encode(threshold, forKey: .threshold)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HistoricalMetricName.self, forKey: .name)
        name = nameDecoded
        let thresholdDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Threshold.self, forKey: .threshold)
        threshold = thresholdDecoded
        let statisticDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Statistic.self, forKey: .statistic)
        statistic = statisticDecoded
        let unitDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Unit.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about a historical metric. For a description of each metric, see [Historical Metrics Definitions](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html) in the Amazon Connect Administrator Guide.
    public struct HistoricalMetric: Swift.Equatable {
        /// The name of the metric.
        public var name: ConnectClientTypes.HistoricalMetricName?
        /// The statistic for the metric.
        public var statistic: ConnectClientTypes.Statistic?
        /// The threshold for the metric, used with service level metrics.
        public var threshold: ConnectClientTypes.Threshold?
        /// The unit for the metric.
        public var unit: ConnectClientTypes.Unit?

        public init(
            name: ConnectClientTypes.HistoricalMetricName? = nil,
            statistic: ConnectClientTypes.Statistic? = nil,
            threshold: ConnectClientTypes.Threshold? = nil,
            unit: ConnectClientTypes.Unit? = nil
        )
        {
            self.name = name
            self.statistic = statistic
            self.threshold = threshold
            self.unit = unit
        }
    }

}

extension ConnectClientTypes.HistoricalMetricData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metric = "Metric"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metric = self.metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HistoricalMetric.self, forKey: .metric)
        metric = metricDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
    }
}

extension ConnectClientTypes {
    /// Contains the data for a historical metric.
    public struct HistoricalMetricData: Swift.Equatable {
        /// Information about the metric.
        public var metric: ConnectClientTypes.HistoricalMetric?
        /// The value of the metric.
        public var value: Swift.Double?

        public init(
            metric: ConnectClientTypes.HistoricalMetric? = nil,
            value: Swift.Double? = nil
        )
        {
            self.metric = metric
            self.value = value
        }
    }

}

extension ConnectClientTypes {
    /// The historical metric names.
    public enum HistoricalMetricName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case abandonTime
        case afterContactWorkTime
        case apiContactsHandled
        case callbackContactsHandled
        case contactsAbandoned
        case contactsAgentHungUpFirst
        case contactsConsulted
        case contactsHandled
        case contactsHandledIncoming
        case contactsHandledOutbound
        case contactsHoldAbandons
        case contactsMissed
        case contactsQueued
        case contactsTransferredIn
        case contactsTransferredInFromQueue
        case contactsTransferredOut
        case contactsTransferredOutFromQueue
        case handleTime
        case holdTime
        case interactionAndHoldTime
        case interactionTime
        case occupancy
        case queuedTime
        case queueAnswerTime
        case serviceLevel
        case sdkUnknown(Swift.String)

        public static var allCases: [HistoricalMetricName] {
            return [
                .abandonTime,
                .afterContactWorkTime,
                .apiContactsHandled,
                .callbackContactsHandled,
                .contactsAbandoned,
                .contactsAgentHungUpFirst,
                .contactsConsulted,
                .contactsHandled,
                .contactsHandledIncoming,
                .contactsHandledOutbound,
                .contactsHoldAbandons,
                .contactsMissed,
                .contactsQueued,
                .contactsTransferredIn,
                .contactsTransferredInFromQueue,
                .contactsTransferredOut,
                .contactsTransferredOutFromQueue,
                .handleTime,
                .holdTime,
                .interactionAndHoldTime,
                .interactionTime,
                .occupancy,
                .queuedTime,
                .queueAnswerTime,
                .serviceLevel,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .abandonTime: return "ABANDON_TIME"
            case .afterContactWorkTime: return "AFTER_CONTACT_WORK_TIME"
            case .apiContactsHandled: return "API_CONTACTS_HANDLED"
            case .callbackContactsHandled: return "CALLBACK_CONTACTS_HANDLED"
            case .contactsAbandoned: return "CONTACTS_ABANDONED"
            case .contactsAgentHungUpFirst: return "CONTACTS_AGENT_HUNG_UP_FIRST"
            case .contactsConsulted: return "CONTACTS_CONSULTED"
            case .contactsHandled: return "CONTACTS_HANDLED"
            case .contactsHandledIncoming: return "CONTACTS_HANDLED_INCOMING"
            case .contactsHandledOutbound: return "CONTACTS_HANDLED_OUTBOUND"
            case .contactsHoldAbandons: return "CONTACTS_HOLD_ABANDONS"
            case .contactsMissed: return "CONTACTS_MISSED"
            case .contactsQueued: return "CONTACTS_QUEUED"
            case .contactsTransferredIn: return "CONTACTS_TRANSFERRED_IN"
            case .contactsTransferredInFromQueue: return "CONTACTS_TRANSFERRED_IN_FROM_QUEUE"
            case .contactsTransferredOut: return "CONTACTS_TRANSFERRED_OUT"
            case .contactsTransferredOutFromQueue: return "CONTACTS_TRANSFERRED_OUT_FROM_QUEUE"
            case .handleTime: return "HANDLE_TIME"
            case .holdTime: return "HOLD_TIME"
            case .interactionAndHoldTime: return "INTERACTION_AND_HOLD_TIME"
            case .interactionTime: return "INTERACTION_TIME"
            case .occupancy: return "OCCUPANCY"
            case .queuedTime: return "QUEUED_TIME"
            case .queueAnswerTime: return "QUEUE_ANSWER_TIME"
            case .serviceLevel: return "SERVICE_LEVEL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HistoricalMetricName(rawValue: rawValue) ?? HistoricalMetricName.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.HistoricalMetricResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collections = "Collections"
        case dimensions = "Dimensions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let collections = collections {
            var collectionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .collections)
            for historicalmetricdata0 in collections {
                try collectionsContainer.encode(historicalmetricdata0)
            }
        }
        if let dimensions = self.dimensions {
            try encodeContainer.encode(dimensions, forKey: .dimensions)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionsDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Dimensions.self, forKey: .dimensions)
        dimensions = dimensionsDecoded
        let collectionsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.HistoricalMetricData?].self, forKey: .collections)
        var collectionsDecoded0:[ConnectClientTypes.HistoricalMetricData]? = nil
        if let collectionsContainer = collectionsContainer {
            collectionsDecoded0 = [ConnectClientTypes.HistoricalMetricData]()
            for structure0 in collectionsContainer {
                if let structure0 = structure0 {
                    collectionsDecoded0?.append(structure0)
                }
            }
        }
        collections = collectionsDecoded0
    }
}

extension ConnectClientTypes {
    /// Contains information about the historical metrics retrieved.
    public struct HistoricalMetricResult: Swift.Equatable {
        /// The set of metrics.
        public var collections: [ConnectClientTypes.HistoricalMetricData]?
        /// The dimension for the metrics.
        public var dimensions: ConnectClientTypes.Dimensions?

        public init(
            collections: [ConnectClientTypes.HistoricalMetricData]? = nil,
            dimensions: ConnectClientTypes.Dimensions? = nil
        )
        {
            self.collections = collections
            self.dimensions = dimensions
        }
    }

}

extension ConnectClientTypes.HoursOfOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case config = "Config"
        case description = "Description"
        case hoursOfOperationArn = "HoursOfOperationArn"
        case hoursOfOperationId = "HoursOfOperationId"
        case lastModifiedRegion = "LastModifiedRegion"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case tags = "Tags"
        case timeZone = "TimeZone"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let config = config {
            var configContainer = encodeContainer.nestedUnkeyedContainer(forKey: .config)
            for hoursofoperationconfig0 in config {
                try configContainer.encode(hoursofoperationconfig0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let hoursOfOperationArn = self.hoursOfOperationArn {
            try encodeContainer.encode(hoursOfOperationArn, forKey: .hoursOfOperationArn)
        }
        if let hoursOfOperationId = self.hoursOfOperationId {
            try encodeContainer.encode(hoursOfOperationId, forKey: .hoursOfOperationId)
        }
        if let lastModifiedRegion = self.lastModifiedRegion {
            try encodeContainer.encode(lastModifiedRegion, forKey: .lastModifiedRegion)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let timeZone = self.timeZone {
            try encodeContainer.encode(timeZone, forKey: .timeZone)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hoursOfOperationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hoursOfOperationId)
        hoursOfOperationId = hoursOfOperationIdDecoded
        let hoursOfOperationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hoursOfOperationArn)
        hoursOfOperationArn = hoursOfOperationArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let timeZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeZone)
        timeZone = timeZoneDecoded
        let configContainer = try containerValues.decodeIfPresent([ConnectClientTypes.HoursOfOperationConfig?].self, forKey: .config)
        var configDecoded0:[ConnectClientTypes.HoursOfOperationConfig]? = nil
        if let configContainer = configContainer {
            configDecoded0 = [ConnectClientTypes.HoursOfOperationConfig]()
            for structure0 in configContainer {
                if let structure0 = structure0 {
                    configDecoded0?.append(structure0)
                }
            }
        }
        config = configDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastModifiedRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedRegion)
        lastModifiedRegion = lastModifiedRegionDecoded
    }
}

extension ConnectClientTypes {
    /// Information about of the hours of operation.
    public struct HoursOfOperation: Swift.Equatable {
        /// Configuration information for the hours of operation.
        public var config: [ConnectClientTypes.HoursOfOperationConfig]?
        /// The description for the hours of operation.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) for the hours of operation.
        public var hoursOfOperationArn: Swift.String?
        /// The identifier for the hours of operation.
        public var hoursOfOperationId: Swift.String?
        /// The Amazon Web Services Region where this resource was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when this resource was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name for the hours of operation.
        public var name: Swift.String?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public var tags: [Swift.String:Swift.String]?
        /// The time zone for the hours of operation.
        public var timeZone: Swift.String?

        public init(
            config: [ConnectClientTypes.HoursOfOperationConfig]? = nil,
            description: Swift.String? = nil,
            hoursOfOperationArn: Swift.String? = nil,
            hoursOfOperationId: Swift.String? = nil,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            timeZone: Swift.String? = nil
        )
        {
            self.config = config
            self.description = description
            self.hoursOfOperationArn = hoursOfOperationArn
            self.hoursOfOperationId = hoursOfOperationId
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.tags = tags
            self.timeZone = timeZone
        }
    }

}

extension ConnectClientTypes.HoursOfOperationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case day = "Day"
        case endTime = "EndTime"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let day = self.day {
            try encodeContainer.encode(day.rawValue, forKey: .day)
        }
        if let endTime = self.endTime {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if let startTime = self.startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dayDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HoursOfOperationDays.self, forKey: .day)
        day = dayDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HoursOfOperationTimeSlice.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HoursOfOperationTimeSlice.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about the hours of operation.
    public struct HoursOfOperationConfig: Swift.Equatable {
        /// The day that the hours of operation applies to.
        /// This member is required.
        public var day: ConnectClientTypes.HoursOfOperationDays?
        /// The end time that your contact center closes.
        /// This member is required.
        public var endTime: ConnectClientTypes.HoursOfOperationTimeSlice?
        /// The start time that your contact center opens.
        /// This member is required.
        public var startTime: ConnectClientTypes.HoursOfOperationTimeSlice?

        public init(
            day: ConnectClientTypes.HoursOfOperationDays? = nil,
            endTime: ConnectClientTypes.HoursOfOperationTimeSlice? = nil,
            startTime: ConnectClientTypes.HoursOfOperationTimeSlice? = nil
        )
        {
            self.day = day
            self.endTime = endTime
            self.startTime = startTime
        }
    }

}

extension ConnectClientTypes {
    public enum HoursOfOperationDays: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case friday
        case monday
        case saturday
        case sunday
        case thursday
        case tuesday
        case wednesday
        case sdkUnknown(Swift.String)

        public static var allCases: [HoursOfOperationDays] {
            return [
                .friday,
                .monday,
                .saturday,
                .sunday,
                .thursday,
                .tuesday,
                .wednesday,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .friday: return "FRIDAY"
            case .monday: return "MONDAY"
            case .saturday: return "SATURDAY"
            case .sunday: return "SUNDAY"
            case .thursday: return "THURSDAY"
            case .tuesday: return "TUESDAY"
            case .wednesday: return "WEDNESDAY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HoursOfOperationDays(rawValue: rawValue) ?? HoursOfOperationDays.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.HoursOfOperationSearchCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case andConditions = "AndConditions"
        case orConditions = "OrConditions"
        case stringCondition = "StringCondition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let andConditions = andConditions {
            var andConditionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .andConditions)
            for hoursofoperationsearchcriteria0 in andConditions {
                try andConditionsContainer.encode(hoursofoperationsearchcriteria0)
            }
        }
        if let orConditions = orConditions {
            var orConditionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .orConditions)
            for hoursofoperationsearchcriteria0 in orConditions {
                try orConditionsContainer.encode(hoursofoperationsearchcriteria0)
            }
        }
        if let stringCondition = self.stringCondition {
            try encodeContainer.encode(stringCondition, forKey: .stringCondition)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orConditionsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.HoursOfOperationSearchCriteria?].self, forKey: .orConditions)
        var orConditionsDecoded0:[ConnectClientTypes.HoursOfOperationSearchCriteria]? = nil
        if let orConditionsContainer = orConditionsContainer {
            orConditionsDecoded0 = [ConnectClientTypes.HoursOfOperationSearchCriteria]()
            for structure0 in orConditionsContainer {
                if let structure0 = structure0 {
                    orConditionsDecoded0?.append(structure0)
                }
            }
        }
        orConditions = orConditionsDecoded0
        let andConditionsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.HoursOfOperationSearchCriteria?].self, forKey: .andConditions)
        var andConditionsDecoded0:[ConnectClientTypes.HoursOfOperationSearchCriteria]? = nil
        if let andConditionsContainer = andConditionsContainer {
            andConditionsDecoded0 = [ConnectClientTypes.HoursOfOperationSearchCriteria]()
            for structure0 in andConditionsContainer {
                if let structure0 = structure0 {
                    andConditionsDecoded0?.append(structure0)
                }
            }
        }
        andConditions = andConditionsDecoded0
        let stringConditionDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.StringCondition.self, forKey: .stringCondition)
        stringCondition = stringConditionDecoded
    }
}

extension ConnectClientTypes {
    /// The search criteria to be used to return hours of operations.
    public struct HoursOfOperationSearchCriteria: Swift.Equatable {
        /// A list of conditions which would be applied together with an AND condition.
        public var andConditions: [ConnectClientTypes.HoursOfOperationSearchCriteria]?
        /// A list of conditions which would be applied together with an OR condition.
        public var orConditions: [ConnectClientTypes.HoursOfOperationSearchCriteria]?
        /// A leaf node condition which can be used to specify a string condition. The currently supported values for FieldName are name, description, timezone, and resourceID.
        public var stringCondition: ConnectClientTypes.StringCondition?

        public init(
            andConditions: [ConnectClientTypes.HoursOfOperationSearchCriteria]? = nil,
            orConditions: [ConnectClientTypes.HoursOfOperationSearchCriteria]? = nil,
            stringCondition: ConnectClientTypes.StringCondition? = nil
        )
        {
            self.andConditions = andConditions
            self.orConditions = orConditions
            self.stringCondition = stringCondition
        }
    }

}

extension ConnectClientTypes.HoursOfOperationSearchFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagFilter = "TagFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagFilter = self.tagFilter {
            try encodeContainer.encode(tagFilter, forKey: .tagFilter)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagFilterDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ControlPlaneTagFilter.self, forKey: .tagFilter)
        tagFilter = tagFilterDecoded
    }
}

extension ConnectClientTypes {
    /// Filters to be applied to search results.
    public struct HoursOfOperationSearchFilter: Swift.Equatable {
        /// An object that can be used to specify Tag conditions inside the SearchFilter. This accepts an OR of AND (List of List) input where:
        ///
        /// * Top level list specifies conditions that need to be applied with OR operator
        ///
        /// * Inner list specifies conditions that need to be applied with AND operator.
        public var tagFilter: ConnectClientTypes.ControlPlaneTagFilter?

        public init(
            tagFilter: ConnectClientTypes.ControlPlaneTagFilter? = nil
        )
        {
            self.tagFilter = tagFilter
        }
    }

}

extension ConnectClientTypes.HoursOfOperationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case lastModifiedRegion = "LastModifiedRegion"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastModifiedRegion = self.lastModifiedRegion {
            try encodeContainer.encode(lastModifiedRegion, forKey: .lastModifiedRegion)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastModifiedRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedRegion)
        lastModifiedRegion = lastModifiedRegionDecoded
    }
}

extension ConnectClientTypes {
    /// Contains summary information about hours of operation for a contact center.
    public struct HoursOfOperationSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the hours of operation.
        public var arn: Swift.String?
        /// The identifier of the hours of operation.
        public var id: Swift.String?
        /// The Amazon Web Services Region where this resource was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when this resource was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name of the hours of operation.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
        }
    }

}

extension ConnectClientTypes.HoursOfOperationTimeSlice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hours = "Hours"
        case minutes = "Minutes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hours = self.hours {
            try encodeContainer.encode(hours, forKey: .hours)
        }
        if let minutes = self.minutes {
            try encodeContainer.encode(minutes, forKey: .minutes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hoursDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .hours)
        hours = hoursDecoded
        let minutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minutes)
        minutes = minutesDecoded
    }
}

extension ConnectClientTypes {
    /// The start time or end time for an hours of operation.
    public struct HoursOfOperationTimeSlice: Swift.Equatable {
        /// The hours.
        /// This member is required.
        public var hours: Swift.Int?
        /// The minutes.
        /// This member is required.
        public var minutes: Swift.Int?

        public init(
            hours: Swift.Int? = nil,
            minutes: Swift.Int? = nil
        )
        {
            self.hours = hours
            self.minutes = minutes
        }
    }

}

extension IdempotencyException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: IdempotencyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An entity with the same name already exists.
public struct IdempotencyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IdempotencyException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct IdempotencyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension IdempotencyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ImportPhoneNumberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case instanceId = "InstanceId"
        case phoneNumberDescription = "PhoneNumberDescription"
        case sourcePhoneNumberArn = "SourcePhoneNumberArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let phoneNumberDescription = self.phoneNumberDescription {
            try encodeContainer.encode(phoneNumberDescription, forKey: .phoneNumberDescription)
        }
        if let sourcePhoneNumberArn = self.sourcePhoneNumberArn {
            try encodeContainer.encode(sourcePhoneNumberArn, forKey: .sourcePhoneNumberArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension ImportPhoneNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/phone-number/import"
    }
}

public struct ImportPhoneNumberInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The description of the phone number.
    public var phoneNumberDescription: Swift.String?
    /// The claimed phone number ARN being imported from the external service, such as Amazon Pinpoint. If it is from Amazon Pinpoint, it looks like the ARN of the phone number to import from Amazon Pinpoint.
    /// This member is required.
    public var sourcePhoneNumberArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        phoneNumberDescription: Swift.String? = nil,
        sourcePhoneNumberArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.instanceId = instanceId
        self.phoneNumberDescription = phoneNumberDescription
        self.sourcePhoneNumberArn = sourcePhoneNumberArn
        self.tags = tags
    }
}

struct ImportPhoneNumberInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let sourcePhoneNumberArn: Swift.String?
    let phoneNumberDescription: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension ImportPhoneNumberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case instanceId = "InstanceId"
        case phoneNumberDescription = "PhoneNumberDescription"
        case sourcePhoneNumberArn = "SourcePhoneNumberArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let sourcePhoneNumberArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourcePhoneNumberArn)
        sourcePhoneNumberArn = sourcePhoneNumberArnDecoded
        let phoneNumberDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberDescription)
        phoneNumberDescription = phoneNumberDescriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension ImportPhoneNumberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ImportPhoneNumberOutputBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberArn = output.phoneNumberArn
            self.phoneNumberId = output.phoneNumberId
        } else {
            self.phoneNumberArn = nil
            self.phoneNumberId = nil
        }
    }
}

public struct ImportPhoneNumberOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the phone number.
    public var phoneNumberArn: Swift.String?
    /// A unique identifier for the phone number.
    public var phoneNumberId: Swift.String?

    public init(
        phoneNumberArn: Swift.String? = nil,
        phoneNumberId: Swift.String? = nil
    )
    {
        self.phoneNumberArn = phoneNumberArn
        self.phoneNumberId = phoneNumberId
    }
}

struct ImportPhoneNumberOutputBody: Swift.Equatable {
    let phoneNumberId: Swift.String?
    let phoneNumberArn: Swift.String?
}

extension ImportPhoneNumberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberArn = "PhoneNumberArn"
        case phoneNumberId = "PhoneNumberId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberId)
        phoneNumberId = phoneNumberIdDecoded
        let phoneNumberArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberArn)
        phoneNumberArn = phoneNumberArnDecoded
    }
}

enum ImportPhoneNumberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IdempotencyException": return try await IdempotencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectClientTypes.Instance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case id = "Id"
        case identityManagementType = "IdentityManagementType"
        case inboundCallsEnabled = "InboundCallsEnabled"
        case instanceAccessUrl = "InstanceAccessUrl"
        case instanceAlias = "InstanceAlias"
        case instanceStatus = "InstanceStatus"
        case outboundCallsEnabled = "OutboundCallsEnabled"
        case serviceRole = "ServiceRole"
        case statusReason = "StatusReason"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let identityManagementType = self.identityManagementType {
            try encodeContainer.encode(identityManagementType.rawValue, forKey: .identityManagementType)
        }
        if let inboundCallsEnabled = self.inboundCallsEnabled {
            try encodeContainer.encode(inboundCallsEnabled, forKey: .inboundCallsEnabled)
        }
        if let instanceAccessUrl = self.instanceAccessUrl {
            try encodeContainer.encode(instanceAccessUrl, forKey: .instanceAccessUrl)
        }
        if let instanceAlias = self.instanceAlias {
            try encodeContainer.encode(instanceAlias, forKey: .instanceAlias)
        }
        if let instanceStatus = self.instanceStatus {
            try encodeContainer.encode(instanceStatus.rawValue, forKey: .instanceStatus)
        }
        if let outboundCallsEnabled = self.outboundCallsEnabled {
            try encodeContainer.encode(outboundCallsEnabled, forKey: .outboundCallsEnabled)
        }
        if let serviceRole = self.serviceRole {
            try encodeContainer.encode(serviceRole, forKey: .serviceRole)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let identityManagementTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.DirectoryType.self, forKey: .identityManagementType)
        identityManagementType = identityManagementTypeDecoded
        let instanceAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceAlias)
        instanceAlias = instanceAliasDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let serviceRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRole)
        serviceRole = serviceRoleDecoded
        let instanceStatusDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.InstanceStatus.self, forKey: .instanceStatus)
        instanceStatus = instanceStatusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.InstanceStatusReason.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let inboundCallsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .inboundCallsEnabled)
        inboundCallsEnabled = inboundCallsEnabledDecoded
        let outboundCallsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .outboundCallsEnabled)
        outboundCallsEnabled = outboundCallsEnabledDecoded
        let instanceAccessUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceAccessUrl)
        instanceAccessUrl = instanceAccessUrlDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ConnectClientTypes.Instance: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Instance(arn: \(Swift.String(describing: arn)), createdTime: \(Swift.String(describing: createdTime)), id: \(Swift.String(describing: id)), identityManagementType: \(Swift.String(describing: identityManagementType)), inboundCallsEnabled: \(Swift.String(describing: inboundCallsEnabled)), instanceAccessUrl: \(Swift.String(describing: instanceAccessUrl)), instanceStatus: \(Swift.String(describing: instanceStatus)), outboundCallsEnabled: \(Swift.String(describing: outboundCallsEnabled)), serviceRole: \(Swift.String(describing: serviceRole)), statusReason: \(Swift.String(describing: statusReason)), tags: \(Swift.String(describing: tags)), instanceAlias: \"CONTENT_REDACTED\")"}
}

extension ConnectClientTypes {
    /// The Amazon Connect instance.
    public struct Instance: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the instance.
        public var arn: Swift.String?
        /// When the instance was created.
        public var createdTime: ClientRuntime.Date?
        /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
        public var id: Swift.String?
        /// The identity management type.
        public var identityManagementType: ConnectClientTypes.DirectoryType?
        /// Whether inbound calls are enabled.
        public var inboundCallsEnabled: Swift.Bool?
        /// This URL allows contact center users to access the Amazon Connect admin website.
        public var instanceAccessUrl: Swift.String?
        /// The alias of instance.
        public var instanceAlias: Swift.String?
        /// The state of the instance.
        public var instanceStatus: ConnectClientTypes.InstanceStatus?
        /// Whether outbound calls are enabled.
        public var outboundCallsEnabled: Swift.Bool?
        /// The service role of the instance.
        public var serviceRole: Swift.String?
        /// Relevant details why the instance was not successfully created.
        public var statusReason: ConnectClientTypes.InstanceStatusReason?
        /// The tags of an instance.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            identityManagementType: ConnectClientTypes.DirectoryType? = nil,
            inboundCallsEnabled: Swift.Bool? = nil,
            instanceAccessUrl: Swift.String? = nil,
            instanceAlias: Swift.String? = nil,
            instanceStatus: ConnectClientTypes.InstanceStatus? = nil,
            outboundCallsEnabled: Swift.Bool? = nil,
            serviceRole: Swift.String? = nil,
            statusReason: ConnectClientTypes.InstanceStatusReason? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.id = id
            self.identityManagementType = identityManagementType
            self.inboundCallsEnabled = inboundCallsEnabled
            self.instanceAccessUrl = instanceAccessUrl
            self.instanceAlias = instanceAlias
            self.instanceStatus = instanceStatus
            self.outboundCallsEnabled = outboundCallsEnabled
            self.serviceRole = serviceRole
            self.statusReason = statusReason
            self.tags = tags
        }
    }

}

extension ConnectClientTypes {
    public enum InstanceAttributeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case autoResolveBestVoices
        case contactflowLogs
        case contactLens
        case earlyMedia
        case enhancedContactMonitoring
        case highVolumeOutbound
        case inboundCalls
        case multiPartyConference
        case outboundCalls
        case useCustomTtsVoices
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceAttributeType] {
            return [
                .autoResolveBestVoices,
                .contactflowLogs,
                .contactLens,
                .earlyMedia,
                .enhancedContactMonitoring,
                .highVolumeOutbound,
                .inboundCalls,
                .multiPartyConference,
                .outboundCalls,
                .useCustomTtsVoices,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .autoResolveBestVoices: return "AUTO_RESOLVE_BEST_VOICES"
            case .contactflowLogs: return "CONTACTFLOW_LOGS"
            case .contactLens: return "CONTACT_LENS"
            case .earlyMedia: return "EARLY_MEDIA"
            case .enhancedContactMonitoring: return "ENHANCED_CONTACT_MONITORING"
            case .highVolumeOutbound: return "HIGH_VOLUME_OUTBOUND"
            case .inboundCalls: return "INBOUND_CALLS"
            case .multiPartyConference: return "MULTI_PARTY_CONFERENCE"
            case .outboundCalls: return "OUTBOUND_CALLS"
            case .useCustomTtsVoices: return "USE_CUSTOM_TTS_VOICES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InstanceAttributeType(rawValue: rawValue) ?? InstanceAttributeType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes {
    public enum InstanceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creationFailed
        case creationInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceStatus] {
            return [
                .active,
                .creationFailed,
                .creationInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creationFailed: return "CREATION_FAILED"
            case .creationInProgress: return "CREATION_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InstanceStatus(rawValue: rawValue) ?? InstanceStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.InstanceStatusReason: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectClientTypes {
    /// Relevant details why the instance was not successfully created.
    public struct InstanceStatusReason: Swift.Equatable {
        /// The message.
        public var message: Swift.String?

        public init(
            message: Swift.String? = nil
        )
        {
            self.message = message
        }
    }

}

extension ConnectClientTypes.InstanceStorageConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case kinesisFirehoseConfig = "KinesisFirehoseConfig"
        case kinesisStreamConfig = "KinesisStreamConfig"
        case kinesisVideoStreamConfig = "KinesisVideoStreamConfig"
        case s3Config = "S3Config"
        case storageType = "StorageType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = self.associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let kinesisFirehoseConfig = self.kinesisFirehoseConfig {
            try encodeContainer.encode(kinesisFirehoseConfig, forKey: .kinesisFirehoseConfig)
        }
        if let kinesisStreamConfig = self.kinesisStreamConfig {
            try encodeContainer.encode(kinesisStreamConfig, forKey: .kinesisStreamConfig)
        }
        if let kinesisVideoStreamConfig = self.kinesisVideoStreamConfig {
            try encodeContainer.encode(kinesisVideoStreamConfig, forKey: .kinesisVideoStreamConfig)
        }
        if let s3Config = self.s3Config {
            try encodeContainer.encode(s3Config, forKey: .s3Config)
        }
        if let storageType = self.storageType {
            try encodeContainer.encode(storageType.rawValue, forKey: .storageType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.StorageType.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let s3ConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.S3Config.self, forKey: .s3Config)
        s3Config = s3ConfigDecoded
        let kinesisVideoStreamConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.KinesisVideoStreamConfig.self, forKey: .kinesisVideoStreamConfig)
        kinesisVideoStreamConfig = kinesisVideoStreamConfigDecoded
        let kinesisStreamConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.KinesisStreamConfig.self, forKey: .kinesisStreamConfig)
        kinesisStreamConfig = kinesisStreamConfigDecoded
        let kinesisFirehoseConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.KinesisFirehoseConfig.self, forKey: .kinesisFirehoseConfig)
        kinesisFirehoseConfig = kinesisFirehoseConfigDecoded
    }
}

extension ConnectClientTypes {
    /// The storage configuration for the instance.
    public struct InstanceStorageConfig: Swift.Equatable {
        /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
        public var associationId: Swift.String?
        /// The configuration of the Kinesis Firehose delivery stream.
        public var kinesisFirehoseConfig: ConnectClientTypes.KinesisFirehoseConfig?
        /// The configuration of the Kinesis data stream.
        public var kinesisStreamConfig: ConnectClientTypes.KinesisStreamConfig?
        /// The configuration of the Kinesis video stream.
        public var kinesisVideoStreamConfig: ConnectClientTypes.KinesisVideoStreamConfig?
        /// The S3 bucket configuration.
        public var s3Config: ConnectClientTypes.S3Config?
        /// A valid storage type.
        /// This member is required.
        public var storageType: ConnectClientTypes.StorageType?

        public init(
            associationId: Swift.String? = nil,
            kinesisFirehoseConfig: ConnectClientTypes.KinesisFirehoseConfig? = nil,
            kinesisStreamConfig: ConnectClientTypes.KinesisStreamConfig? = nil,
            kinesisVideoStreamConfig: ConnectClientTypes.KinesisVideoStreamConfig? = nil,
            s3Config: ConnectClientTypes.S3Config? = nil,
            storageType: ConnectClientTypes.StorageType? = nil
        )
        {
            self.associationId = associationId
            self.kinesisFirehoseConfig = kinesisFirehoseConfig
            self.kinesisStreamConfig = kinesisStreamConfig
            self.kinesisVideoStreamConfig = kinesisVideoStreamConfig
            self.s3Config = s3Config
            self.storageType = storageType
        }
    }

}

extension ConnectClientTypes {
    public enum InstanceStorageResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case agentEvents
        case attachments
        case callRecordings
        case chatTranscripts
        case contactEvaluations
        case contactTraceRecords
        case mediaStreams
        case realTimeContactAnalysisSegments
        case scheduledReports
        case screenRecordings
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceStorageResourceType] {
            return [
                .agentEvents,
                .attachments,
                .callRecordings,
                .chatTranscripts,
                .contactEvaluations,
                .contactTraceRecords,
                .mediaStreams,
                .realTimeContactAnalysisSegments,
                .scheduledReports,
                .screenRecordings,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agentEvents: return "AGENT_EVENTS"
            case .attachments: return "ATTACHMENTS"
            case .callRecordings: return "CALL_RECORDINGS"
            case .chatTranscripts: return "CHAT_TRANSCRIPTS"
            case .contactEvaluations: return "CONTACT_EVALUATIONS"
            case .contactTraceRecords: return "CONTACT_TRACE_RECORDS"
            case .mediaStreams: return "MEDIA_STREAMS"
            case .realTimeContactAnalysisSegments: return "REAL_TIME_CONTACT_ANALYSIS_SEGMENTS"
            case .scheduledReports: return "SCHEDULED_REPORTS"
            case .screenRecordings: return "SCREEN_RECORDINGS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InstanceStorageResourceType(rawValue: rawValue) ?? InstanceStorageResourceType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.InstanceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case id = "Id"
        case identityManagementType = "IdentityManagementType"
        case inboundCallsEnabled = "InboundCallsEnabled"
        case instanceAccessUrl = "InstanceAccessUrl"
        case instanceAlias = "InstanceAlias"
        case instanceStatus = "InstanceStatus"
        case outboundCallsEnabled = "OutboundCallsEnabled"
        case serviceRole = "ServiceRole"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let identityManagementType = self.identityManagementType {
            try encodeContainer.encode(identityManagementType.rawValue, forKey: .identityManagementType)
        }
        if let inboundCallsEnabled = self.inboundCallsEnabled {
            try encodeContainer.encode(inboundCallsEnabled, forKey: .inboundCallsEnabled)
        }
        if let instanceAccessUrl = self.instanceAccessUrl {
            try encodeContainer.encode(instanceAccessUrl, forKey: .instanceAccessUrl)
        }
        if let instanceAlias = self.instanceAlias {
            try encodeContainer.encode(instanceAlias, forKey: .instanceAlias)
        }
        if let instanceStatus = self.instanceStatus {
            try encodeContainer.encode(instanceStatus.rawValue, forKey: .instanceStatus)
        }
        if let outboundCallsEnabled = self.outboundCallsEnabled {
            try encodeContainer.encode(outboundCallsEnabled, forKey: .outboundCallsEnabled)
        }
        if let serviceRole = self.serviceRole {
            try encodeContainer.encode(serviceRole, forKey: .serviceRole)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let identityManagementTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.DirectoryType.self, forKey: .identityManagementType)
        identityManagementType = identityManagementTypeDecoded
        let instanceAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceAlias)
        instanceAlias = instanceAliasDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let serviceRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRole)
        serviceRole = serviceRoleDecoded
        let instanceStatusDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.InstanceStatus.self, forKey: .instanceStatus)
        instanceStatus = instanceStatusDecoded
        let inboundCallsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .inboundCallsEnabled)
        inboundCallsEnabled = inboundCallsEnabledDecoded
        let outboundCallsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .outboundCallsEnabled)
        outboundCallsEnabled = outboundCallsEnabledDecoded
        let instanceAccessUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceAccessUrl)
        instanceAccessUrl = instanceAccessUrlDecoded
    }
}

extension ConnectClientTypes.InstanceSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstanceSummary(arn: \(Swift.String(describing: arn)), createdTime: \(Swift.String(describing: createdTime)), id: \(Swift.String(describing: id)), identityManagementType: \(Swift.String(describing: identityManagementType)), inboundCallsEnabled: \(Swift.String(describing: inboundCallsEnabled)), instanceAccessUrl: \(Swift.String(describing: instanceAccessUrl)), instanceStatus: \(Swift.String(describing: instanceStatus)), outboundCallsEnabled: \(Swift.String(describing: outboundCallsEnabled)), serviceRole: \(Swift.String(describing: serviceRole)), instanceAlias: \"CONTENT_REDACTED\")"}
}

extension ConnectClientTypes {
    /// Information about the instance.
    public struct InstanceSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the instance.
        public var arn: Swift.String?
        /// When the instance was created.
        public var createdTime: ClientRuntime.Date?
        /// The identifier of the instance.
        public var id: Swift.String?
        /// The identity management type of the instance.
        public var identityManagementType: ConnectClientTypes.DirectoryType?
        /// Whether inbound calls are enabled.
        public var inboundCallsEnabled: Swift.Bool?
        /// This URL allows contact center users to access the Amazon Connect admin website.
        public var instanceAccessUrl: Swift.String?
        /// The alias of the instance.
        public var instanceAlias: Swift.String?
        /// The state of the instance.
        public var instanceStatus: ConnectClientTypes.InstanceStatus?
        /// Whether outbound calls are enabled.
        public var outboundCallsEnabled: Swift.Bool?
        /// The service role of the instance.
        public var serviceRole: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            identityManagementType: ConnectClientTypes.DirectoryType? = nil,
            inboundCallsEnabled: Swift.Bool? = nil,
            instanceAccessUrl: Swift.String? = nil,
            instanceAlias: Swift.String? = nil,
            instanceStatus: ConnectClientTypes.InstanceStatus? = nil,
            outboundCallsEnabled: Swift.Bool? = nil,
            serviceRole: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.id = id
            self.identityManagementType = identityManagementType
            self.inboundCallsEnabled = inboundCallsEnabled
            self.instanceAccessUrl = instanceAccessUrl
            self.instanceAlias = instanceAlias
            self.instanceStatus = instanceStatus
            self.outboundCallsEnabled = outboundCallsEnabled
            self.serviceRole = serviceRole
        }
    }

}

extension ConnectClientTypes.IntegrationAssociationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case integrationArn = "IntegrationArn"
        case integrationAssociationArn = "IntegrationAssociationArn"
        case integrationAssociationId = "IntegrationAssociationId"
        case integrationType = "IntegrationType"
        case sourceApplicationName = "SourceApplicationName"
        case sourceApplicationUrl = "SourceApplicationUrl"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let integrationArn = self.integrationArn {
            try encodeContainer.encode(integrationArn, forKey: .integrationArn)
        }
        if let integrationAssociationArn = self.integrationAssociationArn {
            try encodeContainer.encode(integrationAssociationArn, forKey: .integrationAssociationArn)
        }
        if let integrationAssociationId = self.integrationAssociationId {
            try encodeContainer.encode(integrationAssociationId, forKey: .integrationAssociationId)
        }
        if let integrationType = self.integrationType {
            try encodeContainer.encode(integrationType.rawValue, forKey: .integrationType)
        }
        if let sourceApplicationName = self.sourceApplicationName {
            try encodeContainer.encode(sourceApplicationName, forKey: .sourceApplicationName)
        }
        if let sourceApplicationUrl = self.sourceApplicationUrl {
            try encodeContainer.encode(sourceApplicationUrl, forKey: .sourceApplicationUrl)
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let integrationAssociationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationAssociationId)
        integrationAssociationId = integrationAssociationIdDecoded
        let integrationAssociationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationAssociationArn)
        integrationAssociationArn = integrationAssociationArnDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let integrationTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.IntegrationType.self, forKey: .integrationType)
        integrationType = integrationTypeDecoded
        let integrationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationArn)
        integrationArn = integrationArnDecoded
        let sourceApplicationUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceApplicationUrl)
        sourceApplicationUrl = sourceApplicationUrlDecoded
        let sourceApplicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceApplicationName)
        sourceApplicationName = sourceApplicationNameDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
    }
}

extension ConnectClientTypes {
    /// Contains summary information about the associated AppIntegrations.
    public struct IntegrationAssociationSummary: Swift.Equatable {
        /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
        public var instanceId: Swift.String?
        /// The Amazon Resource Name (ARN) for the AppIntegration.
        public var integrationArn: Swift.String?
        /// The Amazon Resource Name (ARN) for the AppIntegration association.
        public var integrationAssociationArn: Swift.String?
        /// The identifier for the AppIntegration association.
        public var integrationAssociationId: Swift.String?
        /// The integration type.
        public var integrationType: ConnectClientTypes.IntegrationType?
        /// The user-provided, friendly name for the external application.
        public var sourceApplicationName: Swift.String?
        /// The URL for the external application.
        public var sourceApplicationUrl: Swift.String?
        /// The name of the source.
        public var sourceType: ConnectClientTypes.SourceType?

        public init(
            instanceId: Swift.String? = nil,
            integrationArn: Swift.String? = nil,
            integrationAssociationArn: Swift.String? = nil,
            integrationAssociationId: Swift.String? = nil,
            integrationType: ConnectClientTypes.IntegrationType? = nil,
            sourceApplicationName: Swift.String? = nil,
            sourceApplicationUrl: Swift.String? = nil,
            sourceType: ConnectClientTypes.SourceType? = nil
        )
        {
            self.instanceId = instanceId
            self.integrationArn = integrationArn
            self.integrationAssociationArn = integrationAssociationArn
            self.integrationAssociationId = integrationAssociationId
            self.integrationType = integrationType
            self.sourceApplicationName = sourceApplicationName
            self.sourceApplicationUrl = sourceApplicationUrl
            self.sourceType = sourceType
        }
    }

}

extension ConnectClientTypes {
    public enum IntegrationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case application
        case casesDomain
        case event
        case fileScanner
        case pinpointApp
        case voiceId
        case wisdomAssistant
        case wisdomKnowledgeBase
        case wisdomQuickResponses
        case sdkUnknown(Swift.String)

        public static var allCases: [IntegrationType] {
            return [
                .application,
                .casesDomain,
                .event,
                .fileScanner,
                .pinpointApp,
                .voiceId,
                .wisdomAssistant,
                .wisdomKnowledgeBase,
                .wisdomQuickResponses,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .application: return "APPLICATION"
            case .casesDomain: return "CASES_DOMAIN"
            case .event: return "EVENT"
            case .fileScanner: return "FILE_SCANNER"
            case .pinpointApp: return "PINPOINT_APP"
            case .voiceId: return "VOICE_ID"
            case .wisdomAssistant: return "WISDOM_ASSISTANT"
            case .wisdomKnowledgeBase: return "WISDOM_KNOWLEDGE_BASE"
            case .wisdomQuickResponses: return "WISDOM_QUICK_RESPONSES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IntegrationType(rawValue: rawValue) ?? IntegrationType.sdkUnknown(rawValue)
        }
    }
}

extension InternalServiceException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServiceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Request processing failed because of an error or failure with the service.
public struct InternalServiceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServiceException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServiceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServiceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectClientTypes.IntervalDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case intervalPeriod = "IntervalPeriod"
        case timeZone = "TimeZone"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let intervalPeriod = self.intervalPeriod {
            try encodeContainer.encode(intervalPeriod.rawValue, forKey: .intervalPeriod)
        }
        if let timeZone = self.timeZone {
            try encodeContainer.encode(timeZone, forKey: .timeZone)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeZone)
        timeZone = timeZoneDecoded
        let intervalPeriodDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.IntervalPeriod.self, forKey: .intervalPeriod)
        intervalPeriod = intervalPeriodDecoded
    }
}

extension ConnectClientTypes {
    /// Information about the interval period to use for returning results.
    public struct IntervalDetails: Swift.Equatable {
        /// IntervalPeriod: An aggregated grouping applied to request metrics. Valid IntervalPeriod values are: FIFTEEN_MIN | THIRTY_MIN | HOUR | DAY | WEEK | TOTAL. For example, if IntervalPeriod is selected THIRTY_MIN, StartTime and EndTime differs by 1 day, then Amazon Connect returns 48 results in the response. Each result is aggregated by the THIRTY_MIN period. By default Amazon Connect aggregates results based on the TOTAL interval period. The following list describes restrictions on StartTime and EndTime based on what IntervalPeriod is requested.
        ///
        /// * FIFTEEN_MIN: The difference between StartTime and EndTime must be less than 3 days.
        ///
        /// * THIRTY_MIN: The difference between StartTime and EndTime must be less than 3 days.
        ///
        /// * HOUR: The difference between StartTime and EndTime must be less than 3 days.
        ///
        /// * DAY: The difference between StartTime and EndTime must be less than 35 days.
        ///
        /// * WEEK: The difference between StartTime and EndTime must be less than 35 days.
        ///
        /// * TOTAL: The difference between StartTime and EndTime must be less than 35 days.
        public var intervalPeriod: ConnectClientTypes.IntervalPeriod?
        /// The timezone applied to requested metrics.
        public var timeZone: Swift.String?

        public init(
            intervalPeriod: ConnectClientTypes.IntervalPeriod? = nil,
            timeZone: Swift.String? = nil
        )
        {
            self.intervalPeriod = intervalPeriod
            self.timeZone = timeZone
        }
    }

}

extension ConnectClientTypes {
    public enum IntervalPeriod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case day
        case fifteenMin
        case hour
        case thirtyMin
        case total
        case week
        case sdkUnknown(Swift.String)

        public static var allCases: [IntervalPeriod] {
            return [
                .day,
                .fifteenMin,
                .hour,
                .thirtyMin,
                .total,
                .week,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .day: return "DAY"
            case .fifteenMin: return "FIFTEEN_MIN"
            case .hour: return "HOUR"
            case .thirtyMin: return "THIRTY_MIN"
            case .total: return "TOTAL"
            case .week: return "WEEK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IntervalPeriod(rawValue: rawValue) ?? IntervalPeriod.sdkUnknown(rawValue)
        }
    }
}

extension InvalidContactFlowException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidContactFlowExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.problems = output.problems
        } else {
            self.properties.problems = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The flow is not valid.
public struct InvalidContactFlowException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The problems with the flow. Please fix before trying again.
        public internal(set) var problems: [ConnectClientTypes.ProblemDetail]? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidContactFlowException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        problems: [ConnectClientTypes.ProblemDetail]? = nil
    )
    {
        self.properties.problems = problems
    }
}

struct InvalidContactFlowExceptionBody: Swift.Equatable {
    let problems: [ConnectClientTypes.ProblemDetail]?
}

extension InvalidContactFlowExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case problems
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let problemsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.ProblemDetail?].self, forKey: .problems)
        var problemsDecoded0:[ConnectClientTypes.ProblemDetail]? = nil
        if let problemsContainer = problemsContainer {
            problemsDecoded0 = [ConnectClientTypes.ProblemDetail]()
            for structure0 in problemsContainer {
                if let structure0 = structure0 {
                    problemsDecoded0?.append(structure0)
                }
            }
        }
        problems = problemsDecoded0
    }
}

extension InvalidContactFlowModuleException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidContactFlowModuleExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.problems = output.problems
        } else {
            self.properties.problems = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The problems with the module. Please fix before trying again.
public struct InvalidContactFlowModuleException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var problems: [ConnectClientTypes.ProblemDetail]? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidContactFlowModuleException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        problems: [ConnectClientTypes.ProblemDetail]? = nil
    )
    {
        self.properties.problems = problems
    }
}

struct InvalidContactFlowModuleExceptionBody: Swift.Equatable {
    let problems: [ConnectClientTypes.ProblemDetail]?
}

extension InvalidContactFlowModuleExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case problems = "Problems"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let problemsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.ProblemDetail?].self, forKey: .problems)
        var problemsDecoded0:[ConnectClientTypes.ProblemDetail]? = nil
        if let problemsContainer = problemsContainer {
            problemsDecoded0 = [ConnectClientTypes.ProblemDetail]()
            for structure0 in problemsContainer {
                if let structure0 = structure0 {
                    problemsDecoded0?.append(structure0)
                }
            }
        }
        problems = problemsDecoded0
    }
}

extension InvalidParameterException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// One or more of the specified parameters are not valid.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message about the parameters.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request is not valid.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message about the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectClientTypes.InvisibleFieldInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.TaskTemplateFieldIdentifier.self, forKey: .id)
        id = idDecoded
    }
}

extension ConnectClientTypes {
    /// A field that is invisible to an agent.
    public struct InvisibleFieldInfo: Swift.Equatable {
        /// Identifier of the invisible field.
        public var id: ConnectClientTypes.TaskTemplateFieldIdentifier?

        public init(
            id: ConnectClientTypes.TaskTemplateFieldIdentifier? = nil
        )
        {
            self.id = id
        }
    }

}

extension ConnectClientTypes.KinesisFirehoseConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firehoseArn = "FirehoseArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firehoseArn = self.firehoseArn {
            try encodeContainer.encode(firehoseArn, forKey: .firehoseArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firehoseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firehoseArn)
        firehoseArn = firehoseArnDecoded
    }
}

extension ConnectClientTypes {
    /// Configuration information of a Kinesis Data Firehose delivery stream.
    public struct KinesisFirehoseConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the delivery stream.
        /// This member is required.
        public var firehoseArn: Swift.String?

        public init(
            firehoseArn: Swift.String? = nil
        )
        {
            self.firehoseArn = firehoseArn
        }
    }

}

extension ConnectClientTypes.KinesisStreamConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamArn = "StreamArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamArn = self.streamArn {
            try encodeContainer.encode(streamArn, forKey: .streamArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamArn)
        streamArn = streamArnDecoded
    }
}

extension ConnectClientTypes {
    /// Configuration information of a Kinesis data stream.
    public struct KinesisStreamConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the data stream.
        /// This member is required.
        public var streamArn: Swift.String?

        public init(
            streamArn: Swift.String? = nil
        )
        {
            self.streamArn = streamArn
        }
    }

}

extension ConnectClientTypes.KinesisVideoStreamConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionConfig = "EncryptionConfig"
        case `prefix` = "Prefix"
        case retentionPeriodHours = "RetentionPeriodHours"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionConfig = self.encryptionConfig {
            try encodeContainer.encode(encryptionConfig, forKey: .encryptionConfig)
        }
        if let `prefix` = self.`prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
        if retentionPeriodHours != 0 {
            try encodeContainer.encode(retentionPeriodHours, forKey: .retentionPeriodHours)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let retentionPeriodHoursDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionPeriodHours) ?? 0
        retentionPeriodHours = retentionPeriodHoursDecoded
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
    }
}

extension ConnectClientTypes {
    /// Configuration information of a Kinesis video stream.
    public struct KinesisVideoStreamConfig: Swift.Equatable {
        /// The encryption configuration.
        /// This member is required.
        public var encryptionConfig: ConnectClientTypes.EncryptionConfig?
        /// The prefix of the video stream.
        /// This member is required.
        public var `prefix`: Swift.String?
        /// The number of hours data is retained in the stream. Kinesis Video Streams retains the data in a data store that is associated with the stream. The default value is 0, indicating that the stream does not persist data.
        /// This member is required.
        public var retentionPeriodHours: Swift.Int

        public init(
            encryptionConfig: ConnectClientTypes.EncryptionConfig? = nil,
            `prefix`: Swift.String? = nil,
            retentionPeriodHours: Swift.Int = 0
        )
        {
            self.encryptionConfig = encryptionConfig
            self.`prefix` = `prefix`
            self.retentionPeriodHours = retentionPeriodHours
        }
    }

}

extension ConnectClientTypes.LexBot: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lexRegion = "LexRegion"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lexRegion = self.lexRegion {
            try encodeContainer.encode(lexRegion, forKey: .lexRegion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let lexRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lexRegion)
        lexRegion = lexRegionDecoded
    }
}

extension ConnectClientTypes {
    /// Configuration information of an Amazon Lex bot.
    public struct LexBot: Swift.Equatable {
        /// The Amazon Web Services Region where the Amazon Lex bot was created.
        /// This member is required.
        public var lexRegion: Swift.String?
        /// The name of the Amazon Lex bot.
        /// This member is required.
        public var name: Swift.String?

        public init(
            lexRegion: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.lexRegion = lexRegion
            self.name = name
        }
    }

}

extension ConnectClientTypes.LexBotConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lexBot = "LexBot"
        case lexV2Bot = "LexV2Bot"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lexBot = self.lexBot {
            try encodeContainer.encode(lexBot, forKey: .lexBot)
        }
        if let lexV2Bot = self.lexV2Bot {
            try encodeContainer.encode(lexV2Bot, forKey: .lexV2Bot)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lexBotDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.LexBot.self, forKey: .lexBot)
        lexBot = lexBotDecoded
        let lexV2BotDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.LexV2Bot.self, forKey: .lexV2Bot)
        lexV2Bot = lexV2BotDecoded
    }
}

extension ConnectClientTypes {
    /// Configuration information of an Amazon Lex or Amazon Lex V2 bot.
    public struct LexBotConfig: Swift.Equatable {
        /// Configuration information of an Amazon Lex bot.
        public var lexBot: ConnectClientTypes.LexBot?
        /// Configuration information of an Amazon Lex V2 bot.
        public var lexV2Bot: ConnectClientTypes.LexV2Bot?

        public init(
            lexBot: ConnectClientTypes.LexBot? = nil,
            lexV2Bot: ConnectClientTypes.LexV2Bot? = nil
        )
        {
            self.lexBot = lexBot
            self.lexV2Bot = lexV2Bot
        }
    }

}

extension ConnectClientTypes.LexV2Bot: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasArn = "AliasArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasArn = self.aliasArn {
            try encodeContainer.encode(aliasArn, forKey: .aliasArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasArn)
        aliasArn = aliasArnDecoded
    }
}

extension ConnectClientTypes {
    /// Configuration information of an Amazon Lex V2 bot.
    public struct LexV2Bot: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Amazon Lex V2 bot.
        public var aliasArn: Swift.String?

        public init(
            aliasArn: Swift.String? = nil
        )
        {
            self.aliasArn = aliasArn
        }
    }

}

extension ConnectClientTypes {
    public enum LexVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case v1
        case v2
        case sdkUnknown(Swift.String)

        public static var allCases: [LexVersion] {
            return [
                .v1,
                .v2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .v1: return "V1"
            case .v2: return "V2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LexVersion(rawValue: rawValue) ?? LexVersion.sdkUnknown(rawValue)
        }
    }
}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The allowed limit for the resource has been exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message about the limit.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAgentStatusesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let agentStatusTypes = agentStatusTypes {
                agentStatusTypes.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "AgentStatusTypes".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension ListAgentStatusesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/agent-status/\(instanceId.urlPercentEncoding())"
    }
}

public struct ListAgentStatusesInput: Swift.Equatable {
    /// Available agent status types.
    public var agentStatusTypes: [ConnectClientTypes.AgentStatusType]?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        agentStatusTypes: [ConnectClientTypes.AgentStatusType]? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentStatusTypes = agentStatusTypes
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAgentStatusesInputBody: Swift.Equatable {
}

extension ListAgentStatusesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAgentStatusesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAgentStatusesOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentStatusSummaryList = output.agentStatusSummaryList
            self.nextToken = output.nextToken
        } else {
            self.agentStatusSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListAgentStatusesOutput: Swift.Equatable {
    /// A summary of agent statuses.
    public var agentStatusSummaryList: [ConnectClientTypes.AgentStatusSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        agentStatusSummaryList: [ConnectClientTypes.AgentStatusSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentStatusSummaryList = agentStatusSummaryList
        self.nextToken = nextToken
    }
}

struct ListAgentStatusesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let agentStatusSummaryList: [ConnectClientTypes.AgentStatusSummary]?
}

extension ListAgentStatusesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentStatusSummaryList = "AgentStatusSummaryList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let agentStatusSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.AgentStatusSummary?].self, forKey: .agentStatusSummaryList)
        var agentStatusSummaryListDecoded0:[ConnectClientTypes.AgentStatusSummary]? = nil
        if let agentStatusSummaryListContainer = agentStatusSummaryListContainer {
            agentStatusSummaryListDecoded0 = [ConnectClientTypes.AgentStatusSummary]()
            for structure0 in agentStatusSummaryListContainer {
                if let structure0 = structure0 {
                    agentStatusSummaryListDecoded0?.append(structure0)
                }
            }
        }
        agentStatusSummaryList = agentStatusSummaryListDecoded0
    }
}

enum ListAgentStatusesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAnalyticsDataAssociationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let dataSetId = dataSetId {
                let dataSetIdQueryItem = ClientRuntime.URLQueryItem(name: "DataSetId".urlPercentEncoding(), value: Swift.String(dataSetId).urlPercentEncoding())
                items.append(dataSetIdQueryItem)
            }
            return items
        }
    }
}

extension ListAnalyticsDataAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/analytics-data/instance/\(instanceId.urlPercentEncoding())/association"
    }
}

public struct ListAnalyticsDataAssociationsInput: Swift.Equatable {
    /// The identifier of the dataset to get the association status.
    public var dataSetId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        dataSetId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataSetId = dataSetId
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAnalyticsDataAssociationsInputBody: Swift.Equatable {
}

extension ListAnalyticsDataAssociationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAnalyticsDataAssociationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAnalyticsDataAssociationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.results = output.results
        } else {
            self.nextToken = nil
            self.results = nil
        }
    }
}

public struct ListAnalyticsDataAssociationsOutput: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// An array of successful results: DataSetId, TargetAccountId, ResourceShareId, ResourceShareArn. This is a paginated API, so nextToken is given if there are more results to be returned.
    public var results: [ConnectClientTypes.AnalyticsDataAssociationResult]?

    public init(
        nextToken: Swift.String? = nil,
        results: [ConnectClientTypes.AnalyticsDataAssociationResult]? = nil
    )
    {
        self.nextToken = nextToken
        self.results = results
    }
}

struct ListAnalyticsDataAssociationsOutputBody: Swift.Equatable {
    let results: [ConnectClientTypes.AnalyticsDataAssociationResult]?
    let nextToken: Swift.String?
}

extension ListAnalyticsDataAssociationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case results = "Results"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.AnalyticsDataAssociationResult?].self, forKey: .results)
        var resultsDecoded0:[ConnectClientTypes.AnalyticsDataAssociationResult]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [ConnectClientTypes.AnalyticsDataAssociationResult]()
            for structure0 in resultsContainer {
                if let structure0 = structure0 {
                    resultsDecoded0?.append(structure0)
                }
            }
        }
        results = resultsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAnalyticsDataAssociationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListApprovedOriginsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListApprovedOriginsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/approved-origins"
    }
}

public struct ListApprovedOriginsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApprovedOriginsInputBody: Swift.Equatable {
}

extension ListApprovedOriginsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListApprovedOriginsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListApprovedOriginsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.origins = output.origins
        } else {
            self.nextToken = nil
            self.origins = nil
        }
    }
}

public struct ListApprovedOriginsOutput: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// The approved origins.
    public var origins: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        origins: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.origins = origins
    }
}

struct ListApprovedOriginsOutputBody: Swift.Equatable {
    let origins: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListApprovedOriginsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case origins = "Origins"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .origins)
        var originsDecoded0:[Swift.String]? = nil
        if let originsContainer = originsContainer {
            originsDecoded0 = [Swift.String]()
            for string0 in originsContainer {
                if let string0 = string0 {
                    originsDecoded0?.append(string0)
                }
            }
        }
        origins = originsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListApprovedOriginsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListBotsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let lexVersion = lexVersion else {
                let message = "Creating a URL Query Item failed. lexVersion is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let lexVersionQueryItem = ClientRuntime.URLQueryItem(name: "lexVersion".urlPercentEncoding(), value: Swift.String(lexVersion.rawValue).urlPercentEncoding())
            items.append(lexVersionQueryItem)
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListBotsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/bots"
    }
}

public struct ListBotsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The version of Amazon Lex or Amazon Lex V2.
    /// This member is required.
    public var lexVersion: ConnectClientTypes.LexVersion?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        lexVersion: ConnectClientTypes.LexVersion? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.lexVersion = lexVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBotsInputBody: Swift.Equatable {
}

extension ListBotsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListBotsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListBotsOutputBody = try responseDecoder.decode(responseBody: data)
            self.lexBots = output.lexBots
            self.nextToken = output.nextToken
        } else {
            self.lexBots = nil
            self.nextToken = nil
        }
    }
}

public struct ListBotsOutput: Swift.Equatable {
    /// The names and Amazon Web Services Regions of the Amazon Lex or Amazon Lex V2 bots associated with the specified instance.
    public var lexBots: [ConnectClientTypes.LexBotConfig]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        lexBots: [ConnectClientTypes.LexBotConfig]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.lexBots = lexBots
        self.nextToken = nextToken
    }
}

struct ListBotsOutputBody: Swift.Equatable {
    let lexBots: [ConnectClientTypes.LexBotConfig]?
    let nextToken: Swift.String?
}

extension ListBotsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lexBots = "LexBots"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lexBotsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.LexBotConfig?].self, forKey: .lexBots)
        var lexBotsDecoded0:[ConnectClientTypes.LexBotConfig]? = nil
        if let lexBotsContainer = lexBotsContainer {
            lexBotsDecoded0 = [ConnectClientTypes.LexBotConfig]()
            for structure0 in lexBotsContainer {
                if let structure0 = structure0 {
                    lexBotsDecoded0?.append(structure0)
                }
            }
        }
        lexBots = lexBotsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListBotsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListContactEvaluationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            guard let contactId = contactId else {
                let message = "Creating a URL Query Item failed. contactId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let contactIdQueryItem = ClientRuntime.URLQueryItem(name: "contactId".urlPercentEncoding(), value: Swift.String(contactId).urlPercentEncoding())
            items.append(contactIdQueryItem)
            return items
        }
    }
}

extension ListContactEvaluationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/contact-evaluations/\(instanceId.urlPercentEncoding())"
    }
}

public struct ListContactEvaluationsInput: Swift.Equatable {
    /// The identifier of the contact in this instance of Amazon Connect.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. This is not expected to be set because the value returned in the previous response is always null.
    public var nextToken: Swift.String?

    public init(
        contactId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contactId = contactId
        self.instanceId = instanceId
        self.nextToken = nextToken
    }
}

struct ListContactEvaluationsInputBody: Swift.Equatable {
}

extension ListContactEvaluationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListContactEvaluationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListContactEvaluationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.evaluationSummaryList = output.evaluationSummaryList
            self.nextToken = output.nextToken
        } else {
            self.evaluationSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListContactEvaluationsOutput: Swift.Equatable {
    /// Provides details about a list of contact evaluations belonging to an instance.
    /// This member is required.
    public var evaluationSummaryList: [ConnectClientTypes.EvaluationSummary]?
    /// If there are additional results, this is the token for the next set of results. This is always returned as null in the response.
    public var nextToken: Swift.String?

    public init(
        evaluationSummaryList: [ConnectClientTypes.EvaluationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.evaluationSummaryList = evaluationSummaryList
        self.nextToken = nextToken
    }
}

struct ListContactEvaluationsOutputBody: Swift.Equatable {
    let evaluationSummaryList: [ConnectClientTypes.EvaluationSummary]?
    let nextToken: Swift.String?
}

extension ListContactEvaluationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationSummaryList = "EvaluationSummaryList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.EvaluationSummary?].self, forKey: .evaluationSummaryList)
        var evaluationSummaryListDecoded0:[ConnectClientTypes.EvaluationSummary]? = nil
        if let evaluationSummaryListContainer = evaluationSummaryListContainer {
            evaluationSummaryListDecoded0 = [ConnectClientTypes.EvaluationSummary]()
            for structure0 in evaluationSummaryListContainer {
                if let structure0 = structure0 {
                    evaluationSummaryListDecoded0?.append(structure0)
                }
            }
        }
        evaluationSummaryList = evaluationSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListContactEvaluationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListContactFlowModulesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let contactFlowModuleState = contactFlowModuleState {
                let contactFlowModuleStateQueryItem = ClientRuntime.URLQueryItem(name: "state".urlPercentEncoding(), value: Swift.String(contactFlowModuleState.rawValue).urlPercentEncoding())
                items.append(contactFlowModuleStateQueryItem)
            }
            return items
        }
    }
}

extension ListContactFlowModulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/contact-flow-modules-summary/\(instanceId.urlPercentEncoding())"
    }
}

public struct ListContactFlowModulesInput: Swift.Equatable {
    /// The state of the flow module.
    public var contactFlowModuleState: ConnectClientTypes.ContactFlowModuleState?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        contactFlowModuleState: ConnectClientTypes.ContactFlowModuleState? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contactFlowModuleState = contactFlowModuleState
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListContactFlowModulesInputBody: Swift.Equatable {
}

extension ListContactFlowModulesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListContactFlowModulesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListContactFlowModulesOutputBody = try responseDecoder.decode(responseBody: data)
            self.contactFlowModulesSummaryList = output.contactFlowModulesSummaryList
            self.nextToken = output.nextToken
        } else {
            self.contactFlowModulesSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListContactFlowModulesOutput: Swift.Equatable {
    /// Information about the flow module.
    public var contactFlowModulesSummaryList: [ConnectClientTypes.ContactFlowModuleSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        contactFlowModulesSummaryList: [ConnectClientTypes.ContactFlowModuleSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contactFlowModulesSummaryList = contactFlowModulesSummaryList
        self.nextToken = nextToken
    }
}

struct ListContactFlowModulesOutputBody: Swift.Equatable {
    let contactFlowModulesSummaryList: [ConnectClientTypes.ContactFlowModuleSummary]?
    let nextToken: Swift.String?
}

extension ListContactFlowModulesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactFlowModulesSummaryList = "ContactFlowModulesSummaryList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactFlowModulesSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.ContactFlowModuleSummary?].self, forKey: .contactFlowModulesSummaryList)
        var contactFlowModulesSummaryListDecoded0:[ConnectClientTypes.ContactFlowModuleSummary]? = nil
        if let contactFlowModulesSummaryListContainer = contactFlowModulesSummaryListContainer {
            contactFlowModulesSummaryListDecoded0 = [ConnectClientTypes.ContactFlowModuleSummary]()
            for structure0 in contactFlowModulesSummaryListContainer {
                if let structure0 = structure0 {
                    contactFlowModulesSummaryListDecoded0?.append(structure0)
                }
            }
        }
        contactFlowModulesSummaryList = contactFlowModulesSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListContactFlowModulesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListContactFlowsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let contactFlowTypes = contactFlowTypes {
                contactFlowTypes.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "contactFlowTypes".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension ListContactFlowsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/contact-flows-summary/\(instanceId.urlPercentEncoding())"
    }
}

public struct ListContactFlowsInput: Swift.Equatable {
    /// The type of flow.
    public var contactFlowTypes: [ConnectClientTypes.ContactFlowType]?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page. The default MaxResult size is 100.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        contactFlowTypes: [ConnectClientTypes.ContactFlowType]? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contactFlowTypes = contactFlowTypes
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListContactFlowsInputBody: Swift.Equatable {
}

extension ListContactFlowsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListContactFlowsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListContactFlowsOutputBody = try responseDecoder.decode(responseBody: data)
            self.contactFlowSummaryList = output.contactFlowSummaryList
            self.nextToken = output.nextToken
        } else {
            self.contactFlowSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListContactFlowsOutput: Swift.Equatable {
    /// Information about the flows.
    public var contactFlowSummaryList: [ConnectClientTypes.ContactFlowSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        contactFlowSummaryList: [ConnectClientTypes.ContactFlowSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contactFlowSummaryList = contactFlowSummaryList
        self.nextToken = nextToken
    }
}

struct ListContactFlowsOutputBody: Swift.Equatable {
    let contactFlowSummaryList: [ConnectClientTypes.ContactFlowSummary]?
    let nextToken: Swift.String?
}

extension ListContactFlowsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactFlowSummaryList = "ContactFlowSummaryList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactFlowSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.ContactFlowSummary?].self, forKey: .contactFlowSummaryList)
        var contactFlowSummaryListDecoded0:[ConnectClientTypes.ContactFlowSummary]? = nil
        if let contactFlowSummaryListContainer = contactFlowSummaryListContainer {
            contactFlowSummaryListDecoded0 = [ConnectClientTypes.ContactFlowSummary]()
            for structure0 in contactFlowSummaryListContainer {
                if let structure0 = structure0 {
                    contactFlowSummaryListDecoded0?.append(structure0)
                }
            }
        }
        contactFlowSummaryList = contactFlowSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListContactFlowsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListContactReferencesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let referenceTypes = referenceTypes else {
                let message = "Creating a URL Query Item failed. referenceTypes is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            referenceTypes.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "referenceTypes".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListContactReferencesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let contactId = contactId else {
            return nil
        }
        return "/contact/references/\(instanceId.urlPercentEncoding())/\(contactId.urlPercentEncoding())"
    }
}

public struct ListContactReferencesInput: Swift.Equatable {
    /// The identifier of the initial contact.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. This is not expected to be set, because the value returned in the previous response is always null.
    public var nextToken: Swift.String?
    /// The type of reference.
    /// This member is required.
    public var referenceTypes: [ConnectClientTypes.ReferenceType]?

    public init(
        contactId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        referenceTypes: [ConnectClientTypes.ReferenceType]? = nil
    )
    {
        self.contactId = contactId
        self.instanceId = instanceId
        self.nextToken = nextToken
        self.referenceTypes = referenceTypes
    }
}

struct ListContactReferencesInputBody: Swift.Equatable {
}

extension ListContactReferencesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListContactReferencesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListContactReferencesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.referenceSummaryList = output.referenceSummaryList
        } else {
            self.nextToken = nil
            self.referenceSummaryList = nil
        }
    }
}

public struct ListContactReferencesOutput: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results. This is always returned as null in the response.
    public var nextToken: Swift.String?
    /// Information about the flows.
    public var referenceSummaryList: [ConnectClientTypes.ReferenceSummary]?

    public init(
        nextToken: Swift.String? = nil,
        referenceSummaryList: [ConnectClientTypes.ReferenceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.referenceSummaryList = referenceSummaryList
    }
}

struct ListContactReferencesOutputBody: Swift.Equatable {
    let referenceSummaryList: [ConnectClientTypes.ReferenceSummary]?
    let nextToken: Swift.String?
}

extension ListContactReferencesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case referenceSummaryList = "ReferenceSummaryList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let referenceSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.ReferenceSummary?].self, forKey: .referenceSummaryList)
        var referenceSummaryListDecoded0:[ConnectClientTypes.ReferenceSummary]? = nil
        if let referenceSummaryListContainer = referenceSummaryListContainer {
            referenceSummaryListDecoded0 = [ConnectClientTypes.ReferenceSummary]()
            for union0 in referenceSummaryListContainer {
                if let union0 = union0 {
                    referenceSummaryListDecoded0?.append(union0)
                }
            }
        }
        referenceSummaryList = referenceSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListContactReferencesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDefaultVocabulariesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case languageCode = "LanguageCode"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDefaultVocabulariesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/default-vocabulary-summary/\(instanceId.urlPercentEncoding())"
    }
}

public struct ListDefaultVocabulariesInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see [What is Amazon Transcribe?](https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html)
    public var languageCode: ConnectClientTypes.VocabularyLanguageCode?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        languageCode: ConnectClientTypes.VocabularyLanguageCode? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.languageCode = languageCode
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDefaultVocabulariesInputBody: Swift.Equatable {
    let languageCode: ConnectClientTypes.VocabularyLanguageCode?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListDefaultVocabulariesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case languageCode = "LanguageCode"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageCodeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.VocabularyLanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDefaultVocabulariesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDefaultVocabulariesOutputBody = try responseDecoder.decode(responseBody: data)
            self.defaultVocabularyList = output.defaultVocabularyList
            self.nextToken = output.nextToken
        } else {
            self.defaultVocabularyList = nil
            self.nextToken = nil
        }
    }
}

public struct ListDefaultVocabulariesOutput: Swift.Equatable {
    /// A list of default vocabularies.
    /// This member is required.
    public var defaultVocabularyList: [ConnectClientTypes.DefaultVocabulary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        defaultVocabularyList: [ConnectClientTypes.DefaultVocabulary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.defaultVocabularyList = defaultVocabularyList
        self.nextToken = nextToken
    }
}

struct ListDefaultVocabulariesOutputBody: Swift.Equatable {
    let defaultVocabularyList: [ConnectClientTypes.DefaultVocabulary]?
    let nextToken: Swift.String?
}

extension ListDefaultVocabulariesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultVocabularyList = "DefaultVocabularyList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultVocabularyListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.DefaultVocabulary?].self, forKey: .defaultVocabularyList)
        var defaultVocabularyListDecoded0:[ConnectClientTypes.DefaultVocabulary]? = nil
        if let defaultVocabularyListContainer = defaultVocabularyListContainer {
            defaultVocabularyListDecoded0 = [ConnectClientTypes.DefaultVocabulary]()
            for structure0 in defaultVocabularyListContainer {
                if let structure0 = structure0 {
                    defaultVocabularyListDecoded0?.append(structure0)
                }
            }
        }
        defaultVocabularyList = defaultVocabularyListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDefaultVocabulariesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEvaluationFormVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListEvaluationFormVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let evaluationFormId = evaluationFormId else {
            return nil
        }
        return "/evaluation-forms/\(instanceId.urlPercentEncoding())/\(evaluationFormId.urlPercentEncoding())/versions"
    }
}

public struct ListEvaluationFormVersionsInput: Swift.Equatable {
    /// The unique identifier for the evaluation form.
    /// This member is required.
    public var evaluationFormId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        evaluationFormId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.evaluationFormId = evaluationFormId
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEvaluationFormVersionsInputBody: Swift.Equatable {
}

extension ListEvaluationFormVersionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListEvaluationFormVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEvaluationFormVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.evaluationFormVersionSummaryList = output.evaluationFormVersionSummaryList
            self.nextToken = output.nextToken
        } else {
            self.evaluationFormVersionSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListEvaluationFormVersionsOutput: Swift.Equatable {
    /// Provides details about a list of evaluation forms belonging to an instance.
    /// This member is required.
    public var evaluationFormVersionSummaryList: [ConnectClientTypes.EvaluationFormVersionSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        evaluationFormVersionSummaryList: [ConnectClientTypes.EvaluationFormVersionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.evaluationFormVersionSummaryList = evaluationFormVersionSummaryList
        self.nextToken = nextToken
    }
}

struct ListEvaluationFormVersionsOutputBody: Swift.Equatable {
    let evaluationFormVersionSummaryList: [ConnectClientTypes.EvaluationFormVersionSummary]?
    let nextToken: Swift.String?
}

extension ListEvaluationFormVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationFormVersionSummaryList = "EvaluationFormVersionSummaryList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationFormVersionSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.EvaluationFormVersionSummary?].self, forKey: .evaluationFormVersionSummaryList)
        var evaluationFormVersionSummaryListDecoded0:[ConnectClientTypes.EvaluationFormVersionSummary]? = nil
        if let evaluationFormVersionSummaryListContainer = evaluationFormVersionSummaryListContainer {
            evaluationFormVersionSummaryListDecoded0 = [ConnectClientTypes.EvaluationFormVersionSummary]()
            for structure0 in evaluationFormVersionSummaryListContainer {
                if let structure0 = structure0 {
                    evaluationFormVersionSummaryListDecoded0?.append(structure0)
                }
            }
        }
        evaluationFormVersionSummaryList = evaluationFormVersionSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEvaluationFormVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEvaluationFormsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListEvaluationFormsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/evaluation-forms/\(instanceId.urlPercentEncoding())"
    }
}

public struct ListEvaluationFormsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEvaluationFormsInputBody: Swift.Equatable {
}

extension ListEvaluationFormsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListEvaluationFormsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEvaluationFormsOutputBody = try responseDecoder.decode(responseBody: data)
            self.evaluationFormSummaryList = output.evaluationFormSummaryList
            self.nextToken = output.nextToken
        } else {
            self.evaluationFormSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListEvaluationFormsOutput: Swift.Equatable {
    /// Provides details about a list of evaluation forms belonging to an instance.
    /// This member is required.
    public var evaluationFormSummaryList: [ConnectClientTypes.EvaluationFormSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        evaluationFormSummaryList: [ConnectClientTypes.EvaluationFormSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.evaluationFormSummaryList = evaluationFormSummaryList
        self.nextToken = nextToken
    }
}

struct ListEvaluationFormsOutputBody: Swift.Equatable {
    let evaluationFormSummaryList: [ConnectClientTypes.EvaluationFormSummary]?
    let nextToken: Swift.String?
}

extension ListEvaluationFormsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationFormSummaryList = "EvaluationFormSummaryList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationFormSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.EvaluationFormSummary?].self, forKey: .evaluationFormSummaryList)
        var evaluationFormSummaryListDecoded0:[ConnectClientTypes.EvaluationFormSummary]? = nil
        if let evaluationFormSummaryListContainer = evaluationFormSummaryListContainer {
            evaluationFormSummaryListDecoded0 = [ConnectClientTypes.EvaluationFormSummary]()
            for structure0 in evaluationFormSummaryListContainer {
                if let structure0 = structure0 {
                    evaluationFormSummaryListDecoded0?.append(structure0)
                }
            }
        }
        evaluationFormSummaryList = evaluationFormSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEvaluationFormsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectClientTypes {
    public enum ListFlowAssociationResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case voicePhoneNumber
        case sdkUnknown(Swift.String)

        public static var allCases: [ListFlowAssociationResourceType] {
            return [
                .voicePhoneNumber,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .voicePhoneNumber: return "VOICE_PHONE_NUMBER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ListFlowAssociationResourceType(rawValue: rawValue) ?? ListFlowAssociationResourceType.sdkUnknown(rawValue)
        }
    }
}

extension ListFlowAssociationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let resourceType = resourceType {
                let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "ResourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
                items.append(resourceTypeQueryItem)
            }
            return items
        }
    }
}

extension ListFlowAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/flow-associations-summary/\(instanceId.urlPercentEncoding())"
    }
}

public struct ListFlowAssociationsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A valid resource type.
    public var resourceType: ConnectClientTypes.ListFlowAssociationResourceType?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceType: ConnectClientTypes.ListFlowAssociationResourceType? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceType = resourceType
    }
}

struct ListFlowAssociationsInputBody: Swift.Equatable {
}

extension ListFlowAssociationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListFlowAssociationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFlowAssociationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.flowAssociationSummaryList = output.flowAssociationSummaryList
            self.nextToken = output.nextToken
        } else {
            self.flowAssociationSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListFlowAssociationsOutput: Swift.Equatable {
    /// Summary of flow associations.
    public var flowAssociationSummaryList: [ConnectClientTypes.FlowAssociationSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        flowAssociationSummaryList: [ConnectClientTypes.FlowAssociationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.flowAssociationSummaryList = flowAssociationSummaryList
        self.nextToken = nextToken
    }
}

struct ListFlowAssociationsOutputBody: Swift.Equatable {
    let flowAssociationSummaryList: [ConnectClientTypes.FlowAssociationSummary]?
    let nextToken: Swift.String?
}

extension ListFlowAssociationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowAssociationSummaryList = "FlowAssociationSummaryList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowAssociationSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.FlowAssociationSummary?].self, forKey: .flowAssociationSummaryList)
        var flowAssociationSummaryListDecoded0:[ConnectClientTypes.FlowAssociationSummary]? = nil
        if let flowAssociationSummaryListContainer = flowAssociationSummaryListContainer {
            flowAssociationSummaryListDecoded0 = [ConnectClientTypes.FlowAssociationSummary]()
            for structure0 in flowAssociationSummaryListContainer {
                if let structure0 = structure0 {
                    flowAssociationSummaryListDecoded0?.append(structure0)
                }
            }
        }
        flowAssociationSummaryList = flowAssociationSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListFlowAssociationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListHoursOfOperationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListHoursOfOperationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/hours-of-operations-summary/\(instanceId.urlPercentEncoding())"
    }
}

public struct ListHoursOfOperationsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page. The default MaxResult size is 100.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListHoursOfOperationsInputBody: Swift.Equatable {
}

extension ListHoursOfOperationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListHoursOfOperationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListHoursOfOperationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.hoursOfOperationSummaryList = output.hoursOfOperationSummaryList
            self.nextToken = output.nextToken
        } else {
            self.hoursOfOperationSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListHoursOfOperationsOutput: Swift.Equatable {
    /// Information about the hours of operation.
    public var hoursOfOperationSummaryList: [ConnectClientTypes.HoursOfOperationSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        hoursOfOperationSummaryList: [ConnectClientTypes.HoursOfOperationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.hoursOfOperationSummaryList = hoursOfOperationSummaryList
        self.nextToken = nextToken
    }
}

struct ListHoursOfOperationsOutputBody: Swift.Equatable {
    let hoursOfOperationSummaryList: [ConnectClientTypes.HoursOfOperationSummary]?
    let nextToken: Swift.String?
}

extension ListHoursOfOperationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hoursOfOperationSummaryList = "HoursOfOperationSummaryList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hoursOfOperationSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.HoursOfOperationSummary?].self, forKey: .hoursOfOperationSummaryList)
        var hoursOfOperationSummaryListDecoded0:[ConnectClientTypes.HoursOfOperationSummary]? = nil
        if let hoursOfOperationSummaryListContainer = hoursOfOperationSummaryListContainer {
            hoursOfOperationSummaryListDecoded0 = [ConnectClientTypes.HoursOfOperationSummary]()
            for structure0 in hoursOfOperationSummaryListContainer {
                if let structure0 = structure0 {
                    hoursOfOperationSummaryListDecoded0?.append(structure0)
                }
            }
        }
        hoursOfOperationSummaryList = hoursOfOperationSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListHoursOfOperationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListInstanceAttributesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListInstanceAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/attributes"
    }
}

public struct ListInstanceAttributesInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListInstanceAttributesInputBody: Swift.Equatable {
}

extension ListInstanceAttributesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListInstanceAttributesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListInstanceAttributesOutputBody = try responseDecoder.decode(responseBody: data)
            self.attributes = output.attributes
            self.nextToken = output.nextToken
        } else {
            self.attributes = nil
            self.nextToken = nil
        }
    }
}

public struct ListInstanceAttributesOutput: Swift.Equatable {
    /// The attribute types.
    public var attributes: [ConnectClientTypes.Attribute]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        attributes: [ConnectClientTypes.Attribute]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.nextToken = nextToken
    }
}

struct ListInstanceAttributesOutputBody: Swift.Equatable {
    let attributes: [ConnectClientTypes.Attribute]?
    let nextToken: Swift.String?
}

extension ListInstanceAttributesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([ConnectClientTypes.Attribute?].self, forKey: .attributes)
        var attributesDecoded0:[ConnectClientTypes.Attribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [ConnectClientTypes.Attribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListInstanceAttributesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListInstanceStorageConfigsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            guard let resourceType = resourceType else {
                let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
            return items
        }
    }
}

extension ListInstanceStorageConfigsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/storage-configs"
    }
}

public struct ListInstanceStorageConfigsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A valid resource type.
    /// This member is required.
    public var resourceType: ConnectClientTypes.InstanceStorageResourceType?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceType: ConnectClientTypes.InstanceStorageResourceType? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceType = resourceType
    }
}

struct ListInstanceStorageConfigsInputBody: Swift.Equatable {
}

extension ListInstanceStorageConfigsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListInstanceStorageConfigsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListInstanceStorageConfigsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.storageConfigs = output.storageConfigs
        } else {
            self.nextToken = nil
            self.storageConfigs = nil
        }
    }
}

public struct ListInstanceStorageConfigsOutput: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// A valid storage type.
    public var storageConfigs: [ConnectClientTypes.InstanceStorageConfig]?

    public init(
        nextToken: Swift.String? = nil,
        storageConfigs: [ConnectClientTypes.InstanceStorageConfig]? = nil
    )
    {
        self.nextToken = nextToken
        self.storageConfigs = storageConfigs
    }
}

struct ListInstanceStorageConfigsOutputBody: Swift.Equatable {
    let storageConfigs: [ConnectClientTypes.InstanceStorageConfig]?
    let nextToken: Swift.String?
}

extension ListInstanceStorageConfigsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case storageConfigs = "StorageConfigs"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageConfigsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.InstanceStorageConfig?].self, forKey: .storageConfigs)
        var storageConfigsDecoded0:[ConnectClientTypes.InstanceStorageConfig]? = nil
        if let storageConfigsContainer = storageConfigsContainer {
            storageConfigsDecoded0 = [ConnectClientTypes.InstanceStorageConfig]()
            for structure0 in storageConfigsContainer {
                if let structure0 = structure0 {
                    storageConfigsDecoded0?.append(structure0)
                }
            }
        }
        storageConfigs = storageConfigsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListInstanceStorageConfigsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListInstancesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/instance"
    }
}

public struct ListInstancesInput: Swift.Equatable {
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListInstancesInputBody: Swift.Equatable {
}

extension ListInstancesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListInstancesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListInstancesOutputBody = try responseDecoder.decode(responseBody: data)
            self.instanceSummaryList = output.instanceSummaryList
            self.nextToken = output.nextToken
        } else {
            self.instanceSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListInstancesOutput: Swift.Equatable {
    /// Information about the instances.
    public var instanceSummaryList: [ConnectClientTypes.InstanceSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceSummaryList: [ConnectClientTypes.InstanceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceSummaryList = instanceSummaryList
        self.nextToken = nextToken
    }
}

struct ListInstancesOutputBody: Swift.Equatable {
    let instanceSummaryList: [ConnectClientTypes.InstanceSummary]?
    let nextToken: Swift.String?
}

extension ListInstancesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceSummaryList = "InstanceSummaryList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.InstanceSummary?].self, forKey: .instanceSummaryList)
        var instanceSummaryListDecoded0:[ConnectClientTypes.InstanceSummary]? = nil
        if let instanceSummaryListContainer = instanceSummaryListContainer {
            instanceSummaryListDecoded0 = [ConnectClientTypes.InstanceSummary]()
            for structure0 in instanceSummaryListContainer {
                if let structure0 = structure0 {
                    instanceSummaryListDecoded0?.append(structure0)
                }
            }
        }
        instanceSummaryList = instanceSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListInstancesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListIntegrationAssociationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let integrationArn = integrationArn {
                let integrationArnQueryItem = ClientRuntime.URLQueryItem(name: "integrationArn".urlPercentEncoding(), value: Swift.String(integrationArn).urlPercentEncoding())
                items.append(integrationArnQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let integrationType = integrationType {
                let integrationTypeQueryItem = ClientRuntime.URLQueryItem(name: "integrationType".urlPercentEncoding(), value: Swift.String(integrationType.rawValue).urlPercentEncoding())
                items.append(integrationTypeQueryItem)
            }
            return items
        }
    }
}

extension ListIntegrationAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/integration-associations"
    }
}

public struct ListIntegrationAssociationsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The Amazon Resource Name (ARN) of the integration.
    public var integrationArn: Swift.String?
    /// The integration type.
    public var integrationType: ConnectClientTypes.IntegrationType?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        integrationArn: Swift.String? = nil,
        integrationType: ConnectClientTypes.IntegrationType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.integrationArn = integrationArn
        self.integrationType = integrationType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIntegrationAssociationsInputBody: Swift.Equatable {
}

extension ListIntegrationAssociationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListIntegrationAssociationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListIntegrationAssociationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.integrationAssociationSummaryList = output.integrationAssociationSummaryList
            self.nextToken = output.nextToken
        } else {
            self.integrationAssociationSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListIntegrationAssociationsOutput: Swift.Equatable {
    /// The associations.
    public var integrationAssociationSummaryList: [ConnectClientTypes.IntegrationAssociationSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        integrationAssociationSummaryList: [ConnectClientTypes.IntegrationAssociationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.integrationAssociationSummaryList = integrationAssociationSummaryList
        self.nextToken = nextToken
    }
}

struct ListIntegrationAssociationsOutputBody: Swift.Equatable {
    let integrationAssociationSummaryList: [ConnectClientTypes.IntegrationAssociationSummary]?
    let nextToken: Swift.String?
}

extension ListIntegrationAssociationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case integrationAssociationSummaryList = "IntegrationAssociationSummaryList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let integrationAssociationSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.IntegrationAssociationSummary?].self, forKey: .integrationAssociationSummaryList)
        var integrationAssociationSummaryListDecoded0:[ConnectClientTypes.IntegrationAssociationSummary]? = nil
        if let integrationAssociationSummaryListContainer = integrationAssociationSummaryListContainer {
            integrationAssociationSummaryListDecoded0 = [ConnectClientTypes.IntegrationAssociationSummary]()
            for structure0 in integrationAssociationSummaryListContainer {
                if let structure0 = structure0 {
                    integrationAssociationSummaryListDecoded0?.append(structure0)
                }
            }
        }
        integrationAssociationSummaryList = integrationAssociationSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListIntegrationAssociationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLambdaFunctionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListLambdaFunctionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/lambda-functions"
    }
}

public struct ListLambdaFunctionsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLambdaFunctionsInputBody: Swift.Equatable {
}

extension ListLambdaFunctionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListLambdaFunctionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLambdaFunctionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.lambdaFunctions = output.lambdaFunctions
            self.nextToken = output.nextToken
        } else {
            self.lambdaFunctions = nil
            self.nextToken = nil
        }
    }
}

public struct ListLambdaFunctionsOutput: Swift.Equatable {
    /// The Lambdafunction ARNs associated with the specified instance.
    public var lambdaFunctions: [Swift.String]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        lambdaFunctions: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.lambdaFunctions = lambdaFunctions
        self.nextToken = nextToken
    }
}

struct ListLambdaFunctionsOutputBody: Swift.Equatable {
    let lambdaFunctions: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListLambdaFunctionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lambdaFunctions = "LambdaFunctions"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaFunctionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .lambdaFunctions)
        var lambdaFunctionsDecoded0:[Swift.String]? = nil
        if let lambdaFunctionsContainer = lambdaFunctionsContainer {
            lambdaFunctionsDecoded0 = [Swift.String]()
            for string0 in lambdaFunctionsContainer {
                if let string0 = string0 {
                    lambdaFunctionsDecoded0?.append(string0)
                }
            }
        }
        lambdaFunctions = lambdaFunctionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListLambdaFunctionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLexBotsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListLexBotsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/lex-bots"
    }
}

public struct ListLexBotsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page. If no value is specified, the default is 10.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLexBotsInputBody: Swift.Equatable {
}

extension ListLexBotsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListLexBotsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLexBotsOutputBody = try responseDecoder.decode(responseBody: data)
            self.lexBots = output.lexBots
            self.nextToken = output.nextToken
        } else {
            self.lexBots = nil
            self.nextToken = nil
        }
    }
}

public struct ListLexBotsOutput: Swift.Equatable {
    /// The names and Amazon Web Services Regions of the Amazon Lex bots associated with the specified instance.
    public var lexBots: [ConnectClientTypes.LexBot]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        lexBots: [ConnectClientTypes.LexBot]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.lexBots = lexBots
        self.nextToken = nextToken
    }
}

struct ListLexBotsOutputBody: Swift.Equatable {
    let lexBots: [ConnectClientTypes.LexBot]?
    let nextToken: Swift.String?
}

extension ListLexBotsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lexBots = "LexBots"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lexBotsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.LexBot?].self, forKey: .lexBots)
        var lexBotsDecoded0:[ConnectClientTypes.LexBot]? = nil
        if let lexBotsContainer = lexBotsContainer {
            lexBotsDecoded0 = [ConnectClientTypes.LexBot]()
            for structure0 in lexBotsContainer {
                if let structure0 = structure0 {
                    lexBotsDecoded0?.append(structure0)
                }
            }
        }
        lexBots = lexBotsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListLexBotsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPhoneNumbersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let phoneNumberTypes = phoneNumberTypes {
                phoneNumberTypes.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "phoneNumberTypes".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let phoneNumberCountryCodes = phoneNumberCountryCodes {
                phoneNumberCountryCodes.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "phoneNumberCountryCodes".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension ListPhoneNumbersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/phone-numbers-summary/\(instanceId.urlPercentEncoding())"
    }
}

public struct ListPhoneNumbersInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page. The default MaxResult size is 100.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ISO country code.
    public var phoneNumberCountryCodes: [ConnectClientTypes.PhoneNumberCountryCode]?
    /// The type of phone number. We recommend using [ListPhoneNumbersV2](https://docs.aws.amazon.com/connect/latest/APIReference/API_ListPhoneNumbersV2.html) to return phone number types. While ListPhoneNumbers returns number types UIFN, SHARED, THIRD_PARTY_TF, and THIRD_PARTY_DID, it incorrectly lists them as TOLL_FREE or DID.
    public var phoneNumberTypes: [ConnectClientTypes.PhoneNumberType]?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        phoneNumberCountryCodes: [ConnectClientTypes.PhoneNumberCountryCode]? = nil,
        phoneNumberTypes: [ConnectClientTypes.PhoneNumberType]? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.phoneNumberCountryCodes = phoneNumberCountryCodes
        self.phoneNumberTypes = phoneNumberTypes
    }
}

struct ListPhoneNumbersInputBody: Swift.Equatable {
}

extension ListPhoneNumbersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListPhoneNumbersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPhoneNumbersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.phoneNumberSummaryList = output.phoneNumberSummaryList
        } else {
            self.nextToken = nil
            self.phoneNumberSummaryList = nil
        }
    }
}

public struct ListPhoneNumbersOutput: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the phone numbers.
    public var phoneNumberSummaryList: [ConnectClientTypes.PhoneNumberSummary]?

    public init(
        nextToken: Swift.String? = nil,
        phoneNumberSummaryList: [ConnectClientTypes.PhoneNumberSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.phoneNumberSummaryList = phoneNumberSummaryList
    }
}

struct ListPhoneNumbersOutputBody: Swift.Equatable {
    let phoneNumberSummaryList: [ConnectClientTypes.PhoneNumberSummary]?
    let nextToken: Swift.String?
}

extension ListPhoneNumbersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case phoneNumberSummaryList = "PhoneNumberSummaryList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.PhoneNumberSummary?].self, forKey: .phoneNumberSummaryList)
        var phoneNumberSummaryListDecoded0:[ConnectClientTypes.PhoneNumberSummary]? = nil
        if let phoneNumberSummaryListContainer = phoneNumberSummaryListContainer {
            phoneNumberSummaryListDecoded0 = [ConnectClientTypes.PhoneNumberSummary]()
            for structure0 in phoneNumberSummaryListContainer {
                if let structure0 = structure0 {
                    phoneNumberSummaryListDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberSummaryList = phoneNumberSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPhoneNumbersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectClientTypes.ListPhoneNumbersSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case phoneNumber = "PhoneNumber"
        case phoneNumberArn = "PhoneNumberArn"
        case phoneNumberCountryCode = "PhoneNumberCountryCode"
        case phoneNumberDescription = "PhoneNumberDescription"
        case phoneNumberId = "PhoneNumberId"
        case phoneNumberType = "PhoneNumberType"
        case sourcePhoneNumberArn = "SourcePhoneNumberArn"
        case targetArn = "TargetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let phoneNumber = self.phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let phoneNumberArn = self.phoneNumberArn {
            try encodeContainer.encode(phoneNumberArn, forKey: .phoneNumberArn)
        }
        if let phoneNumberCountryCode = self.phoneNumberCountryCode {
            try encodeContainer.encode(phoneNumberCountryCode.rawValue, forKey: .phoneNumberCountryCode)
        }
        if let phoneNumberDescription = self.phoneNumberDescription {
            try encodeContainer.encode(phoneNumberDescription, forKey: .phoneNumberDescription)
        }
        if let phoneNumberId = self.phoneNumberId {
            try encodeContainer.encode(phoneNumberId, forKey: .phoneNumberId)
        }
        if let phoneNumberType = self.phoneNumberType {
            try encodeContainer.encode(phoneNumberType.rawValue, forKey: .phoneNumberType)
        }
        if let sourcePhoneNumberArn = self.sourcePhoneNumberArn {
            try encodeContainer.encode(sourcePhoneNumberArn, forKey: .sourcePhoneNumberArn)
        }
        if let targetArn = self.targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberId)
        phoneNumberId = phoneNumberIdDecoded
        let phoneNumberArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberArn)
        phoneNumberArn = phoneNumberArnDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let phoneNumberCountryCodeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.PhoneNumberCountryCode.self, forKey: .phoneNumberCountryCode)
        phoneNumberCountryCode = phoneNumberCountryCodeDecoded
        let phoneNumberTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.PhoneNumberType.self, forKey: .phoneNumberType)
        phoneNumberType = phoneNumberTypeDecoded
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let phoneNumberDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberDescription)
        phoneNumberDescription = phoneNumberDescriptionDecoded
        let sourcePhoneNumberArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourcePhoneNumberArn)
        sourcePhoneNumberArn = sourcePhoneNumberArnDecoded
    }
}

extension ConnectClientTypes {
    /// Information about phone numbers that have been claimed to your Amazon Connect instance or traffic distribution group.
    public struct ListPhoneNumbersSummary: Swift.Equatable {
        /// The identifier of the Amazon Connect instance that phone numbers are claimed to. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
        public var instanceId: Swift.String?
        /// The phone number. Phone numbers are formatted [+] [country code] [subscriber number including area code].
        public var phoneNumber: Swift.String?
        /// The Amazon Resource Name (ARN) of the phone number.
        public var phoneNumberArn: Swift.String?
        /// The ISO country code.
        public var phoneNumberCountryCode: ConnectClientTypes.PhoneNumberCountryCode?
        /// The description of the phone number.
        public var phoneNumberDescription: Swift.String?
        /// A unique identifier for the phone number.
        public var phoneNumberId: Swift.String?
        /// The type of phone number.
        public var phoneNumberType: ConnectClientTypes.PhoneNumberType?
        /// The claimed phone number ARN that was previously imported from the external service, such as Amazon Pinpoint. If it is from Amazon Pinpoint, it looks like the ARN of the phone number that was imported from Amazon Pinpoint.
        public var sourcePhoneNumberArn: Swift.String?
        /// The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone number inbound traffic is routed through.
        public var targetArn: Swift.String?

        public init(
            instanceId: Swift.String? = nil,
            phoneNumber: Swift.String? = nil,
            phoneNumberArn: Swift.String? = nil,
            phoneNumberCountryCode: ConnectClientTypes.PhoneNumberCountryCode? = nil,
            phoneNumberDescription: Swift.String? = nil,
            phoneNumberId: Swift.String? = nil,
            phoneNumberType: ConnectClientTypes.PhoneNumberType? = nil,
            sourcePhoneNumberArn: Swift.String? = nil,
            targetArn: Swift.String? = nil
        )
        {
            self.instanceId = instanceId
            self.phoneNumber = phoneNumber
            self.phoneNumberArn = phoneNumberArn
            self.phoneNumberCountryCode = phoneNumberCountryCode
            self.phoneNumberDescription = phoneNumberDescription
            self.phoneNumberId = phoneNumberId
            self.phoneNumberType = phoneNumberType
            self.sourcePhoneNumberArn = sourcePhoneNumberArn
            self.targetArn = targetArn
        }
    }

}

extension ListPhoneNumbersV2Input: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case phoneNumberCountryCodes = "PhoneNumberCountryCodes"
        case phoneNumberPrefix = "PhoneNumberPrefix"
        case phoneNumberTypes = "PhoneNumberTypes"
        case targetArn = "TargetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let phoneNumberCountryCodes = phoneNumberCountryCodes {
            var phoneNumberCountryCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phoneNumberCountryCodes)
            for phonenumbercountrycode0 in phoneNumberCountryCodes {
                try phoneNumberCountryCodesContainer.encode(phonenumbercountrycode0.rawValue)
            }
        }
        if let phoneNumberPrefix = self.phoneNumberPrefix {
            try encodeContainer.encode(phoneNumberPrefix, forKey: .phoneNumberPrefix)
        }
        if let phoneNumberTypes = phoneNumberTypes {
            var phoneNumberTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phoneNumberTypes)
            for phonenumbertype0 in phoneNumberTypes {
                try phoneNumberTypesContainer.encode(phonenumbertype0.rawValue)
            }
        }
        if let targetArn = self.targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }
}

extension ListPhoneNumbersV2Input: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/phone-number/list"
    }
}

public struct ListPhoneNumbersV2Input: Swift.Equatable {
    /// The identifier of the Amazon Connect instance that phone numbers are claimed to. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance. If both TargetArn and InstanceId are not provided, this API lists numbers claimed to all the Amazon Connect instances belonging to your account in the same AWS Region as the request.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ISO country code.
    public var phoneNumberCountryCodes: [ConnectClientTypes.PhoneNumberCountryCode]?
    /// The prefix of the phone number. If provided, it must contain + as part of the country code.
    public var phoneNumberPrefix: Swift.String?
    /// The type of phone number.
    public var phoneNumberTypes: [ConnectClientTypes.PhoneNumberType]?
    /// The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone number inbound traffic is routed through. If both TargetArn and InstanceId input are not provided, this API lists numbers claimed to all the Amazon Connect instances belonging to your account in the same Amazon Web Services Region as the request.
    public var targetArn: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        phoneNumberCountryCodes: [ConnectClientTypes.PhoneNumberCountryCode]? = nil,
        phoneNumberPrefix: Swift.String? = nil,
        phoneNumberTypes: [ConnectClientTypes.PhoneNumberType]? = nil,
        targetArn: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.phoneNumberCountryCodes = phoneNumberCountryCodes
        self.phoneNumberPrefix = phoneNumberPrefix
        self.phoneNumberTypes = phoneNumberTypes
        self.targetArn = targetArn
    }
}

struct ListPhoneNumbersV2InputBody: Swift.Equatable {
    let targetArn: Swift.String?
    let instanceId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let phoneNumberCountryCodes: [ConnectClientTypes.PhoneNumberCountryCode]?
    let phoneNumberTypes: [ConnectClientTypes.PhoneNumberType]?
    let phoneNumberPrefix: Swift.String?
}

extension ListPhoneNumbersV2InputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case phoneNumberCountryCodes = "PhoneNumberCountryCodes"
        case phoneNumberPrefix = "PhoneNumberPrefix"
        case phoneNumberTypes = "PhoneNumberTypes"
        case targetArn = "TargetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let phoneNumberCountryCodesContainer = try containerValues.decodeIfPresent([ConnectClientTypes.PhoneNumberCountryCode?].self, forKey: .phoneNumberCountryCodes)
        var phoneNumberCountryCodesDecoded0:[ConnectClientTypes.PhoneNumberCountryCode]? = nil
        if let phoneNumberCountryCodesContainer = phoneNumberCountryCodesContainer {
            phoneNumberCountryCodesDecoded0 = [ConnectClientTypes.PhoneNumberCountryCode]()
            for enum0 in phoneNumberCountryCodesContainer {
                if let enum0 = enum0 {
                    phoneNumberCountryCodesDecoded0?.append(enum0)
                }
            }
        }
        phoneNumberCountryCodes = phoneNumberCountryCodesDecoded0
        let phoneNumberTypesContainer = try containerValues.decodeIfPresent([ConnectClientTypes.PhoneNumberType?].self, forKey: .phoneNumberTypes)
        var phoneNumberTypesDecoded0:[ConnectClientTypes.PhoneNumberType]? = nil
        if let phoneNumberTypesContainer = phoneNumberTypesContainer {
            phoneNumberTypesDecoded0 = [ConnectClientTypes.PhoneNumberType]()
            for enum0 in phoneNumberTypesContainer {
                if let enum0 = enum0 {
                    phoneNumberTypesDecoded0?.append(enum0)
                }
            }
        }
        phoneNumberTypes = phoneNumberTypesDecoded0
        let phoneNumberPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberPrefix)
        phoneNumberPrefix = phoneNumberPrefixDecoded
    }
}

extension ListPhoneNumbersV2Output: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPhoneNumbersV2OutputBody = try responseDecoder.decode(responseBody: data)
            self.listPhoneNumbersSummaryList = output.listPhoneNumbersSummaryList
            self.nextToken = output.nextToken
        } else {
            self.listPhoneNumbersSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListPhoneNumbersV2Output: Swift.Equatable {
    /// Information about phone numbers that have been claimed to your Amazon Connect instances or traffic distribution groups.
    public var listPhoneNumbersSummaryList: [ConnectClientTypes.ListPhoneNumbersSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        listPhoneNumbersSummaryList: [ConnectClientTypes.ListPhoneNumbersSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.listPhoneNumbersSummaryList = listPhoneNumbersSummaryList
        self.nextToken = nextToken
    }
}

struct ListPhoneNumbersV2OutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let listPhoneNumbersSummaryList: [ConnectClientTypes.ListPhoneNumbersSummary]?
}

extension ListPhoneNumbersV2OutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listPhoneNumbersSummaryList = "ListPhoneNumbersSummaryList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let listPhoneNumbersSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.ListPhoneNumbersSummary?].self, forKey: .listPhoneNumbersSummaryList)
        var listPhoneNumbersSummaryListDecoded0:[ConnectClientTypes.ListPhoneNumbersSummary]? = nil
        if let listPhoneNumbersSummaryListContainer = listPhoneNumbersSummaryListContainer {
            listPhoneNumbersSummaryListDecoded0 = [ConnectClientTypes.ListPhoneNumbersSummary]()
            for structure0 in listPhoneNumbersSummaryListContainer {
                if let structure0 = structure0 {
                    listPhoneNumbersSummaryListDecoded0?.append(structure0)
                }
            }
        }
        listPhoneNumbersSummaryList = listPhoneNumbersSummaryListDecoded0
    }
}

enum ListPhoneNumbersV2OutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPromptsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListPromptsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/prompts-summary/\(instanceId.urlPercentEncoding())"
    }
}

public struct ListPromptsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page. The default MaxResult size is 100.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPromptsInputBody: Swift.Equatable {
}

extension ListPromptsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListPromptsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPromptsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.promptSummaryList = output.promptSummaryList
        } else {
            self.nextToken = nil
            self.promptSummaryList = nil
        }
    }
}

public struct ListPromptsOutput: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the prompts.
    public var promptSummaryList: [ConnectClientTypes.PromptSummary]?

    public init(
        nextToken: Swift.String? = nil,
        promptSummaryList: [ConnectClientTypes.PromptSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.promptSummaryList = promptSummaryList
    }
}

struct ListPromptsOutputBody: Swift.Equatable {
    let promptSummaryList: [ConnectClientTypes.PromptSummary]?
    let nextToken: Swift.String?
}

extension ListPromptsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case promptSummaryList = "PromptSummaryList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let promptSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.PromptSummary?].self, forKey: .promptSummaryList)
        var promptSummaryListDecoded0:[ConnectClientTypes.PromptSummary]? = nil
        if let promptSummaryListContainer = promptSummaryListContainer {
            promptSummaryListDecoded0 = [ConnectClientTypes.PromptSummary]()
            for structure0 in promptSummaryListContainer {
                if let structure0 = structure0 {
                    promptSummaryListDecoded0?.append(structure0)
                }
            }
        }
        promptSummaryList = promptSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPromptsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListQueueQuickConnectsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListQueueQuickConnectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let queueId = queueId else {
            return nil
        }
        return "/queues/\(instanceId.urlPercentEncoding())/\(queueId.urlPercentEncoding())/quick-connects"
    }
}

public struct ListQueueQuickConnectsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page. The default MaxResult size is 100.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The identifier for the queue.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queueId = queueId
    }
}

struct ListQueueQuickConnectsInputBody: Swift.Equatable {
}

extension ListQueueQuickConnectsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListQueueQuickConnectsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListQueueQuickConnectsOutputBody = try responseDecoder.decode(responseBody: data)
            self.lastModifiedRegion = output.lastModifiedRegion
            self.lastModifiedTime = output.lastModifiedTime
            self.nextToken = output.nextToken
            self.quickConnectSummaryList = output.quickConnectSummaryList
        } else {
            self.lastModifiedRegion = nil
            self.lastModifiedTime = nil
            self.nextToken = nil
            self.quickConnectSummaryList = nil
        }
    }
}

public struct ListQueueQuickConnectsOutput: Swift.Equatable {
    /// The Amazon Web Services Region where this resource was last modified.
    public var lastModifiedRegion: Swift.String?
    /// The timestamp when this resource was last modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the quick connects.
    public var quickConnectSummaryList: [ConnectClientTypes.QuickConnectSummary]?

    public init(
        lastModifiedRegion: Swift.String? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        nextToken: Swift.String? = nil,
        quickConnectSummaryList: [ConnectClientTypes.QuickConnectSummary]? = nil
    )
    {
        self.lastModifiedRegion = lastModifiedRegion
        self.lastModifiedTime = lastModifiedTime
        self.nextToken = nextToken
        self.quickConnectSummaryList = quickConnectSummaryList
    }
}

struct ListQueueQuickConnectsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let quickConnectSummaryList: [ConnectClientTypes.QuickConnectSummary]?
    let lastModifiedTime: ClientRuntime.Date?
    let lastModifiedRegion: Swift.String?
}

extension ListQueueQuickConnectsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastModifiedRegion = "LastModifiedRegion"
        case lastModifiedTime = "LastModifiedTime"
        case nextToken = "NextToken"
        case quickConnectSummaryList = "QuickConnectSummaryList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let quickConnectSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.QuickConnectSummary?].self, forKey: .quickConnectSummaryList)
        var quickConnectSummaryListDecoded0:[ConnectClientTypes.QuickConnectSummary]? = nil
        if let quickConnectSummaryListContainer = quickConnectSummaryListContainer {
            quickConnectSummaryListDecoded0 = [ConnectClientTypes.QuickConnectSummary]()
            for structure0 in quickConnectSummaryListContainer {
                if let structure0 = structure0 {
                    quickConnectSummaryListDecoded0?.append(structure0)
                }
            }
        }
        quickConnectSummaryList = quickConnectSummaryListDecoded0
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastModifiedRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedRegion)
        lastModifiedRegion = lastModifiedRegionDecoded
    }
}

enum ListQueueQuickConnectsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListQueuesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let queueTypes = queueTypes {
                queueTypes.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "queueTypes".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension ListQueuesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/queues-summary/\(instanceId.urlPercentEncoding())"
    }
}

public struct ListQueuesInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page. The default MaxResult size is 100.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The type of queue.
    public var queueTypes: [ConnectClientTypes.QueueType]?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queueTypes: [ConnectClientTypes.QueueType]? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queueTypes = queueTypes
    }
}

struct ListQueuesInputBody: Swift.Equatable {
}

extension ListQueuesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListQueuesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListQueuesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.queueSummaryList = output.queueSummaryList
        } else {
            self.nextToken = nil
            self.queueSummaryList = nil
        }
    }
}

public struct ListQueuesOutput: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the queues.
    public var queueSummaryList: [ConnectClientTypes.QueueSummary]?

    public init(
        nextToken: Swift.String? = nil,
        queueSummaryList: [ConnectClientTypes.QueueSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.queueSummaryList = queueSummaryList
    }
}

struct ListQueuesOutputBody: Swift.Equatable {
    let queueSummaryList: [ConnectClientTypes.QueueSummary]?
    let nextToken: Swift.String?
}

extension ListQueuesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case queueSummaryList = "QueueSummaryList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.QueueSummary?].self, forKey: .queueSummaryList)
        var queueSummaryListDecoded0:[ConnectClientTypes.QueueSummary]? = nil
        if let queueSummaryListContainer = queueSummaryListContainer {
            queueSummaryListDecoded0 = [ConnectClientTypes.QueueSummary]()
            for structure0 in queueSummaryListContainer {
                if let structure0 = structure0 {
                    queueSummaryListDecoded0?.append(structure0)
                }
            }
        }
        queueSummaryList = queueSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListQueuesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListQuickConnectsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let quickConnectTypes = quickConnectTypes {
                quickConnectTypes.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "QuickConnectTypes".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListQuickConnectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/quick-connects/\(instanceId.urlPercentEncoding())"
    }
}

public struct ListQuickConnectsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page. The default MaxResult size is 100.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The type of quick connect. In the Amazon Connect admin website, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE).
    public var quickConnectTypes: [ConnectClientTypes.QuickConnectType]?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        quickConnectTypes: [ConnectClientTypes.QuickConnectType]? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.quickConnectTypes = quickConnectTypes
    }
}

struct ListQuickConnectsInputBody: Swift.Equatable {
}

extension ListQuickConnectsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListQuickConnectsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListQuickConnectsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.quickConnectSummaryList = output.quickConnectSummaryList
        } else {
            self.nextToken = nil
            self.quickConnectSummaryList = nil
        }
    }
}

public struct ListQuickConnectsOutput: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the quick connects.
    public var quickConnectSummaryList: [ConnectClientTypes.QuickConnectSummary]?

    public init(
        nextToken: Swift.String? = nil,
        quickConnectSummaryList: [ConnectClientTypes.QuickConnectSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.quickConnectSummaryList = quickConnectSummaryList
    }
}

struct ListQuickConnectsOutputBody: Swift.Equatable {
    let quickConnectSummaryList: [ConnectClientTypes.QuickConnectSummary]?
    let nextToken: Swift.String?
}

extension ListQuickConnectsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case quickConnectSummaryList = "QuickConnectSummaryList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quickConnectSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.QuickConnectSummary?].self, forKey: .quickConnectSummaryList)
        var quickConnectSummaryListDecoded0:[ConnectClientTypes.QuickConnectSummary]? = nil
        if let quickConnectSummaryListContainer = quickConnectSummaryListContainer {
            quickConnectSummaryListDecoded0 = [ConnectClientTypes.QuickConnectSummary]()
            for structure0 in quickConnectSummaryListContainer {
                if let structure0 = structure0 {
                    quickConnectSummaryListDecoded0?.append(structure0)
                }
            }
        }
        quickConnectSummaryList = quickConnectSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListQuickConnectsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRealtimeContactAnalysisSegmentsV2Input: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case outputType = "OutputType"
        case segmentTypes = "SegmentTypes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let outputType = self.outputType {
            try encodeContainer.encode(outputType.rawValue, forKey: .outputType)
        }
        if let segmentTypes = segmentTypes {
            var segmentTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .segmentTypes)
            for realtimecontactanalysissegmenttype0 in segmentTypes {
                try segmentTypesContainer.encode(realtimecontactanalysissegmenttype0.rawValue)
            }
        }
    }
}

extension ListRealtimeContactAnalysisSegmentsV2Input: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let contactId = contactId else {
            return nil
        }
        return "/contact/list-real-time-analysis-segments-v2/\(instanceId.urlPercentEncoding())/\(contactId.urlPercentEncoding())"
    }
}

public struct ListRealtimeContactAnalysisSegmentsV2Input: Swift.Equatable {
    /// The identifier of the contact in this instance of Amazon Connect.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The Contact Lens output type to be returned.
    /// This member is required.
    public var outputType: ConnectClientTypes.RealTimeContactAnalysisOutputType?
    /// Enum with segment types . Each value corresponds to a segment type returned in the segments list of the API. Each segment type has its own structure. Different channels may have different sets of supported segment types.
    /// This member is required.
    public var segmentTypes: [ConnectClientTypes.RealTimeContactAnalysisSegmentType]?

    public init(
        contactId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        outputType: ConnectClientTypes.RealTimeContactAnalysisOutputType? = nil,
        segmentTypes: [ConnectClientTypes.RealTimeContactAnalysisSegmentType]? = nil
    )
    {
        self.contactId = contactId
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.outputType = outputType
        self.segmentTypes = segmentTypes
    }
}

struct ListRealtimeContactAnalysisSegmentsV2InputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let outputType: ConnectClientTypes.RealTimeContactAnalysisOutputType?
    let segmentTypes: [ConnectClientTypes.RealTimeContactAnalysisSegmentType]?
}

extension ListRealtimeContactAnalysisSegmentsV2InputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case outputType = "OutputType"
        case segmentTypes = "SegmentTypes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let outputTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.RealTimeContactAnalysisOutputType.self, forKey: .outputType)
        outputType = outputTypeDecoded
        let segmentTypesContainer = try containerValues.decodeIfPresent([ConnectClientTypes.RealTimeContactAnalysisSegmentType?].self, forKey: .segmentTypes)
        var segmentTypesDecoded0:[ConnectClientTypes.RealTimeContactAnalysisSegmentType]? = nil
        if let segmentTypesContainer = segmentTypesContainer {
            segmentTypesDecoded0 = [ConnectClientTypes.RealTimeContactAnalysisSegmentType]()
            for enum0 in segmentTypesContainer {
                if let enum0 = enum0 {
                    segmentTypesDecoded0?.append(enum0)
                }
            }
        }
        segmentTypes = segmentTypesDecoded0
    }
}

extension ListRealtimeContactAnalysisSegmentsV2Output: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRealtimeContactAnalysisSegmentsV2OutputBody = try responseDecoder.decode(responseBody: data)
            self.channel = output.channel
            self.nextToken = output.nextToken
            self.segments = output.segments
            self.status = output.status
        } else {
            self.channel = nil
            self.nextToken = nil
            self.segments = nil
            self.status = nil
        }
    }
}

public struct ListRealtimeContactAnalysisSegmentsV2Output: Swift.Equatable {
    /// The channel of the contact. Voice will not be returned.
    /// This member is required.
    public var channel: ConnectClientTypes.RealTimeContactAnalysisSupportedChannel?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// An analyzed transcript or category.
    /// This member is required.
    public var segments: [ConnectClientTypes.RealtimeContactAnalysisSegment]?
    /// Status of real-time contact analysis.
    /// This member is required.
    public var status: ConnectClientTypes.RealTimeContactAnalysisStatus?

    public init(
        channel: ConnectClientTypes.RealTimeContactAnalysisSupportedChannel? = nil,
        nextToken: Swift.String? = nil,
        segments: [ConnectClientTypes.RealtimeContactAnalysisSegment]? = nil,
        status: ConnectClientTypes.RealTimeContactAnalysisStatus? = nil
    )
    {
        self.channel = channel
        self.nextToken = nextToken
        self.segments = segments
        self.status = status
    }
}

struct ListRealtimeContactAnalysisSegmentsV2OutputBody: Swift.Equatable {
    let channel: ConnectClientTypes.RealTimeContactAnalysisSupportedChannel?
    let status: ConnectClientTypes.RealTimeContactAnalysisStatus?
    let segments: [ConnectClientTypes.RealtimeContactAnalysisSegment]?
    let nextToken: Swift.String?
}

extension ListRealtimeContactAnalysisSegmentsV2OutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel = "Channel"
        case nextToken = "NextToken"
        case segments = "Segments"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.RealTimeContactAnalysisSupportedChannel.self, forKey: .channel)
        channel = channelDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.RealTimeContactAnalysisStatus.self, forKey: .status)
        status = statusDecoded
        let segmentsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.RealtimeContactAnalysisSegment?].self, forKey: .segments)
        var segmentsDecoded0:[ConnectClientTypes.RealtimeContactAnalysisSegment]? = nil
        if let segmentsContainer = segmentsContainer {
            segmentsDecoded0 = [ConnectClientTypes.RealtimeContactAnalysisSegment]()
            for union0 in segmentsContainer {
                if let union0 = union0 {
                    segmentsDecoded0?.append(union0)
                }
            }
        }
        segments = segmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRealtimeContactAnalysisSegmentsV2OutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OutputTypeNotFoundException": return try await OutputTypeNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRoutingProfileQueuesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListRoutingProfileQueuesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let routingProfileId = routingProfileId else {
            return nil
        }
        return "/routing-profiles/\(instanceId.urlPercentEncoding())/\(routingProfileId.urlPercentEncoding())/queues"
    }
}

public struct ListRoutingProfileQueuesInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page. The default MaxResult size is 100.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The identifier of the routing profile.
    /// This member is required.
    public var routingProfileId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        routingProfileId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.routingProfileId = routingProfileId
    }
}

struct ListRoutingProfileQueuesInputBody: Swift.Equatable {
}

extension ListRoutingProfileQueuesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListRoutingProfileQueuesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRoutingProfileQueuesOutputBody = try responseDecoder.decode(responseBody: data)
            self.lastModifiedRegion = output.lastModifiedRegion
            self.lastModifiedTime = output.lastModifiedTime
            self.nextToken = output.nextToken
            self.routingProfileQueueConfigSummaryList = output.routingProfileQueueConfigSummaryList
        } else {
            self.lastModifiedRegion = nil
            self.lastModifiedTime = nil
            self.nextToken = nil
            self.routingProfileQueueConfigSummaryList = nil
        }
    }
}

public struct ListRoutingProfileQueuesOutput: Swift.Equatable {
    /// The Amazon Web Services Region where this resource was last modified.
    public var lastModifiedRegion: Swift.String?
    /// The timestamp when this resource was last modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the routing profiles.
    public var routingProfileQueueConfigSummaryList: [ConnectClientTypes.RoutingProfileQueueConfigSummary]?

    public init(
        lastModifiedRegion: Swift.String? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        nextToken: Swift.String? = nil,
        routingProfileQueueConfigSummaryList: [ConnectClientTypes.RoutingProfileQueueConfigSummary]? = nil
    )
    {
        self.lastModifiedRegion = lastModifiedRegion
        self.lastModifiedTime = lastModifiedTime
        self.nextToken = nextToken
        self.routingProfileQueueConfigSummaryList = routingProfileQueueConfigSummaryList
    }
}

struct ListRoutingProfileQueuesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let routingProfileQueueConfigSummaryList: [ConnectClientTypes.RoutingProfileQueueConfigSummary]?
    let lastModifiedTime: ClientRuntime.Date?
    let lastModifiedRegion: Swift.String?
}

extension ListRoutingProfileQueuesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastModifiedRegion = "LastModifiedRegion"
        case lastModifiedTime = "LastModifiedTime"
        case nextToken = "NextToken"
        case routingProfileQueueConfigSummaryList = "RoutingProfileQueueConfigSummaryList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let routingProfileQueueConfigSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.RoutingProfileQueueConfigSummary?].self, forKey: .routingProfileQueueConfigSummaryList)
        var routingProfileQueueConfigSummaryListDecoded0:[ConnectClientTypes.RoutingProfileQueueConfigSummary]? = nil
        if let routingProfileQueueConfigSummaryListContainer = routingProfileQueueConfigSummaryListContainer {
            routingProfileQueueConfigSummaryListDecoded0 = [ConnectClientTypes.RoutingProfileQueueConfigSummary]()
            for structure0 in routingProfileQueueConfigSummaryListContainer {
                if let structure0 = structure0 {
                    routingProfileQueueConfigSummaryListDecoded0?.append(structure0)
                }
            }
        }
        routingProfileQueueConfigSummaryList = routingProfileQueueConfigSummaryListDecoded0
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastModifiedRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedRegion)
        lastModifiedRegion = lastModifiedRegionDecoded
    }
}

enum ListRoutingProfileQueuesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRoutingProfilesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListRoutingProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/routing-profiles-summary/\(instanceId.urlPercentEncoding())"
    }
}

public struct ListRoutingProfilesInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page. The default MaxResult size is 100.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRoutingProfilesInputBody: Swift.Equatable {
}

extension ListRoutingProfilesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListRoutingProfilesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRoutingProfilesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.routingProfileSummaryList = output.routingProfileSummaryList
        } else {
            self.nextToken = nil
            self.routingProfileSummaryList = nil
        }
    }
}

public struct ListRoutingProfilesOutput: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the routing profiles.
    public var routingProfileSummaryList: [ConnectClientTypes.RoutingProfileSummary]?

    public init(
        nextToken: Swift.String? = nil,
        routingProfileSummaryList: [ConnectClientTypes.RoutingProfileSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.routingProfileSummaryList = routingProfileSummaryList
    }
}

struct ListRoutingProfilesOutputBody: Swift.Equatable {
    let routingProfileSummaryList: [ConnectClientTypes.RoutingProfileSummary]?
    let nextToken: Swift.String?
}

extension ListRoutingProfilesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case routingProfileSummaryList = "RoutingProfileSummaryList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routingProfileSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.RoutingProfileSummary?].self, forKey: .routingProfileSummaryList)
        var routingProfileSummaryListDecoded0:[ConnectClientTypes.RoutingProfileSummary]? = nil
        if let routingProfileSummaryListContainer = routingProfileSummaryListContainer {
            routingProfileSummaryListDecoded0 = [ConnectClientTypes.RoutingProfileSummary]()
            for structure0 in routingProfileSummaryListContainer {
                if let structure0 = structure0 {
                    routingProfileSummaryListDecoded0?.append(structure0)
                }
            }
        }
        routingProfileSummaryList = routingProfileSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRoutingProfilesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRulesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let eventSourceName = eventSourceName {
                let eventSourceNameQueryItem = ClientRuntime.URLQueryItem(name: "eventSourceName".urlPercentEncoding(), value: Swift.String(eventSourceName.rawValue).urlPercentEncoding())
                items.append(eventSourceNameQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let publishStatus = publishStatus {
                let publishStatusQueryItem = ClientRuntime.URLQueryItem(name: "publishStatus".urlPercentEncoding(), value: Swift.String(publishStatus.rawValue).urlPercentEncoding())
                items.append(publishStatusQueryItem)
            }
            return items
        }
    }
}

extension ListRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/rules/\(instanceId.urlPercentEncoding())"
    }
}

public struct ListRulesInput: Swift.Equatable {
    /// The name of the event source.
    public var eventSourceName: ConnectClientTypes.EventSourceName?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The publish status of the rule.
    public var publishStatus: ConnectClientTypes.RulePublishStatus?

    public init(
        eventSourceName: ConnectClientTypes.EventSourceName? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        publishStatus: ConnectClientTypes.RulePublishStatus? = nil
    )
    {
        self.eventSourceName = eventSourceName
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.publishStatus = publishStatus
    }
}

struct ListRulesInputBody: Swift.Equatable {
}

extension ListRulesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListRulesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRulesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.ruleSummaryList = output.ruleSummaryList
        } else {
            self.nextToken = nil
            self.ruleSummaryList = nil
        }
    }
}

public struct ListRulesOutput: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Summary information about a rule.
    /// This member is required.
    public var ruleSummaryList: [ConnectClientTypes.RuleSummary]?

    public init(
        nextToken: Swift.String? = nil,
        ruleSummaryList: [ConnectClientTypes.RuleSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.ruleSummaryList = ruleSummaryList
    }
}

struct ListRulesOutputBody: Swift.Equatable {
    let ruleSummaryList: [ConnectClientTypes.RuleSummary]?
    let nextToken: Swift.String?
}

extension ListRulesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case ruleSummaryList = "RuleSummaryList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.RuleSummary?].self, forKey: .ruleSummaryList)
        var ruleSummaryListDecoded0:[ConnectClientTypes.RuleSummary]? = nil
        if let ruleSummaryListContainer = ruleSummaryListContainer {
            ruleSummaryListDecoded0 = [ConnectClientTypes.RuleSummary]()
            for structure0 in ruleSummaryListContainer {
                if let structure0 = structure0 {
                    ruleSummaryListDecoded0?.append(structure0)
                }
            }
        }
        ruleSummaryList = ruleSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRulesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSecurityKeysInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListSecurityKeysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/security-keys"
    }
}

public struct ListSecurityKeysInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSecurityKeysInputBody: Swift.Equatable {
}

extension ListSecurityKeysInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSecurityKeysOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSecurityKeysOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.securityKeys = output.securityKeys
        } else {
            self.nextToken = nil
            self.securityKeys = nil
        }
    }
}

public struct ListSecurityKeysOutput: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// The security keys.
    public var securityKeys: [ConnectClientTypes.SecurityKey]?

    public init(
        nextToken: Swift.String? = nil,
        securityKeys: [ConnectClientTypes.SecurityKey]? = nil
    )
    {
        self.nextToken = nextToken
        self.securityKeys = securityKeys
    }
}

struct ListSecurityKeysOutputBody: Swift.Equatable {
    let securityKeys: [ConnectClientTypes.SecurityKey]?
    let nextToken: Swift.String?
}

extension ListSecurityKeysOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case securityKeys = "SecurityKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityKeysContainer = try containerValues.decodeIfPresent([ConnectClientTypes.SecurityKey?].self, forKey: .securityKeys)
        var securityKeysDecoded0:[ConnectClientTypes.SecurityKey]? = nil
        if let securityKeysContainer = securityKeysContainer {
            securityKeysDecoded0 = [ConnectClientTypes.SecurityKey]()
            for structure0 in securityKeysContainer {
                if let structure0 = structure0 {
                    securityKeysDecoded0?.append(structure0)
                }
            }
        }
        securityKeys = securityKeysDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSecurityKeysOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSecurityProfileApplicationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListSecurityProfileApplicationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let securityProfileId = securityProfileId else {
            return nil
        }
        return "/security-profiles-applications/\(instanceId.urlPercentEncoding())/\(securityProfileId.urlPercentEncoding())"
    }
}

public struct ListSecurityProfileApplicationsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The identifier for the security profle.
    /// This member is required.
    public var securityProfileId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        securityProfileId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.securityProfileId = securityProfileId
    }
}

struct ListSecurityProfileApplicationsInputBody: Swift.Equatable {
}

extension ListSecurityProfileApplicationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSecurityProfileApplicationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSecurityProfileApplicationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.applications = output.applications
            self.lastModifiedRegion = output.lastModifiedRegion
            self.lastModifiedTime = output.lastModifiedTime
            self.nextToken = output.nextToken
        } else {
            self.applications = nil
            self.lastModifiedRegion = nil
            self.lastModifiedTime = nil
            self.nextToken = nil
        }
    }
}

public struct ListSecurityProfileApplicationsOutput: Swift.Equatable {
    /// This API is in preview release for Amazon Connect and is subject to change. A list of the third-party application's metadata.
    public var applications: [ConnectClientTypes.Application]?
    /// The Amazon Web Services Region where this resource was last modified.
    public var lastModifiedRegion: Swift.String?
    /// The timestamp when this resource was last modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        applications: [ConnectClientTypes.Application]? = nil,
        lastModifiedRegion: Swift.String? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applications = applications
        self.lastModifiedRegion = lastModifiedRegion
        self.lastModifiedTime = lastModifiedTime
        self.nextToken = nextToken
    }
}

struct ListSecurityProfileApplicationsOutputBody: Swift.Equatable {
    let applications: [ConnectClientTypes.Application]?
    let nextToken: Swift.String?
    let lastModifiedTime: ClientRuntime.Date?
    let lastModifiedRegion: Swift.String?
}

extension ListSecurityProfileApplicationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applications = "Applications"
        case lastModifiedRegion = "LastModifiedRegion"
        case lastModifiedTime = "LastModifiedTime"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.Application?].self, forKey: .applications)
        var applicationsDecoded0:[ConnectClientTypes.Application]? = nil
        if let applicationsContainer = applicationsContainer {
            applicationsDecoded0 = [ConnectClientTypes.Application]()
            for structure0 in applicationsContainer {
                if let structure0 = structure0 {
                    applicationsDecoded0?.append(structure0)
                }
            }
        }
        applications = applicationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastModifiedRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedRegion)
        lastModifiedRegion = lastModifiedRegionDecoded
    }
}

enum ListSecurityProfileApplicationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSecurityProfilePermissionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListSecurityProfilePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let securityProfileId = securityProfileId else {
            return nil
        }
        return "/security-profiles-permissions/\(instanceId.urlPercentEncoding())/\(securityProfileId.urlPercentEncoding())"
    }
}

public struct ListSecurityProfilePermissionsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The identifier for the security profle.
    /// This member is required.
    public var securityProfileId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        securityProfileId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.securityProfileId = securityProfileId
    }
}

struct ListSecurityProfilePermissionsInputBody: Swift.Equatable {
}

extension ListSecurityProfilePermissionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSecurityProfilePermissionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSecurityProfilePermissionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.lastModifiedRegion = output.lastModifiedRegion
            self.lastModifiedTime = output.lastModifiedTime
            self.nextToken = output.nextToken
            self.permissions = output.permissions
        } else {
            self.lastModifiedRegion = nil
            self.lastModifiedTime = nil
            self.nextToken = nil
            self.permissions = nil
        }
    }
}

public struct ListSecurityProfilePermissionsOutput: Swift.Equatable {
    /// The Amazon Web Services Region where this resource was last modified.
    public var lastModifiedRegion: Swift.String?
    /// The timestamp when this resource was last modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// The permissions granted to the security profile. For a complete list of valid permissions, see [List of security profile permissions](https://docs.aws.amazon.com/connect/latest/adminguide/security-profile-list.html).
    public var permissions: [Swift.String]?

    public init(
        lastModifiedRegion: Swift.String? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        nextToken: Swift.String? = nil,
        permissions: [Swift.String]? = nil
    )
    {
        self.lastModifiedRegion = lastModifiedRegion
        self.lastModifiedTime = lastModifiedTime
        self.nextToken = nextToken
        self.permissions = permissions
    }
}

struct ListSecurityProfilePermissionsOutputBody: Swift.Equatable {
    let permissions: [Swift.String]?
    let nextToken: Swift.String?
    let lastModifiedTime: ClientRuntime.Date?
    let lastModifiedRegion: Swift.String?
}

extension ListSecurityProfilePermissionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastModifiedRegion = "LastModifiedRegion"
        case lastModifiedTime = "LastModifiedTime"
        case nextToken = "NextToken"
        case permissions = "Permissions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .permissions)
        var permissionsDecoded0:[Swift.String]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [Swift.String]()
            for string0 in permissionsContainer {
                if let string0 = string0 {
                    permissionsDecoded0?.append(string0)
                }
            }
        }
        permissions = permissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastModifiedRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedRegion)
        lastModifiedRegion = lastModifiedRegionDecoded
    }
}

enum ListSecurityProfilePermissionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSecurityProfilesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListSecurityProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/security-profiles-summary/\(instanceId.urlPercentEncoding())"
    }
}

public struct ListSecurityProfilesInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page. The default MaxResult size is 100.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSecurityProfilesInputBody: Swift.Equatable {
}

extension ListSecurityProfilesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSecurityProfilesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSecurityProfilesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.securityProfileSummaryList = output.securityProfileSummaryList
        } else {
            self.nextToken = nil
            self.securityProfileSummaryList = nil
        }
    }
}

public struct ListSecurityProfilesOutput: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the security profiles.
    public var securityProfileSummaryList: [ConnectClientTypes.SecurityProfileSummary]?

    public init(
        nextToken: Swift.String? = nil,
        securityProfileSummaryList: [ConnectClientTypes.SecurityProfileSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.securityProfileSummaryList = securityProfileSummaryList
    }
}

struct ListSecurityProfilesOutputBody: Swift.Equatable {
    let securityProfileSummaryList: [ConnectClientTypes.SecurityProfileSummary]?
    let nextToken: Swift.String?
}

extension ListSecurityProfilesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case securityProfileSummaryList = "SecurityProfileSummaryList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityProfileSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.SecurityProfileSummary?].self, forKey: .securityProfileSummaryList)
        var securityProfileSummaryListDecoded0:[ConnectClientTypes.SecurityProfileSummary]? = nil
        if let securityProfileSummaryListContainer = securityProfileSummaryListContainer {
            securityProfileSummaryListDecoded0 = [ConnectClientTypes.SecurityProfileSummary]()
            for structure0 in securityProfileSummaryListContainer {
                if let structure0 = structure0 {
                    securityProfileSummaryListDecoded0?.append(structure0)
                }
            }
        }
        securityProfileSummaryList = securityProfileSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSecurityProfilesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource. All Amazon Connect resources (instances, queues, flows, routing profiles, etc) have an ARN. To locate the ARN for an instance, for example, see [Find your Amazon Connect instance ID/ARN](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html).
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// Information about the tags.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTaskTemplatesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let name = name {
                let nameQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
                items.append(nameQueryItem)
            }
            return items
        }
    }
}

extension ListTaskTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/task/template"
    }
}

public struct ListTaskTemplatesInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page. It is not expected that you set this.
    public var maxResults: Swift.Int?
    /// The name of the task template.
    public var name: Swift.String?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. It is not expected that you set this because the value returned in the previous response is always null.
    public var nextToken: Swift.String?
    /// Marks a template as ACTIVE or INACTIVE for a task to refer to it. Tasks can only be created from ACTIVE templates. If a template is marked as INACTIVE, then a task that refers to this template cannot be created.
    public var status: ConnectClientTypes.TaskTemplateStatus?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        status: ConnectClientTypes.TaskTemplateStatus? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.status = status
    }
}

struct ListTaskTemplatesInputBody: Swift.Equatable {
}

extension ListTaskTemplatesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTaskTemplatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTaskTemplatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.taskTemplates = output.taskTemplates
        } else {
            self.nextToken = nil
            self.taskTemplates = nil
        }
    }
}

public struct ListTaskTemplatesOutput: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results. This is always returned as a null in the response.
    public var nextToken: Swift.String?
    /// Provides details about a list of task templates belonging to an instance.
    public var taskTemplates: [ConnectClientTypes.TaskTemplateMetadata]?

    public init(
        nextToken: Swift.String? = nil,
        taskTemplates: [ConnectClientTypes.TaskTemplateMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.taskTemplates = taskTemplates
    }
}

struct ListTaskTemplatesOutputBody: Swift.Equatable {
    let taskTemplates: [ConnectClientTypes.TaskTemplateMetadata]?
    let nextToken: Swift.String?
}

extension ListTaskTemplatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case taskTemplates = "TaskTemplates"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskTemplatesContainer = try containerValues.decodeIfPresent([ConnectClientTypes.TaskTemplateMetadata?].self, forKey: .taskTemplates)
        var taskTemplatesDecoded0:[ConnectClientTypes.TaskTemplateMetadata]? = nil
        if let taskTemplatesContainer = taskTemplatesContainer {
            taskTemplatesDecoded0 = [ConnectClientTypes.TaskTemplateMetadata]()
            for structure0 in taskTemplatesContainer {
                if let structure0 = structure0 {
                    taskTemplatesDecoded0?.append(structure0)
                }
            }
        }
        taskTemplates = taskTemplatesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTaskTemplatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTrafficDistributionGroupUsersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListTrafficDistributionGroupUsersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trafficDistributionGroupId = trafficDistributionGroupId else {
            return nil
        }
        return "/traffic-distribution-group/\(trafficDistributionGroupId.urlPercentEncoding())/user"
    }
}

public struct ListTrafficDistributionGroupUsersInput: Swift.Equatable {
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.
    /// This member is required.
    public var trafficDistributionGroupId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        trafficDistributionGroupId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.trafficDistributionGroupId = trafficDistributionGroupId
    }
}

struct ListTrafficDistributionGroupUsersInputBody: Swift.Equatable {
}

extension ListTrafficDistributionGroupUsersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTrafficDistributionGroupUsersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTrafficDistributionGroupUsersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.trafficDistributionGroupUserSummaryList = output.trafficDistributionGroupUserSummaryList
        } else {
            self.nextToken = nil
            self.trafficDistributionGroupUserSummaryList = nil
        }
    }
}

public struct ListTrafficDistributionGroupUsersOutput: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// A list of traffic distribution group users.
    public var trafficDistributionGroupUserSummaryList: [ConnectClientTypes.TrafficDistributionGroupUserSummary]?

    public init(
        nextToken: Swift.String? = nil,
        trafficDistributionGroupUserSummaryList: [ConnectClientTypes.TrafficDistributionGroupUserSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.trafficDistributionGroupUserSummaryList = trafficDistributionGroupUserSummaryList
    }
}

struct ListTrafficDistributionGroupUsersOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let trafficDistributionGroupUserSummaryList: [ConnectClientTypes.TrafficDistributionGroupUserSummary]?
}

extension ListTrafficDistributionGroupUsersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case trafficDistributionGroupUserSummaryList = "TrafficDistributionGroupUserSummaryList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let trafficDistributionGroupUserSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.TrafficDistributionGroupUserSummary?].self, forKey: .trafficDistributionGroupUserSummaryList)
        var trafficDistributionGroupUserSummaryListDecoded0:[ConnectClientTypes.TrafficDistributionGroupUserSummary]? = nil
        if let trafficDistributionGroupUserSummaryListContainer = trafficDistributionGroupUserSummaryListContainer {
            trafficDistributionGroupUserSummaryListDecoded0 = [ConnectClientTypes.TrafficDistributionGroupUserSummary]()
            for structure0 in trafficDistributionGroupUserSummaryListContainer {
                if let structure0 = structure0 {
                    trafficDistributionGroupUserSummaryListDecoded0?.append(structure0)
                }
            }
        }
        trafficDistributionGroupUserSummaryList = trafficDistributionGroupUserSummaryListDecoded0
    }
}

enum ListTrafficDistributionGroupUsersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTrafficDistributionGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let instanceId = instanceId {
                let instanceIdQueryItem = ClientRuntime.URLQueryItem(name: "instanceId".urlPercentEncoding(), value: Swift.String(instanceId).urlPercentEncoding())
                items.append(instanceIdQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListTrafficDistributionGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/traffic-distribution-groups"
    }
}

public struct ListTrafficDistributionGroupsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTrafficDistributionGroupsInputBody: Swift.Equatable {
}

extension ListTrafficDistributionGroupsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTrafficDistributionGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTrafficDistributionGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.trafficDistributionGroupSummaryList = output.trafficDistributionGroupSummaryList
        } else {
            self.nextToken = nil
            self.trafficDistributionGroupSummaryList = nil
        }
    }
}

public struct ListTrafficDistributionGroupsOutput: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// A list of traffic distribution groups.
    public var trafficDistributionGroupSummaryList: [ConnectClientTypes.TrafficDistributionGroupSummary]?

    public init(
        nextToken: Swift.String? = nil,
        trafficDistributionGroupSummaryList: [ConnectClientTypes.TrafficDistributionGroupSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.trafficDistributionGroupSummaryList = trafficDistributionGroupSummaryList
    }
}

struct ListTrafficDistributionGroupsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let trafficDistributionGroupSummaryList: [ConnectClientTypes.TrafficDistributionGroupSummary]?
}

extension ListTrafficDistributionGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case trafficDistributionGroupSummaryList = "TrafficDistributionGroupSummaryList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let trafficDistributionGroupSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.TrafficDistributionGroupSummary?].self, forKey: .trafficDistributionGroupSummaryList)
        var trafficDistributionGroupSummaryListDecoded0:[ConnectClientTypes.TrafficDistributionGroupSummary]? = nil
        if let trafficDistributionGroupSummaryListContainer = trafficDistributionGroupSummaryListContainer {
            trafficDistributionGroupSummaryListDecoded0 = [ConnectClientTypes.TrafficDistributionGroupSummary]()
            for structure0 in trafficDistributionGroupSummaryListContainer {
                if let structure0 = structure0 {
                    trafficDistributionGroupSummaryListDecoded0?.append(structure0)
                }
            }
        }
        trafficDistributionGroupSummaryList = trafficDistributionGroupSummaryListDecoded0
    }
}

enum ListTrafficDistributionGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListUseCasesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListUseCasesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let integrationAssociationId = integrationAssociationId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/integration-associations/\(integrationAssociationId.urlPercentEncoding())/use-cases"
    }
}

/// Provides summary information about the use cases for the specified integration association.
public struct ListUseCasesInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the integration association.
    /// This member is required.
    public var integrationAssociationId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        integrationAssociationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.integrationAssociationId = integrationAssociationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListUseCasesInputBody: Swift.Equatable {
}

extension ListUseCasesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListUseCasesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListUseCasesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.useCaseSummaryList = output.useCaseSummaryList
        } else {
            self.nextToken = nil
            self.useCaseSummaryList = nil
        }
    }
}

public struct ListUseCasesOutput: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// The use cases.
    public var useCaseSummaryList: [ConnectClientTypes.UseCase]?

    public init(
        nextToken: Swift.String? = nil,
        useCaseSummaryList: [ConnectClientTypes.UseCase]? = nil
    )
    {
        self.nextToken = nextToken
        self.useCaseSummaryList = useCaseSummaryList
    }
}

struct ListUseCasesOutputBody: Swift.Equatable {
    let useCaseSummaryList: [ConnectClientTypes.UseCase]?
    let nextToken: Swift.String?
}

extension ListUseCasesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case useCaseSummaryList = "UseCaseSummaryList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let useCaseSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.UseCase?].self, forKey: .useCaseSummaryList)
        var useCaseSummaryListDecoded0:[ConnectClientTypes.UseCase]? = nil
        if let useCaseSummaryListContainer = useCaseSummaryListContainer {
            useCaseSummaryListDecoded0 = [ConnectClientTypes.UseCase]()
            for structure0 in useCaseSummaryListContainer {
                if let structure0 = structure0 {
                    useCaseSummaryListDecoded0?.append(structure0)
                }
            }
        }
        useCaseSummaryList = useCaseSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListUseCasesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListUserHierarchyGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListUserHierarchyGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/user-hierarchy-groups-summary/\(instanceId.urlPercentEncoding())"
    }
}

public struct ListUserHierarchyGroupsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page. The default MaxResult size is 100.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListUserHierarchyGroupsInputBody: Swift.Equatable {
}

extension ListUserHierarchyGroupsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListUserHierarchyGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListUserHierarchyGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.userHierarchyGroupSummaryList = output.userHierarchyGroupSummaryList
        } else {
            self.nextToken = nil
            self.userHierarchyGroupSummaryList = nil
        }
    }
}

public struct ListUserHierarchyGroupsOutput: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the hierarchy groups.
    public var userHierarchyGroupSummaryList: [ConnectClientTypes.HierarchyGroupSummary]?

    public init(
        nextToken: Swift.String? = nil,
        userHierarchyGroupSummaryList: [ConnectClientTypes.HierarchyGroupSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.userHierarchyGroupSummaryList = userHierarchyGroupSummaryList
    }
}

struct ListUserHierarchyGroupsOutputBody: Swift.Equatable {
    let userHierarchyGroupSummaryList: [ConnectClientTypes.HierarchyGroupSummary]?
    let nextToken: Swift.String?
}

extension ListUserHierarchyGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case userHierarchyGroupSummaryList = "UserHierarchyGroupSummaryList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userHierarchyGroupSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.HierarchyGroupSummary?].self, forKey: .userHierarchyGroupSummaryList)
        var userHierarchyGroupSummaryListDecoded0:[ConnectClientTypes.HierarchyGroupSummary]? = nil
        if let userHierarchyGroupSummaryListContainer = userHierarchyGroupSummaryListContainer {
            userHierarchyGroupSummaryListDecoded0 = [ConnectClientTypes.HierarchyGroupSummary]()
            for structure0 in userHierarchyGroupSummaryListContainer {
                if let structure0 = structure0 {
                    userHierarchyGroupSummaryListDecoded0?.append(structure0)
                }
            }
        }
        userHierarchyGroupSummaryList = userHierarchyGroupSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListUserHierarchyGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListUsersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListUsersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/users-summary/\(instanceId.urlPercentEncoding())"
    }
}

public struct ListUsersInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page. The default MaxResult size is 100.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListUsersInputBody: Swift.Equatable {
}

extension ListUsersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListUsersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListUsersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.userSummaryList = output.userSummaryList
        } else {
            self.nextToken = nil
            self.userSummaryList = nil
        }
    }
}

public struct ListUsersOutput: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the users.
    public var userSummaryList: [ConnectClientTypes.UserSummary]?

    public init(
        nextToken: Swift.String? = nil,
        userSummaryList: [ConnectClientTypes.UserSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.userSummaryList = userSummaryList
    }
}

struct ListUsersOutputBody: Swift.Equatable {
    let userSummaryList: [ConnectClientTypes.UserSummary]?
    let nextToken: Swift.String?
}

extension ListUsersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case userSummaryList = "UserSummaryList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.UserSummary?].self, forKey: .userSummaryList)
        var userSummaryListDecoded0:[ConnectClientTypes.UserSummary]? = nil
        if let userSummaryListContainer = userSummaryListContainer {
            userSummaryListDecoded0 = [ConnectClientTypes.UserSummary]()
            for structure0 in userSummaryListContainer {
                if let structure0 = structure0 {
                    userSummaryListDecoded0?.append(structure0)
                }
            }
        }
        userSummaryList = userSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListUsersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListViewVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListViewVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let viewId = viewId else {
            return nil
        }
        return "/views/\(instanceId.urlPercentEncoding())/\(viewId.urlPercentEncoding())/versions"
    }
}

public struct ListViewVersionsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page. The default MaxResult size is 100.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The identifier of the view. Both ViewArn and ViewId can be used.
    /// This member is required.
    public var viewId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        viewId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.viewId = viewId
    }
}

struct ListViewVersionsInputBody: Swift.Equatable {
}

extension ListViewVersionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListViewVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListViewVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.viewVersionSummaryList = output.viewVersionSummaryList
        } else {
            self.nextToken = nil
            self.viewVersionSummaryList = nil
        }
    }
}

public struct ListViewVersionsOutput: Swift.Equatable {
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A list of view version summaries.
    public var viewVersionSummaryList: [ConnectClientTypes.ViewVersionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        viewVersionSummaryList: [ConnectClientTypes.ViewVersionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.viewVersionSummaryList = viewVersionSummaryList
    }
}

struct ListViewVersionsOutputBody: Swift.Equatable {
    let viewVersionSummaryList: [ConnectClientTypes.ViewVersionSummary]?
    let nextToken: Swift.String?
}

extension ListViewVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case viewVersionSummaryList = "ViewVersionSummaryList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let viewVersionSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.ViewVersionSummary?].self, forKey: .viewVersionSummaryList)
        var viewVersionSummaryListDecoded0:[ConnectClientTypes.ViewVersionSummary]? = nil
        if let viewVersionSummaryListContainer = viewVersionSummaryListContainer {
            viewVersionSummaryListDecoded0 = [ConnectClientTypes.ViewVersionSummary]()
            for structure0 in viewVersionSummaryListContainer {
                if let structure0 = structure0 {
                    viewVersionSummaryListDecoded0?.append(structure0)
                }
            }
        }
        viewVersionSummaryList = viewVersionSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListViewVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListViewsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let type = type {
                let typeQueryItem = ClientRuntime.URLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
                items.append(typeQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListViewsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/views/\(instanceId.urlPercentEncoding())"
    }
}

public struct ListViewsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page. The default MaxResult size is 100.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The type of the view.
    public var type: ConnectClientTypes.ViewType?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        type: ConnectClientTypes.ViewType? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.type = type
    }
}

struct ListViewsInputBody: Swift.Equatable {
}

extension ListViewsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListViewsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListViewsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.viewsSummaryList = output.viewsSummaryList
        } else {
            self.nextToken = nil
            self.viewsSummaryList = nil
        }
    }
}

public struct ListViewsOutput: Swift.Equatable {
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A list of view summaries.
    public var viewsSummaryList: [ConnectClientTypes.ViewSummary]?

    public init(
        nextToken: Swift.String? = nil,
        viewsSummaryList: [ConnectClientTypes.ViewSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.viewsSummaryList = viewsSummaryList
    }
}

struct ListViewsOutputBody: Swift.Equatable {
    let viewsSummaryList: [ConnectClientTypes.ViewSummary]?
    let nextToken: Swift.String?
}

extension ListViewsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case viewsSummaryList = "ViewsSummaryList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let viewsSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.ViewSummary?].self, forKey: .viewsSummaryList)
        var viewsSummaryListDecoded0:[ConnectClientTypes.ViewSummary]? = nil
        if let viewsSummaryListContainer = viewsSummaryListContainer {
            viewsSummaryListDecoded0 = [ConnectClientTypes.ViewSummary]()
            for structure0 in viewsSummaryListContainer {
                if let structure0 = structure0 {
                    viewsSummaryListDecoded0?.append(structure0)
                }
            }
        }
        viewsSummaryList = viewsSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListViewsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MaximumResultReturnedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MaximumResultReturnedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Maximum number (1000) of tags have been returned with current request. Consider changing request parameters to get more tags.
public struct MaximumResultReturnedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MaximumResultReturnedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct MaximumResultReturnedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MaximumResultReturnedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectClientTypes.MediaConcurrency: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel = "Channel"
        case concurrency = "Concurrency"
        case crossChannelBehavior = "CrossChannelBehavior"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channel = self.channel {
            try encodeContainer.encode(channel.rawValue, forKey: .channel)
        }
        if let concurrency = self.concurrency {
            try encodeContainer.encode(concurrency, forKey: .concurrency)
        }
        if let crossChannelBehavior = self.crossChannelBehavior {
            try encodeContainer.encode(crossChannelBehavior, forKey: .crossChannelBehavior)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Channel.self, forKey: .channel)
        channel = channelDecoded
        let concurrencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .concurrency)
        concurrency = concurrencyDecoded
        let crossChannelBehaviorDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.CrossChannelBehavior.self, forKey: .crossChannelBehavior)
        crossChannelBehavior = crossChannelBehaviorDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about which channels are supported, and how many contacts an agent can have on a channel simultaneously.
    public struct MediaConcurrency: Swift.Equatable {
        /// The channels that agents can handle in the Contact Control Panel (CCP).
        /// This member is required.
        public var channel: ConnectClientTypes.Channel?
        /// The number of contacts an agent can have on a channel simultaneously. Valid Range for VOICE: Minimum value of 1. Maximum value of 1. Valid Range for CHAT: Minimum value of 1. Maximum value of 10. Valid Range for TASK: Minimum value of 1. Maximum value of 10.
        /// This member is required.
        public var concurrency: Swift.Int?
        /// Defines the cross-channel routing behavior for each channel that is enabled for this Routing Profile. For example, this allows you to offer an agent a different contact from another channel when they are currently working with a contact from a Voice channel.
        public var crossChannelBehavior: ConnectClientTypes.CrossChannelBehavior?

        public init(
            channel: ConnectClientTypes.Channel? = nil,
            concurrency: Swift.Int? = nil,
            crossChannelBehavior: ConnectClientTypes.CrossChannelBehavior? = nil
        )
        {
            self.channel = channel
            self.concurrency = concurrency
            self.crossChannelBehavior = crossChannelBehavior
        }
    }

}

extension ConnectClientTypes.MediaPlacement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioFallbackUrl = "AudioFallbackUrl"
        case audioHostUrl = "AudioHostUrl"
        case eventIngestionUrl = "EventIngestionUrl"
        case signalingUrl = "SignalingUrl"
        case turnControlUrl = "TurnControlUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audioFallbackUrl = self.audioFallbackUrl {
            try encodeContainer.encode(audioFallbackUrl, forKey: .audioFallbackUrl)
        }
        if let audioHostUrl = self.audioHostUrl {
            try encodeContainer.encode(audioHostUrl, forKey: .audioHostUrl)
        }
        if let eventIngestionUrl = self.eventIngestionUrl {
            try encodeContainer.encode(eventIngestionUrl, forKey: .eventIngestionUrl)
        }
        if let signalingUrl = self.signalingUrl {
            try encodeContainer.encode(signalingUrl, forKey: .signalingUrl)
        }
        if let turnControlUrl = self.turnControlUrl {
            try encodeContainer.encode(turnControlUrl, forKey: .turnControlUrl)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioHostUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .audioHostUrl)
        audioHostUrl = audioHostUrlDecoded
        let audioFallbackUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .audioFallbackUrl)
        audioFallbackUrl = audioFallbackUrlDecoded
        let signalingUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signalingUrl)
        signalingUrl = signalingUrlDecoded
        let turnControlUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .turnControlUrl)
        turnControlUrl = turnControlUrlDecoded
        let eventIngestionUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventIngestionUrl)
        eventIngestionUrl = eventIngestionUrlDecoded
    }
}

extension ConnectClientTypes {
    /// A set of endpoints used by clients to connect to the media service group for an Amazon Chime SDK meeting.
    public struct MediaPlacement: Swift.Equatable {
        /// The audio fallback URL.
        public var audioFallbackUrl: Swift.String?
        /// The audio host URL.
        public var audioHostUrl: Swift.String?
        /// The event ingestion URL to which you send client meeting events.
        public var eventIngestionUrl: Swift.String?
        /// The signaling URL.
        public var signalingUrl: Swift.String?
        /// The turn control URL.
        public var turnControlUrl: Swift.String?

        public init(
            audioFallbackUrl: Swift.String? = nil,
            audioHostUrl: Swift.String? = nil,
            eventIngestionUrl: Swift.String? = nil,
            signalingUrl: Swift.String? = nil,
            turnControlUrl: Swift.String? = nil
        )
        {
            self.audioFallbackUrl = audioFallbackUrl
            self.audioHostUrl = audioHostUrl
            self.eventIngestionUrl = eventIngestionUrl
            self.signalingUrl = signalingUrl
            self.turnControlUrl = turnControlUrl
        }
    }

}

extension ConnectClientTypes.Meeting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaPlacement = "MediaPlacement"
        case mediaRegion = "MediaRegion"
        case meetingFeatures = "MeetingFeatures"
        case meetingId = "MeetingId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mediaPlacement = self.mediaPlacement {
            try encodeContainer.encode(mediaPlacement, forKey: .mediaPlacement)
        }
        if let mediaRegion = self.mediaRegion {
            try encodeContainer.encode(mediaRegion, forKey: .mediaRegion)
        }
        if let meetingFeatures = self.meetingFeatures {
            try encodeContainer.encode(meetingFeatures, forKey: .meetingFeatures)
        }
        if let meetingId = self.meetingId {
            try encodeContainer.encode(meetingId, forKey: .meetingId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaRegion)
        mediaRegion = mediaRegionDecoded
        let mediaPlacementDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.MediaPlacement.self, forKey: .mediaPlacement)
        mediaPlacement = mediaPlacementDecoded
        let meetingFeaturesDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.MeetingFeaturesConfiguration.self, forKey: .meetingFeatures)
        meetingFeatures = meetingFeaturesDecoded
        let meetingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meetingId)
        meetingId = meetingIdDecoded
    }
}

extension ConnectClientTypes {
    /// A meeting created using the Amazon Chime SDK.
    public struct Meeting: Swift.Equatable {
        /// The media placement for the meeting.
        public var mediaPlacement: ConnectClientTypes.MediaPlacement?
        /// The Amazon Web Services Region in which you create the meeting.
        public var mediaRegion: Swift.String?
        /// The configuration settings of the features available to a meeting.
        public var meetingFeatures: ConnectClientTypes.MeetingFeaturesConfiguration?
        /// The Amazon Chime SDK meeting ID.
        public var meetingId: Swift.String?

        public init(
            mediaPlacement: ConnectClientTypes.MediaPlacement? = nil,
            mediaRegion: Swift.String? = nil,
            meetingFeatures: ConnectClientTypes.MeetingFeaturesConfiguration? = nil,
            meetingId: Swift.String? = nil
        )
        {
            self.mediaPlacement = mediaPlacement
            self.mediaRegion = mediaRegion
            self.meetingFeatures = meetingFeatures
            self.meetingId = meetingId
        }
    }

}

extension ConnectClientTypes {
    public enum MeetingFeatureStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case unavailable
        case sdkUnknown(Swift.String)

        public static var allCases: [MeetingFeatureStatus] {
            return [
                .available,
                .unavailable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .unavailable: return "UNAVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MeetingFeatureStatus(rawValue: rawValue) ?? MeetingFeatureStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.MeetingFeaturesConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audio = "Audio"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audio = self.audio {
            try encodeContainer.encode(audio, forKey: .audio)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.AudioFeatures.self, forKey: .audio)
        audio = audioDecoded
    }
}

extension ConnectClientTypes {
    /// The configuration settings of the features available to a meeting.
    public struct MeetingFeaturesConfiguration: Swift.Equatable {
        /// The configuration settings for the audio features available to a meeting.
        public var audio: ConnectClientTypes.AudioFeatures?

        public init(
            audio: ConnectClientTypes.AudioFeatures? = nil
        )
        {
            self.audio = audio
        }
    }

}

extension ConnectClientTypes.MetricDataV2: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metric = "Metric"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metric = self.metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.MetricV2.self, forKey: .metric)
        metric = metricDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
    }
}

extension ConnectClientTypes {
    /// Contains the name, thresholds, and metric filters.
    public struct MetricDataV2: Swift.Equatable {
        /// The metric name, thresholds, and metric filters of the returned metric.
        public var metric: ConnectClientTypes.MetricV2?
        /// The corresponding value of the metric returned in the response.
        public var value: Swift.Double?

        public init(
            metric: ConnectClientTypes.MetricV2? = nil,
            value: Swift.Double? = nil
        )
        {
            self.metric = metric
            self.value = value
        }
    }

}

extension ConnectClientTypes.MetricFilterV2: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricFilterKey = "MetricFilterKey"
        case metricFilterValues = "MetricFilterValues"
        case negate = "Negate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricFilterKey = self.metricFilterKey {
            try encodeContainer.encode(metricFilterKey, forKey: .metricFilterKey)
        }
        if let metricFilterValues = metricFilterValues {
            var metricFilterValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricFilterValues)
            for string0 in metricFilterValues {
                try metricFilterValuesContainer.encode(string0)
            }
        }
        if negate != false {
            try encodeContainer.encode(negate, forKey: .negate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricFilterKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricFilterKey)
        metricFilterKey = metricFilterKeyDecoded
        let metricFilterValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .metricFilterValues)
        var metricFilterValuesDecoded0:[Swift.String]? = nil
        if let metricFilterValuesContainer = metricFilterValuesContainer {
            metricFilterValuesDecoded0 = [Swift.String]()
            for string0 in metricFilterValuesContainer {
                if let string0 = string0 {
                    metricFilterValuesDecoded0?.append(string0)
                }
            }
        }
        metricFilterValues = metricFilterValuesDecoded0
        let negateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .negate) ?? false
        negate = negateDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about the filter used when retrieving metrics. MetricFiltersV2 can be used on the following metrics: AVG_AGENT_CONNECTING_TIME, CONTACTS_CREATED, CONTACTS_HANDLED, SUM_CONTACTS_DISCONNECTED.
    public struct MetricFilterV2: Swift.Equatable {
        /// The key to use for filtering data. Valid metric filter keys: INITIATION_METHOD, DISCONNECT_REASON. These are the same values as the InitiationMethod and DisconnectReason in the contact record. For more information, see [ContactTraceRecord](https://docs.aws.amazon.com/connect/latest/adminguide/ctr-data-model.html#ctr-ContactTraceRecord) in the Amazon Connect Administrator's Guide.
        public var metricFilterKey: Swift.String?
        /// The values to use for filtering data. Valid metric filter values for INITIATION_METHOD: INBOUND | OUTBOUND | TRANSFER | QUEUE_TRANSFER | CALLBACK | API Valid metric filter values for DISCONNECT_REASON: CUSTOMER_DISCONNECT | AGENT_DISCONNECT | THIRD_PARTY_DISCONNECT | TELECOM_PROBLEM | BARGED | CONTACT_FLOW_DISCONNECT | OTHER | EXPIRED | API
        public var metricFilterValues: [Swift.String]?
        /// The flag to use to filter on requested metric filter values or to not filter on requested metric filter values. By default the negate is false, which indicates to filter on the requested metric filter.
        public var negate: Swift.Bool

        public init(
            metricFilterKey: Swift.String? = nil,
            metricFilterValues: [Swift.String]? = nil,
            negate: Swift.Bool = false
        )
        {
            self.metricFilterKey = metricFilterKey
            self.metricFilterValues = metricFilterValues
            self.negate = negate
        }
    }

}

extension ConnectClientTypes.MetricInterval: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case interval = "Interval"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let interval = self.interval {
            try encodeContainer.encode(interval.rawValue, forKey: .interval)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intervalDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.IntervalPeriod.self, forKey: .interval)
        interval = intervalDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension ConnectClientTypes {
    /// The interval period with the start and end time for the metrics.
    public struct MetricInterval: Swift.Equatable {
        /// The timestamp, in UNIX Epoch time format. End time is based on the interval period selected. For example, If IntervalPeriod is selected THIRTY_MIN, StartTime and EndTime in the API request differs by 1 day, then 48 results are returned in the response. Each result is aggregated by the 30 minutes period, with each StartTime and EndTime differing by 30 minutes.
        public var endTime: ClientRuntime.Date?
        /// The interval period provided in the API request.
        public var interval: ConnectClientTypes.IntervalPeriod?
        /// The timestamp, in UNIX Epoch time format. Start time is based on the interval period selected.
        public var startTime: ClientRuntime.Date?

        public init(
            endTime: ClientRuntime.Date? = nil,
            interval: ConnectClientTypes.IntervalPeriod? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.endTime = endTime
            self.interval = interval
            self.startTime = startTime
        }
    }

}

extension ConnectClientTypes.MetricResultV2: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collections = "Collections"
        case dimensions = "Dimensions"
        case metricInterval = "MetricInterval"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let collections = collections {
            var collectionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .collections)
            for metricdatav20 in collections {
                try collectionsContainer.encode(metricdatav20)
            }
        }
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .dimensions)
            for (dictKey0, dimensionsV2Map0) in dimensions {
                try dimensionsContainer.encode(dimensionsV2Map0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let metricInterval = self.metricInterval {
            try encodeContainer.encode(metricInterval, forKey: .metricInterval)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .dimensions)
        var dimensionsDecoded0: [Swift.String:Swift.String]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, dimensionsv2value0) in dimensionsContainer {
                if let dimensionsv2value0 = dimensionsv2value0 {
                    dimensionsDecoded0?[key0] = dimensionsv2value0
                }
            }
        }
        dimensions = dimensionsDecoded0
        let metricIntervalDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.MetricInterval.self, forKey: .metricInterval)
        metricInterval = metricIntervalDecoded
        let collectionsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.MetricDataV2?].self, forKey: .collections)
        var collectionsDecoded0:[ConnectClientTypes.MetricDataV2]? = nil
        if let collectionsContainer = collectionsContainer {
            collectionsDecoded0 = [ConnectClientTypes.MetricDataV2]()
            for structure0 in collectionsContainer {
                if let structure0 = structure0 {
                    collectionsDecoded0?.append(structure0)
                }
            }
        }
        collections = collectionsDecoded0
    }
}

extension ConnectClientTypes {
    /// Contains information about the metric results.
    public struct MetricResultV2: Swift.Equatable {
        /// The set of metrics.
        public var collections: [ConnectClientTypes.MetricDataV2]?
        /// The dimension for the metrics.
        public var dimensions: [Swift.String:Swift.String]?
        /// The interval period with the start and end time for the metrics.
        public var metricInterval: ConnectClientTypes.MetricInterval?

        public init(
            collections: [ConnectClientTypes.MetricDataV2]? = nil,
            dimensions: [Swift.String:Swift.String]? = nil,
            metricInterval: ConnectClientTypes.MetricInterval? = nil
        )
        {
            self.collections = collections
            self.dimensions = dimensions
            self.metricInterval = metricInterval
        }
    }

}

extension ConnectClientTypes.MetricV2: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricFilters = "MetricFilters"
        case name = "Name"
        case threshold = "Threshold"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricFilters = metricFilters {
            var metricFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricFilters)
            for metricfilterv20 in metricFilters {
                try metricFiltersContainer.encode(metricfilterv20)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let threshold = threshold {
            var thresholdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .threshold)
            for thresholdv20 in threshold {
                try thresholdContainer.encode(thresholdv20)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let thresholdContainer = try containerValues.decodeIfPresent([ConnectClientTypes.ThresholdV2?].self, forKey: .threshold)
        var thresholdDecoded0:[ConnectClientTypes.ThresholdV2]? = nil
        if let thresholdContainer = thresholdContainer {
            thresholdDecoded0 = [ConnectClientTypes.ThresholdV2]()
            for structure0 in thresholdContainer {
                if let structure0 = structure0 {
                    thresholdDecoded0?.append(structure0)
                }
            }
        }
        threshold = thresholdDecoded0
        let metricFiltersContainer = try containerValues.decodeIfPresent([ConnectClientTypes.MetricFilterV2?].self, forKey: .metricFilters)
        var metricFiltersDecoded0:[ConnectClientTypes.MetricFilterV2]? = nil
        if let metricFiltersContainer = metricFiltersContainer {
            metricFiltersDecoded0 = [ConnectClientTypes.MetricFilterV2]()
            for structure0 in metricFiltersContainer {
                if let structure0 = structure0 {
                    metricFiltersDecoded0?.append(structure0)
                }
            }
        }
        metricFilters = metricFiltersDecoded0
    }
}

extension ConnectClientTypes {
    /// Contains information about the metric.
    public struct MetricV2: Swift.Equatable {
        /// Contains the filters to be used when returning data.
        public var metricFilters: [ConnectClientTypes.MetricFilterV2]?
        /// The name of the metric. This parameter is required. The following Required = No is incorrect.
        public var name: Swift.String?
        /// Contains information about the threshold for service level metrics.
        public var threshold: [ConnectClientTypes.ThresholdV2]?

        public init(
            metricFilters: [ConnectClientTypes.MetricFilterV2]? = nil,
            name: Swift.String? = nil,
            threshold: [ConnectClientTypes.ThresholdV2]? = nil
        )
        {
            self.metricFilters = metricFilters
            self.name = name
            self.threshold = threshold
        }
    }

}

extension ConnectClientTypes {
    public enum MonitorCapability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case barge
        case silentMonitor
        case sdkUnknown(Swift.String)

        public static var allCases: [MonitorCapability] {
            return [
                .barge,
                .silentMonitor,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .barge: return "BARGE"
            case .silentMonitor: return "SILENT_MONITOR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MonitorCapability(rawValue: rawValue) ?? MonitorCapability.sdkUnknown(rawValue)
        }
    }
}

extension MonitorContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedMonitorCapabilities = "AllowedMonitorCapabilities"
        case clientToken = "ClientToken"
        case contactId = "ContactId"
        case instanceId = "InstanceId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedMonitorCapabilities = allowedMonitorCapabilities {
            var allowedMonitorCapabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedMonitorCapabilities)
            for monitorcapability0 in allowedMonitorCapabilities {
                try allowedMonitorCapabilitiesContainer.encode(monitorcapability0.rawValue)
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let contactId = self.contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension MonitorContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/contact/monitor"
    }
}

public struct MonitorContactInput: Swift.Equatable {
    /// Specify which monitoring actions the user is allowed to take. For example, whether the user is allowed to escalate from silent monitoring to barge.
    public var allowedMonitorCapabilities: [ConnectClientTypes.MonitorCapability]?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The identifier of the contact.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the user account.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        allowedMonitorCapabilities: [ConnectClientTypes.MonitorCapability]? = nil,
        clientToken: Swift.String? = nil,
        contactId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.allowedMonitorCapabilities = allowedMonitorCapabilities
        self.clientToken = clientToken
        self.contactId = contactId
        self.instanceId = instanceId
        self.userId = userId
    }
}

struct MonitorContactInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let contactId: Swift.String?
    let userId: Swift.String?
    let allowedMonitorCapabilities: [ConnectClientTypes.MonitorCapability]?
    let clientToken: Swift.String?
}

extension MonitorContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedMonitorCapabilities = "AllowedMonitorCapabilities"
        case clientToken = "ClientToken"
        case contactId = "ContactId"
        case instanceId = "InstanceId"
        case userId = "UserId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let allowedMonitorCapabilitiesContainer = try containerValues.decodeIfPresent([ConnectClientTypes.MonitorCapability?].self, forKey: .allowedMonitorCapabilities)
        var allowedMonitorCapabilitiesDecoded0:[ConnectClientTypes.MonitorCapability]? = nil
        if let allowedMonitorCapabilitiesContainer = allowedMonitorCapabilitiesContainer {
            allowedMonitorCapabilitiesDecoded0 = [ConnectClientTypes.MonitorCapability]()
            for enum0 in allowedMonitorCapabilitiesContainer {
                if let enum0 = enum0 {
                    allowedMonitorCapabilitiesDecoded0?.append(enum0)
                }
            }
        }
        allowedMonitorCapabilities = allowedMonitorCapabilitiesDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension MonitorContactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MonitorContactOutputBody = try responseDecoder.decode(responseBody: data)
            self.contactArn = output.contactArn
            self.contactId = output.contactId
        } else {
            self.contactArn = nil
            self.contactId = nil
        }
    }
}

public struct MonitorContactOutput: Swift.Equatable {
    /// The ARN of the contact.
    public var contactArn: Swift.String?
    /// The identifier of the contact.
    public var contactId: Swift.String?

    public init(
        contactArn: Swift.String? = nil,
        contactId: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
        self.contactId = contactId
    }
}

struct MonitorContactOutputBody: Swift.Equatable {
    let contactId: Swift.String?
    let contactArn: Swift.String?
}

extension MonitorContactOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
        case contactId = "ContactId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
    }
}

enum MonitorContactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IdempotencyException": return try await IdempotencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectClientTypes.NewSessionDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case participantDetails = "ParticipantDetails"
        case streamingConfiguration = "StreamingConfiguration"
        case supportedMessagingContentTypes = "SupportedMessagingContentTypes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let participantDetails = self.participantDetails {
            try encodeContainer.encode(participantDetails, forKey: .participantDetails)
        }
        if let streamingConfiguration = self.streamingConfiguration {
            try encodeContainer.encode(streamingConfiguration, forKey: .streamingConfiguration)
        }
        if let supportedMessagingContentTypes = supportedMessagingContentTypes {
            var supportedMessagingContentTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedMessagingContentTypes)
            for supportedmessagingcontenttype0 in supportedMessagingContentTypes {
                try supportedMessagingContentTypesContainer.encode(supportedmessagingcontenttype0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let supportedMessagingContentTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .supportedMessagingContentTypes)
        var supportedMessagingContentTypesDecoded0:[Swift.String]? = nil
        if let supportedMessagingContentTypesContainer = supportedMessagingContentTypesContainer {
            supportedMessagingContentTypesDecoded0 = [Swift.String]()
            for string0 in supportedMessagingContentTypesContainer {
                if let string0 = string0 {
                    supportedMessagingContentTypesDecoded0?.append(string0)
                }
            }
        }
        supportedMessagingContentTypes = supportedMessagingContentTypesDecoded0
        let participantDetailsDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ParticipantDetails.self, forKey: .participantDetails)
        participantDetails = participantDetailsDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let streamingConfigurationDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ChatStreamingConfiguration.self, forKey: .streamingConfiguration)
        streamingConfiguration = streamingConfigurationDecoded
    }
}

extension ConnectClientTypes {
    /// Payload of chat properties to apply when starting a new contact.
    public struct NewSessionDetails: Swift.Equatable {
        /// A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes. They can be accessed in flows just like any other contact attributes. There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys can include only alphanumeric, dash, and underscore characters.
        public var attributes: [Swift.String:Swift.String]?
        /// The customer's details.
        public var participantDetails: ConnectClientTypes.ParticipantDetails?
        /// The streaming configuration, such as the Amazon SNS streaming endpoint.
        public var streamingConfiguration: ConnectClientTypes.ChatStreamingConfiguration?
        /// The supported chat message content types. Supported types are text/plain, text/markdown, application/json, application/vnd.amazonaws.connect.message.interactive, and application/vnd.amazonaws.connect.message.interactive.response. Content types must always contain  text/plain. You can then put any other supported type in the list. For example, all the following lists are valid because they contain text/plain: [text/plain, text/markdown, application/json],  [text/markdown, text/plain], [text/plain, application/json, application/vnd.amazonaws.connect.message.interactive.response].
        public var supportedMessagingContentTypes: [Swift.String]?

        public init(
            attributes: [Swift.String:Swift.String]? = nil,
            participantDetails: ConnectClientTypes.ParticipantDetails? = nil,
            streamingConfiguration: ConnectClientTypes.ChatStreamingConfiguration? = nil,
            supportedMessagingContentTypes: [Swift.String]? = nil
        )
        {
            self.attributes = attributes
            self.participantDetails = participantDetails
            self.streamingConfiguration = streamingConfiguration
            self.supportedMessagingContentTypes = supportedMessagingContentTypes
        }
    }

}

extension ConnectClientTypes {
    public enum NotificationContentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case plainText
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationContentType] {
            return [
                .plainText,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .plainText: return "PLAIN_TEXT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NotificationContentType(rawValue: rawValue) ?? NotificationContentType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes {
    public enum NotificationDeliveryType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case email
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationDeliveryType] {
            return [
                .email,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .email: return "EMAIL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NotificationDeliveryType(rawValue: rawValue) ?? NotificationDeliveryType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.NotificationRecipientType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userIds = "UserIds"
        case userTags = "UserTags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userIds = userIds {
            var userIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userIds)
            for userid0 in userIds {
                try userIdsContainer.encode(userid0)
            }
        }
        if let userTags = userTags {
            var userTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .userTags)
            for (dictKey0, userTagMap0) in userTags {
                try userTagsContainer.encode(userTagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .userTags)
        var userTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let userTagsContainer = userTagsContainer {
            userTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in userTagsContainer {
                if let string0 = string0 {
                    userTagsDecoded0?[key0] = string0
                }
            }
        }
        userTags = userTagsDecoded0
        let userIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .userIds)
        var userIdsDecoded0:[Swift.String]? = nil
        if let userIdsContainer = userIdsContainer {
            userIdsDecoded0 = [Swift.String]()
            for string0 in userIdsContainer {
                if let string0 = string0 {
                    userIdsDecoded0?.append(string0)
                }
            }
        }
        userIds = userIdsDecoded0
    }
}

extension ConnectClientTypes {
    /// The type of notification recipient.
    public struct NotificationRecipientType: Swift.Equatable {
        /// A list of user IDs.
        public var userIds: [Swift.String]?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }. Amazon Connect users with the specified tags will be notified.
        public var userTags: [Swift.String:Swift.String]?

        public init(
            userIds: [Swift.String]? = nil,
            userTags: [Swift.String:Swift.String]? = nil
        )
        {
            self.userIds = userIds
            self.userTags = userTags
        }
    }

}

extension ConnectClientTypes.NumberReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ConnectClientTypes {
    /// Information about a reference when the referenceType is NUMBER. Otherwise, null.
    public struct NumberReference: Swift.Equatable {
        /// Identifier of the number reference.
        public var name: Swift.String?
        /// A valid number.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension ConnectClientTypes {
    public enum NumericQuestionPropertyAutomationLabel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case agentInteractionDuration
        case contactDuration
        case customerHoldTime
        case nonTalkTime
        case nonTalkTimePercentage
        case numberOfInterruptions
        case overallAgentSentimentScore
        case overallCustomerSentimentScore
        case sdkUnknown(Swift.String)

        public static var allCases: [NumericQuestionPropertyAutomationLabel] {
            return [
                .agentInteractionDuration,
                .contactDuration,
                .customerHoldTime,
                .nonTalkTime,
                .nonTalkTimePercentage,
                .numberOfInterruptions,
                .overallAgentSentimentScore,
                .overallCustomerSentimentScore,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agentInteractionDuration: return "AGENT_INTERACTION_DURATION"
            case .contactDuration: return "CONTACT_DURATION"
            case .customerHoldTime: return "CUSTOMER_HOLD_TIME"
            case .nonTalkTime: return "NON_TALK_TIME"
            case .nonTalkTimePercentage: return "NON_TALK_TIME_PERCENTAGE"
            case .numberOfInterruptions: return "NUMBER_OF_INTERRUPTIONS"
            case .overallAgentSentimentScore: return "OVERALL_AGENT_SENTIMENT_SCORE"
            case .overallCustomerSentimentScore: return "OVERALL_CUSTOMER_SENTIMENT_SCORE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NumericQuestionPropertyAutomationLabel(rawValue: rawValue) ?? NumericQuestionPropertyAutomationLabel.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.NumericQuestionPropertyValueAutomation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case label = "Label"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let label = self.label {
            try encodeContainer.encode(label.rawValue, forKey: .label)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let labelDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.NumericQuestionPropertyAutomationLabel.self, forKey: .label)
        label = labelDecoded
    }
}

extension ConnectClientTypes {
    /// Information about the property value used in automation of a numeric questions. Label values are associated with minimum and maximum values for the numeric question.
    ///
    /// * Sentiment scores have a minimum value of -5 and maximum value of 5.
    ///
    /// * Duration labels, such as NON_TALK_TIME, CONTACT_DURATION, AGENT_INTERACTION_DURATION, CUSTOMER_HOLD_TIME have a minimum value of 0 and maximum value of 28800.
    ///
    /// * Percentages have a minimum value of 0 and maximum value of 100.
    ///
    /// * NUMBER_OF_INTERRUPTIONS has a minimum value of 0 and maximum value of 1000.
    public struct NumericQuestionPropertyValueAutomation: Swift.Equatable {
        /// The property label of the automation.
        /// This member is required.
        public var label: ConnectClientTypes.NumericQuestionPropertyAutomationLabel?

        public init(
            label: ConnectClientTypes.NumericQuestionPropertyAutomationLabel? = nil
        )
        {
            self.label = label
        }
    }

}

extension ConnectClientTypes.OutboundCallerConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outboundCallerIdName = "OutboundCallerIdName"
        case outboundCallerIdNumberId = "OutboundCallerIdNumberId"
        case outboundFlowId = "OutboundFlowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outboundCallerIdName = self.outboundCallerIdName {
            try encodeContainer.encode(outboundCallerIdName, forKey: .outboundCallerIdName)
        }
        if let outboundCallerIdNumberId = self.outboundCallerIdNumberId {
            try encodeContainer.encode(outboundCallerIdNumberId, forKey: .outboundCallerIdNumberId)
        }
        if let outboundFlowId = self.outboundFlowId {
            try encodeContainer.encode(outboundFlowId, forKey: .outboundFlowId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outboundCallerIdNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outboundCallerIdName)
        outboundCallerIdName = outboundCallerIdNameDecoded
        let outboundCallerIdNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outboundCallerIdNumberId)
        outboundCallerIdNumberId = outboundCallerIdNumberIdDecoded
        let outboundFlowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outboundFlowId)
        outboundFlowId = outboundFlowIdDecoded
    }
}

extension ConnectClientTypes {
    /// The outbound caller ID name, number, and outbound whisper flow.
    public struct OutboundCallerConfig: Swift.Equatable {
        /// The caller ID name.
        public var outboundCallerIdName: Swift.String?
        /// The caller ID number.
        public var outboundCallerIdNumberId: Swift.String?
        /// The outbound whisper flow to be used during an outbound call.
        public var outboundFlowId: Swift.String?

        public init(
            outboundCallerIdName: Swift.String? = nil,
            outboundCallerIdNumberId: Swift.String? = nil,
            outboundFlowId: Swift.String? = nil
        )
        {
            self.outboundCallerIdName = outboundCallerIdName
            self.outboundCallerIdNumberId = outboundCallerIdNumberId
            self.outboundFlowId = outboundFlowId
        }
    }

}

extension OutboundContactNotPermittedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: OutboundContactNotPermittedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The contact is not permitted.
public struct OutboundContactNotPermittedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message about the contact.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OutboundContactNotPermittedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct OutboundContactNotPermittedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OutboundContactNotPermittedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OutputTypeNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: OutputTypeNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Thrown for analyzed content when requested OutputType was not enabled for a given contact. For example, if an OutputType.Raw was requested for a contact that had `RedactedOnly` Redaction policy set in Contact flow.
public struct OutputTypeNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OutputTypeNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct OutputTypeNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OutputTypeNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectClientTypes.ParticipantCapabilities: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case video = "Video"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let video = self.video {
            try encodeContainer.encode(video.rawValue, forKey: .video)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let videoDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.VideoCapability.self, forKey: .video)
        video = videoDecoded
    }
}

extension ConnectClientTypes {
    /// The configuration for the allowed capabilities for participants present over the call.
    public struct ParticipantCapabilities: Swift.Equatable {
        /// The configuration having the video sharing capabilities for participants over the call.
        public var video: ConnectClientTypes.VideoCapability?

        public init(
            video: ConnectClientTypes.VideoCapability? = nil
        )
        {
            self.video = video
        }
    }

}

extension ConnectClientTypes.ParticipantDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension ConnectClientTypes {
    /// The customer's details.
    public struct ParticipantDetails: Swift.Equatable {
        /// Display name of the participant.
        /// This member is required.
        public var displayName: Swift.String?

        public init(
            displayName: Swift.String? = nil
        )
        {
            self.displayName = displayName
        }
    }

}

extension ConnectClientTypes.ParticipantDetailsToAdd: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case participantRole = "ParticipantRole"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let participantRole = self.participantRole {
            try encodeContainer.encode(participantRole.rawValue, forKey: .participantRole)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let participantRoleDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ParticipantRole.self, forKey: .participantRole)
        participantRole = participantRoleDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension ConnectClientTypes {
    /// The details to add for the participant.
    public struct ParticipantDetailsToAdd: Swift.Equatable {
        /// The display name of the participant.
        public var displayName: Swift.String?
        /// The role of the participant being added.
        public var participantRole: ConnectClientTypes.ParticipantRole?

        public init(
            displayName: Swift.String? = nil,
            participantRole: ConnectClientTypes.ParticipantRole? = nil
        )
        {
            self.displayName = displayName
            self.participantRole = participantRole
        }
    }

}

extension ConnectClientTypes {
    public enum ParticipantRole: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case agent
        case customer
        case customBot
        case system
        case sdkUnknown(Swift.String)

        public static var allCases: [ParticipantRole] {
            return [
                .agent,
                .customer,
                .customBot,
                .system,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agent: return "AGENT"
            case .customer: return "CUSTOMER"
            case .customBot: return "CUSTOM_BOT"
            case .system: return "SYSTEM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ParticipantRole(rawValue: rawValue) ?? ParticipantRole.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes {
    public enum ParticipantTimerAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case unset
        case sdkUnknown(Swift.String)

        public static var allCases: [ParticipantTimerAction] {
            return [
                .unset,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .unset: return "Unset"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ParticipantTimerAction(rawValue: rawValue) ?? ParticipantTimerAction.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.ParticipantTimerConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case participantRole = "ParticipantRole"
        case timerType = "TimerType"
        case timerValue = "TimerValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let participantRole = self.participantRole {
            try encodeContainer.encode(participantRole.rawValue, forKey: .participantRole)
        }
        if let timerType = self.timerType {
            try encodeContainer.encode(timerType.rawValue, forKey: .timerType)
        }
        if let timerValue = self.timerValue {
            try encodeContainer.encode(timerValue, forKey: .timerValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let participantRoleDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.TimerEligibleParticipantRoles.self, forKey: .participantRole)
        participantRole = participantRoleDecoded
        let timerTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ParticipantTimerType.self, forKey: .timerType)
        timerType = timerTypeDecoded
        let timerValueDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ParticipantTimerValue.self, forKey: .timerValue)
        timerValue = timerValueDecoded
    }
}

extension ConnectClientTypes {
    /// Configuration information for the timer. After the timer configuration is set, it persists for the duration of the chat. It persists across new contacts in the chain, for example, transfer contacts. For more information about how chat timeouts work, see [Set up chat timeouts for human participants](https://docs.aws.amazon.com/connect/latest/adminguide/setup-chat-timeouts.html).
    public struct ParticipantTimerConfiguration: Swift.Equatable {
        /// The role of the participant in the chat conversation.
        /// This member is required.
        public var participantRole: ConnectClientTypes.TimerEligibleParticipantRoles?
        /// The type of timer. IDLE indicates the timer applies for considering a human chat participant as idle. DISCONNECT_NONCUSTOMER indicates the timer applies to automatically disconnecting a chat participant due to idleness.
        /// This member is required.
        public var timerType: ConnectClientTypes.ParticipantTimerType?
        /// The value of the timer. Either the timer action (Unset to delete the timer), or the duration of the timer in minutes. Only one value can be set.
        /// This member is required.
        public var timerValue: ConnectClientTypes.ParticipantTimerValue?

        public init(
            participantRole: ConnectClientTypes.TimerEligibleParticipantRoles? = nil,
            timerType: ConnectClientTypes.ParticipantTimerType? = nil,
            timerValue: ConnectClientTypes.ParticipantTimerValue? = nil
        )
        {
            self.participantRole = participantRole
            self.timerType = timerType
            self.timerValue = timerValue
        }
    }

}

extension ConnectClientTypes {
    public enum ParticipantTimerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disconnectNoncustomer
        case idle
        case sdkUnknown(Swift.String)

        public static var allCases: [ParticipantTimerType] {
            return [
                .disconnectNoncustomer,
                .idle,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disconnectNoncustomer: return "DISCONNECT_NONCUSTOMER"
            case .idle: return "IDLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ParticipantTimerType(rawValue: rawValue) ?? ParticipantTimerType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.ParticipantTimerValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case participanttimeraction = "ParticipantTimerAction"
        case participanttimerdurationinminutes = "ParticipantTimerDurationInMinutes"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .participanttimeraction(participanttimeraction):
                try container.encode(participanttimeraction.rawValue, forKey: .participanttimeraction)
            case let .participanttimerdurationinminutes(participanttimerdurationinminutes):
                try container.encode(participanttimerdurationinminutes, forKey: .participanttimerdurationinminutes)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let participanttimeractionDecoded = try values.decodeIfPresent(ConnectClientTypes.ParticipantTimerAction.self, forKey: .participanttimeraction)
        if let participanttimeraction = participanttimeractionDecoded {
            self = .participanttimeraction(participanttimeraction)
            return
        }
        let participanttimerdurationinminutesDecoded = try values.decodeIfPresent(Swift.Int.self, forKey: .participanttimerdurationinminutes)
        if let participanttimerdurationinminutes = participanttimerdurationinminutesDecoded {
            self = .participanttimerdurationinminutes(participanttimerdurationinminutes)
            return
        }
        self = .sdkUnknown("")
    }
}

extension ConnectClientTypes {
    /// The value of the timer. Either the timer action (Unset to delete the timer), or the duration of the timer in minutes. Only one value can be set. For more information about how chat timeouts work, see [Set up chat timeouts for human participants](https://docs.aws.amazon.com/connect/latest/adminguide/setup-chat-timeouts.html).
    public enum ParticipantTimerValue: Swift.Equatable {
        /// The timer action. Currently only one value is allowed: Unset. It deletes a timer.
        case participanttimeraction(ConnectClientTypes.ParticipantTimerAction)
        /// The duration of a timer, in minutes.
        case participanttimerdurationinminutes(Swift.Int)
        case sdkUnknown(Swift.String)
    }

}

extension ConnectClientTypes.ParticipantTokenCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expiry = "Expiry"
        case participantToken = "ParticipantToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expiry = self.expiry {
            try encodeContainer.encode(expiry, forKey: .expiry)
        }
        if let participantToken = self.participantToken {
            try encodeContainer.encode(participantToken, forKey: .participantToken)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let participantTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .participantToken)
        participantToken = participantTokenDecoded
        let expiryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expiry)
        expiry = expiryDecoded
    }
}

extension ConnectClientTypes {
    /// The credentials used by the participant.
    public struct ParticipantTokenCredentials: Swift.Equatable {
        /// The expiration of the token. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
        public var expiry: Swift.String?
        /// The token used by the chat participant to call [CreateParticipantConnection](https://docs.aws.amazon.com/connect-participant/latest/APIReference/API_CreateParticipantConnection.html). The participant token is valid for the lifetime of a chat participant.
        public var participantToken: Swift.String?

        public init(
            expiry: Swift.String? = nil,
            participantToken: Swift.String? = nil
        )
        {
            self.expiry = expiry
            self.participantToken = participantToken
        }
    }

}

extension PauseContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactFlowId = "ContactFlowId"
        case contactId = "ContactId"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactFlowId = self.contactFlowId {
            try encodeContainer.encode(contactFlowId, forKey: .contactFlowId)
        }
        if let contactId = self.contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

extension PauseContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/contact/pause"
    }
}

public struct PauseContactInput: Swift.Equatable {
    /// The identifier of the flow.
    public var contactFlowId: Swift.String?
    /// The identifier of the contact.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        contactFlowId: Swift.String? = nil,
        contactId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.contactFlowId = contactFlowId
        self.contactId = contactId
        self.instanceId = instanceId
    }
}

struct PauseContactInputBody: Swift.Equatable {
    let contactId: Swift.String?
    let instanceId: Swift.String?
    let contactFlowId: Swift.String?
}

extension PauseContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactFlowId = "ContactFlowId"
        case contactId = "ContactId"
        case instanceId = "InstanceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let contactFlowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactFlowId)
        contactFlowId = contactFlowIdDecoded
    }
}

extension PauseContactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PauseContactOutput: Swift.Equatable {

    public init() { }
}

enum PauseContactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectClientTypes.PersistentChat: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rehydrationType = "RehydrationType"
        case sourceContactId = "SourceContactId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rehydrationType = self.rehydrationType {
            try encodeContainer.encode(rehydrationType.rawValue, forKey: .rehydrationType)
        }
        if let sourceContactId = self.sourceContactId {
            try encodeContainer.encode(sourceContactId, forKey: .sourceContactId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rehydrationTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.RehydrationType.self, forKey: .rehydrationType)
        rehydrationType = rehydrationTypeDecoded
        let sourceContactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceContactId)
        sourceContactId = sourceContactIdDecoded
    }
}

extension ConnectClientTypes {
    /// Enable persistent chats. For more information about enabling persistent chat, and for example use cases and how to configure for them, see [Enable persistent chat](https://docs.aws.amazon.com/connect/latest/adminguide/chat-persistence.html).
    public struct PersistentChat: Swift.Equatable {
        /// The contactId that is used for rehydration depends on the rehydration type. RehydrationType is required for persistent chat.
        ///
        /// * ENTIRE_PAST_SESSION: Rehydrates a chat from the most recently terminated past chat contact of the specified past ended chat session. To use this type, provide the initialContactId of the past ended chat session in the sourceContactId field. In this type, Amazon Connect determines the most recent chat contact on the specified chat session that has ended, and uses it to start a persistent chat.
        ///
        /// * FROM_SEGMENT: Rehydrates a chat from the past chat contact that is specified in the sourceContactId field.
        ///
        ///
        /// The actual contactId used for rehydration is provided in the response of this API.
        public var rehydrationType: ConnectClientTypes.RehydrationType?
        /// The contactId from which a persistent chat session must be started.
        public var sourceContactId: Swift.String?

        public init(
            rehydrationType: ConnectClientTypes.RehydrationType? = nil,
            sourceContactId: Swift.String? = nil
        )
        {
            self.rehydrationType = rehydrationType
            self.sourceContactId = sourceContactId
        }
    }

}

extension ConnectClientTypes {
    public enum PhoneNumberCountryCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ad
        case ae
        case af
        case ag
        case ai
        case al
        case am
        case an
        case ao
        case aq
        case ar
        case `as`
        case at
        case au
        case aw
        case az
        case ba
        case bb
        case bd
        case be
        case bf
        case bg
        case bh
        case bi
        case bj
        case bl
        case bm
        case bn
        case bo
        case br
        case bs
        case bt
        case bw
        case by
        case bz
        case ca
        case cc
        case cd
        case cf
        case cg
        case ch
        case ci
        case ck
        case cl
        case cm
        case cn
        case co
        case cr
        case cu
        case cv
        case cw
        case cx
        case cy
        case cz
        case de
        case dj
        case dk
        case dm
        case `do`
        case dz
        case ec
        case ee
        case eg
        case eh
        case er
        case es
        case et
        case fi
        case fj
        case fk
        case fm
        case fo
        case fr
        case ga
        case gb
        case gd
        case ge
        case gg
        case gh
        case gi
        case gl
        case gm
        case gn
        case gq
        case gr
        case gt
        case gu
        case gw
        case gy
        case hk
        case hn
        case hr
        case ht
        case hu
        case id
        case ie
        case il
        case im
        case `in`
        case io
        case iq
        case ir
        case `is`
        case it
        case je
        case jm
        case jo
        case jp
        case ke
        case kg
        case kh
        case ki
        case km
        case kn
        case kp
        case kr
        case kw
        case ky
        case kz
        case la
        case lb
        case lc
        case li
        case lk
        case lr
        case ls
        case lt
        case lu
        case lv
        case ly
        case ma
        case mc
        case md
        case me
        case mf
        case mg
        case mh
        case mk
        case ml
        case mm
        case mn
        case mo
        case mp
        case mr
        case ms
        case mt
        case mu
        case mv
        case mw
        case mx
        case my
        case mz
        case na
        case nc
        case ne
        case ng
        case ni
        case nl
        case no
        case np
        case nr
        case nu
        case nz
        case om
        case pa
        case pe
        case pf
        case pg
        case ph
        case pk
        case pl
        case pm
        case pn
        case pr
        case pt
        case pw
        case py
        case qa
        case re
        case ro
        case rs
        case ru
        case rw
        case sa
        case sb
        case sc
        case sd
        case se
        case sg
        case sh
        case si
        case sj
        case sk
        case sl
        case sm
        case sn
        case so
        case sr
        case st
        case sv
        case sx
        case sy
        case sz
        case tc
        case td
        case tg
        case th
        case tj
        case tk
        case tl
        case tm
        case tn
        case to
        case tr
        case tt
        case tv
        case tw
        case tz
        case ua
        case ug
        case us
        case uy
        case uz
        case va
        case vc
        case ve
        case vg
        case vi
        case vn
        case vu
        case wf
        case ws
        case ye
        case yt
        case za
        case zm
        case zw
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberCountryCode] {
            return [
                .ad,
                .ae,
                .af,
                .ag,
                .ai,
                .al,
                .am,
                .an,
                .ao,
                .aq,
                .ar,
                .as,
                .at,
                .au,
                .aw,
                .az,
                .ba,
                .bb,
                .bd,
                .be,
                .bf,
                .bg,
                .bh,
                .bi,
                .bj,
                .bl,
                .bm,
                .bn,
                .bo,
                .br,
                .bs,
                .bt,
                .bw,
                .by,
                .bz,
                .ca,
                .cc,
                .cd,
                .cf,
                .cg,
                .ch,
                .ci,
                .ck,
                .cl,
                .cm,
                .cn,
                .co,
                .cr,
                .cu,
                .cv,
                .cw,
                .cx,
                .cy,
                .cz,
                .de,
                .dj,
                .dk,
                .dm,
                .do,
                .dz,
                .ec,
                .ee,
                .eg,
                .eh,
                .er,
                .es,
                .et,
                .fi,
                .fj,
                .fk,
                .fm,
                .fo,
                .fr,
                .ga,
                .gb,
                .gd,
                .ge,
                .gg,
                .gh,
                .gi,
                .gl,
                .gm,
                .gn,
                .gq,
                .gr,
                .gt,
                .gu,
                .gw,
                .gy,
                .hk,
                .hn,
                .hr,
                .ht,
                .hu,
                .id,
                .ie,
                .il,
                .im,
                .in,
                .io,
                .iq,
                .ir,
                .is,
                .it,
                .je,
                .jm,
                .jo,
                .jp,
                .ke,
                .kg,
                .kh,
                .ki,
                .km,
                .kn,
                .kp,
                .kr,
                .kw,
                .ky,
                .kz,
                .la,
                .lb,
                .lc,
                .li,
                .lk,
                .lr,
                .ls,
                .lt,
                .lu,
                .lv,
                .ly,
                .ma,
                .mc,
                .md,
                .me,
                .mf,
                .mg,
                .mh,
                .mk,
                .ml,
                .mm,
                .mn,
                .mo,
                .mp,
                .mr,
                .ms,
                .mt,
                .mu,
                .mv,
                .mw,
                .mx,
                .my,
                .mz,
                .na,
                .nc,
                .ne,
                .ng,
                .ni,
                .nl,
                .no,
                .np,
                .nr,
                .nu,
                .nz,
                .om,
                .pa,
                .pe,
                .pf,
                .pg,
                .ph,
                .pk,
                .pl,
                .pm,
                .pn,
                .pr,
                .pt,
                .pw,
                .py,
                .qa,
                .re,
                .ro,
                .rs,
                .ru,
                .rw,
                .sa,
                .sb,
                .sc,
                .sd,
                .se,
                .sg,
                .sh,
                .si,
                .sj,
                .sk,
                .sl,
                .sm,
                .sn,
                .so,
                .sr,
                .st,
                .sv,
                .sx,
                .sy,
                .sz,
                .tc,
                .td,
                .tg,
                .th,
                .tj,
                .tk,
                .tl,
                .tm,
                .tn,
                .to,
                .tr,
                .tt,
                .tv,
                .tw,
                .tz,
                .ua,
                .ug,
                .us,
                .uy,
                .uz,
                .va,
                .vc,
                .ve,
                .vg,
                .vi,
                .vn,
                .vu,
                .wf,
                .ws,
                .ye,
                .yt,
                .za,
                .zm,
                .zw,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ad: return "AD"
            case .ae: return "AE"
            case .af: return "AF"
            case .ag: return "AG"
            case .ai: return "AI"
            case .al: return "AL"
            case .am: return "AM"
            case .an: return "AN"
            case .ao: return "AO"
            case .aq: return "AQ"
            case .ar: return "AR"
            case .as: return "AS"
            case .at: return "AT"
            case .au: return "AU"
            case .aw: return "AW"
            case .az: return "AZ"
            case .ba: return "BA"
            case .bb: return "BB"
            case .bd: return "BD"
            case .be: return "BE"
            case .bf: return "BF"
            case .bg: return "BG"
            case .bh: return "BH"
            case .bi: return "BI"
            case .bj: return "BJ"
            case .bl: return "BL"
            case .bm: return "BM"
            case .bn: return "BN"
            case .bo: return "BO"
            case .br: return "BR"
            case .bs: return "BS"
            case .bt: return "BT"
            case .bw: return "BW"
            case .by: return "BY"
            case .bz: return "BZ"
            case .ca: return "CA"
            case .cc: return "CC"
            case .cd: return "CD"
            case .cf: return "CF"
            case .cg: return "CG"
            case .ch: return "CH"
            case .ci: return "CI"
            case .ck: return "CK"
            case .cl: return "CL"
            case .cm: return "CM"
            case .cn: return "CN"
            case .co: return "CO"
            case .cr: return "CR"
            case .cu: return "CU"
            case .cv: return "CV"
            case .cw: return "CW"
            case .cx: return "CX"
            case .cy: return "CY"
            case .cz: return "CZ"
            case .de: return "DE"
            case .dj: return "DJ"
            case .dk: return "DK"
            case .dm: return "DM"
            case .do: return "DO"
            case .dz: return "DZ"
            case .ec: return "EC"
            case .ee: return "EE"
            case .eg: return "EG"
            case .eh: return "EH"
            case .er: return "ER"
            case .es: return "ES"
            case .et: return "ET"
            case .fi: return "FI"
            case .fj: return "FJ"
            case .fk: return "FK"
            case .fm: return "FM"
            case .fo: return "FO"
            case .fr: return "FR"
            case .ga: return "GA"
            case .gb: return "GB"
            case .gd: return "GD"
            case .ge: return "GE"
            case .gg: return "GG"
            case .gh: return "GH"
            case .gi: return "GI"
            case .gl: return "GL"
            case .gm: return "GM"
            case .gn: return "GN"
            case .gq: return "GQ"
            case .gr: return "GR"
            case .gt: return "GT"
            case .gu: return "GU"
            case .gw: return "GW"
            case .gy: return "GY"
            case .hk: return "HK"
            case .hn: return "HN"
            case .hr: return "HR"
            case .ht: return "HT"
            case .hu: return "HU"
            case .id: return "ID"
            case .ie: return "IE"
            case .il: return "IL"
            case .im: return "IM"
            case .in: return "IN"
            case .io: return "IO"
            case .iq: return "IQ"
            case .ir: return "IR"
            case .is: return "IS"
            case .it: return "IT"
            case .je: return "JE"
            case .jm: return "JM"
            case .jo: return "JO"
            case .jp: return "JP"
            case .ke: return "KE"
            case .kg: return "KG"
            case .kh: return "KH"
            case .ki: return "KI"
            case .km: return "KM"
            case .kn: return "KN"
            case .kp: return "KP"
            case .kr: return "KR"
            case .kw: return "KW"
            case .ky: return "KY"
            case .kz: return "KZ"
            case .la: return "LA"
            case .lb: return "LB"
            case .lc: return "LC"
            case .li: return "LI"
            case .lk: return "LK"
            case .lr: return "LR"
            case .ls: return "LS"
            case .lt: return "LT"
            case .lu: return "LU"
            case .lv: return "LV"
            case .ly: return "LY"
            case .ma: return "MA"
            case .mc: return "MC"
            case .md: return "MD"
            case .me: return "ME"
            case .mf: return "MF"
            case .mg: return "MG"
            case .mh: return "MH"
            case .mk: return "MK"
            case .ml: return "ML"
            case .mm: return "MM"
            case .mn: return "MN"
            case .mo: return "MO"
            case .mp: return "MP"
            case .mr: return "MR"
            case .ms: return "MS"
            case .mt: return "MT"
            case .mu: return "MU"
            case .mv: return "MV"
            case .mw: return "MW"
            case .mx: return "MX"
            case .my: return "MY"
            case .mz: return "MZ"
            case .na: return "NA"
            case .nc: return "NC"
            case .ne: return "NE"
            case .ng: return "NG"
            case .ni: return "NI"
            case .nl: return "NL"
            case .no: return "NO"
            case .np: return "NP"
            case .nr: return "NR"
            case .nu: return "NU"
            case .nz: return "NZ"
            case .om: return "OM"
            case .pa: return "PA"
            case .pe: return "PE"
            case .pf: return "PF"
            case .pg: return "PG"
            case .ph: return "PH"
            case .pk: return "PK"
            case .pl: return "PL"
            case .pm: return "PM"
            case .pn: return "PN"
            case .pr: return "PR"
            case .pt: return "PT"
            case .pw: return "PW"
            case .py: return "PY"
            case .qa: return "QA"
            case .re: return "RE"
            case .ro: return "RO"
            case .rs: return "RS"
            case .ru: return "RU"
            case .rw: return "RW"
            case .sa: return "SA"
            case .sb: return "SB"
            case .sc: return "SC"
            case .sd: return "SD"
            case .se: return "SE"
            case .sg: return "SG"
            case .sh: return "SH"
            case .si: return "SI"
            case .sj: return "SJ"
            case .sk: return "SK"
            case .sl: return "SL"
            case .sm: return "SM"
            case .sn: return "SN"
            case .so: return "SO"
            case .sr: return "SR"
            case .st: return "ST"
            case .sv: return "SV"
            case .sx: return "SX"
            case .sy: return "SY"
            case .sz: return "SZ"
            case .tc: return "TC"
            case .td: return "TD"
            case .tg: return "TG"
            case .th: return "TH"
            case .tj: return "TJ"
            case .tk: return "TK"
            case .tl: return "TL"
            case .tm: return "TM"
            case .tn: return "TN"
            case .to: return "TO"
            case .tr: return "TR"
            case .tt: return "TT"
            case .tv: return "TV"
            case .tw: return "TW"
            case .tz: return "TZ"
            case .ua: return "UA"
            case .ug: return "UG"
            case .us: return "US"
            case .uy: return "UY"
            case .uz: return "UZ"
            case .va: return "VA"
            case .vc: return "VC"
            case .ve: return "VE"
            case .vg: return "VG"
            case .vi: return "VI"
            case .vn: return "VN"
            case .vu: return "VU"
            case .wf: return "WF"
            case .ws: return "WS"
            case .ye: return "YE"
            case .yt: return "YT"
            case .za: return "ZA"
            case .zm: return "ZM"
            case .zw: return "ZW"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhoneNumberCountryCode(rawValue: rawValue) ?? PhoneNumberCountryCode.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.PhoneNumberQuickConnectConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumber = "PhoneNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let phoneNumber = self.phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about a phone number for a quick connect.
    public struct PhoneNumberQuickConnectConfig: Swift.Equatable {
        /// The phone number in E.164 format.
        /// This member is required.
        public var phoneNumber: Swift.String?

        public init(
            phoneNumber: Swift.String? = nil
        )
        {
            self.phoneNumber = phoneNumber
        }
    }

}

extension ConnectClientTypes.PhoneNumberStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.PhoneNumberWorkflowStatus.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectClientTypes {
    /// The status of the phone number.
    ///
    /// * CLAIMED means the previous [ClaimPhoneNumber](https://docs.aws.amazon.com/connect/latest/APIReference/API_ClaimPhoneNumber.html) or [UpdatePhoneNumber](https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumber.html) operation succeeded.
    ///
    /// * IN_PROGRESS means a [ClaimPhoneNumber](https://docs.aws.amazon.com/connect/latest/APIReference/API_ClaimPhoneNumber.html), [UpdatePhoneNumber](https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumber.html), or [UpdatePhoneNumberMetadata](https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumberMetadata.html) operation is still in progress and has not yet completed. You can call [DescribePhoneNumber](https://docs.aws.amazon.com/connect/latest/APIReference/API_DescribePhoneNumber.html) at a later time to verify if the previous operation has completed.
    ///
    /// * FAILED indicates that the previous [ClaimPhoneNumber](https://docs.aws.amazon.com/connect/latest/APIReference/API_ClaimPhoneNumber.html) or [UpdatePhoneNumber](https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumber.html) operation has failed. It will include a message indicating the failure reason. A common reason for a failure may be that the TargetArn value you are claiming or updating a phone number to has reached its limit of total claimed numbers. If you received a FAILED status from a ClaimPhoneNumber API call, you have one day to retry claiming the phone number before the number is released back to the inventory for other customers to claim.
    public struct PhoneNumberStatus: Swift.Equatable {
        /// The status message.
        public var message: Swift.String?
        /// The status.
        public var status: ConnectClientTypes.PhoneNumberWorkflowStatus?

        public init(
            message: Swift.String? = nil,
            status: ConnectClientTypes.PhoneNumberWorkflowStatus? = nil
        )
        {
            self.message = message
            self.status = status
        }
    }

}

extension ConnectClientTypes.PhoneNumberSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case phoneNumber = "PhoneNumber"
        case phoneNumberCountryCode = "PhoneNumberCountryCode"
        case phoneNumberType = "PhoneNumberType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let phoneNumber = self.phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let phoneNumberCountryCode = self.phoneNumberCountryCode {
            try encodeContainer.encode(phoneNumberCountryCode.rawValue, forKey: .phoneNumberCountryCode)
        }
        if let phoneNumberType = self.phoneNumberType {
            try encodeContainer.encode(phoneNumberType.rawValue, forKey: .phoneNumberType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let phoneNumberTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.PhoneNumberType.self, forKey: .phoneNumberType)
        phoneNumberType = phoneNumberTypeDecoded
        let phoneNumberCountryCodeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.PhoneNumberCountryCode.self, forKey: .phoneNumberCountryCode)
        phoneNumberCountryCode = phoneNumberCountryCodeDecoded
    }
}

extension ConnectClientTypes {
    /// Contains summary information about a phone number for a contact center.
    public struct PhoneNumberSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the phone number.
        public var arn: Swift.String?
        /// The identifier of the phone number.
        public var id: Swift.String?
        /// The phone number.
        public var phoneNumber: Swift.String?
        /// The ISO country code.
        public var phoneNumberCountryCode: ConnectClientTypes.PhoneNumberCountryCode?
        /// The type of phone number.
        public var phoneNumberType: ConnectClientTypes.PhoneNumberType?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            phoneNumber: Swift.String? = nil,
            phoneNumberCountryCode: ConnectClientTypes.PhoneNumberCountryCode? = nil,
            phoneNumberType: ConnectClientTypes.PhoneNumberType? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.phoneNumber = phoneNumber
            self.phoneNumberCountryCode = phoneNumberCountryCode
            self.phoneNumberType = phoneNumberType
        }
    }

}

extension ConnectClientTypes {
    public enum PhoneNumberType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case did
        case shared
        case shortCode
        case thirdPartyDid
        case thirdPartyTf
        case tollFree
        case uifn
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberType] {
            return [
                .did,
                .shared,
                .shortCode,
                .thirdPartyDid,
                .thirdPartyTf,
                .tollFree,
                .uifn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .did: return "DID"
            case .shared: return "SHARED"
            case .shortCode: return "SHORT_CODE"
            case .thirdPartyDid: return "THIRD_PARTY_DID"
            case .thirdPartyTf: return "THIRD_PARTY_TF"
            case .tollFree: return "TOLL_FREE"
            case .uifn: return "UIFN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhoneNumberType(rawValue: rawValue) ?? PhoneNumberType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes {
    public enum PhoneNumberWorkflowStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case claimed
        case failed
        case inprogress
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberWorkflowStatus] {
            return [
                .claimed,
                .failed,
                .inprogress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .claimed: return "CLAIMED"
            case .failed: return "FAILED"
            case .inprogress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhoneNumberWorkflowStatus(rawValue: rawValue) ?? PhoneNumberWorkflowStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes {
    public enum PhoneType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deskPhone
        case softPhone
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneType] {
            return [
                .deskPhone,
                .softPhone,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deskPhone: return "DESK_PHONE"
            case .softPhone: return "SOFT_PHONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhoneType(rawValue: rawValue) ?? PhoneType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.ProblemDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectClientTypes {
    /// Information about a problem detail.
    public struct ProblemDetail: Swift.Equatable {
        /// The problem detail's message.
        public var message: Swift.String?

        public init(
            message: Swift.String? = nil
        )
        {
            self.message = message
        }
    }

}

extension ConnectClientTypes.Prompt: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case lastModifiedRegion = "LastModifiedRegion"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case promptARN = "PromptARN"
        case promptId = "PromptId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModifiedRegion = self.lastModifiedRegion {
            try encodeContainer.encode(lastModifiedRegion, forKey: .lastModifiedRegion)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let promptARN = self.promptARN {
            try encodeContainer.encode(promptARN, forKey: .promptARN)
        }
        if let promptId = self.promptId {
            try encodeContainer.encode(promptId, forKey: .promptId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let promptARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .promptARN)
        promptARN = promptARNDecoded
        let promptIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .promptId)
        promptId = promptIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastModifiedRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedRegion)
        lastModifiedRegion = lastModifiedRegionDecoded
    }
}

extension ConnectClientTypes {
    /// Information about a prompt.
    public struct Prompt: Swift.Equatable {
        /// The description of the prompt.
        public var description: Swift.String?
        /// The Amazon Web Services Region where this resource was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when this resource was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name of the prompt.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the prompt.
        public var promptARN: Swift.String?
        /// A unique identifier for the prompt.
        public var promptId: Swift.String?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public var tags: [Swift.String:Swift.String]?

        public init(
            description: Swift.String? = nil,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            promptARN: Swift.String? = nil,
            promptId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.description = description
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.promptARN = promptARN
            self.promptId = promptId
            self.tags = tags
        }
    }

}

extension ConnectClientTypes.PromptSearchCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case andConditions = "AndConditions"
        case orConditions = "OrConditions"
        case stringCondition = "StringCondition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let andConditions = andConditions {
            var andConditionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .andConditions)
            for promptsearchcriteria0 in andConditions {
                try andConditionsContainer.encode(promptsearchcriteria0)
            }
        }
        if let orConditions = orConditions {
            var orConditionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .orConditions)
            for promptsearchcriteria0 in orConditions {
                try orConditionsContainer.encode(promptsearchcriteria0)
            }
        }
        if let stringCondition = self.stringCondition {
            try encodeContainer.encode(stringCondition, forKey: .stringCondition)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orConditionsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.PromptSearchCriteria?].self, forKey: .orConditions)
        var orConditionsDecoded0:[ConnectClientTypes.PromptSearchCriteria]? = nil
        if let orConditionsContainer = orConditionsContainer {
            orConditionsDecoded0 = [ConnectClientTypes.PromptSearchCriteria]()
            for structure0 in orConditionsContainer {
                if let structure0 = structure0 {
                    orConditionsDecoded0?.append(structure0)
                }
            }
        }
        orConditions = orConditionsDecoded0
        let andConditionsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.PromptSearchCriteria?].self, forKey: .andConditions)
        var andConditionsDecoded0:[ConnectClientTypes.PromptSearchCriteria]? = nil
        if let andConditionsContainer = andConditionsContainer {
            andConditionsDecoded0 = [ConnectClientTypes.PromptSearchCriteria]()
            for structure0 in andConditionsContainer {
                if let structure0 = structure0 {
                    andConditionsDecoded0?.append(structure0)
                }
            }
        }
        andConditions = andConditionsDecoded0
        let stringConditionDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.StringCondition.self, forKey: .stringCondition)
        stringCondition = stringConditionDecoded
    }
}

extension ConnectClientTypes {
    /// The search criteria to be used to return prompts.
    public struct PromptSearchCriteria: Swift.Equatable {
        /// A list of conditions which would be applied together with an AND condition.
        public var andConditions: [ConnectClientTypes.PromptSearchCriteria]?
        /// A list of conditions which would be applied together with an OR condition.
        public var orConditions: [ConnectClientTypes.PromptSearchCriteria]?
        /// A leaf node condition which can be used to specify a string condition. The currently supported values for FieldName are name, description, and resourceID.
        public var stringCondition: ConnectClientTypes.StringCondition?

        public init(
            andConditions: [ConnectClientTypes.PromptSearchCriteria]? = nil,
            orConditions: [ConnectClientTypes.PromptSearchCriteria]? = nil,
            stringCondition: ConnectClientTypes.StringCondition? = nil
        )
        {
            self.andConditions = andConditions
            self.orConditions = orConditions
            self.stringCondition = stringCondition
        }
    }

}

extension ConnectClientTypes.PromptSearchFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagFilter = "TagFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagFilter = self.tagFilter {
            try encodeContainer.encode(tagFilter, forKey: .tagFilter)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagFilterDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ControlPlaneTagFilter.self, forKey: .tagFilter)
        tagFilter = tagFilterDecoded
    }
}

extension ConnectClientTypes {
    /// Filters to be applied to search results.
    public struct PromptSearchFilter: Swift.Equatable {
        /// An object that can be used to specify Tag conditions inside the SearchFilter. This accepts an OR of AND (List of List) input where:
        ///
        /// * Top level list specifies conditions that need to be applied with OR operator
        ///
        /// * Inner list specifies conditions that need to be applied with AND operator.
        public var tagFilter: ConnectClientTypes.ControlPlaneTagFilter?

        public init(
            tagFilter: ConnectClientTypes.ControlPlaneTagFilter? = nil
        )
        {
            self.tagFilter = tagFilter
        }
    }

}

extension ConnectClientTypes.PromptSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case lastModifiedRegion = "LastModifiedRegion"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastModifiedRegion = self.lastModifiedRegion {
            try encodeContainer.encode(lastModifiedRegion, forKey: .lastModifiedRegion)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastModifiedRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedRegion)
        lastModifiedRegion = lastModifiedRegionDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about the prompt.
    public struct PromptSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the prompt.
        public var arn: Swift.String?
        /// The identifier of the prompt.
        public var id: Swift.String?
        /// The Amazon Web Services Region where this resource was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when this resource was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name of the prompt.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
        }
    }

}

extension PropertyValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PropertyValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.propertyList = output.propertyList
        } else {
            self.properties.message = nil
            self.properties.propertyList = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The property is not valid.
public struct PropertyValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        public internal(set) var propertyList: [ConnectClientTypes.PropertyValidationExceptionProperty]? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PropertyValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        propertyList: [ConnectClientTypes.PropertyValidationExceptionProperty]? = nil
    )
    {
        self.properties.message = message
        self.properties.propertyList = propertyList
    }
}

struct PropertyValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let propertyList: [ConnectClientTypes.PropertyValidationExceptionProperty]?
}

extension PropertyValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case propertyList = "PropertyList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let propertyListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.PropertyValidationExceptionProperty?].self, forKey: .propertyList)
        var propertyListDecoded0:[ConnectClientTypes.PropertyValidationExceptionProperty]? = nil
        if let propertyListContainer = propertyListContainer {
            propertyListDecoded0 = [ConnectClientTypes.PropertyValidationExceptionProperty]()
            for structure0 in propertyListContainer {
                if let structure0 = structure0 {
                    propertyListDecoded0?.append(structure0)
                }
            }
        }
        propertyList = propertyListDecoded0
    }
}

extension ConnectClientTypes.PropertyValidationExceptionProperty: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case propertyPath = "PropertyPath"
        case reason = "Reason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let propertyPath = self.propertyPath {
            try encodeContainer.encode(propertyPath, forKey: .propertyPath)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyPath)
        propertyPath = propertyPathDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.PropertyValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about why a property is not valid.
    public struct PropertyValidationExceptionProperty: Swift.Equatable {
        /// A message describing why the property is not valid.
        /// This member is required.
        public var message: Swift.String?
        /// The full property path.
        /// This member is required.
        public var propertyPath: Swift.String?
        /// Why the property is not valid.
        /// This member is required.
        public var reason: ConnectClientTypes.PropertyValidationExceptionReason?

        public init(
            message: Swift.String? = nil,
            propertyPath: Swift.String? = nil,
            reason: ConnectClientTypes.PropertyValidationExceptionReason? = nil
        )
        {
            self.message = message
            self.propertyPath = propertyPath
            self.reason = reason
        }
    }

}

extension ConnectClientTypes {
    public enum PropertyValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case invalidFormat
        case notSupported
        case referencedResourceNotFound
        case requiredPropertyMissing
        case resourceNameAlreadyExists
        case uniqueConstraintViolated
        case sdkUnknown(Swift.String)

        public static var allCases: [PropertyValidationExceptionReason] {
            return [
                .invalidFormat,
                .notSupported,
                .referencedResourceNotFound,
                .requiredPropertyMissing,
                .resourceNameAlreadyExists,
                .uniqueConstraintViolated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .invalidFormat: return "INVALID_FORMAT"
            case .notSupported: return "NOT_SUPPORTED"
            case .referencedResourceNotFound: return "REFERENCED_RESOURCE_NOT_FOUND"
            case .requiredPropertyMissing: return "REQUIRED_PROPERTY_MISSING"
            case .resourceNameAlreadyExists: return "RESOURCE_NAME_ALREADY_EXISTS"
            case .uniqueConstraintViolated: return "UNIQUE_CONSTRAINT_VIOLATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PropertyValidationExceptionReason(rawValue: rawValue) ?? PropertyValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension PutUserStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentStatusId = "AgentStatusId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentStatusId = self.agentStatusId {
            try encodeContainer.encode(agentStatusId, forKey: .agentStatusId)
        }
    }
}

extension PutUserStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let userId = userId else {
            return nil
        }
        return "/users/\(instanceId.urlPercentEncoding())/\(userId.urlPercentEncoding())/status"
    }
}

public struct PutUserStatusInput: Swift.Equatable {
    /// The identifier of the agent status.
    /// This member is required.
    public var agentStatusId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the user.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        agentStatusId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.agentStatusId = agentStatusId
        self.instanceId = instanceId
        self.userId = userId
    }
}

struct PutUserStatusInputBody: Swift.Equatable {
    let agentStatusId: Swift.String?
}

extension PutUserStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentStatusId = "AgentStatusId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentStatusIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentStatusId)
        agentStatusId = agentStatusIdDecoded
    }
}

extension PutUserStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutUserStatusOutput: Swift.Equatable {

    public init() { }
}

enum PutUserStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectClientTypes.Queue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case hoursOfOperationId = "HoursOfOperationId"
        case lastModifiedRegion = "LastModifiedRegion"
        case lastModifiedTime = "LastModifiedTime"
        case maxContacts = "MaxContacts"
        case name = "Name"
        case outboundCallerConfig = "OutboundCallerConfig"
        case queueArn = "QueueArn"
        case queueId = "QueueId"
        case status = "Status"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let hoursOfOperationId = self.hoursOfOperationId {
            try encodeContainer.encode(hoursOfOperationId, forKey: .hoursOfOperationId)
        }
        if let lastModifiedRegion = self.lastModifiedRegion {
            try encodeContainer.encode(lastModifiedRegion, forKey: .lastModifiedRegion)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let maxContacts = self.maxContacts {
            try encodeContainer.encode(maxContacts, forKey: .maxContacts)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outboundCallerConfig = self.outboundCallerConfig {
            try encodeContainer.encode(outboundCallerConfig, forKey: .outboundCallerConfig)
        }
        if let queueArn = self.queueArn {
            try encodeContainer.encode(queueArn, forKey: .queueArn)
        }
        if let queueId = self.queueId {
            try encodeContainer.encode(queueId, forKey: .queueId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let queueArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueArn)
        queueArn = queueArnDecoded
        let queueIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueId)
        queueId = queueIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let outboundCallerConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.OutboundCallerConfig.self, forKey: .outboundCallerConfig)
        outboundCallerConfig = outboundCallerConfigDecoded
        let hoursOfOperationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hoursOfOperationId)
        hoursOfOperationId = hoursOfOperationIdDecoded
        let maxContactsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxContacts)
        maxContacts = maxContactsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.QueueStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastModifiedRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedRegion)
        lastModifiedRegion = lastModifiedRegionDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about a queue.
    public struct Queue: Swift.Equatable {
        /// The description of the queue.
        public var description: Swift.String?
        /// The identifier for the hours of operation.
        public var hoursOfOperationId: Swift.String?
        /// The Amazon Web Services Region where this resource was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when this resource was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The maximum number of contacts that can be in the queue before it is considered full.
        public var maxContacts: Swift.Int?
        /// The name of the queue.
        public var name: Swift.String?
        /// The outbound caller ID name, number, and outbound whisper flow.
        public var outboundCallerConfig: ConnectClientTypes.OutboundCallerConfig?
        /// The Amazon Resource Name (ARN) for the queue.
        public var queueArn: Swift.String?
        /// The identifier for the queue.
        public var queueId: Swift.String?
        /// The status of the queue.
        public var status: ConnectClientTypes.QueueStatus?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public var tags: [Swift.String:Swift.String]?

        public init(
            description: Swift.String? = nil,
            hoursOfOperationId: Swift.String? = nil,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            maxContacts: Swift.Int? = nil,
            name: Swift.String? = nil,
            outboundCallerConfig: ConnectClientTypes.OutboundCallerConfig? = nil,
            queueArn: Swift.String? = nil,
            queueId: Swift.String? = nil,
            status: ConnectClientTypes.QueueStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.description = description
            self.hoursOfOperationId = hoursOfOperationId
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.maxContacts = maxContacts
            self.name = name
            self.outboundCallerConfig = outboundCallerConfig
            self.queueArn = queueArn
            self.queueId = queueId
            self.status = status
            self.tags = tags
        }
    }

}

extension ConnectClientTypes.QueueInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enqueueTimestamp = "EnqueueTimestamp"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enqueueTimestamp = self.enqueueTimestamp {
            try encodeContainer.encodeTimestamp(enqueueTimestamp, format: .epochSeconds, forKey: .enqueueTimestamp)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let enqueueTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .enqueueTimestamp)
        enqueueTimestamp = enqueueTimestampDecoded
    }
}

extension ConnectClientTypes {
    /// If this contact was queued, this contains information about the queue.
    public struct QueueInfo: Swift.Equatable {
        /// The timestamp when the contact was added to the queue.
        public var enqueueTimestamp: ClientRuntime.Date?
        /// The unique identifier for the queue.
        public var id: Swift.String?

        public init(
            enqueueTimestamp: ClientRuntime.Date? = nil,
            id: Swift.String? = nil
        )
        {
            self.enqueueTimestamp = enqueueTimestamp
            self.id = id
        }
    }

}

extension ConnectClientTypes.QueueQuickConnectConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactFlowId = "ContactFlowId"
        case queueId = "QueueId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactFlowId = self.contactFlowId {
            try encodeContainer.encode(contactFlowId, forKey: .contactFlowId)
        }
        if let queueId = self.queueId {
            try encodeContainer.encode(queueId, forKey: .queueId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueId)
        queueId = queueIdDecoded
        let contactFlowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactFlowId)
        contactFlowId = contactFlowIdDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about a queue for a quick connect. The flow must be of type Transfer to Queue.
    public struct QueueQuickConnectConfig: Swift.Equatable {
        /// The identifier of the flow.
        /// This member is required.
        public var contactFlowId: Swift.String?
        /// The identifier for the queue.
        /// This member is required.
        public var queueId: Swift.String?

        public init(
            contactFlowId: Swift.String? = nil,
            queueId: Swift.String? = nil
        )
        {
            self.contactFlowId = contactFlowId
            self.queueId = queueId
        }
    }

}

extension ConnectClientTypes.QueueReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about a queue resource for which metrics are returned.
    public struct QueueReference: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the queue.
        public var arn: Swift.String?
        /// The identifier of the queue.
        public var id: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
        }
    }

}

extension ConnectClientTypes.QueueSearchCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case andConditions = "AndConditions"
        case orConditions = "OrConditions"
        case queueTypeCondition = "QueueTypeCondition"
        case stringCondition = "StringCondition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let andConditions = andConditions {
            var andConditionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .andConditions)
            for queuesearchcriteria0 in andConditions {
                try andConditionsContainer.encode(queuesearchcriteria0)
            }
        }
        if let orConditions = orConditions {
            var orConditionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .orConditions)
            for queuesearchcriteria0 in orConditions {
                try orConditionsContainer.encode(queuesearchcriteria0)
            }
        }
        if let queueTypeCondition = self.queueTypeCondition {
            try encodeContainer.encode(queueTypeCondition.rawValue, forKey: .queueTypeCondition)
        }
        if let stringCondition = self.stringCondition {
            try encodeContainer.encode(stringCondition, forKey: .stringCondition)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orConditionsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.QueueSearchCriteria?].self, forKey: .orConditions)
        var orConditionsDecoded0:[ConnectClientTypes.QueueSearchCriteria]? = nil
        if let orConditionsContainer = orConditionsContainer {
            orConditionsDecoded0 = [ConnectClientTypes.QueueSearchCriteria]()
            for structure0 in orConditionsContainer {
                if let structure0 = structure0 {
                    orConditionsDecoded0?.append(structure0)
                }
            }
        }
        orConditions = orConditionsDecoded0
        let andConditionsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.QueueSearchCriteria?].self, forKey: .andConditions)
        var andConditionsDecoded0:[ConnectClientTypes.QueueSearchCriteria]? = nil
        if let andConditionsContainer = andConditionsContainer {
            andConditionsDecoded0 = [ConnectClientTypes.QueueSearchCriteria]()
            for structure0 in andConditionsContainer {
                if let structure0 = structure0 {
                    andConditionsDecoded0?.append(structure0)
                }
            }
        }
        andConditions = andConditionsDecoded0
        let stringConditionDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.StringCondition.self, forKey: .stringCondition)
        stringCondition = stringConditionDecoded
        let queueTypeConditionDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.SearchableQueueType.self, forKey: .queueTypeCondition)
        queueTypeCondition = queueTypeConditionDecoded
    }
}

extension ConnectClientTypes {
    /// The search criteria to be used to return queues. The name and description fields support "contains" queries with a minimum of 2 characters and a maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results.
    public struct QueueSearchCriteria: Swift.Equatable {
        /// A list of conditions which would be applied together with an AND condition.
        public var andConditions: [ConnectClientTypes.QueueSearchCriteria]?
        /// A list of conditions which would be applied together with an OR condition.
        public var orConditions: [ConnectClientTypes.QueueSearchCriteria]?
        /// The type of queue.
        public var queueTypeCondition: ConnectClientTypes.SearchableQueueType?
        /// A leaf node condition which can be used to specify a string condition. The currently supported values for FieldName are name, description, and resourceID.
        public var stringCondition: ConnectClientTypes.StringCondition?

        public init(
            andConditions: [ConnectClientTypes.QueueSearchCriteria]? = nil,
            orConditions: [ConnectClientTypes.QueueSearchCriteria]? = nil,
            queueTypeCondition: ConnectClientTypes.SearchableQueueType? = nil,
            stringCondition: ConnectClientTypes.StringCondition? = nil
        )
        {
            self.andConditions = andConditions
            self.orConditions = orConditions
            self.queueTypeCondition = queueTypeCondition
            self.stringCondition = stringCondition
        }
    }

}

extension ConnectClientTypes.QueueSearchFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagFilter = "TagFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagFilter = self.tagFilter {
            try encodeContainer.encode(tagFilter, forKey: .tagFilter)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagFilterDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ControlPlaneTagFilter.self, forKey: .tagFilter)
        tagFilter = tagFilterDecoded
    }
}

extension ConnectClientTypes {
    /// Filters to be applied to search results.
    public struct QueueSearchFilter: Swift.Equatable {
        /// An object that can be used to specify Tag conditions inside the SearchFilter. This accepts an OR of AND (List of List) input where:
        ///
        /// * Top level list specifies conditions that need to be applied with OR operator
        ///
        /// * Inner list specifies conditions that need to be applied with AND operator.
        public var tagFilter: ConnectClientTypes.ControlPlaneTagFilter?

        public init(
            tagFilter: ConnectClientTypes.ControlPlaneTagFilter? = nil
        )
        {
            self.tagFilter = tagFilter
        }
    }

}

extension ConnectClientTypes {
    public enum QueueStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [QueueStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QueueStatus(rawValue: rawValue) ?? QueueStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.QueueSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case lastModifiedRegion = "LastModifiedRegion"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case queueType = "QueueType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastModifiedRegion = self.lastModifiedRegion {
            try encodeContainer.encode(lastModifiedRegion, forKey: .lastModifiedRegion)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let queueType = self.queueType {
            try encodeContainer.encode(queueType.rawValue, forKey: .queueType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let queueTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.QueueType.self, forKey: .queueType)
        queueType = queueTypeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastModifiedRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedRegion)
        lastModifiedRegion = lastModifiedRegionDecoded
    }
}

extension ConnectClientTypes {
    /// Contains summary information about a queue.
    public struct QueueSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the queue.
        public var arn: Swift.String?
        /// The identifier of the queue.
        public var id: Swift.String?
        /// The Amazon Web Services Region where this resource was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when this resource was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name of the queue.
        public var name: Swift.String?
        /// The type of queue.
        public var queueType: ConnectClientTypes.QueueType?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            queueType: ConnectClientTypes.QueueType? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.queueType = queueType
        }
    }

}

extension ConnectClientTypes {
    public enum QueueType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case agent
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [QueueType] {
            return [
                .agent,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agent: return "AGENT"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QueueType(rawValue: rawValue) ?? QueueType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.QuickConnect: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case lastModifiedRegion = "LastModifiedRegion"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case quickConnectARN = "QuickConnectARN"
        case quickConnectConfig = "QuickConnectConfig"
        case quickConnectId = "QuickConnectId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModifiedRegion = self.lastModifiedRegion {
            try encodeContainer.encode(lastModifiedRegion, forKey: .lastModifiedRegion)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let quickConnectARN = self.quickConnectARN {
            try encodeContainer.encode(quickConnectARN, forKey: .quickConnectARN)
        }
        if let quickConnectConfig = self.quickConnectConfig {
            try encodeContainer.encode(quickConnectConfig, forKey: .quickConnectConfig)
        }
        if let quickConnectId = self.quickConnectId {
            try encodeContainer.encode(quickConnectId, forKey: .quickConnectId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quickConnectARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quickConnectARN)
        quickConnectARN = quickConnectARNDecoded
        let quickConnectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quickConnectId)
        quickConnectId = quickConnectIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let quickConnectConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.QuickConnectConfig.self, forKey: .quickConnectConfig)
        quickConnectConfig = quickConnectConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastModifiedRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedRegion)
        lastModifiedRegion = lastModifiedRegionDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about a quick connect.
    public struct QuickConnect: Swift.Equatable {
        /// The description.
        public var description: Swift.String?
        /// The Amazon Web Services Region where this resource was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when this resource was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name of the quick connect.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the quick connect.
        public var quickConnectARN: Swift.String?
        /// Contains information about the quick connect.
        public var quickConnectConfig: ConnectClientTypes.QuickConnectConfig?
        /// The identifier for the quick connect.
        public var quickConnectId: Swift.String?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public var tags: [Swift.String:Swift.String]?

        public init(
            description: Swift.String? = nil,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            quickConnectARN: Swift.String? = nil,
            quickConnectConfig: ConnectClientTypes.QuickConnectConfig? = nil,
            quickConnectId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.description = description
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.quickConnectARN = quickConnectARN
            self.quickConnectConfig = quickConnectConfig
            self.quickConnectId = quickConnectId
            self.tags = tags
        }
    }

}

extension ConnectClientTypes.QuickConnectConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneConfig = "PhoneConfig"
        case queueConfig = "QueueConfig"
        case quickConnectType = "QuickConnectType"
        case userConfig = "UserConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let phoneConfig = self.phoneConfig {
            try encodeContainer.encode(phoneConfig, forKey: .phoneConfig)
        }
        if let queueConfig = self.queueConfig {
            try encodeContainer.encode(queueConfig, forKey: .queueConfig)
        }
        if let quickConnectType = self.quickConnectType {
            try encodeContainer.encode(quickConnectType.rawValue, forKey: .quickConnectType)
        }
        if let userConfig = self.userConfig {
            try encodeContainer.encode(userConfig, forKey: .userConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quickConnectTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.QuickConnectType.self, forKey: .quickConnectType)
        quickConnectType = quickConnectTypeDecoded
        let userConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.UserQuickConnectConfig.self, forKey: .userConfig)
        userConfig = userConfigDecoded
        let queueConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.QueueQuickConnectConfig.self, forKey: .queueConfig)
        queueConfig = queueConfigDecoded
        let phoneConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.PhoneNumberQuickConnectConfig.self, forKey: .phoneConfig)
        phoneConfig = phoneConfigDecoded
    }
}

extension ConnectClientTypes {
    /// Contains configuration settings for a quick connect.
    public struct QuickConnectConfig: Swift.Equatable {
        /// The phone configuration. This is required only if QuickConnectType is PHONE_NUMBER.
        public var phoneConfig: ConnectClientTypes.PhoneNumberQuickConnectConfig?
        /// The queue configuration. This is required only if QuickConnectType is QUEUE.
        public var queueConfig: ConnectClientTypes.QueueQuickConnectConfig?
        /// The type of quick connect. In the Amazon Connect admin website, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE).
        /// This member is required.
        public var quickConnectType: ConnectClientTypes.QuickConnectType?
        /// The user configuration. This is required only if QuickConnectType is USER.
        public var userConfig: ConnectClientTypes.UserQuickConnectConfig?

        public init(
            phoneConfig: ConnectClientTypes.PhoneNumberQuickConnectConfig? = nil,
            queueConfig: ConnectClientTypes.QueueQuickConnectConfig? = nil,
            quickConnectType: ConnectClientTypes.QuickConnectType? = nil,
            userConfig: ConnectClientTypes.UserQuickConnectConfig? = nil
        )
        {
            self.phoneConfig = phoneConfig
            self.queueConfig = queueConfig
            self.quickConnectType = quickConnectType
            self.userConfig = userConfig
        }
    }

}

extension ConnectClientTypes.QuickConnectSearchCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case andConditions = "AndConditions"
        case orConditions = "OrConditions"
        case stringCondition = "StringCondition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let andConditions = andConditions {
            var andConditionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .andConditions)
            for quickconnectsearchcriteria0 in andConditions {
                try andConditionsContainer.encode(quickconnectsearchcriteria0)
            }
        }
        if let orConditions = orConditions {
            var orConditionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .orConditions)
            for quickconnectsearchcriteria0 in orConditions {
                try orConditionsContainer.encode(quickconnectsearchcriteria0)
            }
        }
        if let stringCondition = self.stringCondition {
            try encodeContainer.encode(stringCondition, forKey: .stringCondition)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orConditionsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.QuickConnectSearchCriteria?].self, forKey: .orConditions)
        var orConditionsDecoded0:[ConnectClientTypes.QuickConnectSearchCriteria]? = nil
        if let orConditionsContainer = orConditionsContainer {
            orConditionsDecoded0 = [ConnectClientTypes.QuickConnectSearchCriteria]()
            for structure0 in orConditionsContainer {
                if let structure0 = structure0 {
                    orConditionsDecoded0?.append(structure0)
                }
            }
        }
        orConditions = orConditionsDecoded0
        let andConditionsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.QuickConnectSearchCriteria?].self, forKey: .andConditions)
        var andConditionsDecoded0:[ConnectClientTypes.QuickConnectSearchCriteria]? = nil
        if let andConditionsContainer = andConditionsContainer {
            andConditionsDecoded0 = [ConnectClientTypes.QuickConnectSearchCriteria]()
            for structure0 in andConditionsContainer {
                if let structure0 = structure0 {
                    andConditionsDecoded0?.append(structure0)
                }
            }
        }
        andConditions = andConditionsDecoded0
        let stringConditionDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.StringCondition.self, forKey: .stringCondition)
        stringCondition = stringConditionDecoded
    }
}

extension ConnectClientTypes {
    /// The search criteria to be used to return quick connects.
    public struct QuickConnectSearchCriteria: Swift.Equatable {
        /// A list of conditions which would be applied together with an AND condition.
        public var andConditions: [ConnectClientTypes.QuickConnectSearchCriteria]?
        /// A list of conditions which would be applied together with an OR condition.
        public var orConditions: [ConnectClientTypes.QuickConnectSearchCriteria]?
        /// A leaf node condition which can be used to specify a string condition. The currently supported values for FieldName are name, description, and resourceID.
        public var stringCondition: ConnectClientTypes.StringCondition?

        public init(
            andConditions: [ConnectClientTypes.QuickConnectSearchCriteria]? = nil,
            orConditions: [ConnectClientTypes.QuickConnectSearchCriteria]? = nil,
            stringCondition: ConnectClientTypes.StringCondition? = nil
        )
        {
            self.andConditions = andConditions
            self.orConditions = orConditions
            self.stringCondition = stringCondition
        }
    }

}

extension ConnectClientTypes.QuickConnectSearchFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagFilter = "TagFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagFilter = self.tagFilter {
            try encodeContainer.encode(tagFilter, forKey: .tagFilter)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagFilterDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ControlPlaneTagFilter.self, forKey: .tagFilter)
        tagFilter = tagFilterDecoded
    }
}

extension ConnectClientTypes {
    /// Filters to be applied to search results.
    public struct QuickConnectSearchFilter: Swift.Equatable {
        /// An object that can be used to specify Tag conditions inside the SearchFilter. This accepts an OR of AND (List of List) input where:
        ///
        /// * Top level list specifies conditions that need to be applied with OR operator
        ///
        /// * Inner list specifies conditions that need to be applied with AND operator.
        public var tagFilter: ConnectClientTypes.ControlPlaneTagFilter?

        public init(
            tagFilter: ConnectClientTypes.ControlPlaneTagFilter? = nil
        )
        {
            self.tagFilter = tagFilter
        }
    }

}

extension ConnectClientTypes.QuickConnectSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case lastModifiedRegion = "LastModifiedRegion"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case quickConnectType = "QuickConnectType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastModifiedRegion = self.lastModifiedRegion {
            try encodeContainer.encode(lastModifiedRegion, forKey: .lastModifiedRegion)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let quickConnectType = self.quickConnectType {
            try encodeContainer.encode(quickConnectType.rawValue, forKey: .quickConnectType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let quickConnectTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.QuickConnectType.self, forKey: .quickConnectType)
        quickConnectType = quickConnectTypeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastModifiedRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedRegion)
        lastModifiedRegion = lastModifiedRegionDecoded
    }
}

extension ConnectClientTypes {
    /// Contains summary information about a quick connect.
    public struct QuickConnectSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the quick connect.
        public var arn: Swift.String?
        /// The identifier for the quick connect.
        public var id: Swift.String?
        /// The Amazon Web Services Region where this resource was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when this resource was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name of the quick connect.
        public var name: Swift.String?
        /// The type of quick connect. In the Amazon Connect admin website, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE).
        public var quickConnectType: ConnectClientTypes.QuickConnectType?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            quickConnectType: ConnectClientTypes.QuickConnectType? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.quickConnectType = quickConnectType
        }
    }

}

extension ConnectClientTypes {
    public enum QuickConnectType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case phoneNumber
        case queue
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [QuickConnectType] {
            return [
                .phoneNumber,
                .queue,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .phoneNumber: return "PHONE_NUMBER"
            case .queue: return "QUEUE"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QuickConnectType(rawValue: rawValue) ?? QuickConnectType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.ReadOnlyFieldInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.TaskTemplateFieldIdentifier.self, forKey: .id)
        id = idDecoded
    }
}

extension ConnectClientTypes {
    /// Indicates a field that is read-only to an agent.
    public struct ReadOnlyFieldInfo: Swift.Equatable {
        /// Identifier of the read-only field.
        public var id: ConnectClientTypes.TaskTemplateFieldIdentifier?

        public init(
            id: ConnectClientTypes.TaskTemplateFieldIdentifier? = nil
        )
        {
            self.id = id
        }
    }

}

extension ConnectClientTypes.RealTimeContactAnalysisAttachment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentId = "AttachmentId"
        case attachmentName = "AttachmentName"
        case contentType = "ContentType"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentId = self.attachmentId {
            try encodeContainer.encode(attachmentId, forKey: .attachmentId)
        }
        if let attachmentName = self.attachmentName {
            try encodeContainer.encode(attachmentName, forKey: .attachmentName)
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachmentName)
        attachmentName = attachmentNameDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let attachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachmentId)
        attachmentId = attachmentIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ArtifactStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ConnectClientTypes {
    /// Object that describes attached file.
    public struct RealTimeContactAnalysisAttachment: Swift.Equatable {
        /// A unique identifier for the attachment.
        /// This member is required.
        public var attachmentId: Swift.String?
        /// A case-sensitive name of the attachment being uploaded. Can be redacted.
        /// This member is required.
        public var attachmentName: Swift.String?
        /// Describes the MIME file type of the attachment. For a list of supported file types, see [Feature specifications](https://docs.aws.amazon.com/connect/latest/adminguide/feature-limits.html) in the Amazon Connect Administrator Guide.
        public var contentType: Swift.String?
        /// Status of the attachment.
        public var status: ConnectClientTypes.ArtifactStatus?

        public init(
            attachmentId: Swift.String? = nil,
            attachmentName: Swift.String? = nil,
            contentType: Swift.String? = nil,
            status: ConnectClientTypes.ArtifactStatus? = nil
        )
        {
            self.attachmentId = attachmentId
            self.attachmentName = attachmentName
            self.contentType = contentType
            self.status = status
        }
    }

}

extension ConnectClientTypes.RealTimeContactAnalysisCategoryDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pointsOfInterest = "PointsOfInterest"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pointsOfInterest = pointsOfInterest {
            var pointsOfInterestContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pointsOfInterest)
            for realtimecontactanalysispointofinterest0 in pointsOfInterest {
                try pointsOfInterestContainer.encode(realtimecontactanalysispointofinterest0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pointsOfInterestContainer = try containerValues.decodeIfPresent([ConnectClientTypes.RealTimeContactAnalysisPointOfInterest?].self, forKey: .pointsOfInterest)
        var pointsOfInterestDecoded0:[ConnectClientTypes.RealTimeContactAnalysisPointOfInterest]? = nil
        if let pointsOfInterestContainer = pointsOfInterestContainer {
            pointsOfInterestDecoded0 = [ConnectClientTypes.RealTimeContactAnalysisPointOfInterest]()
            for structure0 in pointsOfInterestContainer {
                if let structure0 = structure0 {
                    pointsOfInterestDecoded0?.append(structure0)
                }
            }
        }
        pointsOfInterest = pointsOfInterestDecoded0
    }
}

extension ConnectClientTypes {
    /// Provides information about the category rule that was matched.
    public struct RealTimeContactAnalysisCategoryDetails: Swift.Equatable {
        /// List of PointOfInterest - objects describing a single match of a rule.
        /// This member is required.
        public var pointsOfInterest: [ConnectClientTypes.RealTimeContactAnalysisPointOfInterest]?

        public init(
            pointsOfInterest: [ConnectClientTypes.RealTimeContactAnalysisPointOfInterest]? = nil
        )
        {
            self.pointsOfInterest = pointsOfInterest
        }
    }

}

extension ConnectClientTypes.RealTimeContactAnalysisCharacterInterval: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beginOffsetChar = "BeginOffsetChar"
        case endOffsetChar = "EndOffsetChar"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if beginOffsetChar != 0 {
            try encodeContainer.encode(beginOffsetChar, forKey: .beginOffsetChar)
        }
        if endOffsetChar != 0 {
            try encodeContainer.encode(endOffsetChar, forKey: .endOffsetChar)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let beginOffsetCharDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .beginOffsetChar) ?? 0
        beginOffsetChar = beginOffsetCharDecoded
        let endOffsetCharDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endOffsetChar) ?? 0
        endOffsetChar = endOffsetCharDecoded
    }
}

extension ConnectClientTypes {
    /// Begin and end offsets for a part of text.
    public struct RealTimeContactAnalysisCharacterInterval: Swift.Equatable {
        /// The beginning of the character interval.
        /// This member is required.
        public var beginOffsetChar: Swift.Int
        /// The end of the character interval.
        /// This member is required.
        public var endOffsetChar: Swift.Int

        public init(
            beginOffsetChar: Swift.Int = 0,
            endOffsetChar: Swift.Int = 0
        )
        {
            self.beginOffsetChar = beginOffsetChar
            self.endOffsetChar = endOffsetChar
        }
    }

}

extension ConnectClientTypes.RealTimeContactAnalysisIssueDetected: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transcriptItems = "TranscriptItems"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transcriptItems = transcriptItems {
            var transcriptItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .transcriptItems)
            for realtimecontactanalysistranscriptitemwithcontent0 in transcriptItems {
                try transcriptItemsContainer.encode(realtimecontactanalysistranscriptitemwithcontent0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transcriptItemsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.RealTimeContactAnalysisTranscriptItemWithContent?].self, forKey: .transcriptItems)
        var transcriptItemsDecoded0:[ConnectClientTypes.RealTimeContactAnalysisTranscriptItemWithContent]? = nil
        if let transcriptItemsContainer = transcriptItemsContainer {
            transcriptItemsDecoded0 = [ConnectClientTypes.RealTimeContactAnalysisTranscriptItemWithContent]()
            for structure0 in transcriptItemsContainer {
                if let structure0 = structure0 {
                    transcriptItemsDecoded0?.append(structure0)
                }
            }
        }
        transcriptItems = transcriptItemsDecoded0
    }
}

extension ConnectClientTypes {
    /// Potential issues that are detected based on an artificial intelligence analysis of each turn in the conversation.
    public struct RealTimeContactAnalysisIssueDetected: Swift.Equatable {
        /// List of the transcript items (segments) that are associated with a given issue.
        /// This member is required.
        public var transcriptItems: [ConnectClientTypes.RealTimeContactAnalysisTranscriptItemWithContent]?

        public init(
            transcriptItems: [ConnectClientTypes.RealTimeContactAnalysisTranscriptItemWithContent]? = nil
        )
        {
            self.transcriptItems = transcriptItems
        }
    }

}

extension ConnectClientTypes {
    public enum RealTimeContactAnalysisOutputType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case raw
        case redacted
        case sdkUnknown(Swift.String)

        public static var allCases: [RealTimeContactAnalysisOutputType] {
            return [
                .raw,
                .redacted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .raw: return "Raw"
            case .redacted: return "Redacted"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RealTimeContactAnalysisOutputType(rawValue: rawValue) ?? RealTimeContactAnalysisOutputType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.RealTimeContactAnalysisPointOfInterest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transcriptItems = "TranscriptItems"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transcriptItems = transcriptItems {
            var transcriptItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .transcriptItems)
            for realtimecontactanalysistranscriptitemwithcharacteroffsets0 in transcriptItems {
                try transcriptItemsContainer.encode(realtimecontactanalysistranscriptitemwithcharacteroffsets0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transcriptItemsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.RealTimeContactAnalysisTranscriptItemWithCharacterOffsets?].self, forKey: .transcriptItems)
        var transcriptItemsDecoded0:[ConnectClientTypes.RealTimeContactAnalysisTranscriptItemWithCharacterOffsets]? = nil
        if let transcriptItemsContainer = transcriptItemsContainer {
            transcriptItemsDecoded0 = [ConnectClientTypes.RealTimeContactAnalysisTranscriptItemWithCharacterOffsets]()
            for structure0 in transcriptItemsContainer {
                if let structure0 = structure0 {
                    transcriptItemsDecoded0?.append(structure0)
                }
            }
        }
        transcriptItems = transcriptItemsDecoded0
    }
}

extension ConnectClientTypes {
    /// The section of the contact transcript segment that category rule was detected.
    public struct RealTimeContactAnalysisPointOfInterest: Swift.Equatable {
        /// List of the transcript items (segments) that are associated with a given point of interest.
        public var transcriptItems: [ConnectClientTypes.RealTimeContactAnalysisTranscriptItemWithCharacterOffsets]?

        public init(
            transcriptItems: [ConnectClientTypes.RealTimeContactAnalysisTranscriptItemWithCharacterOffsets]? = nil
        )
        {
            self.transcriptItems = transcriptItems
        }
    }

}

extension ConnectClientTypes.RealTimeContactAnalysisSegmentAttachments: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachments = "Attachments"
        case displayName = "DisplayName"
        case id = "Id"
        case participantId = "ParticipantId"
        case participantRole = "ParticipantRole"
        case time = "Time"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachments = attachments {
            var attachmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachments)
            for realtimecontactanalysisattachment0 in attachments {
                try attachmentsContainer.encode(realtimecontactanalysisattachment0)
            }
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let participantId = self.participantId {
            try encodeContainer.encode(participantId, forKey: .participantId)
        }
        if let participantRole = self.participantRole {
            try encodeContainer.encode(participantRole.rawValue, forKey: .participantRole)
        }
        if let time = self.time {
            try encodeContainer.encode(time, forKey: .time)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let participantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .participantId)
        participantId = participantIdDecoded
        let participantRoleDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ParticipantRole.self, forKey: .participantRole)
        participantRole = participantRoleDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let attachmentsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.RealTimeContactAnalysisAttachment?].self, forKey: .attachments)
        var attachmentsDecoded0:[ConnectClientTypes.RealTimeContactAnalysisAttachment]? = nil
        if let attachmentsContainer = attachmentsContainer {
            attachmentsDecoded0 = [ConnectClientTypes.RealTimeContactAnalysisAttachment]()
            for structure0 in attachmentsContainer {
                if let structure0 = structure0 {
                    attachmentsDecoded0?.append(structure0)
                }
            }
        }
        attachments = attachmentsDecoded0
        let timeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.RealTimeContactAnalysisTimeData.self, forKey: .time)
        time = timeDecoded
    }
}

extension ConnectClientTypes {
    /// Segment containing list of attachments.
    public struct RealTimeContactAnalysisSegmentAttachments: Swift.Equatable {
        /// List of objects describing an individual attachment.
        /// This member is required.
        public var attachments: [ConnectClientTypes.RealTimeContactAnalysisAttachment]?
        /// The display name of the participant. Can be redacted.
        public var displayName: Swift.String?
        /// The identifier of the segment.
        /// This member is required.
        public var id: Swift.String?
        /// The identifier of the participant.
        /// This member is required.
        public var participantId: Swift.String?
        /// The role of the participant. For example, is it a customer, agent, or system.
        /// This member is required.
        public var participantRole: ConnectClientTypes.ParticipantRole?
        /// Field describing the time of the event. It can have different representations of time.
        /// This member is required.
        public var time: ConnectClientTypes.RealTimeContactAnalysisTimeData?

        public init(
            attachments: [ConnectClientTypes.RealTimeContactAnalysisAttachment]? = nil,
            displayName: Swift.String? = nil,
            id: Swift.String? = nil,
            participantId: Swift.String? = nil,
            participantRole: ConnectClientTypes.ParticipantRole? = nil,
            time: ConnectClientTypes.RealTimeContactAnalysisTimeData? = nil
        )
        {
            self.attachments = attachments
            self.displayName = displayName
            self.id = id
            self.participantId = participantId
            self.participantRole = participantRole
            self.time = time
        }
    }

}

extension ConnectClientTypes.RealTimeContactAnalysisSegmentCategories: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case matchedDetails = "MatchedDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let matchedDetails = matchedDetails {
            var matchedDetailsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .matchedDetails)
            for (dictKey0, realTimeContactAnalysisMatchedDetails0) in matchedDetails {
                try matchedDetailsContainer.encode(realTimeContactAnalysisMatchedDetails0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let matchedDetailsContainer = try containerValues.decodeIfPresent([Swift.String: ConnectClientTypes.RealTimeContactAnalysisCategoryDetails?].self, forKey: .matchedDetails)
        var matchedDetailsDecoded0: [Swift.String:ConnectClientTypes.RealTimeContactAnalysisCategoryDetails]? = nil
        if let matchedDetailsContainer = matchedDetailsContainer {
            matchedDetailsDecoded0 = [Swift.String:ConnectClientTypes.RealTimeContactAnalysisCategoryDetails]()
            for (key0, realtimecontactanalysiscategorydetails0) in matchedDetailsContainer {
                if let realtimecontactanalysiscategorydetails0 = realtimecontactanalysiscategorydetails0 {
                    matchedDetailsDecoded0?[key0] = realtimecontactanalysiscategorydetails0
                }
            }
        }
        matchedDetails = matchedDetailsDecoded0
    }
}

extension ConnectClientTypes {
    /// The matched category rules.
    public struct RealTimeContactAnalysisSegmentCategories: Swift.Equatable {
        /// Map between the name of the matched rule and RealTimeContactAnalysisCategoryDetails.
        /// This member is required.
        public var matchedDetails: [Swift.String:ConnectClientTypes.RealTimeContactAnalysisCategoryDetails]?

        public init(
            matchedDetails: [Swift.String:ConnectClientTypes.RealTimeContactAnalysisCategoryDetails]? = nil
        )
        {
            self.matchedDetails = matchedDetails
        }
    }

}

extension ConnectClientTypes.RealTimeContactAnalysisSegmentEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case eventType = "EventType"
        case id = "Id"
        case participantId = "ParticipantId"
        case participantRole = "ParticipantRole"
        case time = "Time"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let eventType = self.eventType {
            try encodeContainer.encode(eventType, forKey: .eventType)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let participantId = self.participantId {
            try encodeContainer.encode(participantId, forKey: .participantId)
        }
        if let participantRole = self.participantRole {
            try encodeContainer.encode(participantRole.rawValue, forKey: .participantRole)
        }
        if let time = self.time {
            try encodeContainer.encode(time, forKey: .time)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let participantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .participantId)
        participantId = participantIdDecoded
        let participantRoleDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ParticipantRole.self, forKey: .participantRole)
        participantRole = participantRoleDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let timeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.RealTimeContactAnalysisTimeData.self, forKey: .time)
        time = timeDecoded
    }
}

extension ConnectClientTypes {
    /// Segment type describing a contact event.
    public struct RealTimeContactAnalysisSegmentEvent: Swift.Equatable {
        /// The display name of the participant. Can be redacted.
        public var displayName: Swift.String?
        /// Type of the event. For example, application/vnd.amazonaws.connect.event.participant.left.
        /// This member is required.
        public var eventType: Swift.String?
        /// The identifier of the contact event.
        /// This member is required.
        public var id: Swift.String?
        /// The identifier of the participant.
        public var participantId: Swift.String?
        /// The role of the participant. For example, is it a customer, agent, or system.
        public var participantRole: ConnectClientTypes.ParticipantRole?
        /// Field describing the time of the event. It can have different representations of time.
        /// This member is required.
        public var time: ConnectClientTypes.RealTimeContactAnalysisTimeData?

        public init(
            displayName: Swift.String? = nil,
            eventType: Swift.String? = nil,
            id: Swift.String? = nil,
            participantId: Swift.String? = nil,
            participantRole: ConnectClientTypes.ParticipantRole? = nil,
            time: ConnectClientTypes.RealTimeContactAnalysisTimeData? = nil
        )
        {
            self.displayName = displayName
            self.eventType = eventType
            self.id = id
            self.participantId = participantId
            self.participantRole = participantRole
            self.time = time
        }
    }

}

extension ConnectClientTypes.RealTimeContactAnalysisSegmentIssues: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case issuesDetected = "IssuesDetected"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let issuesDetected = issuesDetected {
            var issuesDetectedContainer = encodeContainer.nestedUnkeyedContainer(forKey: .issuesDetected)
            for realtimecontactanalysisissuedetected0 in issuesDetected {
                try issuesDetectedContainer.encode(realtimecontactanalysisissuedetected0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let issuesDetectedContainer = try containerValues.decodeIfPresent([ConnectClientTypes.RealTimeContactAnalysisIssueDetected?].self, forKey: .issuesDetected)
        var issuesDetectedDecoded0:[ConnectClientTypes.RealTimeContactAnalysisIssueDetected]? = nil
        if let issuesDetectedContainer = issuesDetectedContainer {
            issuesDetectedDecoded0 = [ConnectClientTypes.RealTimeContactAnalysisIssueDetected]()
            for structure0 in issuesDetectedContainer {
                if let structure0 = structure0 {
                    issuesDetectedDecoded0?.append(structure0)
                }
            }
        }
        issuesDetected = issuesDetectedDecoded0
    }
}

extension ConnectClientTypes {
    /// Segment type containing a list of detected issues.
    public struct RealTimeContactAnalysisSegmentIssues: Swift.Equatable {
        /// List of the issues detected.
        /// This member is required.
        public var issuesDetected: [ConnectClientTypes.RealTimeContactAnalysisIssueDetected]?

        public init(
            issuesDetected: [ConnectClientTypes.RealTimeContactAnalysisIssueDetected]? = nil
        )
        {
            self.issuesDetected = issuesDetected
        }
    }

}

extension ConnectClientTypes.RealTimeContactAnalysisSegmentTranscript: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case contentType = "ContentType"
        case displayName = "DisplayName"
        case id = "Id"
        case participantId = "ParticipantId"
        case participantRole = "ParticipantRole"
        case redaction = "Redaction"
        case sentiment = "Sentiment"
        case time = "Time"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let participantId = self.participantId {
            try encodeContainer.encode(participantId, forKey: .participantId)
        }
        if let participantRole = self.participantRole {
            try encodeContainer.encode(participantRole.rawValue, forKey: .participantRole)
        }
        if let redaction = self.redaction {
            try encodeContainer.encode(redaction, forKey: .redaction)
        }
        if let sentiment = self.sentiment {
            try encodeContainer.encode(sentiment.rawValue, forKey: .sentiment)
        }
        if let time = self.time {
            try encodeContainer.encode(time, forKey: .time)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let participantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .participantId)
        participantId = participantIdDecoded
        let participantRoleDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ParticipantRole.self, forKey: .participantRole)
        participantRole = participantRoleDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let timeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.RealTimeContactAnalysisTimeData.self, forKey: .time)
        time = timeDecoded
        let redactionDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.RealTimeContactAnalysisTranscriptItemRedaction.self, forKey: .redaction)
        redaction = redactionDecoded
        let sentimentDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.RealTimeContactAnalysisSentimentLabel.self, forKey: .sentiment)
        sentiment = sentimentDecoded
    }
}

extension ConnectClientTypes {
    /// The analyzed transcript segment.
    public struct RealTimeContactAnalysisSegmentTranscript: Swift.Equatable {
        /// The content of the transcript. Can be redacted.
        /// This member is required.
        public var content: Swift.String?
        /// The type of content of the item. For example, text/plain.
        public var contentType: Swift.String?
        /// The display name of the participant.
        public var displayName: Swift.String?
        /// The identifier of the transcript.
        /// This member is required.
        public var id: Swift.String?
        /// The identifier of the participant.
        /// This member is required.
        public var participantId: Swift.String?
        /// The role of the participant. For example, is it a customer, agent, or system.
        /// This member is required.
        public var participantRole: ConnectClientTypes.ParticipantRole?
        /// Object describing redaction that was applied to the transcript. If transcript has the field it means part of the transcript was redacted.
        public var redaction: ConnectClientTypes.RealTimeContactAnalysisTranscriptItemRedaction?
        /// The sentiment detected for this piece of transcript.
        public var sentiment: ConnectClientTypes.RealTimeContactAnalysisSentimentLabel?
        /// Field describing the time of the event. It can have different representations of time.
        /// This member is required.
        public var time: ConnectClientTypes.RealTimeContactAnalysisTimeData?

        public init(
            content: Swift.String? = nil,
            contentType: Swift.String? = nil,
            displayName: Swift.String? = nil,
            id: Swift.String? = nil,
            participantId: Swift.String? = nil,
            participantRole: ConnectClientTypes.ParticipantRole? = nil,
            redaction: ConnectClientTypes.RealTimeContactAnalysisTranscriptItemRedaction? = nil,
            sentiment: ConnectClientTypes.RealTimeContactAnalysisSentimentLabel? = nil,
            time: ConnectClientTypes.RealTimeContactAnalysisTimeData? = nil
        )
        {
            self.content = content
            self.contentType = contentType
            self.displayName = displayName
            self.id = id
            self.participantId = participantId
            self.participantRole = participantRole
            self.redaction = redaction
            self.sentiment = sentiment
            self.time = time
        }
    }

}

extension ConnectClientTypes {
    public enum RealTimeContactAnalysisSegmentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case attachments
        case categories
        case event
        case issues
        case transcript
        case sdkUnknown(Swift.String)

        public static var allCases: [RealTimeContactAnalysisSegmentType] {
            return [
                .attachments,
                .categories,
                .event,
                .issues,
                .transcript,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .attachments: return "Attachments"
            case .categories: return "Categories"
            case .event: return "Event"
            case .issues: return "Issues"
            case .transcript: return "Transcript"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RealTimeContactAnalysisSegmentType(rawValue: rawValue) ?? RealTimeContactAnalysisSegmentType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes {
    public enum RealTimeContactAnalysisSentimentLabel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case negative
        case neutral
        case positive
        case sdkUnknown(Swift.String)

        public static var allCases: [RealTimeContactAnalysisSentimentLabel] {
            return [
                .negative,
                .neutral,
                .positive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .negative: return "NEGATIVE"
            case .neutral: return "NEUTRAL"
            case .positive: return "POSITIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RealTimeContactAnalysisSentimentLabel(rawValue: rawValue) ?? RealTimeContactAnalysisSentimentLabel.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes {
    public enum RealTimeContactAnalysisStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [RealTimeContactAnalysisStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RealTimeContactAnalysisStatus(rawValue: rawValue) ?? RealTimeContactAnalysisStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes {
    public enum RealTimeContactAnalysisSupportedChannel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case chat
        case voice
        case sdkUnknown(Swift.String)

        public static var allCases: [RealTimeContactAnalysisSupportedChannel] {
            return [
                .chat,
                .voice,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .chat: return "CHAT"
            case .voice: return "VOICE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RealTimeContactAnalysisSupportedChannel(rawValue: rawValue) ?? RealTimeContactAnalysisSupportedChannel.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.RealTimeContactAnalysisTimeData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case absolutetime = "AbsoluteTime"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .absolutetime(absolutetime):
                try container.encodeTimestamp(absolutetime, format: .dateTime, forKey: .absolutetime)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let absolutetimeDecoded = try values.decodeTimestampIfPresent(.dateTime, forKey: .absolutetime)
        if let absolutetime = absolutetimeDecoded {
            self = .absolutetime(absolutetime)
            return
        }
        self = .sdkUnknown("")
    }
}

extension ConnectClientTypes {
    /// Object describing time with which the segment is associated. It can have different representations of time. Currently supported: absoluteTime
    public enum RealTimeContactAnalysisTimeData: Swift.Equatable {
        /// Time represented in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
        case absolutetime(ClientRuntime.Date)
        case sdkUnknown(Swift.String)
    }

}

extension ConnectClientTypes.RealTimeContactAnalysisTranscriptItemRedaction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case characterOffsets = "CharacterOffsets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let characterOffsets = characterOffsets {
            var characterOffsetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .characterOffsets)
            for realtimecontactanalysischaracterinterval0 in characterOffsets {
                try characterOffsetsContainer.encode(realtimecontactanalysischaracterinterval0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let characterOffsetsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.RealTimeContactAnalysisCharacterInterval?].self, forKey: .characterOffsets)
        var characterOffsetsDecoded0:[ConnectClientTypes.RealTimeContactAnalysisCharacterInterval]? = nil
        if let characterOffsetsContainer = characterOffsetsContainer {
            characterOffsetsDecoded0 = [ConnectClientTypes.RealTimeContactAnalysisCharacterInterval]()
            for structure0 in characterOffsetsContainer {
                if let structure0 = structure0 {
                    characterOffsetsDecoded0?.append(structure0)
                }
            }
        }
        characterOffsets = characterOffsetsDecoded0
    }
}

extension ConnectClientTypes {
    /// Object describing redaction applied to the segment.
    public struct RealTimeContactAnalysisTranscriptItemRedaction: Swift.Equatable {
        /// List of character intervals each describing a part of the text that was redacted. For OutputType.Raw, part of the original text that contains data that can be redacted. For  OutputType.Redacted, part of the string with redaction tag.
        public var characterOffsets: [ConnectClientTypes.RealTimeContactAnalysisCharacterInterval]?

        public init(
            characterOffsets: [ConnectClientTypes.RealTimeContactAnalysisCharacterInterval]? = nil
        )
        {
            self.characterOffsets = characterOffsets
        }
    }

}

extension ConnectClientTypes.RealTimeContactAnalysisTranscriptItemWithCharacterOffsets: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case characterOffsets = "CharacterOffsets"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let characterOffsets = self.characterOffsets {
            try encodeContainer.encode(characterOffsets, forKey: .characterOffsets)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let characterOffsetsDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.RealTimeContactAnalysisCharacterInterval.self, forKey: .characterOffsets)
        characterOffsets = characterOffsetsDecoded
    }
}

extension ConnectClientTypes {
    /// Transcript representation containing Id and list of character intervals that are associated with analysis data. For example, this object within a RealTimeContactAnalysisPointOfInterest in Category.MatchedDetails would have character interval describing part of the text that matched category.
    public struct RealTimeContactAnalysisTranscriptItemWithCharacterOffsets: Swift.Equatable {
        /// List of character intervals within transcript content/text.
        public var characterOffsets: ConnectClientTypes.RealTimeContactAnalysisCharacterInterval?
        /// Transcript identifier. Matches the identifier from one of the TranscriptSegments.
        /// This member is required.
        public var id: Swift.String?

        public init(
            characterOffsets: ConnectClientTypes.RealTimeContactAnalysisCharacterInterval? = nil,
            id: Swift.String? = nil
        )
        {
            self.characterOffsets = characterOffsets
            self.id = id
        }
    }

}

extension ConnectClientTypes.RealTimeContactAnalysisTranscriptItemWithContent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case characterOffsets = "CharacterOffsets"
        case content = "Content"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let characterOffsets = self.characterOffsets {
            try encodeContainer.encode(characterOffsets, forKey: .characterOffsets)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let characterOffsetsDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.RealTimeContactAnalysisCharacterInterval.self, forKey: .characterOffsets)
        characterOffsets = characterOffsetsDecoded
    }
}

extension ConnectClientTypes {
    /// Transcript representation containing Id, Content and list of character intervals that are associated with analysis data. For example, this object within an issue detected would describe both content that contains identified issue and intervals where that content is taken from.
    public struct RealTimeContactAnalysisTranscriptItemWithContent: Swift.Equatable {
        /// Begin and end offsets for a part of text.
        public var characterOffsets: ConnectClientTypes.RealTimeContactAnalysisCharacterInterval?
        /// Part of the transcript content that contains identified issue. Can be redacted
        public var content: Swift.String?
        /// Transcript identifier. Matches the identifier from one of the TranscriptSegments.
        /// This member is required.
        public var id: Swift.String?

        public init(
            characterOffsets: ConnectClientTypes.RealTimeContactAnalysisCharacterInterval? = nil,
            content: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.characterOffsets = characterOffsets
            self.content = content
            self.id = id
        }
    }

}

extension ConnectClientTypes.RealtimeContactAnalysisSegment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachments = "Attachments"
        case categories = "Categories"
        case event = "Event"
        case issues = "Issues"
        case transcript = "Transcript"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .attachments(attachments):
                try container.encode(attachments, forKey: .attachments)
            case let .categories(categories):
                try container.encode(categories, forKey: .categories)
            case let .event(event):
                try container.encode(event, forKey: .event)
            case let .issues(issues):
                try container.encode(issues, forKey: .issues)
            case let .transcript(transcript):
                try container.encode(transcript, forKey: .transcript)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let transcriptDecoded = try values.decodeIfPresent(ConnectClientTypes.RealTimeContactAnalysisSegmentTranscript.self, forKey: .transcript)
        if let transcript = transcriptDecoded {
            self = .transcript(transcript)
            return
        }
        let categoriesDecoded = try values.decodeIfPresent(ConnectClientTypes.RealTimeContactAnalysisSegmentCategories.self, forKey: .categories)
        if let categories = categoriesDecoded {
            self = .categories(categories)
            return
        }
        let issuesDecoded = try values.decodeIfPresent(ConnectClientTypes.RealTimeContactAnalysisSegmentIssues.self, forKey: .issues)
        if let issues = issuesDecoded {
            self = .issues(issues)
            return
        }
        let eventDecoded = try values.decodeIfPresent(ConnectClientTypes.RealTimeContactAnalysisSegmentEvent.self, forKey: .event)
        if let event = eventDecoded {
            self = .event(event)
            return
        }
        let attachmentsDecoded = try values.decodeIfPresent(ConnectClientTypes.RealTimeContactAnalysisSegmentAttachments.self, forKey: .attachments)
        if let attachments = attachmentsDecoded {
            self = .attachments(attachments)
            return
        }
        self = .sdkUnknown("")
    }
}

extension ConnectClientTypes {
    /// An analyzed segment for a real-time analysis session.
    public enum RealtimeContactAnalysisSegment: Swift.Equatable {
        /// The analyzed transcript segment.
        case transcript(ConnectClientTypes.RealTimeContactAnalysisSegmentTranscript)
        /// The matched category rules.
        case categories(ConnectClientTypes.RealTimeContactAnalysisSegmentCategories)
        /// Segment type containing a list of detected issues.
        case issues(ConnectClientTypes.RealTimeContactAnalysisSegmentIssues)
        /// Segment type describing a contact event.
        case event(ConnectClientTypes.RealTimeContactAnalysisSegmentEvent)
        /// The analyzed attachments.
        case attachments(ConnectClientTypes.RealTimeContactAnalysisSegmentAttachments)
        case sdkUnknown(Swift.String)
    }

}

extension ConnectClientTypes.Reference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ReferenceType.self, forKey: .type)
        type = typeDecoded
    }
}

extension ConnectClientTypes {
    /// Well-formed data on a contact, used by agents to complete a contact request. You can have up to 4,096 UTF-8 bytes across all references for a contact.
    public struct Reference: Swift.Equatable {
        /// The type of the reference. DATE must be of type Epoch timestamp.
        /// This member is required.
        public var type: ConnectClientTypes.ReferenceType?
        /// A valid value for the reference. For example, for a URL reference, a formatted URL that is displayed to an agent in the Contact Control Panel (CCP).
        /// This member is required.
        public var value: Swift.String?

        public init(
            type: ConnectClientTypes.ReferenceType? = nil,
            value: Swift.String? = nil
        )
        {
            self.type = type
            self.value = value
        }
    }

}

extension ConnectClientTypes {
    public enum ReferenceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case approved
        case rejected
        case sdkUnknown(Swift.String)

        public static var allCases: [ReferenceStatus] {
            return [
                .approved,
                .rejected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .approved: return "APPROVED"
            case .rejected: return "REJECTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReferenceStatus(rawValue: rawValue) ?? ReferenceStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.ReferenceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachment = "Attachment"
        case date = "Date"
        case email = "Email"
        case number = "Number"
        case string = "String"
        case url = "Url"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .attachment(attachment):
                try container.encode(attachment, forKey: .attachment)
            case let .date(date):
                try container.encode(date, forKey: .date)
            case let .email(email):
                try container.encode(email, forKey: .email)
            case let .number(number):
                try container.encode(number, forKey: .number)
            case let .string(string):
                try container.encode(string, forKey: .string)
            case let .url(url):
                try container.encode(url, forKey: .url)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try values.decodeIfPresent(ConnectClientTypes.UrlReference.self, forKey: .url)
        if let url = urlDecoded {
            self = .url(url)
            return
        }
        let attachmentDecoded = try values.decodeIfPresent(ConnectClientTypes.AttachmentReference.self, forKey: .attachment)
        if let attachment = attachmentDecoded {
            self = .attachment(attachment)
            return
        }
        let stringDecoded = try values.decodeIfPresent(ConnectClientTypes.StringReference.self, forKey: .string)
        if let string = stringDecoded {
            self = .string(string)
            return
        }
        let numberDecoded = try values.decodeIfPresent(ConnectClientTypes.NumberReference.self, forKey: .number)
        if let number = numberDecoded {
            self = .number(number)
            return
        }
        let dateDecoded = try values.decodeIfPresent(ConnectClientTypes.DateReference.self, forKey: .date)
        if let date = dateDecoded {
            self = .date(date)
            return
        }
        let emailDecoded = try values.decodeIfPresent(ConnectClientTypes.EmailReference.self, forKey: .email)
        if let email = emailDecoded {
            self = .email(email)
            return
        }
        self = .sdkUnknown("")
    }
}

extension ConnectClientTypes {
    /// Contains summary information about a reference. ReferenceSummary contains only one non null field between the URL and attachment based on the reference type.
    public enum ReferenceSummary: Swift.Equatable {
        /// Information about the reference when the referenceType is URL. Otherwise, null.
        case url(ConnectClientTypes.UrlReference)
        /// Information about the reference when the referenceType is ATTACHMENT. Otherwise, null.
        case attachment(ConnectClientTypes.AttachmentReference)
        /// Information about a reference when the referenceType is STRING. Otherwise, null.
        case string(ConnectClientTypes.StringReference)
        /// Information about a reference when the referenceType is NUMBER. Otherwise, null.
        case number(ConnectClientTypes.NumberReference)
        /// Information about a reference when the referenceType is DATE. Otherwise, null.
        case date(ConnectClientTypes.DateReference)
        /// Information about a reference when the referenceType is EMAIL. Otherwise, null.
        case email(ConnectClientTypes.EmailReference)
        case sdkUnknown(Swift.String)
    }

}

extension ConnectClientTypes {
    public enum ReferenceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case attachment
        case date
        case email
        case number
        case string
        case url
        case sdkUnknown(Swift.String)

        public static var allCases: [ReferenceType] {
            return [
                .attachment,
                .date,
                .email,
                .number,
                .string,
                .url,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .attachment: return "ATTACHMENT"
            case .date: return "DATE"
            case .email: return "EMAIL"
            case .number: return "NUMBER"
            case .string: return "STRING"
            case .url: return "URL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReferenceType(rawValue: rawValue) ?? ReferenceType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes {
    public enum RehydrationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case entirePastSession
        case fromSegment
        case sdkUnknown(Swift.String)

        public static var allCases: [RehydrationType] {
            return [
                .entirePastSession,
                .fromSegment,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .entirePastSession: return "ENTIRE_PAST_SESSION"
            case .fromSegment: return "FROM_SEGMENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RehydrationType(rawValue: rawValue) ?? RehydrationType.sdkUnknown(rawValue)
        }
    }
}

extension ReleasePhoneNumberInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension ReleasePhoneNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let phoneNumberId = phoneNumberId else {
            return nil
        }
        return "/phone-number/\(phoneNumberId.urlPercentEncoding())"
    }
}

public struct ReleasePhoneNumberInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// A unique identifier for the phone number.
    /// This member is required.
    public var phoneNumberId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        phoneNumberId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.phoneNumberId = phoneNumberId
    }
}

struct ReleasePhoneNumberInputBody: Swift.Equatable {
}

extension ReleasePhoneNumberInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ReleasePhoneNumberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct ReleasePhoneNumberOutput: Swift.Equatable {

    public init() { }
}

enum ReleasePhoneNumberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IdempotencyException": return try await IdempotencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ReplicateInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReplicateInstanceInput(clientToken: \(Swift.String(describing: clientToken)), instanceId: \(Swift.String(describing: instanceId)), replicaRegion: \(Swift.String(describing: replicaRegion)), replicaAlias: \"CONTENT_REDACTED\")"}
}

extension ReplicateInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case replicaAlias = "ReplicaAlias"
        case replicaRegion = "ReplicaRegion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let replicaAlias = self.replicaAlias {
            try encodeContainer.encode(replicaAlias, forKey: .replicaAlias)
        }
        if let replicaRegion = self.replicaRegion {
            try encodeContainer.encode(replicaRegion, forKey: .replicaRegion)
        }
    }
}

extension ReplicateInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/replicate"
    }
}

public struct ReplicateInstanceInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance. You can provide the InstanceId, or the entire ARN.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The alias for the replicated instance. The ReplicaAlias must be unique.
    /// This member is required.
    public var replicaAlias: Swift.String?
    /// The Amazon Web Services Region where to replicate the Amazon Connect instance.
    /// This member is required.
    public var replicaRegion: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        replicaAlias: Swift.String? = nil,
        replicaRegion: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.instanceId = instanceId
        self.replicaAlias = replicaAlias
        self.replicaRegion = replicaRegion
    }
}

struct ReplicateInstanceInputBody: Swift.Equatable {
    let replicaRegion: Swift.String?
    let clientToken: Swift.String?
    let replicaAlias: Swift.String?
}

extension ReplicateInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case replicaAlias = "ReplicaAlias"
        case replicaRegion = "ReplicaRegion"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicaRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicaRegion)
        replicaRegion = replicaRegionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let replicaAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicaAlias)
        replicaAlias = replicaAliasDecoded
    }
}

extension ReplicateInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ReplicateInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct ReplicateInstanceOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the replicated instance.
    public var arn: Swift.String?
    /// The identifier of the replicated instance. You can find the instanceId in the ARN of the instance. The replicated instance has the same identifier as the instance it was replicated from.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct ReplicateInstanceOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
}

extension ReplicateInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum ReplicateInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotReadyException": return try await ResourceNotReadyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectClientTypes.RequiredFieldInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.TaskTemplateFieldIdentifier.self, forKey: .id)
        id = idDecoded
    }
}

extension ConnectClientTypes {
    /// Information about a required field.
    public struct RequiredFieldInfo: Swift.Equatable {
        /// The unique identifier for the field.
        public var id: ConnectClientTypes.TaskTemplateFieldIdentifier?

        public init(
            id: ConnectClientTypes.TaskTemplateFieldIdentifier? = nil
        )
        {
            self.id = id
        }
    }

}

extension ResourceConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A resource already has that name.
public struct ResourceConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceInUseException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// That resource is already in use. Please try another.
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The identifier for the resource.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of resource.
        public internal(set) var resourceType: ConnectClientTypes.ResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: ConnectClientTypes.ResourceType? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: ConnectClientTypes.ResourceType?
    let resourceId: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message about the resource.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotReadyException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotReadyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource is not ready.
public struct ResourceNotReadyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotReadyException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotReadyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotReadyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectClientTypes.ResourceTagsSearchCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagSearchCondition = "TagSearchCondition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagSearchCondition = self.tagSearchCondition {
            try encodeContainer.encode(tagSearchCondition, forKey: .tagSearchCondition)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagSearchConditionDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.TagSearchCondition.self, forKey: .tagSearchCondition)
        tagSearchCondition = tagSearchConditionDecoded
    }
}

extension ConnectClientTypes {
    /// The search criteria to be used to search tags.
    public struct ResourceTagsSearchCriteria: Swift.Equatable {
        /// The search criteria to be used to return tags.
        public var tagSearchCondition: ConnectClientTypes.TagSearchCondition?

        public init(
            tagSearchCondition: ConnectClientTypes.TagSearchCondition? = nil
        )
        {
            self.tagSearchCondition = tagSearchCondition
        }
    }

}

extension ConnectClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case contact
        case contactFlow
        case hierarchyGroup
        case hierarchyLevel
        case instance
        case participant
        case phoneNumber
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .contact,
                .contactFlow,
                .hierarchyGroup,
                .hierarchyLevel,
                .instance,
                .participant,
                .phoneNumber,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contact: return "CONTACT"
            case .contactFlow: return "CONTACT_FLOW"
            case .hierarchyGroup: return "HIERARCHY_GROUP"
            case .hierarchyLevel: return "HIERARCHY_LEVEL"
            case .instance: return "INSTANCE"
            case .participant: return "PARTICIPANT"
            case .phoneNumber: return "PHONE_NUMBER"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension ResumeContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactFlowId = "ContactFlowId"
        case contactId = "ContactId"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactFlowId = self.contactFlowId {
            try encodeContainer.encode(contactFlowId, forKey: .contactFlowId)
        }
        if let contactId = self.contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

extension ResumeContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/contact/resume"
    }
}

public struct ResumeContactInput: Swift.Equatable {
    /// The identifier of the flow.
    public var contactFlowId: Swift.String?
    /// The identifier of the contact.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        contactFlowId: Swift.String? = nil,
        contactId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.contactFlowId = contactFlowId
        self.contactId = contactId
        self.instanceId = instanceId
    }
}

struct ResumeContactInputBody: Swift.Equatable {
    let contactId: Swift.String?
    let instanceId: Swift.String?
    let contactFlowId: Swift.String?
}

extension ResumeContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactFlowId = "ContactFlowId"
        case contactId = "ContactId"
        case instanceId = "InstanceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let contactFlowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactFlowId)
        contactFlowId = contactFlowIdDecoded
    }
}

extension ResumeContactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct ResumeContactOutput: Swift.Equatable {

    public init() { }
}

enum ResumeContactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResumeContactRecordingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case initialContactId = "InitialContactId"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = self.contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let initialContactId = self.initialContactId {
            try encodeContainer.encode(initialContactId, forKey: .initialContactId)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

extension ResumeContactRecordingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/contact/resume-recording"
    }
}

public struct ResumeContactRecordingInput: Swift.Equatable {
    /// The identifier of the contact.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.
    /// This member is required.
    public var initialContactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        contactId: Swift.String? = nil,
        initialContactId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.contactId = contactId
        self.initialContactId = initialContactId
        self.instanceId = instanceId
    }
}

struct ResumeContactRecordingInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let contactId: Swift.String?
    let initialContactId: Swift.String?
}

extension ResumeContactRecordingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case initialContactId = "InitialContactId"
        case instanceId = "InstanceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let initialContactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initialContactId)
        initialContactId = initialContactIdDecoded
    }
}

extension ResumeContactRecordingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct ResumeContactRecordingOutput: Swift.Equatable {

    public init() { }
}

enum ResumeContactRecordingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectClientTypes.RoutingProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentAvailabilityTimer = "AgentAvailabilityTimer"
        case defaultOutboundQueueId = "DefaultOutboundQueueId"
        case description = "Description"
        case instanceId = "InstanceId"
        case isDefault = "IsDefault"
        case lastModifiedRegion = "LastModifiedRegion"
        case lastModifiedTime = "LastModifiedTime"
        case mediaConcurrencies = "MediaConcurrencies"
        case name = "Name"
        case numberOfAssociatedQueues = "NumberOfAssociatedQueues"
        case numberOfAssociatedUsers = "NumberOfAssociatedUsers"
        case routingProfileArn = "RoutingProfileArn"
        case routingProfileId = "RoutingProfileId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentAvailabilityTimer = self.agentAvailabilityTimer {
            try encodeContainer.encode(agentAvailabilityTimer.rawValue, forKey: .agentAvailabilityTimer)
        }
        if let defaultOutboundQueueId = self.defaultOutboundQueueId {
            try encodeContainer.encode(defaultOutboundQueueId, forKey: .defaultOutboundQueueId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if isDefault != false {
            try encodeContainer.encode(isDefault, forKey: .isDefault)
        }
        if let lastModifiedRegion = self.lastModifiedRegion {
            try encodeContainer.encode(lastModifiedRegion, forKey: .lastModifiedRegion)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let mediaConcurrencies = mediaConcurrencies {
            var mediaConcurrenciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mediaConcurrencies)
            for mediaconcurrency0 in mediaConcurrencies {
                try mediaConcurrenciesContainer.encode(mediaconcurrency0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let numberOfAssociatedQueues = self.numberOfAssociatedQueues {
            try encodeContainer.encode(numberOfAssociatedQueues, forKey: .numberOfAssociatedQueues)
        }
        if let numberOfAssociatedUsers = self.numberOfAssociatedUsers {
            try encodeContainer.encode(numberOfAssociatedUsers, forKey: .numberOfAssociatedUsers)
        }
        if let routingProfileArn = self.routingProfileArn {
            try encodeContainer.encode(routingProfileArn, forKey: .routingProfileArn)
        }
        if let routingProfileId = self.routingProfileId {
            try encodeContainer.encode(routingProfileId, forKey: .routingProfileId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let routingProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routingProfileArn)
        routingProfileArn = routingProfileArnDecoded
        let routingProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routingProfileId)
        routingProfileId = routingProfileIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let mediaConcurrenciesContainer = try containerValues.decodeIfPresent([ConnectClientTypes.MediaConcurrency?].self, forKey: .mediaConcurrencies)
        var mediaConcurrenciesDecoded0:[ConnectClientTypes.MediaConcurrency]? = nil
        if let mediaConcurrenciesContainer = mediaConcurrenciesContainer {
            mediaConcurrenciesDecoded0 = [ConnectClientTypes.MediaConcurrency]()
            for structure0 in mediaConcurrenciesContainer {
                if let structure0 = structure0 {
                    mediaConcurrenciesDecoded0?.append(structure0)
                }
            }
        }
        mediaConcurrencies = mediaConcurrenciesDecoded0
        let defaultOutboundQueueIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultOutboundQueueId)
        defaultOutboundQueueId = defaultOutboundQueueIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let numberOfAssociatedQueuesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfAssociatedQueues)
        numberOfAssociatedQueues = numberOfAssociatedQueuesDecoded
        let numberOfAssociatedUsersDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfAssociatedUsers)
        numberOfAssociatedUsers = numberOfAssociatedUsersDecoded
        let agentAvailabilityTimerDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.AgentAvailabilityTimer.self, forKey: .agentAvailabilityTimer)
        agentAvailabilityTimer = agentAvailabilityTimerDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastModifiedRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedRegion)
        lastModifiedRegion = lastModifiedRegionDecoded
        let isDefaultDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isDefault) ?? false
        isDefault = isDefaultDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about a routing profile.
    public struct RoutingProfile: Swift.Equatable {
        /// Whether agents with this routing profile will have their routing order calculated based on time since their last inbound contact or longest idle time.
        public var agentAvailabilityTimer: ConnectClientTypes.AgentAvailabilityTimer?
        /// The identifier of the default outbound queue for this routing profile.
        public var defaultOutboundQueueId: Swift.String?
        /// The description of the routing profile.
        public var description: Swift.String?
        /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
        public var instanceId: Swift.String?
        /// Whether this a default routing profile.
        public var isDefault: Swift.Bool
        /// The Amazon Web Services Region where this resource was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when this resource was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The channels agents can handle in the Contact Control Panel (CCP) for this routing profile.
        public var mediaConcurrencies: [ConnectClientTypes.MediaConcurrency]?
        /// The name of the routing profile.
        public var name: Swift.String?
        /// The number of associated queues in routing profile.
        public var numberOfAssociatedQueues: Swift.Int?
        /// The number of associated users in routing profile.
        public var numberOfAssociatedUsers: Swift.Int?
        /// The Amazon Resource Name (ARN) of the routing profile.
        public var routingProfileArn: Swift.String?
        /// The identifier of the routing profile.
        public var routingProfileId: Swift.String?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public var tags: [Swift.String:Swift.String]?

        public init(
            agentAvailabilityTimer: ConnectClientTypes.AgentAvailabilityTimer? = nil,
            defaultOutboundQueueId: Swift.String? = nil,
            description: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            isDefault: Swift.Bool = false,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            mediaConcurrencies: [ConnectClientTypes.MediaConcurrency]? = nil,
            name: Swift.String? = nil,
            numberOfAssociatedQueues: Swift.Int? = nil,
            numberOfAssociatedUsers: Swift.Int? = nil,
            routingProfileArn: Swift.String? = nil,
            routingProfileId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.agentAvailabilityTimer = agentAvailabilityTimer
            self.defaultOutboundQueueId = defaultOutboundQueueId
            self.description = description
            self.instanceId = instanceId
            self.isDefault = isDefault
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.mediaConcurrencies = mediaConcurrencies
            self.name = name
            self.numberOfAssociatedQueues = numberOfAssociatedQueues
            self.numberOfAssociatedUsers = numberOfAssociatedUsers
            self.routingProfileArn = routingProfileArn
            self.routingProfileId = routingProfileId
            self.tags = tags
        }
    }

}

extension ConnectClientTypes.RoutingProfileQueueConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delay = "Delay"
        case priority = "Priority"
        case queueReference = "QueueReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let delay = self.delay {
            try encodeContainer.encode(delay, forKey: .delay)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let queueReference = self.queueReference {
            try encodeContainer.encode(queueReference, forKey: .queueReference)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueReferenceDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.RoutingProfileQueueReference.self, forKey: .queueReference)
        queueReference = queueReferenceDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let delayDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .delay)
        delay = delayDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about the queue and channel for which priority and delay can be set.
    public struct RoutingProfileQueueConfig: Swift.Equatable {
        /// The delay, in seconds, a contact should be in the queue before they are routed to an available agent. For more information, see [Queues: priority and delay](https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html) in the Amazon Connect Administrator Guide.
        /// This member is required.
        public var delay: Swift.Int?
        /// The order in which contacts are to be handled for the queue. For more information, see [Queues: priority and delay](https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html).
        /// This member is required.
        public var priority: Swift.Int?
        /// Contains information about a queue resource.
        /// This member is required.
        public var queueReference: ConnectClientTypes.RoutingProfileQueueReference?

        public init(
            delay: Swift.Int? = nil,
            priority: Swift.Int? = nil,
            queueReference: ConnectClientTypes.RoutingProfileQueueReference? = nil
        )
        {
            self.delay = delay
            self.priority = priority
            self.queueReference = queueReference
        }
    }

}

extension ConnectClientTypes.RoutingProfileQueueConfigSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel = "Channel"
        case delay = "Delay"
        case priority = "Priority"
        case queueArn = "QueueArn"
        case queueId = "QueueId"
        case queueName = "QueueName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channel = self.channel {
            try encodeContainer.encode(channel.rawValue, forKey: .channel)
        }
        if delay != 0 {
            try encodeContainer.encode(delay, forKey: .delay)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let queueArn = self.queueArn {
            try encodeContainer.encode(queueArn, forKey: .queueArn)
        }
        if let queueId = self.queueId {
            try encodeContainer.encode(queueId, forKey: .queueId)
        }
        if let queueName = self.queueName {
            try encodeContainer.encode(queueName, forKey: .queueName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueId)
        queueId = queueIdDecoded
        let queueArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueArn)
        queueArn = queueArnDecoded
        let queueNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueName)
        queueName = queueNameDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let delayDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .delay) ?? 0
        delay = delayDecoded
        let channelDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Channel.self, forKey: .channel)
        channel = channelDecoded
    }
}

extension ConnectClientTypes {
    /// Contains summary information about a routing profile queue.
    public struct RoutingProfileQueueConfigSummary: Swift.Equatable {
        /// The channels this queue supports.
        /// This member is required.
        public var channel: ConnectClientTypes.Channel?
        /// The delay, in seconds, that a contact should be in the queue before they are routed to an available agent. For more information, see [Queues: priority and delay](https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html) in the Amazon Connect Administrator Guide.
        /// This member is required.
        public var delay: Swift.Int
        /// The order in which contacts are to be handled for the queue. For more information, see [Queues: priority and delay](https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html).
        /// This member is required.
        public var priority: Swift.Int?
        /// The Amazon Resource Name (ARN) of the queue.
        /// This member is required.
        public var queueArn: Swift.String?
        /// The identifier for the queue.
        /// This member is required.
        public var queueId: Swift.String?
        /// The name of the queue.
        /// This member is required.
        public var queueName: Swift.String?

        public init(
            channel: ConnectClientTypes.Channel? = nil,
            delay: Swift.Int = 0,
            priority: Swift.Int? = nil,
            queueArn: Swift.String? = nil,
            queueId: Swift.String? = nil,
            queueName: Swift.String? = nil
        )
        {
            self.channel = channel
            self.delay = delay
            self.priority = priority
            self.queueArn = queueArn
            self.queueId = queueId
            self.queueName = queueName
        }
    }

}

extension ConnectClientTypes.RoutingProfileQueueReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel = "Channel"
        case queueId = "QueueId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channel = self.channel {
            try encodeContainer.encode(channel.rawValue, forKey: .channel)
        }
        if let queueId = self.queueId {
            try encodeContainer.encode(queueId, forKey: .queueId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueId)
        queueId = queueIdDecoded
        let channelDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Channel.self, forKey: .channel)
        channel = channelDecoded
    }
}

extension ConnectClientTypes {
    /// Contains the channel and queue identifier for a routing profile.
    public struct RoutingProfileQueueReference: Swift.Equatable {
        /// The channels agents can handle in the Contact Control Panel (CCP) for this routing profile.
        /// This member is required.
        public var channel: ConnectClientTypes.Channel?
        /// The identifier for the queue.
        /// This member is required.
        public var queueId: Swift.String?

        public init(
            channel: ConnectClientTypes.Channel? = nil,
            queueId: Swift.String? = nil
        )
        {
            self.channel = channel
            self.queueId = queueId
        }
    }

}

extension ConnectClientTypes.RoutingProfileReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension ConnectClientTypes {
    /// Information about the routing profile assigned to the user.
    public struct RoutingProfileReference: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the routing profile.
        public var arn: Swift.String?
        /// The identifier of the routing profile.
        public var id: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
        }
    }

}

extension ConnectClientTypes.RoutingProfileSearchCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case andConditions = "AndConditions"
        case orConditions = "OrConditions"
        case stringCondition = "StringCondition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let andConditions = andConditions {
            var andConditionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .andConditions)
            for routingprofilesearchcriteria0 in andConditions {
                try andConditionsContainer.encode(routingprofilesearchcriteria0)
            }
        }
        if let orConditions = orConditions {
            var orConditionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .orConditions)
            for routingprofilesearchcriteria0 in orConditions {
                try orConditionsContainer.encode(routingprofilesearchcriteria0)
            }
        }
        if let stringCondition = self.stringCondition {
            try encodeContainer.encode(stringCondition, forKey: .stringCondition)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orConditionsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.RoutingProfileSearchCriteria?].self, forKey: .orConditions)
        var orConditionsDecoded0:[ConnectClientTypes.RoutingProfileSearchCriteria]? = nil
        if let orConditionsContainer = orConditionsContainer {
            orConditionsDecoded0 = [ConnectClientTypes.RoutingProfileSearchCriteria]()
            for structure0 in orConditionsContainer {
                if let structure0 = structure0 {
                    orConditionsDecoded0?.append(structure0)
                }
            }
        }
        orConditions = orConditionsDecoded0
        let andConditionsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.RoutingProfileSearchCriteria?].self, forKey: .andConditions)
        var andConditionsDecoded0:[ConnectClientTypes.RoutingProfileSearchCriteria]? = nil
        if let andConditionsContainer = andConditionsContainer {
            andConditionsDecoded0 = [ConnectClientTypes.RoutingProfileSearchCriteria]()
            for structure0 in andConditionsContainer {
                if let structure0 = structure0 {
                    andConditionsDecoded0?.append(structure0)
                }
            }
        }
        andConditions = andConditionsDecoded0
        let stringConditionDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.StringCondition.self, forKey: .stringCondition)
        stringCondition = stringConditionDecoded
    }
}

extension ConnectClientTypes {
    /// The search criteria to be used to return routing profiles. The name and description fields support "contains" queries with a minimum of 2 characters and a maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results.
    public struct RoutingProfileSearchCriteria: Swift.Equatable {
        /// A list of conditions which would be applied together with an AND condition.
        public var andConditions: [ConnectClientTypes.RoutingProfileSearchCriteria]?
        /// A list of conditions which would be applied together with an OR condition.
        public var orConditions: [ConnectClientTypes.RoutingProfileSearchCriteria]?
        /// A leaf node condition which can be used to specify a string condition. The currently supported values for FieldName are name, description, and resourceID.
        public var stringCondition: ConnectClientTypes.StringCondition?

        public init(
            andConditions: [ConnectClientTypes.RoutingProfileSearchCriteria]? = nil,
            orConditions: [ConnectClientTypes.RoutingProfileSearchCriteria]? = nil,
            stringCondition: ConnectClientTypes.StringCondition? = nil
        )
        {
            self.andConditions = andConditions
            self.orConditions = orConditions
            self.stringCondition = stringCondition
        }
    }

}

extension ConnectClientTypes.RoutingProfileSearchFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagFilter = "TagFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagFilter = self.tagFilter {
            try encodeContainer.encode(tagFilter, forKey: .tagFilter)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagFilterDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ControlPlaneTagFilter.self, forKey: .tagFilter)
        tagFilter = tagFilterDecoded
    }
}

extension ConnectClientTypes {
    /// Filters to be applied to search results.
    public struct RoutingProfileSearchFilter: Swift.Equatable {
        /// An object that can be used to specify Tag conditions inside the SearchFilter. This accepts an OR of AND (List of List) input where:
        ///
        /// * Top level list specifies conditions that need to be applied with OR operator
        ///
        /// * Inner list specifies conditions that need to be applied with AND operator.
        public var tagFilter: ConnectClientTypes.ControlPlaneTagFilter?

        public init(
            tagFilter: ConnectClientTypes.ControlPlaneTagFilter? = nil
        )
        {
            self.tagFilter = tagFilter
        }
    }

}

extension ConnectClientTypes.RoutingProfileSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case lastModifiedRegion = "LastModifiedRegion"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastModifiedRegion = self.lastModifiedRegion {
            try encodeContainer.encode(lastModifiedRegion, forKey: .lastModifiedRegion)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastModifiedRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedRegion)
        lastModifiedRegion = lastModifiedRegionDecoded
    }
}

extension ConnectClientTypes {
    /// Contains summary information about a routing profile.
    public struct RoutingProfileSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the routing profile.
        public var arn: Swift.String?
        /// The identifier of the routing profile.
        public var id: Swift.String?
        /// The Amazon Web Services Region where this resource was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when this resource was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name of the routing profile.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
        }
    }

}

extension ConnectClientTypes.Rule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case createdTime = "CreatedTime"
        case function = "Function"
        case lastUpdatedBy = "LastUpdatedBy"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case publishStatus = "PublishStatus"
        case ruleArn = "RuleArn"
        case ruleId = "RuleId"
        case tags = "Tags"
        case triggerEventSource = "TriggerEventSource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for ruleaction0 in actions {
                try actionsContainer.encode(ruleaction0)
            }
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let function = self.function {
            try encodeContainer.encode(function, forKey: .function)
        }
        if let lastUpdatedBy = self.lastUpdatedBy {
            try encodeContainer.encode(lastUpdatedBy, forKey: .lastUpdatedBy)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let publishStatus = self.publishStatus {
            try encodeContainer.encode(publishStatus.rawValue, forKey: .publishStatus)
        }
        if let ruleArn = self.ruleArn {
            try encodeContainer.encode(ruleArn, forKey: .ruleArn)
        }
        if let ruleId = self.ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let triggerEventSource = self.triggerEventSource {
            try encodeContainer.encode(triggerEventSource, forKey: .triggerEventSource)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ruleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let ruleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleArn)
        ruleArn = ruleArnDecoded
        let triggerEventSourceDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.RuleTriggerEventSource.self, forKey: .triggerEventSource)
        triggerEventSource = triggerEventSourceDecoded
        let functionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .function)
        function = functionDecoded
        let actionsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.RuleAction?].self, forKey: .actions)
        var actionsDecoded0:[ConnectClientTypes.RuleAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [ConnectClientTypes.RuleAction]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let publishStatusDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.RulePublishStatus.self, forKey: .publishStatus)
        publishStatus = publishStatusDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let lastUpdatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedBy)
        lastUpdatedBy = lastUpdatedByDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ConnectClientTypes {
    /// Information about a rule.
    public struct Rule: Swift.Equatable {
        /// A list of actions to be run when the rule is triggered.
        /// This member is required.
        public var actions: [ConnectClientTypes.RuleAction]?
        /// The timestamp for when the rule was created.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// The conditions of the rule.
        /// This member is required.
        public var function: Swift.String?
        /// The Amazon Resource Name (ARN) of the user who last updated the rule.
        /// This member is required.
        public var lastUpdatedBy: Swift.String?
        /// The timestamp for the when the rule was last updated.
        /// This member is required.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The name of the rule.
        /// This member is required.
        public var name: Swift.String?
        /// The publish status of the rule.
        /// This member is required.
        public var publishStatus: ConnectClientTypes.RulePublishStatus?
        /// The Amazon Resource Name (ARN) of the rule.
        /// This member is required.
        public var ruleArn: Swift.String?
        /// A unique identifier for the rule.
        /// This member is required.
        public var ruleId: Swift.String?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public var tags: [Swift.String:Swift.String]?
        /// The event source to trigger the rule.
        /// This member is required.
        public var triggerEventSource: ConnectClientTypes.RuleTriggerEventSource?

        public init(
            actions: [ConnectClientTypes.RuleAction]? = nil,
            createdTime: ClientRuntime.Date? = nil,
            function: Swift.String? = nil,
            lastUpdatedBy: Swift.String? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            publishStatus: ConnectClientTypes.RulePublishStatus? = nil,
            ruleArn: Swift.String? = nil,
            ruleId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            triggerEventSource: ConnectClientTypes.RuleTriggerEventSource? = nil
        )
        {
            self.actions = actions
            self.createdTime = createdTime
            self.function = function
            self.lastUpdatedBy = lastUpdatedBy
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.publishStatus = publishStatus
            self.ruleArn = ruleArn
            self.ruleId = ruleId
            self.tags = tags
            self.triggerEventSource = triggerEventSource
        }
    }

}

extension ConnectClientTypes.RuleAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionType = "ActionType"
        case assignContactCategoryAction = "AssignContactCategoryAction"
        case createCaseAction = "CreateCaseAction"
        case endAssociatedTasksAction = "EndAssociatedTasksAction"
        case eventBridgeAction = "EventBridgeAction"
        case sendNotificationAction = "SendNotificationAction"
        case taskAction = "TaskAction"
        case updateCaseAction = "UpdateCaseAction"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionType = self.actionType {
            try encodeContainer.encode(actionType.rawValue, forKey: .actionType)
        }
        if let assignContactCategoryAction = self.assignContactCategoryAction {
            try encodeContainer.encode(assignContactCategoryAction, forKey: .assignContactCategoryAction)
        }
        if let createCaseAction = self.createCaseAction {
            try encodeContainer.encode(createCaseAction, forKey: .createCaseAction)
        }
        if let endAssociatedTasksAction = self.endAssociatedTasksAction {
            try encodeContainer.encode(endAssociatedTasksAction, forKey: .endAssociatedTasksAction)
        }
        if let eventBridgeAction = self.eventBridgeAction {
            try encodeContainer.encode(eventBridgeAction, forKey: .eventBridgeAction)
        }
        if let sendNotificationAction = self.sendNotificationAction {
            try encodeContainer.encode(sendNotificationAction, forKey: .sendNotificationAction)
        }
        if let taskAction = self.taskAction {
            try encodeContainer.encode(taskAction, forKey: .taskAction)
        }
        if let updateCaseAction = self.updateCaseAction {
            try encodeContainer.encode(updateCaseAction, forKey: .updateCaseAction)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ActionType.self, forKey: .actionType)
        actionType = actionTypeDecoded
        let taskActionDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.TaskActionDefinition.self, forKey: .taskAction)
        taskAction = taskActionDecoded
        let eventBridgeActionDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.EventBridgeActionDefinition.self, forKey: .eventBridgeAction)
        eventBridgeAction = eventBridgeActionDecoded
        let assignContactCategoryActionDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.AssignContactCategoryActionDefinition.self, forKey: .assignContactCategoryAction)
        assignContactCategoryAction = assignContactCategoryActionDecoded
        let sendNotificationActionDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.SendNotificationActionDefinition.self, forKey: .sendNotificationAction)
        sendNotificationAction = sendNotificationActionDecoded
        let createCaseActionDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.CreateCaseActionDefinition.self, forKey: .createCaseAction)
        createCaseAction = createCaseActionDecoded
        let updateCaseActionDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.UpdateCaseActionDefinition.self, forKey: .updateCaseAction)
        updateCaseAction = updateCaseActionDecoded
        let endAssociatedTasksActionDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.EndAssociatedTasksActionDefinition.self, forKey: .endAssociatedTasksAction)
        endAssociatedTasksAction = endAssociatedTasksActionDecoded
    }
}

extension ConnectClientTypes {
    /// Information about the action to be performed when a rule is triggered.
    public struct RuleAction: Swift.Equatable {
        /// The type of action that creates a rule.
        /// This member is required.
        public var actionType: ConnectClientTypes.ActionType?
        /// Information about the contact category action. Supported only for TriggerEventSource values: OnPostCallAnalysisAvailable | OnRealTimeCallAnalysisAvailable | OnRealTimeChatAnalysisAvailable | OnPostChatAnalysisAvailable | OnZendeskTicketCreate | OnZendeskTicketStatusUpdate | OnSalesforceCaseCreate
        public var assignContactCategoryAction: ConnectClientTypes.AssignContactCategoryActionDefinition?
        /// Information about the create case action. Supported only for TriggerEventSource values: OnPostCallAnalysisAvailable | OnPostChatAnalysisAvailable.
        public var createCaseAction: ConnectClientTypes.CreateCaseActionDefinition?
        /// Information about the end associated tasks action. Supported only for TriggerEventSource values: OnCaseUpdate.
        public var endAssociatedTasksAction: ConnectClientTypes.EndAssociatedTasksActionDefinition?
        /// Information about the EventBridge action. Supported only for TriggerEventSource values: OnPostCallAnalysisAvailable | OnRealTimeCallAnalysisAvailable | OnRealTimeChatAnalysisAvailable | OnPostChatAnalysisAvailable | OnContactEvaluationSubmit | OnMetricDataUpdate
        public var eventBridgeAction: ConnectClientTypes.EventBridgeActionDefinition?
        /// Information about the send notification action. Supported only for TriggerEventSource values: OnPostCallAnalysisAvailable | OnRealTimeCallAnalysisAvailable | OnRealTimeChatAnalysisAvailable | OnPostChatAnalysisAvailable | OnContactEvaluationSubmit | OnMetricDataUpdate
        public var sendNotificationAction: ConnectClientTypes.SendNotificationActionDefinition?
        /// Information about the task action. This field is required if TriggerEventSource is one of the following values: OnZendeskTicketCreate | OnZendeskTicketStatusUpdate | OnSalesforceCaseCreate
        public var taskAction: ConnectClientTypes.TaskActionDefinition?
        /// Information about the update case action. Supported only for TriggerEventSource values: OnCaseCreate | OnCaseUpdate.
        public var updateCaseAction: ConnectClientTypes.UpdateCaseActionDefinition?

        public init(
            actionType: ConnectClientTypes.ActionType? = nil,
            assignContactCategoryAction: ConnectClientTypes.AssignContactCategoryActionDefinition? = nil,
            createCaseAction: ConnectClientTypes.CreateCaseActionDefinition? = nil,
            endAssociatedTasksAction: ConnectClientTypes.EndAssociatedTasksActionDefinition? = nil,
            eventBridgeAction: ConnectClientTypes.EventBridgeActionDefinition? = nil,
            sendNotificationAction: ConnectClientTypes.SendNotificationActionDefinition? = nil,
            taskAction: ConnectClientTypes.TaskActionDefinition? = nil,
            updateCaseAction: ConnectClientTypes.UpdateCaseActionDefinition? = nil
        )
        {
            self.actionType = actionType
            self.assignContactCategoryAction = assignContactCategoryAction
            self.createCaseAction = createCaseAction
            self.endAssociatedTasksAction = endAssociatedTasksAction
            self.eventBridgeAction = eventBridgeAction
            self.sendNotificationAction = sendNotificationAction
            self.taskAction = taskAction
            self.updateCaseAction = updateCaseAction
        }
    }

}

extension ConnectClientTypes {
    public enum RulePublishStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case draft
        case published
        case sdkUnknown(Swift.String)

        public static var allCases: [RulePublishStatus] {
            return [
                .draft,
                .published,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .draft: return "DRAFT"
            case .published: return "PUBLISHED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RulePublishStatus(rawValue: rawValue) ?? RulePublishStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.RuleSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionSummaries = "ActionSummaries"
        case createdTime = "CreatedTime"
        case eventSourceName = "EventSourceName"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case publishStatus = "PublishStatus"
        case ruleArn = "RuleArn"
        case ruleId = "RuleId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionSummaries = actionSummaries {
            var actionSummariesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actionSummaries)
            for actionsummary0 in actionSummaries {
                try actionSummariesContainer.encode(actionsummary0)
            }
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let eventSourceName = self.eventSourceName {
            try encodeContainer.encode(eventSourceName.rawValue, forKey: .eventSourceName)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let publishStatus = self.publishStatus {
            try encodeContainer.encode(publishStatus.rawValue, forKey: .publishStatus)
        }
        if let ruleArn = self.ruleArn {
            try encodeContainer.encode(ruleArn, forKey: .ruleArn)
        }
        if let ruleId = self.ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ruleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let ruleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleArn)
        ruleArn = ruleArnDecoded
        let eventSourceNameDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.EventSourceName.self, forKey: .eventSourceName)
        eventSourceName = eventSourceNameDecoded
        let publishStatusDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.RulePublishStatus.self, forKey: .publishStatus)
        publishStatus = publishStatusDecoded
        let actionSummariesContainer = try containerValues.decodeIfPresent([ConnectClientTypes.ActionSummary?].self, forKey: .actionSummaries)
        var actionSummariesDecoded0:[ConnectClientTypes.ActionSummary]? = nil
        if let actionSummariesContainer = actionSummariesContainer {
            actionSummariesDecoded0 = [ConnectClientTypes.ActionSummary]()
            for structure0 in actionSummariesContainer {
                if let structure0 = structure0 {
                    actionSummariesDecoded0?.append(structure0)
                }
            }
        }
        actionSummaries = actionSummariesDecoded0
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension ConnectClientTypes {
    /// A list of ActionTypes associated with a rule.
    public struct RuleSummary: Swift.Equatable {
        /// A list of ActionTypes associated with a rule.
        /// This member is required.
        public var actionSummaries: [ConnectClientTypes.ActionSummary]?
        /// The timestamp for when the rule was created.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// The name of the event source.
        /// This member is required.
        public var eventSourceName: ConnectClientTypes.EventSourceName?
        /// The timestamp for when the rule was last updated.
        /// This member is required.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The name of the rule.
        /// This member is required.
        public var name: Swift.String?
        /// The publish status of the rule.
        /// This member is required.
        public var publishStatus: ConnectClientTypes.RulePublishStatus?
        /// The Amazon Resource Name (ARN) of the rule.
        /// This member is required.
        public var ruleArn: Swift.String?
        /// A unique identifier for the rule.
        /// This member is required.
        public var ruleId: Swift.String?

        public init(
            actionSummaries: [ConnectClientTypes.ActionSummary]? = nil,
            createdTime: ClientRuntime.Date? = nil,
            eventSourceName: ConnectClientTypes.EventSourceName? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            publishStatus: ConnectClientTypes.RulePublishStatus? = nil,
            ruleArn: Swift.String? = nil,
            ruleId: Swift.String? = nil
        )
        {
            self.actionSummaries = actionSummaries
            self.createdTime = createdTime
            self.eventSourceName = eventSourceName
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.publishStatus = publishStatus
            self.ruleArn = ruleArn
            self.ruleId = ruleId
        }
    }

}

extension ConnectClientTypes.RuleTriggerEventSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSourceName = "EventSourceName"
        case integrationAssociationId = "IntegrationAssociationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventSourceName = self.eventSourceName {
            try encodeContainer.encode(eventSourceName.rawValue, forKey: .eventSourceName)
        }
        if let integrationAssociationId = self.integrationAssociationId {
            try encodeContainer.encode(integrationAssociationId, forKey: .integrationAssociationId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventSourceNameDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.EventSourceName.self, forKey: .eventSourceName)
        eventSourceName = eventSourceNameDecoded
        let integrationAssociationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationAssociationId)
        integrationAssociationId = integrationAssociationIdDecoded
    }
}

extension ConnectClientTypes {
    /// The name of the event source. This field is required if TriggerEventSource is one of the following values: OnZendeskTicketCreate | OnZendeskTicketStatusUpdate | OnSalesforceCaseCreate | OnContactEvaluationSubmit | OnMetricDataUpdate.
    public struct RuleTriggerEventSource: Swift.Equatable {
        /// The name of the event source.
        /// This member is required.
        public var eventSourceName: ConnectClientTypes.EventSourceName?
        /// The identifier for the integration association.
        public var integrationAssociationId: Swift.String?

        public init(
            eventSourceName: ConnectClientTypes.EventSourceName? = nil,
            integrationAssociationId: Swift.String? = nil
        )
        {
            self.eventSourceName = eventSourceName
            self.integrationAssociationId = integrationAssociationId
        }
    }

}

extension ConnectClientTypes.S3Config: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "BucketName"
        case bucketPrefix = "BucketPrefix"
        case encryptionConfig = "EncryptionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let bucketPrefix = self.bucketPrefix {
            try encodeContainer.encode(bucketPrefix, forKey: .bucketPrefix)
        }
        if let encryptionConfig = self.encryptionConfig {
            try encodeContainer.encode(encryptionConfig, forKey: .encryptionConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let bucketPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketPrefix)
        bucketPrefix = bucketPrefixDecoded
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
    }
}

extension ConnectClientTypes {
    /// Information about the Amazon Simple Storage Service (Amazon S3) storage type.
    public struct S3Config: Swift.Equatable {
        /// The S3 bucket name.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The S3 bucket prefix.
        /// This member is required.
        public var bucketPrefix: Swift.String?
        /// The Amazon S3 encryption configuration.
        public var encryptionConfig: ConnectClientTypes.EncryptionConfig?

        public init(
            bucketName: Swift.String? = nil,
            bucketPrefix: Swift.String? = nil,
            encryptionConfig: ConnectClientTypes.EncryptionConfig? = nil
        )
        {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.encryptionConfig = encryptionConfig
        }
    }

}

extension SearchAvailablePhoneNumbersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case phoneNumberCountryCode = "PhoneNumberCountryCode"
        case phoneNumberPrefix = "PhoneNumberPrefix"
        case phoneNumberType = "PhoneNumberType"
        case targetArn = "TargetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let phoneNumberCountryCode = self.phoneNumberCountryCode {
            try encodeContainer.encode(phoneNumberCountryCode.rawValue, forKey: .phoneNumberCountryCode)
        }
        if let phoneNumberPrefix = self.phoneNumberPrefix {
            try encodeContainer.encode(phoneNumberPrefix, forKey: .phoneNumberPrefix)
        }
        if let phoneNumberType = self.phoneNumberType {
            try encodeContainer.encode(phoneNumberType.rawValue, forKey: .phoneNumberType)
        }
        if let targetArn = self.targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }
}

extension SearchAvailablePhoneNumbersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/phone-number/search-available"
    }
}

public struct SearchAvailablePhoneNumbersInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance that phone numbers are claimed to. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance. You must enter InstanceId or TargetArn.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ISO country code.
    /// This member is required.
    public var phoneNumberCountryCode: ConnectClientTypes.PhoneNumberCountryCode?
    /// The prefix of the phone number. If provided, it must contain + as part of the country code.
    public var phoneNumberPrefix: Swift.String?
    /// The type of phone number.
    /// This member is required.
    public var phoneNumberType: ConnectClientTypes.PhoneNumberType?
    /// The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone number inbound traffic is routed through. You must enter InstanceId or TargetArn.
    public var targetArn: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        phoneNumberCountryCode: ConnectClientTypes.PhoneNumberCountryCode? = nil,
        phoneNumberPrefix: Swift.String? = nil,
        phoneNumberType: ConnectClientTypes.PhoneNumberType? = nil,
        targetArn: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.phoneNumberCountryCode = phoneNumberCountryCode
        self.phoneNumberPrefix = phoneNumberPrefix
        self.phoneNumberType = phoneNumberType
        self.targetArn = targetArn
    }
}

struct SearchAvailablePhoneNumbersInputBody: Swift.Equatable {
    let targetArn: Swift.String?
    let instanceId: Swift.String?
    let phoneNumberCountryCode: ConnectClientTypes.PhoneNumberCountryCode?
    let phoneNumberType: ConnectClientTypes.PhoneNumberType?
    let phoneNumberPrefix: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension SearchAvailablePhoneNumbersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case phoneNumberCountryCode = "PhoneNumberCountryCode"
        case phoneNumberPrefix = "PhoneNumberPrefix"
        case phoneNumberType = "PhoneNumberType"
        case targetArn = "TargetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let phoneNumberCountryCodeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.PhoneNumberCountryCode.self, forKey: .phoneNumberCountryCode)
        phoneNumberCountryCode = phoneNumberCountryCodeDecoded
        let phoneNumberTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.PhoneNumberType.self, forKey: .phoneNumberType)
        phoneNumberType = phoneNumberTypeDecoded
        let phoneNumberPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberPrefix)
        phoneNumberPrefix = phoneNumberPrefixDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension SearchAvailablePhoneNumbersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchAvailablePhoneNumbersOutputBody = try responseDecoder.decode(responseBody: data)
            self.availableNumbersList = output.availableNumbersList
            self.nextToken = output.nextToken
        } else {
            self.availableNumbersList = nil
            self.nextToken = nil
        }
    }
}

public struct SearchAvailablePhoneNumbersOutput: Swift.Equatable {
    /// A list of available phone numbers that you can claim to your Amazon Connect instance or traffic distribution group.
    public var availableNumbersList: [ConnectClientTypes.AvailableNumberSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        availableNumbersList: [ConnectClientTypes.AvailableNumberSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.availableNumbersList = availableNumbersList
        self.nextToken = nextToken
    }
}

struct SearchAvailablePhoneNumbersOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let availableNumbersList: [ConnectClientTypes.AvailableNumberSummary]?
}

extension SearchAvailablePhoneNumbersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availableNumbersList = "AvailableNumbersList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let availableNumbersListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.AvailableNumberSummary?].self, forKey: .availableNumbersList)
        var availableNumbersListDecoded0:[ConnectClientTypes.AvailableNumberSummary]? = nil
        if let availableNumbersListContainer = availableNumbersListContainer {
            availableNumbersListDecoded0 = [ConnectClientTypes.AvailableNumberSummary]()
            for structure0 in availableNumbersListContainer {
                if let structure0 = structure0 {
                    availableNumbersListDecoded0?.append(structure0)
                }
            }
        }
        availableNumbersList = availableNumbersListDecoded0
    }
}

enum SearchAvailablePhoneNumbersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SearchHoursOfOperationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case searchCriteria = "SearchCriteria"
        case searchFilter = "SearchFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let searchCriteria = self.searchCriteria {
            try encodeContainer.encode(searchCriteria, forKey: .searchCriteria)
        }
        if let searchFilter = self.searchFilter {
            try encodeContainer.encode(searchFilter, forKey: .searchFilter)
        }
    }
}

extension SearchHoursOfOperationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/search-hours-of-operations"
    }
}

public struct SearchHoursOfOperationsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The search criteria to be used to return hours of operations.
    public var searchCriteria: ConnectClientTypes.HoursOfOperationSearchCriteria?
    /// Filters to be applied to search results.
    public var searchFilter: ConnectClientTypes.HoursOfOperationSearchFilter?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchCriteria: ConnectClientTypes.HoursOfOperationSearchCriteria? = nil,
        searchFilter: ConnectClientTypes.HoursOfOperationSearchFilter? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchCriteria = searchCriteria
        self.searchFilter = searchFilter
    }
}

struct SearchHoursOfOperationsInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let searchFilter: ConnectClientTypes.HoursOfOperationSearchFilter?
    let searchCriteria: ConnectClientTypes.HoursOfOperationSearchCriteria?
}

extension SearchHoursOfOperationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case searchCriteria = "SearchCriteria"
        case searchFilter = "SearchFilter"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let searchFilterDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HoursOfOperationSearchFilter.self, forKey: .searchFilter)
        searchFilter = searchFilterDecoded
        let searchCriteriaDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HoursOfOperationSearchCriteria.self, forKey: .searchCriteria)
        searchCriteria = searchCriteriaDecoded
    }
}

extension SearchHoursOfOperationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchHoursOfOperationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.approximateTotalCount = output.approximateTotalCount
            self.hoursOfOperations = output.hoursOfOperations
            self.nextToken = output.nextToken
        } else {
            self.approximateTotalCount = nil
            self.hoursOfOperations = nil
            self.nextToken = nil
        }
    }
}

public struct SearchHoursOfOperationsOutput: Swift.Equatable {
    /// The total number of hours of operations which matched your search query.
    public var approximateTotalCount: Swift.Int?
    /// Information about the hours of operations.
    public var hoursOfOperations: [ConnectClientTypes.HoursOfOperation]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        approximateTotalCount: Swift.Int? = nil,
        hoursOfOperations: [ConnectClientTypes.HoursOfOperation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.approximateTotalCount = approximateTotalCount
        self.hoursOfOperations = hoursOfOperations
        self.nextToken = nextToken
    }
}

struct SearchHoursOfOperationsOutputBody: Swift.Equatable {
    let hoursOfOperations: [ConnectClientTypes.HoursOfOperation]?
    let nextToken: Swift.String?
    let approximateTotalCount: Swift.Int?
}

extension SearchHoursOfOperationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approximateTotalCount = "ApproximateTotalCount"
        case hoursOfOperations = "HoursOfOperations"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hoursOfOperationsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.HoursOfOperation?].self, forKey: .hoursOfOperations)
        var hoursOfOperationsDecoded0:[ConnectClientTypes.HoursOfOperation]? = nil
        if let hoursOfOperationsContainer = hoursOfOperationsContainer {
            hoursOfOperationsDecoded0 = [ConnectClientTypes.HoursOfOperation]()
            for structure0 in hoursOfOperationsContainer {
                if let structure0 = structure0 {
                    hoursOfOperationsDecoded0?.append(structure0)
                }
            }
        }
        hoursOfOperations = hoursOfOperationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let approximateTotalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .approximateTotalCount)
        approximateTotalCount = approximateTotalCountDecoded
    }
}

enum SearchHoursOfOperationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SearchPromptsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case searchCriteria = "SearchCriteria"
        case searchFilter = "SearchFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let searchCriteria = self.searchCriteria {
            try encodeContainer.encode(searchCriteria, forKey: .searchCriteria)
        }
        if let searchFilter = self.searchFilter {
            try encodeContainer.encode(searchFilter, forKey: .searchFilter)
        }
    }
}

extension SearchPromptsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/search-prompts"
    }
}

public struct SearchPromptsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The search criteria to be used to return prompts.
    public var searchCriteria: ConnectClientTypes.PromptSearchCriteria?
    /// Filters to be applied to search results.
    public var searchFilter: ConnectClientTypes.PromptSearchFilter?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchCriteria: ConnectClientTypes.PromptSearchCriteria? = nil,
        searchFilter: ConnectClientTypes.PromptSearchFilter? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchCriteria = searchCriteria
        self.searchFilter = searchFilter
    }
}

struct SearchPromptsInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let searchFilter: ConnectClientTypes.PromptSearchFilter?
    let searchCriteria: ConnectClientTypes.PromptSearchCriteria?
}

extension SearchPromptsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case searchCriteria = "SearchCriteria"
        case searchFilter = "SearchFilter"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let searchFilterDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.PromptSearchFilter.self, forKey: .searchFilter)
        searchFilter = searchFilterDecoded
        let searchCriteriaDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.PromptSearchCriteria.self, forKey: .searchCriteria)
        searchCriteria = searchCriteriaDecoded
    }
}

extension SearchPromptsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchPromptsOutputBody = try responseDecoder.decode(responseBody: data)
            self.approximateTotalCount = output.approximateTotalCount
            self.nextToken = output.nextToken
            self.prompts = output.prompts
        } else {
            self.approximateTotalCount = nil
            self.nextToken = nil
            self.prompts = nil
        }
    }
}

public struct SearchPromptsOutput: Swift.Equatable {
    /// The total number of quick connects which matched your search query.
    public var approximateTotalCount: Swift.Int?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the prompts.
    public var prompts: [ConnectClientTypes.Prompt]?

    public init(
        approximateTotalCount: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        prompts: [ConnectClientTypes.Prompt]? = nil
    )
    {
        self.approximateTotalCount = approximateTotalCount
        self.nextToken = nextToken
        self.prompts = prompts
    }
}

struct SearchPromptsOutputBody: Swift.Equatable {
    let prompts: [ConnectClientTypes.Prompt]?
    let nextToken: Swift.String?
    let approximateTotalCount: Swift.Int?
}

extension SearchPromptsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approximateTotalCount = "ApproximateTotalCount"
        case nextToken = "NextToken"
        case prompts = "Prompts"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let promptsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.Prompt?].self, forKey: .prompts)
        var promptsDecoded0:[ConnectClientTypes.Prompt]? = nil
        if let promptsContainer = promptsContainer {
            promptsDecoded0 = [ConnectClientTypes.Prompt]()
            for structure0 in promptsContainer {
                if let structure0 = structure0 {
                    promptsDecoded0?.append(structure0)
                }
            }
        }
        prompts = promptsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let approximateTotalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .approximateTotalCount)
        approximateTotalCount = approximateTotalCountDecoded
    }
}

enum SearchPromptsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SearchQueuesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case searchCriteria = "SearchCriteria"
        case searchFilter = "SearchFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let searchCriteria = self.searchCriteria {
            try encodeContainer.encode(searchCriteria, forKey: .searchCriteria)
        }
        if let searchFilter = self.searchFilter {
            try encodeContainer.encode(searchFilter, forKey: .searchFilter)
        }
    }
}

extension SearchQueuesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/search-queues"
    }
}

public struct SearchQueuesInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The search criteria to be used to return queues. The name and description fields support "contains" queries with a minimum of 2 characters and a maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results.
    public var searchCriteria: ConnectClientTypes.QueueSearchCriteria?
    /// Filters to be applied to search results.
    public var searchFilter: ConnectClientTypes.QueueSearchFilter?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchCriteria: ConnectClientTypes.QueueSearchCriteria? = nil,
        searchFilter: ConnectClientTypes.QueueSearchFilter? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchCriteria = searchCriteria
        self.searchFilter = searchFilter
    }
}

struct SearchQueuesInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let searchFilter: ConnectClientTypes.QueueSearchFilter?
    let searchCriteria: ConnectClientTypes.QueueSearchCriteria?
}

extension SearchQueuesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case searchCriteria = "SearchCriteria"
        case searchFilter = "SearchFilter"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let searchFilterDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.QueueSearchFilter.self, forKey: .searchFilter)
        searchFilter = searchFilterDecoded
        let searchCriteriaDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.QueueSearchCriteria.self, forKey: .searchCriteria)
        searchCriteria = searchCriteriaDecoded
    }
}

extension SearchQueuesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchQueuesOutputBody = try responseDecoder.decode(responseBody: data)
            self.approximateTotalCount = output.approximateTotalCount
            self.nextToken = output.nextToken
            self.queues = output.queues
        } else {
            self.approximateTotalCount = nil
            self.nextToken = nil
            self.queues = nil
        }
    }
}

public struct SearchQueuesOutput: Swift.Equatable {
    /// The total number of queues which matched your search query.
    public var approximateTotalCount: Swift.Int?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the queues.
    public var queues: [ConnectClientTypes.Queue]?

    public init(
        approximateTotalCount: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queues: [ConnectClientTypes.Queue]? = nil
    )
    {
        self.approximateTotalCount = approximateTotalCount
        self.nextToken = nextToken
        self.queues = queues
    }
}

struct SearchQueuesOutputBody: Swift.Equatable {
    let queues: [ConnectClientTypes.Queue]?
    let nextToken: Swift.String?
    let approximateTotalCount: Swift.Int?
}

extension SearchQueuesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approximateTotalCount = "ApproximateTotalCount"
        case nextToken = "NextToken"
        case queues = "Queues"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queuesContainer = try containerValues.decodeIfPresent([ConnectClientTypes.Queue?].self, forKey: .queues)
        var queuesDecoded0:[ConnectClientTypes.Queue]? = nil
        if let queuesContainer = queuesContainer {
            queuesDecoded0 = [ConnectClientTypes.Queue]()
            for structure0 in queuesContainer {
                if let structure0 = structure0 {
                    queuesDecoded0?.append(structure0)
                }
            }
        }
        queues = queuesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let approximateTotalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .approximateTotalCount)
        approximateTotalCount = approximateTotalCountDecoded
    }
}

enum SearchQueuesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SearchQuickConnectsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case searchCriteria = "SearchCriteria"
        case searchFilter = "SearchFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let searchCriteria = self.searchCriteria {
            try encodeContainer.encode(searchCriteria, forKey: .searchCriteria)
        }
        if let searchFilter = self.searchFilter {
            try encodeContainer.encode(searchFilter, forKey: .searchFilter)
        }
    }
}

extension SearchQuickConnectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/search-quick-connects"
    }
}

public struct SearchQuickConnectsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The search criteria to be used to return quick connects.
    public var searchCriteria: ConnectClientTypes.QuickConnectSearchCriteria?
    /// Filters to be applied to search results.
    public var searchFilter: ConnectClientTypes.QuickConnectSearchFilter?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchCriteria: ConnectClientTypes.QuickConnectSearchCriteria? = nil,
        searchFilter: ConnectClientTypes.QuickConnectSearchFilter? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchCriteria = searchCriteria
        self.searchFilter = searchFilter
    }
}

struct SearchQuickConnectsInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let searchFilter: ConnectClientTypes.QuickConnectSearchFilter?
    let searchCriteria: ConnectClientTypes.QuickConnectSearchCriteria?
}

extension SearchQuickConnectsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case searchCriteria = "SearchCriteria"
        case searchFilter = "SearchFilter"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let searchFilterDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.QuickConnectSearchFilter.self, forKey: .searchFilter)
        searchFilter = searchFilterDecoded
        let searchCriteriaDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.QuickConnectSearchCriteria.self, forKey: .searchCriteria)
        searchCriteria = searchCriteriaDecoded
    }
}

extension SearchQuickConnectsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchQuickConnectsOutputBody = try responseDecoder.decode(responseBody: data)
            self.approximateTotalCount = output.approximateTotalCount
            self.nextToken = output.nextToken
            self.quickConnects = output.quickConnects
        } else {
            self.approximateTotalCount = nil
            self.nextToken = nil
            self.quickConnects = nil
        }
    }
}

public struct SearchQuickConnectsOutput: Swift.Equatable {
    /// The total number of quick connects which matched your search query.
    public var approximateTotalCount: Swift.Int?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the quick connects.
    public var quickConnects: [ConnectClientTypes.QuickConnect]?

    public init(
        approximateTotalCount: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        quickConnects: [ConnectClientTypes.QuickConnect]? = nil
    )
    {
        self.approximateTotalCount = approximateTotalCount
        self.nextToken = nextToken
        self.quickConnects = quickConnects
    }
}

struct SearchQuickConnectsOutputBody: Swift.Equatable {
    let quickConnects: [ConnectClientTypes.QuickConnect]?
    let nextToken: Swift.String?
    let approximateTotalCount: Swift.Int?
}

extension SearchQuickConnectsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approximateTotalCount = "ApproximateTotalCount"
        case nextToken = "NextToken"
        case quickConnects = "QuickConnects"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quickConnectsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.QuickConnect?].self, forKey: .quickConnects)
        var quickConnectsDecoded0:[ConnectClientTypes.QuickConnect]? = nil
        if let quickConnectsContainer = quickConnectsContainer {
            quickConnectsDecoded0 = [ConnectClientTypes.QuickConnect]()
            for structure0 in quickConnectsContainer {
                if let structure0 = structure0 {
                    quickConnectsDecoded0?.append(structure0)
                }
            }
        }
        quickConnects = quickConnectsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let approximateTotalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .approximateTotalCount)
        approximateTotalCount = approximateTotalCountDecoded
    }
}

enum SearchQuickConnectsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SearchResourceTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceTypes = "ResourceTypes"
        case searchCriteria = "SearchCriteria"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceTypes = resourceTypes {
            var resourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypes)
            for string0 in resourceTypes {
                try resourceTypesContainer.encode(string0)
            }
        }
        if let searchCriteria = self.searchCriteria {
            try encodeContainer.encode(searchCriteria, forKey: .searchCriteria)
        }
    }
}

extension SearchResourceTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/search-resource-tags"
    }
}

public struct SearchResourceTagsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The list of resource types to be used to search tags from. If not provided or if any empty list is provided, this API will search from all supported resource types.
    public var resourceTypes: [Swift.String]?
    /// The search criteria to be used to return tags.
    public var searchCriteria: ConnectClientTypes.ResourceTagsSearchCriteria?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceTypes: [Swift.String]? = nil,
        searchCriteria: ConnectClientTypes.ResourceTagsSearchCriteria? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceTypes = resourceTypes
        self.searchCriteria = searchCriteria
    }
}

struct SearchResourceTagsInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let resourceTypes: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let searchCriteria: ConnectClientTypes.ResourceTagsSearchCriteria?
}

extension SearchResourceTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceTypes = "ResourceTypes"
        case searchCriteria = "SearchCriteria"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let resourceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[Swift.String]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [Swift.String]()
            for string0 in resourceTypesContainer {
                if let string0 = string0 {
                    resourceTypesDecoded0?.append(string0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let searchCriteriaDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ResourceTagsSearchCriteria.self, forKey: .searchCriteria)
        searchCriteria = searchCriteriaDecoded
    }
}

extension SearchResourceTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchResourceTagsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct SearchResourceTagsOutput: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// A list of tags used in the Amazon Connect instance.
    public var tags: [ConnectClientTypes.TagSet]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [ConnectClientTypes.TagSet]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct SearchResourceTagsOutputBody: Swift.Equatable {
    let tags: [ConnectClientTypes.TagSet]?
    let nextToken: Swift.String?
}

extension SearchResourceTagsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.TagSet?].self, forKey: .tags)
        var tagsDecoded0:[ConnectClientTypes.TagSet]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ConnectClientTypes.TagSet]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum SearchResourceTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MaximumResultReturnedException": return try await MaximumResultReturnedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SearchRoutingProfilesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case searchCriteria = "SearchCriteria"
        case searchFilter = "SearchFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let searchCriteria = self.searchCriteria {
            try encodeContainer.encode(searchCriteria, forKey: .searchCriteria)
        }
        if let searchFilter = self.searchFilter {
            try encodeContainer.encode(searchFilter, forKey: .searchFilter)
        }
    }
}

extension SearchRoutingProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/search-routing-profiles"
    }
}

public struct SearchRoutingProfilesInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The search criteria to be used to return routing profiles. The name and description fields support "contains" queries with a minimum of 2 characters and a maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results.
    public var searchCriteria: ConnectClientTypes.RoutingProfileSearchCriteria?
    /// Filters to be applied to search results.
    public var searchFilter: ConnectClientTypes.RoutingProfileSearchFilter?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchCriteria: ConnectClientTypes.RoutingProfileSearchCriteria? = nil,
        searchFilter: ConnectClientTypes.RoutingProfileSearchFilter? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchCriteria = searchCriteria
        self.searchFilter = searchFilter
    }
}

struct SearchRoutingProfilesInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let searchFilter: ConnectClientTypes.RoutingProfileSearchFilter?
    let searchCriteria: ConnectClientTypes.RoutingProfileSearchCriteria?
}

extension SearchRoutingProfilesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case searchCriteria = "SearchCriteria"
        case searchFilter = "SearchFilter"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let searchFilterDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.RoutingProfileSearchFilter.self, forKey: .searchFilter)
        searchFilter = searchFilterDecoded
        let searchCriteriaDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.RoutingProfileSearchCriteria.self, forKey: .searchCriteria)
        searchCriteria = searchCriteriaDecoded
    }
}

extension SearchRoutingProfilesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchRoutingProfilesOutputBody = try responseDecoder.decode(responseBody: data)
            self.approximateTotalCount = output.approximateTotalCount
            self.nextToken = output.nextToken
            self.routingProfiles = output.routingProfiles
        } else {
            self.approximateTotalCount = nil
            self.nextToken = nil
            self.routingProfiles = nil
        }
    }
}

public struct SearchRoutingProfilesOutput: Swift.Equatable {
    /// The total number of routing profiles which matched your search query.
    public var approximateTotalCount: Swift.Int?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the routing profiles.
    public var routingProfiles: [ConnectClientTypes.RoutingProfile]?

    public init(
        approximateTotalCount: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        routingProfiles: [ConnectClientTypes.RoutingProfile]? = nil
    )
    {
        self.approximateTotalCount = approximateTotalCount
        self.nextToken = nextToken
        self.routingProfiles = routingProfiles
    }
}

struct SearchRoutingProfilesOutputBody: Swift.Equatable {
    let routingProfiles: [ConnectClientTypes.RoutingProfile]?
    let nextToken: Swift.String?
    let approximateTotalCount: Swift.Int?
}

extension SearchRoutingProfilesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approximateTotalCount = "ApproximateTotalCount"
        case nextToken = "NextToken"
        case routingProfiles = "RoutingProfiles"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routingProfilesContainer = try containerValues.decodeIfPresent([ConnectClientTypes.RoutingProfile?].self, forKey: .routingProfiles)
        var routingProfilesDecoded0:[ConnectClientTypes.RoutingProfile]? = nil
        if let routingProfilesContainer = routingProfilesContainer {
            routingProfilesDecoded0 = [ConnectClientTypes.RoutingProfile]()
            for structure0 in routingProfilesContainer {
                if let structure0 = structure0 {
                    routingProfilesDecoded0?.append(structure0)
                }
            }
        }
        routingProfiles = routingProfilesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let approximateTotalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .approximateTotalCount)
        approximateTotalCount = approximateTotalCountDecoded
    }
}

enum SearchRoutingProfilesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SearchSecurityProfilesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case searchCriteria = "SearchCriteria"
        case searchFilter = "SearchFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let searchCriteria = self.searchCriteria {
            try encodeContainer.encode(searchCriteria, forKey: .searchCriteria)
        }
        if let searchFilter = self.searchFilter {
            try encodeContainer.encode(searchFilter, forKey: .searchFilter)
        }
    }
}

extension SearchSecurityProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/search-security-profiles"
    }
}

public struct SearchSecurityProfilesInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The search criteria to be used to return security profiles. The name field support "contains" queries with a minimum of 2 characters and maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results. The currently supported value for FieldName: name
    public var searchCriteria: ConnectClientTypes.SecurityProfileSearchCriteria?
    /// Filters to be applied to search results.
    public var searchFilter: ConnectClientTypes.SecurityProfilesSearchFilter?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchCriteria: ConnectClientTypes.SecurityProfileSearchCriteria? = nil,
        searchFilter: ConnectClientTypes.SecurityProfilesSearchFilter? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchCriteria = searchCriteria
        self.searchFilter = searchFilter
    }
}

struct SearchSecurityProfilesInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let searchCriteria: ConnectClientTypes.SecurityProfileSearchCriteria?
    let searchFilter: ConnectClientTypes.SecurityProfilesSearchFilter?
}

extension SearchSecurityProfilesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case searchCriteria = "SearchCriteria"
        case searchFilter = "SearchFilter"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let searchCriteriaDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.SecurityProfileSearchCriteria.self, forKey: .searchCriteria)
        searchCriteria = searchCriteriaDecoded
        let searchFilterDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.SecurityProfilesSearchFilter.self, forKey: .searchFilter)
        searchFilter = searchFilterDecoded
    }
}

extension SearchSecurityProfilesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchSecurityProfilesOutputBody = try responseDecoder.decode(responseBody: data)
            self.approximateTotalCount = output.approximateTotalCount
            self.nextToken = output.nextToken
            self.securityProfiles = output.securityProfiles
        } else {
            self.approximateTotalCount = nil
            self.nextToken = nil
            self.securityProfiles = nil
        }
    }
}

public struct SearchSecurityProfilesOutput: Swift.Equatable {
    /// The total number of security profiles which matched your search query.
    public var approximateTotalCount: Swift.Int?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the security profiles.
    public var securityProfiles: [ConnectClientTypes.SecurityProfileSearchSummary]?

    public init(
        approximateTotalCount: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        securityProfiles: [ConnectClientTypes.SecurityProfileSearchSummary]? = nil
    )
    {
        self.approximateTotalCount = approximateTotalCount
        self.nextToken = nextToken
        self.securityProfiles = securityProfiles
    }
}

struct SearchSecurityProfilesOutputBody: Swift.Equatable {
    let securityProfiles: [ConnectClientTypes.SecurityProfileSearchSummary]?
    let nextToken: Swift.String?
    let approximateTotalCount: Swift.Int?
}

extension SearchSecurityProfilesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approximateTotalCount = "ApproximateTotalCount"
        case nextToken = "NextToken"
        case securityProfiles = "SecurityProfiles"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityProfilesContainer = try containerValues.decodeIfPresent([ConnectClientTypes.SecurityProfileSearchSummary?].self, forKey: .securityProfiles)
        var securityProfilesDecoded0:[ConnectClientTypes.SecurityProfileSearchSummary]? = nil
        if let securityProfilesContainer = securityProfilesContainer {
            securityProfilesDecoded0 = [ConnectClientTypes.SecurityProfileSearchSummary]()
            for structure0 in securityProfilesContainer {
                if let structure0 = structure0 {
                    securityProfilesDecoded0?.append(structure0)
                }
            }
        }
        securityProfiles = securityProfilesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let approximateTotalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .approximateTotalCount)
        approximateTotalCount = approximateTotalCountDecoded
    }
}

enum SearchSecurityProfilesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SearchUsersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case searchCriteria = "SearchCriteria"
        case searchFilter = "SearchFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let searchCriteria = self.searchCriteria {
            try encodeContainer.encode(searchCriteria, forKey: .searchCriteria)
        }
        if let searchFilter = self.searchFilter {
            try encodeContainer.encode(searchFilter, forKey: .searchFilter)
        }
    }
}

extension SearchUsersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/search-users"
    }
}

public struct SearchUsersInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance. InstanceID is a required field. The "Required: No" below is incorrect.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The search criteria to be used to return users. The name and description fields support "contains" queries with a minimum of 2 characters and a maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results.
    public var searchCriteria: ConnectClientTypes.UserSearchCriteria?
    /// Filters to be applied to search results.
    public var searchFilter: ConnectClientTypes.UserSearchFilter?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchCriteria: ConnectClientTypes.UserSearchCriteria? = nil,
        searchFilter: ConnectClientTypes.UserSearchFilter? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchCriteria = searchCriteria
        self.searchFilter = searchFilter
    }
}

struct SearchUsersInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let searchFilter: ConnectClientTypes.UserSearchFilter?
    let searchCriteria: ConnectClientTypes.UserSearchCriteria?
}

extension SearchUsersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case searchCriteria = "SearchCriteria"
        case searchFilter = "SearchFilter"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let searchFilterDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.UserSearchFilter.self, forKey: .searchFilter)
        searchFilter = searchFilterDecoded
        let searchCriteriaDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.UserSearchCriteria.self, forKey: .searchCriteria)
        searchCriteria = searchCriteriaDecoded
    }
}

extension SearchUsersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchUsersOutputBody = try responseDecoder.decode(responseBody: data)
            self.approximateTotalCount = output.approximateTotalCount
            self.nextToken = output.nextToken
            self.users = output.users
        } else {
            self.approximateTotalCount = nil
            self.nextToken = nil
            self.users = nil
        }
    }
}

public struct SearchUsersOutput: Swift.Equatable {
    /// The total number of users who matched your search query.
    public var approximateTotalCount: Swift.Int?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the users.
    public var users: [ConnectClientTypes.UserSearchSummary]?

    public init(
        approximateTotalCount: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        users: [ConnectClientTypes.UserSearchSummary]? = nil
    )
    {
        self.approximateTotalCount = approximateTotalCount
        self.nextToken = nextToken
        self.users = users
    }
}

struct SearchUsersOutputBody: Swift.Equatable {
    let users: [ConnectClientTypes.UserSearchSummary]?
    let nextToken: Swift.String?
    let approximateTotalCount: Swift.Int?
}

extension SearchUsersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approximateTotalCount = "ApproximateTotalCount"
        case nextToken = "NextToken"
        case users = "Users"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usersContainer = try containerValues.decodeIfPresent([ConnectClientTypes.UserSearchSummary?].self, forKey: .users)
        var usersDecoded0:[ConnectClientTypes.UserSearchSummary]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [ConnectClientTypes.UserSearchSummary]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let approximateTotalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .approximateTotalCount)
        approximateTotalCount = approximateTotalCountDecoded
    }
}

enum SearchUsersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SearchVocabulariesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case languageCode = "LanguageCode"
        case maxResults = "MaxResults"
        case nameStartsWith = "NameStartsWith"
        case nextToken = "NextToken"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nameStartsWith = self.nameStartsWith {
            try encodeContainer.encode(nameStartsWith, forKey: .nameStartsWith)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }
}

extension SearchVocabulariesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/vocabulary-summary/\(instanceId.urlPercentEncoding())"
    }
}

public struct SearchVocabulariesInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see [What is Amazon Transcribe?](https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html)
    public var languageCode: ConnectClientTypes.VocabularyLanguageCode?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The starting pattern of the name of the vocabulary.
    public var nameStartsWith: Swift.String?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The current state of the custom vocabulary.
    public var state: ConnectClientTypes.VocabularyState?

    public init(
        instanceId: Swift.String? = nil,
        languageCode: ConnectClientTypes.VocabularyLanguageCode? = nil,
        maxResults: Swift.Int? = nil,
        nameStartsWith: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        state: ConnectClientTypes.VocabularyState? = nil
    )
    {
        self.instanceId = instanceId
        self.languageCode = languageCode
        self.maxResults = maxResults
        self.nameStartsWith = nameStartsWith
        self.nextToken = nextToken
        self.state = state
    }
}

struct SearchVocabulariesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let state: ConnectClientTypes.VocabularyState?
    let nameStartsWith: Swift.String?
    let languageCode: ConnectClientTypes.VocabularyLanguageCode?
}

extension SearchVocabulariesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case languageCode = "LanguageCode"
        case maxResults = "MaxResults"
        case nameStartsWith = "NameStartsWith"
        case nextToken = "NextToken"
        case state = "State"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.VocabularyState.self, forKey: .state)
        state = stateDecoded
        let nameStartsWithDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nameStartsWith)
        nameStartsWith = nameStartsWithDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.VocabularyLanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
    }
}

extension SearchVocabulariesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchVocabulariesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.vocabularySummaryList = output.vocabularySummaryList
        } else {
            self.nextToken = nil
            self.vocabularySummaryList = nil
        }
    }
}

public struct SearchVocabulariesOutput: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// The list of the available custom vocabularies.
    public var vocabularySummaryList: [ConnectClientTypes.VocabularySummary]?

    public init(
        nextToken: Swift.String? = nil,
        vocabularySummaryList: [ConnectClientTypes.VocabularySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.vocabularySummaryList = vocabularySummaryList
    }
}

struct SearchVocabulariesOutputBody: Swift.Equatable {
    let vocabularySummaryList: [ConnectClientTypes.VocabularySummary]?
    let nextToken: Swift.String?
}

extension SearchVocabulariesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case vocabularySummaryList = "VocabularySummaryList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vocabularySummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.VocabularySummary?].self, forKey: .vocabularySummaryList)
        var vocabularySummaryListDecoded0:[ConnectClientTypes.VocabularySummary]? = nil
        if let vocabularySummaryListContainer = vocabularySummaryListContainer {
            vocabularySummaryListDecoded0 = [ConnectClientTypes.VocabularySummary]()
            for structure0 in vocabularySummaryListContainer {
                if let structure0 = structure0 {
                    vocabularySummaryListDecoded0?.append(structure0)
                }
            }
        }
        vocabularySummaryList = vocabularySummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum SearchVocabulariesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectClientTypes {
    public enum SearchableQueueType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchableQueueType] {
            return [
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SearchableQueueType(rawValue: rawValue) ?? SearchableQueueType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.SecurityKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case creationTime = "CreationTime"
        case key = "Key"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = self.associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension ConnectClientTypes {
    /// Configuration information of the security key.
    public struct SecurityKey: Swift.Equatable {
        /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
        public var associationId: Swift.String?
        /// When the security key was created.
        public var creationTime: ClientRuntime.Date?
        /// The key of the security key.
        public var key: Swift.String?

        public init(
            associationId: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            key: Swift.String? = nil
        )
        {
            self.associationId = associationId
            self.creationTime = creationTime
            self.key = key
        }
    }

}

extension ConnectClientTypes.SecurityProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedAccessControlTags = "AllowedAccessControlTags"
        case arn = "Arn"
        case description = "Description"
        case id = "Id"
        case lastModifiedRegion = "LastModifiedRegion"
        case lastModifiedTime = "LastModifiedTime"
        case organizationResourceId = "OrganizationResourceId"
        case securityProfileName = "SecurityProfileName"
        case tagRestrictedResources = "TagRestrictedResources"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedAccessControlTags = allowedAccessControlTags {
            var allowedAccessControlTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .allowedAccessControlTags)
            for (dictKey0, allowedAccessControlTags0) in allowedAccessControlTags {
                try allowedAccessControlTagsContainer.encode(allowedAccessControlTags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastModifiedRegion = self.lastModifiedRegion {
            try encodeContainer.encode(lastModifiedRegion, forKey: .lastModifiedRegion)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let organizationResourceId = self.organizationResourceId {
            try encodeContainer.encode(organizationResourceId, forKey: .organizationResourceId)
        }
        if let securityProfileName = self.securityProfileName {
            try encodeContainer.encode(securityProfileName, forKey: .securityProfileName)
        }
        if let tagRestrictedResources = tagRestrictedResources {
            var tagRestrictedResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagRestrictedResources)
            for tagrestrictedresourcename0 in tagRestrictedResources {
                try tagRestrictedResourcesContainer.encode(tagrestrictedresourcename0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let organizationResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationResourceId)
        organizationResourceId = organizationResourceIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let securityProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityProfileName)
        securityProfileName = securityProfileNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let allowedAccessControlTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .allowedAccessControlTags)
        var allowedAccessControlTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let allowedAccessControlTagsContainer = allowedAccessControlTagsContainer {
            allowedAccessControlTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, securityprofilepolicyvalue0) in allowedAccessControlTagsContainer {
                if let securityprofilepolicyvalue0 = securityprofilepolicyvalue0 {
                    allowedAccessControlTagsDecoded0?[key0] = securityprofilepolicyvalue0
                }
            }
        }
        allowedAccessControlTags = allowedAccessControlTagsDecoded0
        let tagRestrictedResourcesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagRestrictedResources)
        var tagRestrictedResourcesDecoded0:[Swift.String]? = nil
        if let tagRestrictedResourcesContainer = tagRestrictedResourcesContainer {
            tagRestrictedResourcesDecoded0 = [Swift.String]()
            for string0 in tagRestrictedResourcesContainer {
                if let string0 = string0 {
                    tagRestrictedResourcesDecoded0?.append(string0)
                }
            }
        }
        tagRestrictedResources = tagRestrictedResourcesDecoded0
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastModifiedRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedRegion)
        lastModifiedRegion = lastModifiedRegionDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about a security profile.
    public struct SecurityProfile: Swift.Equatable {
        /// The list of tags that a security profile uses to restrict access to resources in Amazon Connect.
        public var allowedAccessControlTags: [Swift.String:Swift.String]?
        /// The Amazon Resource Name (ARN) for the secruity profile.
        public var arn: Swift.String?
        /// The description of the security profile.
        public var description: Swift.String?
        /// The identifier for the security profile.
        public var id: Swift.String?
        /// The Amazon Web Services Region where this resource was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when this resource was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The organization resource identifier for the security profile.
        public var organizationResourceId: Swift.String?
        /// The name for the security profile.
        public var securityProfileName: Swift.String?
        /// The list of resources that a security profile applies tag restrictions to in Amazon Connect.
        public var tagRestrictedResources: [Swift.String]?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public var tags: [Swift.String:Swift.String]?

        public init(
            allowedAccessControlTags: [Swift.String:Swift.String]? = nil,
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            organizationResourceId: Swift.String? = nil,
            securityProfileName: Swift.String? = nil,
            tagRestrictedResources: [Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.allowedAccessControlTags = allowedAccessControlTags
            self.arn = arn
            self.description = description
            self.id = id
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.organizationResourceId = organizationResourceId
            self.securityProfileName = securityProfileName
            self.tagRestrictedResources = tagRestrictedResources
            self.tags = tags
        }
    }

}

extension ConnectClientTypes.SecurityProfileSearchCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case andConditions = "AndConditions"
        case orConditions = "OrConditions"
        case stringCondition = "StringCondition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let andConditions = andConditions {
            var andConditionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .andConditions)
            for securityprofilesearchcriteria0 in andConditions {
                try andConditionsContainer.encode(securityprofilesearchcriteria0)
            }
        }
        if let orConditions = orConditions {
            var orConditionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .orConditions)
            for securityprofilesearchcriteria0 in orConditions {
                try orConditionsContainer.encode(securityprofilesearchcriteria0)
            }
        }
        if let stringCondition = self.stringCondition {
            try encodeContainer.encode(stringCondition, forKey: .stringCondition)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orConditionsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.SecurityProfileSearchCriteria?].self, forKey: .orConditions)
        var orConditionsDecoded0:[ConnectClientTypes.SecurityProfileSearchCriteria]? = nil
        if let orConditionsContainer = orConditionsContainer {
            orConditionsDecoded0 = [ConnectClientTypes.SecurityProfileSearchCriteria]()
            for structure0 in orConditionsContainer {
                if let structure0 = structure0 {
                    orConditionsDecoded0?.append(structure0)
                }
            }
        }
        orConditions = orConditionsDecoded0
        let andConditionsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.SecurityProfileSearchCriteria?].self, forKey: .andConditions)
        var andConditionsDecoded0:[ConnectClientTypes.SecurityProfileSearchCriteria]? = nil
        if let andConditionsContainer = andConditionsContainer {
            andConditionsDecoded0 = [ConnectClientTypes.SecurityProfileSearchCriteria]()
            for structure0 in andConditionsContainer {
                if let structure0 = structure0 {
                    andConditionsDecoded0?.append(structure0)
                }
            }
        }
        andConditions = andConditionsDecoded0
        let stringConditionDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.StringCondition.self, forKey: .stringCondition)
        stringCondition = stringConditionDecoded
    }
}

extension ConnectClientTypes {
    /// The search criteria to be used to return security profiles. The name field support "contains" queries with a minimum of 2 characters and maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results.
    public struct SecurityProfileSearchCriteria: Swift.Equatable {
        /// A list of conditions which would be applied together with an AND condition.
        public var andConditions: [ConnectClientTypes.SecurityProfileSearchCriteria]?
        /// A list of conditions which would be applied together with an OR condition.
        public var orConditions: [ConnectClientTypes.SecurityProfileSearchCriteria]?
        /// A leaf node condition which can be used to specify a string condition.
        public var stringCondition: ConnectClientTypes.StringCondition?

        public init(
            andConditions: [ConnectClientTypes.SecurityProfileSearchCriteria]? = nil,
            orConditions: [ConnectClientTypes.SecurityProfileSearchCriteria]? = nil,
            stringCondition: ConnectClientTypes.StringCondition? = nil
        )
        {
            self.andConditions = andConditions
            self.orConditions = orConditions
            self.stringCondition = stringCondition
        }
    }

}

extension ConnectClientTypes.SecurityProfileSearchSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case id = "Id"
        case organizationResourceId = "OrganizationResourceId"
        case securityProfileName = "SecurityProfileName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let organizationResourceId = self.organizationResourceId {
            try encodeContainer.encode(organizationResourceId, forKey: .organizationResourceId)
        }
        if let securityProfileName = self.securityProfileName {
            try encodeContainer.encode(securityProfileName, forKey: .securityProfileName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let organizationResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationResourceId)
        organizationResourceId = organizationResourceIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let securityProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityProfileName)
        securityProfileName = securityProfileNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ConnectClientTypes {
    /// Information about the returned security profiles.
    public struct SecurityProfileSearchSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the security profile.
        public var arn: Swift.String?
        /// The description of the security profile.
        public var description: Swift.String?
        /// The identifier of the security profile.
        public var id: Swift.String?
        /// The organization resource identifier.
        public var organizationResourceId: Swift.String?
        /// The name of the security profile.
        public var securityProfileName: Swift.String?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            organizationResourceId: Swift.String? = nil,
            securityProfileName: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.id = id
            self.organizationResourceId = organizationResourceId
            self.securityProfileName = securityProfileName
            self.tags = tags
        }
    }

}

extension ConnectClientTypes.SecurityProfileSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case lastModifiedRegion = "LastModifiedRegion"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastModifiedRegion = self.lastModifiedRegion {
            try encodeContainer.encode(lastModifiedRegion, forKey: .lastModifiedRegion)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastModifiedRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedRegion)
        lastModifiedRegion = lastModifiedRegionDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about a security profile.
    public struct SecurityProfileSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the security profile.
        public var arn: Swift.String?
        /// The identifier of the security profile.
        public var id: Swift.String?
        /// The Amazon Web Services Region where this resource was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when this resource was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name of the security profile.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
        }
    }

}

extension ConnectClientTypes.SecurityProfilesSearchFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagFilter = "TagFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagFilter = self.tagFilter {
            try encodeContainer.encode(tagFilter, forKey: .tagFilter)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagFilterDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ControlPlaneTagFilter.self, forKey: .tagFilter)
        tagFilter = tagFilterDecoded
    }
}

extension ConnectClientTypes {
    /// Filters to be applied to search results.
    public struct SecurityProfilesSearchFilter: Swift.Equatable {
        /// An object that can be used to specify Tag conditions inside the SearchFilter. This accepts an OR of AND (List of List) input where:
        ///
        /// * Top level list specifies conditions that need to be applied with OR operator
        ///
        /// * Inner list specifies conditions that need to be applied with AND operator.
        public var tagFilter: ConnectClientTypes.ControlPlaneTagFilter?

        public init(
            tagFilter: ConnectClientTypes.ControlPlaneTagFilter? = nil
        )
        {
            self.tagFilter = tagFilter
        }
    }

}

extension ConnectClientTypes.SegmentAttributeValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case valueString = "ValueString"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let valueString = self.valueString {
            try encodeContainer.encode(valueString, forKey: .valueString)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .valueString)
        valueString = valueStringDecoded
    }
}

extension ConnectClientTypes {
    /// A value for a segment attribute. This is structured as a map where the key is valueString and the value is a string.
    public struct SegmentAttributeValue: Swift.Equatable {
        /// The value of a segment attribute.
        public var valueString: Swift.String?

        public init(
            valueString: Swift.String? = nil
        )
        {
            self.valueString = valueString
        }
    }

}

extension SendChatIntegrationEventInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationId = "DestinationId"
        case event = "Event"
        case newSessionDetails = "NewSessionDetails"
        case sourceId = "SourceId"
        case subtype = "Subtype"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationId = self.destinationId {
            try encodeContainer.encode(destinationId, forKey: .destinationId)
        }
        if let event = self.event {
            try encodeContainer.encode(event, forKey: .event)
        }
        if let newSessionDetails = self.newSessionDetails {
            try encodeContainer.encode(newSessionDetails, forKey: .newSessionDetails)
        }
        if let sourceId = self.sourceId {
            try encodeContainer.encode(sourceId, forKey: .sourceId)
        }
        if let subtype = self.subtype {
            try encodeContainer.encode(subtype, forKey: .subtype)
        }
    }
}

extension SendChatIntegrationEventInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/chat-integration-event"
    }
}

public struct SendChatIntegrationEventInput: Swift.Equatable {
    /// Chat system identifier, used in part to uniquely identify chat. This is associated with the Amazon Connect instance and flow to be used to start chats. For SMS, this is the phone number destination of inbound SMS messages represented by an Amazon Pinpoint phone number ARN.
    /// This member is required.
    public var destinationId: Swift.String?
    /// Chat integration event payload
    /// This member is required.
    public var event: ConnectClientTypes.ChatEvent?
    /// Contact properties to apply when starting a new chat. If the integration event is handled with an existing chat, this is ignored.
    public var newSessionDetails: ConnectClientTypes.NewSessionDetails?
    /// External identifier of chat customer participant, used in part to uniquely identify a chat. For SMS, this is the E164 phone number of the chat customer participant.
    /// This member is required.
    public var sourceId: Swift.String?
    /// Classification of a channel. This is used in part to uniquely identify chat. Valid value: ["connect:sms"]
    public var subtype: Swift.String?

    public init(
        destinationId: Swift.String? = nil,
        event: ConnectClientTypes.ChatEvent? = nil,
        newSessionDetails: ConnectClientTypes.NewSessionDetails? = nil,
        sourceId: Swift.String? = nil,
        subtype: Swift.String? = nil
    )
    {
        self.destinationId = destinationId
        self.event = event
        self.newSessionDetails = newSessionDetails
        self.sourceId = sourceId
        self.subtype = subtype
    }
}

struct SendChatIntegrationEventInputBody: Swift.Equatable {
    let sourceId: Swift.String?
    let destinationId: Swift.String?
    let subtype: Swift.String?
    let event: ConnectClientTypes.ChatEvent?
    let newSessionDetails: ConnectClientTypes.NewSessionDetails?
}

extension SendChatIntegrationEventInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationId = "DestinationId"
        case event = "Event"
        case newSessionDetails = "NewSessionDetails"
        case sourceId = "SourceId"
        case subtype = "Subtype"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let destinationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationId)
        destinationId = destinationIdDecoded
        let subtypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subtype)
        subtype = subtypeDecoded
        let eventDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ChatEvent.self, forKey: .event)
        event = eventDecoded
        let newSessionDetailsDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.NewSessionDetails.self, forKey: .newSessionDetails)
        newSessionDetails = newSessionDetailsDecoded
    }
}

extension SendChatIntegrationEventOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SendChatIntegrationEventOutputBody = try responseDecoder.decode(responseBody: data)
            self.initialContactId = output.initialContactId
            self.newChatCreated = output.newChatCreated
        } else {
            self.initialContactId = nil
            self.newChatCreated = nil
        }
    }
}

public struct SendChatIntegrationEventOutput: Swift.Equatable {
    /// Identifier of chat contact used to handle integration event. This may be null if the integration event is not valid without an already existing chat contact.
    public var initialContactId: Swift.String?
    /// Whether handling the integration event resulted in creating a new chat or acting on existing chat.
    public var newChatCreated: Swift.Bool?

    public init(
        initialContactId: Swift.String? = nil,
        newChatCreated: Swift.Bool? = nil
    )
    {
        self.initialContactId = initialContactId
        self.newChatCreated = newChatCreated
    }
}

struct SendChatIntegrationEventOutputBody: Swift.Equatable {
    let initialContactId: Swift.String?
    let newChatCreated: Swift.Bool?
}

extension SendChatIntegrationEventOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialContactId = "InitialContactId"
        case newChatCreated = "NewChatCreated"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialContactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initialContactId)
        initialContactId = initialContactIdDecoded
        let newChatCreatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .newChatCreated)
        newChatCreated = newChatCreatedDecoded
    }
}

enum SendChatIntegrationEventOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectClientTypes.SendNotificationActionDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case contentType = "ContentType"
        case deliveryMethod = "DeliveryMethod"
        case recipient = "Recipient"
        case subject = "Subject"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType.rawValue, forKey: .contentType)
        }
        if let deliveryMethod = self.deliveryMethod {
            try encodeContainer.encode(deliveryMethod.rawValue, forKey: .deliveryMethod)
        }
        if let recipient = self.recipient {
            try encodeContainer.encode(recipient, forKey: .recipient)
        }
        if let subject = self.subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryMethodDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.NotificationDeliveryType.self, forKey: .deliveryMethod)
        deliveryMethod = deliveryMethodDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subject)
        subject = subjectDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.NotificationContentType.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let recipientDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.NotificationRecipientType.self, forKey: .recipient)
        recipient = recipientDecoded
    }
}

extension ConnectClientTypes {
    /// Information about the send notification action.
    public struct SendNotificationActionDefinition: Swift.Equatable {
        /// Notification content. Supports variable injection. For more information, see [JSONPath reference](https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html) in the Amazon Connect Administrators Guide.
        /// This member is required.
        public var content: Swift.String?
        /// Content type format.
        /// This member is required.
        public var contentType: ConnectClientTypes.NotificationContentType?
        /// Notification delivery method.
        /// This member is required.
        public var deliveryMethod: ConnectClientTypes.NotificationDeliveryType?
        /// Notification recipient.
        /// This member is required.
        public var recipient: ConnectClientTypes.NotificationRecipientType?
        /// The subject of the email if the delivery method is EMAIL. Supports variable injection. For more information, see [JSONPath reference](https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html) in the Amazon Connect Administrators Guide.
        public var subject: Swift.String?

        public init(
            content: Swift.String? = nil,
            contentType: ConnectClientTypes.NotificationContentType? = nil,
            deliveryMethod: ConnectClientTypes.NotificationDeliveryType? = nil,
            recipient: ConnectClientTypes.NotificationRecipientType? = nil,
            subject: Swift.String? = nil
        )
        {
            self.content = content
            self.contentType = contentType
            self.deliveryMethod = deliveryMethod
            self.recipient = recipient
            self.subject = subject
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service quota has been exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectClientTypes.SignInConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributions = "Distributions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let distributions = distributions {
            var distributionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .distributions)
            for signindistribution0 in distributions {
                try distributionsContainer.encode(signindistribution0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.SignInDistribution?].self, forKey: .distributions)
        var distributionsDecoded0:[ConnectClientTypes.SignInDistribution]? = nil
        if let distributionsContainer = distributionsContainer {
            distributionsDecoded0 = [ConnectClientTypes.SignInDistribution]()
            for structure0 in distributionsContainer {
                if let structure0 = structure0 {
                    distributionsDecoded0?.append(structure0)
                }
            }
        }
        distributions = distributionsDecoded0
    }
}

extension ConnectClientTypes {
    /// The distribution that determines which Amazon Web Services Regions should be used to sign in agents in to both the instance and its replica(s).
    public struct SignInConfig: Swift.Equatable {
        /// Information about traffic distributions.
        /// This member is required.
        public var distributions: [ConnectClientTypes.SignInDistribution]?

        public init(
            distributions: [ConnectClientTypes.SignInDistribution]? = nil
        )
        {
            self.distributions = distributions
        }
    }

}

extension ConnectClientTypes.SignInDistribution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case region = "Region"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
    }
}

extension ConnectClientTypes {
    /// The distribution of sign in traffic between the instance and its replica(s).
    public struct SignInDistribution: Swift.Equatable {
        /// Whether sign in distribution is enabled.
        /// This member is required.
        public var enabled: Swift.Bool
        /// The Amazon Web Services Region of the sign in distribution.
        /// This member is required.
        public var region: Swift.String?

        public init(
            enabled: Swift.Bool = false,
            region: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.region = region
        }
    }

}

extension ConnectClientTypes.SingleSelectQuestionRuleCategoryAutomation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case category = "Category"
        case condition = "Condition"
        case optionRefId = "OptionRefId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = self.category {
            try encodeContainer.encode(category, forKey: .category)
        }
        if let condition = self.condition {
            try encodeContainer.encode(condition.rawValue, forKey: .condition)
        }
        if let optionRefId = self.optionRefId {
            try encodeContainer.encode(optionRefId, forKey: .optionRefId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .category)
        category = categoryDecoded
        let conditionDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.SingleSelectQuestionRuleCategoryAutomationCondition.self, forKey: .condition)
        condition = conditionDecoded
        let optionRefIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionRefId)
        optionRefId = optionRefIdDecoded
    }
}

extension ConnectClientTypes {
    /// Information about the automation option based on a rule category for a single select question.
    public struct SingleSelectQuestionRuleCategoryAutomation: Swift.Equatable {
        /// The category name, as defined in Rules.
        /// This member is required.
        public var category: Swift.String?
        /// The condition to apply for the automation option. If the condition is PRESENT, then the option is applied when the contact data includes the category. Similarly, if the condition is NOT_PRESENT, then the option is applied when the contact data does not include the category.
        /// This member is required.
        public var condition: ConnectClientTypes.SingleSelectQuestionRuleCategoryAutomationCondition?
        /// The identifier of the answer option.
        /// This member is required.
        public var optionRefId: Swift.String?

        public init(
            category: Swift.String? = nil,
            condition: ConnectClientTypes.SingleSelectQuestionRuleCategoryAutomationCondition? = nil,
            optionRefId: Swift.String? = nil
        )
        {
            self.category = category
            self.condition = condition
            self.optionRefId = optionRefId
        }
    }

}

extension ConnectClientTypes {
    public enum SingleSelectQuestionRuleCategoryAutomationCondition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case notPresent
        case present
        case sdkUnknown(Swift.String)

        public static var allCases: [SingleSelectQuestionRuleCategoryAutomationCondition] {
            return [
                .notPresent,
                .present,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .notPresent: return "NOT_PRESENT"
            case .present: return "PRESENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SingleSelectQuestionRuleCategoryAutomationCondition(rawValue: rawValue) ?? SingleSelectQuestionRuleCategoryAutomationCondition.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes {
    public enum SourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cases
        case salesforce
        case zendesk
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceType] {
            return [
                .cases,
                .salesforce,
                .zendesk,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cases: return "CASES"
            case .salesforce: return "SALESFORCE"
            case .zendesk: return "ZENDESK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceType(rawValue: rawValue) ?? SourceType.sdkUnknown(rawValue)
        }
    }
}

extension StartChatContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case chatDurationInMinutes = "ChatDurationInMinutes"
        case clientToken = "ClientToken"
        case contactFlowId = "ContactFlowId"
        case initialMessage = "InitialMessage"
        case instanceId = "InstanceId"
        case participantDetails = "ParticipantDetails"
        case persistentChat = "PersistentChat"
        case relatedContactId = "RelatedContactId"
        case segmentAttributes = "SegmentAttributes"
        case supportedMessagingContentTypes = "SupportedMessagingContentTypes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let chatDurationInMinutes = self.chatDurationInMinutes {
            try encodeContainer.encode(chatDurationInMinutes, forKey: .chatDurationInMinutes)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let contactFlowId = self.contactFlowId {
            try encodeContainer.encode(contactFlowId, forKey: .contactFlowId)
        }
        if let initialMessage = self.initialMessage {
            try encodeContainer.encode(initialMessage, forKey: .initialMessage)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let participantDetails = self.participantDetails {
            try encodeContainer.encode(participantDetails, forKey: .participantDetails)
        }
        if let persistentChat = self.persistentChat {
            try encodeContainer.encode(persistentChat, forKey: .persistentChat)
        }
        if let relatedContactId = self.relatedContactId {
            try encodeContainer.encode(relatedContactId, forKey: .relatedContactId)
        }
        if let segmentAttributes = segmentAttributes {
            var segmentAttributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .segmentAttributes)
            for (dictKey0, segmentAttributes0) in segmentAttributes {
                try segmentAttributesContainer.encode(segmentAttributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let supportedMessagingContentTypes = supportedMessagingContentTypes {
            var supportedMessagingContentTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedMessagingContentTypes)
            for supportedmessagingcontenttype0 in supportedMessagingContentTypes {
                try supportedMessagingContentTypesContainer.encode(supportedmessagingcontenttype0)
            }
        }
    }
}

extension StartChatContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/contact/chat"
    }
}

public struct StartChatContactInput: Swift.Equatable {
    /// A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes. They can be accessed in flows just like any other contact attributes. There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys can include only alphanumeric, dash, and underscore characters.
    public var attributes: [Swift.String:Swift.String]?
    /// The total duration of the newly started chat session. If not specified, the chat session duration defaults to 25 hour. The minimum configurable time is 60 minutes. The maximum configurable time is 10,080 minutes (7 days).
    public var chatDurationInMinutes: Swift.Int?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The identifier of the flow for initiating the chat. To see the ContactFlowId in the Amazon Connect admin website, on the navigation menu go to Routing, Contact Flows. Choose the flow. On the flow page, under the name of the flow, choose Show additional flow information. The ContactFlowId is the last part of the ARN, shown here in bold: arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/846ec553-a005-41c0-8341-xxxxxxxxxxxx
    /// This member is required.
    public var contactFlowId: Swift.String?
    /// The initial message to be sent to the newly created chat.
    public var initialMessage: ConnectClientTypes.ChatMessage?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Information identifying the participant.
    /// This member is required.
    public var participantDetails: ConnectClientTypes.ParticipantDetails?
    /// Enable persistent chats. For more information about enabling persistent chat, and for example use cases and how to configure for them, see [Enable persistent chat](https://docs.aws.amazon.com/connect/latest/adminguide/chat-persistence.html).
    public var persistentChat: ConnectClientTypes.PersistentChat?
    /// The unique identifier for an Amazon Connect contact. This identifier is related to the chat starting. You cannot provide data for both RelatedContactId and PersistentChat.
    public var relatedContactId: Swift.String?
    /// A set of system defined key-value pairs stored on individual contact segments using an attribute map. The attributes are standard Amazon Connect attributes. They can be accessed in flows. Attribute keys can include only alphanumeric, -, and _. This field can be used to show channel subtype, such as connect:Guide. The types application/vnd.amazonaws.connect.message.interactive and application/vnd.amazonaws.connect.message.interactive.response must be present in the SupportedMessagingContentTypes field of this API in order to set SegmentAttributes as { "connect:Subtype": {"valueString" : "connect:Guide" }}.
    public var segmentAttributes: [Swift.String:ConnectClientTypes.SegmentAttributeValue]?
    /// The supported chat message content types. Supported types are text/plain, text/markdown, application/json, application/vnd.amazonaws.connect.message.interactive, and application/vnd.amazonaws.connect.message.interactive.response. Content types must always contain text/plain. You can then put any other supported type in the list. For example, all the following lists are valid because they contain text/plain: [text/plain, text/markdown, application/json], [text/markdown, text/plain], [text/plain, application/json, application/vnd.amazonaws.connect.message.interactive.response]. The type application/vnd.amazonaws.connect.message.interactive is required to use the [Show view](https://docs.aws.amazon.com/connect/latest/adminguide/show-view-block.html) flow block.
    public var supportedMessagingContentTypes: [Swift.String]?

    public init(
        attributes: [Swift.String:Swift.String]? = nil,
        chatDurationInMinutes: Swift.Int? = nil,
        clientToken: Swift.String? = nil,
        contactFlowId: Swift.String? = nil,
        initialMessage: ConnectClientTypes.ChatMessage? = nil,
        instanceId: Swift.String? = nil,
        participantDetails: ConnectClientTypes.ParticipantDetails? = nil,
        persistentChat: ConnectClientTypes.PersistentChat? = nil,
        relatedContactId: Swift.String? = nil,
        segmentAttributes: [Swift.String:ConnectClientTypes.SegmentAttributeValue]? = nil,
        supportedMessagingContentTypes: [Swift.String]? = nil
    )
    {
        self.attributes = attributes
        self.chatDurationInMinutes = chatDurationInMinutes
        self.clientToken = clientToken
        self.contactFlowId = contactFlowId
        self.initialMessage = initialMessage
        self.instanceId = instanceId
        self.participantDetails = participantDetails
        self.persistentChat = persistentChat
        self.relatedContactId = relatedContactId
        self.segmentAttributes = segmentAttributes
        self.supportedMessagingContentTypes = supportedMessagingContentTypes
    }
}

struct StartChatContactInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let contactFlowId: Swift.String?
    let attributes: [Swift.String:Swift.String]?
    let participantDetails: ConnectClientTypes.ParticipantDetails?
    let initialMessage: ConnectClientTypes.ChatMessage?
    let clientToken: Swift.String?
    let chatDurationInMinutes: Swift.Int?
    let supportedMessagingContentTypes: [Swift.String]?
    let persistentChat: ConnectClientTypes.PersistentChat?
    let relatedContactId: Swift.String?
    let segmentAttributes: [Swift.String:ConnectClientTypes.SegmentAttributeValue]?
}

extension StartChatContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case chatDurationInMinutes = "ChatDurationInMinutes"
        case clientToken = "ClientToken"
        case contactFlowId = "ContactFlowId"
        case initialMessage = "InitialMessage"
        case instanceId = "InstanceId"
        case participantDetails = "ParticipantDetails"
        case persistentChat = "PersistentChat"
        case relatedContactId = "RelatedContactId"
        case segmentAttributes = "SegmentAttributes"
        case supportedMessagingContentTypes = "SupportedMessagingContentTypes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let contactFlowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactFlowId)
        contactFlowId = contactFlowIdDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let participantDetailsDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ParticipantDetails.self, forKey: .participantDetails)
        participantDetails = participantDetailsDecoded
        let initialMessageDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ChatMessage.self, forKey: .initialMessage)
        initialMessage = initialMessageDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let chatDurationInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .chatDurationInMinutes)
        chatDurationInMinutes = chatDurationInMinutesDecoded
        let supportedMessagingContentTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .supportedMessagingContentTypes)
        var supportedMessagingContentTypesDecoded0:[Swift.String]? = nil
        if let supportedMessagingContentTypesContainer = supportedMessagingContentTypesContainer {
            supportedMessagingContentTypesDecoded0 = [Swift.String]()
            for string0 in supportedMessagingContentTypesContainer {
                if let string0 = string0 {
                    supportedMessagingContentTypesDecoded0?.append(string0)
                }
            }
        }
        supportedMessagingContentTypes = supportedMessagingContentTypesDecoded0
        let persistentChatDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.PersistentChat.self, forKey: .persistentChat)
        persistentChat = persistentChatDecoded
        let relatedContactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relatedContactId)
        relatedContactId = relatedContactIdDecoded
        let segmentAttributesContainer = try containerValues.decodeIfPresent([Swift.String: ConnectClientTypes.SegmentAttributeValue?].self, forKey: .segmentAttributes)
        var segmentAttributesDecoded0: [Swift.String:ConnectClientTypes.SegmentAttributeValue]? = nil
        if let segmentAttributesContainer = segmentAttributesContainer {
            segmentAttributesDecoded0 = [Swift.String:ConnectClientTypes.SegmentAttributeValue]()
            for (key0, segmentattributevalue0) in segmentAttributesContainer {
                if let segmentattributevalue0 = segmentattributevalue0 {
                    segmentAttributesDecoded0?[key0] = segmentattributevalue0
                }
            }
        }
        segmentAttributes = segmentAttributesDecoded0
    }
}

extension StartChatContactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartChatContactOutputBody = try responseDecoder.decode(responseBody: data)
            self.contactId = output.contactId
            self.continuedFromContactId = output.continuedFromContactId
            self.participantId = output.participantId
            self.participantToken = output.participantToken
        } else {
            self.contactId = nil
            self.continuedFromContactId = nil
            self.participantId = nil
            self.participantToken = nil
        }
    }
}

public struct StartChatContactOutput: Swift.Equatable {
    /// The identifier of this contact within the Amazon Connect instance.
    public var contactId: Swift.String?
    /// The contactId from which a persistent chat session is started. This field is populated only for persistent chats.
    public var continuedFromContactId: Swift.String?
    /// The identifier for a chat participant. The participantId for a chat participant is the same throughout the chat lifecycle.
    public var participantId: Swift.String?
    /// The token used by the chat participant to call [CreateParticipantConnection](https://docs.aws.amazon.com/connect-participant/latest/APIReference/API_CreateParticipantConnection.html). The participant token is valid for the lifetime of a chat participant.
    public var participantToken: Swift.String?

    public init(
        contactId: Swift.String? = nil,
        continuedFromContactId: Swift.String? = nil,
        participantId: Swift.String? = nil,
        participantToken: Swift.String? = nil
    )
    {
        self.contactId = contactId
        self.continuedFromContactId = continuedFromContactId
        self.participantId = participantId
        self.participantToken = participantToken
    }
}

struct StartChatContactOutputBody: Swift.Equatable {
    let contactId: Swift.String?
    let participantId: Swift.String?
    let participantToken: Swift.String?
    let continuedFromContactId: Swift.String?
}

extension StartChatContactOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case continuedFromContactId = "ContinuedFromContactId"
        case participantId = "ParticipantId"
        case participantToken = "ParticipantToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let participantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .participantId)
        participantId = participantIdDecoded
        let participantTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .participantToken)
        participantToken = participantTokenDecoded
        let continuedFromContactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .continuedFromContactId)
        continuedFromContactId = continuedFromContactIdDecoded
    }
}

enum StartChatContactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartContactEvaluationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case contactId = "ContactId"
        case evaluationFormId = "EvaluationFormId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let contactId = self.contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let evaluationFormId = self.evaluationFormId {
            try encodeContainer.encode(evaluationFormId, forKey: .evaluationFormId)
        }
    }
}

extension StartContactEvaluationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/contact-evaluations/\(instanceId.urlPercentEncoding())"
    }
}

public struct StartContactEvaluationInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The identifier of the contact in this instance of Amazon Connect.
    /// This member is required.
    public var contactId: Swift.String?
    /// The unique identifier for the evaluation form.
    /// This member is required.
    public var evaluationFormId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        contactId: Swift.String? = nil,
        evaluationFormId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.contactId = contactId
        self.evaluationFormId = evaluationFormId
        self.instanceId = instanceId
    }
}

struct StartContactEvaluationInputBody: Swift.Equatable {
    let contactId: Swift.String?
    let evaluationFormId: Swift.String?
    let clientToken: Swift.String?
}

extension StartContactEvaluationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case contactId = "ContactId"
        case evaluationFormId = "EvaluationFormId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let evaluationFormIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationFormId)
        evaluationFormId = evaluationFormIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension StartContactEvaluationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartContactEvaluationOutputBody = try responseDecoder.decode(responseBody: data)
            self.evaluationArn = output.evaluationArn
            self.evaluationId = output.evaluationId
        } else {
            self.evaluationArn = nil
            self.evaluationId = nil
        }
    }
}

public struct StartContactEvaluationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the contact evaluation resource.
    /// This member is required.
    public var evaluationArn: Swift.String?
    /// A unique identifier for the contact evaluation.
    /// This member is required.
    public var evaluationId: Swift.String?

    public init(
        evaluationArn: Swift.String? = nil,
        evaluationId: Swift.String? = nil
    )
    {
        self.evaluationArn = evaluationArn
        self.evaluationId = evaluationId
    }
}

struct StartContactEvaluationOutputBody: Swift.Equatable {
    let evaluationId: Swift.String?
    let evaluationArn: Swift.String?
}

extension StartContactEvaluationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationArn = "EvaluationArn"
        case evaluationId = "EvaluationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationId)
        evaluationId = evaluationIdDecoded
        let evaluationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationArn)
        evaluationArn = evaluationArnDecoded
    }
}

enum StartContactEvaluationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartContactRecordingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case initialContactId = "InitialContactId"
        case instanceId = "InstanceId"
        case voiceRecordingConfiguration = "VoiceRecordingConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = self.contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let initialContactId = self.initialContactId {
            try encodeContainer.encode(initialContactId, forKey: .initialContactId)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let voiceRecordingConfiguration = self.voiceRecordingConfiguration {
            try encodeContainer.encode(voiceRecordingConfiguration, forKey: .voiceRecordingConfiguration)
        }
    }
}

extension StartContactRecordingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/contact/start-recording"
    }
}

public struct StartContactRecordingInput: Swift.Equatable {
    /// The identifier of the contact.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.
    /// This member is required.
    public var initialContactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The person being recorded.
    /// This member is required.
    public var voiceRecordingConfiguration: ConnectClientTypes.VoiceRecordingConfiguration?

    public init(
        contactId: Swift.String? = nil,
        initialContactId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        voiceRecordingConfiguration: ConnectClientTypes.VoiceRecordingConfiguration? = nil
    )
    {
        self.contactId = contactId
        self.initialContactId = initialContactId
        self.instanceId = instanceId
        self.voiceRecordingConfiguration = voiceRecordingConfiguration
    }
}

struct StartContactRecordingInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let contactId: Swift.String?
    let initialContactId: Swift.String?
    let voiceRecordingConfiguration: ConnectClientTypes.VoiceRecordingConfiguration?
}

extension StartContactRecordingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case initialContactId = "InitialContactId"
        case instanceId = "InstanceId"
        case voiceRecordingConfiguration = "VoiceRecordingConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let initialContactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initialContactId)
        initialContactId = initialContactIdDecoded
        let voiceRecordingConfigurationDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.VoiceRecordingConfiguration.self, forKey: .voiceRecordingConfiguration)
        voiceRecordingConfiguration = voiceRecordingConfigurationDecoded
    }
}

extension StartContactRecordingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StartContactRecordingOutput: Swift.Equatable {

    public init() { }
}

enum StartContactRecordingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartContactStreamingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chatStreamingConfiguration = "ChatStreamingConfiguration"
        case clientToken = "ClientToken"
        case contactId = "ContactId"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chatStreamingConfiguration = self.chatStreamingConfiguration {
            try encodeContainer.encode(chatStreamingConfiguration, forKey: .chatStreamingConfiguration)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let contactId = self.contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

extension StartContactStreamingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/contact/start-streaming"
    }
}

public struct StartContactStreamingInput: Swift.Equatable {
    /// The streaming configuration, such as the Amazon SNS streaming endpoint.
    /// This member is required.
    public var chatStreamingConfiguration: ConnectClientTypes.ChatStreamingConfiguration?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    /// This member is required.
    public var clientToken: Swift.String?
    /// The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        chatStreamingConfiguration: ConnectClientTypes.ChatStreamingConfiguration? = nil,
        clientToken: Swift.String? = nil,
        contactId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.chatStreamingConfiguration = chatStreamingConfiguration
        self.clientToken = clientToken
        self.contactId = contactId
        self.instanceId = instanceId
    }
}

struct StartContactStreamingInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let contactId: Swift.String?
    let chatStreamingConfiguration: ConnectClientTypes.ChatStreamingConfiguration?
    let clientToken: Swift.String?
}

extension StartContactStreamingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chatStreamingConfiguration = "ChatStreamingConfiguration"
        case clientToken = "ClientToken"
        case contactId = "ContactId"
        case instanceId = "InstanceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let chatStreamingConfigurationDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ChatStreamingConfiguration.self, forKey: .chatStreamingConfiguration)
        chatStreamingConfiguration = chatStreamingConfigurationDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension StartContactStreamingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartContactStreamingOutputBody = try responseDecoder.decode(responseBody: data)
            self.streamingId = output.streamingId
        } else {
            self.streamingId = nil
        }
    }
}

public struct StartContactStreamingOutput: Swift.Equatable {
    /// The identifier of the streaming configuration enabled.
    /// This member is required.
    public var streamingId: Swift.String?

    public init(
        streamingId: Swift.String? = nil
    )
    {
        self.streamingId = streamingId
    }
}

struct StartContactStreamingOutputBody: Swift.Equatable {
    let streamingId: Swift.String?
}

extension StartContactStreamingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingId = "StreamingId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamingId)
        streamingId = streamingIdDecoded
    }
}

enum StartContactStreamingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartOutboundVoiceContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case answerMachineDetectionConfig = "AnswerMachineDetectionConfig"
        case attributes = "Attributes"
        case campaignId = "CampaignId"
        case clientToken = "ClientToken"
        case contactFlowId = "ContactFlowId"
        case description = "Description"
        case destinationPhoneNumber = "DestinationPhoneNumber"
        case instanceId = "InstanceId"
        case name = "Name"
        case queueId = "QueueId"
        case references = "References"
        case relatedContactId = "RelatedContactId"
        case sourcePhoneNumber = "SourcePhoneNumber"
        case trafficType = "TrafficType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let answerMachineDetectionConfig = self.answerMachineDetectionConfig {
            try encodeContainer.encode(answerMachineDetectionConfig, forKey: .answerMachineDetectionConfig)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let campaignId = self.campaignId {
            try encodeContainer.encode(campaignId, forKey: .campaignId)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let contactFlowId = self.contactFlowId {
            try encodeContainer.encode(contactFlowId, forKey: .contactFlowId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationPhoneNumber = self.destinationPhoneNumber {
            try encodeContainer.encode(destinationPhoneNumber, forKey: .destinationPhoneNumber)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let queueId = self.queueId {
            try encodeContainer.encode(queueId, forKey: .queueId)
        }
        if let references = references {
            var referencesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .references)
            for (dictKey0, contactReferences0) in references {
                try referencesContainer.encode(contactReferences0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let relatedContactId = self.relatedContactId {
            try encodeContainer.encode(relatedContactId, forKey: .relatedContactId)
        }
        if let sourcePhoneNumber = self.sourcePhoneNumber {
            try encodeContainer.encode(sourcePhoneNumber, forKey: .sourcePhoneNumber)
        }
        if let trafficType = self.trafficType {
            try encodeContainer.encode(trafficType.rawValue, forKey: .trafficType)
        }
    }
}

extension StartOutboundVoiceContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/contact/outbound-voice"
    }
}

public struct StartOutboundVoiceContactInput: Swift.Equatable {
    /// Configuration of the answering machine detection for this outbound call.
    public var answerMachineDetectionConfig: ConnectClientTypes.AnswerMachineDetectionConfig?
    /// A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes, and can be accessed in flows just like any other contact attributes. There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys can include only alphanumeric, dash, and underscore characters.
    public var attributes: [Swift.String:Swift.String]?
    /// The campaign identifier of the outbound communication.
    public var campaignId: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/). The token is valid for 7 days after creation. If a contact is already started, the contact ID is returned.
    public var clientToken: Swift.String?
    /// The identifier of the flow for the outbound call. To see the ContactFlowId in the Amazon Connect admin website, on the navigation menu go to Routing, Contact Flows. Choose the flow. On the flow page, under the name of the flow, choose Show additional flow information. The ContactFlowId is the last part of the ARN, shown here in bold: arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/846ec553-a005-41c0-8341-xxxxxxxxxxxx
    /// This member is required.
    public var contactFlowId: Swift.String?
    /// A description of the voice contact that is shown to an agent in the Contact Control Panel (CCP).
    public var description: Swift.String?
    /// The phone number of the customer, in E.164 format.
    /// This member is required.
    public var destinationPhoneNumber: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of a voice contact that is shown to an agent in the Contact Control Panel (CCP).
    public var name: Swift.String?
    /// The queue for the call. If you specify a queue, the phone displayed for caller ID is the phone number specified in the queue. If you do not specify a queue, the queue defined in the flow is used. If you do not specify a queue, you must specify a source phone number.
    public var queueId: Swift.String?
    /// A formatted URL that is shown to an agent in the Contact Control Panel (CCP). Contacts can have the following reference types at the time of creation: URL | NUMBER | STRING | DATE | EMAIL. ATTACHMENT is not a supported reference type during voice contact creation.
    public var references: [Swift.String:ConnectClientTypes.Reference]?
    /// The contactId that is related to this contact. Linking voice, task, or chat by using RelatedContactID copies over contact attributes from the related contact to the new contact. All updates to user-defined attributes in the new contact are limited to the individual contact ID. There are no limits to the number of contacts that can be linked by using RelatedContactId.
    public var relatedContactId: Swift.String?
    /// The phone number associated with the Amazon Connect instance, in E.164 format. If you do not specify a source phone number, you must specify a queue.
    public var sourcePhoneNumber: Swift.String?
    /// Denotes the class of traffic. Calls with different traffic types are handled differently by Amazon Connect. The default value is GENERAL. Use CAMPAIGN if EnableAnswerMachineDetection is set to true. For all other cases, use GENERAL.
    public var trafficType: ConnectClientTypes.TrafficType?

    public init(
        answerMachineDetectionConfig: ConnectClientTypes.AnswerMachineDetectionConfig? = nil,
        attributes: [Swift.String:Swift.String]? = nil,
        campaignId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        contactFlowId: Swift.String? = nil,
        description: Swift.String? = nil,
        destinationPhoneNumber: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        queueId: Swift.String? = nil,
        references: [Swift.String:ConnectClientTypes.Reference]? = nil,
        relatedContactId: Swift.String? = nil,
        sourcePhoneNumber: Swift.String? = nil,
        trafficType: ConnectClientTypes.TrafficType? = nil
    )
    {
        self.answerMachineDetectionConfig = answerMachineDetectionConfig
        self.attributes = attributes
        self.campaignId = campaignId
        self.clientToken = clientToken
        self.contactFlowId = contactFlowId
        self.description = description
        self.destinationPhoneNumber = destinationPhoneNumber
        self.instanceId = instanceId
        self.name = name
        self.queueId = queueId
        self.references = references
        self.relatedContactId = relatedContactId
        self.sourcePhoneNumber = sourcePhoneNumber
        self.trafficType = trafficType
    }
}

struct StartOutboundVoiceContactInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let references: [Swift.String:ConnectClientTypes.Reference]?
    let relatedContactId: Swift.String?
    let destinationPhoneNumber: Swift.String?
    let contactFlowId: Swift.String?
    let instanceId: Swift.String?
    let clientToken: Swift.String?
    let sourcePhoneNumber: Swift.String?
    let queueId: Swift.String?
    let attributes: [Swift.String:Swift.String]?
    let answerMachineDetectionConfig: ConnectClientTypes.AnswerMachineDetectionConfig?
    let campaignId: Swift.String?
    let trafficType: ConnectClientTypes.TrafficType?
}

extension StartOutboundVoiceContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case answerMachineDetectionConfig = "AnswerMachineDetectionConfig"
        case attributes = "Attributes"
        case campaignId = "CampaignId"
        case clientToken = "ClientToken"
        case contactFlowId = "ContactFlowId"
        case description = "Description"
        case destinationPhoneNumber = "DestinationPhoneNumber"
        case instanceId = "InstanceId"
        case name = "Name"
        case queueId = "QueueId"
        case references = "References"
        case relatedContactId = "RelatedContactId"
        case sourcePhoneNumber = "SourcePhoneNumber"
        case trafficType = "TrafficType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let referencesContainer = try containerValues.decodeIfPresent([Swift.String: ConnectClientTypes.Reference?].self, forKey: .references)
        var referencesDecoded0: [Swift.String:ConnectClientTypes.Reference]? = nil
        if let referencesContainer = referencesContainer {
            referencesDecoded0 = [Swift.String:ConnectClientTypes.Reference]()
            for (key0, reference0) in referencesContainer {
                if let reference0 = reference0 {
                    referencesDecoded0?[key0] = reference0
                }
            }
        }
        references = referencesDecoded0
        let relatedContactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relatedContactId)
        relatedContactId = relatedContactIdDecoded
        let destinationPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationPhoneNumber)
        destinationPhoneNumber = destinationPhoneNumberDecoded
        let contactFlowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactFlowId)
        contactFlowId = contactFlowIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let sourcePhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourcePhoneNumber)
        sourcePhoneNumber = sourcePhoneNumberDecoded
        let queueIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueId)
        queueId = queueIdDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let answerMachineDetectionConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.AnswerMachineDetectionConfig.self, forKey: .answerMachineDetectionConfig)
        answerMachineDetectionConfig = answerMachineDetectionConfigDecoded
        let campaignIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .campaignId)
        campaignId = campaignIdDecoded
        let trafficTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.TrafficType.self, forKey: .trafficType)
        trafficType = trafficTypeDecoded
    }
}

extension StartOutboundVoiceContactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartOutboundVoiceContactOutputBody = try responseDecoder.decode(responseBody: data)
            self.contactId = output.contactId
        } else {
            self.contactId = nil
        }
    }
}

public struct StartOutboundVoiceContactOutput: Swift.Equatable {
    /// The identifier of this contact within the Amazon Connect instance.
    public var contactId: Swift.String?

    public init(
        contactId: Swift.String? = nil
    )
    {
        self.contactId = contactId
    }
}

struct StartOutboundVoiceContactOutputBody: Swift.Equatable {
    let contactId: Swift.String?
}

extension StartOutboundVoiceContactOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
    }
}

enum StartOutboundVoiceContactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DestinationNotAllowedException": return try await DestinationNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OutboundContactNotPermittedException": return try await OutboundContactNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartTaskContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case clientToken = "ClientToken"
        case contactFlowId = "ContactFlowId"
        case description = "Description"
        case instanceId = "InstanceId"
        case name = "Name"
        case previousContactId = "PreviousContactId"
        case quickConnectId = "QuickConnectId"
        case references = "References"
        case relatedContactId = "RelatedContactId"
        case scheduledTime = "ScheduledTime"
        case taskTemplateId = "TaskTemplateId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let contactFlowId = self.contactFlowId {
            try encodeContainer.encode(contactFlowId, forKey: .contactFlowId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let previousContactId = self.previousContactId {
            try encodeContainer.encode(previousContactId, forKey: .previousContactId)
        }
        if let quickConnectId = self.quickConnectId {
            try encodeContainer.encode(quickConnectId, forKey: .quickConnectId)
        }
        if let references = references {
            var referencesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .references)
            for (dictKey0, contactReferences0) in references {
                try referencesContainer.encode(contactReferences0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let relatedContactId = self.relatedContactId {
            try encodeContainer.encode(relatedContactId, forKey: .relatedContactId)
        }
        if let scheduledTime = self.scheduledTime {
            try encodeContainer.encodeTimestamp(scheduledTime, format: .epochSeconds, forKey: .scheduledTime)
        }
        if let taskTemplateId = self.taskTemplateId {
            try encodeContainer.encode(taskTemplateId, forKey: .taskTemplateId)
        }
    }
}

extension StartTaskContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/contact/task"
    }
}

public struct StartTaskContactInput: Swift.Equatable {
    /// A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes, and can be accessed in flows just like any other contact attributes. There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys can include only alphanumeric, dash, and underscore characters.
    public var attributes: [Swift.String:Swift.String]?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The identifier of the flow for initiating the tasks. To see the ContactFlowId in the Amazon Connect admin website, on the navigation menu go to Routing, Contact Flows. Choose the flow. On the flow page, under the name of the flow, choose Show additional flow information. The ContactFlowId is the last part of the ARN, shown here in bold: arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/846ec553-a005-41c0-8341-xxxxxxxxxxxx
    public var contactFlowId: Swift.String?
    /// A description of the task that is shown to an agent in the Contact Control Panel (CCP).
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of a task that is shown to an agent in the Contact Control Panel (CCP).
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the previous chat, voice, or task contact. Any updates to user-defined attributes to task contacts linked using the same PreviousContactID will affect every contact in the chain. There can be a maximum of 12 linked task contacts in a chain.
    public var previousContactId: Swift.String?
    /// The identifier for the quick connect. Tasks that are created by using QuickConnectId will use the flow that is defined on agent or queue quick connect. For more information about quick connects, see [Create quick connects](https://docs.aws.amazon.com/connect/latest/adminguide/quick-connects.html).
    public var quickConnectId: Swift.String?
    /// A formatted URL that is shown to an agent in the Contact Control Panel (CCP). Tasks can have the following reference types at the time of creation: URL | NUMBER | STRING | DATE | EMAIL. ATTACHMENT is not a supported reference type during task creation.
    public var references: [Swift.String:ConnectClientTypes.Reference]?
    /// The contactId that is [related](https://docs.aws.amazon.com/connect/latest/adminguide/tasks.html#linked-tasks) to this contact. Linking tasks together by using RelatedContactID copies over contact attributes from the related task contact to the new task contact. All updates to user-defined attributes in the new task contact are limited to the individual contact ID, unlike what happens when tasks are linked by using PreviousContactID. There are no limits to the number of contacts that can be linked by using RelatedContactId.
    public var relatedContactId: Swift.String?
    /// The timestamp, in Unix Epoch seconds format, at which to start running the inbound flow. The scheduled time cannot be in the past. It must be within up to 6 days in future.
    public var scheduledTime: ClientRuntime.Date?
    /// A unique identifier for the task template. For more information about task templates, see [Create task templates](https://docs.aws.amazon.com/connect/latest/adminguide/task-templates.html) in the Amazon Connect Administrator Guide.
    public var taskTemplateId: Swift.String?

    public init(
        attributes: [Swift.String:Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        contactFlowId: Swift.String? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        previousContactId: Swift.String? = nil,
        quickConnectId: Swift.String? = nil,
        references: [Swift.String:ConnectClientTypes.Reference]? = nil,
        relatedContactId: Swift.String? = nil,
        scheduledTime: ClientRuntime.Date? = nil,
        taskTemplateId: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.clientToken = clientToken
        self.contactFlowId = contactFlowId
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.previousContactId = previousContactId
        self.quickConnectId = quickConnectId
        self.references = references
        self.relatedContactId = relatedContactId
        self.scheduledTime = scheduledTime
        self.taskTemplateId = taskTemplateId
    }
}

struct StartTaskContactInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let previousContactId: Swift.String?
    let contactFlowId: Swift.String?
    let attributes: [Swift.String:Swift.String]?
    let name: Swift.String?
    let references: [Swift.String:ConnectClientTypes.Reference]?
    let description: Swift.String?
    let clientToken: Swift.String?
    let scheduledTime: ClientRuntime.Date?
    let taskTemplateId: Swift.String?
    let quickConnectId: Swift.String?
    let relatedContactId: Swift.String?
}

extension StartTaskContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case clientToken = "ClientToken"
        case contactFlowId = "ContactFlowId"
        case description = "Description"
        case instanceId = "InstanceId"
        case name = "Name"
        case previousContactId = "PreviousContactId"
        case quickConnectId = "QuickConnectId"
        case references = "References"
        case relatedContactId = "RelatedContactId"
        case scheduledTime = "ScheduledTime"
        case taskTemplateId = "TaskTemplateId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let previousContactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .previousContactId)
        previousContactId = previousContactIdDecoded
        let contactFlowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactFlowId)
        contactFlowId = contactFlowIdDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let referencesContainer = try containerValues.decodeIfPresent([Swift.String: ConnectClientTypes.Reference?].self, forKey: .references)
        var referencesDecoded0: [Swift.String:ConnectClientTypes.Reference]? = nil
        if let referencesContainer = referencesContainer {
            referencesDecoded0 = [Swift.String:ConnectClientTypes.Reference]()
            for (key0, reference0) in referencesContainer {
                if let reference0 = reference0 {
                    referencesDecoded0?[key0] = reference0
                }
            }
        }
        references = referencesDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let scheduledTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .scheduledTime)
        scheduledTime = scheduledTimeDecoded
        let taskTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskTemplateId)
        taskTemplateId = taskTemplateIdDecoded
        let quickConnectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quickConnectId)
        quickConnectId = quickConnectIdDecoded
        let relatedContactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relatedContactId)
        relatedContactId = relatedContactIdDecoded
    }
}

extension StartTaskContactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartTaskContactOutputBody = try responseDecoder.decode(responseBody: data)
            self.contactId = output.contactId
        } else {
            self.contactId = nil
        }
    }
}

public struct StartTaskContactOutput: Swift.Equatable {
    /// The identifier of this contact within the Amazon Connect instance.
    public var contactId: Swift.String?

    public init(
        contactId: Swift.String? = nil
    )
    {
        self.contactId = contactId
    }
}

struct StartTaskContactOutputBody: Swift.Equatable {
    let contactId: Swift.String?
}

extension StartTaskContactOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
    }
}

enum StartTaskContactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartWebRTCContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedCapabilities = "AllowedCapabilities"
        case attributes = "Attributes"
        case clientToken = "ClientToken"
        case contactFlowId = "ContactFlowId"
        case description = "Description"
        case instanceId = "InstanceId"
        case participantDetails = "ParticipantDetails"
        case references = "References"
        case relatedContactId = "RelatedContactId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedCapabilities = self.allowedCapabilities {
            try encodeContainer.encode(allowedCapabilities, forKey: .allowedCapabilities)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let contactFlowId = self.contactFlowId {
            try encodeContainer.encode(contactFlowId, forKey: .contactFlowId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let participantDetails = self.participantDetails {
            try encodeContainer.encode(participantDetails, forKey: .participantDetails)
        }
        if let references = references {
            var referencesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .references)
            for (dictKey0, contactReferences0) in references {
                try referencesContainer.encode(contactReferences0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let relatedContactId = self.relatedContactId {
            try encodeContainer.encode(relatedContactId, forKey: .relatedContactId)
        }
    }
}

extension StartWebRTCContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/contact/webrtc"
    }
}

public struct StartWebRTCContactInput: Swift.Equatable {
    /// Information about the video sharing capabilities of the participants (customer, agent).
    public var allowedCapabilities: ConnectClientTypes.AllowedCapabilities?
    /// A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes, and can be accessed in flows just like any other contact attributes. There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys can include only alphanumeric, -, and _ characters.
    public var attributes: [Swift.String:Swift.String]?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/). The token is valid for 7 days after creation. If a contact is already started, the contact ID is returned.
    public var clientToken: Swift.String?
    /// The identifier of the flow for the call. To see the ContactFlowId in the Amazon Connect admin website, on the navigation menu go to Routing, Contact Flows. Choose the flow. On the flow page, under the name of the flow, choose Show additional flow information. The ContactFlowId is the last part of the ARN, shown here in bold: arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/846ec553-a005-41c0-8341-xxxxxxxxxxxx
    /// This member is required.
    public var contactFlowId: Swift.String?
    /// A description of the task that is shown to an agent in the Contact Control Panel (CCP).
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The customer's details.
    /// This member is required.
    public var participantDetails: ConnectClientTypes.ParticipantDetails?
    /// A formatted URL that is shown to an agent in the Contact Control Panel (CCP). Tasks can have the following reference types at the time of creation: URL | NUMBER | STRING | DATE | EMAIL. ATTACHMENT is not a supported reference type during task creation.
    public var references: [Swift.String:ConnectClientTypes.Reference]?
    /// The unique identifier for an Amazon Connect contact. This identifier is related to the contact starting.
    public var relatedContactId: Swift.String?

    public init(
        allowedCapabilities: ConnectClientTypes.AllowedCapabilities? = nil,
        attributes: [Swift.String:Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        contactFlowId: Swift.String? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        participantDetails: ConnectClientTypes.ParticipantDetails? = nil,
        references: [Swift.String:ConnectClientTypes.Reference]? = nil,
        relatedContactId: Swift.String? = nil
    )
    {
        self.allowedCapabilities = allowedCapabilities
        self.attributes = attributes
        self.clientToken = clientToken
        self.contactFlowId = contactFlowId
        self.description = description
        self.instanceId = instanceId
        self.participantDetails = participantDetails
        self.references = references
        self.relatedContactId = relatedContactId
    }
}

struct StartWebRTCContactInputBody: Swift.Equatable {
    let attributes: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
    let contactFlowId: Swift.String?
    let instanceId: Swift.String?
    let allowedCapabilities: ConnectClientTypes.AllowedCapabilities?
    let participantDetails: ConnectClientTypes.ParticipantDetails?
    let relatedContactId: Swift.String?
    let references: [Swift.String:ConnectClientTypes.Reference]?
    let description: Swift.String?
}

extension StartWebRTCContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedCapabilities = "AllowedCapabilities"
        case attributes = "Attributes"
        case clientToken = "ClientToken"
        case contactFlowId = "ContactFlowId"
        case description = "Description"
        case instanceId = "InstanceId"
        case participantDetails = "ParticipantDetails"
        case references = "References"
        case relatedContactId = "RelatedContactId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let contactFlowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactFlowId)
        contactFlowId = contactFlowIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let allowedCapabilitiesDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.AllowedCapabilities.self, forKey: .allowedCapabilities)
        allowedCapabilities = allowedCapabilitiesDecoded
        let participantDetailsDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ParticipantDetails.self, forKey: .participantDetails)
        participantDetails = participantDetailsDecoded
        let relatedContactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relatedContactId)
        relatedContactId = relatedContactIdDecoded
        let referencesContainer = try containerValues.decodeIfPresent([Swift.String: ConnectClientTypes.Reference?].self, forKey: .references)
        var referencesDecoded0: [Swift.String:ConnectClientTypes.Reference]? = nil
        if let referencesContainer = referencesContainer {
            referencesDecoded0 = [Swift.String:ConnectClientTypes.Reference]()
            for (key0, reference0) in referencesContainer {
                if let reference0 = reference0 {
                    referencesDecoded0?[key0] = reference0
                }
            }
        }
        references = referencesDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension StartWebRTCContactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartWebRTCContactOutputBody = try responseDecoder.decode(responseBody: data)
            self.connectionData = output.connectionData
            self.contactId = output.contactId
            self.participantId = output.participantId
            self.participantToken = output.participantToken
        } else {
            self.connectionData = nil
            self.contactId = nil
            self.participantId = nil
            self.participantToken = nil
        }
    }
}

public struct StartWebRTCContactOutput: Swift.Equatable {
    /// Information required for the client application (mobile application or website) to connect to the call.
    public var connectionData: ConnectClientTypes.ConnectionData?
    /// The identifier of the contact in this instance of Amazon Connect.
    public var contactId: Swift.String?
    /// The identifier for a contact participant. The ParticipantId for a contact participant is the same throughout the contact lifecycle.
    public var participantId: Swift.String?
    /// The token used by the contact participant to call the [CreateParticipantConnection](https://docs.aws.amazon.com/connect-participant/latest/APIReference/API_CreateParticipantConnection.html) API. The participant token is valid for the lifetime of a contact participant.
    public var participantToken: Swift.String?

    public init(
        connectionData: ConnectClientTypes.ConnectionData? = nil,
        contactId: Swift.String? = nil,
        participantId: Swift.String? = nil,
        participantToken: Swift.String? = nil
    )
    {
        self.connectionData = connectionData
        self.contactId = contactId
        self.participantId = participantId
        self.participantToken = participantToken
    }
}

struct StartWebRTCContactOutputBody: Swift.Equatable {
    let connectionData: ConnectClientTypes.ConnectionData?
    let contactId: Swift.String?
    let participantId: Swift.String?
    let participantToken: Swift.String?
}

extension StartWebRTCContactOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionData = "ConnectionData"
        case contactId = "ContactId"
        case participantId = "ParticipantId"
        case participantToken = "ParticipantToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionDataDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ConnectionData.self, forKey: .connectionData)
        connectionData = connectionDataDecoded
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let participantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .participantId)
        participantId = participantIdDecoded
        let participantTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .participantToken)
        participantToken = participantTokenDecoded
    }
}

enum StartWebRTCContactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectClientTypes {
    public enum Statistic: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case avg
        case max
        case sum
        case sdkUnknown(Swift.String)

        public static var allCases: [Statistic] {
            return [
                .avg,
                .max,
                .sum,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .avg: return "AVG"
            case .max: return "MAX"
            case .sum: return "SUM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Statistic(rawValue: rawValue) ?? Statistic.sdkUnknown(rawValue)
        }
    }
}

extension StopContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case disconnectReason = "DisconnectReason"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = self.contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let disconnectReason = self.disconnectReason {
            try encodeContainer.encode(disconnectReason, forKey: .disconnectReason)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

extension StopContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/contact/stop"
    }
}

public struct StopContactInput: Swift.Equatable {
    /// The ID of the contact.
    /// This member is required.
    public var contactId: Swift.String?
    /// The reason a contact can be disconnected. Only Amazon Connect outbound campaigns can provide this field.
    public var disconnectReason: ConnectClientTypes.DisconnectReason?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        contactId: Swift.String? = nil,
        disconnectReason: ConnectClientTypes.DisconnectReason? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.contactId = contactId
        self.disconnectReason = disconnectReason
        self.instanceId = instanceId
    }
}

struct StopContactInputBody: Swift.Equatable {
    let contactId: Swift.String?
    let instanceId: Swift.String?
    let disconnectReason: ConnectClientTypes.DisconnectReason?
}

extension StopContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case disconnectReason = "DisconnectReason"
        case instanceId = "InstanceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let disconnectReasonDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.DisconnectReason.self, forKey: .disconnectReason)
        disconnectReason = disconnectReasonDecoded
    }
}

extension StopContactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopContactOutput: Swift.Equatable {

    public init() { }
}

enum StopContactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ContactNotFoundException": return try await ContactNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopContactRecordingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case initialContactId = "InitialContactId"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = self.contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let initialContactId = self.initialContactId {
            try encodeContainer.encode(initialContactId, forKey: .initialContactId)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

extension StopContactRecordingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/contact/stop-recording"
    }
}

public struct StopContactRecordingInput: Swift.Equatable {
    /// The identifier of the contact.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.
    /// This member is required.
    public var initialContactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        contactId: Swift.String? = nil,
        initialContactId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.contactId = contactId
        self.initialContactId = initialContactId
        self.instanceId = instanceId
    }
}

struct StopContactRecordingInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let contactId: Swift.String?
    let initialContactId: Swift.String?
}

extension StopContactRecordingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case initialContactId = "InitialContactId"
        case instanceId = "InstanceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let initialContactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initialContactId)
        initialContactId = initialContactIdDecoded
    }
}

extension StopContactRecordingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopContactRecordingOutput: Swift.Equatable {

    public init() { }
}

enum StopContactRecordingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopContactStreamingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case instanceId = "InstanceId"
        case streamingId = "StreamingId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = self.contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let streamingId = self.streamingId {
            try encodeContainer.encode(streamingId, forKey: .streamingId)
        }
    }
}

extension StopContactStreamingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/contact/stop-streaming"
    }
}

public struct StopContactStreamingInput: Swift.Equatable {
    /// The identifier of the contact. This is the identifier of the contact that is associated with the first interaction with the contact center.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the streaming configuration enabled.
    /// This member is required.
    public var streamingId: Swift.String?

    public init(
        contactId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        streamingId: Swift.String? = nil
    )
    {
        self.contactId = contactId
        self.instanceId = instanceId
        self.streamingId = streamingId
    }
}

struct StopContactStreamingInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let contactId: Swift.String?
    let streamingId: Swift.String?
}

extension StopContactStreamingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case instanceId = "InstanceId"
        case streamingId = "StreamingId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let streamingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamingId)
        streamingId = streamingIdDecoded
    }
}

extension StopContactStreamingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopContactStreamingOutput: Swift.Equatable {

    public init() { }
}

enum StopContactStreamingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectClientTypes {
    public enum StorageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case kinesisFirehose
        case kinesisStream
        case kinesisVideoStream
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageType] {
            return [
                .kinesisFirehose,
                .kinesisStream,
                .kinesisVideoStream,
                .s3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .kinesisFirehose: return "KINESIS_FIREHOSE"
            case .kinesisStream: return "KINESIS_STREAM"
            case .kinesisVideoStream: return "KINESIS_VIDEO_STREAM"
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StorageType(rawValue: rawValue) ?? StorageType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes {
    public enum StringComparisonType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case contains
        case exact
        case startsWith
        case sdkUnknown(Swift.String)

        public static var allCases: [StringComparisonType] {
            return [
                .contains,
                .exact,
                .startsWith,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contains: return "CONTAINS"
            case .exact: return "EXACT"
            case .startsWith: return "STARTS_WITH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StringComparisonType(rawValue: rawValue) ?? StringComparisonType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.StringCondition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparisonType = "ComparisonType"
        case fieldName = "FieldName"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparisonType = self.comparisonType {
            try encodeContainer.encode(comparisonType.rawValue, forKey: .comparisonType)
        }
        if let fieldName = self.fieldName {
            try encodeContainer.encode(fieldName, forKey: .fieldName)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldName)
        fieldName = fieldNameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let comparisonTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.StringComparisonType.self, forKey: .comparisonType)
        comparisonType = comparisonTypeDecoded
    }
}

extension ConnectClientTypes {
    /// A leaf node condition which can be used to specify a string condition.
    public struct StringCondition: Swift.Equatable {
        /// The type of comparison to be made when evaluating the string condition.
        public var comparisonType: ConnectClientTypes.StringComparisonType?
        /// The name of the field in the string condition.
        public var fieldName: Swift.String?
        /// The value of the string.
        public var value: Swift.String?

        public init(
            comparisonType: ConnectClientTypes.StringComparisonType? = nil,
            fieldName: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.comparisonType = comparisonType
            self.fieldName = fieldName
            self.value = value
        }
    }

}

extension ConnectClientTypes.StringReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ConnectClientTypes {
    /// Information about a reference when the referenceType is STRING. Otherwise, null.
    public struct StringReference: Swift.Equatable {
        /// Identifier of the string reference.
        public var name: Swift.String?
        /// A valid string.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension SubmitContactEvaluationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case answers = "Answers"
        case notes = "Notes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let answers = answers {
            var answersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .answers)
            for (dictKey0, evaluationAnswersInputMap0) in answers {
                try answersContainer.encode(evaluationAnswersInputMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let notes = notes {
            var notesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .notes)
            for (dictKey0, evaluationNotesMap0) in notes {
                try notesContainer.encode(evaluationNotesMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension SubmitContactEvaluationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let evaluationId = evaluationId else {
            return nil
        }
        return "/contact-evaluations/\(instanceId.urlPercentEncoding())/\(evaluationId.urlPercentEncoding())/submit"
    }
}

public struct SubmitContactEvaluationInput: Swift.Equatable {
    /// A map of question identifiers to answer value.
    public var answers: [Swift.String:ConnectClientTypes.EvaluationAnswerInput]?
    /// A unique identifier for the contact evaluation.
    /// This member is required.
    public var evaluationId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A map of question identifiers to note value.
    public var notes: [Swift.String:ConnectClientTypes.EvaluationNote]?

    public init(
        answers: [Swift.String:ConnectClientTypes.EvaluationAnswerInput]? = nil,
        evaluationId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        notes: [Swift.String:ConnectClientTypes.EvaluationNote]? = nil
    )
    {
        self.answers = answers
        self.evaluationId = evaluationId
        self.instanceId = instanceId
        self.notes = notes
    }
}

struct SubmitContactEvaluationInputBody: Swift.Equatable {
    let answers: [Swift.String:ConnectClientTypes.EvaluationAnswerInput]?
    let notes: [Swift.String:ConnectClientTypes.EvaluationNote]?
}

extension SubmitContactEvaluationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case answers = "Answers"
        case notes = "Notes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let answersContainer = try containerValues.decodeIfPresent([Swift.String: ConnectClientTypes.EvaluationAnswerInput?].self, forKey: .answers)
        var answersDecoded0: [Swift.String:ConnectClientTypes.EvaluationAnswerInput]? = nil
        if let answersContainer = answersContainer {
            answersDecoded0 = [Swift.String:ConnectClientTypes.EvaluationAnswerInput]()
            for (key0, evaluationanswerinput0) in answersContainer {
                if let evaluationanswerinput0 = evaluationanswerinput0 {
                    answersDecoded0?[key0] = evaluationanswerinput0
                }
            }
        }
        answers = answersDecoded0
        let notesContainer = try containerValues.decodeIfPresent([Swift.String: ConnectClientTypes.EvaluationNote?].self, forKey: .notes)
        var notesDecoded0: [Swift.String:ConnectClientTypes.EvaluationNote]? = nil
        if let notesContainer = notesContainer {
            notesDecoded0 = [Swift.String:ConnectClientTypes.EvaluationNote]()
            for (key0, evaluationnote0) in notesContainer {
                if let evaluationnote0 = evaluationnote0 {
                    notesDecoded0?[key0] = evaluationnote0
                }
            }
        }
        notes = notesDecoded0
    }
}

extension SubmitContactEvaluationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SubmitContactEvaluationOutputBody = try responseDecoder.decode(responseBody: data)
            self.evaluationArn = output.evaluationArn
            self.evaluationId = output.evaluationId
        } else {
            self.evaluationArn = nil
            self.evaluationId = nil
        }
    }
}

public struct SubmitContactEvaluationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the contact evaluation resource.
    /// This member is required.
    public var evaluationArn: Swift.String?
    /// A unique identifier for the contact evaluation.
    /// This member is required.
    public var evaluationId: Swift.String?

    public init(
        evaluationArn: Swift.String? = nil,
        evaluationId: Swift.String? = nil
    )
    {
        self.evaluationArn = evaluationArn
        self.evaluationId = evaluationId
    }
}

struct SubmitContactEvaluationOutputBody: Swift.Equatable {
    let evaluationId: Swift.String?
    let evaluationArn: Swift.String?
}

extension SubmitContactEvaluationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationArn = "EvaluationArn"
        case evaluationId = "EvaluationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationId)
        evaluationId = evaluationIdDecoded
        let evaluationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationArn)
        evaluationArn = evaluationArnDecoded
    }
}

enum SubmitContactEvaluationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectClientTypes.SuccessfulRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case requestIdentifier = "RequestIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = self.contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let requestIdentifier = self.requestIdentifier {
            try encodeContainer.encode(requestIdentifier, forKey: .requestIdentifier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestIdentifier)
        requestIdentifier = requestIdentifierDecoded
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
    }
}

extension ConnectClientTypes {
    /// Request for which contact was successfully created.
    public struct SuccessfulRequest: Swift.Equatable {
        /// The contactId of the contact that was created successfully.
        public var contactId: Swift.String?
        /// Request identifier provided in the API call in the ContactDataRequest to create a contact.
        public var requestIdentifier: Swift.String?

        public init(
            contactId: Swift.String? = nil,
            requestIdentifier: Swift.String? = nil
        )
        {
            self.contactId = contactId
            self.requestIdentifier = requestIdentifier
        }
    }

}

extension SuspendContactRecordingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case initialContactId = "InitialContactId"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = self.contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let initialContactId = self.initialContactId {
            try encodeContainer.encode(initialContactId, forKey: .initialContactId)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

extension SuspendContactRecordingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/contact/suspend-recording"
    }
}

public struct SuspendContactRecordingInput: Swift.Equatable {
    /// The identifier of the contact.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.
    /// This member is required.
    public var initialContactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        contactId: Swift.String? = nil,
        initialContactId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.contactId = contactId
        self.initialContactId = initialContactId
        self.instanceId = instanceId
    }
}

struct SuspendContactRecordingInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let contactId: Swift.String?
    let initialContactId: Swift.String?
}

extension SuspendContactRecordingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case initialContactId = "InitialContactId"
        case instanceId = "InstanceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let initialContactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initialContactId)
        initialContactId = initialContactIdDecoded
    }
}

extension SuspendContactRecordingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct SuspendContactRecordingOutput: Swift.Equatable {

    public init() { }
}

enum SuspendContactRecordingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectClientTypes.TagCondition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKey = "TagKey"
        case tagValue = "TagValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagKey = self.tagKey {
            try encodeContainer.encode(tagKey, forKey: .tagKey)
        }
        if let tagValue = self.tagValue {
            try encodeContainer.encode(tagValue, forKey: .tagValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagKey)
        tagKey = tagKeyDecoded
        let tagValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagValue)
        tagValue = tagValueDecoded
    }
}

extension ConnectClientTypes {
    /// A leaf node condition which can be used to specify a tag condition, for example, HAVE BPO = 123.
    public struct TagCondition: Swift.Equatable {
        /// The tag key in the tag condition.
        public var tagKey: Swift.String?
        /// The tag value in the tag condition.
        public var tagValue: Swift.String?

        public init(
            tagKey: Swift.String? = nil,
            tagValue: Swift.String? = nil
        )
        {
            self.tagKey = tagKey
            self.tagValue = tagValue
        }
    }

}

extension TagContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case instanceId = "InstanceId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = self.contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, contactTagMap0) in tags {
                try tagsContainer.encode(contactTagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/contact/tags"
    }
}

public struct TagContactInput: Swift.Equatable {
    /// The identifier of the contact in this instance of Amazon Connect.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The tags to be assigned to the contact resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }. Authorization is not supported by this tag.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        contactId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.contactId = contactId
        self.instanceId = instanceId
        self.tags = tags
    }
}

struct TagContactInputBody: Swift.Equatable {
    let contactId: Swift.String?
    let instanceId: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension TagContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case instanceId = "InstanceId"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, contacttagvalue0) in tagsContainer {
                if let contacttagvalue0 = contacttagvalue0 {
                    tagsDecoded0?[key0] = contacttagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagContactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagContactOutput: Swift.Equatable {

    public init() { }
}

enum TagContactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectClientTypes.TagSearchCondition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKey
        case tagKeyComparisonType
        case tagValue
        case tagValueComparisonType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagKey = self.tagKey {
            try encodeContainer.encode(tagKey, forKey: .tagKey)
        }
        if let tagKeyComparisonType = self.tagKeyComparisonType {
            try encodeContainer.encode(tagKeyComparisonType.rawValue, forKey: .tagKeyComparisonType)
        }
        if let tagValue = self.tagValue {
            try encodeContainer.encode(tagValue, forKey: .tagValue)
        }
        if let tagValueComparisonType = self.tagValueComparisonType {
            try encodeContainer.encode(tagValueComparisonType.rawValue, forKey: .tagValueComparisonType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagKey)
        tagKey = tagKeyDecoded
        let tagValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagValue)
        tagValue = tagValueDecoded
        let tagKeyComparisonTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.StringComparisonType.self, forKey: .tagKeyComparisonType)
        tagKeyComparisonType = tagKeyComparisonTypeDecoded
        let tagValueComparisonTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.StringComparisonType.self, forKey: .tagValueComparisonType)
        tagValueComparisonType = tagValueComparisonTypeDecoded
    }
}

extension ConnectClientTypes {
    /// The search criteria to be used to return tags.
    public struct TagSearchCondition: Swift.Equatable {
        /// The tag key used in the tag search condition.
        public var tagKey: Swift.String?
        /// The type of comparison to be made when evaluating the tag key in tag search condition.
        public var tagKeyComparisonType: ConnectClientTypes.StringComparisonType?
        /// The tag value used in the tag search condition.
        public var tagValue: Swift.String?
        /// The type of comparison to be made when evaluating the tag value in tag search condition.
        public var tagValueComparisonType: ConnectClientTypes.StringComparisonType?

        public init(
            tagKey: Swift.String? = nil,
            tagKeyComparisonType: ConnectClientTypes.StringComparisonType? = nil,
            tagValue: Swift.String? = nil,
            tagValueComparisonType: ConnectClientTypes.StringComparisonType? = nil
        )
        {
            self.tagKey = tagKey
            self.tagKeyComparisonType = tagKeyComparisonType
            self.tagValue = tagValue
            self.tagValueComparisonType = tagValueComparisonType
        }
    }

}

extension ConnectClientTypes.TagSet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ConnectClientTypes {
    /// A tag set contains tag key and tag value.
    public struct TagSet: Swift.Equatable {
        /// The tag key in the tagSet.
        public var key: Swift.String?
        /// The tag value in the tagSet.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension ConnectClientTypes.TaskActionDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactFlowId = "ContactFlowId"
        case description = "Description"
        case name = "Name"
        case references = "References"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactFlowId = self.contactFlowId {
            try encodeContainer.encode(contactFlowId, forKey: .contactFlowId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let references = references {
            var referencesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .references)
            for (dictKey0, contactReferences0) in references {
                try referencesContainer.encode(contactReferences0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let contactFlowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactFlowId)
        contactFlowId = contactFlowIdDecoded
        let referencesContainer = try containerValues.decodeIfPresent([Swift.String: ConnectClientTypes.Reference?].self, forKey: .references)
        var referencesDecoded0: [Swift.String:ConnectClientTypes.Reference]? = nil
        if let referencesContainer = referencesContainer {
            referencesDecoded0 = [Swift.String:ConnectClientTypes.Reference]()
            for (key0, reference0) in referencesContainer {
                if let reference0 = reference0 {
                    referencesDecoded0?[key0] = reference0
                }
            }
        }
        references = referencesDecoded0
    }
}

extension ConnectClientTypes {
    /// Information about the task action.
    public struct TaskActionDefinition: Swift.Equatable {
        /// The identifier of the flow.
        /// This member is required.
        public var contactFlowId: Swift.String?
        /// The description. Supports variable injection. For more information, see [JSONPath reference](https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html) in the Amazon Connect Administrators Guide.
        public var description: Swift.String?
        /// The name. Supports variable injection. For more information, see [JSONPath reference](https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html) in the Amazon Connect Administrators Guide.
        /// This member is required.
        public var name: Swift.String?
        /// Information about the reference when the referenceType is URL. Otherwise, null. (Supports variable injection in the Value field.)
        public var references: [Swift.String:ConnectClientTypes.Reference]?

        public init(
            contactFlowId: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            references: [Swift.String:ConnectClientTypes.Reference]? = nil
        )
        {
            self.contactFlowId = contactFlowId
            self.description = description
            self.name = name
            self.references = references
        }
    }

}

extension ConnectClientTypes.TaskTemplateConstraints: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invisibleFields = "InvisibleFields"
        case readOnlyFields = "ReadOnlyFields"
        case requiredFields = "RequiredFields"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invisibleFields = invisibleFields {
            var invisibleFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .invisibleFields)
            for invisiblefieldinfo0 in invisibleFields {
                try invisibleFieldsContainer.encode(invisiblefieldinfo0)
            }
        }
        if let readOnlyFields = readOnlyFields {
            var readOnlyFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .readOnlyFields)
            for readonlyfieldinfo0 in readOnlyFields {
                try readOnlyFieldsContainer.encode(readonlyfieldinfo0)
            }
        }
        if let requiredFields = requiredFields {
            var requiredFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requiredFields)
            for requiredfieldinfo0 in requiredFields {
                try requiredFieldsContainer.encode(requiredfieldinfo0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requiredFieldsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.RequiredFieldInfo?].self, forKey: .requiredFields)
        var requiredFieldsDecoded0:[ConnectClientTypes.RequiredFieldInfo]? = nil
        if let requiredFieldsContainer = requiredFieldsContainer {
            requiredFieldsDecoded0 = [ConnectClientTypes.RequiredFieldInfo]()
            for structure0 in requiredFieldsContainer {
                if let structure0 = structure0 {
                    requiredFieldsDecoded0?.append(structure0)
                }
            }
        }
        requiredFields = requiredFieldsDecoded0
        let readOnlyFieldsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.ReadOnlyFieldInfo?].self, forKey: .readOnlyFields)
        var readOnlyFieldsDecoded0:[ConnectClientTypes.ReadOnlyFieldInfo]? = nil
        if let readOnlyFieldsContainer = readOnlyFieldsContainer {
            readOnlyFieldsDecoded0 = [ConnectClientTypes.ReadOnlyFieldInfo]()
            for structure0 in readOnlyFieldsContainer {
                if let structure0 = structure0 {
                    readOnlyFieldsDecoded0?.append(structure0)
                }
            }
        }
        readOnlyFields = readOnlyFieldsDecoded0
        let invisibleFieldsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.InvisibleFieldInfo?].self, forKey: .invisibleFields)
        var invisibleFieldsDecoded0:[ConnectClientTypes.InvisibleFieldInfo]? = nil
        if let invisibleFieldsContainer = invisibleFieldsContainer {
            invisibleFieldsDecoded0 = [ConnectClientTypes.InvisibleFieldInfo]()
            for structure0 in invisibleFieldsContainer {
                if let structure0 = structure0 {
                    invisibleFieldsDecoded0?.append(structure0)
                }
            }
        }
        invisibleFields = invisibleFieldsDecoded0
    }
}

extension ConnectClientTypes {
    /// Describes constraints that apply to the template fields.
    public struct TaskTemplateConstraints: Swift.Equatable {
        /// Lists the fields that are invisible to agents.
        public var invisibleFields: [ConnectClientTypes.InvisibleFieldInfo]?
        /// Lists the fields that are read-only to agents, and cannot be edited.
        public var readOnlyFields: [ConnectClientTypes.ReadOnlyFieldInfo]?
        /// Lists the fields that are required to be filled by agents.
        public var requiredFields: [ConnectClientTypes.RequiredFieldInfo]?

        public init(
            invisibleFields: [ConnectClientTypes.InvisibleFieldInfo]? = nil,
            readOnlyFields: [ConnectClientTypes.ReadOnlyFieldInfo]? = nil,
            requiredFields: [ConnectClientTypes.RequiredFieldInfo]? = nil
        )
        {
            self.invisibleFields = invisibleFields
            self.readOnlyFields = readOnlyFields
            self.requiredFields = requiredFields
        }
    }

}

extension ConnectClientTypes.TaskTemplateDefaultFieldValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.TaskTemplateFieldIdentifier.self, forKey: .id)
        id = idDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
    }
}

extension ConnectClientTypes {
    /// Describes a default field and its corresponding value.
    public struct TaskTemplateDefaultFieldValue: Swift.Equatable {
        /// Default value for the field.
        public var defaultValue: Swift.String?
        /// Identifier of a field.
        public var id: ConnectClientTypes.TaskTemplateFieldIdentifier?

        public init(
            defaultValue: Swift.String? = nil,
            id: ConnectClientTypes.TaskTemplateFieldIdentifier? = nil
        )
        {
            self.defaultValue = defaultValue
            self.id = id
        }
    }

}

extension ConnectClientTypes.TaskTemplateDefaults: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultFieldValues = "DefaultFieldValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultFieldValues = defaultFieldValues {
            var defaultFieldValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .defaultFieldValues)
            for tasktemplatedefaultfieldvalue0 in defaultFieldValues {
                try defaultFieldValuesContainer.encode(tasktemplatedefaultfieldvalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultFieldValuesContainer = try containerValues.decodeIfPresent([ConnectClientTypes.TaskTemplateDefaultFieldValue?].self, forKey: .defaultFieldValues)
        var defaultFieldValuesDecoded0:[ConnectClientTypes.TaskTemplateDefaultFieldValue]? = nil
        if let defaultFieldValuesContainer = defaultFieldValuesContainer {
            defaultFieldValuesDecoded0 = [ConnectClientTypes.TaskTemplateDefaultFieldValue]()
            for structure0 in defaultFieldValuesContainer {
                if let structure0 = structure0 {
                    defaultFieldValuesDecoded0?.append(structure0)
                }
            }
        }
        defaultFieldValues = defaultFieldValuesDecoded0
    }
}

extension ConnectClientTypes {
    /// Describes default values for fields on a template.
    public struct TaskTemplateDefaults: Swift.Equatable {
        /// Default value for the field.
        public var defaultFieldValues: [ConnectClientTypes.TaskTemplateDefaultFieldValue]?

        public init(
            defaultFieldValues: [ConnectClientTypes.TaskTemplateDefaultFieldValue]? = nil
        )
        {
            self.defaultFieldValues = defaultFieldValues
        }
    }

}

extension ConnectClientTypes.TaskTemplateField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case id = "Id"
        case singleSelectOptions = "SingleSelectOptions"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let singleSelectOptions = singleSelectOptions {
            var singleSelectOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .singleSelectOptions)
            for tasktemplatesingleselectoption0 in singleSelectOptions {
                try singleSelectOptionsContainer.encode(tasktemplatesingleselectoption0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.TaskTemplateFieldIdentifier.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.TaskTemplateFieldType.self, forKey: .type)
        type = typeDecoded
        let singleSelectOptionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .singleSelectOptions)
        var singleSelectOptionsDecoded0:[Swift.String]? = nil
        if let singleSelectOptionsContainer = singleSelectOptionsContainer {
            singleSelectOptionsDecoded0 = [Swift.String]()
            for string0 in singleSelectOptionsContainer {
                if let string0 = string0 {
                    singleSelectOptionsDecoded0?.append(string0)
                }
            }
        }
        singleSelectOptions = singleSelectOptionsDecoded0
    }
}

extension ConnectClientTypes {
    /// Describes a single task template field.
    public struct TaskTemplateField: Swift.Equatable {
        /// The description of the field.
        public var description: Swift.String?
        /// The unique identifier for the field.
        /// This member is required.
        public var id: ConnectClientTypes.TaskTemplateFieldIdentifier?
        /// A list of options for a single select field.
        public var singleSelectOptions: [Swift.String]?
        /// Indicates the type of field.
        public var type: ConnectClientTypes.TaskTemplateFieldType?

        public init(
            description: Swift.String? = nil,
            id: ConnectClientTypes.TaskTemplateFieldIdentifier? = nil,
            singleSelectOptions: [Swift.String]? = nil,
            type: ConnectClientTypes.TaskTemplateFieldType? = nil
        )
        {
            self.description = description
            self.id = id
            self.singleSelectOptions = singleSelectOptions
            self.type = type
        }
    }

}

extension ConnectClientTypes.TaskTemplateFieldIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ConnectClientTypes {
    /// The identifier of the task template field.
    public struct TaskTemplateFieldIdentifier: Swift.Equatable {
        /// The name of the task template field.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension ConnectClientTypes {
    public enum TaskTemplateFieldType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case boolean
        case dateTime
        case description
        case email
        case name
        case number
        case quickConnect
        case scheduledTime
        case singleSelect
        case text
        case textArea
        case url
        case sdkUnknown(Swift.String)

        public static var allCases: [TaskTemplateFieldType] {
            return [
                .boolean,
                .dateTime,
                .description,
                .email,
                .name,
                .number,
                .quickConnect,
                .scheduledTime,
                .singleSelect,
                .text,
                .textArea,
                .url,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .boolean: return "BOOLEAN"
            case .dateTime: return "DATE_TIME"
            case .description: return "DESCRIPTION"
            case .email: return "EMAIL"
            case .name: return "NAME"
            case .number: return "NUMBER"
            case .quickConnect: return "QUICK_CONNECT"
            case .scheduledTime: return "SCHEDULED_TIME"
            case .singleSelect: return "SINGLE_SELECT"
            case .text: return "TEXT"
            case .textArea: return "TEXT_AREA"
            case .url: return "URL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TaskTemplateFieldType(rawValue: rawValue) ?? TaskTemplateFieldType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.TaskTemplateMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case description = "Description"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.TaskTemplateStatus.self, forKey: .status)
        status = statusDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension ConnectClientTypes {
    /// Contains summary information about the task template.
    public struct TaskTemplateMetadata: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the task template.
        public var arn: Swift.String?
        /// The timestamp when the task template was created.
        public var createdTime: ClientRuntime.Date?
        /// The description of the task template.
        public var description: Swift.String?
        /// A unique identifier for the task template.
        public var id: Swift.String?
        /// The timestamp when the task template was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name of the task template.
        public var name: Swift.String?
        /// Marks a template as ACTIVE or INACTIVE for a task to refer to it. Tasks can only be created from ACTIVE templates. If a template is marked as INACTIVE, then a task that refers to this template cannot be created.
        public var status: ConnectClientTypes.TaskTemplateStatus?

        public init(
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: ConnectClientTypes.TaskTemplateStatus? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.status = status
        }
    }

}

extension ConnectClientTypes {
    public enum TaskTemplateStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [TaskTemplateStatus] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TaskTemplateStatus(rawValue: rawValue) ?? TaskTemplateStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.TelephonyConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributions = "Distributions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let distributions = distributions {
            var distributionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .distributions)
            for distribution0 in distributions {
                try distributionsContainer.encode(distribution0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.Distribution?].self, forKey: .distributions)
        var distributionsDecoded0:[ConnectClientTypes.Distribution]? = nil
        if let distributionsContainer = distributionsContainer {
            distributionsDecoded0 = [ConnectClientTypes.Distribution]()
            for structure0 in distributionsContainer {
                if let structure0 = structure0 {
                    distributionsDecoded0?.append(structure0)
                }
            }
        }
        distributions = distributionsDecoded0
    }
}

extension ConnectClientTypes {
    /// The distribution of traffic between the instance and its replicas.
    public struct TelephonyConfig: Swift.Equatable {
        /// Information about traffic distributions.
        /// This member is required.
        public var distributions: [ConnectClientTypes.Distribution]?

        public init(
            distributions: [ConnectClientTypes.Distribution]? = nil
        )
        {
            self.distributions = distributions
        }
    }

}

extension ConnectClientTypes.Threshold: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparison = "Comparison"
        case thresholdValue = "ThresholdValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparison = self.comparison {
            try encodeContainer.encode(comparison.rawValue, forKey: .comparison)
        }
        if let thresholdValue = self.thresholdValue {
            try encodeContainer.encode(thresholdValue, forKey: .thresholdValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparisonDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Comparison.self, forKey: .comparison)
        comparison = comparisonDecoded
        let thresholdValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .thresholdValue)
        thresholdValue = thresholdValueDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about the threshold for service level metrics.
    public struct Threshold: Swift.Equatable {
        /// The type of comparison. Only "less than" (LT) comparisons are supported.
        public var comparison: ConnectClientTypes.Comparison?
        /// The threshold value to compare.
        public var thresholdValue: Swift.Double?

        public init(
            comparison: ConnectClientTypes.Comparison? = nil,
            thresholdValue: Swift.Double? = nil
        )
        {
            self.comparison = comparison
            self.thresholdValue = thresholdValue
        }
    }

}

extension ConnectClientTypes.ThresholdV2: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparison = "Comparison"
        case thresholdValue = "ThresholdValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparison = self.comparison {
            try encodeContainer.encode(comparison, forKey: .comparison)
        }
        if let thresholdValue = self.thresholdValue {
            try encodeContainer.encode(thresholdValue, forKey: .thresholdValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparisonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comparison)
        comparison = comparisonDecoded
        let thresholdValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .thresholdValue)
        thresholdValue = thresholdValueDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about the threshold for service level metrics.
    public struct ThresholdV2: Swift.Equatable {
        /// The type of comparison. Only "less than" (LT) comparisons are supported.
        public var comparison: Swift.String?
        /// The threshold value to compare.
        public var thresholdValue: Swift.Double?

        public init(
            comparison: Swift.String? = nil,
            thresholdValue: Swift.Double? = nil
        )
        {
            self.comparison = comparison
            self.thresholdValue = thresholdValue
        }
    }

}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The throttling limit has been exceeded.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectClientTypes {
    public enum TimerEligibleParticipantRoles: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case agent
        case customer
        case sdkUnknown(Swift.String)

        public static var allCases: [TimerEligibleParticipantRoles] {
            return [
                .agent,
                .customer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agent: return "AGENT"
            case .customer: return "CUSTOMER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TimerEligibleParticipantRoles(rawValue: rawValue) ?? TimerEligibleParticipantRoles.sdkUnknown(rawValue)
        }
    }
}

extension TooManyRequestsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Displayed when rate-related API limits are exceeded.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectClientTypes.TrafficDistributionGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case id = "Id"
        case instanceArn = "InstanceArn"
        case isDefault = "IsDefault"
        case name = "Name"
        case status = "Status"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if isDefault != false {
            try encodeContainer.encode(isDefault, forKey: .isDefault)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.TrafficDistributionGroupStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let isDefaultDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isDefault) ?? false
        isDefault = isDefaultDecoded
    }
}

extension ConnectClientTypes {
    /// Information about a traffic distribution group.
    public struct TrafficDistributionGroup: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the traffic distribution group.
        public var arn: Swift.String?
        /// The description of the traffic distribution group.
        public var description: Swift.String?
        /// The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.
        public var id: Swift.String?
        /// The Amazon Resource Name (ARN).
        public var instanceArn: Swift.String?
        /// Whether this is the default traffic distribution group created during instance replication. The default traffic distribution group cannot be deleted by the DeleteTrafficDistributionGroup API. The default traffic distribution group is deleted as part of the process for deleting a replica. The SignInConfig distribution is available only on a default TrafficDistributionGroup (see the IsDefault parameter in the [TrafficDistributionGroup](https://docs.aws.amazon.com/connect/latest/APIReference/API_TrafficDistributionGroup.html) data type). If you call UpdateTrafficDistribution with a modified SignInConfig and a non-default TrafficDistributionGroup, an InvalidRequestException is returned.
        public var isDefault: Swift.Bool
        /// The name of the traffic distribution group.
        public var name: Swift.String?
        /// The status of the traffic distribution group.
        ///
        /// * CREATION_IN_PROGRESS means the previous [CreateTrafficDistributionGroup](https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html) operation is still in progress and has not yet completed.
        ///
        /// * ACTIVE means the previous [CreateTrafficDistributionGroup](https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html) operation has succeeded.
        ///
        /// * CREATION_FAILED indicates that the previous [CreateTrafficDistributionGroup](https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html) operation has failed.
        ///
        /// * PENDING_DELETION means the previous [DeleteTrafficDistributionGroup](https://docs.aws.amazon.com/connect/latest/APIReference/API_DeleteTrafficDistributionGroup.html) operation is still in progress and has not yet completed.
        ///
        /// * DELETION_FAILED means the previous [DeleteTrafficDistributionGroup](https://docs.aws.amazon.com/connect/latest/APIReference/API_DeleteTrafficDistributionGroup.html) operation has failed.
        ///
        /// * UPDATE_IN_PROGRESS means the previous [UpdateTrafficDistribution](https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdateTrafficDistribution.html) operation is still in progress and has not yet completed.
        public var status: ConnectClientTypes.TrafficDistributionGroupStatus?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            instanceArn: Swift.String? = nil,
            isDefault: Swift.Bool = false,
            name: Swift.String? = nil,
            status: ConnectClientTypes.TrafficDistributionGroupStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.id = id
            self.instanceArn = instanceArn
            self.isDefault = isDefault
            self.name = name
            self.status = status
            self.tags = tags
        }
    }

}

extension ConnectClientTypes {
    public enum TrafficDistributionGroupStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creationFailed
        case creationInProgress
        case deletionFailed
        case pendingDeletion
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [TrafficDistributionGroupStatus] {
            return [
                .active,
                .creationFailed,
                .creationInProgress,
                .deletionFailed,
                .pendingDeletion,
                .updateInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creationFailed: return "CREATION_FAILED"
            case .creationInProgress: return "CREATION_IN_PROGRESS"
            case .deletionFailed: return "DELETION_FAILED"
            case .pendingDeletion: return "PENDING_DELETION"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TrafficDistributionGroupStatus(rawValue: rawValue) ?? TrafficDistributionGroupStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.TrafficDistributionGroupSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case instanceArn = "InstanceArn"
        case isDefault = "IsDefault"
        case name = "Name"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if isDefault != false {
            try encodeContainer.encode(isDefault, forKey: .isDefault)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.TrafficDistributionGroupStatus.self, forKey: .status)
        status = statusDecoded
        let isDefaultDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isDefault) ?? false
        isDefault = isDefaultDecoded
    }
}

extension ConnectClientTypes {
    /// Information about traffic distribution groups.
    public struct TrafficDistributionGroupSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the traffic distribution group.
        public var arn: Swift.String?
        /// The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.
        public var id: Swift.String?
        /// The Amazon Resource Name (ARN) of the traffic distribution group.
        public var instanceArn: Swift.String?
        /// Whether this is the default traffic distribution group created during instance replication. The default traffic distribution group cannot be deleted by the DeleteTrafficDistributionGroup API. The default traffic distribution group is deleted as part of the process for deleting a replica.
        public var isDefault: Swift.Bool
        /// The name of the traffic distribution group.
        public var name: Swift.String?
        /// The status of the traffic distribution group.
        ///
        /// * CREATION_IN_PROGRESS means the previous [CreateTrafficDistributionGroup](https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html) operation is still in progress and has not yet completed.
        ///
        /// * ACTIVE means the previous [CreateTrafficDistributionGroup](https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html) operation has succeeded.
        ///
        /// * CREATION_FAILED indicates that the previous [CreateTrafficDistributionGroup](https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html) operation has failed.
        ///
        /// * PENDING_DELETION means the previous [DeleteTrafficDistributionGroup](https://docs.aws.amazon.com/connect/latest/APIReference/API_DeleteTrafficDistributionGroup.html) operation is still in progress and has not yet completed.
        ///
        /// * DELETION_FAILED means the previous [DeleteTrafficDistributionGroup](https://docs.aws.amazon.com/connect/latest/APIReference/API_DeleteTrafficDistributionGroup.html) operation has failed.
        ///
        /// * UPDATE_IN_PROGRESS means the previous [UpdateTrafficDistributionGroup](https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdateTrafficDistributionGroup.html) operation is still in progress and has not yet completed.
        public var status: ConnectClientTypes.TrafficDistributionGroupStatus?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            instanceArn: Swift.String? = nil,
            isDefault: Swift.Bool = false,
            name: Swift.String? = nil,
            status: ConnectClientTypes.TrafficDistributionGroupStatus? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.instanceArn = instanceArn
            self.isDefault = isDefault
            self.name = name
            self.status = status
        }
    }

}

extension ConnectClientTypes.TrafficDistributionGroupUserSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension ConnectClientTypes {
    /// Summary information about a traffic distribution group user.
    public struct TrafficDistributionGroupUserSummary: Swift.Equatable {
        /// The identifier for the user. This can be the ID or the ARN of the user.
        public var userId: Swift.String?

        public init(
            userId: Swift.String? = nil
        )
        {
            self.userId = userId
        }
    }

}

extension ConnectClientTypes {
    public enum TrafficType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case campaign
        case general
        case sdkUnknown(Swift.String)

        public static var allCases: [TrafficType] {
            return [
                .campaign,
                .general,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .campaign: return "CAMPAIGN"
            case .general: return "GENERAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TrafficType(rawValue: rawValue) ?? TrafficType.sdkUnknown(rawValue)
        }
    }
}

extension TransferContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case contactFlowId = "ContactFlowId"
        case contactId = "ContactId"
        case instanceId = "InstanceId"
        case queueId = "QueueId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let contactFlowId = self.contactFlowId {
            try encodeContainer.encode(contactFlowId, forKey: .contactFlowId)
        }
        if let contactId = self.contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let queueId = self.queueId {
            try encodeContainer.encode(queueId, forKey: .queueId)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension TransferContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/contact/transfer"
    }
}

public struct TransferContactInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The identifier of the flow.
    /// This member is required.
    public var contactFlowId: Swift.String?
    /// The identifier of the contact in this instance of Amazon Connect.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the queue.
    public var queueId: Swift.String?
    /// The identifier for the user. This can be the ID or the ARN of the user.
    public var userId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        contactFlowId: Swift.String? = nil,
        contactId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        queueId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.contactFlowId = contactFlowId
        self.contactId = contactId
        self.instanceId = instanceId
        self.queueId = queueId
        self.userId = userId
    }
}

struct TransferContactInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let contactId: Swift.String?
    let queueId: Swift.String?
    let userId: Swift.String?
    let contactFlowId: Swift.String?
    let clientToken: Swift.String?
}

extension TransferContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case contactFlowId = "ContactFlowId"
        case contactId = "ContactId"
        case instanceId = "InstanceId"
        case queueId = "QueueId"
        case userId = "UserId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let queueIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueId)
        queueId = queueIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let contactFlowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactFlowId)
        contactFlowId = contactFlowIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension TransferContactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TransferContactOutputBody = try responseDecoder.decode(responseBody: data)
            self.contactArn = output.contactArn
            self.contactId = output.contactId
        } else {
            self.contactArn = nil
            self.contactId = nil
        }
    }
}

public struct TransferContactOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact.
    public var contactArn: Swift.String?
    /// The identifier of the contact in this instance of Amazon Connect.
    public var contactId: Swift.String?

    public init(
        contactArn: Swift.String? = nil,
        contactId: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
        self.contactId = contactId
    }
}

struct TransferContactOutputBody: Swift.Equatable {
    let contactId: Swift.String?
    let contactArn: Swift.String?
}

extension TransferContactOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
        case contactId = "ContactId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
    }
}

enum TransferContactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IdempotencyException": return try await IdempotencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectClientTypes {
    public enum Unit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case count
        case percent
        case seconds
        case sdkUnknown(Swift.String)

        public static var allCases: [Unit] {
            return [
                .count,
                .percent,
                .seconds,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .count: return "COUNT"
            case .percent: return "PERCENT"
            case .seconds: return "SECONDS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Unit(rawValue: rawValue) ?? Unit.sdkUnknown(rawValue)
        }
    }
}

extension UntagContactInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "TagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let contactId = contactId else {
            return nil
        }
        return "/contact/tags/\(instanceId.urlPercentEncoding())/\(contactId.urlPercentEncoding())"
    }
}

public struct UntagContactInput: Swift.Equatable {
    /// The identifier of the contact in this instance of Amazon Connect.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A list of tag keys. Existing tags on the contact whose keys are members of this list will be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        contactId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.contactId = contactId
        self.instanceId = instanceId
        self.tagKeys = tagKeys
    }
}

struct UntagContactInputBody: Swift.Equatable {
}

extension UntagContactInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagContactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagContactOutput: Swift.Equatable {

    public init() { }
}

enum UntagContactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAgentStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case displayOrder = "DisplayOrder"
        case name = "Name"
        case resetOrderNumber = "ResetOrderNumber"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayOrder = self.displayOrder {
            try encodeContainer.encode(displayOrder, forKey: .displayOrder)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resetOrderNumber = self.resetOrderNumber {
            try encodeContainer.encode(resetOrderNumber, forKey: .resetOrderNumber)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }
}

extension UpdateAgentStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let agentStatusId = agentStatusId else {
            return nil
        }
        return "/agent-status/\(instanceId.urlPercentEncoding())/\(agentStatusId.urlPercentEncoding())"
    }
}

public struct UpdateAgentStatusInput: Swift.Equatable {
    /// The identifier of the agent status.
    /// This member is required.
    public var agentStatusId: Swift.String?
    /// The description of the agent status.
    public var description: Swift.String?
    /// The display order of the agent status.
    public var displayOrder: Swift.Int?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the agent status.
    public var name: Swift.String?
    /// A number indicating the reset order of the agent status.
    public var resetOrderNumber: Swift.Bool?
    /// The state of the agent status.
    public var state: ConnectClientTypes.AgentStatusState?

    public init(
        agentStatusId: Swift.String? = nil,
        description: Swift.String? = nil,
        displayOrder: Swift.Int? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        resetOrderNumber: Swift.Bool? = nil,
        state: ConnectClientTypes.AgentStatusState? = nil
    )
    {
        self.agentStatusId = agentStatusId
        self.description = description
        self.displayOrder = displayOrder
        self.instanceId = instanceId
        self.name = name
        self.resetOrderNumber = resetOrderNumber
        self.state = state
    }
}

struct UpdateAgentStatusInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let state: ConnectClientTypes.AgentStatusState?
    let displayOrder: Swift.Int?
    let resetOrderNumber: Swift.Bool?
}

extension UpdateAgentStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case displayOrder = "DisplayOrder"
        case name = "Name"
        case resetOrderNumber = "ResetOrderNumber"
        case state = "State"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.AgentStatusState.self, forKey: .state)
        state = stateDecoded
        let displayOrderDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .displayOrder)
        displayOrder = displayOrderDecoded
        let resetOrderNumberDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .resetOrderNumber)
        resetOrderNumber = resetOrderNumberDecoded
    }
}

extension UpdateAgentStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateAgentStatusOutput: Swift.Equatable {

    public init() { }
}

enum UpdateAgentStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DuplicateResourceException": return try await DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectClientTypes.UpdateCaseActionDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields = "Fields"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fields = fields {
            var fieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fields)
            for fieldvalue0 in fields {
                try fieldsContainer.encode(fieldvalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.FieldValue?].self, forKey: .fields)
        var fieldsDecoded0:[ConnectClientTypes.FieldValue]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [ConnectClientTypes.FieldValue]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension ConnectClientTypes {
    /// The UpdateCase action definition.
    public struct UpdateCaseActionDefinition: Swift.Equatable {
        /// An array of objects with Field ID and Value data.
        /// This member is required.
        public var fields: [ConnectClientTypes.FieldValue]?

        public init(
            fields: [ConnectClientTypes.FieldValue]? = nil
        )
        {
            self.fields = fields
        }
    }

}

extension UpdateContactAttributesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case initialContactId = "InitialContactId"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let initialContactId = self.initialContactId {
            try encodeContainer.encode(initialContactId, forKey: .initialContactId)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

extension UpdateContactAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/contact/attributes"
    }
}

public struct UpdateContactAttributesInput: Swift.Equatable {
    /// The Amazon Connect attributes. These attributes can be accessed in flows just like any other contact attributes. You can have up to 32,768 UTF-8 bytes across all attributes for a contact. Attribute keys can include only alphanumeric, dash, and underscore characters.
    /// This member is required.
    public var attributes: [Swift.String:Swift.String]?
    /// The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.
    /// This member is required.
    public var initialContactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        attributes: [Swift.String:Swift.String]? = nil,
        initialContactId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.initialContactId = initialContactId
        self.instanceId = instanceId
    }
}

struct UpdateContactAttributesInputBody: Swift.Equatable {
    let initialContactId: Swift.String?
    let instanceId: Swift.String?
    let attributes: [Swift.String:Swift.String]?
}

extension UpdateContactAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case initialContactId = "InitialContactId"
        case instanceId = "InstanceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialContactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initialContactId)
        initialContactId = initialContactIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension UpdateContactAttributesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateContactAttributesOutput: Swift.Equatable {

    public init() { }
}

enum UpdateContactAttributesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateContactEvaluationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case answers = "Answers"
        case notes = "Notes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let answers = answers {
            var answersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .answers)
            for (dictKey0, evaluationAnswersInputMap0) in answers {
                try answersContainer.encode(evaluationAnswersInputMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let notes = notes {
            var notesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .notes)
            for (dictKey0, evaluationNotesMap0) in notes {
                try notesContainer.encode(evaluationNotesMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension UpdateContactEvaluationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let evaluationId = evaluationId else {
            return nil
        }
        return "/contact-evaluations/\(instanceId.urlPercentEncoding())/\(evaluationId.urlPercentEncoding())"
    }
}

public struct UpdateContactEvaluationInput: Swift.Equatable {
    /// A map of question identifiers to answer value.
    public var answers: [Swift.String:ConnectClientTypes.EvaluationAnswerInput]?
    /// A unique identifier for the contact evaluation.
    /// This member is required.
    public var evaluationId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A map of question identifiers to note value.
    public var notes: [Swift.String:ConnectClientTypes.EvaluationNote]?

    public init(
        answers: [Swift.String:ConnectClientTypes.EvaluationAnswerInput]? = nil,
        evaluationId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        notes: [Swift.String:ConnectClientTypes.EvaluationNote]? = nil
    )
    {
        self.answers = answers
        self.evaluationId = evaluationId
        self.instanceId = instanceId
        self.notes = notes
    }
}

struct UpdateContactEvaluationInputBody: Swift.Equatable {
    let answers: [Swift.String:ConnectClientTypes.EvaluationAnswerInput]?
    let notes: [Swift.String:ConnectClientTypes.EvaluationNote]?
}

extension UpdateContactEvaluationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case answers = "Answers"
        case notes = "Notes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let answersContainer = try containerValues.decodeIfPresent([Swift.String: ConnectClientTypes.EvaluationAnswerInput?].self, forKey: .answers)
        var answersDecoded0: [Swift.String:ConnectClientTypes.EvaluationAnswerInput]? = nil
        if let answersContainer = answersContainer {
            answersDecoded0 = [Swift.String:ConnectClientTypes.EvaluationAnswerInput]()
            for (key0, evaluationanswerinput0) in answersContainer {
                if let evaluationanswerinput0 = evaluationanswerinput0 {
                    answersDecoded0?[key0] = evaluationanswerinput0
                }
            }
        }
        answers = answersDecoded0
        let notesContainer = try containerValues.decodeIfPresent([Swift.String: ConnectClientTypes.EvaluationNote?].self, forKey: .notes)
        var notesDecoded0: [Swift.String:ConnectClientTypes.EvaluationNote]? = nil
        if let notesContainer = notesContainer {
            notesDecoded0 = [Swift.String:ConnectClientTypes.EvaluationNote]()
            for (key0, evaluationnote0) in notesContainer {
                if let evaluationnote0 = evaluationnote0 {
                    notesDecoded0?[key0] = evaluationnote0
                }
            }
        }
        notes = notesDecoded0
    }
}

extension UpdateContactEvaluationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateContactEvaluationOutputBody = try responseDecoder.decode(responseBody: data)
            self.evaluationArn = output.evaluationArn
            self.evaluationId = output.evaluationId
        } else {
            self.evaluationArn = nil
            self.evaluationId = nil
        }
    }
}

public struct UpdateContactEvaluationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the contact evaluation resource.
    /// This member is required.
    public var evaluationArn: Swift.String?
    /// A unique identifier for the contact evaluation.
    /// This member is required.
    public var evaluationId: Swift.String?

    public init(
        evaluationArn: Swift.String? = nil,
        evaluationId: Swift.String? = nil
    )
    {
        self.evaluationArn = evaluationArn
        self.evaluationId = evaluationId
    }
}

struct UpdateContactEvaluationOutputBody: Swift.Equatable {
    let evaluationId: Swift.String?
    let evaluationArn: Swift.String?
}

extension UpdateContactEvaluationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationArn = "EvaluationArn"
        case evaluationId = "EvaluationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationId)
        evaluationId = evaluationIdDecoded
        let evaluationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationArn)
        evaluationArn = evaluationArnDecoded
    }
}

enum UpdateContactEvaluationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateContactFlowContentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
    }
}

extension UpdateContactFlowContentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let contactFlowId = contactFlowId else {
            return nil
        }
        return "/contact-flows/\(instanceId.urlPercentEncoding())/\(contactFlowId.urlPercentEncoding())/content"
    }
}

public struct UpdateContactFlowContentInput: Swift.Equatable {
    /// The identifier of the flow.
    /// This member is required.
    public var contactFlowId: Swift.String?
    /// The JSON string that represents the content of the flow. For an example, see [Example flow in Amazon Connect Flow language](https://docs.aws.amazon.com/connect/latest/APIReference/flow-language-example.html). Length Constraints: Minimum length of 1. Maximum length of 256000.
    /// This member is required.
    public var content: Swift.String?
    /// The identifier of the Amazon Connect instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        contactFlowId: Swift.String? = nil,
        content: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.contactFlowId = contactFlowId
        self.content = content
        self.instanceId = instanceId
    }
}

struct UpdateContactFlowContentInputBody: Swift.Equatable {
    let content: Swift.String?
}

extension UpdateContactFlowContentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
    }
}

extension UpdateContactFlowContentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateContactFlowContentOutput: Swift.Equatable {

    public init() { }
}

enum UpdateContactFlowContentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidContactFlowException": return try await InvalidContactFlowException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateContactFlowMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactFlowState = "ContactFlowState"
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactFlowState = self.contactFlowState {
            try encodeContainer.encode(contactFlowState.rawValue, forKey: .contactFlowState)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateContactFlowMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let contactFlowId = contactFlowId else {
            return nil
        }
        return "/contact-flows/\(instanceId.urlPercentEncoding())/\(contactFlowId.urlPercentEncoding())/metadata"
    }
}

public struct UpdateContactFlowMetadataInput: Swift.Equatable {
    /// The identifier of the flow.
    /// This member is required.
    public var contactFlowId: Swift.String?
    /// The state of flow.
    public var contactFlowState: ConnectClientTypes.ContactFlowState?
    /// The description of the flow.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the flow.
    public var name: Swift.String?

    public init(
        contactFlowId: Swift.String? = nil,
        contactFlowState: ConnectClientTypes.ContactFlowState? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.contactFlowId = contactFlowId
        self.contactFlowState = contactFlowState
        self.description = description
        self.instanceId = instanceId
        self.name = name
    }
}

struct UpdateContactFlowMetadataInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let contactFlowState: ConnectClientTypes.ContactFlowState?
}

extension UpdateContactFlowMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactFlowState = "ContactFlowState"
        case description = "Description"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let contactFlowStateDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ContactFlowState.self, forKey: .contactFlowState)
        contactFlowState = contactFlowStateDecoded
    }
}

extension UpdateContactFlowMetadataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateContactFlowMetadataOutput: Swift.Equatable {

    public init() { }
}

enum UpdateContactFlowMetadataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DuplicateResourceException": return try await DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateContactFlowModuleContentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
    }
}

extension UpdateContactFlowModuleContentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let contactFlowModuleId = contactFlowModuleId else {
            return nil
        }
        return "/contact-flow-modules/\(instanceId.urlPercentEncoding())/\(contactFlowModuleId.urlPercentEncoding())/content"
    }
}

public struct UpdateContactFlowModuleContentInput: Swift.Equatable {
    /// The identifier of the flow module.
    /// This member is required.
    public var contactFlowModuleId: Swift.String?
    /// The JSON string that represents the content of the flow. For an example, see [Example flow in Amazon Connect Flow language](https://docs.aws.amazon.com/connect/latest/APIReference/flow-language-example.html).
    /// This member is required.
    public var content: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        contactFlowModuleId: Swift.String? = nil,
        content: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.contactFlowModuleId = contactFlowModuleId
        self.content = content
        self.instanceId = instanceId
    }
}

struct UpdateContactFlowModuleContentInputBody: Swift.Equatable {
    let content: Swift.String?
}

extension UpdateContactFlowModuleContentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
    }
}

extension UpdateContactFlowModuleContentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateContactFlowModuleContentOutput: Swift.Equatable {

    public init() { }
}

enum UpdateContactFlowModuleContentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidContactFlowModuleException": return try await InvalidContactFlowModuleException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateContactFlowModuleMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }
}

extension UpdateContactFlowModuleMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let contactFlowModuleId = contactFlowModuleId else {
            return nil
        }
        return "/contact-flow-modules/\(instanceId.urlPercentEncoding())/\(contactFlowModuleId.urlPercentEncoding())/metadata"
    }
}

public struct UpdateContactFlowModuleMetadataInput: Swift.Equatable {
    /// The identifier of the flow module.
    /// This member is required.
    public var contactFlowModuleId: Swift.String?
    /// The description of the flow module.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the flow module.
    public var name: Swift.String?
    /// The state of flow module.
    public var state: ConnectClientTypes.ContactFlowModuleState?

    public init(
        contactFlowModuleId: Swift.String? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        state: ConnectClientTypes.ContactFlowModuleState? = nil
    )
    {
        self.contactFlowModuleId = contactFlowModuleId
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.state = state
    }
}

struct UpdateContactFlowModuleMetadataInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let state: ConnectClientTypes.ContactFlowModuleState?
}

extension UpdateContactFlowModuleMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case state = "State"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ContactFlowModuleState.self, forKey: .state)
        state = stateDecoded
    }
}

extension UpdateContactFlowModuleMetadataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateContactFlowModuleMetadataOutput: Swift.Equatable {

    public init() { }
}

enum UpdateContactFlowModuleMetadataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DuplicateResourceException": return try await DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateContactFlowNameInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateContactFlowNameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let contactFlowId = contactFlowId else {
            return nil
        }
        return "/contact-flows/\(instanceId.urlPercentEncoding())/\(contactFlowId.urlPercentEncoding())/name"
    }
}

public struct UpdateContactFlowNameInput: Swift.Equatable {
    /// The identifier of the flow.
    /// This member is required.
    public var contactFlowId: Swift.String?
    /// The description of the flow.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the flow.
    public var name: Swift.String?

    public init(
        contactFlowId: Swift.String? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.contactFlowId = contactFlowId
        self.description = description
        self.instanceId = instanceId
        self.name = name
    }
}

struct UpdateContactFlowNameInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
}

extension UpdateContactFlowNameInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateContactFlowNameOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateContactFlowNameOutput: Swift.Equatable {

    public init() { }
}

enum UpdateContactFlowNameOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DuplicateResourceException": return try await DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case references = "References"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let references = references {
            var referencesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .references)
            for (dictKey0, contactReferences0) in references {
                try referencesContainer.encode(contactReferences0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension UpdateContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let contactId = contactId else {
            return nil
        }
        return "/contacts/\(instanceId.urlPercentEncoding())/\(contactId.urlPercentEncoding())"
    }
}

public struct UpdateContactInput: Swift.Equatable {
    /// The identifier of the contact. This is the identifier of the contact associated with the first interaction with your contact center.
    /// This member is required.
    public var contactId: Swift.String?
    /// The description of the contact.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the contact.
    public var name: Swift.String?
    /// Well-formed data on contact, shown to agents on Contact Control Panel (CCP).
    public var references: [Swift.String:ConnectClientTypes.Reference]?

    public init(
        contactId: Swift.String? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        references: [Swift.String:ConnectClientTypes.Reference]? = nil
    )
    {
        self.contactId = contactId
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.references = references
    }
}

struct UpdateContactInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let references: [Swift.String:ConnectClientTypes.Reference]?
}

extension UpdateContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case references = "References"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let referencesContainer = try containerValues.decodeIfPresent([Swift.String: ConnectClientTypes.Reference?].self, forKey: .references)
        var referencesDecoded0: [Swift.String:ConnectClientTypes.Reference]? = nil
        if let referencesContainer = referencesContainer {
            referencesDecoded0 = [Swift.String:ConnectClientTypes.Reference]()
            for (key0, reference0) in referencesContainer {
                if let reference0 = reference0 {
                    referencesDecoded0?[key0] = reference0
                }
            }
        }
        references = referencesDecoded0
    }
}

extension UpdateContactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateContactOutput: Swift.Equatable {

    public init() { }
}

enum UpdateContactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateContactScheduleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case instanceId = "InstanceId"
        case scheduledTime = "ScheduledTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = self.contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let scheduledTime = self.scheduledTime {
            try encodeContainer.encodeTimestamp(scheduledTime, format: .epochSeconds, forKey: .scheduledTime)
        }
    }
}

extension UpdateContactScheduleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/contact/schedule"
    }
}

public struct UpdateContactScheduleInput: Swift.Equatable {
    /// The identifier of the contact.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The timestamp, in Unix Epoch seconds format, at which to start running the inbound flow. The scheduled time cannot be in the past. It must be within up to 6 days in future.
    /// This member is required.
    public var scheduledTime: ClientRuntime.Date?

    public init(
        contactId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        scheduledTime: ClientRuntime.Date? = nil
    )
    {
        self.contactId = contactId
        self.instanceId = instanceId
        self.scheduledTime = scheduledTime
    }
}

struct UpdateContactScheduleInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let contactId: Swift.String?
    let scheduledTime: ClientRuntime.Date?
}

extension UpdateContactScheduleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case instanceId = "InstanceId"
        case scheduledTime = "ScheduledTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let scheduledTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .scheduledTime)
        scheduledTime = scheduledTimeDecoded
    }
}

extension UpdateContactScheduleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateContactScheduleOutput: Swift.Equatable {

    public init() { }
}

enum UpdateContactScheduleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateEvaluationFormInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case createNewVersion = "CreateNewVersion"
        case description = "Description"
        case evaluationFormVersion = "EvaluationFormVersion"
        case items = "Items"
        case scoringStrategy = "ScoringStrategy"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let createNewVersion = self.createNewVersion {
            try encodeContainer.encode(createNewVersion, forKey: .createNewVersion)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let evaluationFormVersion = self.evaluationFormVersion {
            try encodeContainer.encode(evaluationFormVersion, forKey: .evaluationFormVersion)
        }
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for evaluationformitem0 in items {
                try itemsContainer.encode(evaluationformitem0)
            }
        }
        if let scoringStrategy = self.scoringStrategy {
            try encodeContainer.encode(scoringStrategy, forKey: .scoringStrategy)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }
}

extension UpdateEvaluationFormInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let evaluationFormId = evaluationFormId else {
            return nil
        }
        return "/evaluation-forms/\(instanceId.urlPercentEncoding())/\(evaluationFormId.urlPercentEncoding())"
    }
}

public struct UpdateEvaluationFormInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// A flag indicating whether the operation must create a new version.
    public var createNewVersion: Swift.Bool?
    /// The description of the evaluation form.
    public var description: Swift.String?
    /// The unique identifier for the evaluation form.
    /// This member is required.
    public var evaluationFormId: Swift.String?
    /// A version of the evaluation form to update.
    /// This member is required.
    public var evaluationFormVersion: Swift.Int?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Items that are part of the evaluation form. The total number of sections and questions must not exceed 100 each. Questions must be contained in a section.
    /// This member is required.
    public var items: [ConnectClientTypes.EvaluationFormItem]?
    /// A scoring strategy of the evaluation form.
    public var scoringStrategy: ConnectClientTypes.EvaluationFormScoringStrategy?
    /// A title of the evaluation form.
    /// This member is required.
    public var title: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        createNewVersion: Swift.Bool? = nil,
        description: Swift.String? = nil,
        evaluationFormId: Swift.String? = nil,
        evaluationFormVersion: Swift.Int? = nil,
        instanceId: Swift.String? = nil,
        items: [ConnectClientTypes.EvaluationFormItem]? = nil,
        scoringStrategy: ConnectClientTypes.EvaluationFormScoringStrategy? = nil,
        title: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.createNewVersion = createNewVersion
        self.description = description
        self.evaluationFormId = evaluationFormId
        self.evaluationFormVersion = evaluationFormVersion
        self.instanceId = instanceId
        self.items = items
        self.scoringStrategy = scoringStrategy
        self.title = title
    }
}

struct UpdateEvaluationFormInputBody: Swift.Equatable {
    let evaluationFormVersion: Swift.Int?
    let createNewVersion: Swift.Bool?
    let title: Swift.String?
    let description: Swift.String?
    let items: [ConnectClientTypes.EvaluationFormItem]?
    let scoringStrategy: ConnectClientTypes.EvaluationFormScoringStrategy?
    let clientToken: Swift.String?
}

extension UpdateEvaluationFormInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case createNewVersion = "CreateNewVersion"
        case description = "Description"
        case evaluationFormVersion = "EvaluationFormVersion"
        case items = "Items"
        case scoringStrategy = "ScoringStrategy"
        case title = "Title"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationFormVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .evaluationFormVersion)
        evaluationFormVersion = evaluationFormVersionDecoded
        let createNewVersionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createNewVersion)
        createNewVersion = createNewVersionDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let itemsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.EvaluationFormItem?].self, forKey: .items)
        var itemsDecoded0:[ConnectClientTypes.EvaluationFormItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ConnectClientTypes.EvaluationFormItem]()
            for union0 in itemsContainer {
                if let union0 = union0 {
                    itemsDecoded0?.append(union0)
                }
            }
        }
        items = itemsDecoded0
        let scoringStrategyDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.EvaluationFormScoringStrategy.self, forKey: .scoringStrategy)
        scoringStrategy = scoringStrategyDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateEvaluationFormOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateEvaluationFormOutputBody = try responseDecoder.decode(responseBody: data)
            self.evaluationFormArn = output.evaluationFormArn
            self.evaluationFormId = output.evaluationFormId
            self.evaluationFormVersion = output.evaluationFormVersion
        } else {
            self.evaluationFormArn = nil
            self.evaluationFormId = nil
            self.evaluationFormVersion = 0
        }
    }
}

public struct UpdateEvaluationFormOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the contact evaluation resource.
    /// This member is required.
    public var evaluationFormArn: Swift.String?
    /// The unique identifier for the evaluation form.
    /// This member is required.
    public var evaluationFormId: Swift.String?
    /// The version of the updated evaluation form resource.
    /// This member is required.
    public var evaluationFormVersion: Swift.Int

    public init(
        evaluationFormArn: Swift.String? = nil,
        evaluationFormId: Swift.String? = nil,
        evaluationFormVersion: Swift.Int = 0
    )
    {
        self.evaluationFormArn = evaluationFormArn
        self.evaluationFormId = evaluationFormId
        self.evaluationFormVersion = evaluationFormVersion
    }
}

struct UpdateEvaluationFormOutputBody: Swift.Equatable {
    let evaluationFormId: Swift.String?
    let evaluationFormArn: Swift.String?
    let evaluationFormVersion: Swift.Int
}

extension UpdateEvaluationFormOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationFormArn = "EvaluationFormArn"
        case evaluationFormId = "EvaluationFormId"
        case evaluationFormVersion = "EvaluationFormVersion"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationFormIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationFormId)
        evaluationFormId = evaluationFormIdDecoded
        let evaluationFormArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationFormArn)
        evaluationFormArn = evaluationFormArnDecoded
        let evaluationFormVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .evaluationFormVersion) ?? 0
        evaluationFormVersion = evaluationFormVersionDecoded
    }
}

enum UpdateEvaluationFormOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateHoursOfOperationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case config = "Config"
        case description = "Description"
        case name = "Name"
        case timeZone = "TimeZone"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let config = config {
            var configContainer = encodeContainer.nestedUnkeyedContainer(forKey: .config)
            for hoursofoperationconfig0 in config {
                try configContainer.encode(hoursofoperationconfig0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let timeZone = self.timeZone {
            try encodeContainer.encode(timeZone, forKey: .timeZone)
        }
    }
}

extension UpdateHoursOfOperationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let hoursOfOperationId = hoursOfOperationId else {
            return nil
        }
        return "/hours-of-operations/\(instanceId.urlPercentEncoding())/\(hoursOfOperationId.urlPercentEncoding())"
    }
}

public struct UpdateHoursOfOperationInput: Swift.Equatable {
    /// Configuration information of the hours of operation.
    public var config: [ConnectClientTypes.HoursOfOperationConfig]?
    /// The description of the hours of operation.
    public var description: Swift.String?
    /// The identifier of the hours of operation.
    /// This member is required.
    public var hoursOfOperationId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the hours of operation.
    public var name: Swift.String?
    /// The time zone of the hours of operation.
    public var timeZone: Swift.String?

    public init(
        config: [ConnectClientTypes.HoursOfOperationConfig]? = nil,
        description: Swift.String? = nil,
        hoursOfOperationId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        timeZone: Swift.String? = nil
    )
    {
        self.config = config
        self.description = description
        self.hoursOfOperationId = hoursOfOperationId
        self.instanceId = instanceId
        self.name = name
        self.timeZone = timeZone
    }
}

struct UpdateHoursOfOperationInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let timeZone: Swift.String?
    let config: [ConnectClientTypes.HoursOfOperationConfig]?
}

extension UpdateHoursOfOperationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case config = "Config"
        case description = "Description"
        case name = "Name"
        case timeZone = "TimeZone"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let timeZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeZone)
        timeZone = timeZoneDecoded
        let configContainer = try containerValues.decodeIfPresent([ConnectClientTypes.HoursOfOperationConfig?].self, forKey: .config)
        var configDecoded0:[ConnectClientTypes.HoursOfOperationConfig]? = nil
        if let configContainer = configContainer {
            configDecoded0 = [ConnectClientTypes.HoursOfOperationConfig]()
            for structure0 in configContainer {
                if let structure0 = structure0 {
                    configDecoded0?.append(structure0)
                }
            }
        }
        config = configDecoded0
    }
}

extension UpdateHoursOfOperationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateHoursOfOperationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateHoursOfOperationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DuplicateResourceException": return try await DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateInstanceAttributeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }
}

extension UpdateInstanceAttributeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let attributeType = attributeType else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/attribute/\(attributeType.rawValue.urlPercentEncoding())"
    }
}

public struct UpdateInstanceAttributeInput: Swift.Equatable {
    /// The type of attribute. Only allowlisted customers can consume USE_CUSTOM_TTS_VOICES. To access this feature, contact Amazon Web Services Support for allowlisting.
    /// This member is required.
    public var attributeType: ConnectClientTypes.InstanceAttributeType?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The value for the attribute. Maximum character limit is 100.
    /// This member is required.
    public var value: Swift.String?

    public init(
        attributeType: ConnectClientTypes.InstanceAttributeType? = nil,
        instanceId: Swift.String? = nil,
        value: Swift.String? = nil
    )
    {
        self.attributeType = attributeType
        self.instanceId = instanceId
        self.value = value
    }
}

struct UpdateInstanceAttributeInputBody: Swift.Equatable {
    let value: Swift.String?
}

extension UpdateInstanceAttributeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case value = "Value"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension UpdateInstanceAttributeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateInstanceAttributeOutput: Swift.Equatable {

    public init() { }
}

enum UpdateInstanceAttributeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateInstanceStorageConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case storageConfig = "StorageConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let storageConfig = self.storageConfig {
            try encodeContainer.encode(storageConfig, forKey: .storageConfig)
        }
    }
}

extension UpdateInstanceStorageConfigInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceType = resourceType else {
                let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
            return items
        }
    }
}

extension UpdateInstanceStorageConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let associationId = associationId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/storage-config/\(associationId.urlPercentEncoding())"
    }
}

public struct UpdateInstanceStorageConfigInput: Swift.Equatable {
    /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
    /// This member is required.
    public var associationId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A valid resource type.
    /// This member is required.
    public var resourceType: ConnectClientTypes.InstanceStorageResourceType?
    /// The storage configuration for the instance.
    /// This member is required.
    public var storageConfig: ConnectClientTypes.InstanceStorageConfig?

    public init(
        associationId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        resourceType: ConnectClientTypes.InstanceStorageResourceType? = nil,
        storageConfig: ConnectClientTypes.InstanceStorageConfig? = nil
    )
    {
        self.associationId = associationId
        self.instanceId = instanceId
        self.resourceType = resourceType
        self.storageConfig = storageConfig
    }
}

struct UpdateInstanceStorageConfigInputBody: Swift.Equatable {
    let storageConfig: ConnectClientTypes.InstanceStorageConfig?
}

extension UpdateInstanceStorageConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case storageConfig = "StorageConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.InstanceStorageConfig.self, forKey: .storageConfig)
        storageConfig = storageConfigDecoded
    }
}

extension UpdateInstanceStorageConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateInstanceStorageConfigOutput: Swift.Equatable {

    public init() { }
}

enum UpdateInstanceStorageConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectClientTypes.UpdateParticipantRoleConfigChannelInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chat = "Chat"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .chat(chat):
                try container.encode(chat, forKey: .chat)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let chatDecoded = try values.decodeIfPresent(ConnectClientTypes.ChatParticipantRoleConfig.self, forKey: .chat)
        if let chat = chatDecoded {
            self = .chat(chat)
            return
        }
        self = .sdkUnknown("")
    }
}

extension ConnectClientTypes {
    /// Configuration information for the chat participant role.
    public enum UpdateParticipantRoleConfigChannelInfo: Swift.Equatable {
        /// Configuration information for the chat participant role.
        case chat(ConnectClientTypes.ChatParticipantRoleConfig)
        case sdkUnknown(Swift.String)
    }

}

extension UpdateParticipantRoleConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelConfiguration = "ChannelConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelConfiguration = self.channelConfiguration {
            try encodeContainer.encode(channelConfiguration, forKey: .channelConfiguration)
        }
    }
}

extension UpdateParticipantRoleConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let contactId = contactId else {
            return nil
        }
        return "/contact/participant-role-config/\(instanceId.urlPercentEncoding())/\(contactId.urlPercentEncoding())"
    }
}

public struct UpdateParticipantRoleConfigInput: Swift.Equatable {
    /// The Amazon Connect channel you want to configure.
    /// This member is required.
    public var channelConfiguration: ConnectClientTypes.UpdateParticipantRoleConfigChannelInfo?
    /// The identifier of the contact in this instance of Amazon Connect.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        channelConfiguration: ConnectClientTypes.UpdateParticipantRoleConfigChannelInfo? = nil,
        contactId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.channelConfiguration = channelConfiguration
        self.contactId = contactId
        self.instanceId = instanceId
    }
}

struct UpdateParticipantRoleConfigInputBody: Swift.Equatable {
    let channelConfiguration: ConnectClientTypes.UpdateParticipantRoleConfigChannelInfo?
}

extension UpdateParticipantRoleConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelConfiguration = "ChannelConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelConfigurationDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.UpdateParticipantRoleConfigChannelInfo.self, forKey: .channelConfiguration)
        channelConfiguration = channelConfigurationDecoded
    }
}

extension UpdateParticipantRoleConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateParticipantRoleConfigOutput: Swift.Equatable {

    public init() { }
}

enum UpdateParticipantRoleConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePhoneNumberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case instanceId = "InstanceId"
        case targetArn = "TargetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let targetArn = self.targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }
}

extension UpdatePhoneNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let phoneNumberId = phoneNumberId else {
            return nil
        }
        return "/phone-number/\(phoneNumberId.urlPercentEncoding())"
    }
}

public struct UpdatePhoneNumberInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The identifier of the Amazon Connect instance that phone numbers are claimed to. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance. You must enter InstanceId or TargetArn.
    public var instanceId: Swift.String?
    /// A unique identifier for the phone number.
    /// This member is required.
    public var phoneNumberId: Swift.String?
    /// The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone number inbound traffic is routed through. You must enter InstanceId or TargetArn.
    public var targetArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        phoneNumberId: Swift.String? = nil,
        targetArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.instanceId = instanceId
        self.phoneNumberId = phoneNumberId
        self.targetArn = targetArn
    }
}

struct UpdatePhoneNumberInputBody: Swift.Equatable {
    let targetArn: Swift.String?
    let instanceId: Swift.String?
    let clientToken: Swift.String?
}

extension UpdatePhoneNumberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case instanceId = "InstanceId"
        case targetArn = "TargetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdatePhoneNumberMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case phoneNumberDescription = "PhoneNumberDescription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let phoneNumberDescription = self.phoneNumberDescription {
            try encodeContainer.encode(phoneNumberDescription, forKey: .phoneNumberDescription)
        }
    }
}

extension UpdatePhoneNumberMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let phoneNumberId = phoneNumberId else {
            return nil
        }
        return "/phone-number/\(phoneNumberId.urlPercentEncoding())/metadata"
    }
}

public struct UpdatePhoneNumberMetadataInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The description of the phone number.
    public var phoneNumberDescription: Swift.String?
    /// The Amazon Resource Name (ARN) or resource ID of the phone number.
    /// This member is required.
    public var phoneNumberId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        phoneNumberDescription: Swift.String? = nil,
        phoneNumberId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.phoneNumberDescription = phoneNumberDescription
        self.phoneNumberId = phoneNumberId
    }
}

struct UpdatePhoneNumberMetadataInputBody: Swift.Equatable {
    let phoneNumberDescription: Swift.String?
    let clientToken: Swift.String?
}

extension UpdatePhoneNumberMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case phoneNumberDescription = "PhoneNumberDescription"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberDescription)
        phoneNumberDescription = phoneNumberDescriptionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdatePhoneNumberMetadataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdatePhoneNumberMetadataOutput: Swift.Equatable {

    public init() { }
}

enum UpdatePhoneNumberMetadataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IdempotencyException": return try await IdempotencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePhoneNumberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdatePhoneNumberOutputBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberArn = output.phoneNumberArn
            self.phoneNumberId = output.phoneNumberId
        } else {
            self.phoneNumberArn = nil
            self.phoneNumberId = nil
        }
    }
}

public struct UpdatePhoneNumberOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the phone number.
    public var phoneNumberArn: Swift.String?
    /// A unique identifier for the phone number.
    public var phoneNumberId: Swift.String?

    public init(
        phoneNumberArn: Swift.String? = nil,
        phoneNumberId: Swift.String? = nil
    )
    {
        self.phoneNumberArn = phoneNumberArn
        self.phoneNumberId = phoneNumberId
    }
}

struct UpdatePhoneNumberOutputBody: Swift.Equatable {
    let phoneNumberId: Swift.String?
    let phoneNumberArn: Swift.String?
}

extension UpdatePhoneNumberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberArn = "PhoneNumberArn"
        case phoneNumberId = "PhoneNumberId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberId)
        phoneNumberId = phoneNumberIdDecoded
        let phoneNumberArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberArn)
        phoneNumberArn = phoneNumberArnDecoded
    }
}

enum UpdatePhoneNumberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IdempotencyException": return try await IdempotencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePromptInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case s3Uri = "S3Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let s3Uri = self.s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }
}

extension UpdatePromptInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let promptId = promptId else {
            return nil
        }
        return "/prompts/\(instanceId.urlPercentEncoding())/\(promptId.urlPercentEncoding())"
    }
}

public struct UpdatePromptInput: Swift.Equatable {
    /// A description of the prompt.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the prompt.
    public var name: Swift.String?
    /// A unique identifier for the prompt.
    /// This member is required.
    public var promptId: Swift.String?
    /// The URI for the S3 bucket where the prompt is stored. You can provide S3 pre-signed URLs returned by the [GetPromptFile](https://docs.aws.amazon.com/connect/latest/APIReference/API_GetPromptFile.html) API instead of providing S3 URIs.
    public var s3Uri: Swift.String?

    public init(
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        promptId: Swift.String? = nil,
        s3Uri: Swift.String? = nil
    )
    {
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.promptId = promptId
        self.s3Uri = s3Uri
    }
}

struct UpdatePromptInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let s3Uri: Swift.String?
}

extension UpdatePromptInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case s3Uri = "S3Uri"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let s3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
    }
}

extension UpdatePromptOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdatePromptOutputBody = try responseDecoder.decode(responseBody: data)
            self.promptARN = output.promptARN
            self.promptId = output.promptId
        } else {
            self.promptARN = nil
            self.promptId = nil
        }
    }
}

public struct UpdatePromptOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the prompt.
    public var promptARN: Swift.String?
    /// A unique identifier for the prompt.
    public var promptId: Swift.String?

    public init(
        promptARN: Swift.String? = nil,
        promptId: Swift.String? = nil
    )
    {
        self.promptARN = promptARN
        self.promptId = promptId
    }
}

struct UpdatePromptOutputBody: Swift.Equatable {
    let promptARN: Swift.String?
    let promptId: Swift.String?
}

extension UpdatePromptOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case promptARN = "PromptARN"
        case promptId = "PromptId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let promptARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .promptARN)
        promptARN = promptARNDecoded
        let promptIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .promptId)
        promptId = promptIdDecoded
    }
}

enum UpdatePromptOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateQueueHoursOfOperationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hoursOfOperationId = "HoursOfOperationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hoursOfOperationId = self.hoursOfOperationId {
            try encodeContainer.encode(hoursOfOperationId, forKey: .hoursOfOperationId)
        }
    }
}

extension UpdateQueueHoursOfOperationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let queueId = queueId else {
            return nil
        }
        return "/queues/\(instanceId.urlPercentEncoding())/\(queueId.urlPercentEncoding())/hours-of-operation"
    }
}

public struct UpdateQueueHoursOfOperationInput: Swift.Equatable {
    /// The identifier for the hours of operation.
    /// This member is required.
    public var hoursOfOperationId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the queue.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        hoursOfOperationId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.hoursOfOperationId = hoursOfOperationId
        self.instanceId = instanceId
        self.queueId = queueId
    }
}

struct UpdateQueueHoursOfOperationInputBody: Swift.Equatable {
    let hoursOfOperationId: Swift.String?
}

extension UpdateQueueHoursOfOperationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hoursOfOperationId = "HoursOfOperationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hoursOfOperationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hoursOfOperationId)
        hoursOfOperationId = hoursOfOperationIdDecoded
    }
}

extension UpdateQueueHoursOfOperationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateQueueHoursOfOperationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateQueueHoursOfOperationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateQueueMaxContactsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxContacts = "MaxContacts"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxContacts = self.maxContacts {
            try encodeContainer.encode(maxContacts, forKey: .maxContacts)
        }
    }
}

extension UpdateQueueMaxContactsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let queueId = queueId else {
            return nil
        }
        return "/queues/\(instanceId.urlPercentEncoding())/\(queueId.urlPercentEncoding())/max-contacts"
    }
}

public struct UpdateQueueMaxContactsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of contacts that can be in the queue before it is considered full.
    public var maxContacts: Swift.Int?
    /// The identifier for the queue.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxContacts: Swift.Int? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxContacts = maxContacts
        self.queueId = queueId
    }
}

struct UpdateQueueMaxContactsInputBody: Swift.Equatable {
    let maxContacts: Swift.Int?
}

extension UpdateQueueMaxContactsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxContacts = "MaxContacts"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxContactsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxContacts)
        maxContacts = maxContactsDecoded
    }
}

extension UpdateQueueMaxContactsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateQueueMaxContactsOutput: Swift.Equatable {

    public init() { }
}

enum UpdateQueueMaxContactsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateQueueNameInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateQueueNameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let queueId = queueId else {
            return nil
        }
        return "/queues/\(instanceId.urlPercentEncoding())/\(queueId.urlPercentEncoding())/name"
    }
}

public struct UpdateQueueNameInput: Swift.Equatable {
    /// The description of the queue.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the queue.
    public var name: Swift.String?
    /// The identifier for the queue.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.queueId = queueId
    }
}

struct UpdateQueueNameInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
}

extension UpdateQueueNameInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateQueueNameOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateQueueNameOutput: Swift.Equatable {

    public init() { }
}

enum UpdateQueueNameOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DuplicateResourceException": return try await DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateQueueOutboundCallerConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outboundCallerConfig = "OutboundCallerConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outboundCallerConfig = self.outboundCallerConfig {
            try encodeContainer.encode(outboundCallerConfig, forKey: .outboundCallerConfig)
        }
    }
}

extension UpdateQueueOutboundCallerConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let queueId = queueId else {
            return nil
        }
        return "/queues/\(instanceId.urlPercentEncoding())/\(queueId.urlPercentEncoding())/outbound-caller-config"
    }
}

public struct UpdateQueueOutboundCallerConfigInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The outbound caller ID name, number, and outbound whisper flow.
    /// This member is required.
    public var outboundCallerConfig: ConnectClientTypes.OutboundCallerConfig?
    /// The identifier for the queue.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        outboundCallerConfig: ConnectClientTypes.OutboundCallerConfig? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.outboundCallerConfig = outboundCallerConfig
        self.queueId = queueId
    }
}

struct UpdateQueueOutboundCallerConfigInputBody: Swift.Equatable {
    let outboundCallerConfig: ConnectClientTypes.OutboundCallerConfig?
}

extension UpdateQueueOutboundCallerConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outboundCallerConfig = "OutboundCallerConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outboundCallerConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.OutboundCallerConfig.self, forKey: .outboundCallerConfig)
        outboundCallerConfig = outboundCallerConfigDecoded
    }
}

extension UpdateQueueOutboundCallerConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateQueueOutboundCallerConfigOutput: Swift.Equatable {

    public init() { }
}

enum UpdateQueueOutboundCallerConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateQueueStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension UpdateQueueStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let queueId = queueId else {
            return nil
        }
        return "/queues/\(instanceId.urlPercentEncoding())/\(queueId.urlPercentEncoding())/status"
    }
}

public struct UpdateQueueStatusInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the queue.
    /// This member is required.
    public var queueId: Swift.String?
    /// The status of the queue.
    /// This member is required.
    public var status: ConnectClientTypes.QueueStatus?

    public init(
        instanceId: Swift.String? = nil,
        queueId: Swift.String? = nil,
        status: ConnectClientTypes.QueueStatus? = nil
    )
    {
        self.instanceId = instanceId
        self.queueId = queueId
        self.status = status
    }
}

struct UpdateQueueStatusInputBody: Swift.Equatable {
    let status: ConnectClientTypes.QueueStatus?
}

extension UpdateQueueStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.QueueStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateQueueStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateQueueStatusOutput: Swift.Equatable {

    public init() { }
}

enum UpdateQueueStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateQuickConnectConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quickConnectConfig = "QuickConnectConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let quickConnectConfig = self.quickConnectConfig {
            try encodeContainer.encode(quickConnectConfig, forKey: .quickConnectConfig)
        }
    }
}

extension UpdateQuickConnectConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let quickConnectId = quickConnectId else {
            return nil
        }
        return "/quick-connects/\(instanceId.urlPercentEncoding())/\(quickConnectId.urlPercentEncoding())/config"
    }
}

public struct UpdateQuickConnectConfigInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Information about the configuration settings for the quick connect.
    /// This member is required.
    public var quickConnectConfig: ConnectClientTypes.QuickConnectConfig?
    /// The identifier for the quick connect.
    /// This member is required.
    public var quickConnectId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        quickConnectConfig: ConnectClientTypes.QuickConnectConfig? = nil,
        quickConnectId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.quickConnectConfig = quickConnectConfig
        self.quickConnectId = quickConnectId
    }
}

struct UpdateQuickConnectConfigInputBody: Swift.Equatable {
    let quickConnectConfig: ConnectClientTypes.QuickConnectConfig?
}

extension UpdateQuickConnectConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quickConnectConfig = "QuickConnectConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quickConnectConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.QuickConnectConfig.self, forKey: .quickConnectConfig)
        quickConnectConfig = quickConnectConfigDecoded
    }
}

extension UpdateQuickConnectConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateQuickConnectConfigOutput: Swift.Equatable {

    public init() { }
}

enum UpdateQuickConnectConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateQuickConnectNameInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateQuickConnectNameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let quickConnectId = quickConnectId else {
            return nil
        }
        return "/quick-connects/\(instanceId.urlPercentEncoding())/\(quickConnectId.urlPercentEncoding())/name"
    }
}

public struct UpdateQuickConnectNameInput: Swift.Equatable {
    /// The description of the quick connect.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the quick connect.
    public var name: Swift.String?
    /// The identifier for the quick connect.
    /// This member is required.
    public var quickConnectId: Swift.String?

    public init(
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        quickConnectId: Swift.String? = nil
    )
    {
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.quickConnectId = quickConnectId
    }
}

struct UpdateQuickConnectNameInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
}

extension UpdateQuickConnectNameInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateQuickConnectNameOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateQuickConnectNameOutput: Swift.Equatable {

    public init() { }
}

enum UpdateQuickConnectNameOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRoutingProfileAgentAvailabilityTimerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentAvailabilityTimer = "AgentAvailabilityTimer"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentAvailabilityTimer = self.agentAvailabilityTimer {
            try encodeContainer.encode(agentAvailabilityTimer.rawValue, forKey: .agentAvailabilityTimer)
        }
    }
}

extension UpdateRoutingProfileAgentAvailabilityTimerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let routingProfileId = routingProfileId else {
            return nil
        }
        return "/routing-profiles/\(instanceId.urlPercentEncoding())/\(routingProfileId.urlPercentEncoding())/agent-availability-timer"
    }
}

public struct UpdateRoutingProfileAgentAvailabilityTimerInput: Swift.Equatable {
    /// Whether agents with this routing profile will have their routing order calculated based on time since their last inbound contact or longest idle time.
    /// This member is required.
    public var agentAvailabilityTimer: ConnectClientTypes.AgentAvailabilityTimer?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the routing profile.
    /// This member is required.
    public var routingProfileId: Swift.String?

    public init(
        agentAvailabilityTimer: ConnectClientTypes.AgentAvailabilityTimer? = nil,
        instanceId: Swift.String? = nil,
        routingProfileId: Swift.String? = nil
    )
    {
        self.agentAvailabilityTimer = agentAvailabilityTimer
        self.instanceId = instanceId
        self.routingProfileId = routingProfileId
    }
}

struct UpdateRoutingProfileAgentAvailabilityTimerInputBody: Swift.Equatable {
    let agentAvailabilityTimer: ConnectClientTypes.AgentAvailabilityTimer?
}

extension UpdateRoutingProfileAgentAvailabilityTimerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentAvailabilityTimer = "AgentAvailabilityTimer"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentAvailabilityTimerDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.AgentAvailabilityTimer.self, forKey: .agentAvailabilityTimer)
        agentAvailabilityTimer = agentAvailabilityTimerDecoded
    }
}

extension UpdateRoutingProfileAgentAvailabilityTimerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateRoutingProfileAgentAvailabilityTimerOutput: Swift.Equatable {

    public init() { }
}

enum UpdateRoutingProfileAgentAvailabilityTimerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRoutingProfileConcurrencyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaConcurrencies = "MediaConcurrencies"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mediaConcurrencies = mediaConcurrencies {
            var mediaConcurrenciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mediaConcurrencies)
            for mediaconcurrency0 in mediaConcurrencies {
                try mediaConcurrenciesContainer.encode(mediaconcurrency0)
            }
        }
    }
}

extension UpdateRoutingProfileConcurrencyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let routingProfileId = routingProfileId else {
            return nil
        }
        return "/routing-profiles/\(instanceId.urlPercentEncoding())/\(routingProfileId.urlPercentEncoding())/concurrency"
    }
}

public struct UpdateRoutingProfileConcurrencyInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The channels that agents can handle in the Contact Control Panel (CCP).
    /// This member is required.
    public var mediaConcurrencies: [ConnectClientTypes.MediaConcurrency]?
    /// The identifier of the routing profile.
    /// This member is required.
    public var routingProfileId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        mediaConcurrencies: [ConnectClientTypes.MediaConcurrency]? = nil,
        routingProfileId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.mediaConcurrencies = mediaConcurrencies
        self.routingProfileId = routingProfileId
    }
}

struct UpdateRoutingProfileConcurrencyInputBody: Swift.Equatable {
    let mediaConcurrencies: [ConnectClientTypes.MediaConcurrency]?
}

extension UpdateRoutingProfileConcurrencyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaConcurrencies = "MediaConcurrencies"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaConcurrenciesContainer = try containerValues.decodeIfPresent([ConnectClientTypes.MediaConcurrency?].self, forKey: .mediaConcurrencies)
        var mediaConcurrenciesDecoded0:[ConnectClientTypes.MediaConcurrency]? = nil
        if let mediaConcurrenciesContainer = mediaConcurrenciesContainer {
            mediaConcurrenciesDecoded0 = [ConnectClientTypes.MediaConcurrency]()
            for structure0 in mediaConcurrenciesContainer {
                if let structure0 = structure0 {
                    mediaConcurrenciesDecoded0?.append(structure0)
                }
            }
        }
        mediaConcurrencies = mediaConcurrenciesDecoded0
    }
}

extension UpdateRoutingProfileConcurrencyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateRoutingProfileConcurrencyOutput: Swift.Equatable {

    public init() { }
}

enum UpdateRoutingProfileConcurrencyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRoutingProfileDefaultOutboundQueueInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultOutboundQueueId = "DefaultOutboundQueueId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultOutboundQueueId = self.defaultOutboundQueueId {
            try encodeContainer.encode(defaultOutboundQueueId, forKey: .defaultOutboundQueueId)
        }
    }
}

extension UpdateRoutingProfileDefaultOutboundQueueInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let routingProfileId = routingProfileId else {
            return nil
        }
        return "/routing-profiles/\(instanceId.urlPercentEncoding())/\(routingProfileId.urlPercentEncoding())/default-outbound-queue"
    }
}

public struct UpdateRoutingProfileDefaultOutboundQueueInput: Swift.Equatable {
    /// The identifier for the default outbound queue.
    /// This member is required.
    public var defaultOutboundQueueId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the routing profile.
    /// This member is required.
    public var routingProfileId: Swift.String?

    public init(
        defaultOutboundQueueId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        routingProfileId: Swift.String? = nil
    )
    {
        self.defaultOutboundQueueId = defaultOutboundQueueId
        self.instanceId = instanceId
        self.routingProfileId = routingProfileId
    }
}

struct UpdateRoutingProfileDefaultOutboundQueueInputBody: Swift.Equatable {
    let defaultOutboundQueueId: Swift.String?
}

extension UpdateRoutingProfileDefaultOutboundQueueInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultOutboundQueueId = "DefaultOutboundQueueId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultOutboundQueueIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultOutboundQueueId)
        defaultOutboundQueueId = defaultOutboundQueueIdDecoded
    }
}

extension UpdateRoutingProfileDefaultOutboundQueueOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateRoutingProfileDefaultOutboundQueueOutput: Swift.Equatable {

    public init() { }
}

enum UpdateRoutingProfileDefaultOutboundQueueOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRoutingProfileNameInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateRoutingProfileNameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let routingProfileId = routingProfileId else {
            return nil
        }
        return "/routing-profiles/\(instanceId.urlPercentEncoding())/\(routingProfileId.urlPercentEncoding())/name"
    }
}

public struct UpdateRoutingProfileNameInput: Swift.Equatable {
    /// The description of the routing profile. Must not be more than 250 characters.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the routing profile. Must not be more than 127 characters.
    public var name: Swift.String?
    /// The identifier of the routing profile.
    /// This member is required.
    public var routingProfileId: Swift.String?

    public init(
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        routingProfileId: Swift.String? = nil
    )
    {
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.routingProfileId = routingProfileId
    }
}

struct UpdateRoutingProfileNameInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
}

extension UpdateRoutingProfileNameInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateRoutingProfileNameOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateRoutingProfileNameOutput: Swift.Equatable {

    public init() { }
}

enum UpdateRoutingProfileNameOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DuplicateResourceException": return try await DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRoutingProfileQueuesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queueConfigs = "QueueConfigs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queueConfigs = queueConfigs {
            var queueConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queueConfigs)
            for routingprofilequeueconfig0 in queueConfigs {
                try queueConfigsContainer.encode(routingprofilequeueconfig0)
            }
        }
    }
}

extension UpdateRoutingProfileQueuesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let routingProfileId = routingProfileId else {
            return nil
        }
        return "/routing-profiles/\(instanceId.urlPercentEncoding())/\(routingProfileId.urlPercentEncoding())/queues"
    }
}

public struct UpdateRoutingProfileQueuesInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The queues to be updated for this routing profile. Queues must first be associated to the routing profile. You can do this using AssociateRoutingProfileQueues.
    /// This member is required.
    public var queueConfigs: [ConnectClientTypes.RoutingProfileQueueConfig]?
    /// The identifier of the routing profile.
    /// This member is required.
    public var routingProfileId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        queueConfigs: [ConnectClientTypes.RoutingProfileQueueConfig]? = nil,
        routingProfileId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.queueConfigs = queueConfigs
        self.routingProfileId = routingProfileId
    }
}

struct UpdateRoutingProfileQueuesInputBody: Swift.Equatable {
    let queueConfigs: [ConnectClientTypes.RoutingProfileQueueConfig]?
}

extension UpdateRoutingProfileQueuesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queueConfigs = "QueueConfigs"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueConfigsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.RoutingProfileQueueConfig?].self, forKey: .queueConfigs)
        var queueConfigsDecoded0:[ConnectClientTypes.RoutingProfileQueueConfig]? = nil
        if let queueConfigsContainer = queueConfigsContainer {
            queueConfigsDecoded0 = [ConnectClientTypes.RoutingProfileQueueConfig]()
            for structure0 in queueConfigsContainer {
                if let structure0 = structure0 {
                    queueConfigsDecoded0?.append(structure0)
                }
            }
        }
        queueConfigs = queueConfigsDecoded0
    }
}

extension UpdateRoutingProfileQueuesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateRoutingProfileQueuesOutput: Swift.Equatable {

    public init() { }
}

enum UpdateRoutingProfileQueuesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case function = "Function"
        case name = "Name"
        case publishStatus = "PublishStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for ruleaction0 in actions {
                try actionsContainer.encode(ruleaction0)
            }
        }
        if let function = self.function {
            try encodeContainer.encode(function, forKey: .function)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let publishStatus = self.publishStatus {
            try encodeContainer.encode(publishStatus.rawValue, forKey: .publishStatus)
        }
    }
}

extension UpdateRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let ruleId = ruleId else {
            return nil
        }
        return "/rules/\(instanceId.urlPercentEncoding())/\(ruleId.urlPercentEncoding())"
    }
}

public struct UpdateRuleInput: Swift.Equatable {
    /// A list of actions to be run when the rule is triggered.
    /// This member is required.
    public var actions: [ConnectClientTypes.RuleAction]?
    /// The conditions of the rule.
    /// This member is required.
    public var function: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the rule. You can change the name only if TriggerEventSource is one of the following values: OnZendeskTicketCreate | OnZendeskTicketStatusUpdate | OnSalesforceCaseCreate
    /// This member is required.
    public var name: Swift.String?
    /// The publish status of the rule.
    /// This member is required.
    public var publishStatus: ConnectClientTypes.RulePublishStatus?
    /// A unique identifier for the rule.
    /// This member is required.
    public var ruleId: Swift.String?

    public init(
        actions: [ConnectClientTypes.RuleAction]? = nil,
        function: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        publishStatus: ConnectClientTypes.RulePublishStatus? = nil,
        ruleId: Swift.String? = nil
    )
    {
        self.actions = actions
        self.function = function
        self.instanceId = instanceId
        self.name = name
        self.publishStatus = publishStatus
        self.ruleId = ruleId
    }
}

struct UpdateRuleInputBody: Swift.Equatable {
    let name: Swift.String?
    let function: Swift.String?
    let actions: [ConnectClientTypes.RuleAction]?
    let publishStatus: ConnectClientTypes.RulePublishStatus?
}

extension UpdateRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case function = "Function"
        case name = "Name"
        case publishStatus = "PublishStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let functionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .function)
        function = functionDecoded
        let actionsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.RuleAction?].self, forKey: .actions)
        var actionsDecoded0:[ConnectClientTypes.RuleAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [ConnectClientTypes.RuleAction]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let publishStatusDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.RulePublishStatus.self, forKey: .publishStatus)
        publishStatus = publishStatusDecoded
    }
}

extension UpdateRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateRuleOutput: Swift.Equatable {

    public init() { }
}

enum UpdateRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSecurityProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedAccessControlTags = "AllowedAccessControlTags"
        case applications = "Applications"
        case description = "Description"
        case permissions = "Permissions"
        case tagRestrictedResources = "TagRestrictedResources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedAccessControlTags = allowedAccessControlTags {
            var allowedAccessControlTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .allowedAccessControlTags)
            for (dictKey0, allowedAccessControlTags0) in allowedAccessControlTags {
                try allowedAccessControlTagsContainer.encode(allowedAccessControlTags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let applications = applications {
            var applicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applications)
            for application0 in applications {
                try applicationsContainer.encode(application0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for securityprofilepermission0 in permissions {
                try permissionsContainer.encode(securityprofilepermission0)
            }
        }
        if let tagRestrictedResources = tagRestrictedResources {
            var tagRestrictedResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagRestrictedResources)
            for tagrestrictedresourcename0 in tagRestrictedResources {
                try tagRestrictedResourcesContainer.encode(tagrestrictedresourcename0)
            }
        }
    }
}

extension UpdateSecurityProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let securityProfileId = securityProfileId else {
            return nil
        }
        return "/security-profiles/\(instanceId.urlPercentEncoding())/\(securityProfileId.urlPercentEncoding())"
    }
}

public struct UpdateSecurityProfileInput: Swift.Equatable {
    /// The list of tags that a security profile uses to restrict access to resources in Amazon Connect.
    public var allowedAccessControlTags: [Swift.String:Swift.String]?
    /// This API is in preview release for Amazon Connect and is subject to change. A list of the third-party application's metadata.
    public var applications: [ConnectClientTypes.Application]?
    /// The description of the security profile.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The permissions granted to a security profile. For a list of valid permissions, see [List of security profile permissions](https://docs.aws.amazon.com/connect/latest/adminguide/security-profile-list.html).
    public var permissions: [Swift.String]?
    /// The identifier for the security profle.
    /// This member is required.
    public var securityProfileId: Swift.String?
    /// The list of resources that a security profile applies tag restrictions to in Amazon Connect.
    public var tagRestrictedResources: [Swift.String]?

    public init(
        allowedAccessControlTags: [Swift.String:Swift.String]? = nil,
        applications: [ConnectClientTypes.Application]? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        permissions: [Swift.String]? = nil,
        securityProfileId: Swift.String? = nil,
        tagRestrictedResources: [Swift.String]? = nil
    )
    {
        self.allowedAccessControlTags = allowedAccessControlTags
        self.applications = applications
        self.description = description
        self.instanceId = instanceId
        self.permissions = permissions
        self.securityProfileId = securityProfileId
        self.tagRestrictedResources = tagRestrictedResources
    }
}

struct UpdateSecurityProfileInputBody: Swift.Equatable {
    let description: Swift.String?
    let permissions: [Swift.String]?
    let allowedAccessControlTags: [Swift.String:Swift.String]?
    let tagRestrictedResources: [Swift.String]?
    let applications: [ConnectClientTypes.Application]?
}

extension UpdateSecurityProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedAccessControlTags = "AllowedAccessControlTags"
        case applications = "Applications"
        case description = "Description"
        case permissions = "Permissions"
        case tagRestrictedResources = "TagRestrictedResources"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .permissions)
        var permissionsDecoded0:[Swift.String]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [Swift.String]()
            for string0 in permissionsContainer {
                if let string0 = string0 {
                    permissionsDecoded0?.append(string0)
                }
            }
        }
        permissions = permissionsDecoded0
        let allowedAccessControlTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .allowedAccessControlTags)
        var allowedAccessControlTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let allowedAccessControlTagsContainer = allowedAccessControlTagsContainer {
            allowedAccessControlTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, securityprofilepolicyvalue0) in allowedAccessControlTagsContainer {
                if let securityprofilepolicyvalue0 = securityprofilepolicyvalue0 {
                    allowedAccessControlTagsDecoded0?[key0] = securityprofilepolicyvalue0
                }
            }
        }
        allowedAccessControlTags = allowedAccessControlTagsDecoded0
        let tagRestrictedResourcesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagRestrictedResources)
        var tagRestrictedResourcesDecoded0:[Swift.String]? = nil
        if let tagRestrictedResourcesContainer = tagRestrictedResourcesContainer {
            tagRestrictedResourcesDecoded0 = [Swift.String]()
            for string0 in tagRestrictedResourcesContainer {
                if let string0 = string0 {
                    tagRestrictedResourcesDecoded0?.append(string0)
                }
            }
        }
        tagRestrictedResources = tagRestrictedResourcesDecoded0
        let applicationsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.Application?].self, forKey: .applications)
        var applicationsDecoded0:[ConnectClientTypes.Application]? = nil
        if let applicationsContainer = applicationsContainer {
            applicationsDecoded0 = [ConnectClientTypes.Application]()
            for structure0 in applicationsContainer {
                if let structure0 = structure0 {
                    applicationsDecoded0?.append(structure0)
                }
            }
        }
        applications = applicationsDecoded0
    }
}

extension UpdateSecurityProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateSecurityProfileOutput: Swift.Equatable {

    public init() { }
}

enum UpdateSecurityProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateTaskTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case constraints = "Constraints"
        case contactFlowId = "ContactFlowId"
        case defaults = "Defaults"
        case description = "Description"
        case fields = "Fields"
        case name = "Name"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let constraints = self.constraints {
            try encodeContainer.encode(constraints, forKey: .constraints)
        }
        if let contactFlowId = self.contactFlowId {
            try encodeContainer.encode(contactFlowId, forKey: .contactFlowId)
        }
        if let defaults = self.defaults {
            try encodeContainer.encode(defaults, forKey: .defaults)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let fields = fields {
            var fieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fields)
            for tasktemplatefield0 in fields {
                try fieldsContainer.encode(tasktemplatefield0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension UpdateTaskTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let taskTemplateId = taskTemplateId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/task/template/\(taskTemplateId.urlPercentEncoding())"
    }
}

public struct UpdateTaskTemplateInput: Swift.Equatable {
    /// Constraints that are applicable to the fields listed.
    public var constraints: ConnectClientTypes.TaskTemplateConstraints?
    /// The identifier of the flow that runs by default when a task is created by referencing this template.
    public var contactFlowId: Swift.String?
    /// The default values for fields when a task is created by referencing this template.
    public var defaults: ConnectClientTypes.TaskTemplateDefaults?
    /// The description of the task template.
    public var description: Swift.String?
    /// Fields that are part of the template.
    public var fields: [ConnectClientTypes.TaskTemplateField]?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the task template.
    public var name: Swift.String?
    /// Marks a template as ACTIVE or INACTIVE for a task to refer to it. Tasks can only be created from ACTIVE templates. If a template is marked as INACTIVE, then a task that refers to this template cannot be created.
    public var status: ConnectClientTypes.TaskTemplateStatus?
    /// A unique identifier for the task template.
    /// This member is required.
    public var taskTemplateId: Swift.String?

    public init(
        constraints: ConnectClientTypes.TaskTemplateConstraints? = nil,
        contactFlowId: Swift.String? = nil,
        defaults: ConnectClientTypes.TaskTemplateDefaults? = nil,
        description: Swift.String? = nil,
        fields: [ConnectClientTypes.TaskTemplateField]? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        status: ConnectClientTypes.TaskTemplateStatus? = nil,
        taskTemplateId: Swift.String? = nil
    )
    {
        self.constraints = constraints
        self.contactFlowId = contactFlowId
        self.defaults = defaults
        self.description = description
        self.fields = fields
        self.instanceId = instanceId
        self.name = name
        self.status = status
        self.taskTemplateId = taskTemplateId
    }
}

struct UpdateTaskTemplateInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let contactFlowId: Swift.String?
    let constraints: ConnectClientTypes.TaskTemplateConstraints?
    let defaults: ConnectClientTypes.TaskTemplateDefaults?
    let status: ConnectClientTypes.TaskTemplateStatus?
    let fields: [ConnectClientTypes.TaskTemplateField]?
}

extension UpdateTaskTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case constraints = "Constraints"
        case contactFlowId = "ContactFlowId"
        case defaults = "Defaults"
        case description = "Description"
        case fields = "Fields"
        case name = "Name"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let contactFlowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactFlowId)
        contactFlowId = contactFlowIdDecoded
        let constraintsDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.TaskTemplateConstraints.self, forKey: .constraints)
        constraints = constraintsDecoded
        let defaultsDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.TaskTemplateDefaults.self, forKey: .defaults)
        defaults = defaultsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.TaskTemplateStatus.self, forKey: .status)
        status = statusDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.TaskTemplateField?].self, forKey: .fields)
        var fieldsDecoded0:[ConnectClientTypes.TaskTemplateField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [ConnectClientTypes.TaskTemplateField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension UpdateTaskTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateTaskTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.constraints = output.constraints
            self.contactFlowId = output.contactFlowId
            self.createdTime = output.createdTime
            self.defaults = output.defaults
            self.description = output.description
            self.fields = output.fields
            self.id = output.id
            self.instanceId = output.instanceId
            self.lastModifiedTime = output.lastModifiedTime
            self.name = output.name
            self.status = output.status
        } else {
            self.arn = nil
            self.constraints = nil
            self.contactFlowId = nil
            self.createdTime = nil
            self.defaults = nil
            self.description = nil
            self.fields = nil
            self.id = nil
            self.instanceId = nil
            self.lastModifiedTime = nil
            self.name = nil
            self.status = nil
        }
    }
}

public struct UpdateTaskTemplateOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the task template resource.
    public var arn: Swift.String?
    /// Constraints that are applicable to the fields listed.
    public var constraints: ConnectClientTypes.TaskTemplateConstraints?
    /// The identifier of the flow that runs by default when a task is created by referencing this template.
    public var contactFlowId: Swift.String?
    /// The timestamp when the task template was created.
    public var createdTime: ClientRuntime.Date?
    /// The default values for fields when a task is created by referencing this template.
    public var defaults: ConnectClientTypes.TaskTemplateDefaults?
    /// The description of the task template.
    public var description: Swift.String?
    /// Fields that are part of the template.
    public var fields: [ConnectClientTypes.TaskTemplateField]?
    /// The identifier of the task template resource.
    public var id: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    public var instanceId: Swift.String?
    /// The timestamp when the task template was last modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The name of the task template.
    public var name: Swift.String?
    /// Marks a template as ACTIVE or INACTIVE for a task to refer to it. Tasks can only be created from ACTIVE templates. If a template is marked as INACTIVE, then a task that refers to this template cannot be created.
    public var status: ConnectClientTypes.TaskTemplateStatus?

    public init(
        arn: Swift.String? = nil,
        constraints: ConnectClientTypes.TaskTemplateConstraints? = nil,
        contactFlowId: Swift.String? = nil,
        createdTime: ClientRuntime.Date? = nil,
        defaults: ConnectClientTypes.TaskTemplateDefaults? = nil,
        description: Swift.String? = nil,
        fields: [ConnectClientTypes.TaskTemplateField]? = nil,
        id: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        status: ConnectClientTypes.TaskTemplateStatus? = nil
    )
    {
        self.arn = arn
        self.constraints = constraints
        self.contactFlowId = contactFlowId
        self.createdTime = createdTime
        self.defaults = defaults
        self.description = description
        self.fields = fields
        self.id = id
        self.instanceId = instanceId
        self.lastModifiedTime = lastModifiedTime
        self.name = name
        self.status = status
    }
}

struct UpdateTaskTemplateOutputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let id: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let contactFlowId: Swift.String?
    let constraints: ConnectClientTypes.TaskTemplateConstraints?
    let defaults: ConnectClientTypes.TaskTemplateDefaults?
    let fields: [ConnectClientTypes.TaskTemplateField]?
    let status: ConnectClientTypes.TaskTemplateStatus?
    let lastModifiedTime: ClientRuntime.Date?
    let createdTime: ClientRuntime.Date?
}

extension UpdateTaskTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case constraints = "Constraints"
        case contactFlowId = "ContactFlowId"
        case createdTime = "CreatedTime"
        case defaults = "Defaults"
        case description = "Description"
        case fields = "Fields"
        case id = "Id"
        case instanceId = "InstanceId"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let contactFlowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactFlowId)
        contactFlowId = contactFlowIdDecoded
        let constraintsDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.TaskTemplateConstraints.self, forKey: .constraints)
        constraints = constraintsDecoded
        let defaultsDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.TaskTemplateDefaults.self, forKey: .defaults)
        defaults = defaultsDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.TaskTemplateField?].self, forKey: .fields)
        var fieldsDecoded0:[ConnectClientTypes.TaskTemplateField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [ConnectClientTypes.TaskTemplateField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.TaskTemplateStatus.self, forKey: .status)
        status = statusDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

enum UpdateTaskTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PropertyValidationException": return try await PropertyValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateTrafficDistributionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentConfig = "AgentConfig"
        case signInConfig = "SignInConfig"
        case telephonyConfig = "TelephonyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentConfig = self.agentConfig {
            try encodeContainer.encode(agentConfig, forKey: .agentConfig)
        }
        if let signInConfig = self.signInConfig {
            try encodeContainer.encode(signInConfig, forKey: .signInConfig)
        }
        if let telephonyConfig = self.telephonyConfig {
            try encodeContainer.encode(telephonyConfig, forKey: .telephonyConfig)
        }
    }
}

extension UpdateTrafficDistributionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/traffic-distribution/\(id.urlPercentEncoding())"
    }
}

public struct UpdateTrafficDistributionInput: Swift.Equatable {
    /// The distribution of agents between the instance and its replica(s).
    public var agentConfig: ConnectClientTypes.AgentConfig?
    /// The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.
    /// This member is required.
    public var id: Swift.String?
    /// The distribution that determines which Amazon Web Services Regions should be used to sign in agents in to both the instance and its replica(s).
    public var signInConfig: ConnectClientTypes.SignInConfig?
    /// The distribution of traffic between the instance and its replica(s).
    public var telephonyConfig: ConnectClientTypes.TelephonyConfig?

    public init(
        agentConfig: ConnectClientTypes.AgentConfig? = nil,
        id: Swift.String? = nil,
        signInConfig: ConnectClientTypes.SignInConfig? = nil,
        telephonyConfig: ConnectClientTypes.TelephonyConfig? = nil
    )
    {
        self.agentConfig = agentConfig
        self.id = id
        self.signInConfig = signInConfig
        self.telephonyConfig = telephonyConfig
    }
}

struct UpdateTrafficDistributionInputBody: Swift.Equatable {
    let telephonyConfig: ConnectClientTypes.TelephonyConfig?
    let signInConfig: ConnectClientTypes.SignInConfig?
    let agentConfig: ConnectClientTypes.AgentConfig?
}

extension UpdateTrafficDistributionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentConfig = "AgentConfig"
        case signInConfig = "SignInConfig"
        case telephonyConfig = "TelephonyConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let telephonyConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.TelephonyConfig.self, forKey: .telephonyConfig)
        telephonyConfig = telephonyConfigDecoded
        let signInConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.SignInConfig.self, forKey: .signInConfig)
        signInConfig = signInConfigDecoded
        let agentConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.AgentConfig.self, forKey: .agentConfig)
        agentConfig = agentConfigDecoded
    }
}

extension UpdateTrafficDistributionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateTrafficDistributionOutput: Swift.Equatable {

    public init() { }
}

enum UpdateTrafficDistributionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateUserHierarchyGroupNameInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateUserHierarchyGroupNameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let hierarchyGroupId = hierarchyGroupId else {
            return nil
        }
        return "/user-hierarchy-groups/\(instanceId.urlPercentEncoding())/\(hierarchyGroupId.urlPercentEncoding())/name"
    }
}

public struct UpdateUserHierarchyGroupNameInput: Swift.Equatable {
    /// The identifier of the hierarchy group.
    /// This member is required.
    public var hierarchyGroupId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the hierarchy group. Must not be more than 100 characters.
    /// This member is required.
    public var name: Swift.String?

    public init(
        hierarchyGroupId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.hierarchyGroupId = hierarchyGroupId
        self.instanceId = instanceId
        self.name = name
    }
}

struct UpdateUserHierarchyGroupNameInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension UpdateUserHierarchyGroupNameInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateUserHierarchyGroupNameOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateUserHierarchyGroupNameOutput: Swift.Equatable {

    public init() { }
}

enum UpdateUserHierarchyGroupNameOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DuplicateResourceException": return try await DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateUserHierarchyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hierarchyGroupId = "HierarchyGroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hierarchyGroupId = self.hierarchyGroupId {
            try encodeContainer.encode(hierarchyGroupId, forKey: .hierarchyGroupId)
        }
    }
}

extension UpdateUserHierarchyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let userId = userId else {
            return nil
        }
        return "/users/\(instanceId.urlPercentEncoding())/\(userId.urlPercentEncoding())/hierarchy"
    }
}

public struct UpdateUserHierarchyInput: Swift.Equatable {
    /// The identifier of the hierarchy group.
    public var hierarchyGroupId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the user account.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        hierarchyGroupId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.hierarchyGroupId = hierarchyGroupId
        self.instanceId = instanceId
        self.userId = userId
    }
}

struct UpdateUserHierarchyInputBody: Swift.Equatable {
    let hierarchyGroupId: Swift.String?
}

extension UpdateUserHierarchyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hierarchyGroupId = "HierarchyGroupId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hierarchyGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hierarchyGroupId)
        hierarchyGroupId = hierarchyGroupIdDecoded
    }
}

extension UpdateUserHierarchyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateUserHierarchyOutput: Swift.Equatable {

    public init() { }
}

enum UpdateUserHierarchyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateUserHierarchyStructureInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hierarchyStructure = "HierarchyStructure"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hierarchyStructure = self.hierarchyStructure {
            try encodeContainer.encode(hierarchyStructure, forKey: .hierarchyStructure)
        }
    }
}

extension UpdateUserHierarchyStructureInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/user-hierarchy-structure/\(instanceId.urlPercentEncoding())"
    }
}

public struct UpdateUserHierarchyStructureInput: Swift.Equatable {
    /// The hierarchy levels to update.
    /// This member is required.
    public var hierarchyStructure: ConnectClientTypes.HierarchyStructureUpdate?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        hierarchyStructure: ConnectClientTypes.HierarchyStructureUpdate? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.hierarchyStructure = hierarchyStructure
        self.instanceId = instanceId
    }
}

struct UpdateUserHierarchyStructureInputBody: Swift.Equatable {
    let hierarchyStructure: ConnectClientTypes.HierarchyStructureUpdate?
}

extension UpdateUserHierarchyStructureInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hierarchyStructure = "HierarchyStructure"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hierarchyStructureDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyStructureUpdate.self, forKey: .hierarchyStructure)
        hierarchyStructure = hierarchyStructureDecoded
    }
}

extension UpdateUserHierarchyStructureOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateUserHierarchyStructureOutput: Swift.Equatable {

    public init() { }
}

enum UpdateUserHierarchyStructureOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateUserIdentityInfoInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityInfo = "IdentityInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityInfo = self.identityInfo {
            try encodeContainer.encode(identityInfo, forKey: .identityInfo)
        }
    }
}

extension UpdateUserIdentityInfoInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let userId = userId else {
            return nil
        }
        return "/users/\(instanceId.urlPercentEncoding())/\(userId.urlPercentEncoding())/identity-info"
    }
}

public struct UpdateUserIdentityInfoInput: Swift.Equatable {
    /// The identity information for the user.
    /// This member is required.
    public var identityInfo: ConnectClientTypes.UserIdentityInfo?
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the user account.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        identityInfo: ConnectClientTypes.UserIdentityInfo? = nil,
        instanceId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.identityInfo = identityInfo
        self.instanceId = instanceId
        self.userId = userId
    }
}

struct UpdateUserIdentityInfoInputBody: Swift.Equatable {
    let identityInfo: ConnectClientTypes.UserIdentityInfo?
}

extension UpdateUserIdentityInfoInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityInfo = "IdentityInfo"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityInfoDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.UserIdentityInfo.self, forKey: .identityInfo)
        identityInfo = identityInfoDecoded
    }
}

extension UpdateUserIdentityInfoOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateUserIdentityInfoOutput: Swift.Equatable {

    public init() { }
}

enum UpdateUserIdentityInfoOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateUserPhoneConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneConfig = "PhoneConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let phoneConfig = self.phoneConfig {
            try encodeContainer.encode(phoneConfig, forKey: .phoneConfig)
        }
    }
}

extension UpdateUserPhoneConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let userId = userId else {
            return nil
        }
        return "/users/\(instanceId.urlPercentEncoding())/\(userId.urlPercentEncoding())/phone-config"
    }
}

public struct UpdateUserPhoneConfigInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Information about phone configuration settings for the user.
    /// This member is required.
    public var phoneConfig: ConnectClientTypes.UserPhoneConfig?
    /// The identifier of the user account.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        phoneConfig: ConnectClientTypes.UserPhoneConfig? = nil,
        userId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.phoneConfig = phoneConfig
        self.userId = userId
    }
}

struct UpdateUserPhoneConfigInputBody: Swift.Equatable {
    let phoneConfig: ConnectClientTypes.UserPhoneConfig?
}

extension UpdateUserPhoneConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneConfig = "PhoneConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.UserPhoneConfig.self, forKey: .phoneConfig)
        phoneConfig = phoneConfigDecoded
    }
}

extension UpdateUserPhoneConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateUserPhoneConfigOutput: Swift.Equatable {

    public init() { }
}

enum UpdateUserPhoneConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateUserRoutingProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routingProfileId = "RoutingProfileId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let routingProfileId = self.routingProfileId {
            try encodeContainer.encode(routingProfileId, forKey: .routingProfileId)
        }
    }
}

extension UpdateUserRoutingProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let userId = userId else {
            return nil
        }
        return "/users/\(instanceId.urlPercentEncoding())/\(userId.urlPercentEncoding())/routing-profile"
    }
}

public struct UpdateUserRoutingProfileInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the routing profile for the user.
    /// This member is required.
    public var routingProfileId: Swift.String?
    /// The identifier of the user account.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        routingProfileId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.routingProfileId = routingProfileId
        self.userId = userId
    }
}

struct UpdateUserRoutingProfileInputBody: Swift.Equatable {
    let routingProfileId: Swift.String?
}

extension UpdateUserRoutingProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routingProfileId = "RoutingProfileId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routingProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routingProfileId)
        routingProfileId = routingProfileIdDecoded
    }
}

extension UpdateUserRoutingProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateUserRoutingProfileOutput: Swift.Equatable {

    public init() { }
}

enum UpdateUserRoutingProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateUserSecurityProfilesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityProfileIds = "SecurityProfileIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityProfileIds = securityProfileIds {
            var securityProfileIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityProfileIds)
            for securityprofileid0 in securityProfileIds {
                try securityProfileIdsContainer.encode(securityprofileid0)
            }
        }
    }
}

extension UpdateUserSecurityProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let userId = userId else {
            return nil
        }
        return "/users/\(instanceId.urlPercentEncoding())/\(userId.urlPercentEncoding())/security-profiles"
    }
}

public struct UpdateUserSecurityProfilesInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can [find the instance ID](https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html) in the Amazon Resource Name (ARN) of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifiers of the security profiles for the user.
    /// This member is required.
    public var securityProfileIds: [Swift.String]?
    /// The identifier of the user account.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        securityProfileIds: [Swift.String]? = nil,
        userId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.securityProfileIds = securityProfileIds
        self.userId = userId
    }
}

struct UpdateUserSecurityProfilesInputBody: Swift.Equatable {
    let securityProfileIds: [Swift.String]?
}

extension UpdateUserSecurityProfilesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityProfileIds = "SecurityProfileIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityProfileIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityProfileIds)
        var securityProfileIdsDecoded0:[Swift.String]? = nil
        if let securityProfileIdsContainer = securityProfileIdsContainer {
            securityProfileIdsDecoded0 = [Swift.String]()
            for string0 in securityProfileIdsContainer {
                if let string0 = string0 {
                    securityProfileIdsDecoded0?.append(string0)
                }
            }
        }
        securityProfileIds = securityProfileIdsDecoded0
    }
}

extension UpdateUserSecurityProfilesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateUserSecurityProfilesOutput: Swift.Equatable {

    public init() { }
}

enum UpdateUserSecurityProfilesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateViewContentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension UpdateViewContentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let viewId = viewId else {
            return nil
        }
        return "/views/\(instanceId.urlPercentEncoding())/\(viewId.urlPercentEncoding())"
    }
}

public struct UpdateViewContentInput: Swift.Equatable {
    /// View content containing all content necessary to render a view except for runtime input data and the runtime input schema, which is auto-generated by this operation. The total uncompressed content has a maximum file size of 400kB.
    /// This member is required.
    public var content: ConnectClientTypes.ViewInputContent?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Indicates the view status as either SAVED or PUBLISHED. The PUBLISHED status will initiate validation on the content.
    /// This member is required.
    public var status: ConnectClientTypes.ViewStatus?
    /// The identifier of the view. Both ViewArn and ViewId can be used.
    /// This member is required.
    public var viewId: Swift.String?

    public init(
        content: ConnectClientTypes.ViewInputContent? = nil,
        instanceId: Swift.String? = nil,
        status: ConnectClientTypes.ViewStatus? = nil,
        viewId: Swift.String? = nil
    )
    {
        self.content = content
        self.instanceId = instanceId
        self.status = status
        self.viewId = viewId
    }
}

struct UpdateViewContentInputBody: Swift.Equatable {
    let status: ConnectClientTypes.ViewStatus?
    let content: ConnectClientTypes.ViewInputContent?
}

extension UpdateViewContentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ViewStatus.self, forKey: .status)
        status = statusDecoded
        let contentDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ViewInputContent.self, forKey: .content)
        content = contentDecoded
    }
}

extension UpdateViewContentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateViewContentOutputBody = try responseDecoder.decode(responseBody: data)
            self.view = output.view
        } else {
            self.view = nil
        }
    }
}

public struct UpdateViewContentOutput: Swift.Equatable {
    /// A view resource object. Contains metadata and content necessary to render the view.
    public var view: ConnectClientTypes.View?

    public init(
        view: ConnectClientTypes.View? = nil
    )
    {
        self.view = view
    }
}

struct UpdateViewContentOutputBody: Swift.Equatable {
    let view: ConnectClientTypes.View?
}

extension UpdateViewContentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case view = "View"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let viewDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.View.self, forKey: .view)
        view = viewDecoded
    }
}

enum UpdateViewContentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateViewMetadataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateViewMetadataInput(description: \(Swift.String(describing: description)), instanceId: \(Swift.String(describing: instanceId)), viewId: \(Swift.String(describing: viewId)), name: \"CONTENT_REDACTED\")"}
}

extension UpdateViewMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateViewMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let viewId = viewId else {
            return nil
        }
        return "/views/\(instanceId.urlPercentEncoding())/\(viewId.urlPercentEncoding())/metadata"
    }
}

public struct UpdateViewMetadataInput: Swift.Equatable {
    /// The description of the view.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the view.
    public var name: Swift.String?
    /// The identifier of the view. Both ViewArn and ViewId can be used.
    /// This member is required.
    public var viewId: Swift.String?

    public init(
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        viewId: Swift.String? = nil
    )
    {
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.viewId = viewId
    }
}

struct UpdateViewMetadataInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
}

extension UpdateViewMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateViewMetadataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateViewMetadataOutput: Swift.Equatable {

    public init() { }
}

enum UpdateViewMetadataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DuplicateResourceException": return try await DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectClientTypes.UrlReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ConnectClientTypes {
    /// The URL reference.
    public struct UrlReference: Swift.Equatable {
        /// Identifier of the URL reference.
        public var name: Swift.String?
        /// A valid URL.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension ConnectClientTypes.UseCase: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case useCaseArn = "UseCaseArn"
        case useCaseId = "UseCaseId"
        case useCaseType = "UseCaseType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let useCaseArn = self.useCaseArn {
            try encodeContainer.encode(useCaseArn, forKey: .useCaseArn)
        }
        if let useCaseId = self.useCaseId {
            try encodeContainer.encode(useCaseId, forKey: .useCaseId)
        }
        if let useCaseType = self.useCaseType {
            try encodeContainer.encode(useCaseType.rawValue, forKey: .useCaseType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let useCaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .useCaseId)
        useCaseId = useCaseIdDecoded
        let useCaseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .useCaseArn)
        useCaseArn = useCaseArnDecoded
        let useCaseTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.UseCaseType.self, forKey: .useCaseType)
        useCaseType = useCaseTypeDecoded
    }
}

extension ConnectClientTypes {
    /// Contains the use case.
    public struct UseCase: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the use case.
        public var useCaseArn: Swift.String?
        /// The identifier for the use case.
        public var useCaseId: Swift.String?
        /// The type of use case to associate to the integration association. Each integration association can have only one of each use case type.
        public var useCaseType: ConnectClientTypes.UseCaseType?

        public init(
            useCaseArn: Swift.String? = nil,
            useCaseId: Swift.String? = nil,
            useCaseType: ConnectClientTypes.UseCaseType? = nil
        )
        {
            self.useCaseArn = useCaseArn
            self.useCaseId = useCaseId
            self.useCaseType = useCaseType
        }
    }

}

extension ConnectClientTypes {
    public enum UseCaseType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connectCampaigns
        case rulesEvaluation
        case sdkUnknown(Swift.String)

        public static var allCases: [UseCaseType] {
            return [
                .connectCampaigns,
                .rulesEvaluation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connectCampaigns: return "CONNECT_CAMPAIGNS"
            case .rulesEvaluation: return "RULES_EVALUATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UseCaseType(rawValue: rawValue) ?? UseCaseType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.User: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case directoryUserId = "DirectoryUserId"
        case hierarchyGroupId = "HierarchyGroupId"
        case id = "Id"
        case identityInfo = "IdentityInfo"
        case lastModifiedRegion = "LastModifiedRegion"
        case lastModifiedTime = "LastModifiedTime"
        case phoneConfig = "PhoneConfig"
        case routingProfileId = "RoutingProfileId"
        case securityProfileIds = "SecurityProfileIds"
        case tags = "Tags"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let directoryUserId = self.directoryUserId {
            try encodeContainer.encode(directoryUserId, forKey: .directoryUserId)
        }
        if let hierarchyGroupId = self.hierarchyGroupId {
            try encodeContainer.encode(hierarchyGroupId, forKey: .hierarchyGroupId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let identityInfo = self.identityInfo {
            try encodeContainer.encode(identityInfo, forKey: .identityInfo)
        }
        if let lastModifiedRegion = self.lastModifiedRegion {
            try encodeContainer.encode(lastModifiedRegion, forKey: .lastModifiedRegion)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let phoneConfig = self.phoneConfig {
            try encodeContainer.encode(phoneConfig, forKey: .phoneConfig)
        }
        if let routingProfileId = self.routingProfileId {
            try encodeContainer.encode(routingProfileId, forKey: .routingProfileId)
        }
        if let securityProfileIds = securityProfileIds {
            var securityProfileIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityProfileIds)
            for securityprofileid0 in securityProfileIds {
                try securityProfileIdsContainer.encode(securityprofileid0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let identityInfoDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.UserIdentityInfo.self, forKey: .identityInfo)
        identityInfo = identityInfoDecoded
        let phoneConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.UserPhoneConfig.self, forKey: .phoneConfig)
        phoneConfig = phoneConfigDecoded
        let directoryUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryUserId)
        directoryUserId = directoryUserIdDecoded
        let securityProfileIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityProfileIds)
        var securityProfileIdsDecoded0:[Swift.String]? = nil
        if let securityProfileIdsContainer = securityProfileIdsContainer {
            securityProfileIdsDecoded0 = [Swift.String]()
            for string0 in securityProfileIdsContainer {
                if let string0 = string0 {
                    securityProfileIdsDecoded0?.append(string0)
                }
            }
        }
        securityProfileIds = securityProfileIdsDecoded0
        let routingProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routingProfileId)
        routingProfileId = routingProfileIdDecoded
        let hierarchyGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hierarchyGroupId)
        hierarchyGroupId = hierarchyGroupIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastModifiedRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedRegion)
        lastModifiedRegion = lastModifiedRegionDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about a user account for an Amazon Connect instance.
    public struct User: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the user account.
        public var arn: Swift.String?
        /// The identifier of the user account in the directory used for identity management.
        public var directoryUserId: Swift.String?
        /// The identifier of the hierarchy group for the user.
        public var hierarchyGroupId: Swift.String?
        /// The identifier of the user account.
        public var id: Swift.String?
        /// Information about the user identity.
        public var identityInfo: ConnectClientTypes.UserIdentityInfo?
        /// The Amazon Web Services Region where this resource was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when this resource was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// Information about the phone configuration for the user.
        public var phoneConfig: ConnectClientTypes.UserPhoneConfig?
        /// The identifier of the routing profile for the user.
        public var routingProfileId: Swift.String?
        /// The identifiers of the security profiles for the user.
        public var securityProfileIds: [Swift.String]?
        /// The tags.
        public var tags: [Swift.String:Swift.String]?
        /// The user name assigned to the user account.
        public var username: Swift.String?

        public init(
            arn: Swift.String? = nil,
            directoryUserId: Swift.String? = nil,
            hierarchyGroupId: Swift.String? = nil,
            id: Swift.String? = nil,
            identityInfo: ConnectClientTypes.UserIdentityInfo? = nil,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            phoneConfig: ConnectClientTypes.UserPhoneConfig? = nil,
            routingProfileId: Swift.String? = nil,
            securityProfileIds: [Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            username: Swift.String? = nil
        )
        {
            self.arn = arn
            self.directoryUserId = directoryUserId
            self.hierarchyGroupId = hierarchyGroupId
            self.id = id
            self.identityInfo = identityInfo
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.phoneConfig = phoneConfig
            self.routingProfileId = routingProfileId
            self.securityProfileIds = securityProfileIds
            self.tags = tags
            self.username = username
        }
    }

}

extension ConnectClientTypes.UserData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeSlotsByChannel = "ActiveSlotsByChannel"
        case availableSlotsByChannel = "AvailableSlotsByChannel"
        case contacts = "Contacts"
        case hierarchyPath = "HierarchyPath"
        case maxSlotsByChannel = "MaxSlotsByChannel"
        case nextStatus = "NextStatus"
        case routingProfile = "RoutingProfile"
        case status = "Status"
        case user = "User"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeSlotsByChannel = activeSlotsByChannel {
            var activeSlotsByChannelContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .activeSlotsByChannel)
            for (dictKey0, channelToCountMap0) in activeSlotsByChannel {
                try activeSlotsByChannelContainer.encode(channelToCountMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let availableSlotsByChannel = availableSlotsByChannel {
            var availableSlotsByChannelContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .availableSlotsByChannel)
            for (dictKey0, channelToCountMap0) in availableSlotsByChannel {
                try availableSlotsByChannelContainer.encode(channelToCountMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let contacts = contacts {
            var contactsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .contacts)
            for agentcontactreference0 in contacts {
                try contactsContainer.encode(agentcontactreference0)
            }
        }
        if let hierarchyPath = self.hierarchyPath {
            try encodeContainer.encode(hierarchyPath, forKey: .hierarchyPath)
        }
        if let maxSlotsByChannel = maxSlotsByChannel {
            var maxSlotsByChannelContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .maxSlotsByChannel)
            for (dictKey0, channelToCountMap0) in maxSlotsByChannel {
                try maxSlotsByChannelContainer.encode(channelToCountMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let nextStatus = self.nextStatus {
            try encodeContainer.encode(nextStatus, forKey: .nextStatus)
        }
        if let routingProfile = self.routingProfile {
            try encodeContainer.encode(routingProfile, forKey: .routingProfile)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let user = self.user {
            try encodeContainer.encode(user, forKey: .user)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.UserReference.self, forKey: .user)
        user = userDecoded
        let routingProfileDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.RoutingProfileReference.self, forKey: .routingProfile)
        routingProfile = routingProfileDecoded
        let hierarchyPathDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyPathReference.self, forKey: .hierarchyPath)
        hierarchyPath = hierarchyPathDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.AgentStatusReference.self, forKey: .status)
        status = statusDecoded
        let availableSlotsByChannelContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .availableSlotsByChannel)
        var availableSlotsByChannelDecoded0: [Swift.String:Swift.Int]? = nil
        if let availableSlotsByChannelContainer = availableSlotsByChannelContainer {
            availableSlotsByChannelDecoded0 = [Swift.String:Swift.Int]()
            for (key0, integercount0) in availableSlotsByChannelContainer {
                if let integercount0 = integercount0 {
                    availableSlotsByChannelDecoded0?[key0] = integercount0
                }
            }
        }
        availableSlotsByChannel = availableSlotsByChannelDecoded0
        let maxSlotsByChannelContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .maxSlotsByChannel)
        var maxSlotsByChannelDecoded0: [Swift.String:Swift.Int]? = nil
        if let maxSlotsByChannelContainer = maxSlotsByChannelContainer {
            maxSlotsByChannelDecoded0 = [Swift.String:Swift.Int]()
            for (key0, integercount0) in maxSlotsByChannelContainer {
                if let integercount0 = integercount0 {
                    maxSlotsByChannelDecoded0?[key0] = integercount0
                }
            }
        }
        maxSlotsByChannel = maxSlotsByChannelDecoded0
        let activeSlotsByChannelContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .activeSlotsByChannel)
        var activeSlotsByChannelDecoded0: [Swift.String:Swift.Int]? = nil
        if let activeSlotsByChannelContainer = activeSlotsByChannelContainer {
            activeSlotsByChannelDecoded0 = [Swift.String:Swift.Int]()
            for (key0, integercount0) in activeSlotsByChannelContainer {
                if let integercount0 = integercount0 {
                    activeSlotsByChannelDecoded0?[key0] = integercount0
                }
            }
        }
        activeSlotsByChannel = activeSlotsByChannelDecoded0
        let contactsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.AgentContactReference?].self, forKey: .contacts)
        var contactsDecoded0:[ConnectClientTypes.AgentContactReference]? = nil
        if let contactsContainer = contactsContainer {
            contactsDecoded0 = [ConnectClientTypes.AgentContactReference]()
            for structure0 in contactsContainer {
                if let structure0 = structure0 {
                    contactsDecoded0?.append(structure0)
                }
            }
        }
        contacts = contactsDecoded0
        let nextStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextStatus)
        nextStatus = nextStatusDecoded
    }
}

extension ConnectClientTypes {
    /// Data for a user.
    public struct UserData: Swift.Equatable {
        /// A map of active slots by channel. The key is a channel name. The value is an integer: the number of active slots.
        public var activeSlotsByChannel: [Swift.String:Swift.Int]?
        /// A map of available slots by channel. The key is a channel name. The value is an integer: the available number of slots.
        public var availableSlotsByChannel: [Swift.String:Swift.Int]?
        /// A list of contact reference information.
        public var contacts: [ConnectClientTypes.AgentContactReference]?
        /// Contains information about the levels of a hierarchy group assigned to a user.
        public var hierarchyPath: ConnectClientTypes.HierarchyPathReference?
        /// A map of maximum slots by channel. The key is a channel name. The value is an integer: the maximum number of slots. This is calculated from [MediaConcurrency](https://docs.aws.amazon.com/connect/latest/APIReference/API_MediaConcurrency.html) of the RoutingProfile assigned to the agent.
        public var maxSlotsByChannel: [Swift.String:Swift.Int]?
        /// The Next status of the agent.
        public var nextStatus: Swift.String?
        /// Information about the routing profile that is assigned to the user.
        public var routingProfile: ConnectClientTypes.RoutingProfileReference?
        /// The status of the agent that they manually set in their Contact Control Panel (CCP), or that the supervisor manually changes in the real-time metrics report.
        public var status: ConnectClientTypes.AgentStatusReference?
        /// Information about the user for the data that is returned. It contains the resourceId and ARN of the user.
        public var user: ConnectClientTypes.UserReference?

        public init(
            activeSlotsByChannel: [Swift.String:Swift.Int]? = nil,
            availableSlotsByChannel: [Swift.String:Swift.Int]? = nil,
            contacts: [ConnectClientTypes.AgentContactReference]? = nil,
            hierarchyPath: ConnectClientTypes.HierarchyPathReference? = nil,
            maxSlotsByChannel: [Swift.String:Swift.Int]? = nil,
            nextStatus: Swift.String? = nil,
            routingProfile: ConnectClientTypes.RoutingProfileReference? = nil,
            status: ConnectClientTypes.AgentStatusReference? = nil,
            user: ConnectClientTypes.UserReference? = nil
        )
        {
            self.activeSlotsByChannel = activeSlotsByChannel
            self.availableSlotsByChannel = availableSlotsByChannel
            self.contacts = contacts
            self.hierarchyPath = hierarchyPath
            self.maxSlotsByChannel = maxSlotsByChannel
            self.nextStatus = nextStatus
            self.routingProfile = routingProfile
            self.status = status
            self.user = user
        }
    }

}

extension ConnectClientTypes.UserDataFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agents = "Agents"
        case contactFilter = "ContactFilter"
        case queues = "Queues"
        case routingProfiles = "RoutingProfiles"
        case userHierarchyGroups = "UserHierarchyGroups"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agents = agents {
            var agentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .agents)
            for userid0 in agents {
                try agentsContainer.encode(userid0)
            }
        }
        if let contactFilter = self.contactFilter {
            try encodeContainer.encode(contactFilter, forKey: .contactFilter)
        }
        if let queues = queues {
            var queuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queues)
            for queueid0 in queues {
                try queuesContainer.encode(queueid0)
            }
        }
        if let routingProfiles = routingProfiles {
            var routingProfilesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .routingProfiles)
            for routingprofileid0 in routingProfiles {
                try routingProfilesContainer.encode(routingprofileid0)
            }
        }
        if let userHierarchyGroups = userHierarchyGroups {
            var userHierarchyGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userHierarchyGroups)
            for hierarchygroupid0 in userHierarchyGroups {
                try userHierarchyGroupsContainer.encode(hierarchygroupid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .queues)
        var queuesDecoded0:[Swift.String]? = nil
        if let queuesContainer = queuesContainer {
            queuesDecoded0 = [Swift.String]()
            for string0 in queuesContainer {
                if let string0 = string0 {
                    queuesDecoded0?.append(string0)
                }
            }
        }
        queues = queuesDecoded0
        let contactFilterDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ContactFilter.self, forKey: .contactFilter)
        contactFilter = contactFilterDecoded
        let routingProfilesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .routingProfiles)
        var routingProfilesDecoded0:[Swift.String]? = nil
        if let routingProfilesContainer = routingProfilesContainer {
            routingProfilesDecoded0 = [Swift.String]()
            for string0 in routingProfilesContainer {
                if let string0 = string0 {
                    routingProfilesDecoded0?.append(string0)
                }
            }
        }
        routingProfiles = routingProfilesDecoded0
        let agentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .agents)
        var agentsDecoded0:[Swift.String]? = nil
        if let agentsContainer = agentsContainer {
            agentsDecoded0 = [Swift.String]()
            for string0 in agentsContainer {
                if let string0 = string0 {
                    agentsDecoded0?.append(string0)
                }
            }
        }
        agents = agentsDecoded0
        let userHierarchyGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .userHierarchyGroups)
        var userHierarchyGroupsDecoded0:[Swift.String]? = nil
        if let userHierarchyGroupsContainer = userHierarchyGroupsContainer {
            userHierarchyGroupsDecoded0 = [Swift.String]()
            for string0 in userHierarchyGroupsContainer {
                if let string0 = string0 {
                    userHierarchyGroupsDecoded0?.append(string0)
                }
            }
        }
        userHierarchyGroups = userHierarchyGroupsDecoded0
    }
}

extension ConnectClientTypes {
    /// A filter for the user data.
    public struct UserDataFilters: Swift.Equatable {
        /// A list of up to 100 agent IDs or ARNs.
        public var agents: [Swift.String]?
        /// A filter for the user data based on the contact information that is associated to the user. It contains a list of contact states.
        public var contactFilter: ConnectClientTypes.ContactFilter?
        /// A list of up to 100 queues or ARNs.
        public var queues: [Swift.String]?
        /// A list of up to 100 routing profile IDs or ARNs.
        public var routingProfiles: [Swift.String]?
        /// A UserHierarchyGroup ID or ARN.
        public var userHierarchyGroups: [Swift.String]?

        public init(
            agents: [Swift.String]? = nil,
            contactFilter: ConnectClientTypes.ContactFilter? = nil,
            queues: [Swift.String]? = nil,
            routingProfiles: [Swift.String]? = nil,
            userHierarchyGroups: [Swift.String]? = nil
        )
        {
            self.agents = agents
            self.contactFilter = contactFilter
            self.queues = queues
            self.routingProfiles = routingProfiles
            self.userHierarchyGroups = userHierarchyGroups
        }
    }

}

extension ConnectClientTypes.UserIdentityInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case email = "Email"
        case firstName = "FirstName"
        case lastName = "LastName"
        case mobile = "Mobile"
        case secondaryEmail = "SecondaryEmail"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let firstName = self.firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = self.lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let mobile = self.mobile {
            try encodeContainer.encode(mobile, forKey: .mobile)
        }
        if let secondaryEmail = self.secondaryEmail {
            try encodeContainer.encode(secondaryEmail, forKey: .secondaryEmail)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let secondaryEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secondaryEmail)
        secondaryEmail = secondaryEmailDecoded
        let mobileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mobile)
        mobile = mobileDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about the identity of a user.
    public struct UserIdentityInfo: Swift.Equatable {
        /// The email address. If you are using SAML for identity management and include this parameter, an error is returned.
        public var email: Swift.String?
        /// The first name. This is required if you are using Amazon Connect or SAML for identity management.
        public var firstName: Swift.String?
        /// The last name. This is required if you are using Amazon Connect or SAML for identity management.
        public var lastName: Swift.String?
        /// The user's mobile number.
        public var mobile: Swift.String?
        /// The user's secondary email address. If you provide a secondary email, the user receives email notifications - other than password reset notifications - to this email address instead of to their primary email address. Pattern: (?=^.{0,265}$)[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,63}
        public var secondaryEmail: Swift.String?

        public init(
            email: Swift.String? = nil,
            firstName: Swift.String? = nil,
            lastName: Swift.String? = nil,
            mobile: Swift.String? = nil,
            secondaryEmail: Swift.String? = nil
        )
        {
            self.email = email
            self.firstName = firstName
            self.lastName = lastName
            self.mobile = mobile
            self.secondaryEmail = secondaryEmail
        }
    }

}

extension ConnectClientTypes.UserIdentityInfoLite: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firstName = "FirstName"
        case lastName = "LastName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firstName = self.firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = self.lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
    }
}

extension ConnectClientTypes {
    /// The user's first name and last name.
    public struct UserIdentityInfoLite: Swift.Equatable {
        /// The user's first name.
        public var firstName: Swift.String?
        /// The user's last name.
        public var lastName: Swift.String?

        public init(
            firstName: Swift.String? = nil,
            lastName: Swift.String? = nil
        )
        {
            self.firstName = firstName
            self.lastName = lastName
        }
    }

}

extension UserNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UserNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// No user with the specified credentials was found in the Amazon Connect instance.
public struct UserNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UserNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UserNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UserNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectClientTypes.UserPhoneConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterContactWorkTimeLimit = "AfterContactWorkTimeLimit"
        case autoAccept = "AutoAccept"
        case deskPhoneNumber = "DeskPhoneNumber"
        case phoneType = "PhoneType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if afterContactWorkTimeLimit != 0 {
            try encodeContainer.encode(afterContactWorkTimeLimit, forKey: .afterContactWorkTimeLimit)
        }
        if autoAccept != false {
            try encodeContainer.encode(autoAccept, forKey: .autoAccept)
        }
        if let deskPhoneNumber = self.deskPhoneNumber {
            try encodeContainer.encode(deskPhoneNumber, forKey: .deskPhoneNumber)
        }
        if let phoneType = self.phoneType {
            try encodeContainer.encode(phoneType.rawValue, forKey: .phoneType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.PhoneType.self, forKey: .phoneType)
        phoneType = phoneTypeDecoded
        let autoAcceptDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoAccept) ?? false
        autoAccept = autoAcceptDecoded
        let afterContactWorkTimeLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .afterContactWorkTimeLimit) ?? 0
        afterContactWorkTimeLimit = afterContactWorkTimeLimitDecoded
        let deskPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deskPhoneNumber)
        deskPhoneNumber = deskPhoneNumberDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about the phone configuration settings for a user.
    public struct UserPhoneConfig: Swift.Equatable {
        /// The After Call Work (ACW) timeout setting, in seconds. When returned by a SearchUsers call, AfterContactWorkTimeLimit is returned in milliseconds.
        public var afterContactWorkTimeLimit: Swift.Int
        /// The Auto accept setting.
        public var autoAccept: Swift.Bool
        /// The phone number for the user's desk phone.
        public var deskPhoneNumber: Swift.String?
        /// The phone type.
        /// This member is required.
        public var phoneType: ConnectClientTypes.PhoneType?

        public init(
            afterContactWorkTimeLimit: Swift.Int = 0,
            autoAccept: Swift.Bool = false,
            deskPhoneNumber: Swift.String? = nil,
            phoneType: ConnectClientTypes.PhoneType? = nil
        )
        {
            self.afterContactWorkTimeLimit = afterContactWorkTimeLimit
            self.autoAccept = autoAccept
            self.deskPhoneNumber = deskPhoneNumber
            self.phoneType = phoneType
        }
    }

}

extension ConnectClientTypes.UserQuickConnectConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactFlowId = "ContactFlowId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactFlowId = self.contactFlowId {
            try encodeContainer.encode(contactFlowId, forKey: .contactFlowId)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let contactFlowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactFlowId)
        contactFlowId = contactFlowIdDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about the quick connect configuration settings for a user. The contact flow must be of type Transfer to Agent.
    public struct UserQuickConnectConfig: Swift.Equatable {
        /// The identifier of the flow.
        /// This member is required.
        public var contactFlowId: Swift.String?
        /// The identifier of the user.
        /// This member is required.
        public var userId: Swift.String?

        public init(
            contactFlowId: Swift.String? = nil,
            userId: Swift.String? = nil
        )
        {
            self.contactFlowId = contactFlowId
            self.userId = userId
        }
    }

}

extension ConnectClientTypes.UserReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension ConnectClientTypes {
    /// Information about the user.
    public struct UserReference: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the user.
        public var arn: Swift.String?
        /// The unique identifier for the user.
        public var id: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
        }
    }

}

extension ConnectClientTypes.UserSearchCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case andConditions = "AndConditions"
        case hierarchyGroupCondition = "HierarchyGroupCondition"
        case orConditions = "OrConditions"
        case stringCondition = "StringCondition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let andConditions = andConditions {
            var andConditionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .andConditions)
            for usersearchcriteria0 in andConditions {
                try andConditionsContainer.encode(usersearchcriteria0)
            }
        }
        if let hierarchyGroupCondition = self.hierarchyGroupCondition {
            try encodeContainer.encode(hierarchyGroupCondition, forKey: .hierarchyGroupCondition)
        }
        if let orConditions = orConditions {
            var orConditionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .orConditions)
            for usersearchcriteria0 in orConditions {
                try orConditionsContainer.encode(usersearchcriteria0)
            }
        }
        if let stringCondition = self.stringCondition {
            try encodeContainer.encode(stringCondition, forKey: .stringCondition)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orConditionsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.UserSearchCriteria?].self, forKey: .orConditions)
        var orConditionsDecoded0:[ConnectClientTypes.UserSearchCriteria]? = nil
        if let orConditionsContainer = orConditionsContainer {
            orConditionsDecoded0 = [ConnectClientTypes.UserSearchCriteria]()
            for structure0 in orConditionsContainer {
                if let structure0 = structure0 {
                    orConditionsDecoded0?.append(structure0)
                }
            }
        }
        orConditions = orConditionsDecoded0
        let andConditionsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.UserSearchCriteria?].self, forKey: .andConditions)
        var andConditionsDecoded0:[ConnectClientTypes.UserSearchCriteria]? = nil
        if let andConditionsContainer = andConditionsContainer {
            andConditionsDecoded0 = [ConnectClientTypes.UserSearchCriteria]()
            for structure0 in andConditionsContainer {
                if let structure0 = structure0 {
                    andConditionsDecoded0?.append(structure0)
                }
            }
        }
        andConditions = andConditionsDecoded0
        let stringConditionDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.StringCondition.self, forKey: .stringCondition)
        stringCondition = stringConditionDecoded
        let hierarchyGroupConditionDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyGroupCondition.self, forKey: .hierarchyGroupCondition)
        hierarchyGroupCondition = hierarchyGroupConditionDecoded
    }
}

extension ConnectClientTypes {
    /// The search criteria to be used to return users. The name and description fields support "contains" queries with a minimum of 2 characters and a maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results.
    public struct UserSearchCriteria: Swift.Equatable {
        /// A list of conditions which would be applied together with an AND condition.
        public var andConditions: [ConnectClientTypes.UserSearchCriteria]?
        /// A leaf node condition which can be used to specify a hierarchy group condition.
        public var hierarchyGroupCondition: ConnectClientTypes.HierarchyGroupCondition?
        /// A list of conditions which would be applied together with an OR condition.
        public var orConditions: [ConnectClientTypes.UserSearchCriteria]?
        /// A leaf node condition which can be used to specify a string condition. The currently supported values for FieldName are name, description, and resourceID.
        public var stringCondition: ConnectClientTypes.StringCondition?

        public init(
            andConditions: [ConnectClientTypes.UserSearchCriteria]? = nil,
            hierarchyGroupCondition: ConnectClientTypes.HierarchyGroupCondition? = nil,
            orConditions: [ConnectClientTypes.UserSearchCriteria]? = nil,
            stringCondition: ConnectClientTypes.StringCondition? = nil
        )
        {
            self.andConditions = andConditions
            self.hierarchyGroupCondition = hierarchyGroupCondition
            self.orConditions = orConditions
            self.stringCondition = stringCondition
        }
    }

}

extension ConnectClientTypes.UserSearchFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagFilter = "TagFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagFilter = self.tagFilter {
            try encodeContainer.encode(tagFilter, forKey: .tagFilter)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagFilterDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ControlPlaneTagFilter.self, forKey: .tagFilter)
        tagFilter = tagFilterDecoded
    }
}

extension ConnectClientTypes {
    /// Filters to be applied to search results.
    public struct UserSearchFilter: Swift.Equatable {
        /// An object that can be used to specify Tag conditions inside the SearchFilter. This accepts an OR of AND (List of List) input where:
        ///
        /// * Top level list specifies conditions that need to be applied with OR operator
        ///
        /// * Inner list specifies conditions that need to be applied with AND operator.
        public var tagFilter: ConnectClientTypes.ControlPlaneTagFilter?

        public init(
            tagFilter: ConnectClientTypes.ControlPlaneTagFilter? = nil
        )
        {
            self.tagFilter = tagFilter
        }
    }

}

extension ConnectClientTypes.UserSearchSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case directoryUserId = "DirectoryUserId"
        case hierarchyGroupId = "HierarchyGroupId"
        case id = "Id"
        case identityInfo = "IdentityInfo"
        case phoneConfig = "PhoneConfig"
        case routingProfileId = "RoutingProfileId"
        case securityProfileIds = "SecurityProfileIds"
        case tags = "Tags"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let directoryUserId = self.directoryUserId {
            try encodeContainer.encode(directoryUserId, forKey: .directoryUserId)
        }
        if let hierarchyGroupId = self.hierarchyGroupId {
            try encodeContainer.encode(hierarchyGroupId, forKey: .hierarchyGroupId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let identityInfo = self.identityInfo {
            try encodeContainer.encode(identityInfo, forKey: .identityInfo)
        }
        if let phoneConfig = self.phoneConfig {
            try encodeContainer.encode(phoneConfig, forKey: .phoneConfig)
        }
        if let routingProfileId = self.routingProfileId {
            try encodeContainer.encode(routingProfileId, forKey: .routingProfileId)
        }
        if let securityProfileIds = securityProfileIds {
            var securityProfileIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityProfileIds)
            for securityprofileid0 in securityProfileIds {
                try securityProfileIdsContainer.encode(securityprofileid0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let directoryUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryUserId)
        directoryUserId = directoryUserIdDecoded
        let hierarchyGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hierarchyGroupId)
        hierarchyGroupId = hierarchyGroupIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let identityInfoDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.UserIdentityInfoLite.self, forKey: .identityInfo)
        identityInfo = identityInfoDecoded
        let phoneConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.UserPhoneConfig.self, forKey: .phoneConfig)
        phoneConfig = phoneConfigDecoded
        let routingProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routingProfileId)
        routingProfileId = routingProfileIdDecoded
        let securityProfileIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityProfileIds)
        var securityProfileIdsDecoded0:[Swift.String]? = nil
        if let securityProfileIdsContainer = securityProfileIdsContainer {
            securityProfileIdsDecoded0 = [Swift.String]()
            for string0 in securityProfileIdsContainer {
                if let string0 = string0 {
                    securityProfileIdsDecoded0?.append(string0)
                }
            }
        }
        securityProfileIds = securityProfileIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
    }
}

extension ConnectClientTypes {
    /// Information about the returned users.
    public struct UserSearchSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the user.
        public var arn: Swift.String?
        /// The directory identifier of the user.
        public var directoryUserId: Swift.String?
        /// The identifier of the user's hierarchy group.
        public var hierarchyGroupId: Swift.String?
        /// The identifier of the user's summary.
        public var id: Swift.String?
        /// The user's first name and last name.
        public var identityInfo: ConnectClientTypes.UserIdentityInfoLite?
        /// Contains information about the phone configuration settings for a user.
        public var phoneConfig: ConnectClientTypes.UserPhoneConfig?
        /// The identifier of the user's routing profile.
        public var routingProfileId: Swift.String?
        /// The identifiers of the user's security profiles.
        public var securityProfileIds: [Swift.String]?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public var tags: [Swift.String:Swift.String]?
        /// The name of the user.
        public var username: Swift.String?

        public init(
            arn: Swift.String? = nil,
            directoryUserId: Swift.String? = nil,
            hierarchyGroupId: Swift.String? = nil,
            id: Swift.String? = nil,
            identityInfo: ConnectClientTypes.UserIdentityInfoLite? = nil,
            phoneConfig: ConnectClientTypes.UserPhoneConfig? = nil,
            routingProfileId: Swift.String? = nil,
            securityProfileIds: [Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            username: Swift.String? = nil
        )
        {
            self.arn = arn
            self.directoryUserId = directoryUserId
            self.hierarchyGroupId = hierarchyGroupId
            self.id = id
            self.identityInfo = identityInfo
            self.phoneConfig = phoneConfig
            self.routingProfileId = routingProfileId
            self.securityProfileIds = securityProfileIds
            self.tags = tags
            self.username = username
        }
    }

}

extension ConnectClientTypes.UserSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case lastModifiedRegion = "LastModifiedRegion"
        case lastModifiedTime = "LastModifiedTime"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastModifiedRegion = self.lastModifiedRegion {
            try encodeContainer.encode(lastModifiedRegion, forKey: .lastModifiedRegion)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastModifiedRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedRegion)
        lastModifiedRegion = lastModifiedRegionDecoded
    }
}

extension ConnectClientTypes {
    /// Contains summary information about a user.
    public struct UserSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the user account.
        public var arn: Swift.String?
        /// The identifier of the user account.
        public var id: Swift.String?
        /// The Amazon Web Services Region where this resource was last modified.
        public var lastModifiedRegion: Swift.String?
        /// The timestamp when this resource was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The Amazon Connect user name of the user account.
        public var username: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedRegion: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            username: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.username = username
        }
    }

}

extension ConnectClientTypes {
    public enum VideoCapability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case send
        case sdkUnknown(Swift.String)

        public static var allCases: [VideoCapability] {
            return [
                .send,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .send: return "SEND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VideoCapability(rawValue: rawValue) ?? VideoCapability.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.View: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case content = "Content"
        case createdTime = "CreatedTime"
        case description = "Description"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case status = "Status"
        case tags = "Tags"
        case type = "Type"
        case version = "Version"
        case versionDescription = "VersionDescription"
        case viewContentSha256 = "ViewContentSha256"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let versionDescription = self.versionDescription {
            try encodeContainer.encode(versionDescription, forKey: .versionDescription)
        }
        if let viewContentSha256 = self.viewContentSha256 {
            try encodeContainer.encode(viewContentSha256, forKey: .viewContentSha256)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ViewStatus.self, forKey: .status)
        status = statusDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ViewType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .version) ?? 0
        version = versionDecoded
        let versionDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionDescription)
        versionDescription = versionDescriptionDecoded
        let contentDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ViewContent.self, forKey: .content)
        content = contentDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let viewContentSha256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .viewContentSha256)
        viewContentSha256 = viewContentSha256Decoded
    }
}

extension ConnectClientTypes.View: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "View(arn: \(Swift.String(describing: arn)), content: \(Swift.String(describing: content)), createdTime: \(Swift.String(describing: createdTime)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)), version: \(Swift.String(describing: version)), versionDescription: \(Swift.String(describing: versionDescription)), viewContentSha256: \(Swift.String(describing: viewContentSha256)), name: \"CONTENT_REDACTED\")"}
}

extension ConnectClientTypes {
    /// A view resource object. Contains metadata and content necessary to render the view.
    public struct View: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the view.
        public var arn: Swift.String?
        /// View content containing all content necessary to render a view except for runtime input data.
        public var content: ConnectClientTypes.ViewContent?
        /// The timestamp of when the view was created.
        public var createdTime: ClientRuntime.Date?
        /// The description of the view.
        public var description: Swift.String?
        /// The identifier of the view.
        public var id: Swift.String?
        /// Latest timestamp of the UpdateViewContent or CreateViewVersion operations.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name of the view.
        public var name: Swift.String?
        /// Indicates the view status as either SAVED or PUBLISHED. The PUBLISHED status will initiate validation on the content.
        public var status: ConnectClientTypes.ViewStatus?
        /// The tags associated with the view resource (not specific to view version).
        public var tags: [Swift.String:Swift.String]?
        /// The type of the view - CUSTOMER_MANAGED.
        public var type: ConnectClientTypes.ViewType?
        /// Current version of the view.
        public var version: Swift.Int
        /// The description of the version.
        public var versionDescription: Swift.String?
        /// Indicates the checksum value of the latest published view content.
        public var viewContentSha256: Swift.String?

        public init(
            arn: Swift.String? = nil,
            content: ConnectClientTypes.ViewContent? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: ConnectClientTypes.ViewStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: ConnectClientTypes.ViewType? = nil,
            version: Swift.Int = 0,
            versionDescription: Swift.String? = nil,
            viewContentSha256: Swift.String? = nil
        )
        {
            self.arn = arn
            self.content = content
            self.createdTime = createdTime
            self.description = description
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.status = status
            self.tags = tags
            self.type = type
            self.version = version
            self.versionDescription = versionDescription
            self.viewContentSha256 = viewContentSha256
        }
    }

}

extension ConnectClientTypes.ViewContent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case inputSchema = "InputSchema"
        case template = "Template"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for viewaction0 in actions {
                try actionsContainer.encode(viewaction0)
            }
        }
        if let inputSchema = self.inputSchema {
            try encodeContainer.encode(inputSchema, forKey: .inputSchema)
        }
        if let template = self.template {
            try encodeContainer.encode(template, forKey: .template)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputSchemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputSchema)
        inputSchema = inputSchemaDecoded
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
        let actionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .actions)
        var actionsDecoded0:[Swift.String]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Swift.String]()
            for string0 in actionsContainer {
                if let string0 = string0 {
                    actionsDecoded0?.append(string0)
                }
            }
        }
        actions = actionsDecoded0
    }
}

extension ConnectClientTypes.ViewContent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ViewContent(actions: \(Swift.String(describing: actions)), template: \(Swift.String(describing: template)), inputSchema: \"CONTENT_REDACTED\")"}
}

extension ConnectClientTypes {
    /// View content containing all content necessary to render a view except for runtime input data.
    public struct ViewContent: Swift.Equatable {
        /// A list of possible actions from the view.
        public var actions: [Swift.String]?
        /// The data schema matching data that the view template must be provided to render.
        public var inputSchema: Swift.String?
        /// The view template representing the structure of the view.
        public var template: Swift.String?

        public init(
            actions: [Swift.String]? = nil,
            inputSchema: Swift.String? = nil,
            template: Swift.String? = nil
        )
        {
            self.actions = actions
            self.inputSchema = inputSchema
            self.template = template
        }
    }

}

extension ConnectClientTypes.ViewInputContent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case template = "Template"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for viewaction0 in actions {
                try actionsContainer.encode(viewaction0)
            }
        }
        if let template = self.template {
            try encodeContainer.encode(template, forKey: .template)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
        let actionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .actions)
        var actionsDecoded0:[Swift.String]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Swift.String]()
            for string0 in actionsContainer {
                if let string0 = string0 {
                    actionsDecoded0?.append(string0)
                }
            }
        }
        actions = actionsDecoded0
    }
}

extension ConnectClientTypes {
    /// View content containing all content necessary to render a view except for runtime input data and the runtime input schema, which is auto-generated by this operation.
    public struct ViewInputContent: Swift.Equatable {
        /// A list of possible actions from the view.
        public var actions: [Swift.String]?
        /// The view template representing the structure of the view.
        public var template: Swift.String?

        public init(
            actions: [Swift.String]? = nil,
            template: Swift.String? = nil
        )
        {
            self.actions = actions
            self.template = template
        }
    }

}

extension ConnectClientTypes {
    public enum ViewStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case published
        case saved
        case sdkUnknown(Swift.String)

        public static var allCases: [ViewStatus] {
            return [
                .published,
                .saved,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .published: return "PUBLISHED"
            case .saved: return "SAVED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ViewStatus(rawValue: rawValue) ?? ViewStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.ViewSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case status = "Status"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ViewType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ViewStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension ConnectClientTypes.ViewSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ViewSummary(arn: \(Swift.String(describing: arn)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), name: \"CONTENT_REDACTED\")"}
}

extension ConnectClientTypes {
    /// A summary of a view's metadata.
    public struct ViewSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the view.
        public var arn: Swift.String?
        /// The description of the view.
        public var description: Swift.String?
        /// The identifier of the view.
        public var id: Swift.String?
        /// The name of the view.
        public var name: Swift.String?
        /// Indicates the view status as either SAVED or PUBLISHED. The PUBLISHED status will initiate validation on the content.
        public var status: ConnectClientTypes.ViewStatus?
        /// The type of the view.
        public var type: ConnectClientTypes.ViewType?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: ConnectClientTypes.ViewStatus? = nil,
            type: ConnectClientTypes.ViewType? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.id = id
            self.name = name
            self.status = status
            self.type = type
        }
    }

}

extension ConnectClientTypes {
    public enum ViewType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsManaged
        case customerManaged
        case sdkUnknown(Swift.String)

        public static var allCases: [ViewType] {
            return [
                .awsManaged,
                .customerManaged,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsManaged: return "AWS_MANAGED"
            case .customerManaged: return "CUSTOMER_MANAGED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ViewType(rawValue: rawValue) ?? ViewType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.ViewVersionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case type = "Type"
        case version = "Version"
        case versionDescription = "VersionDescription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let versionDescription = self.versionDescription {
            try encodeContainer.encode(versionDescription, forKey: .versionDescription)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ViewType.self, forKey: .type)
        type = typeDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .version) ?? 0
        version = versionDecoded
        let versionDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionDescription)
        versionDescription = versionDescriptionDecoded
    }
}

extension ConnectClientTypes.ViewVersionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ViewVersionSummary(arn: \(Swift.String(describing: arn)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), type: \(Swift.String(describing: type)), version: \(Swift.String(describing: version)), versionDescription: \(Swift.String(describing: versionDescription)), name: \"CONTENT_REDACTED\")"}
}

extension ConnectClientTypes {
    /// A summary of a view version's metadata.
    public struct ViewVersionSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the view version.
        public var arn: Swift.String?
        /// The description of the view version.
        public var description: Swift.String?
        /// The identifier of the view version.
        public var id: Swift.String?
        /// The name of the view version.
        public var name: Swift.String?
        /// The type of the view version.
        public var type: ConnectClientTypes.ViewType?
        /// The sequentially incremented version of the view version.
        public var version: Swift.Int
        /// The description of the view version.
        public var versionDescription: Swift.String?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            type: ConnectClientTypes.ViewType? = nil,
            version: Swift.Int = 0,
            versionDescription: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.id = id
            self.name = name
            self.type = type
            self.version = version
            self.versionDescription = versionDescription
        }
    }

}

extension ConnectClientTypes.Vocabulary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case content = "Content"
        case failureReason = "FailureReason"
        case id = "Id"
        case languageCode = "LanguageCode"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.VocabularyLanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.VocabularyState.self, forKey: .state)
        state = stateDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ConnectClientTypes {
    /// Contains information about a custom vocabulary.
    public struct Vocabulary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the custom vocabulary.
        /// This member is required.
        public var arn: Swift.String?
        /// The content of the custom vocabulary in plain-text format with a table of values. Each row in the table represents a word or a phrase, described with Phrase, IPA, SoundsLike, and DisplayAs fields. Separate the fields with TAB characters. For more information, see [Create a custom vocabulary using a table](https://docs.aws.amazon.com/transcribe/latest/dg/custom-vocabulary.html#create-vocabulary-table).
        public var content: Swift.String?
        /// The reason why the custom vocabulary was not created.
        public var failureReason: Swift.String?
        /// The identifier of the custom vocabulary.
        /// This member is required.
        public var id: Swift.String?
        /// The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see [What is Amazon Transcribe?](https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html)
        /// This member is required.
        public var languageCode: ConnectClientTypes.VocabularyLanguageCode?
        /// The timestamp when the custom vocabulary was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// A unique name of the custom vocabulary.
        /// This member is required.
        public var name: Swift.String?
        /// The current state of the custom vocabulary.
        /// This member is required.
        public var state: ConnectClientTypes.VocabularyState?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            content: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            id: Swift.String? = nil,
            languageCode: ConnectClientTypes.VocabularyLanguageCode? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            state: ConnectClientTypes.VocabularyState? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.content = content
            self.failureReason = failureReason
            self.id = id
            self.languageCode = languageCode
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.state = state
            self.tags = tags
        }
    }

}

extension ConnectClientTypes {
    public enum VocabularyLanguageCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case arAe
        case deCh
        case deDe
        case enAb
        case enAu
        case enGb
        case enIe
        case enIn
        case enNz
        case enUs
        case enWl
        case enZa
        case esEs
        case esUs
        case frCa
        case frFr
        case hiIn
        case itIt
        case jaJp
        case koKr
        case ptBr
        case ptPt
        case zhCn
        case sdkUnknown(Swift.String)

        public static var allCases: [VocabularyLanguageCode] {
            return [
                .arAe,
                .deCh,
                .deDe,
                .enAb,
                .enAu,
                .enGb,
                .enIe,
                .enIn,
                .enNz,
                .enUs,
                .enWl,
                .enZa,
                .esEs,
                .esUs,
                .frCa,
                .frFr,
                .hiIn,
                .itIt,
                .jaJp,
                .koKr,
                .ptBr,
                .ptPt,
                .zhCn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .arAe: return "ar-AE"
            case .deCh: return "de-CH"
            case .deDe: return "de-DE"
            case .enAb: return "en-AB"
            case .enAu: return "en-AU"
            case .enGb: return "en-GB"
            case .enIe: return "en-IE"
            case .enIn: return "en-IN"
            case .enNz: return "en-NZ"
            case .enUs: return "en-US"
            case .enWl: return "en-WL"
            case .enZa: return "en-ZA"
            case .esEs: return "es-ES"
            case .esUs: return "es-US"
            case .frCa: return "fr-CA"
            case .frFr: return "fr-FR"
            case .hiIn: return "hi-IN"
            case .itIt: return "it-IT"
            case .jaJp: return "ja-JP"
            case .koKr: return "ko-KR"
            case .ptBr: return "pt-BR"
            case .ptPt: return "pt-PT"
            case .zhCn: return "zh-CN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VocabularyLanguageCode(rawValue: rawValue) ?? VocabularyLanguageCode.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes {
    public enum VocabularyState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creationFailed
        case creationInProgress
        case deleteInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [VocabularyState] {
            return [
                .active,
                .creationFailed,
                .creationInProgress,
                .deleteInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creationFailed: return "CREATION_FAILED"
            case .creationInProgress: return "CREATION_IN_PROGRESS"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VocabularyState(rawValue: rawValue) ?? VocabularyState.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.VocabularySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case failureReason = "FailureReason"
        case id = "Id"
        case languageCode = "LanguageCode"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.VocabularyLanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.VocabularyState.self, forKey: .state)
        state = stateDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension ConnectClientTypes {
    /// Contains summary information about the custom vocabulary.
    public struct VocabularySummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the custom vocabulary.
        /// This member is required.
        public var arn: Swift.String?
        /// The reason why the custom vocabulary was not created.
        public var failureReason: Swift.String?
        /// The identifier of the custom vocabulary.
        /// This member is required.
        public var id: Swift.String?
        /// The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see [What is Amazon Transcribe?](https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html)
        /// This member is required.
        public var languageCode: ConnectClientTypes.VocabularyLanguageCode?
        /// The timestamp when the custom vocabulary was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// A unique name of the custom vocabulary.
        /// This member is required.
        public var name: Swift.String?
        /// The current state of the custom vocabulary.
        /// This member is required.
        public var state: ConnectClientTypes.VocabularyState?

        public init(
            arn: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            id: Swift.String? = nil,
            languageCode: ConnectClientTypes.VocabularyLanguageCode? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            state: ConnectClientTypes.VocabularyState? = nil
        )
        {
            self.arn = arn
            self.failureReason = failureReason
            self.id = id
            self.languageCode = languageCode
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.state = state
        }
    }

}

extension ConnectClientTypes.VoiceRecordingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceRecordingTrack = "VoiceRecordingTrack"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let voiceRecordingTrack = self.voiceRecordingTrack {
            try encodeContainer.encode(voiceRecordingTrack.rawValue, forKey: .voiceRecordingTrack)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceRecordingTrackDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.VoiceRecordingTrack.self, forKey: .voiceRecordingTrack)
        voiceRecordingTrack = voiceRecordingTrackDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about the recording configuration settings.
    public struct VoiceRecordingConfiguration: Swift.Equatable {
        /// Identifies which track is being recorded.
        public var voiceRecordingTrack: ConnectClientTypes.VoiceRecordingTrack?

        public init(
            voiceRecordingTrack: ConnectClientTypes.VoiceRecordingTrack? = nil
        )
        {
            self.voiceRecordingTrack = voiceRecordingTrack
        }
    }

}

extension ConnectClientTypes {
    public enum VoiceRecordingTrack: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case fromAgent
        case toAgent
        case sdkUnknown(Swift.String)

        public static var allCases: [VoiceRecordingTrack] {
            return [
                .all,
                .fromAgent,
                .toAgent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .fromAgent: return "FROM_AGENT"
            case .toAgent: return "TO_AGENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VoiceRecordingTrack(rawValue: rawValue) ?? VoiceRecordingTrack.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.WisdomInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionArn = "SessionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sessionArn = self.sessionArn {
            try encodeContainer.encode(sessionArn, forKey: .sessionArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionArn)
        sessionArn = sessionArnDecoded
    }
}

extension ConnectClientTypes {
    /// Information about Amazon Connect Wisdom.
    public struct WisdomInfo: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Wisdom session.
        public var sessionArn: Swift.String?

        public init(
            sessionArn: Swift.String? = nil
        )
        {
            self.sessionArn = sessionArn
        }
    }

}
