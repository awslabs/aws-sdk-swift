// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime
import SmithyJSON
import SmithyReadWrite
import SmithyRetries
import typealias Foundation.TimeInterval

extension DeleteLexiconInput {

    static func urlPathProvider(_ value: DeleteLexiconInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/v1/lexicons/\(name.urlPercentEncoding())"
    }
}

public struct DeleteLexiconInput {
    /// The name of the lexicon to delete. Must be an existing lexicon in the region.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

extension DeleteLexiconOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteLexiconOutput {
        return DeleteLexiconOutput()
    }
}

public struct DeleteLexiconOutput {

    public init() { }
}

enum DeleteLexiconOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LexiconNotFoundException": return try LexiconNotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DescribeVoicesInput {

    static func queryItemProvider(_ value: DescribeVoicesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let languageCode = value.languageCode {
            let languageCodeQueryItem = ClientRuntime.SDKURLQueryItem(name: "LanguageCode".urlPercentEncoding(), value: Swift.String(languageCode.rawValue).urlPercentEncoding())
            items.append(languageCodeQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let engine = value.engine {
            let engineQueryItem = ClientRuntime.SDKURLQueryItem(name: "Engine".urlPercentEncoding(), value: Swift.String(engine.rawValue).urlPercentEncoding())
            items.append(engineQueryItem)
        }
        if let includeAdditionalLanguageCodes = value.includeAdditionalLanguageCodes {
            let includeAdditionalLanguageCodesQueryItem = ClientRuntime.SDKURLQueryItem(name: "IncludeAdditionalLanguageCodes".urlPercentEncoding(), value: Swift.String(includeAdditionalLanguageCodes).urlPercentEncoding())
            items.append(includeAdditionalLanguageCodesQueryItem)
        }
        return items
    }
}

extension DescribeVoicesInput {

    static func urlPathProvider(_ value: DescribeVoicesInput) -> Swift.String? {
        return "/v1/voices"
    }
}

public struct DescribeVoicesInput {
    /// Specifies the engine (standard, neural, long-form or generative) used by Amazon Polly when processing input text for speech synthesis.
    public var engine: PollyClientTypes.Engine?
    /// Boolean value indicating whether to return any bilingual voices that use the specified language as an additional language. For instance, if you request all languages that use US English (es-US), and there is an Italian voice that speaks both Italian (it-IT) and US English, that voice will be included if you specify yes but not if you specify no.
    public var includeAdditionalLanguageCodes: Swift.Bool?
    /// The language identification tag (ISO 639 code for the language name-ISO 3166 country code) for filtering the list of voices returned. If you don't specify this optional parameter, all available voices are returned.
    public var languageCode: PollyClientTypes.LanguageCode?
    /// An opaque pagination token returned from the previous DescribeVoices operation. If present, this indicates where to continue the listing.
    public var nextToken: Swift.String?

    public init(
        engine: PollyClientTypes.Engine? = nil,
        includeAdditionalLanguageCodes: Swift.Bool? = nil,
        languageCode: PollyClientTypes.LanguageCode? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.engine = engine
        self.includeAdditionalLanguageCodes = includeAdditionalLanguageCodes
        self.languageCode = languageCode
        self.nextToken = nextToken
    }
}

extension DescribeVoicesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DescribeVoicesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeVoicesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.voices = try reader["Voices"].readListIfPresent(memberReadingClosure: PollyClientTypes.Voice.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct DescribeVoicesOutput {
    /// The pagination token to use in the next request to continue the listing of voices. NextToken is returned only if the response is truncated.
    public var nextToken: Swift.String?
    /// A list of voices with their properties.
    public var voices: [PollyClientTypes.Voice]?

    public init(
        nextToken: Swift.String? = nil,
        voices: [PollyClientTypes.Voice]? = nil
    )
    {
        self.nextToken = nextToken
        self.voices = voices
    }
}

enum DescribeVoicesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension PollyClientTypes {

    public enum Engine: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case generative
        case longForm
        case neural
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [Engine] {
            return [
                .generative,
                .longForm,
                .neural,
                .standard,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .generative: return "generative"
            case .longForm: return "long-form"
            case .neural: return "neural"
            case .standard: return "standard"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension EngineNotSupportedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> EngineNotSupportedException {
        let reader = baseError.errorBodyReader
        var value = EngineNotSupportedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// This engine is not compatible with the voice that you have designated. Choose a new voice that is compatible with the engine or change the engine and restart the operation.
public struct EngineNotSupportedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EngineNotSupportedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension PollyClientTypes {

    public enum Gender: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case female
        case male
        case sdkUnknown(Swift.String)

        public static var allCases: [Gender] {
            return [
                .female,
                .male,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .female: return "Female"
            case .male: return "Male"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GetLexiconInput {

    static func urlPathProvider(_ value: GetLexiconInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/v1/lexicons/\(name.urlPercentEncoding())"
    }
}

public struct GetLexiconInput {
    /// Name of the lexicon.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

extension GetLexiconOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetLexiconOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLexiconOutput()
        value.lexicon = try reader["Lexicon"].readIfPresent(with: PollyClientTypes.Lexicon.read(from:))
        value.lexiconAttributes = try reader["LexiconAttributes"].readIfPresent(with: PollyClientTypes.LexiconAttributes.read(from:))
        return value
    }
}

public struct GetLexiconOutput {
    /// Lexicon object that provides name and the string content of the lexicon.
    public var lexicon: PollyClientTypes.Lexicon?
    /// Metadata of the lexicon, including phonetic alphabetic used, language code, lexicon ARN, number of lexemes defined in the lexicon, and size of lexicon in bytes.
    public var lexiconAttributes: PollyClientTypes.LexiconAttributes?

    public init(
        lexicon: PollyClientTypes.Lexicon? = nil,
        lexiconAttributes: PollyClientTypes.LexiconAttributes? = nil
    )
    {
        self.lexicon = lexicon
        self.lexiconAttributes = lexiconAttributes
    }
}

enum GetLexiconOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LexiconNotFoundException": return try LexiconNotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetSpeechSynthesisTaskInput {

    static func urlPathProvider(_ value: GetSpeechSynthesisTaskInput) -> Swift.String? {
        guard let taskId = value.taskId else {
            return nil
        }
        return "/v1/synthesisTasks/\(taskId.urlPercentEncoding())"
    }
}

public struct GetSpeechSynthesisTaskInput {
    /// The Amazon Polly generated identifier for a speech synthesis task.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

extension GetSpeechSynthesisTaskOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetSpeechSynthesisTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSpeechSynthesisTaskOutput()
        value.synthesisTask = try reader["SynthesisTask"].readIfPresent(with: PollyClientTypes.SynthesisTask.read(from:))
        return value
    }
}

public struct GetSpeechSynthesisTaskOutput {
    /// SynthesisTask object that provides information from the requested task, including output format, creation time, task status, and so on.
    public var synthesisTask: PollyClientTypes.SynthesisTask?

    public init(
        synthesisTask: PollyClientTypes.SynthesisTask? = nil
    )
    {
        self.synthesisTask = synthesisTask
    }
}

enum GetSpeechSynthesisTaskOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidTaskIdException": return try InvalidTaskIdException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "SynthesisTaskNotFoundException": return try SynthesisTaskNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InvalidLexiconException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidLexiconException {
        let reader = baseError.errorBodyReader
        var value = InvalidLexiconException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// Amazon Polly can't find the specified lexicon. Verify that the lexicon's name is spelled correctly, and then try again.
public struct InvalidLexiconException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidLexiconException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidNextTokenException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidNextTokenException {
        let reader = baseError.errorBodyReader
        var value = InvalidNextTokenException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The NextToken is invalid. Verify that it's spelled correctly, and then try again.
public struct InvalidNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNextTokenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidS3BucketException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidS3BucketException {
        let reader = baseError.errorBodyReader
        var value = InvalidS3BucketException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The provided Amazon S3 bucket name is invalid. Please check your input with S3 bucket naming requirements and try again.
public struct InvalidS3BucketException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidS3BucketException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidS3KeyException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidS3KeyException {
        let reader = baseError.errorBodyReader
        var value = InvalidS3KeyException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The provided Amazon S3 key prefix is invalid. Please provide a valid S3 object key name.
public struct InvalidS3KeyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidS3KeyException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidSampleRateException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidSampleRateException {
        let reader = baseError.errorBodyReader
        var value = InvalidSampleRateException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The specified sample rate is not valid.
public struct InvalidSampleRateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSampleRateException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidSnsTopicArnException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidSnsTopicArnException {
        let reader = baseError.errorBodyReader
        var value = InvalidSnsTopicArnException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The provided SNS topic ARN is invalid. Please provide a valid SNS topic ARN and try again.
public struct InvalidSnsTopicArnException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSnsTopicArnException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidSsmlException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidSsmlException {
        let reader = baseError.errorBodyReader
        var value = InvalidSsmlException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The SSML you provided is invalid. Verify the SSML syntax, spelling of tags and values, and then try again.
public struct InvalidSsmlException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSsmlException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidTaskIdException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidTaskIdException {
        let reader = baseError.errorBodyReader
        var value = InvalidTaskIdException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The provided Task ID is not valid. Please provide a valid Task ID and try again.
public struct InvalidTaskIdException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTaskIdException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension PollyClientTypes {

    public enum LanguageCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case arAe
        case arb
        case caEs
        case cmnCn
        case cyGb
        case daDk
        case deAt
        case deDe
        case enAu
        case enGb
        case enGbWls
        case enIe
        case enIn
        case enNz
        case enUs
        case enZa
        case esEs
        case esMx
        case esUs
        case fiFi
        case frBe
        case frCa
        case frFr
        case hiIn
        case isIs
        case itIt
        case jaJp
        case koKr
        case nbNo
        case nlBe
        case nlNl
        case plPl
        case ptBr
        case ptPt
        case roRo
        case ruRu
        case svSe
        case trTr
        case yueCn
        case sdkUnknown(Swift.String)

        public static var allCases: [LanguageCode] {
            return [
                .arAe,
                .arb,
                .caEs,
                .cmnCn,
                .cyGb,
                .daDk,
                .deAt,
                .deDe,
                .enAu,
                .enGb,
                .enGbWls,
                .enIe,
                .enIn,
                .enNz,
                .enUs,
                .enZa,
                .esEs,
                .esMx,
                .esUs,
                .fiFi,
                .frBe,
                .frCa,
                .frFr,
                .hiIn,
                .isIs,
                .itIt,
                .jaJp,
                .koKr,
                .nbNo,
                .nlBe,
                .nlNl,
                .plPl,
                .ptBr,
                .ptPt,
                .roRo,
                .ruRu,
                .svSe,
                .trTr,
                .yueCn,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .arAe: return "ar-AE"
            case .arb: return "arb"
            case .caEs: return "ca-ES"
            case .cmnCn: return "cmn-CN"
            case .cyGb: return "cy-GB"
            case .daDk: return "da-DK"
            case .deAt: return "de-AT"
            case .deDe: return "de-DE"
            case .enAu: return "en-AU"
            case .enGb: return "en-GB"
            case .enGbWls: return "en-GB-WLS"
            case .enIe: return "en-IE"
            case .enIn: return "en-IN"
            case .enNz: return "en-NZ"
            case .enUs: return "en-US"
            case .enZa: return "en-ZA"
            case .esEs: return "es-ES"
            case .esMx: return "es-MX"
            case .esUs: return "es-US"
            case .fiFi: return "fi-FI"
            case .frBe: return "fr-BE"
            case .frCa: return "fr-CA"
            case .frFr: return "fr-FR"
            case .hiIn: return "hi-IN"
            case .isIs: return "is-IS"
            case .itIt: return "it-IT"
            case .jaJp: return "ja-JP"
            case .koKr: return "ko-KR"
            case .nbNo: return "nb-NO"
            case .nlBe: return "nl-BE"
            case .nlNl: return "nl-NL"
            case .plPl: return "pl-PL"
            case .ptBr: return "pt-BR"
            case .ptPt: return "pt-PT"
            case .roRo: return "ro-RO"
            case .ruRu: return "ru-RU"
            case .svSe: return "sv-SE"
            case .trTr: return "tr-TR"
            case .yueCn: return "yue-CN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LanguageNotSupportedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> LanguageNotSupportedException {
        let reader = baseError.errorBodyReader
        var value = LanguageNotSupportedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The language specified is not currently supported by Amazon Polly in this capacity.
public struct LanguageNotSupportedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LanguageNotSupportedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension PollyClientTypes.Lexicon: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Lexicon(name: \(Swift.String(describing: name)), content: \"CONTENT_REDACTED\")"}
}

extension PollyClientTypes.Lexicon {

    static func read(from reader: SmithyJSON.Reader) throws -> PollyClientTypes.Lexicon {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PollyClientTypes.Lexicon()
        value.content = try reader["Content"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension PollyClientTypes {
    /// Provides lexicon name and lexicon content in string format. For more information, see [Pronunciation Lexicon Specification (PLS) Version 1.0](https://www.w3.org/TR/pronunciation-lexicon/).
    public struct Lexicon {
        /// Lexicon content in string format. The content of a lexicon must be in PLS format.
        public var content: Swift.String?
        /// Name of the lexicon.
        public var name: Swift.String?

        public init(
            content: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.content = content
            self.name = name
        }
    }

}

extension PollyClientTypes.LexiconAttributes {

    static func read(from reader: SmithyJSON.Reader) throws -> PollyClientTypes.LexiconAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PollyClientTypes.LexiconAttributes()
        value.alphabet = try reader["Alphabet"].readIfPresent()
        value.languageCode = try reader["LanguageCode"].readIfPresent()
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: .epochSeconds)
        value.lexiconArn = try reader["LexiconArn"].readIfPresent()
        value.lexemesCount = try reader["LexemesCount"].readIfPresent() ?? 0
        value.size = try reader["Size"].readIfPresent() ?? 0
        return value
    }
}

extension PollyClientTypes {
    /// Contains metadata describing the lexicon such as the number of lexemes, language code, and so on. For more information, see [Managing Lexicons](https://docs.aws.amazon.com/polly/latest/dg/managing-lexicons.html).
    public struct LexiconAttributes {
        /// Phonetic alphabet used in the lexicon. Valid values are ipa and x-sampa.
        public var alphabet: Swift.String?
        /// Language code that the lexicon applies to. A lexicon with a language code such as "en" would be applied to all English languages (en-GB, en-US, en-AUS, en-WLS, and so on.
        public var languageCode: PollyClientTypes.LanguageCode?
        /// Date lexicon was last modified (a timestamp value).
        public var lastModified: ClientRuntime.Date?
        /// Number of lexemes in the lexicon.
        public var lexemesCount: Swift.Int
        /// Amazon Resource Name (ARN) of the lexicon.
        public var lexiconArn: Swift.String?
        /// Total size of the lexicon, in characters.
        public var size: Swift.Int

        public init(
            alphabet: Swift.String? = nil,
            languageCode: PollyClientTypes.LanguageCode? = nil,
            lastModified: ClientRuntime.Date? = nil,
            lexemesCount: Swift.Int = 0,
            lexiconArn: Swift.String? = nil,
            size: Swift.Int = 0
        )
        {
            self.alphabet = alphabet
            self.languageCode = languageCode
            self.lastModified = lastModified
            self.lexemesCount = lexemesCount
            self.lexiconArn = lexiconArn
            self.size = size
        }
    }

}

extension PollyClientTypes.LexiconDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> PollyClientTypes.LexiconDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PollyClientTypes.LexiconDescription()
        value.name = try reader["Name"].readIfPresent()
        value.attributes = try reader["Attributes"].readIfPresent(with: PollyClientTypes.LexiconAttributes.read(from:))
        return value
    }
}

extension PollyClientTypes {
    /// Describes the content of the lexicon.
    public struct LexiconDescription {
        /// Provides lexicon metadata.
        public var attributes: PollyClientTypes.LexiconAttributes?
        /// Name of the lexicon.
        public var name: Swift.String?

        public init(
            attributes: PollyClientTypes.LexiconAttributes? = nil,
            name: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.name = name
        }
    }

}

extension LexiconNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> LexiconNotFoundException {
        let reader = baseError.errorBodyReader
        var value = LexiconNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// Amazon Polly can't find the specified lexicon. This could be caused by a lexicon that is missing, its name is misspelled or specifying a lexicon that is in a different region. Verify that the lexicon exists, is in the region (see [ListLexicons]) and that you spelled its name is spelled correctly. Then try again.
public struct LexiconNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LexiconNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension LexiconSizeExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> LexiconSizeExceededException {
        let reader = baseError.errorBodyReader
        var value = LexiconSizeExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The maximum size of the specified lexicon would be exceeded by this operation.
public struct LexiconSizeExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LexiconSizeExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ListLexiconsInput {

    static func queryItemProvider(_ value: ListLexiconsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListLexiconsInput {

    static func urlPathProvider(_ value: ListLexiconsInput) -> Swift.String? {
        return "/v1/lexicons"
    }
}

public struct ListLexiconsInput {
    /// An opaque pagination token returned from previous ListLexicons operation. If present, indicates where to continue the list of lexicons.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

extension ListLexiconsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListLexiconsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLexiconsOutput()
        value.lexicons = try reader["Lexicons"].readListIfPresent(memberReadingClosure: PollyClientTypes.LexiconDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListLexiconsOutput {
    /// A list of lexicon names and attributes.
    public var lexicons: [PollyClientTypes.LexiconDescription]?
    /// The pagination token to use in the next request to continue the listing of lexicons. NextToken is returned only if the response is truncated.
    public var nextToken: Swift.String?

    public init(
        lexicons: [PollyClientTypes.LexiconDescription]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.lexicons = lexicons
        self.nextToken = nextToken
    }
}

enum ListLexiconsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListSpeechSynthesisTasksInput {

    static func queryItemProvider(_ value: ListSpeechSynthesisTasksInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let status = value.status {
            let statusQueryItem = ClientRuntime.SDKURLQueryItem(name: "Status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListSpeechSynthesisTasksInput {

    static func urlPathProvider(_ value: ListSpeechSynthesisTasksInput) -> Swift.String? {
        return "/v1/synthesisTasks"
    }
}

public struct ListSpeechSynthesisTasksInput {
    /// Maximum number of speech synthesis tasks returned in a List operation.
    public var maxResults: Swift.Int?
    /// The pagination token to use in the next request to continue the listing of speech synthesis tasks.
    public var nextToken: Swift.String?
    /// Status of the speech synthesis tasks returned in a List operation
    public var status: PollyClientTypes.TaskStatus?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: PollyClientTypes.TaskStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

extension ListSpeechSynthesisTasksOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListSpeechSynthesisTasksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSpeechSynthesisTasksOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.synthesisTasks = try reader["SynthesisTasks"].readListIfPresent(memberReadingClosure: PollyClientTypes.SynthesisTask.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListSpeechSynthesisTasksOutput {
    /// An opaque pagination token returned from the previous List operation in this request. If present, this indicates where to continue the listing.
    public var nextToken: Swift.String?
    /// List of SynthesisTask objects that provides information from the specified task in the list request, including output format, creation time, task status, and so on.
    public var synthesisTasks: [PollyClientTypes.SynthesisTask]?

    public init(
        nextToken: Swift.String? = nil,
        synthesisTasks: [PollyClientTypes.SynthesisTask]? = nil
    )
    {
        self.nextToken = nextToken
        self.synthesisTasks = synthesisTasks
    }
}

enum ListSpeechSynthesisTasksOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension MarksNotSupportedForFormatException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> MarksNotSupportedForFormatException {
        let reader = baseError.errorBodyReader
        var value = MarksNotSupportedForFormatException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// Speech marks are not supported for the OutputFormat selected. Speech marks are only available for content in json format.
public struct MarksNotSupportedForFormatException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MarksNotSupportedForFormatException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension MaxLexemeLengthExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> MaxLexemeLengthExceededException {
        let reader = baseError.errorBodyReader
        var value = MaxLexemeLengthExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The maximum size of the lexeme would be exceeded by this operation.
public struct MaxLexemeLengthExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MaxLexemeLengthExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension MaxLexiconsNumberExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> MaxLexiconsNumberExceededException {
        let reader = baseError.errorBodyReader
        var value = MaxLexiconsNumberExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The maximum number of lexicons would be exceeded by this operation.
public struct MaxLexiconsNumberExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MaxLexiconsNumberExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension PollyClientTypes {

    public enum OutputFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case json
        case mp3
        case oggVorbis
        case pcm
        case sdkUnknown(Swift.String)

        public static var allCases: [OutputFormat] {
            return [
                .json,
                .mp3,
                .oggVorbis,
                .pcm,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .json: return "json"
            case .mp3: return "mp3"
            case .oggVorbis: return "ogg_vorbis"
            case .pcm: return "pcm"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public enum PollyClientTypes {}

extension PutLexiconInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutLexiconInput(name: \(Swift.String(describing: name)), content: \"CONTENT_REDACTED\")"}
}

extension PutLexiconInput {

    static func urlPathProvider(_ value: PutLexiconInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/v1/lexicons/\(name.urlPercentEncoding())"
    }
}

extension PutLexiconInput {

    static func write(value: PutLexiconInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Content"].write(value.content)
    }
}

public struct PutLexiconInput {
    /// Content of the PLS lexicon as string data.
    /// This member is required.
    public var content: Swift.String?
    /// Name of the lexicon. The name must follow the regular express format [0-9A-Za-z]{1,20}. That is, the name is a case-sensitive alphanumeric string up to 20 characters long.
    /// This member is required.
    public var name: Swift.String?

    public init(
        content: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.content = content
        self.name = name
    }
}

extension PutLexiconOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> PutLexiconOutput {
        return PutLexiconOutput()
    }
}

public struct PutLexiconOutput {

    public init() { }
}

enum PutLexiconOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidLexiconException": return try InvalidLexiconException.makeError(baseError: baseError)
            case "LexiconSizeExceededException": return try LexiconSizeExceededException.makeError(baseError: baseError)
            case "MaxLexemeLengthExceededException": return try MaxLexemeLengthExceededException.makeError(baseError: baseError)
            case "MaxLexiconsNumberExceededException": return try MaxLexiconsNumberExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "UnsupportedPlsAlphabetException": return try UnsupportedPlsAlphabetException.makeError(baseError: baseError)
            case "UnsupportedPlsLanguageException": return try UnsupportedPlsLanguageException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ServiceFailureException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceFailureException {
        let reader = baseError.errorBodyReader
        var value = ServiceFailureException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// An unknown condition has caused a service failure.
public struct ServiceFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceFailureException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension PollyClientTypes {

    public enum SpeechMarkType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case sentence
        case ssml
        case viseme
        case word
        case sdkUnknown(Swift.String)

        public static var allCases: [SpeechMarkType] {
            return [
                .sentence,
                .ssml,
                .viseme,
                .word,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .sentence: return "sentence"
            case .ssml: return "ssml"
            case .viseme: return "viseme"
            case .word: return "word"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SsmlMarksNotSupportedForTextTypeException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> SsmlMarksNotSupportedForTextTypeException {
        let reader = baseError.errorBodyReader
        var value = SsmlMarksNotSupportedForTextTypeException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// SSML speech marks are not supported for plain text-type input.
public struct SsmlMarksNotSupportedForTextTypeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SsmlMarksNotSupportedForTextTypeException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension StartSpeechSynthesisTaskInput {

    static func urlPathProvider(_ value: StartSpeechSynthesisTaskInput) -> Swift.String? {
        return "/v1/synthesisTasks"
    }
}

extension StartSpeechSynthesisTaskInput {

    static func write(value: StartSpeechSynthesisTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Engine"].write(value.engine)
        try writer["LanguageCode"].write(value.languageCode)
        try writer["LexiconNames"].writeList(value.lexiconNames, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OutputFormat"].write(value.outputFormat)
        try writer["OutputS3BucketName"].write(value.outputS3BucketName)
        try writer["OutputS3KeyPrefix"].write(value.outputS3KeyPrefix)
        try writer["SampleRate"].write(value.sampleRate)
        try writer["SnsTopicArn"].write(value.snsTopicArn)
        try writer["SpeechMarkTypes"].writeList(value.speechMarkTypes, memberWritingClosure: PollyClientTypes.SpeechMarkType.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Text"].write(value.text)
        try writer["TextType"].write(value.textType)
        try writer["VoiceId"].write(value.voiceId)
    }
}

public struct StartSpeechSynthesisTaskInput {
    /// Specifies the engine (standard, neural, long-form or generative) for Amazon Polly to use when processing input text for speech synthesis. Using a voice that is not supported for the engine selected will result in an error.
    public var engine: PollyClientTypes.Engine?
    /// Optional language code for the Speech Synthesis request. This is only necessary if using a bilingual voice, such as Aditi, which can be used for either Indian English (en-IN) or Hindi (hi-IN). If a bilingual voice is used and no language code is specified, Amazon Polly uses the default language of the bilingual voice. The default language for any voice is the one returned by the [DescribeVoices](https://docs.aws.amazon.com/polly/latest/dg/API_DescribeVoices.html) operation for the LanguageCode parameter. For example, if no language code is specified, Aditi will use Indian English rather than Hindi.
    public var languageCode: PollyClientTypes.LanguageCode?
    /// List of one or more pronunciation lexicon names you want the service to apply during synthesis. Lexicons are applied only if the language of the lexicon is the same as the language of the voice.
    public var lexiconNames: [Swift.String]?
    /// The format in which the returned output will be encoded. For audio stream, this will be mp3, ogg_vorbis, or pcm. For speech marks, this will be json.
    /// This member is required.
    public var outputFormat: PollyClientTypes.OutputFormat?
    /// Amazon S3 bucket name to which the output file will be saved.
    /// This member is required.
    public var outputS3BucketName: Swift.String?
    /// The Amazon S3 key prefix for the output speech file.
    public var outputS3KeyPrefix: Swift.String?
    /// The audio frequency specified in Hz. The valid values for mp3 and ogg_vorbis are "8000", "16000", "22050", and "24000". The default value for standard voices is "22050". The default value for neural voices is "24000". The default value for long-form voices is "24000". The default value for generative voices is "24000". Valid values for pcm are "8000" and "16000" The default value is "16000".
    public var sampleRate: Swift.String?
    /// ARN for the SNS topic optionally used for providing status notification for a speech synthesis task.
    public var snsTopicArn: Swift.String?
    /// The type of speech marks returned for the input text.
    public var speechMarkTypes: [PollyClientTypes.SpeechMarkType]?
    /// The input text to synthesize. If you specify ssml as the TextType, follow the SSML format for the input text.
    /// This member is required.
    public var text: Swift.String?
    /// Specifies whether the input text is plain text or SSML. The default value is plain text.
    public var textType: PollyClientTypes.TextType?
    /// Voice ID to use for the synthesis.
    /// This member is required.
    public var voiceId: PollyClientTypes.VoiceId?

    public init(
        engine: PollyClientTypes.Engine? = nil,
        languageCode: PollyClientTypes.LanguageCode? = nil,
        lexiconNames: [Swift.String]? = nil,
        outputFormat: PollyClientTypes.OutputFormat? = nil,
        outputS3BucketName: Swift.String? = nil,
        outputS3KeyPrefix: Swift.String? = nil,
        sampleRate: Swift.String? = nil,
        snsTopicArn: Swift.String? = nil,
        speechMarkTypes: [PollyClientTypes.SpeechMarkType]? = nil,
        text: Swift.String? = nil,
        textType: PollyClientTypes.TextType? = nil,
        voiceId: PollyClientTypes.VoiceId? = nil
    )
    {
        self.engine = engine
        self.languageCode = languageCode
        self.lexiconNames = lexiconNames
        self.outputFormat = outputFormat
        self.outputS3BucketName = outputS3BucketName
        self.outputS3KeyPrefix = outputS3KeyPrefix
        self.sampleRate = sampleRate
        self.snsTopicArn = snsTopicArn
        self.speechMarkTypes = speechMarkTypes
        self.text = text
        self.textType = textType
        self.voiceId = voiceId
    }
}

extension StartSpeechSynthesisTaskOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> StartSpeechSynthesisTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartSpeechSynthesisTaskOutput()
        value.synthesisTask = try reader["SynthesisTask"].readIfPresent(with: PollyClientTypes.SynthesisTask.read(from:))
        return value
    }
}

public struct StartSpeechSynthesisTaskOutput {
    /// SynthesisTask object that provides information and attributes about a newly submitted speech synthesis task.
    public var synthesisTask: PollyClientTypes.SynthesisTask?

    public init(
        synthesisTask: PollyClientTypes.SynthesisTask? = nil
    )
    {
        self.synthesisTask = synthesisTask
    }
}

enum StartSpeechSynthesisTaskOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EngineNotSupportedException": return try EngineNotSupportedException.makeError(baseError: baseError)
            case "InvalidS3BucketException": return try InvalidS3BucketException.makeError(baseError: baseError)
            case "InvalidS3KeyException": return try InvalidS3KeyException.makeError(baseError: baseError)
            case "InvalidSampleRateException": return try InvalidSampleRateException.makeError(baseError: baseError)
            case "InvalidSnsTopicArnException": return try InvalidSnsTopicArnException.makeError(baseError: baseError)
            case "InvalidSsmlException": return try InvalidSsmlException.makeError(baseError: baseError)
            case "LanguageNotSupportedException": return try LanguageNotSupportedException.makeError(baseError: baseError)
            case "LexiconNotFoundException": return try LexiconNotFoundException.makeError(baseError: baseError)
            case "MarksNotSupportedForFormatException": return try MarksNotSupportedForFormatException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "SsmlMarksNotSupportedForTextTypeException": return try SsmlMarksNotSupportedForTextTypeException.makeError(baseError: baseError)
            case "TextLengthExceededException": return try TextLengthExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension PollyClientTypes.SynthesisTask {

    static func read(from reader: SmithyJSON.Reader) throws -> PollyClientTypes.SynthesisTask {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PollyClientTypes.SynthesisTask()
        value.engine = try reader["Engine"].readIfPresent()
        value.taskId = try reader["TaskId"].readIfPresent()
        value.taskStatus = try reader["TaskStatus"].readIfPresent()
        value.taskStatusReason = try reader["TaskStatusReason"].readIfPresent()
        value.outputUri = try reader["OutputUri"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: .epochSeconds)
        value.requestCharacters = try reader["RequestCharacters"].readIfPresent() ?? 0
        value.snsTopicArn = try reader["SnsTopicArn"].readIfPresent()
        value.lexiconNames = try reader["LexiconNames"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.outputFormat = try reader["OutputFormat"].readIfPresent()
        value.sampleRate = try reader["SampleRate"].readIfPresent()
        value.speechMarkTypes = try reader["SpeechMarkTypes"].readListIfPresent(memberReadingClosure: PollyClientTypes.SpeechMarkType.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.textType = try reader["TextType"].readIfPresent()
        value.voiceId = try reader["VoiceId"].readIfPresent()
        value.languageCode = try reader["LanguageCode"].readIfPresent()
        return value
    }
}

extension PollyClientTypes {
    /// SynthesisTask object that provides information about a speech synthesis task.
    public struct SynthesisTask {
        /// Timestamp for the time the synthesis task was started.
        public var creationTime: ClientRuntime.Date?
        /// Specifies the engine (standard, neural, long-form or generative) for Amazon Polly to use when processing input text for speech synthesis. Using a voice that is not supported for the engine selected will result in an error.
        public var engine: PollyClientTypes.Engine?
        /// Optional language code for a synthesis task. This is only necessary if using a bilingual voice, such as Aditi, which can be used for either Indian English (en-IN) or Hindi (hi-IN). If a bilingual voice is used and no language code is specified, Amazon Polly uses the default language of the bilingual voice. The default language for any voice is the one returned by the [DescribeVoices](https://docs.aws.amazon.com/polly/latest/dg/API_DescribeVoices.html) operation for the LanguageCode parameter. For example, if no language code is specified, Aditi will use Indian English rather than Hindi.
        public var languageCode: PollyClientTypes.LanguageCode?
        /// List of one or more pronunciation lexicon names you want the service to apply during synthesis. Lexicons are applied only if the language of the lexicon is the same as the language of the voice.
        public var lexiconNames: [Swift.String]?
        /// The format in which the returned output will be encoded. For audio stream, this will be mp3, ogg_vorbis, or pcm. For speech marks, this will be json.
        public var outputFormat: PollyClientTypes.OutputFormat?
        /// Pathway for the output speech file.
        public var outputUri: Swift.String?
        /// Number of billable characters synthesized.
        public var requestCharacters: Swift.Int
        /// The audio frequency specified in Hz. The valid values for mp3 and ogg_vorbis are "8000", "16000", "22050", and "24000". The default value for standard voices is "22050". The default value for neural voices is "24000". The default value for long-form voices is "24000". The default value for generative voices is "24000". Valid values for pcm are "8000" and "16000" The default value is "16000".
        public var sampleRate: Swift.String?
        /// ARN for the SNS topic optionally used for providing status notification for a speech synthesis task.
        public var snsTopicArn: Swift.String?
        /// The type of speech marks returned for the input text.
        public var speechMarkTypes: [PollyClientTypes.SpeechMarkType]?
        /// The Amazon Polly generated identifier for a speech synthesis task.
        public var taskId: Swift.String?
        /// Current status of the individual speech synthesis task.
        public var taskStatus: PollyClientTypes.TaskStatus?
        /// Reason for the current status of a specific speech synthesis task, including errors if the task has failed.
        public var taskStatusReason: Swift.String?
        /// Specifies whether the input text is plain text or SSML. The default value is plain text.
        public var textType: PollyClientTypes.TextType?
        /// Voice ID to use for the synthesis.
        public var voiceId: PollyClientTypes.VoiceId?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            engine: PollyClientTypes.Engine? = nil,
            languageCode: PollyClientTypes.LanguageCode? = nil,
            lexiconNames: [Swift.String]? = nil,
            outputFormat: PollyClientTypes.OutputFormat? = nil,
            outputUri: Swift.String? = nil,
            requestCharacters: Swift.Int = 0,
            sampleRate: Swift.String? = nil,
            snsTopicArn: Swift.String? = nil,
            speechMarkTypes: [PollyClientTypes.SpeechMarkType]? = nil,
            taskId: Swift.String? = nil,
            taskStatus: PollyClientTypes.TaskStatus? = nil,
            taskStatusReason: Swift.String? = nil,
            textType: PollyClientTypes.TextType? = nil,
            voiceId: PollyClientTypes.VoiceId? = nil
        )
        {
            self.creationTime = creationTime
            self.engine = engine
            self.languageCode = languageCode
            self.lexiconNames = lexiconNames
            self.outputFormat = outputFormat
            self.outputUri = outputUri
            self.requestCharacters = requestCharacters
            self.sampleRate = sampleRate
            self.snsTopicArn = snsTopicArn
            self.speechMarkTypes = speechMarkTypes
            self.taskId = taskId
            self.taskStatus = taskStatus
            self.taskStatusReason = taskStatusReason
            self.textType = textType
            self.voiceId = voiceId
        }
    }

}

extension SynthesisTaskNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> SynthesisTaskNotFoundException {
        let reader = baseError.errorBodyReader
        var value = SynthesisTaskNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The Speech Synthesis task with requested Task ID cannot be found.
public struct SynthesisTaskNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SynthesisTaskNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SynthesizeSpeechInput {
    public func presignURL(config: PollyClient.PollyClientConfiguration, expiration: Foundation.TimeInterval) async throws -> ClientRuntime.URL? {
        let serviceName = "Polly"
        let input = self
        let context = ClientRuntime.HttpContextBuilder()
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "synthesizeSpeech")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withPartitionID(value: config.partitionID)
                      .withAuthSchemes(value: config.authSchemes ?? [])
                      .withAuthSchemeResolver(value: config.authSchemeResolver)
                      .withUnsignedPayloadTrait(value: false)
                      .withSocketTimeout(value: config.httpClientConfiguration.socketTimeout)
                      .withFlowType(value: .PRESIGN_URL)
                      .withExpiration(value: expiration)
                      .withIdentityResolver(value: config.awsCredentialIdentityResolver, schemeID: "aws.auth#sigv4")
                      .withIdentityResolver(value: config.awsCredentialIdentityResolver, schemeID: "aws.auth#sigv4a")
                      .withRegion(value: config.region)
                      .withSigningName(value: "polly")
                      .withSigningRegion(value: config.signingRegion)
                      .build()
        var operation = ClientRuntime.OperationStack<SynthesizeSpeechInput, SynthesizeSpeechOutput>(id: "synthesizeSpeech")
        operation.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLPathMiddleware<SynthesizeSpeechInput, SynthesizeSpeechOutput>(SynthesizeSpeechInput.urlPathProvider(_:)))
        operation.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLHostMiddleware<SynthesizeSpeechInput, SynthesizeSpeechOutput>())
        let endpointParams = EndpointParams(endpoint: config.endpoint, region: config.region, useDualStack: config.useDualStack ?? false, useFIPS: config.useFIPS ?? false)
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware<SynthesizeSpeechOutput>(endpointResolver: config.endpointResolver, endpointParams: endpointParams))
        operation.buildStep.intercept(position: .before, middleware: ClientRuntime.AuthSchemeMiddleware<SynthesizeSpeechOutput>())
        operation.serializeStep.intercept(position: .after, middleware: SynthesizeSpeechInputGETQueryItemMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: ClientRuntime.RetryMiddleware<SmithyRetries.DefaultRetryStrategy, AWSClientRuntime.AWSRetryErrorInfoProvider, SynthesizeSpeechOutput>(options: config.retryStrategyOptions))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.SignerMiddleware<SynthesizeSpeechOutput>())
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware<SynthesizeSpeechOutput>(SynthesizeSpeechOutput.httpOutput(from:), SynthesizeSpeechOutputError.httpError(from:)))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.LoggerMiddleware<SynthesizeSpeechInput, SynthesizeSpeechOutput>(clientLogMode: config.clientLogMode))
        let presignedRequestBuilder = try await operation.presignedRequest(context: context, input: input, output: SynthesizeSpeechOutput(), next: ClientRuntime.NoopHandler())
        guard let builtRequest = presignedRequestBuilder?.build(), let presignedURL = builtRequest.endpoint.url else {
            return nil
        }
        return presignedURL
    }
}

extension SynthesizeSpeechInput {
    public func presign(config: PollyClient.PollyClientConfiguration, expiration: Foundation.TimeInterval) async throws -> ClientRuntime.SdkHttpRequest? {
        let serviceName = "Polly"
        let input = self
        let context = ClientRuntime.HttpContextBuilder()
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "synthesizeSpeech")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withPartitionID(value: config.partitionID)
                      .withAuthSchemes(value: config.authSchemes ?? [])
                      .withAuthSchemeResolver(value: config.authSchemeResolver)
                      .withUnsignedPayloadTrait(value: false)
                      .withSocketTimeout(value: config.httpClientConfiguration.socketTimeout)
                      .withFlowType(value: .PRESIGN_REQUEST)
                      .withExpiration(value: expiration)
                      .withIdentityResolver(value: config.awsCredentialIdentityResolver, schemeID: "aws.auth#sigv4")
                      .withIdentityResolver(value: config.awsCredentialIdentityResolver, schemeID: "aws.auth#sigv4a")
                      .withRegion(value: config.region)
                      .withSigningName(value: "polly")
                      .withSigningRegion(value: config.signingRegion)
                      .build()
        var operation = ClientRuntime.OperationStack<SynthesizeSpeechInput, SynthesizeSpeechOutput>(id: "synthesizeSpeech")
        operation.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLPathMiddleware<SynthesizeSpeechInput, SynthesizeSpeechOutput>(SynthesizeSpeechInput.urlPathProvider(_:)))
        operation.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLHostMiddleware<SynthesizeSpeechInput, SynthesizeSpeechOutput>())
        let endpointParams = EndpointParams(endpoint: config.endpoint, region: config.region, useDualStack: config.useDualStack ?? false, useFIPS: config.useFIPS ?? false)
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware<SynthesizeSpeechOutput>(endpointResolver: config.endpointResolver, endpointParams: endpointParams))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware<SynthesizeSpeechInput, SynthesizeSpeechOutput>(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromConfig(serviceID: serviceName, version: "1.0", config: config)))
        operation.buildStep.intercept(position: .before, middleware: ClientRuntime.AuthSchemeMiddleware<SynthesizeSpeechOutput>())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<SynthesizeSpeechInput, SynthesizeSpeechOutput>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .after, middleware: ClientRuntime.BodyMiddleware<SynthesizeSpeechInput, SynthesizeSpeechOutput, SmithyJSON.Writer>(rootNodeInfo: "", inputWritingClosure: SynthesizeSpeechInput.write(value:to:)))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware<SynthesizeSpeechInput, SynthesizeSpeechOutput>())
        operation.finalizeStep.intercept(position: .after, middleware: ClientRuntime.RetryMiddleware<SmithyRetries.DefaultRetryStrategy, AWSClientRuntime.AWSRetryErrorInfoProvider, SynthesizeSpeechOutput>(options: config.retryStrategyOptions))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.SignerMiddleware<SynthesizeSpeechOutput>())
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware<SynthesizeSpeechOutput>(SynthesizeSpeechOutput.httpOutput(from:), SynthesizeSpeechOutputError.httpError(from:)))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.LoggerMiddleware<SynthesizeSpeechInput, SynthesizeSpeechOutput>(clientLogMode: config.clientLogMode))
        let presignedRequestBuilder = try await operation.presignedRequest(context: context, input: input, output: SynthesizeSpeechOutput(), next: ClientRuntime.NoopHandler())
        guard let builtRequest = presignedRequestBuilder?.build() else {
            return nil
        }
        return builtRequest
    }
}

public struct SynthesizeSpeechInputGETQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SynthesizeSpeechInputGETQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SynthesizeSpeechInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<SynthesizeSpeechOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        try self.apply(input: input.operationInput, builder: input.builder, attributes: context)
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SynthesizeSpeechInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SynthesizeSpeechOutput>
    public typealias Context = ClientRuntime.HttpContext
}
extension SynthesizeSpeechInputGETQueryItemMiddleware: ClientRuntime.RequestMessageSerializer {
    public typealias InputType = SynthesizeSpeechInput
    public typealias RequestType = ClientRuntime.SdkHttpRequest
    public typealias AttributesType = ClientRuntime.HttpContext

    public func apply(input: InputType, builder: ClientRuntime.SdkHttpRequestBuilder, attributes: ClientRuntime.HttpContext) throws {
        if let engine = input.engine {
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "Engine".urlPercentEncoding(), value: Swift.String(engine.rawValue).urlPercentEncoding())
            builder.withQueryItem(queryItem)
        }
        if let languageCode = input.languageCode {
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "LanguageCode".urlPercentEncoding(), value: Swift.String(languageCode.rawValue).urlPercentEncoding())
            builder.withQueryItem(queryItem)
        }
        if let lexiconNames = input.lexiconNames {
            lexiconNames.forEach { item in
                let queryItem = ClientRuntime.SDKURLQueryItem(name: "LexiconNames".urlPercentEncoding(), value: Swift.String(item).urlPercentEncoding())
                builder.withQueryItem(queryItem)
            }
        }
        if let outputFormat = input.outputFormat {
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "OutputFormat".urlPercentEncoding(), value: Swift.String(outputFormat.rawValue).urlPercentEncoding())
            builder.withQueryItem(queryItem)
        }
        if let sampleRate = input.sampleRate {
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "SampleRate".urlPercentEncoding(), value: Swift.String(sampleRate).urlPercentEncoding())
            builder.withQueryItem(queryItem)
        }
        if let speechMarkTypes = input.speechMarkTypes {
            speechMarkTypes.forEach { item in
                let queryItem = ClientRuntime.SDKURLQueryItem(name: "SpeechMarkTypes".urlPercentEncoding(), value: Swift.String(item.rawValue).urlPercentEncoding())
                builder.withQueryItem(queryItem)
            }
        }
        if let text = input.text {
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "Text".urlPercentEncoding(), value: Swift.String(text).urlPercentEncoding())
            builder.withQueryItem(queryItem)
        }
        if let textType = input.textType {
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "TextType".urlPercentEncoding(), value: Swift.String(textType.rawValue).urlPercentEncoding())
            builder.withQueryItem(queryItem)
        }
        if let voiceId = input.voiceId {
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "VoiceId".urlPercentEncoding(), value: Swift.String(voiceId.rawValue).urlPercentEncoding())
            builder.withQueryItem(queryItem)
        }
    }
}

extension SynthesizeSpeechInput {

    static func urlPathProvider(_ value: SynthesizeSpeechInput) -> Swift.String? {
        return "/v1/speech"
    }
}

extension SynthesizeSpeechInput {

    static func write(value: SynthesizeSpeechInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Engine"].write(value.engine)
        try writer["LanguageCode"].write(value.languageCode)
        try writer["LexiconNames"].writeList(value.lexiconNames, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OutputFormat"].write(value.outputFormat)
        try writer["SampleRate"].write(value.sampleRate)
        try writer["SpeechMarkTypes"].writeList(value.speechMarkTypes, memberWritingClosure: PollyClientTypes.SpeechMarkType.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Text"].write(value.text)
        try writer["TextType"].write(value.textType)
        try writer["VoiceId"].write(value.voiceId)
    }
}

public struct SynthesizeSpeechInput {
    /// Specifies the engine (standard, neural, long-form, or generative) for Amazon Polly to use when processing input text for speech synthesis. Provide an engine that is supported by the voice you select. If you don't provide an engine, the standard engine is selected by default. If a chosen voice isn't supported by the standard engine, this will result in an error. For information on Amazon Polly voices and which voices are available for each engine, see [Available Voices](https://docs.aws.amazon.com/polly/latest/dg/voicelist.html). Type: String Valid Values: standard | neural | long-form | generative Required: Yes
    public var engine: PollyClientTypes.Engine?
    /// Optional language code for the Synthesize Speech request. This is only necessary if using a bilingual voice, such as Aditi, which can be used for either Indian English (en-IN) or Hindi (hi-IN). If a bilingual voice is used and no language code is specified, Amazon Polly uses the default language of the bilingual voice. The default language for any voice is the one returned by the [DescribeVoices](https://docs.aws.amazon.com/polly/latest/dg/API_DescribeVoices.html) operation for the LanguageCode parameter. For example, if no language code is specified, Aditi will use Indian English rather than Hindi.
    public var languageCode: PollyClientTypes.LanguageCode?
    /// List of one or more pronunciation lexicon names you want the service to apply during synthesis. Lexicons are applied only if the language of the lexicon is the same as the language of the voice. For information about storing lexicons, see [PutLexicon](https://docs.aws.amazon.com/polly/latest/dg/API_PutLexicon.html).
    public var lexiconNames: [Swift.String]?
    /// The format in which the returned output will be encoded. For audio stream, this will be mp3, ogg_vorbis, or pcm. For speech marks, this will be json. When pcm is used, the content returned is audio/pcm in a signed 16-bit, 1 channel (mono), little-endian format.
    /// This member is required.
    public var outputFormat: PollyClientTypes.OutputFormat?
    /// The audio frequency specified in Hz. The valid values for mp3 and ogg_vorbis are "8000", "16000", "22050", and "24000". The default value for standard voices is "22050". The default value for neural voices is "24000". The default value for long-form voices is "24000". The default value for generative voices is "24000". Valid values for pcm are "8000" and "16000" The default value is "16000".
    public var sampleRate: Swift.String?
    /// The type of speech marks returned for the input text.
    public var speechMarkTypes: [PollyClientTypes.SpeechMarkType]?
    /// Input text to synthesize. If you specify ssml as the TextType, follow the SSML format for the input text.
    /// This member is required.
    public var text: Swift.String?
    /// Specifies whether the input text is plain text or SSML. The default value is plain text. For more information, see [Using SSML](https://docs.aws.amazon.com/polly/latest/dg/ssml.html).
    public var textType: PollyClientTypes.TextType?
    /// Voice ID to use for the synthesis. You can get a list of available voice IDs by calling the [DescribeVoices](https://docs.aws.amazon.com/polly/latest/dg/API_DescribeVoices.html) operation.
    /// This member is required.
    public var voiceId: PollyClientTypes.VoiceId?

    public init(
        engine: PollyClientTypes.Engine? = nil,
        languageCode: PollyClientTypes.LanguageCode? = nil,
        lexiconNames: [Swift.String]? = nil,
        outputFormat: PollyClientTypes.OutputFormat? = nil,
        sampleRate: Swift.String? = nil,
        speechMarkTypes: [PollyClientTypes.SpeechMarkType]? = nil,
        text: Swift.String? = nil,
        textType: PollyClientTypes.TextType? = nil,
        voiceId: PollyClientTypes.VoiceId? = nil
    )
    {
        self.engine = engine
        self.languageCode = languageCode
        self.lexiconNames = lexiconNames
        self.outputFormat = outputFormat
        self.sampleRate = sampleRate
        self.speechMarkTypes = speechMarkTypes
        self.text = text
        self.textType = textType
        self.voiceId = voiceId
    }
}

extension SynthesizeSpeechOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> SynthesizeSpeechOutput {
        var value = SynthesizeSpeechOutput()
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            value.contentType = contentTypeHeaderValue
        }
        if let requestCharactersHeaderValue = httpResponse.headers.value(for: "x-amzn-RequestCharacters") {
            value.requestCharacters = Swift.Int(requestCharactersHeaderValue) ?? 0
        }
        switch httpResponse.body {
        case .data(let data):
            value.audioStream = .data(data)
        case .stream(let stream):
            value.audioStream = .stream(stream)
        case .noStream:
            value.audioStream = nil
        }
        return value
    }
}

public struct SynthesizeSpeechOutput {
    /// Stream containing the synthesized speech.
    public var audioStream: ClientRuntime.ByteStream?
    /// Specifies the type audio stream. This should reflect the OutputFormat parameter in your request.
    ///
    /// * If you request mp3 as the OutputFormat, the ContentType returned is audio/mpeg.
    ///
    /// * If you request ogg_vorbis as the OutputFormat, the ContentType returned is audio/ogg.
    ///
    /// * If you request pcm as the OutputFormat, the ContentType returned is audio/pcm in a signed 16-bit, 1 channel (mono), little-endian format.
    ///
    /// * If you request json as the OutputFormat, the ContentType returned is application/x-json-stream.
    public var contentType: Swift.String?
    /// Number of characters synthesized.
    public var requestCharacters: Swift.Int

    public init(
        audioStream: ClientRuntime.ByteStream? = nil,
        contentType: Swift.String? = nil,
        requestCharacters: Swift.Int = 0
    )
    {
        self.audioStream = audioStream
        self.contentType = contentType
        self.requestCharacters = requestCharacters
    }
}

enum SynthesizeSpeechOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EngineNotSupportedException": return try EngineNotSupportedException.makeError(baseError: baseError)
            case "InvalidSampleRateException": return try InvalidSampleRateException.makeError(baseError: baseError)
            case "InvalidSsmlException": return try InvalidSsmlException.makeError(baseError: baseError)
            case "LanguageNotSupportedException": return try LanguageNotSupportedException.makeError(baseError: baseError)
            case "LexiconNotFoundException": return try LexiconNotFoundException.makeError(baseError: baseError)
            case "MarksNotSupportedForFormatException": return try MarksNotSupportedForFormatException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "SsmlMarksNotSupportedForTextTypeException": return try SsmlMarksNotSupportedForTextTypeException.makeError(baseError: baseError)
            case "TextLengthExceededException": return try TextLengthExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension PollyClientTypes {

    public enum TaskStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case scheduled
        case sdkUnknown(Swift.String)

        public static var allCases: [TaskStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .scheduled,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "completed"
            case .failed: return "failed"
            case .inProgress: return "inProgress"
            case .scheduled: return "scheduled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TextLengthExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TextLengthExceededException {
        let reader = baseError.errorBodyReader
        var value = TextLengthExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The value of the "Text" parameter is longer than the accepted limits. For the SynthesizeSpeech API, the limit for input text is a maximum of 6000 characters total, of which no more than 3000 can be billed characters. For the StartSpeechSynthesisTask API, the maximum is 200,000 characters, of which no more than 100,000 can be billed characters. SSML tags are not counted as billed characters.
public struct TextLengthExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TextLengthExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension PollyClientTypes {

    public enum TextType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ssml
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [TextType] {
            return [
                .ssml,
                .text,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ssml: return "ssml"
            case .text: return "text"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension UnsupportedPlsAlphabetException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnsupportedPlsAlphabetException {
        let reader = baseError.errorBodyReader
        var value = UnsupportedPlsAlphabetException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The alphabet specified by the lexicon is not a supported alphabet. Valid values are x-sampa and ipa.
public struct UnsupportedPlsAlphabetException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedPlsAlphabetException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension UnsupportedPlsLanguageException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnsupportedPlsLanguageException {
        let reader = baseError.errorBodyReader
        var value = UnsupportedPlsLanguageException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The language specified in the lexicon is unsupported. For a list of supported languages, see [Lexicon Attributes](https://docs.aws.amazon.com/polly/latest/dg/API_LexiconAttributes.html).
public struct UnsupportedPlsLanguageException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedPlsLanguageException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension PollyClientTypes.Voice {

    static func read(from reader: SmithyJSON.Reader) throws -> PollyClientTypes.Voice {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PollyClientTypes.Voice()
        value.gender = try reader["Gender"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.languageCode = try reader["LanguageCode"].readIfPresent()
        value.languageName = try reader["LanguageName"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.additionalLanguageCodes = try reader["AdditionalLanguageCodes"].readListIfPresent(memberReadingClosure: PollyClientTypes.LanguageCode.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.supportedEngines = try reader["SupportedEngines"].readListIfPresent(memberReadingClosure: PollyClientTypes.Engine.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PollyClientTypes {
    /// Description of the voice.
    public struct Voice {
        /// Additional codes for languages available for the specified voice in addition to its default language. For example, the default language for Aditi is Indian English (en-IN) because it was first used for that language. Since Aditi is bilingual and fluent in both Indian English and Hindi, this parameter would show the code hi-IN.
        public var additionalLanguageCodes: [PollyClientTypes.LanguageCode]?
        /// Gender of the voice.
        public var gender: PollyClientTypes.Gender?
        /// Amazon Polly assigned voice ID. This is the ID that you specify when calling the SynthesizeSpeech operation.
        public var id: PollyClientTypes.VoiceId?
        /// Language code of the voice.
        public var languageCode: PollyClientTypes.LanguageCode?
        /// Human readable name of the language in English.
        public var languageName: Swift.String?
        /// Name of the voice (for example, Salli, Kendra, etc.). This provides a human readable voice name that you might display in your application.
        public var name: Swift.String?
        /// Specifies which engines (standard, neural, long-form or generative) are supported by a given voice.
        public var supportedEngines: [PollyClientTypes.Engine]?

        public init(
            additionalLanguageCodes: [PollyClientTypes.LanguageCode]? = nil,
            gender: PollyClientTypes.Gender? = nil,
            id: PollyClientTypes.VoiceId? = nil,
            languageCode: PollyClientTypes.LanguageCode? = nil,
            languageName: Swift.String? = nil,
            name: Swift.String? = nil,
            supportedEngines: [PollyClientTypes.Engine]? = nil
        )
        {
            self.additionalLanguageCodes = additionalLanguageCodes
            self.gender = gender
            self.id = id
            self.languageCode = languageCode
            self.languageName = languageName
            self.name = name
            self.supportedEngines = supportedEngines
        }
    }

}

extension PollyClientTypes {

    public enum VoiceId: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aditi
        case adriano
        case amy
        case andres
        case aria
        case arlet
        case arthur
        case astrid
        case ayanda
        case bianca
        case brian
        case burcu
        case camila
        case carla
        case carmen
        case celine
        case chantal
        case conchita
        case cristiano
        case daniel
        case danielle
        case dora
        case elin
        case emma
        case enrique
        case ewa
        case filiz
        case gabrielle
        case geraint
        case giorgio
        case gregory
        case gwyneth
        case hala
        case hannah
        case hans
        case hiujin
        case ida
        case ines
        case isabelle
        case ivy
        case jacek
        case jan
        case joanna
        case joey
        case justin
        case kajal
        case karl
        case kazuha
        case kendra
        case kevin
        case kimberly
        case laura
        case lea
        case liam
        case lisa
        case liv
        case lotte
        case lucia
        case lupe
        case mads
        case maja
        case marlene
        case mathieu
        case matthew
        case maxim
        case mia
        case miguel
        case mizuki
        case naja
        case niamh
        case nicole
        case ola
        case olivia
        case pedro
        case penelope
        case raveena
        case remi
        case ricardo
        case ruben
        case russell
        case ruth
        case salli
        case seoyeon
        case sergio
        case sofie
        case stephen
        case suvi
        case takumi
        case tatyana
        case thiago
        case tomoko
        case vicki
        case vitoria
        case zayd
        case zeina
        case zhiyu
        case sdkUnknown(Swift.String)

        public static var allCases: [VoiceId] {
            return [
                .aditi,
                .adriano,
                .amy,
                .andres,
                .aria,
                .arlet,
                .arthur,
                .astrid,
                .ayanda,
                .bianca,
                .brian,
                .burcu,
                .camila,
                .carla,
                .carmen,
                .celine,
                .chantal,
                .conchita,
                .cristiano,
                .daniel,
                .danielle,
                .dora,
                .elin,
                .emma,
                .enrique,
                .ewa,
                .filiz,
                .gabrielle,
                .geraint,
                .giorgio,
                .gregory,
                .gwyneth,
                .hala,
                .hannah,
                .hans,
                .hiujin,
                .ida,
                .ines,
                .isabelle,
                .ivy,
                .jacek,
                .jan,
                .joanna,
                .joey,
                .justin,
                .kajal,
                .karl,
                .kazuha,
                .kendra,
                .kevin,
                .kimberly,
                .laura,
                .lea,
                .liam,
                .lisa,
                .liv,
                .lotte,
                .lucia,
                .lupe,
                .mads,
                .maja,
                .marlene,
                .mathieu,
                .matthew,
                .maxim,
                .mia,
                .miguel,
                .mizuki,
                .naja,
                .niamh,
                .nicole,
                .ola,
                .olivia,
                .pedro,
                .penelope,
                .raveena,
                .remi,
                .ricardo,
                .ruben,
                .russell,
                .ruth,
                .salli,
                .seoyeon,
                .sergio,
                .sofie,
                .stephen,
                .suvi,
                .takumi,
                .tatyana,
                .thiago,
                .tomoko,
                .vicki,
                .vitoria,
                .zayd,
                .zeina,
                .zhiyu,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aditi: return "Aditi"
            case .adriano: return "Adriano"
            case .amy: return "Amy"
            case .andres: return "Andres"
            case .aria: return "Aria"
            case .arlet: return "Arlet"
            case .arthur: return "Arthur"
            case .astrid: return "Astrid"
            case .ayanda: return "Ayanda"
            case .bianca: return "Bianca"
            case .brian: return "Brian"
            case .burcu: return "Burcu"
            case .camila: return "Camila"
            case .carla: return "Carla"
            case .carmen: return "Carmen"
            case .celine: return "Celine"
            case .chantal: return "Chantal"
            case .conchita: return "Conchita"
            case .cristiano: return "Cristiano"
            case .daniel: return "Daniel"
            case .danielle: return "Danielle"
            case .dora: return "Dora"
            case .elin: return "Elin"
            case .emma: return "Emma"
            case .enrique: return "Enrique"
            case .ewa: return "Ewa"
            case .filiz: return "Filiz"
            case .gabrielle: return "Gabrielle"
            case .geraint: return "Geraint"
            case .giorgio: return "Giorgio"
            case .gregory: return "Gregory"
            case .gwyneth: return "Gwyneth"
            case .hala: return "Hala"
            case .hannah: return "Hannah"
            case .hans: return "Hans"
            case .hiujin: return "Hiujin"
            case .ida: return "Ida"
            case .ines: return "Ines"
            case .isabelle: return "Isabelle"
            case .ivy: return "Ivy"
            case .jacek: return "Jacek"
            case .jan: return "Jan"
            case .joanna: return "Joanna"
            case .joey: return "Joey"
            case .justin: return "Justin"
            case .kajal: return "Kajal"
            case .karl: return "Karl"
            case .kazuha: return "Kazuha"
            case .kendra: return "Kendra"
            case .kevin: return "Kevin"
            case .kimberly: return "Kimberly"
            case .laura: return "Laura"
            case .lea: return "Lea"
            case .liam: return "Liam"
            case .lisa: return "Lisa"
            case .liv: return "Liv"
            case .lotte: return "Lotte"
            case .lucia: return "Lucia"
            case .lupe: return "Lupe"
            case .mads: return "Mads"
            case .maja: return "Maja"
            case .marlene: return "Marlene"
            case .mathieu: return "Mathieu"
            case .matthew: return "Matthew"
            case .maxim: return "Maxim"
            case .mia: return "Mia"
            case .miguel: return "Miguel"
            case .mizuki: return "Mizuki"
            case .naja: return "Naja"
            case .niamh: return "Niamh"
            case .nicole: return "Nicole"
            case .ola: return "Ola"
            case .olivia: return "Olivia"
            case .pedro: return "Pedro"
            case .penelope: return "Penelope"
            case .raveena: return "Raveena"
            case .remi: return "Remi"
            case .ricardo: return "Ricardo"
            case .ruben: return "Ruben"
            case .russell: return "Russell"
            case .ruth: return "Ruth"
            case .salli: return "Salli"
            case .seoyeon: return "Seoyeon"
            case .sergio: return "Sergio"
            case .sofie: return "Sofie"
            case .stephen: return "Stephen"
            case .suvi: return "Suvi"
            case .takumi: return "Takumi"
            case .tatyana: return "Tatyana"
            case .thiago: return "Thiago"
            case .tomoko: return "Tomoko"
            case .vicki: return "Vicki"
            case .vitoria: return "Vitoria"
            case .zayd: return "Zayd"
            case .zeina: return "Zeina"
            case .zhiyu: return "Zhiyu"
            case let .sdkUnknown(s): return s
            }
        }
    }
}
