// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime
import typealias Foundation.TimeInterval

extension DeleteLexiconInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v1/lexicons/\(name.urlPercentEncoding())"
    }
}

public struct DeleteLexiconInput: Swift.Equatable {
    /// The name of the lexicon to delete. Must be an existing lexicon in the region.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteLexiconInputBody: Swift.Equatable {
}

extension DeleteLexiconInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteLexiconOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLexiconOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LexiconNotFoundException" : self = .lexiconNotFoundException(try LexiconNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteLexiconOutputError: Swift.Error, Swift.Equatable {
    case lexiconNotFoundException(LexiconNotFoundException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLexiconOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLexiconOutputResponse: Swift.Equatable {

    public init () { }
}

extension DescribeVoicesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let languageCode = languageCode {
                let languageCodeQueryItem = ClientRuntime.URLQueryItem(name: "LanguageCode".urlPercentEncoding(), value: Swift.String(languageCode.rawValue).urlPercentEncoding())
                items.append(languageCodeQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let engine = engine {
                let engineQueryItem = ClientRuntime.URLQueryItem(name: "Engine".urlPercentEncoding(), value: Swift.String(engine.rawValue).urlPercentEncoding())
                items.append(engineQueryItem)
            }
            if let includeAdditionalLanguageCodes = includeAdditionalLanguageCodes {
                let includeAdditionalLanguageCodesQueryItem = ClientRuntime.URLQueryItem(name: "IncludeAdditionalLanguageCodes".urlPercentEncoding(), value: Swift.String(includeAdditionalLanguageCodes).urlPercentEncoding())
                items.append(includeAdditionalLanguageCodesQueryItem)
            }
            return items
        }
    }
}

extension DescribeVoicesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/voices"
    }
}

public struct DescribeVoicesInput: Swift.Equatable {
    /// Specifies the engine (standard or neural) used by Amazon Polly when processing input text for speech synthesis.
    public var engine: PollyClientTypes.Engine?
    /// Boolean value indicating whether to return any bilingual voices that use the specified language as an additional language. For instance, if you request all languages that use US English (es-US), and there is an Italian voice that speaks both Italian (it-IT) and US English, that voice will be included if you specify yes but not if you specify no.
    public var includeAdditionalLanguageCodes: Swift.Bool?
    /// The language identification tag (ISO 639 code for the language name-ISO 3166 country code) for filtering the list of voices returned. If you don't specify this optional parameter, all available voices are returned.
    public var languageCode: PollyClientTypes.LanguageCode?
    /// An opaque pagination token returned from the previous DescribeVoices operation. If present, this indicates where to continue the listing.
    public var nextToken: Swift.String?

    public init (
        engine: PollyClientTypes.Engine? = nil,
        includeAdditionalLanguageCodes: Swift.Bool? = nil,
        languageCode: PollyClientTypes.LanguageCode? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.engine = engine
        self.includeAdditionalLanguageCodes = includeAdditionalLanguageCodes
        self.languageCode = languageCode
        self.nextToken = nextToken
    }
}

struct DescribeVoicesInputBody: Swift.Equatable {
}

extension DescribeVoicesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeVoicesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeVoicesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeVoicesOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeVoicesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeVoicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.voices = output.voices
        } else {
            self.nextToken = nil
            self.voices = nil
        }
    }
}

public struct DescribeVoicesOutputResponse: Swift.Equatable {
    /// The pagination token to use in the next request to continue the listing of voices. NextToken is returned only if the response is truncated.
    public var nextToken: Swift.String?
    /// A list of voices with their properties.
    public var voices: [PollyClientTypes.Voice]?

    public init (
        nextToken: Swift.String? = nil,
        voices: [PollyClientTypes.Voice]? = nil
    )
    {
        self.nextToken = nextToken
        self.voices = voices
    }
}

struct DescribeVoicesOutputResponseBody: Swift.Equatable {
    let voices: [PollyClientTypes.Voice]?
    let nextToken: Swift.String?
}

extension DescribeVoicesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case voices = "Voices"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voicesContainer = try containerValues.decodeIfPresent([PollyClientTypes.Voice?].self, forKey: .voices)
        var voicesDecoded0:[PollyClientTypes.Voice]? = nil
        if let voicesContainer = voicesContainer {
            voicesDecoded0 = [PollyClientTypes.Voice]()
            for structure0 in voicesContainer {
                if let structure0 = structure0 {
                    voicesDecoded0?.append(structure0)
                }
            }
        }
        voices = voicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension PollyClientTypes {
    public enum Engine: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case neural
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [Engine] {
            return [
                .neural,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .neural: return "neural"
            case .standard: return "standard"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Engine(rawValue: rawValue) ?? Engine.sdkUnknown(rawValue)
        }
    }
}

extension EngineNotSupportedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: EngineNotSupportedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This engine is not compatible with the voice that you have designated. Choose a new voice that is compatible with the engine or change the engine and restart the operation.
public struct EngineNotSupportedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EngineNotSupportedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EngineNotSupportedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PollyClientTypes {
    public enum Gender: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case female
        case male
        case sdkUnknown(Swift.String)

        public static var allCases: [Gender] {
            return [
                .female,
                .male,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .female: return "Female"
            case .male: return "Male"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Gender(rawValue: rawValue) ?? Gender.sdkUnknown(rawValue)
        }
    }
}

extension GetLexiconInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v1/lexicons/\(name.urlPercentEncoding())"
    }
}

public struct GetLexiconInput: Swift.Equatable {
    /// Name of the lexicon.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetLexiconInputBody: Swift.Equatable {
}

extension GetLexiconInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLexiconOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLexiconOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LexiconNotFoundException" : self = .lexiconNotFoundException(try LexiconNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetLexiconOutputError: Swift.Error, Swift.Equatable {
    case lexiconNotFoundException(LexiconNotFoundException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLexiconOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetLexiconOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lexicon = output.lexicon
            self.lexiconAttributes = output.lexiconAttributes
        } else {
            self.lexicon = nil
            self.lexiconAttributes = nil
        }
    }
}

public struct GetLexiconOutputResponse: Swift.Equatable {
    /// Lexicon object that provides name and the string content of the lexicon.
    public var lexicon: PollyClientTypes.Lexicon?
    /// Metadata of the lexicon, including phonetic alphabetic used, language code, lexicon ARN, number of lexemes defined in the lexicon, and size of lexicon in bytes.
    public var lexiconAttributes: PollyClientTypes.LexiconAttributes?

    public init (
        lexicon: PollyClientTypes.Lexicon? = nil,
        lexiconAttributes: PollyClientTypes.LexiconAttributes? = nil
    )
    {
        self.lexicon = lexicon
        self.lexiconAttributes = lexiconAttributes
    }
}

struct GetLexiconOutputResponseBody: Swift.Equatable {
    let lexicon: PollyClientTypes.Lexicon?
    let lexiconAttributes: PollyClientTypes.LexiconAttributes?
}

extension GetLexiconOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lexicon = "Lexicon"
        case lexiconAttributes = "LexiconAttributes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lexiconDecoded = try containerValues.decodeIfPresent(PollyClientTypes.Lexicon.self, forKey: .lexicon)
        lexicon = lexiconDecoded
        let lexiconAttributesDecoded = try containerValues.decodeIfPresent(PollyClientTypes.LexiconAttributes.self, forKey: .lexiconAttributes)
        lexiconAttributes = lexiconAttributesDecoded
    }
}

extension GetSpeechSynthesisTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let taskId = taskId else {
            return nil
        }
        return "/v1/synthesisTasks/\(taskId.urlPercentEncoding())"
    }
}

public struct GetSpeechSynthesisTaskInput: Swift.Equatable {
    /// The Amazon Polly generated identifier for a speech synthesis task.
    /// This member is required.
    public var taskId: Swift.String?

    public init (
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

struct GetSpeechSynthesisTaskInputBody: Swift.Equatable {
}

extension GetSpeechSynthesisTaskInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSpeechSynthesisTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSpeechSynthesisTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidTaskIdException" : self = .invalidTaskIdException(try InvalidTaskIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SynthesisTaskNotFoundException" : self = .synthesisTaskNotFoundException(try SynthesisTaskNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSpeechSynthesisTaskOutputError: Swift.Error, Swift.Equatable {
    case invalidTaskIdException(InvalidTaskIdException)
    case serviceFailureException(ServiceFailureException)
    case synthesisTaskNotFoundException(SynthesisTaskNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSpeechSynthesisTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSpeechSynthesisTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.synthesisTask = output.synthesisTask
        } else {
            self.synthesisTask = nil
        }
    }
}

public struct GetSpeechSynthesisTaskOutputResponse: Swift.Equatable {
    /// SynthesisTask object that provides information from the requested task, including output format, creation time, task status, and so on.
    public var synthesisTask: PollyClientTypes.SynthesisTask?

    public init (
        synthesisTask: PollyClientTypes.SynthesisTask? = nil
    )
    {
        self.synthesisTask = synthesisTask
    }
}

struct GetSpeechSynthesisTaskOutputResponseBody: Swift.Equatable {
    let synthesisTask: PollyClientTypes.SynthesisTask?
}

extension GetSpeechSynthesisTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case synthesisTask = "SynthesisTask"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let synthesisTaskDecoded = try containerValues.decodeIfPresent(PollyClientTypes.SynthesisTask.self, forKey: .synthesisTask)
        synthesisTask = synthesisTaskDecoded
    }
}

extension InvalidLexiconException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidLexiconExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Amazon Polly can't find the specified lexicon. Verify that the lexicon's name is spelled correctly, and then try again.
public struct InvalidLexiconException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidLexiconExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidLexiconExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The NextToken is invalid. Verify that it's spelled correctly, and then try again.
public struct InvalidNextTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidS3BucketException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidS3BucketExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The provided Amazon S3 bucket name is invalid. Please check your input with S3 bucket naming requirements and try again.
public struct InvalidS3BucketException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidS3BucketExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidS3BucketExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidS3KeyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidS3KeyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The provided Amazon S3 key prefix is invalid. Please provide a valid S3 object key name.
public struct InvalidS3KeyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidS3KeyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidS3KeyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSampleRateException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidSampleRateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified sample rate is not valid.
public struct InvalidSampleRateException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSampleRateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidSampleRateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSnsTopicArnException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidSnsTopicArnExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The provided SNS topic ARN is invalid. Please provide a valid SNS topic ARN and try again.
public struct InvalidSnsTopicArnException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSnsTopicArnExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidSnsTopicArnExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSsmlException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidSsmlExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The SSML you provided is invalid. Verify the SSML syntax, spelling of tags and values, and then try again.
public struct InvalidSsmlException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSsmlExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidSsmlExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTaskIdException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidTaskIdExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The provided Task ID is not valid. Please provide a valid Task ID and try again.
public struct InvalidTaskIdException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTaskIdExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTaskIdExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PollyClientTypes {
    public enum LanguageCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case arAe
        case arb
        case caEs
        case cmnCn
        case cyGb
        case daDk
        case deAt
        case deDe
        case enAu
        case enGb
        case enGbWls
        case enIn
        case enNz
        case enUs
        case enZa
        case esEs
        case esMx
        case esUs
        case fiFi
        case frCa
        case frFr
        case hiIn
        case isIs
        case itIt
        case jaJp
        case koKr
        case nbNo
        case nlNl
        case plPl
        case ptBr
        case ptPt
        case roRo
        case ruRu
        case svSe
        case trTr
        case yueCn
        case sdkUnknown(Swift.String)

        public static var allCases: [LanguageCode] {
            return [
                .arAe,
                .arb,
                .caEs,
                .cmnCn,
                .cyGb,
                .daDk,
                .deAt,
                .deDe,
                .enAu,
                .enGb,
                .enGbWls,
                .enIn,
                .enNz,
                .enUs,
                .enZa,
                .esEs,
                .esMx,
                .esUs,
                .fiFi,
                .frCa,
                .frFr,
                .hiIn,
                .isIs,
                .itIt,
                .jaJp,
                .koKr,
                .nbNo,
                .nlNl,
                .plPl,
                .ptBr,
                .ptPt,
                .roRo,
                .ruRu,
                .svSe,
                .trTr,
                .yueCn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .arAe: return "ar-AE"
            case .arb: return "arb"
            case .caEs: return "ca-ES"
            case .cmnCn: return "cmn-CN"
            case .cyGb: return "cy-GB"
            case .daDk: return "da-DK"
            case .deAt: return "de-AT"
            case .deDe: return "de-DE"
            case .enAu: return "en-AU"
            case .enGb: return "en-GB"
            case .enGbWls: return "en-GB-WLS"
            case .enIn: return "en-IN"
            case .enNz: return "en-NZ"
            case .enUs: return "en-US"
            case .enZa: return "en-ZA"
            case .esEs: return "es-ES"
            case .esMx: return "es-MX"
            case .esUs: return "es-US"
            case .fiFi: return "fi-FI"
            case .frCa: return "fr-CA"
            case .frFr: return "fr-FR"
            case .hiIn: return "hi-IN"
            case .isIs: return "is-IS"
            case .itIt: return "it-IT"
            case .jaJp: return "ja-JP"
            case .koKr: return "ko-KR"
            case .nbNo: return "nb-NO"
            case .nlNl: return "nl-NL"
            case .plPl: return "pl-PL"
            case .ptBr: return "pt-BR"
            case .ptPt: return "pt-PT"
            case .roRo: return "ro-RO"
            case .ruRu: return "ru-RU"
            case .svSe: return "sv-SE"
            case .trTr: return "tr-TR"
            case .yueCn: return "yue-CN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LanguageCode(rawValue: rawValue) ?? LanguageCode.sdkUnknown(rawValue)
        }
    }
}

extension LanguageNotSupportedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: LanguageNotSupportedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The language specified is not currently supported by Amazon Polly in this capacity.
public struct LanguageNotSupportedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LanguageNotSupportedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LanguageNotSupportedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PollyClientTypes.Lexicon: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension PollyClientTypes.Lexicon: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Lexicon(name: \(Swift.String(describing: name)), content: \"CONTENT_REDACTED\")"}
}

extension PollyClientTypes {
    /// Provides lexicon name and lexicon content in string format. For more information, see [Pronunciation Lexicon Specification (PLS) Version 1.0](https://www.w3.org/TR/pronunciation-lexicon/).
    public struct Lexicon: Swift.Equatable {
        /// Lexicon content in string format. The content of a lexicon must be in PLS format.
        public var content: Swift.String?
        /// Name of the lexicon.
        public var name: Swift.String?

        public init (
            content: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.content = content
            self.name = name
        }
    }

}

extension PollyClientTypes.LexiconAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alphabet = "Alphabet"
        case languageCode = "LanguageCode"
        case lastModified = "LastModified"
        case lexemesCount = "LexemesCount"
        case lexiconArn = "LexiconArn"
        case size = "Size"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alphabet = self.alphabet {
            try encodeContainer.encode(alphabet, forKey: .alphabet)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let lastModified = self.lastModified {
            try encodeContainer.encodeTimestamp(lastModified, format: .epochSeconds, forKey: .lastModified)
        }
        if lexemesCount != 0 {
            try encodeContainer.encode(lexemesCount, forKey: .lexemesCount)
        }
        if let lexiconArn = self.lexiconArn {
            try encodeContainer.encode(lexiconArn, forKey: .lexiconArn)
        }
        if size != 0 {
            try encodeContainer.encode(size, forKey: .size)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alphabetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alphabet)
        alphabet = alphabetDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(PollyClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let lexiconArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lexiconArn)
        lexiconArn = lexiconArnDecoded
        let lexemesCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lexemesCount) ?? 0
        lexemesCount = lexemesCountDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .size) ?? 0
        size = sizeDecoded
    }
}

extension PollyClientTypes {
    /// Contains metadata describing the lexicon such as the number of lexemes, language code, and so on. For more information, see [Managing Lexicons](https://docs.aws.amazon.com/polly/latest/dg/managing-lexicons.html).
    public struct LexiconAttributes: Swift.Equatable {
        /// Phonetic alphabet used in the lexicon. Valid values are ipa and x-sampa.
        public var alphabet: Swift.String?
        /// Language code that the lexicon applies to. A lexicon with a language code such as "en" would be applied to all English languages (en-GB, en-US, en-AUS, en-WLS, and so on.
        public var languageCode: PollyClientTypes.LanguageCode?
        /// Date lexicon was last modified (a timestamp value).
        public var lastModified: ClientRuntime.Date?
        /// Number of lexemes in the lexicon.
        public var lexemesCount: Swift.Int
        /// Amazon Resource Name (ARN) of the lexicon.
        public var lexiconArn: Swift.String?
        /// Total size of the lexicon, in characters.
        public var size: Swift.Int

        public init (
            alphabet: Swift.String? = nil,
            languageCode: PollyClientTypes.LanguageCode? = nil,
            lastModified: ClientRuntime.Date? = nil,
            lexemesCount: Swift.Int = 0,
            lexiconArn: Swift.String? = nil,
            size: Swift.Int = 0
        )
        {
            self.alphabet = alphabet
            self.languageCode = languageCode
            self.lastModified = lastModified
            self.lexemesCount = lexemesCount
            self.lexiconArn = lexiconArn
            self.size = size
        }
    }

}

extension PollyClientTypes.LexiconDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = self.attributes {
            try encodeContainer.encode(attributes, forKey: .attributes)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let attributesDecoded = try containerValues.decodeIfPresent(PollyClientTypes.LexiconAttributes.self, forKey: .attributes)
        attributes = attributesDecoded
    }
}

extension PollyClientTypes {
    /// Describes the content of the lexicon.
    public struct LexiconDescription: Swift.Equatable {
        /// Provides lexicon metadata.
        public var attributes: PollyClientTypes.LexiconAttributes?
        /// Name of the lexicon.
        public var name: Swift.String?

        public init (
            attributes: PollyClientTypes.LexiconAttributes? = nil,
            name: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.name = name
        }
    }

}

extension LexiconNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: LexiconNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Amazon Polly can't find the specified lexicon. This could be caused by a lexicon that is missing, its name is misspelled or specifying a lexicon that is in a different region. Verify that the lexicon exists, is in the region (see [ListLexicons]) and that you spelled its name is spelled correctly. Then try again.
public struct LexiconNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LexiconNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LexiconNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LexiconSizeExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: LexiconSizeExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum size of the specified lexicon would be exceeded by this operation.
public struct LexiconSizeExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LexiconSizeExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LexiconSizeExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListLexiconsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListLexiconsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/lexicons"
    }
}

public struct ListLexiconsInput: Swift.Equatable {
    /// An opaque pagination token returned from previous ListLexicons operation. If present, indicates where to continue the list of lexicons.
    public var nextToken: Swift.String?

    public init (
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListLexiconsInputBody: Swift.Equatable {
}

extension ListLexiconsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListLexiconsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLexiconsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListLexiconsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLexiconsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListLexiconsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lexicons = output.lexicons
            self.nextToken = output.nextToken
        } else {
            self.lexicons = nil
            self.nextToken = nil
        }
    }
}

public struct ListLexiconsOutputResponse: Swift.Equatable {
    /// A list of lexicon names and attributes.
    public var lexicons: [PollyClientTypes.LexiconDescription]?
    /// The pagination token to use in the next request to continue the listing of lexicons. NextToken is returned only if the response is truncated.
    public var nextToken: Swift.String?

    public init (
        lexicons: [PollyClientTypes.LexiconDescription]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.lexicons = lexicons
        self.nextToken = nextToken
    }
}

struct ListLexiconsOutputResponseBody: Swift.Equatable {
    let lexicons: [PollyClientTypes.LexiconDescription]?
    let nextToken: Swift.String?
}

extension ListLexiconsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lexicons = "Lexicons"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lexiconsContainer = try containerValues.decodeIfPresent([PollyClientTypes.LexiconDescription?].self, forKey: .lexicons)
        var lexiconsDecoded0:[PollyClientTypes.LexiconDescription]? = nil
        if let lexiconsContainer = lexiconsContainer {
            lexiconsDecoded0 = [PollyClientTypes.LexiconDescription]()
            for structure0 in lexiconsContainer {
                if let structure0 = structure0 {
                    lexiconsDecoded0?.append(structure0)
                }
            }
        }
        lexicons = lexiconsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSpeechSynthesisTasksInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "Status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListSpeechSynthesisTasksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/synthesisTasks"
    }
}

public struct ListSpeechSynthesisTasksInput: Swift.Equatable {
    /// Maximum number of speech synthesis tasks returned in a List operation.
    public var maxResults: Swift.Int?
    /// The pagination token to use in the next request to continue the listing of speech synthesis tasks.
    public var nextToken: Swift.String?
    /// Status of the speech synthesis tasks returned in a List operation
    public var status: PollyClientTypes.TaskStatus?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: PollyClientTypes.TaskStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

struct ListSpeechSynthesisTasksInputBody: Swift.Equatable {
}

extension ListSpeechSynthesisTasksInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSpeechSynthesisTasksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSpeechSynthesisTasksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSpeechSynthesisTasksOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSpeechSynthesisTasksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSpeechSynthesisTasksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.synthesisTasks = output.synthesisTasks
        } else {
            self.nextToken = nil
            self.synthesisTasks = nil
        }
    }
}

public struct ListSpeechSynthesisTasksOutputResponse: Swift.Equatable {
    /// An opaque pagination token returned from the previous List operation in this request. If present, this indicates where to continue the listing.
    public var nextToken: Swift.String?
    /// List of SynthesisTask objects that provides information from the specified task in the list request, including output format, creation time, task status, and so on.
    public var synthesisTasks: [PollyClientTypes.SynthesisTask]?

    public init (
        nextToken: Swift.String? = nil,
        synthesisTasks: [PollyClientTypes.SynthesisTask]? = nil
    )
    {
        self.nextToken = nextToken
        self.synthesisTasks = synthesisTasks
    }
}

struct ListSpeechSynthesisTasksOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let synthesisTasks: [PollyClientTypes.SynthesisTask]?
}

extension ListSpeechSynthesisTasksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case synthesisTasks = "SynthesisTasks"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let synthesisTasksContainer = try containerValues.decodeIfPresent([PollyClientTypes.SynthesisTask?].self, forKey: .synthesisTasks)
        var synthesisTasksDecoded0:[PollyClientTypes.SynthesisTask]? = nil
        if let synthesisTasksContainer = synthesisTasksContainer {
            synthesisTasksDecoded0 = [PollyClientTypes.SynthesisTask]()
            for structure0 in synthesisTasksContainer {
                if let structure0 = structure0 {
                    synthesisTasksDecoded0?.append(structure0)
                }
            }
        }
        synthesisTasks = synthesisTasksDecoded0
    }
}

extension MarksNotSupportedForFormatException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MarksNotSupportedForFormatExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Speech marks are not supported for the OutputFormat selected. Speech marks are only available for content in json format.
public struct MarksNotSupportedForFormatException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MarksNotSupportedForFormatExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MarksNotSupportedForFormatExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaxLexemeLengthExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MaxLexemeLengthExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum size of the lexeme would be exceeded by this operation.
public struct MaxLexemeLengthExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MaxLexemeLengthExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MaxLexemeLengthExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaxLexiconsNumberExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MaxLexiconsNumberExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum number of lexicons would be exceeded by this operation.
public struct MaxLexiconsNumberExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MaxLexiconsNumberExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MaxLexiconsNumberExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PollyClientTypes {
    public enum OutputFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case json
        case mp3
        case oggVorbis
        case pcm
        case sdkUnknown(Swift.String)

        public static var allCases: [OutputFormat] {
            return [
                .json,
                .mp3,
                .oggVorbis,
                .pcm,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .json: return "json"
            case .mp3: return "mp3"
            case .oggVorbis: return "ogg_vorbis"
            case .pcm: return "pcm"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OutputFormat(rawValue: rawValue) ?? OutputFormat.sdkUnknown(rawValue)
        }
    }
}

extension PutLexiconInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutLexiconInput(name: \(Swift.String(describing: name)), content: \"CONTENT_REDACTED\")"}
}

extension PutLexiconInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
    }
}

extension PutLexiconInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v1/lexicons/\(name.urlPercentEncoding())"
    }
}

public struct PutLexiconInput: Swift.Equatable {
    /// Content of the PLS lexicon as string data.
    /// This member is required.
    public var content: Swift.String?
    /// Name of the lexicon. The name must follow the regular express format [0-9A-Za-z]{1,20}. That is, the name is a case-sensitive alphanumeric string up to 20 characters long.
    /// This member is required.
    public var name: Swift.String?

    public init (
        content: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.content = content
        self.name = name
    }
}

struct PutLexiconInputBody: Swift.Equatable {
    let content: Swift.String?
}

extension PutLexiconInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
    }
}

extension PutLexiconOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutLexiconOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidLexiconException" : self = .invalidLexiconException(try InvalidLexiconException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LexiconSizeExceededException" : self = .lexiconSizeExceededException(try LexiconSizeExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaxLexemeLengthExceededException" : self = .maxLexemeLengthExceededException(try MaxLexemeLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaxLexiconsNumberExceededException" : self = .maxLexiconsNumberExceededException(try MaxLexiconsNumberExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedPlsAlphabetException" : self = .unsupportedPlsAlphabetException(try UnsupportedPlsAlphabetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedPlsLanguageException" : self = .unsupportedPlsLanguageException(try UnsupportedPlsLanguageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutLexiconOutputError: Swift.Error, Swift.Equatable {
    case invalidLexiconException(InvalidLexiconException)
    case lexiconSizeExceededException(LexiconSizeExceededException)
    case maxLexemeLengthExceededException(MaxLexemeLengthExceededException)
    case maxLexiconsNumberExceededException(MaxLexiconsNumberExceededException)
    case serviceFailureException(ServiceFailureException)
    case unsupportedPlsAlphabetException(UnsupportedPlsAlphabetException)
    case unsupportedPlsLanguageException(UnsupportedPlsLanguageException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutLexiconOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutLexiconOutputResponse: Swift.Equatable {

    public init () { }
}

extension ServiceFailureException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An unknown condition has caused a service failure.
public struct ServiceFailureException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceFailureExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PollyClientTypes {
    public enum SpeechMarkType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sentence
        case ssml
        case viseme
        case word
        case sdkUnknown(Swift.String)

        public static var allCases: [SpeechMarkType] {
            return [
                .sentence,
                .ssml,
                .viseme,
                .word,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sentence: return "sentence"
            case .ssml: return "ssml"
            case .viseme: return "viseme"
            case .word: return "word"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SpeechMarkType(rawValue: rawValue) ?? SpeechMarkType.sdkUnknown(rawValue)
        }
    }
}

extension SsmlMarksNotSupportedForTextTypeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SsmlMarksNotSupportedForTextTypeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// SSML speech marks are not supported for plain text-type input.
public struct SsmlMarksNotSupportedForTextTypeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SsmlMarksNotSupportedForTextTypeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension SsmlMarksNotSupportedForTextTypeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StartSpeechSynthesisTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engine = "Engine"
        case languageCode = "LanguageCode"
        case lexiconNames = "LexiconNames"
        case outputFormat = "OutputFormat"
        case outputS3BucketName = "OutputS3BucketName"
        case outputS3KeyPrefix = "OutputS3KeyPrefix"
        case sampleRate = "SampleRate"
        case snsTopicArn = "SnsTopicArn"
        case speechMarkTypes = "SpeechMarkTypes"
        case text = "Text"
        case textType = "TextType"
        case voiceId = "VoiceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engine = self.engine {
            try encodeContainer.encode(engine.rawValue, forKey: .engine)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let lexiconNames = lexiconNames {
            var lexiconNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lexiconNames)
            for lexiconname0 in lexiconNames {
                try lexiconNamesContainer.encode(lexiconname0)
            }
        }
        if let outputFormat = self.outputFormat {
            try encodeContainer.encode(outputFormat.rawValue, forKey: .outputFormat)
        }
        if let outputS3BucketName = self.outputS3BucketName {
            try encodeContainer.encode(outputS3BucketName, forKey: .outputS3BucketName)
        }
        if let outputS3KeyPrefix = self.outputS3KeyPrefix {
            try encodeContainer.encode(outputS3KeyPrefix, forKey: .outputS3KeyPrefix)
        }
        if let sampleRate = self.sampleRate {
            try encodeContainer.encode(sampleRate, forKey: .sampleRate)
        }
        if let snsTopicArn = self.snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let speechMarkTypes = speechMarkTypes {
            var speechMarkTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .speechMarkTypes)
            for speechmarktype0 in speechMarkTypes {
                try speechMarkTypesContainer.encode(speechmarktype0.rawValue)
            }
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let textType = self.textType {
            try encodeContainer.encode(textType.rawValue, forKey: .textType)
        }
        if let voiceId = self.voiceId {
            try encodeContainer.encode(voiceId.rawValue, forKey: .voiceId)
        }
    }
}

extension StartSpeechSynthesisTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/synthesisTasks"
    }
}

public struct StartSpeechSynthesisTaskInput: Swift.Equatable {
    /// Specifies the engine (standard or neural) for Amazon Polly to use when processing input text for speech synthesis. Using a voice that is not supported for the engine selected will result in an error.
    public var engine: PollyClientTypes.Engine?
    /// Optional language code for the Speech Synthesis request. This is only necessary if using a bilingual voice, such as Aditi, which can be used for either Indian English (en-IN) or Hindi (hi-IN). If a bilingual voice is used and no language code is specified, Amazon Polly uses the default language of the bilingual voice. The default language for any voice is the one returned by the [DescribeVoices](https://docs.aws.amazon.com/polly/latest/dg/API_DescribeVoices.html) operation for the LanguageCode parameter. For example, if no language code is specified, Aditi will use Indian English rather than Hindi.
    public var languageCode: PollyClientTypes.LanguageCode?
    /// List of one or more pronunciation lexicon names you want the service to apply during synthesis. Lexicons are applied only if the language of the lexicon is the same as the language of the voice.
    public var lexiconNames: [Swift.String]?
    /// The format in which the returned output will be encoded. For audio stream, this will be mp3, ogg_vorbis, or pcm. For speech marks, this will be json.
    /// This member is required.
    public var outputFormat: PollyClientTypes.OutputFormat?
    /// Amazon S3 bucket name to which the output file will be saved.
    /// This member is required.
    public var outputS3BucketName: Swift.String?
    /// The Amazon S3 key prefix for the output speech file.
    public var outputS3KeyPrefix: Swift.String?
    /// The audio frequency specified in Hz. The valid values for mp3 and ogg_vorbis are "8000", "16000", "22050", and "24000". The default value for standard voices is "22050". The default value for neural voices is "24000". Valid values for pcm are "8000" and "16000" The default value is "16000".
    public var sampleRate: Swift.String?
    /// ARN for the SNS topic optionally used for providing status notification for a speech synthesis task.
    public var snsTopicArn: Swift.String?
    /// The type of speech marks returned for the input text.
    public var speechMarkTypes: [PollyClientTypes.SpeechMarkType]?
    /// The input text to synthesize. If you specify ssml as the TextType, follow the SSML format for the input text.
    /// This member is required.
    public var text: Swift.String?
    /// Specifies whether the input text is plain text or SSML. The default value is plain text.
    public var textType: PollyClientTypes.TextType?
    /// Voice ID to use for the synthesis.
    /// This member is required.
    public var voiceId: PollyClientTypes.VoiceId?

    public init (
        engine: PollyClientTypes.Engine? = nil,
        languageCode: PollyClientTypes.LanguageCode? = nil,
        lexiconNames: [Swift.String]? = nil,
        outputFormat: PollyClientTypes.OutputFormat? = nil,
        outputS3BucketName: Swift.String? = nil,
        outputS3KeyPrefix: Swift.String? = nil,
        sampleRate: Swift.String? = nil,
        snsTopicArn: Swift.String? = nil,
        speechMarkTypes: [PollyClientTypes.SpeechMarkType]? = nil,
        text: Swift.String? = nil,
        textType: PollyClientTypes.TextType? = nil,
        voiceId: PollyClientTypes.VoiceId? = nil
    )
    {
        self.engine = engine
        self.languageCode = languageCode
        self.lexiconNames = lexiconNames
        self.outputFormat = outputFormat
        self.outputS3BucketName = outputS3BucketName
        self.outputS3KeyPrefix = outputS3KeyPrefix
        self.sampleRate = sampleRate
        self.snsTopicArn = snsTopicArn
        self.speechMarkTypes = speechMarkTypes
        self.text = text
        self.textType = textType
        self.voiceId = voiceId
    }
}

struct StartSpeechSynthesisTaskInputBody: Swift.Equatable {
    let engine: PollyClientTypes.Engine?
    let languageCode: PollyClientTypes.LanguageCode?
    let lexiconNames: [Swift.String]?
    let outputFormat: PollyClientTypes.OutputFormat?
    let outputS3BucketName: Swift.String?
    let outputS3KeyPrefix: Swift.String?
    let sampleRate: Swift.String?
    let snsTopicArn: Swift.String?
    let speechMarkTypes: [PollyClientTypes.SpeechMarkType]?
    let text: Swift.String?
    let textType: PollyClientTypes.TextType?
    let voiceId: PollyClientTypes.VoiceId?
}

extension StartSpeechSynthesisTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engine = "Engine"
        case languageCode = "LanguageCode"
        case lexiconNames = "LexiconNames"
        case outputFormat = "OutputFormat"
        case outputS3BucketName = "OutputS3BucketName"
        case outputS3KeyPrefix = "OutputS3KeyPrefix"
        case sampleRate = "SampleRate"
        case snsTopicArn = "SnsTopicArn"
        case speechMarkTypes = "SpeechMarkTypes"
        case text = "Text"
        case textType = "TextType"
        case voiceId = "VoiceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineDecoded = try containerValues.decodeIfPresent(PollyClientTypes.Engine.self, forKey: .engine)
        engine = engineDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(PollyClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let lexiconNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .lexiconNames)
        var lexiconNamesDecoded0:[Swift.String]? = nil
        if let lexiconNamesContainer = lexiconNamesContainer {
            lexiconNamesDecoded0 = [Swift.String]()
            for string0 in lexiconNamesContainer {
                if let string0 = string0 {
                    lexiconNamesDecoded0?.append(string0)
                }
            }
        }
        lexiconNames = lexiconNamesDecoded0
        let outputFormatDecoded = try containerValues.decodeIfPresent(PollyClientTypes.OutputFormat.self, forKey: .outputFormat)
        outputFormat = outputFormatDecoded
        let outputS3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3BucketName)
        outputS3BucketName = outputS3BucketNameDecoded
        let outputS3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3KeyPrefix)
        outputS3KeyPrefix = outputS3KeyPrefixDecoded
        let sampleRateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sampleRate)
        sampleRate = sampleRateDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let speechMarkTypesContainer = try containerValues.decodeIfPresent([PollyClientTypes.SpeechMarkType?].self, forKey: .speechMarkTypes)
        var speechMarkTypesDecoded0:[PollyClientTypes.SpeechMarkType]? = nil
        if let speechMarkTypesContainer = speechMarkTypesContainer {
            speechMarkTypesDecoded0 = [PollyClientTypes.SpeechMarkType]()
            for enum0 in speechMarkTypesContainer {
                if let enum0 = enum0 {
                    speechMarkTypesDecoded0?.append(enum0)
                }
            }
        }
        speechMarkTypes = speechMarkTypesDecoded0
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let textTypeDecoded = try containerValues.decodeIfPresent(PollyClientTypes.TextType.self, forKey: .textType)
        textType = textTypeDecoded
        let voiceIdDecoded = try containerValues.decodeIfPresent(PollyClientTypes.VoiceId.self, forKey: .voiceId)
        voiceId = voiceIdDecoded
    }
}

extension StartSpeechSynthesisTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartSpeechSynthesisTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EngineNotSupportedException" : self = .engineNotSupportedException(try EngineNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3BucketException" : self = .invalidS3BucketException(try InvalidS3BucketException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3KeyException" : self = .invalidS3KeyException(try InvalidS3KeyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSampleRateException" : self = .invalidSampleRateException(try InvalidSampleRateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSnsTopicArnException" : self = .invalidSnsTopicArnException(try InvalidSnsTopicArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSsmlException" : self = .invalidSsmlException(try InvalidSsmlException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LanguageNotSupportedException" : self = .languageNotSupportedException(try LanguageNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LexiconNotFoundException" : self = .lexiconNotFoundException(try LexiconNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MarksNotSupportedForFormatException" : self = .marksNotSupportedForFormatException(try MarksNotSupportedForFormatException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SsmlMarksNotSupportedForTextTypeException" : self = .ssmlMarksNotSupportedForTextTypeException(try SsmlMarksNotSupportedForTextTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TextLengthExceededException" : self = .textLengthExceededException(try TextLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartSpeechSynthesisTaskOutputError: Swift.Error, Swift.Equatable {
    case engineNotSupportedException(EngineNotSupportedException)
    case invalidS3BucketException(InvalidS3BucketException)
    case invalidS3KeyException(InvalidS3KeyException)
    case invalidSampleRateException(InvalidSampleRateException)
    case invalidSnsTopicArnException(InvalidSnsTopicArnException)
    case invalidSsmlException(InvalidSsmlException)
    case languageNotSupportedException(LanguageNotSupportedException)
    case lexiconNotFoundException(LexiconNotFoundException)
    case marksNotSupportedForFormatException(MarksNotSupportedForFormatException)
    case serviceFailureException(ServiceFailureException)
    case ssmlMarksNotSupportedForTextTypeException(SsmlMarksNotSupportedForTextTypeException)
    case textLengthExceededException(TextLengthExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartSpeechSynthesisTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartSpeechSynthesisTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.synthesisTask = output.synthesisTask
        } else {
            self.synthesisTask = nil
        }
    }
}

public struct StartSpeechSynthesisTaskOutputResponse: Swift.Equatable {
    /// SynthesisTask object that provides information and attributes about a newly submitted speech synthesis task.
    public var synthesisTask: PollyClientTypes.SynthesisTask?

    public init (
        synthesisTask: PollyClientTypes.SynthesisTask? = nil
    )
    {
        self.synthesisTask = synthesisTask
    }
}

struct StartSpeechSynthesisTaskOutputResponseBody: Swift.Equatable {
    let synthesisTask: PollyClientTypes.SynthesisTask?
}

extension StartSpeechSynthesisTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case synthesisTask = "SynthesisTask"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let synthesisTaskDecoded = try containerValues.decodeIfPresent(PollyClientTypes.SynthesisTask.self, forKey: .synthesisTask)
        synthesisTask = synthesisTaskDecoded
    }
}

extension PollyClientTypes.SynthesisTask: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case engine = "Engine"
        case languageCode = "LanguageCode"
        case lexiconNames = "LexiconNames"
        case outputFormat = "OutputFormat"
        case outputUri = "OutputUri"
        case requestCharacters = "RequestCharacters"
        case sampleRate = "SampleRate"
        case snsTopicArn = "SnsTopicArn"
        case speechMarkTypes = "SpeechMarkTypes"
        case taskId = "TaskId"
        case taskStatus = "TaskStatus"
        case taskStatusReason = "TaskStatusReason"
        case textType = "TextType"
        case voiceId = "VoiceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let engine = self.engine {
            try encodeContainer.encode(engine.rawValue, forKey: .engine)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let lexiconNames = lexiconNames {
            var lexiconNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lexiconNames)
            for lexiconname0 in lexiconNames {
                try lexiconNamesContainer.encode(lexiconname0)
            }
        }
        if let outputFormat = self.outputFormat {
            try encodeContainer.encode(outputFormat.rawValue, forKey: .outputFormat)
        }
        if let outputUri = self.outputUri {
            try encodeContainer.encode(outputUri, forKey: .outputUri)
        }
        if requestCharacters != 0 {
            try encodeContainer.encode(requestCharacters, forKey: .requestCharacters)
        }
        if let sampleRate = self.sampleRate {
            try encodeContainer.encode(sampleRate, forKey: .sampleRate)
        }
        if let snsTopicArn = self.snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let speechMarkTypes = speechMarkTypes {
            var speechMarkTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .speechMarkTypes)
            for speechmarktype0 in speechMarkTypes {
                try speechMarkTypesContainer.encode(speechmarktype0.rawValue)
            }
        }
        if let taskId = self.taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
        if let taskStatus = self.taskStatus {
            try encodeContainer.encode(taskStatus.rawValue, forKey: .taskStatus)
        }
        if let taskStatusReason = self.taskStatusReason {
            try encodeContainer.encode(taskStatusReason, forKey: .taskStatusReason)
        }
        if let textType = self.textType {
            try encodeContainer.encode(textType.rawValue, forKey: .textType)
        }
        if let voiceId = self.voiceId {
            try encodeContainer.encode(voiceId.rawValue, forKey: .voiceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineDecoded = try containerValues.decodeIfPresent(PollyClientTypes.Engine.self, forKey: .engine)
        engine = engineDecoded
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let taskStatusDecoded = try containerValues.decodeIfPresent(PollyClientTypes.TaskStatus.self, forKey: .taskStatus)
        taskStatus = taskStatusDecoded
        let taskStatusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskStatusReason)
        taskStatusReason = taskStatusReasonDecoded
        let outputUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputUri)
        outputUri = outputUriDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let requestCharactersDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .requestCharacters) ?? 0
        requestCharacters = requestCharactersDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let lexiconNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .lexiconNames)
        var lexiconNamesDecoded0:[Swift.String]? = nil
        if let lexiconNamesContainer = lexiconNamesContainer {
            lexiconNamesDecoded0 = [Swift.String]()
            for string0 in lexiconNamesContainer {
                if let string0 = string0 {
                    lexiconNamesDecoded0?.append(string0)
                }
            }
        }
        lexiconNames = lexiconNamesDecoded0
        let outputFormatDecoded = try containerValues.decodeIfPresent(PollyClientTypes.OutputFormat.self, forKey: .outputFormat)
        outputFormat = outputFormatDecoded
        let sampleRateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sampleRate)
        sampleRate = sampleRateDecoded
        let speechMarkTypesContainer = try containerValues.decodeIfPresent([PollyClientTypes.SpeechMarkType?].self, forKey: .speechMarkTypes)
        var speechMarkTypesDecoded0:[PollyClientTypes.SpeechMarkType]? = nil
        if let speechMarkTypesContainer = speechMarkTypesContainer {
            speechMarkTypesDecoded0 = [PollyClientTypes.SpeechMarkType]()
            for enum0 in speechMarkTypesContainer {
                if let enum0 = enum0 {
                    speechMarkTypesDecoded0?.append(enum0)
                }
            }
        }
        speechMarkTypes = speechMarkTypesDecoded0
        let textTypeDecoded = try containerValues.decodeIfPresent(PollyClientTypes.TextType.self, forKey: .textType)
        textType = textTypeDecoded
        let voiceIdDecoded = try containerValues.decodeIfPresent(PollyClientTypes.VoiceId.self, forKey: .voiceId)
        voiceId = voiceIdDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(PollyClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
    }
}

extension PollyClientTypes {
    /// SynthesisTask object that provides information about a speech synthesis task.
    public struct SynthesisTask: Swift.Equatable {
        /// Timestamp for the time the synthesis task was started.
        public var creationTime: ClientRuntime.Date?
        /// Specifies the engine (standard or neural) for Amazon Polly to use when processing input text for speech synthesis. Using a voice that is not supported for the engine selected will result in an error.
        public var engine: PollyClientTypes.Engine?
        /// Optional language code for a synthesis task. This is only necessary if using a bilingual voice, such as Aditi, which can be used for either Indian English (en-IN) or Hindi (hi-IN). If a bilingual voice is used and no language code is specified, Amazon Polly uses the default language of the bilingual voice. The default language for any voice is the one returned by the [DescribeVoices](https://docs.aws.amazon.com/polly/latest/dg/API_DescribeVoices.html) operation for the LanguageCode parameter. For example, if no language code is specified, Aditi will use Indian English rather than Hindi.
        public var languageCode: PollyClientTypes.LanguageCode?
        /// List of one or more pronunciation lexicon names you want the service to apply during synthesis. Lexicons are applied only if the language of the lexicon is the same as the language of the voice.
        public var lexiconNames: [Swift.String]?
        /// The format in which the returned output will be encoded. For audio stream, this will be mp3, ogg_vorbis, or pcm. For speech marks, this will be json.
        public var outputFormat: PollyClientTypes.OutputFormat?
        /// Pathway for the output speech file.
        public var outputUri: Swift.String?
        /// Number of billable characters synthesized.
        public var requestCharacters: Swift.Int
        /// The audio frequency specified in Hz. The valid values for mp3 and ogg_vorbis are "8000", "16000", "22050", and "24000". The default value for standard voices is "22050". The default value for neural voices is "24000". Valid values for pcm are "8000" and "16000" The default value is "16000".
        public var sampleRate: Swift.String?
        /// ARN for the SNS topic optionally used for providing status notification for a speech synthesis task.
        public var snsTopicArn: Swift.String?
        /// The type of speech marks returned for the input text.
        public var speechMarkTypes: [PollyClientTypes.SpeechMarkType]?
        /// The Amazon Polly generated identifier for a speech synthesis task.
        public var taskId: Swift.String?
        /// Current status of the individual speech synthesis task.
        public var taskStatus: PollyClientTypes.TaskStatus?
        /// Reason for the current status of a specific speech synthesis task, including errors if the task has failed.
        public var taskStatusReason: Swift.String?
        /// Specifies whether the input text is plain text or SSML. The default value is plain text.
        public var textType: PollyClientTypes.TextType?
        /// Voice ID to use for the synthesis.
        public var voiceId: PollyClientTypes.VoiceId?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            engine: PollyClientTypes.Engine? = nil,
            languageCode: PollyClientTypes.LanguageCode? = nil,
            lexiconNames: [Swift.String]? = nil,
            outputFormat: PollyClientTypes.OutputFormat? = nil,
            outputUri: Swift.String? = nil,
            requestCharacters: Swift.Int = 0,
            sampleRate: Swift.String? = nil,
            snsTopicArn: Swift.String? = nil,
            speechMarkTypes: [PollyClientTypes.SpeechMarkType]? = nil,
            taskId: Swift.String? = nil,
            taskStatus: PollyClientTypes.TaskStatus? = nil,
            taskStatusReason: Swift.String? = nil,
            textType: PollyClientTypes.TextType? = nil,
            voiceId: PollyClientTypes.VoiceId? = nil
        )
        {
            self.creationTime = creationTime
            self.engine = engine
            self.languageCode = languageCode
            self.lexiconNames = lexiconNames
            self.outputFormat = outputFormat
            self.outputUri = outputUri
            self.requestCharacters = requestCharacters
            self.sampleRate = sampleRate
            self.snsTopicArn = snsTopicArn
            self.speechMarkTypes = speechMarkTypes
            self.taskId = taskId
            self.taskStatus = taskStatus
            self.taskStatusReason = taskStatusReason
            self.textType = textType
            self.voiceId = voiceId
        }
    }

}

extension SynthesisTaskNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SynthesisTaskNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The Speech Synthesis task with requested Task ID cannot be found.
public struct SynthesisTaskNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SynthesisTaskNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension SynthesisTaskNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SynthesizeSpeechInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engine = "Engine"
        case languageCode = "LanguageCode"
        case lexiconNames = "LexiconNames"
        case outputFormat = "OutputFormat"
        case sampleRate = "SampleRate"
        case speechMarkTypes = "SpeechMarkTypes"
        case text = "Text"
        case textType = "TextType"
        case voiceId = "VoiceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engine = self.engine {
            try encodeContainer.encode(engine.rawValue, forKey: .engine)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let lexiconNames = lexiconNames {
            var lexiconNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lexiconNames)
            for lexiconname0 in lexiconNames {
                try lexiconNamesContainer.encode(lexiconname0)
            }
        }
        if let outputFormat = self.outputFormat {
            try encodeContainer.encode(outputFormat.rawValue, forKey: .outputFormat)
        }
        if let sampleRate = self.sampleRate {
            try encodeContainer.encode(sampleRate, forKey: .sampleRate)
        }
        if let speechMarkTypes = speechMarkTypes {
            var speechMarkTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .speechMarkTypes)
            for speechmarktype0 in speechMarkTypes {
                try speechMarkTypesContainer.encode(speechmarktype0.rawValue)
            }
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let textType = self.textType {
            try encodeContainer.encode(textType.rawValue, forKey: .textType)
        }
        if let voiceId = self.voiceId {
            try encodeContainer.encode(voiceId.rawValue, forKey: .voiceId)
        }
    }
}

extension SynthesizeSpeechInput {
    public func presignURL(config: PollyClientConfigurationProtocol, expiration: Foundation.TimeInterval) async throws -> ClientRuntime.URL? {
        let serviceName = "Polly"
        let input = self
        let encoder = ClientRuntime.JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        let decoder = ClientRuntime.JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "synthesizeSpeech")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withPartitionID(value: config.partitionID)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "polly")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<SynthesizeSpeechInput, SynthesizeSpeechOutputResponse, SynthesizeSpeechOutputError>(id: "synthesizeSpeech")
        operation.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLPathMiddleware<SynthesizeSpeechInput, SynthesizeSpeechOutputResponse, SynthesizeSpeechOutputError>())
        operation.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLHostMiddleware<SynthesizeSpeechInput, SynthesizeSpeechOutputResponse>())
        let endpointParams = EndpointParams(endpoint: config.endpoint, region: config.region, useDualStack: config.useDualStack ?? false, useFIPS: config.useFIPS ?? false)
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware<SynthesizeSpeechOutputResponse, SynthesizeSpeechOutputError>(endpointResolver: config.endpointResolver, endpointParams: endpointParams))
        operation.serializeStep.intercept(position: .after, middleware: SynthesizeSpeechInputGETQueryItemMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: ClientRuntime.RetryerMiddleware<SynthesizeSpeechOutputResponse, SynthesizeSpeechOutputError>(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(signatureType: .requestQueryParams, expiration: expiration, unsignedBody: false, signingAlgorithm: .sigv4)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware<SynthesizeSpeechOutputResponse, SynthesizeSpeechOutputError>(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware<SynthesizeSpeechOutputResponse, SynthesizeSpeechOutputError>(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware<SynthesizeSpeechOutputResponse, SynthesizeSpeechOutputError>())
        let presignedRequestBuilder = try await operation.presignedRequest(context: context.build(), input: input, next: ClientRuntime.NoopHandler())
        guard let builtRequest = presignedRequestBuilder?.build(), let presignedURL = builtRequest.endpoint.url else {
            return nil
        }
        return presignedURL
    }
}

extension SynthesizeSpeechInput {
    public func presign(config: PollyClientConfigurationProtocol, expiration: Foundation.TimeInterval) async throws -> ClientRuntime.SdkHttpRequest? {
        let serviceName = "Polly"
        let input = self
        let encoder = ClientRuntime.JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        let decoder = ClientRuntime.JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "synthesizeSpeech")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withPartitionID(value: config.partitionID)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "polly")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<SynthesizeSpeechInput, SynthesizeSpeechOutputResponse, SynthesizeSpeechOutputError>(id: "synthesizeSpeech")
        operation.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLPathMiddleware<SynthesizeSpeechInput, SynthesizeSpeechOutputResponse, SynthesizeSpeechOutputError>())
        operation.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLHostMiddleware<SynthesizeSpeechInput, SynthesizeSpeechOutputResponse>())
        let endpointParams = EndpointParams(endpoint: config.endpoint, region: config.region, useDualStack: config.useDualStack ?? false, useFIPS: config.useFIPS ?? false)
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware<SynthesizeSpeechOutputResponse, SynthesizeSpeechOutputError>(endpointResolver: config.endpointResolver, endpointParams: endpointParams))
        let apiMetadata = AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0")
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: apiMetadata, frameworkMetadata: config.frameworkMetadata)))
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<SynthesizeSpeechInput, SynthesizeSpeechOutputResponse>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .after, middleware: ClientRuntime.SerializableBodyMiddleware<SynthesizeSpeechInput, SynthesizeSpeechOutputResponse>(xmlName: "SynthesizeSpeechInput"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: ClientRuntime.RetryerMiddleware<SynthesizeSpeechOutputResponse, SynthesizeSpeechOutputError>(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(expiration: expiration, unsignedBody: false, signingAlgorithm: .sigv4)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware<SynthesizeSpeechOutputResponse, SynthesizeSpeechOutputError>(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware<SynthesizeSpeechOutputResponse, SynthesizeSpeechOutputError>(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware<SynthesizeSpeechOutputResponse, SynthesizeSpeechOutputError>())
        let presignedRequestBuilder = try await operation.presignedRequest(context: context.build(), input: input, next: ClientRuntime.NoopHandler())
        guard let builtRequest = presignedRequestBuilder?.build() else {
            return nil
        }
        return builtRequest
    }
}

public struct SynthesizeSpeechInputGETQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SynthesizeSpeechInputGETQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SynthesizeSpeechInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<SynthesizeSpeechOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let engine = input.operationInput.engine {
            let queryItem = ClientRuntime.URLQueryItem(name: "Engine".urlPercentEncoding(), value: Swift.String(engine.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(queryItem)
        }
        if let languageCode = input.operationInput.languageCode {
            let queryItem = ClientRuntime.URLQueryItem(name: "LanguageCode".urlPercentEncoding(), value: Swift.String(languageCode.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(queryItem)
        }
        if let lexiconNames = input.operationInput.lexiconNames {
            lexiconNames.forEach { item in
                let queryItem = ClientRuntime.URLQueryItem(name: "LexiconNames".urlPercentEncoding(), value: Swift.String(item).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let outputFormat = input.operationInput.outputFormat {
            let queryItem = ClientRuntime.URLQueryItem(name: "OutputFormat".urlPercentEncoding(), value: Swift.String(outputFormat.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(queryItem)
        }
        if let sampleRate = input.operationInput.sampleRate {
            let queryItem = ClientRuntime.URLQueryItem(name: "SampleRate".urlPercentEncoding(), value: Swift.String(sampleRate).urlPercentEncoding())
            input.builder.withQueryItem(queryItem)
        }
        if let speechMarkTypes = input.operationInput.speechMarkTypes {
            speechMarkTypes.forEach { item in
                let queryItem = ClientRuntime.URLQueryItem(name: "SpeechMarkTypes".urlPercentEncoding(), value: Swift.String(item.rawValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let text = input.operationInput.text {
            let queryItem = ClientRuntime.URLQueryItem(name: "Text".urlPercentEncoding(), value: Swift.String(text).urlPercentEncoding())
            input.builder.withQueryItem(queryItem)
        }
        if let textType = input.operationInput.textType {
            let queryItem = ClientRuntime.URLQueryItem(name: "TextType".urlPercentEncoding(), value: Swift.String(textType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(queryItem)
        }
        if let voiceId = input.operationInput.voiceId {
            let queryItem = ClientRuntime.URLQueryItem(name: "VoiceId".urlPercentEncoding(), value: Swift.String(voiceId.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(queryItem)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SynthesizeSpeechInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SynthesizeSpeechOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension SynthesizeSpeechInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/speech"
    }
}

public struct SynthesizeSpeechInput: Swift.Equatable {
    /// Specifies the engine (standard or neural) for Amazon Polly to use when processing input text for speech synthesis. For information on Amazon Polly voices and which voices are available in standard-only, NTTS-only, and both standard and NTTS formats, see [Available Voices](https://docs.aws.amazon.com/polly/latest/dg/voicelist.html). NTTS-only voices When using NTTS-only voices such as Kevin (en-US), this parameter is required and must be set to neural. If the engine is not specified, or is set to standard, this will result in an error. Type: String Valid Values: standard | neural Required: Yes Standard voices For standard voices, this is not required; the engine parameter defaults to standard. If the engine is not specified, or is set to standard and an NTTS-only voice is selected, this will result in an error.
    public var engine: PollyClientTypes.Engine?
    /// Optional language code for the Synthesize Speech request. This is only necessary if using a bilingual voice, such as Aditi, which can be used for either Indian English (en-IN) or Hindi (hi-IN). If a bilingual voice is used and no language code is specified, Amazon Polly uses the default language of the bilingual voice. The default language for any voice is the one returned by the [DescribeVoices](https://docs.aws.amazon.com/polly/latest/dg/API_DescribeVoices.html) operation for the LanguageCode parameter. For example, if no language code is specified, Aditi will use Indian English rather than Hindi.
    public var languageCode: PollyClientTypes.LanguageCode?
    /// List of one or more pronunciation lexicon names you want the service to apply during synthesis. Lexicons are applied only if the language of the lexicon is the same as the language of the voice. For information about storing lexicons, see [PutLexicon](https://docs.aws.amazon.com/polly/latest/dg/API_PutLexicon.html).
    public var lexiconNames: [Swift.String]?
    /// The format in which the returned output will be encoded. For audio stream, this will be mp3, ogg_vorbis, or pcm. For speech marks, this will be json. When pcm is used, the content returned is audio/pcm in a signed 16-bit, 1 channel (mono), little-endian format.
    /// This member is required.
    public var outputFormat: PollyClientTypes.OutputFormat?
    /// The audio frequency specified in Hz. The valid values for mp3 and ogg_vorbis are "8000", "16000", "22050", and "24000". The default value for standard voices is "22050". The default value for neural voices is "24000". Valid values for pcm are "8000" and "16000" The default value is "16000".
    public var sampleRate: Swift.String?
    /// The type of speech marks returned for the input text.
    public var speechMarkTypes: [PollyClientTypes.SpeechMarkType]?
    /// Input text to synthesize. If you specify ssml as the TextType, follow the SSML format for the input text.
    /// This member is required.
    public var text: Swift.String?
    /// Specifies whether the input text is plain text or SSML. The default value is plain text. For more information, see [Using SSML](https://docs.aws.amazon.com/polly/latest/dg/ssml.html).
    public var textType: PollyClientTypes.TextType?
    /// Voice ID to use for the synthesis. You can get a list of available voice IDs by calling the [DescribeVoices](https://docs.aws.amazon.com/polly/latest/dg/API_DescribeVoices.html) operation.
    /// This member is required.
    public var voiceId: PollyClientTypes.VoiceId?

    public init (
        engine: PollyClientTypes.Engine? = nil,
        languageCode: PollyClientTypes.LanguageCode? = nil,
        lexiconNames: [Swift.String]? = nil,
        outputFormat: PollyClientTypes.OutputFormat? = nil,
        sampleRate: Swift.String? = nil,
        speechMarkTypes: [PollyClientTypes.SpeechMarkType]? = nil,
        text: Swift.String? = nil,
        textType: PollyClientTypes.TextType? = nil,
        voiceId: PollyClientTypes.VoiceId? = nil
    )
    {
        self.engine = engine
        self.languageCode = languageCode
        self.lexiconNames = lexiconNames
        self.outputFormat = outputFormat
        self.sampleRate = sampleRate
        self.speechMarkTypes = speechMarkTypes
        self.text = text
        self.textType = textType
        self.voiceId = voiceId
    }
}

struct SynthesizeSpeechInputBody: Swift.Equatable {
    let engine: PollyClientTypes.Engine?
    let languageCode: PollyClientTypes.LanguageCode?
    let lexiconNames: [Swift.String]?
    let outputFormat: PollyClientTypes.OutputFormat?
    let sampleRate: Swift.String?
    let speechMarkTypes: [PollyClientTypes.SpeechMarkType]?
    let text: Swift.String?
    let textType: PollyClientTypes.TextType?
    let voiceId: PollyClientTypes.VoiceId?
}

extension SynthesizeSpeechInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engine = "Engine"
        case languageCode = "LanguageCode"
        case lexiconNames = "LexiconNames"
        case outputFormat = "OutputFormat"
        case sampleRate = "SampleRate"
        case speechMarkTypes = "SpeechMarkTypes"
        case text = "Text"
        case textType = "TextType"
        case voiceId = "VoiceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineDecoded = try containerValues.decodeIfPresent(PollyClientTypes.Engine.self, forKey: .engine)
        engine = engineDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(PollyClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let lexiconNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .lexiconNames)
        var lexiconNamesDecoded0:[Swift.String]? = nil
        if let lexiconNamesContainer = lexiconNamesContainer {
            lexiconNamesDecoded0 = [Swift.String]()
            for string0 in lexiconNamesContainer {
                if let string0 = string0 {
                    lexiconNamesDecoded0?.append(string0)
                }
            }
        }
        lexiconNames = lexiconNamesDecoded0
        let outputFormatDecoded = try containerValues.decodeIfPresent(PollyClientTypes.OutputFormat.self, forKey: .outputFormat)
        outputFormat = outputFormatDecoded
        let sampleRateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sampleRate)
        sampleRate = sampleRateDecoded
        let speechMarkTypesContainer = try containerValues.decodeIfPresent([PollyClientTypes.SpeechMarkType?].self, forKey: .speechMarkTypes)
        var speechMarkTypesDecoded0:[PollyClientTypes.SpeechMarkType]? = nil
        if let speechMarkTypesContainer = speechMarkTypesContainer {
            speechMarkTypesDecoded0 = [PollyClientTypes.SpeechMarkType]()
            for enum0 in speechMarkTypesContainer {
                if let enum0 = enum0 {
                    speechMarkTypesDecoded0?.append(enum0)
                }
            }
        }
        speechMarkTypes = speechMarkTypesDecoded0
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let textTypeDecoded = try containerValues.decodeIfPresent(PollyClientTypes.TextType.self, forKey: .textType)
        textType = textTypeDecoded
        let voiceIdDecoded = try containerValues.decodeIfPresent(PollyClientTypes.VoiceId.self, forKey: .voiceId)
        voiceId = voiceIdDecoded
    }
}

extension SynthesizeSpeechOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SynthesizeSpeechOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EngineNotSupportedException" : self = .engineNotSupportedException(try EngineNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSampleRateException" : self = .invalidSampleRateException(try InvalidSampleRateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSsmlException" : self = .invalidSsmlException(try InvalidSsmlException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LanguageNotSupportedException" : self = .languageNotSupportedException(try LanguageNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LexiconNotFoundException" : self = .lexiconNotFoundException(try LexiconNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MarksNotSupportedForFormatException" : self = .marksNotSupportedForFormatException(try MarksNotSupportedForFormatException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SsmlMarksNotSupportedForTextTypeException" : self = .ssmlMarksNotSupportedForTextTypeException(try SsmlMarksNotSupportedForTextTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TextLengthExceededException" : self = .textLengthExceededException(try TextLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SynthesizeSpeechOutputError: Swift.Error, Swift.Equatable {
    case engineNotSupportedException(EngineNotSupportedException)
    case invalidSampleRateException(InvalidSampleRateException)
    case invalidSsmlException(InvalidSsmlException)
    case languageNotSupportedException(LanguageNotSupportedException)
    case lexiconNotFoundException(LexiconNotFoundException)
    case marksNotSupportedForFormatException(MarksNotSupportedForFormatException)
    case serviceFailureException(ServiceFailureException)
    case ssmlMarksNotSupportedForTextTypeException(SsmlMarksNotSupportedForTextTypeException)
    case textLengthExceededException(TextLengthExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SynthesizeSpeechOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let requestCharactersHeaderValue = httpResponse.headers.value(for: "x-amzn-RequestCharacters") {
            self.requestCharacters = Swift.Int(requestCharactersHeaderValue) ?? 0
        } else {
            self.requestCharacters = 0
        }
        if let data = httpResponse.body.toBytes()?.getData() {
            self.audioStream = ByteStream.from(data: data)
        } else {
            self.audioStream = nil
        }
    }
}

public struct SynthesizeSpeechOutputResponse: Swift.Equatable {
    /// Stream containing the synthesized speech.
    public var audioStream: ClientRuntime.ByteStream?
    /// Specifies the type audio stream. This should reflect the OutputFormat parameter in your request.
    ///
    /// * If you request mp3 as the OutputFormat, the ContentType returned is audio/mpeg.
    ///
    /// * If you request ogg_vorbis as the OutputFormat, the ContentType returned is audio/ogg.
    ///
    /// * If you request pcm as the OutputFormat, the ContentType returned is audio/pcm in a signed 16-bit, 1 channel (mono), little-endian format.
    ///
    /// * If you request json as the OutputFormat, the ContentType returned is application/x-json-stream.
    public var contentType: Swift.String?
    /// Number of characters synthesized.
    public var requestCharacters: Swift.Int

    public init (
        audioStream: ClientRuntime.ByteStream? = nil,
        contentType: Swift.String? = nil,
        requestCharacters: Swift.Int = 0
    )
    {
        self.audioStream = audioStream
        self.contentType = contentType
        self.requestCharacters = requestCharacters
    }
}

struct SynthesizeSpeechOutputResponseBody: Swift.Equatable {
    let audioStream: ClientRuntime.ByteStream?
}

extension SynthesizeSpeechOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioStream = "AudioStream"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioStreamDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .audioStream)
        audioStream = audioStreamDecoded
    }
}

extension PollyClientTypes {
    public enum TaskStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case scheduled
        case sdkUnknown(Swift.String)

        public static var allCases: [TaskStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .scheduled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "completed"
            case .failed: return "failed"
            case .inProgress: return "inProgress"
            case .scheduled: return "scheduled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TaskStatus(rawValue: rawValue) ?? TaskStatus.sdkUnknown(rawValue)
        }
    }
}

extension TextLengthExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TextLengthExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The value of the "Text" parameter is longer than the accepted limits. For the SynthesizeSpeech API, the limit for input text is a maximum of 6000 characters total, of which no more than 3000 can be billed characters. For the StartSpeechSynthesisTask API, the maximum is 200,000 characters, of which no more than 100,000 can be billed characters. SSML tags are not counted as billed characters.
public struct TextLengthExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TextLengthExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TextLengthExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PollyClientTypes {
    public enum TextType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ssml
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [TextType] {
            return [
                .ssml,
                .text,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ssml: return "ssml"
            case .text: return "text"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TextType(rawValue: rawValue) ?? TextType.sdkUnknown(rawValue)
        }
    }
}

extension UnsupportedPlsAlphabetException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UnsupportedPlsAlphabetExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The alphabet specified by the lexicon is not a supported alphabet. Valid values are x-sampa and ipa.
public struct UnsupportedPlsAlphabetException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedPlsAlphabetExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedPlsAlphabetExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedPlsLanguageException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UnsupportedPlsLanguageExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The language specified in the lexicon is unsupported. For a list of supported languages, see [Lexicon Attributes](https://docs.aws.amazon.com/polly/latest/dg/API_LexiconAttributes.html).
public struct UnsupportedPlsLanguageException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedPlsLanguageExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedPlsLanguageExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PollyClientTypes.Voice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalLanguageCodes = "AdditionalLanguageCodes"
        case gender = "Gender"
        case id = "Id"
        case languageCode = "LanguageCode"
        case languageName = "LanguageName"
        case name = "Name"
        case supportedEngines = "SupportedEngines"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalLanguageCodes = additionalLanguageCodes {
            var additionalLanguageCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalLanguageCodes)
            for languagecode0 in additionalLanguageCodes {
                try additionalLanguageCodesContainer.encode(languagecode0.rawValue)
            }
        }
        if let gender = self.gender {
            try encodeContainer.encode(gender.rawValue, forKey: .gender)
        }
        if let id = self.id {
            try encodeContainer.encode(id.rawValue, forKey: .id)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let languageName = self.languageName {
            try encodeContainer.encode(languageName, forKey: .languageName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let supportedEngines = supportedEngines {
            var supportedEnginesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedEngines)
            for engine0 in supportedEngines {
                try supportedEnginesContainer.encode(engine0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let genderDecoded = try containerValues.decodeIfPresent(PollyClientTypes.Gender.self, forKey: .gender)
        gender = genderDecoded
        let idDecoded = try containerValues.decodeIfPresent(PollyClientTypes.VoiceId.self, forKey: .id)
        id = idDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(PollyClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let languageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .languageName)
        languageName = languageNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let additionalLanguageCodesContainer = try containerValues.decodeIfPresent([PollyClientTypes.LanguageCode?].self, forKey: .additionalLanguageCodes)
        var additionalLanguageCodesDecoded0:[PollyClientTypes.LanguageCode]? = nil
        if let additionalLanguageCodesContainer = additionalLanguageCodesContainer {
            additionalLanguageCodesDecoded0 = [PollyClientTypes.LanguageCode]()
            for enum0 in additionalLanguageCodesContainer {
                if let enum0 = enum0 {
                    additionalLanguageCodesDecoded0?.append(enum0)
                }
            }
        }
        additionalLanguageCodes = additionalLanguageCodesDecoded0
        let supportedEnginesContainer = try containerValues.decodeIfPresent([PollyClientTypes.Engine?].self, forKey: .supportedEngines)
        var supportedEnginesDecoded0:[PollyClientTypes.Engine]? = nil
        if let supportedEnginesContainer = supportedEnginesContainer {
            supportedEnginesDecoded0 = [PollyClientTypes.Engine]()
            for enum0 in supportedEnginesContainer {
                if let enum0 = enum0 {
                    supportedEnginesDecoded0?.append(enum0)
                }
            }
        }
        supportedEngines = supportedEnginesDecoded0
    }
}

extension PollyClientTypes {
    /// Description of the voice.
    public struct Voice: Swift.Equatable {
        /// Additional codes for languages available for the specified voice in addition to its default language. For example, the default language for Aditi is Indian English (en-IN) because it was first used for that language. Since Aditi is bilingual and fluent in both Indian English and Hindi, this parameter would show the code hi-IN.
        public var additionalLanguageCodes: [PollyClientTypes.LanguageCode]?
        /// Gender of the voice.
        public var gender: PollyClientTypes.Gender?
        /// Amazon Polly assigned voice ID. This is the ID that you specify when calling the SynthesizeSpeech operation.
        public var id: PollyClientTypes.VoiceId?
        /// Language code of the voice.
        public var languageCode: PollyClientTypes.LanguageCode?
        /// Human readable name of the language in English.
        public var languageName: Swift.String?
        /// Name of the voice (for example, Salli, Kendra, etc.). This provides a human readable voice name that you might display in your application.
        public var name: Swift.String?
        /// Specifies which engines (standard or neural) that are supported by a given voice.
        public var supportedEngines: [PollyClientTypes.Engine]?

        public init (
            additionalLanguageCodes: [PollyClientTypes.LanguageCode]? = nil,
            gender: PollyClientTypes.Gender? = nil,
            id: PollyClientTypes.VoiceId? = nil,
            languageCode: PollyClientTypes.LanguageCode? = nil,
            languageName: Swift.String? = nil,
            name: Swift.String? = nil,
            supportedEngines: [PollyClientTypes.Engine]? = nil
        )
        {
            self.additionalLanguageCodes = additionalLanguageCodes
            self.gender = gender
            self.id = id
            self.languageCode = languageCode
            self.languageName = languageName
            self.name = name
            self.supportedEngines = supportedEngines
        }
    }

}

extension PollyClientTypes {
    public enum VoiceId: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aditi
        case adriano
        case amy
        case andres
        case aria
        case arlet
        case arthur
        case astrid
        case ayanda
        case bianca
        case brian
        case camila
        case carla
        case carmen
        case celine
        case chantal
        case conchita
        case cristiano
        case daniel
        case dora
        case elin
        case emma
        case enrique
        case ewa
        case filiz
        case gabrielle
        case geraint
        case giorgio
        case gwyneth
        case hala
        case hannah
        case hans
        case hiujin
        case ida
        case ines
        case ivy
        case jacek
        case jan
        case joanna
        case joey
        case justin
        case kajal
        case karl
        case kazuha
        case kendra
        case kevin
        case kimberly
        case laura
        case lea
        case liam
        case liv
        case lotte
        case lucia
        case lupe
        case mads
        case maja
        case marlene
        case mathieu
        case matthew
        case maxim
        case mia
        case miguel
        case mizuki
        case naja
        case nicole
        case ola
        case olivia
        case pedro
        case penelope
        case raveena
        case remi
        case ricardo
        case ruben
        case russell
        case ruth
        case salli
        case seoyeon
        case sergio
        case stephen
        case suvi
        case takumi
        case tatyana
        case thiago
        case tomoko
        case vicki
        case vitoria
        case zeina
        case zhiyu
        case sdkUnknown(Swift.String)

        public static var allCases: [VoiceId] {
            return [
                .aditi,
                .adriano,
                .amy,
                .andres,
                .aria,
                .arlet,
                .arthur,
                .astrid,
                .ayanda,
                .bianca,
                .brian,
                .camila,
                .carla,
                .carmen,
                .celine,
                .chantal,
                .conchita,
                .cristiano,
                .daniel,
                .dora,
                .elin,
                .emma,
                .enrique,
                .ewa,
                .filiz,
                .gabrielle,
                .geraint,
                .giorgio,
                .gwyneth,
                .hala,
                .hannah,
                .hans,
                .hiujin,
                .ida,
                .ines,
                .ivy,
                .jacek,
                .jan,
                .joanna,
                .joey,
                .justin,
                .kajal,
                .karl,
                .kazuha,
                .kendra,
                .kevin,
                .kimberly,
                .laura,
                .lea,
                .liam,
                .liv,
                .lotte,
                .lucia,
                .lupe,
                .mads,
                .maja,
                .marlene,
                .mathieu,
                .matthew,
                .maxim,
                .mia,
                .miguel,
                .mizuki,
                .naja,
                .nicole,
                .ola,
                .olivia,
                .pedro,
                .penelope,
                .raveena,
                .remi,
                .ricardo,
                .ruben,
                .russell,
                .ruth,
                .salli,
                .seoyeon,
                .sergio,
                .stephen,
                .suvi,
                .takumi,
                .tatyana,
                .thiago,
                .tomoko,
                .vicki,
                .vitoria,
                .zeina,
                .zhiyu,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aditi: return "Aditi"
            case .adriano: return "Adriano"
            case .amy: return "Amy"
            case .andres: return "Andres"
            case .aria: return "Aria"
            case .arlet: return "Arlet"
            case .arthur: return "Arthur"
            case .astrid: return "Astrid"
            case .ayanda: return "Ayanda"
            case .bianca: return "Bianca"
            case .brian: return "Brian"
            case .camila: return "Camila"
            case .carla: return "Carla"
            case .carmen: return "Carmen"
            case .celine: return "Celine"
            case .chantal: return "Chantal"
            case .conchita: return "Conchita"
            case .cristiano: return "Cristiano"
            case .daniel: return "Daniel"
            case .dora: return "Dora"
            case .elin: return "Elin"
            case .emma: return "Emma"
            case .enrique: return "Enrique"
            case .ewa: return "Ewa"
            case .filiz: return "Filiz"
            case .gabrielle: return "Gabrielle"
            case .geraint: return "Geraint"
            case .giorgio: return "Giorgio"
            case .gwyneth: return "Gwyneth"
            case .hala: return "Hala"
            case .hannah: return "Hannah"
            case .hans: return "Hans"
            case .hiujin: return "Hiujin"
            case .ida: return "Ida"
            case .ines: return "Ines"
            case .ivy: return "Ivy"
            case .jacek: return "Jacek"
            case .jan: return "Jan"
            case .joanna: return "Joanna"
            case .joey: return "Joey"
            case .justin: return "Justin"
            case .kajal: return "Kajal"
            case .karl: return "Karl"
            case .kazuha: return "Kazuha"
            case .kendra: return "Kendra"
            case .kevin: return "Kevin"
            case .kimberly: return "Kimberly"
            case .laura: return "Laura"
            case .lea: return "Lea"
            case .liam: return "Liam"
            case .liv: return "Liv"
            case .lotte: return "Lotte"
            case .lucia: return "Lucia"
            case .lupe: return "Lupe"
            case .mads: return "Mads"
            case .maja: return "Maja"
            case .marlene: return "Marlene"
            case .mathieu: return "Mathieu"
            case .matthew: return "Matthew"
            case .maxim: return "Maxim"
            case .mia: return "Mia"
            case .miguel: return "Miguel"
            case .mizuki: return "Mizuki"
            case .naja: return "Naja"
            case .nicole: return "Nicole"
            case .ola: return "Ola"
            case .olivia: return "Olivia"
            case .pedro: return "Pedro"
            case .penelope: return "Penelope"
            case .raveena: return "Raveena"
            case .remi: return "Remi"
            case .ricardo: return "Ricardo"
            case .ruben: return "Ruben"
            case .russell: return "Russell"
            case .ruth: return "Ruth"
            case .salli: return "Salli"
            case .seoyeon: return "Seoyeon"
            case .sergio: return "Sergio"
            case .stephen: return "Stephen"
            case .suvi: return "Suvi"
            case .takumi: return "Takumi"
            case .tatyana: return "Tatyana"
            case .thiago: return "Thiago"
            case .tomoko: return "Tomoko"
            case .vicki: return "Vicki"
            case .vitoria: return "Vitoria"
            case .zeina: return "Zeina"
            case .zhiyu: return "Zhiyu"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VoiceId(rawValue: rawValue) ?? VoiceId.sdkUnknown(rawValue)
        }
    }
}
