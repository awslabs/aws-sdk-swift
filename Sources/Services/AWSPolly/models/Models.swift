// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime
import typealias Foundation.TimeInterval

extension DeleteLexiconInput {

    static func urlPathProvider(_ value: DeleteLexiconInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/v1/lexicons/\(name.urlPercentEncoding())"
    }
}

public struct DeleteLexiconInput: Swift.Equatable {
    /// The name of the lexicon to delete. Must be an existing lexicon in the region.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteLexiconInputBody: Swift.Equatable {
}

extension DeleteLexiconInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteLexiconOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteLexiconOutput: Swift.Equatable {

    public init() { }
}

enum DeleteLexiconOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "LexiconNotFoundException": return try await LexiconNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeVoicesInput {

    static func queryItemProvider(_ value: DescribeVoicesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let languageCode = value.languageCode {
            let languageCodeQueryItem = ClientRuntime.SDKURLQueryItem(name: "LanguageCode".urlPercentEncoding(), value: Swift.String(languageCode.rawValue).urlPercentEncoding())
            items.append(languageCodeQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let engine = value.engine {
            let engineQueryItem = ClientRuntime.SDKURLQueryItem(name: "Engine".urlPercentEncoding(), value: Swift.String(engine.rawValue).urlPercentEncoding())
            items.append(engineQueryItem)
        }
        if let includeAdditionalLanguageCodes = value.includeAdditionalLanguageCodes {
            let includeAdditionalLanguageCodesQueryItem = ClientRuntime.SDKURLQueryItem(name: "IncludeAdditionalLanguageCodes".urlPercentEncoding(), value: Swift.String(includeAdditionalLanguageCodes).urlPercentEncoding())
            items.append(includeAdditionalLanguageCodesQueryItem)
        }
        return items
    }
}

extension DescribeVoicesInput {

    static func urlPathProvider(_ value: DescribeVoicesInput) -> Swift.String? {
        return "/v1/voices"
    }
}

public struct DescribeVoicesInput: Swift.Equatable {
    /// Specifies the engine (standard, neural or long-form) used by Amazon Polly when processing input text for speech synthesis.
    public var engine: PollyClientTypes.Engine?
    /// Boolean value indicating whether to return any bilingual voices that use the specified language as an additional language. For instance, if you request all languages that use US English (es-US), and there is an Italian voice that speaks both Italian (it-IT) and US English, that voice will be included if you specify yes but not if you specify no.
    public var includeAdditionalLanguageCodes: Swift.Bool?
    /// The language identification tag (ISO 639 code for the language name-ISO 3166 country code) for filtering the list of voices returned. If you don't specify this optional parameter, all available voices are returned.
    public var languageCode: PollyClientTypes.LanguageCode?
    /// An opaque pagination token returned from the previous DescribeVoices operation. If present, this indicates where to continue the listing.
    public var nextToken: Swift.String?

    public init(
        engine: PollyClientTypes.Engine? = nil,
        includeAdditionalLanguageCodes: Swift.Bool? = nil,
        languageCode: PollyClientTypes.LanguageCode? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.engine = engine
        self.includeAdditionalLanguageCodes = includeAdditionalLanguageCodes
        self.languageCode = languageCode
        self.nextToken = nextToken
    }
}

struct DescribeVoicesInputBody: Swift.Equatable {
}

extension DescribeVoicesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeVoicesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeVoicesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.voices = output.voices
        } else {
            self.nextToken = nil
            self.voices = nil
        }
    }
}

public struct DescribeVoicesOutput: Swift.Equatable {
    /// The pagination token to use in the next request to continue the listing of voices. NextToken is returned only if the response is truncated.
    public var nextToken: Swift.String?
    /// A list of voices with their properties.
    public var voices: [PollyClientTypes.Voice]?

    public init(
        nextToken: Swift.String? = nil,
        voices: [PollyClientTypes.Voice]? = nil
    )
    {
        self.nextToken = nextToken
        self.voices = voices
    }
}

struct DescribeVoicesOutputBody: Swift.Equatable {
    let voices: [PollyClientTypes.Voice]?
    let nextToken: Swift.String?
}

extension DescribeVoicesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case voices = "Voices"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voicesContainer = try containerValues.decodeIfPresent([PollyClientTypes.Voice?].self, forKey: .voices)
        var voicesDecoded0:[PollyClientTypes.Voice]? = nil
        if let voicesContainer = voicesContainer {
            voicesDecoded0 = [PollyClientTypes.Voice]()
            for structure0 in voicesContainer {
                if let structure0 = structure0 {
                    voicesDecoded0?.append(structure0)
                }
            }
        }
        voices = voicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeVoicesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PollyClientTypes {
    public enum Engine: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case longForm
        case neural
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [Engine] {
            return [
                .longForm,
                .neural,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .longForm: return "long-form"
            case .neural: return "neural"
            case .standard: return "standard"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Engine(rawValue: rawValue) ?? Engine.sdkUnknown(rawValue)
        }
    }
}

extension EngineNotSupportedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EngineNotSupportedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This engine is not compatible with the voice that you have designated. Choose a new voice that is compatible with the engine or change the engine and restart the operation.
public struct EngineNotSupportedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EngineNotSupportedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct EngineNotSupportedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EngineNotSupportedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PollyClientTypes {
    public enum Gender: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case female
        case male
        case sdkUnknown(Swift.String)

        public static var allCases: [Gender] {
            return [
                .female,
                .male,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .female: return "Female"
            case .male: return "Male"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Gender(rawValue: rawValue) ?? Gender.sdkUnknown(rawValue)
        }
    }
}

extension GetLexiconInput {

    static func urlPathProvider(_ value: GetLexiconInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/v1/lexicons/\(name.urlPercentEncoding())"
    }
}

public struct GetLexiconInput: Swift.Equatable {
    /// Name of the lexicon.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetLexiconInputBody: Swift.Equatable {
}

extension GetLexiconInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetLexiconOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLexiconOutputBody = try responseDecoder.decode(responseBody: data)
            self.lexicon = output.lexicon
            self.lexiconAttributes = output.lexiconAttributes
        } else {
            self.lexicon = nil
            self.lexiconAttributes = nil
        }
    }
}

public struct GetLexiconOutput: Swift.Equatable {
    /// Lexicon object that provides name and the string content of the lexicon.
    public var lexicon: PollyClientTypes.Lexicon?
    /// Metadata of the lexicon, including phonetic alphabetic used, language code, lexicon ARN, number of lexemes defined in the lexicon, and size of lexicon in bytes.
    public var lexiconAttributes: PollyClientTypes.LexiconAttributes?

    public init(
        lexicon: PollyClientTypes.Lexicon? = nil,
        lexiconAttributes: PollyClientTypes.LexiconAttributes? = nil
    )
    {
        self.lexicon = lexicon
        self.lexiconAttributes = lexiconAttributes
    }
}

struct GetLexiconOutputBody: Swift.Equatable {
    let lexicon: PollyClientTypes.Lexicon?
    let lexiconAttributes: PollyClientTypes.LexiconAttributes?
}

extension GetLexiconOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lexicon = "Lexicon"
        case lexiconAttributes = "LexiconAttributes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lexiconDecoded = try containerValues.decodeIfPresent(PollyClientTypes.Lexicon.self, forKey: .lexicon)
        lexicon = lexiconDecoded
        let lexiconAttributesDecoded = try containerValues.decodeIfPresent(PollyClientTypes.LexiconAttributes.self, forKey: .lexiconAttributes)
        lexiconAttributes = lexiconAttributesDecoded
    }
}

enum GetLexiconOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "LexiconNotFoundException": return try await LexiconNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSpeechSynthesisTaskInput {

    static func urlPathProvider(_ value: GetSpeechSynthesisTaskInput) -> Swift.String? {
        guard let taskId = value.taskId else {
            return nil
        }
        return "/v1/synthesisTasks/\(taskId.urlPercentEncoding())"
    }
}

public struct GetSpeechSynthesisTaskInput: Swift.Equatable {
    /// The Amazon Polly generated identifier for a speech synthesis task.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

struct GetSpeechSynthesisTaskInputBody: Swift.Equatable {
}

extension GetSpeechSynthesisTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSpeechSynthesisTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSpeechSynthesisTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.synthesisTask = output.synthesisTask
        } else {
            self.synthesisTask = nil
        }
    }
}

public struct GetSpeechSynthesisTaskOutput: Swift.Equatable {
    /// SynthesisTask object that provides information from the requested task, including output format, creation time, task status, and so on.
    public var synthesisTask: PollyClientTypes.SynthesisTask?

    public init(
        synthesisTask: PollyClientTypes.SynthesisTask? = nil
    )
    {
        self.synthesisTask = synthesisTask
    }
}

struct GetSpeechSynthesisTaskOutputBody: Swift.Equatable {
    let synthesisTask: PollyClientTypes.SynthesisTask?
}

extension GetSpeechSynthesisTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case synthesisTask = "SynthesisTask"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let synthesisTaskDecoded = try containerValues.decodeIfPresent(PollyClientTypes.SynthesisTask.self, forKey: .synthesisTask)
        synthesisTask = synthesisTaskDecoded
    }
}

enum GetSpeechSynthesisTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidTaskIdException": return try await InvalidTaskIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SynthesisTaskNotFoundException": return try await SynthesisTaskNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InvalidLexiconException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidLexiconExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Amazon Polly can't find the specified lexicon. Verify that the lexicon's name is spelled correctly, and then try again.
public struct InvalidLexiconException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidLexiconException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidLexiconExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidLexiconExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The NextToken is invalid. Verify that it's spelled correctly, and then try again.
public struct InvalidNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNextTokenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidS3BucketException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidS3BucketExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The provided Amazon S3 bucket name is invalid. Please check your input with S3 bucket naming requirements and try again.
public struct InvalidS3BucketException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidS3BucketException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidS3BucketExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidS3BucketExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidS3KeyException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidS3KeyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The provided Amazon S3 key prefix is invalid. Please provide a valid S3 object key name.
public struct InvalidS3KeyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidS3KeyException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidS3KeyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidS3KeyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSampleRateException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidSampleRateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified sample rate is not valid.
public struct InvalidSampleRateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSampleRateException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidSampleRateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidSampleRateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSnsTopicArnException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidSnsTopicArnExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The provided SNS topic ARN is invalid. Please provide a valid SNS topic ARN and try again.
public struct InvalidSnsTopicArnException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSnsTopicArnException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidSnsTopicArnExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidSnsTopicArnExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSsmlException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidSsmlExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The SSML you provided is invalid. Verify the SSML syntax, spelling of tags and values, and then try again.
public struct InvalidSsmlException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSsmlException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidSsmlExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidSsmlExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTaskIdException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidTaskIdExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The provided Task ID is not valid. Please provide a valid Task ID and try again.
public struct InvalidTaskIdException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTaskIdException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidTaskIdExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTaskIdExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PollyClientTypes {
    public enum LanguageCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case arAe
        case arb
        case caEs
        case cmnCn
        case cyGb
        case daDk
        case deAt
        case deDe
        case enAu
        case enGb
        case enGbWls
        case enIe
        case enIn
        case enNz
        case enUs
        case enZa
        case esEs
        case esMx
        case esUs
        case fiFi
        case frBe
        case frCa
        case frFr
        case hiIn
        case isIs
        case itIt
        case jaJp
        case koKr
        case nbNo
        case nlBe
        case nlNl
        case plPl
        case ptBr
        case ptPt
        case roRo
        case ruRu
        case svSe
        case trTr
        case yueCn
        case sdkUnknown(Swift.String)

        public static var allCases: [LanguageCode] {
            return [
                .arAe,
                .arb,
                .caEs,
                .cmnCn,
                .cyGb,
                .daDk,
                .deAt,
                .deDe,
                .enAu,
                .enGb,
                .enGbWls,
                .enIe,
                .enIn,
                .enNz,
                .enUs,
                .enZa,
                .esEs,
                .esMx,
                .esUs,
                .fiFi,
                .frBe,
                .frCa,
                .frFr,
                .hiIn,
                .isIs,
                .itIt,
                .jaJp,
                .koKr,
                .nbNo,
                .nlBe,
                .nlNl,
                .plPl,
                .ptBr,
                .ptPt,
                .roRo,
                .ruRu,
                .svSe,
                .trTr,
                .yueCn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .arAe: return "ar-AE"
            case .arb: return "arb"
            case .caEs: return "ca-ES"
            case .cmnCn: return "cmn-CN"
            case .cyGb: return "cy-GB"
            case .daDk: return "da-DK"
            case .deAt: return "de-AT"
            case .deDe: return "de-DE"
            case .enAu: return "en-AU"
            case .enGb: return "en-GB"
            case .enGbWls: return "en-GB-WLS"
            case .enIe: return "en-IE"
            case .enIn: return "en-IN"
            case .enNz: return "en-NZ"
            case .enUs: return "en-US"
            case .enZa: return "en-ZA"
            case .esEs: return "es-ES"
            case .esMx: return "es-MX"
            case .esUs: return "es-US"
            case .fiFi: return "fi-FI"
            case .frBe: return "fr-BE"
            case .frCa: return "fr-CA"
            case .frFr: return "fr-FR"
            case .hiIn: return "hi-IN"
            case .isIs: return "is-IS"
            case .itIt: return "it-IT"
            case .jaJp: return "ja-JP"
            case .koKr: return "ko-KR"
            case .nbNo: return "nb-NO"
            case .nlBe: return "nl-BE"
            case .nlNl: return "nl-NL"
            case .plPl: return "pl-PL"
            case .ptBr: return "pt-BR"
            case .ptPt: return "pt-PT"
            case .roRo: return "ro-RO"
            case .ruRu: return "ru-RU"
            case .svSe: return "sv-SE"
            case .trTr: return "tr-TR"
            case .yueCn: return "yue-CN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LanguageCode(rawValue: rawValue) ?? LanguageCode.sdkUnknown(rawValue)
        }
    }
}

extension LanguageNotSupportedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LanguageNotSupportedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The language specified is not currently supported by Amazon Polly in this capacity.
public struct LanguageNotSupportedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LanguageNotSupportedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LanguageNotSupportedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LanguageNotSupportedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PollyClientTypes.Lexicon: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension PollyClientTypes.Lexicon: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Lexicon(name: \(Swift.String(describing: name)), content: \"CONTENT_REDACTED\")"}
}

extension PollyClientTypes {
    /// Provides lexicon name and lexicon content in string format. For more information, see [Pronunciation Lexicon Specification (PLS) Version 1.0](https://www.w3.org/TR/pronunciation-lexicon/).
    public struct Lexicon: Swift.Equatable {
        /// Lexicon content in string format. The content of a lexicon must be in PLS format.
        public var content: Swift.String?
        /// Name of the lexicon.
        public var name: Swift.String?

        public init(
            content: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.content = content
            self.name = name
        }
    }

}

extension PollyClientTypes.LexiconAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alphabet = "Alphabet"
        case languageCode = "LanguageCode"
        case lastModified = "LastModified"
        case lexemesCount = "LexemesCount"
        case lexiconArn = "LexiconArn"
        case size = "Size"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alphabet = self.alphabet {
            try encodeContainer.encode(alphabet, forKey: .alphabet)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let lastModified = self.lastModified {
            try encodeContainer.encodeTimestamp(lastModified, format: .epochSeconds, forKey: .lastModified)
        }
        if lexemesCount != 0 {
            try encodeContainer.encode(lexemesCount, forKey: .lexemesCount)
        }
        if let lexiconArn = self.lexiconArn {
            try encodeContainer.encode(lexiconArn, forKey: .lexiconArn)
        }
        if size != 0 {
            try encodeContainer.encode(size, forKey: .size)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alphabetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alphabet)
        alphabet = alphabetDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(PollyClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let lexiconArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lexiconArn)
        lexiconArn = lexiconArnDecoded
        let lexemesCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lexemesCount) ?? 0
        lexemesCount = lexemesCountDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .size) ?? 0
        size = sizeDecoded
    }
}

extension PollyClientTypes {
    /// Contains metadata describing the lexicon such as the number of lexemes, language code, and so on. For more information, see [Managing Lexicons](https://docs.aws.amazon.com/polly/latest/dg/managing-lexicons.html).
    public struct LexiconAttributes: Swift.Equatable {
        /// Phonetic alphabet used in the lexicon. Valid values are ipa and x-sampa.
        public var alphabet: Swift.String?
        /// Language code that the lexicon applies to. A lexicon with a language code such as "en" would be applied to all English languages (en-GB, en-US, en-AUS, en-WLS, and so on.
        public var languageCode: PollyClientTypes.LanguageCode?
        /// Date lexicon was last modified (a timestamp value).
        public var lastModified: ClientRuntime.Date?
        /// Number of lexemes in the lexicon.
        public var lexemesCount: Swift.Int
        /// Amazon Resource Name (ARN) of the lexicon.
        public var lexiconArn: Swift.String?
        /// Total size of the lexicon, in characters.
        public var size: Swift.Int

        public init(
            alphabet: Swift.String? = nil,
            languageCode: PollyClientTypes.LanguageCode? = nil,
            lastModified: ClientRuntime.Date? = nil,
            lexemesCount: Swift.Int = 0,
            lexiconArn: Swift.String? = nil,
            size: Swift.Int = 0
        )
        {
            self.alphabet = alphabet
            self.languageCode = languageCode
            self.lastModified = lastModified
            self.lexemesCount = lexemesCount
            self.lexiconArn = lexiconArn
            self.size = size
        }
    }

}

extension PollyClientTypes.LexiconDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = self.attributes {
            try encodeContainer.encode(attributes, forKey: .attributes)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let attributesDecoded = try containerValues.decodeIfPresent(PollyClientTypes.LexiconAttributes.self, forKey: .attributes)
        attributes = attributesDecoded
    }
}

extension PollyClientTypes {
    /// Describes the content of the lexicon.
    public struct LexiconDescription: Swift.Equatable {
        /// Provides lexicon metadata.
        public var attributes: PollyClientTypes.LexiconAttributes?
        /// Name of the lexicon.
        public var name: Swift.String?

        public init(
            attributes: PollyClientTypes.LexiconAttributes? = nil,
            name: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.name = name
        }
    }

}

extension LexiconNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LexiconNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Amazon Polly can't find the specified lexicon. This could be caused by a lexicon that is missing, its name is misspelled or specifying a lexicon that is in a different region. Verify that the lexicon exists, is in the region (see [ListLexicons]) and that you spelled its name is spelled correctly. Then try again.
public struct LexiconNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LexiconNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LexiconNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LexiconNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LexiconSizeExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LexiconSizeExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The maximum size of the specified lexicon would be exceeded by this operation.
public struct LexiconSizeExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LexiconSizeExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LexiconSizeExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LexiconSizeExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListLexiconsInput {

    static func queryItemProvider(_ value: ListLexiconsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListLexiconsInput {

    static func urlPathProvider(_ value: ListLexiconsInput) -> Swift.String? {
        return "/v1/lexicons"
    }
}

public struct ListLexiconsInput: Swift.Equatable {
    /// An opaque pagination token returned from previous ListLexicons operation. If present, indicates where to continue the list of lexicons.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListLexiconsInputBody: Swift.Equatable {
}

extension ListLexiconsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListLexiconsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLexiconsOutputBody = try responseDecoder.decode(responseBody: data)
            self.lexicons = output.lexicons
            self.nextToken = output.nextToken
        } else {
            self.lexicons = nil
            self.nextToken = nil
        }
    }
}

public struct ListLexiconsOutput: Swift.Equatable {
    /// A list of lexicon names and attributes.
    public var lexicons: [PollyClientTypes.LexiconDescription]?
    /// The pagination token to use in the next request to continue the listing of lexicons. NextToken is returned only if the response is truncated.
    public var nextToken: Swift.String?

    public init(
        lexicons: [PollyClientTypes.LexiconDescription]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.lexicons = lexicons
        self.nextToken = nextToken
    }
}

struct ListLexiconsOutputBody: Swift.Equatable {
    let lexicons: [PollyClientTypes.LexiconDescription]?
    let nextToken: Swift.String?
}

extension ListLexiconsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lexicons = "Lexicons"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lexiconsContainer = try containerValues.decodeIfPresent([PollyClientTypes.LexiconDescription?].self, forKey: .lexicons)
        var lexiconsDecoded0:[PollyClientTypes.LexiconDescription]? = nil
        if let lexiconsContainer = lexiconsContainer {
            lexiconsDecoded0 = [PollyClientTypes.LexiconDescription]()
            for structure0 in lexiconsContainer {
                if let structure0 = structure0 {
                    lexiconsDecoded0?.append(structure0)
                }
            }
        }
        lexicons = lexiconsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListLexiconsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSpeechSynthesisTasksInput {

    static func queryItemProvider(_ value: ListSpeechSynthesisTasksInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let status = value.status {
            let statusQueryItem = ClientRuntime.SDKURLQueryItem(name: "Status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListSpeechSynthesisTasksInput {

    static func urlPathProvider(_ value: ListSpeechSynthesisTasksInput) -> Swift.String? {
        return "/v1/synthesisTasks"
    }
}

public struct ListSpeechSynthesisTasksInput: Swift.Equatable {
    /// Maximum number of speech synthesis tasks returned in a List operation.
    public var maxResults: Swift.Int?
    /// The pagination token to use in the next request to continue the listing of speech synthesis tasks.
    public var nextToken: Swift.String?
    /// Status of the speech synthesis tasks returned in a List operation
    public var status: PollyClientTypes.TaskStatus?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: PollyClientTypes.TaskStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

struct ListSpeechSynthesisTasksInputBody: Swift.Equatable {
}

extension ListSpeechSynthesisTasksInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSpeechSynthesisTasksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSpeechSynthesisTasksOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.synthesisTasks = output.synthesisTasks
        } else {
            self.nextToken = nil
            self.synthesisTasks = nil
        }
    }
}

public struct ListSpeechSynthesisTasksOutput: Swift.Equatable {
    /// An opaque pagination token returned from the previous List operation in this request. If present, this indicates where to continue the listing.
    public var nextToken: Swift.String?
    /// List of SynthesisTask objects that provides information from the specified task in the list request, including output format, creation time, task status, and so on.
    public var synthesisTasks: [PollyClientTypes.SynthesisTask]?

    public init(
        nextToken: Swift.String? = nil,
        synthesisTasks: [PollyClientTypes.SynthesisTask]? = nil
    )
    {
        self.nextToken = nextToken
        self.synthesisTasks = synthesisTasks
    }
}

struct ListSpeechSynthesisTasksOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let synthesisTasks: [PollyClientTypes.SynthesisTask]?
}

extension ListSpeechSynthesisTasksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case synthesisTasks = "SynthesisTasks"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let synthesisTasksContainer = try containerValues.decodeIfPresent([PollyClientTypes.SynthesisTask?].self, forKey: .synthesisTasks)
        var synthesisTasksDecoded0:[PollyClientTypes.SynthesisTask]? = nil
        if let synthesisTasksContainer = synthesisTasksContainer {
            synthesisTasksDecoded0 = [PollyClientTypes.SynthesisTask]()
            for structure0 in synthesisTasksContainer {
                if let structure0 = structure0 {
                    synthesisTasksDecoded0?.append(structure0)
                }
            }
        }
        synthesisTasks = synthesisTasksDecoded0
    }
}

enum ListSpeechSynthesisTasksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MarksNotSupportedForFormatException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MarksNotSupportedForFormatExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Speech marks are not supported for the OutputFormat selected. Speech marks are only available for content in json format.
public struct MarksNotSupportedForFormatException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MarksNotSupportedForFormatException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct MarksNotSupportedForFormatExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MarksNotSupportedForFormatExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaxLexemeLengthExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MaxLexemeLengthExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The maximum size of the lexeme would be exceeded by this operation.
public struct MaxLexemeLengthExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MaxLexemeLengthExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct MaxLexemeLengthExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MaxLexemeLengthExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaxLexiconsNumberExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MaxLexiconsNumberExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The maximum number of lexicons would be exceeded by this operation.
public struct MaxLexiconsNumberExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MaxLexiconsNumberExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct MaxLexiconsNumberExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MaxLexiconsNumberExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PollyClientTypes {
    public enum OutputFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case json
        case mp3
        case oggVorbis
        case pcm
        case sdkUnknown(Swift.String)

        public static var allCases: [OutputFormat] {
            return [
                .json,
                .mp3,
                .oggVorbis,
                .pcm,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .json: return "json"
            case .mp3: return "mp3"
            case .oggVorbis: return "ogg_vorbis"
            case .pcm: return "pcm"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OutputFormat(rawValue: rawValue) ?? OutputFormat.sdkUnknown(rawValue)
        }
    }
}

public enum PollyClientTypes {}

extension PutLexiconInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutLexiconInput(name: \(Swift.String(describing: name)), content: \"CONTENT_REDACTED\")"}
}

extension PutLexiconInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
    }
}

extension PutLexiconInput {

    static func urlPathProvider(_ value: PutLexiconInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/v1/lexicons/\(name.urlPercentEncoding())"
    }
}

public struct PutLexiconInput: Swift.Equatable {
    /// Content of the PLS lexicon as string data.
    /// This member is required.
    public var content: Swift.String?
    /// Name of the lexicon. The name must follow the regular express format [0-9A-Za-z]{1,20}. That is, the name is a case-sensitive alphanumeric string up to 20 characters long.
    /// This member is required.
    public var name: Swift.String?

    public init(
        content: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.content = content
        self.name = name
    }
}

struct PutLexiconInputBody: Swift.Equatable {
    let content: Swift.String?
}

extension PutLexiconInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
    }
}

extension PutLexiconOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutLexiconOutput: Swift.Equatable {

    public init() { }
}

enum PutLexiconOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidLexiconException": return try await InvalidLexiconException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LexiconSizeExceededException": return try await LexiconSizeExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MaxLexemeLengthExceededException": return try await MaxLexemeLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MaxLexiconsNumberExceededException": return try await MaxLexiconsNumberExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedPlsAlphabetException": return try await UnsupportedPlsAlphabetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedPlsLanguageException": return try await UnsupportedPlsLanguageException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceFailureException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An unknown condition has caused a service failure.
public struct ServiceFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceFailureException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceFailureExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PollyClientTypes {
    public enum SpeechMarkType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sentence
        case ssml
        case viseme
        case word
        case sdkUnknown(Swift.String)

        public static var allCases: [SpeechMarkType] {
            return [
                .sentence,
                .ssml,
                .viseme,
                .word,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sentence: return "sentence"
            case .ssml: return "ssml"
            case .viseme: return "viseme"
            case .word: return "word"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SpeechMarkType(rawValue: rawValue) ?? SpeechMarkType.sdkUnknown(rawValue)
        }
    }
}

extension SsmlMarksNotSupportedForTextTypeException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SsmlMarksNotSupportedForTextTypeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// SSML speech marks are not supported for plain text-type input.
public struct SsmlMarksNotSupportedForTextTypeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SsmlMarksNotSupportedForTextTypeException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct SsmlMarksNotSupportedForTextTypeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension SsmlMarksNotSupportedForTextTypeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StartSpeechSynthesisTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engine = "Engine"
        case languageCode = "LanguageCode"
        case lexiconNames = "LexiconNames"
        case outputFormat = "OutputFormat"
        case outputS3BucketName = "OutputS3BucketName"
        case outputS3KeyPrefix = "OutputS3KeyPrefix"
        case sampleRate = "SampleRate"
        case snsTopicArn = "SnsTopicArn"
        case speechMarkTypes = "SpeechMarkTypes"
        case text = "Text"
        case textType = "TextType"
        case voiceId = "VoiceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engine = self.engine {
            try encodeContainer.encode(engine.rawValue, forKey: .engine)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let lexiconNames = lexiconNames {
            var lexiconNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lexiconNames)
            for lexiconname0 in lexiconNames {
                try lexiconNamesContainer.encode(lexiconname0)
            }
        }
        if let outputFormat = self.outputFormat {
            try encodeContainer.encode(outputFormat.rawValue, forKey: .outputFormat)
        }
        if let outputS3BucketName = self.outputS3BucketName {
            try encodeContainer.encode(outputS3BucketName, forKey: .outputS3BucketName)
        }
        if let outputS3KeyPrefix = self.outputS3KeyPrefix {
            try encodeContainer.encode(outputS3KeyPrefix, forKey: .outputS3KeyPrefix)
        }
        if let sampleRate = self.sampleRate {
            try encodeContainer.encode(sampleRate, forKey: .sampleRate)
        }
        if let snsTopicArn = self.snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let speechMarkTypes = speechMarkTypes {
            var speechMarkTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .speechMarkTypes)
            for speechmarktype0 in speechMarkTypes {
                try speechMarkTypesContainer.encode(speechmarktype0.rawValue)
            }
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let textType = self.textType {
            try encodeContainer.encode(textType.rawValue, forKey: .textType)
        }
        if let voiceId = self.voiceId {
            try encodeContainer.encode(voiceId.rawValue, forKey: .voiceId)
        }
    }
}

extension StartSpeechSynthesisTaskInput {

    static func urlPathProvider(_ value: StartSpeechSynthesisTaskInput) -> Swift.String? {
        return "/v1/synthesisTasks"
    }
}

public struct StartSpeechSynthesisTaskInput: Swift.Equatable {
    /// Specifies the engine (standard, neural or long-form) for Amazon Polly to use when processing input text for speech synthesis. Using a voice that is not supported for the engine selected will result in an error.
    public var engine: PollyClientTypes.Engine?
    /// Optional language code for the Speech Synthesis request. This is only necessary if using a bilingual voice, such as Aditi, which can be used for either Indian English (en-IN) or Hindi (hi-IN). If a bilingual voice is used and no language code is specified, Amazon Polly uses the default language of the bilingual voice. The default language for any voice is the one returned by the [DescribeVoices](https://docs.aws.amazon.com/polly/latest/dg/API_DescribeVoices.html) operation for the LanguageCode parameter. For example, if no language code is specified, Aditi will use Indian English rather than Hindi.
    public var languageCode: PollyClientTypes.LanguageCode?
    /// List of one or more pronunciation lexicon names you want the service to apply during synthesis. Lexicons are applied only if the language of the lexicon is the same as the language of the voice.
    public var lexiconNames: [Swift.String]?
    /// The format in which the returned output will be encoded. For audio stream, this will be mp3, ogg_vorbis, or pcm. For speech marks, this will be json.
    /// This member is required.
    public var outputFormat: PollyClientTypes.OutputFormat?
    /// Amazon S3 bucket name to which the output file will be saved.
    /// This member is required.
    public var outputS3BucketName: Swift.String?
    /// The Amazon S3 key prefix for the output speech file.
    public var outputS3KeyPrefix: Swift.String?
    /// The audio frequency specified in Hz. The valid values for mp3 and ogg_vorbis are "8000", "16000", "22050", and "24000". The default value for standard voices is "22050". The default value for neural voices is "24000". The default value for long-form voices is "24000". Valid values for pcm are "8000" and "16000" The default value is "16000".
    public var sampleRate: Swift.String?
    /// ARN for the SNS topic optionally used for providing status notification for a speech synthesis task.
    public var snsTopicArn: Swift.String?
    /// The type of speech marks returned for the input text.
    public var speechMarkTypes: [PollyClientTypes.SpeechMarkType]?
    /// The input text to synthesize. If you specify ssml as the TextType, follow the SSML format for the input text.
    /// This member is required.
    public var text: Swift.String?
    /// Specifies whether the input text is plain text or SSML. The default value is plain text.
    public var textType: PollyClientTypes.TextType?
    /// Voice ID to use for the synthesis.
    /// This member is required.
    public var voiceId: PollyClientTypes.VoiceId?

    public init(
        engine: PollyClientTypes.Engine? = nil,
        languageCode: PollyClientTypes.LanguageCode? = nil,
        lexiconNames: [Swift.String]? = nil,
        outputFormat: PollyClientTypes.OutputFormat? = nil,
        outputS3BucketName: Swift.String? = nil,
        outputS3KeyPrefix: Swift.String? = nil,
        sampleRate: Swift.String? = nil,
        snsTopicArn: Swift.String? = nil,
        speechMarkTypes: [PollyClientTypes.SpeechMarkType]? = nil,
        text: Swift.String? = nil,
        textType: PollyClientTypes.TextType? = nil,
        voiceId: PollyClientTypes.VoiceId? = nil
    )
    {
        self.engine = engine
        self.languageCode = languageCode
        self.lexiconNames = lexiconNames
        self.outputFormat = outputFormat
        self.outputS3BucketName = outputS3BucketName
        self.outputS3KeyPrefix = outputS3KeyPrefix
        self.sampleRate = sampleRate
        self.snsTopicArn = snsTopicArn
        self.speechMarkTypes = speechMarkTypes
        self.text = text
        self.textType = textType
        self.voiceId = voiceId
    }
}

struct StartSpeechSynthesisTaskInputBody: Swift.Equatable {
    let engine: PollyClientTypes.Engine?
    let languageCode: PollyClientTypes.LanguageCode?
    let lexiconNames: [Swift.String]?
    let outputFormat: PollyClientTypes.OutputFormat?
    let outputS3BucketName: Swift.String?
    let outputS3KeyPrefix: Swift.String?
    let sampleRate: Swift.String?
    let snsTopicArn: Swift.String?
    let speechMarkTypes: [PollyClientTypes.SpeechMarkType]?
    let text: Swift.String?
    let textType: PollyClientTypes.TextType?
    let voiceId: PollyClientTypes.VoiceId?
}

extension StartSpeechSynthesisTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engine = "Engine"
        case languageCode = "LanguageCode"
        case lexiconNames = "LexiconNames"
        case outputFormat = "OutputFormat"
        case outputS3BucketName = "OutputS3BucketName"
        case outputS3KeyPrefix = "OutputS3KeyPrefix"
        case sampleRate = "SampleRate"
        case snsTopicArn = "SnsTopicArn"
        case speechMarkTypes = "SpeechMarkTypes"
        case text = "Text"
        case textType = "TextType"
        case voiceId = "VoiceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineDecoded = try containerValues.decodeIfPresent(PollyClientTypes.Engine.self, forKey: .engine)
        engine = engineDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(PollyClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let lexiconNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .lexiconNames)
        var lexiconNamesDecoded0:[Swift.String]? = nil
        if let lexiconNamesContainer = lexiconNamesContainer {
            lexiconNamesDecoded0 = [Swift.String]()
            for string0 in lexiconNamesContainer {
                if let string0 = string0 {
                    lexiconNamesDecoded0?.append(string0)
                }
            }
        }
        lexiconNames = lexiconNamesDecoded0
        let outputFormatDecoded = try containerValues.decodeIfPresent(PollyClientTypes.OutputFormat.self, forKey: .outputFormat)
        outputFormat = outputFormatDecoded
        let outputS3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3BucketName)
        outputS3BucketName = outputS3BucketNameDecoded
        let outputS3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3KeyPrefix)
        outputS3KeyPrefix = outputS3KeyPrefixDecoded
        let sampleRateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sampleRate)
        sampleRate = sampleRateDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let speechMarkTypesContainer = try containerValues.decodeIfPresent([PollyClientTypes.SpeechMarkType?].self, forKey: .speechMarkTypes)
        var speechMarkTypesDecoded0:[PollyClientTypes.SpeechMarkType]? = nil
        if let speechMarkTypesContainer = speechMarkTypesContainer {
            speechMarkTypesDecoded0 = [PollyClientTypes.SpeechMarkType]()
            for enum0 in speechMarkTypesContainer {
                if let enum0 = enum0 {
                    speechMarkTypesDecoded0?.append(enum0)
                }
            }
        }
        speechMarkTypes = speechMarkTypesDecoded0
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let textTypeDecoded = try containerValues.decodeIfPresent(PollyClientTypes.TextType.self, forKey: .textType)
        textType = textTypeDecoded
        let voiceIdDecoded = try containerValues.decodeIfPresent(PollyClientTypes.VoiceId.self, forKey: .voiceId)
        voiceId = voiceIdDecoded
    }
}

extension StartSpeechSynthesisTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartSpeechSynthesisTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.synthesisTask = output.synthesisTask
        } else {
            self.synthesisTask = nil
        }
    }
}

public struct StartSpeechSynthesisTaskOutput: Swift.Equatable {
    /// SynthesisTask object that provides information and attributes about a newly submitted speech synthesis task.
    public var synthesisTask: PollyClientTypes.SynthesisTask?

    public init(
        synthesisTask: PollyClientTypes.SynthesisTask? = nil
    )
    {
        self.synthesisTask = synthesisTask
    }
}

struct StartSpeechSynthesisTaskOutputBody: Swift.Equatable {
    let synthesisTask: PollyClientTypes.SynthesisTask?
}

extension StartSpeechSynthesisTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case synthesisTask = "SynthesisTask"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let synthesisTaskDecoded = try containerValues.decodeIfPresent(PollyClientTypes.SynthesisTask.self, forKey: .synthesisTask)
        synthesisTask = synthesisTaskDecoded
    }
}

enum StartSpeechSynthesisTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EngineNotSupportedException": return try await EngineNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidS3BucketException": return try await InvalidS3BucketException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidS3KeyException": return try await InvalidS3KeyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidSampleRateException": return try await InvalidSampleRateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidSnsTopicArnException": return try await InvalidSnsTopicArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidSsmlException": return try await InvalidSsmlException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LanguageNotSupportedException": return try await LanguageNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LexiconNotFoundException": return try await LexiconNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MarksNotSupportedForFormatException": return try await MarksNotSupportedForFormatException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SsmlMarksNotSupportedForTextTypeException": return try await SsmlMarksNotSupportedForTextTypeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TextLengthExceededException": return try await TextLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PollyClientTypes.SynthesisTask: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case engine = "Engine"
        case languageCode = "LanguageCode"
        case lexiconNames = "LexiconNames"
        case outputFormat = "OutputFormat"
        case outputUri = "OutputUri"
        case requestCharacters = "RequestCharacters"
        case sampleRate = "SampleRate"
        case snsTopicArn = "SnsTopicArn"
        case speechMarkTypes = "SpeechMarkTypes"
        case taskId = "TaskId"
        case taskStatus = "TaskStatus"
        case taskStatusReason = "TaskStatusReason"
        case textType = "TextType"
        case voiceId = "VoiceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let engine = self.engine {
            try encodeContainer.encode(engine.rawValue, forKey: .engine)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let lexiconNames = lexiconNames {
            var lexiconNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lexiconNames)
            for lexiconname0 in lexiconNames {
                try lexiconNamesContainer.encode(lexiconname0)
            }
        }
        if let outputFormat = self.outputFormat {
            try encodeContainer.encode(outputFormat.rawValue, forKey: .outputFormat)
        }
        if let outputUri = self.outputUri {
            try encodeContainer.encode(outputUri, forKey: .outputUri)
        }
        if requestCharacters != 0 {
            try encodeContainer.encode(requestCharacters, forKey: .requestCharacters)
        }
        if let sampleRate = self.sampleRate {
            try encodeContainer.encode(sampleRate, forKey: .sampleRate)
        }
        if let snsTopicArn = self.snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let speechMarkTypes = speechMarkTypes {
            var speechMarkTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .speechMarkTypes)
            for speechmarktype0 in speechMarkTypes {
                try speechMarkTypesContainer.encode(speechmarktype0.rawValue)
            }
        }
        if let taskId = self.taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
        if let taskStatus = self.taskStatus {
            try encodeContainer.encode(taskStatus.rawValue, forKey: .taskStatus)
        }
        if let taskStatusReason = self.taskStatusReason {
            try encodeContainer.encode(taskStatusReason, forKey: .taskStatusReason)
        }
        if let textType = self.textType {
            try encodeContainer.encode(textType.rawValue, forKey: .textType)
        }
        if let voiceId = self.voiceId {
            try encodeContainer.encode(voiceId.rawValue, forKey: .voiceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineDecoded = try containerValues.decodeIfPresent(PollyClientTypes.Engine.self, forKey: .engine)
        engine = engineDecoded
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let taskStatusDecoded = try containerValues.decodeIfPresent(PollyClientTypes.TaskStatus.self, forKey: .taskStatus)
        taskStatus = taskStatusDecoded
        let taskStatusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskStatusReason)
        taskStatusReason = taskStatusReasonDecoded
        let outputUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputUri)
        outputUri = outputUriDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let requestCharactersDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .requestCharacters) ?? 0
        requestCharacters = requestCharactersDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let lexiconNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .lexiconNames)
        var lexiconNamesDecoded0:[Swift.String]? = nil
        if let lexiconNamesContainer = lexiconNamesContainer {
            lexiconNamesDecoded0 = [Swift.String]()
            for string0 in lexiconNamesContainer {
                if let string0 = string0 {
                    lexiconNamesDecoded0?.append(string0)
                }
            }
        }
        lexiconNames = lexiconNamesDecoded0
        let outputFormatDecoded = try containerValues.decodeIfPresent(PollyClientTypes.OutputFormat.self, forKey: .outputFormat)
        outputFormat = outputFormatDecoded
        let sampleRateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sampleRate)
        sampleRate = sampleRateDecoded
        let speechMarkTypesContainer = try containerValues.decodeIfPresent([PollyClientTypes.SpeechMarkType?].self, forKey: .speechMarkTypes)
        var speechMarkTypesDecoded0:[PollyClientTypes.SpeechMarkType]? = nil
        if let speechMarkTypesContainer = speechMarkTypesContainer {
            speechMarkTypesDecoded0 = [PollyClientTypes.SpeechMarkType]()
            for enum0 in speechMarkTypesContainer {
                if let enum0 = enum0 {
                    speechMarkTypesDecoded0?.append(enum0)
                }
            }
        }
        speechMarkTypes = speechMarkTypesDecoded0
        let textTypeDecoded = try containerValues.decodeIfPresent(PollyClientTypes.TextType.self, forKey: .textType)
        textType = textTypeDecoded
        let voiceIdDecoded = try containerValues.decodeIfPresent(PollyClientTypes.VoiceId.self, forKey: .voiceId)
        voiceId = voiceIdDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(PollyClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
    }
}

extension PollyClientTypes {
    /// SynthesisTask object that provides information about a speech synthesis task.
    public struct SynthesisTask: Swift.Equatable {
        /// Timestamp for the time the synthesis task was started.
        public var creationTime: ClientRuntime.Date?
        /// Specifies the engine (standard, neural or long-form) for Amazon Polly to use when processing input text for speech synthesis. Using a voice that is not supported for the engine selected will result in an error.
        public var engine: PollyClientTypes.Engine?
        /// Optional language code for a synthesis task. This is only necessary if using a bilingual voice, such as Aditi, which can be used for either Indian English (en-IN) or Hindi (hi-IN). If a bilingual voice is used and no language code is specified, Amazon Polly uses the default language of the bilingual voice. The default language for any voice is the one returned by the [DescribeVoices](https://docs.aws.amazon.com/polly/latest/dg/API_DescribeVoices.html) operation for the LanguageCode parameter. For example, if no language code is specified, Aditi will use Indian English rather than Hindi.
        public var languageCode: PollyClientTypes.LanguageCode?
        /// List of one or more pronunciation lexicon names you want the service to apply during synthesis. Lexicons are applied only if the language of the lexicon is the same as the language of the voice.
        public var lexiconNames: [Swift.String]?
        /// The format in which the returned output will be encoded. For audio stream, this will be mp3, ogg_vorbis, or pcm. For speech marks, this will be json.
        public var outputFormat: PollyClientTypes.OutputFormat?
        /// Pathway for the output speech file.
        public var outputUri: Swift.String?
        /// Number of billable characters synthesized.
        public var requestCharacters: Swift.Int
        /// The audio frequency specified in Hz. The valid values for mp3 and ogg_vorbis are "8000", "16000", "22050", and "24000". The default value for standard voices is "22050". The default value for neural voices is "24000". The default value for long-form voices is "24000". Valid values for pcm are "8000" and "16000" The default value is "16000".
        public var sampleRate: Swift.String?
        /// ARN for the SNS topic optionally used for providing status notification for a speech synthesis task.
        public var snsTopicArn: Swift.String?
        /// The type of speech marks returned for the input text.
        public var speechMarkTypes: [PollyClientTypes.SpeechMarkType]?
        /// The Amazon Polly generated identifier for a speech synthesis task.
        public var taskId: Swift.String?
        /// Current status of the individual speech synthesis task.
        public var taskStatus: PollyClientTypes.TaskStatus?
        /// Reason for the current status of a specific speech synthesis task, including errors if the task has failed.
        public var taskStatusReason: Swift.String?
        /// Specifies whether the input text is plain text or SSML. The default value is plain text.
        public var textType: PollyClientTypes.TextType?
        /// Voice ID to use for the synthesis.
        public var voiceId: PollyClientTypes.VoiceId?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            engine: PollyClientTypes.Engine? = nil,
            languageCode: PollyClientTypes.LanguageCode? = nil,
            lexiconNames: [Swift.String]? = nil,
            outputFormat: PollyClientTypes.OutputFormat? = nil,
            outputUri: Swift.String? = nil,
            requestCharacters: Swift.Int = 0,
            sampleRate: Swift.String? = nil,
            snsTopicArn: Swift.String? = nil,
            speechMarkTypes: [PollyClientTypes.SpeechMarkType]? = nil,
            taskId: Swift.String? = nil,
            taskStatus: PollyClientTypes.TaskStatus? = nil,
            taskStatusReason: Swift.String? = nil,
            textType: PollyClientTypes.TextType? = nil,
            voiceId: PollyClientTypes.VoiceId? = nil
        )
        {
            self.creationTime = creationTime
            self.engine = engine
            self.languageCode = languageCode
            self.lexiconNames = lexiconNames
            self.outputFormat = outputFormat
            self.outputUri = outputUri
            self.requestCharacters = requestCharacters
            self.sampleRate = sampleRate
            self.snsTopicArn = snsTopicArn
            self.speechMarkTypes = speechMarkTypes
            self.taskId = taskId
            self.taskStatus = taskStatus
            self.taskStatusReason = taskStatusReason
            self.textType = textType
            self.voiceId = voiceId
        }
    }

}

extension SynthesisTaskNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SynthesisTaskNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The Speech Synthesis task with requested Task ID cannot be found.
public struct SynthesisTaskNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SynthesisTaskNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct SynthesisTaskNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension SynthesisTaskNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SynthesizeSpeechInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engine = "Engine"
        case languageCode = "LanguageCode"
        case lexiconNames = "LexiconNames"
        case outputFormat = "OutputFormat"
        case sampleRate = "SampleRate"
        case speechMarkTypes = "SpeechMarkTypes"
        case text = "Text"
        case textType = "TextType"
        case voiceId = "VoiceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engine = self.engine {
            try encodeContainer.encode(engine.rawValue, forKey: .engine)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let lexiconNames = lexiconNames {
            var lexiconNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lexiconNames)
            for lexiconname0 in lexiconNames {
                try lexiconNamesContainer.encode(lexiconname0)
            }
        }
        if let outputFormat = self.outputFormat {
            try encodeContainer.encode(outputFormat.rawValue, forKey: .outputFormat)
        }
        if let sampleRate = self.sampleRate {
            try encodeContainer.encode(sampleRate, forKey: .sampleRate)
        }
        if let speechMarkTypes = speechMarkTypes {
            var speechMarkTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .speechMarkTypes)
            for speechmarktype0 in speechMarkTypes {
                try speechMarkTypesContainer.encode(speechmarktype0.rawValue)
            }
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let textType = self.textType {
            try encodeContainer.encode(textType.rawValue, forKey: .textType)
        }
        if let voiceId = self.voiceId {
            try encodeContainer.encode(voiceId.rawValue, forKey: .voiceId)
        }
    }
}

extension SynthesizeSpeechInput {
    public func presignURL(config: PollyClient.PollyClientConfiguration, expiration: Foundation.TimeInterval) async throws -> ClientRuntime.URL? {
        let serviceName = "Polly"
        let input = self
        let encoder = ClientRuntime.JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        let decoder = ClientRuntime.JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "synthesizeSpeech")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withPartitionID(value: config.partitionID)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "polly")
                      .withSigningRegion(value: config.signingRegion)
                      .build()
        var operation = ClientRuntime.OperationStack<SynthesizeSpeechInput, SynthesizeSpeechOutput>(id: "synthesizeSpeech")
        operation.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLPathMiddleware<SynthesizeSpeechInput, SynthesizeSpeechOutput>(SynthesizeSpeechInput.urlPathProvider(_:)))
        operation.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLHostMiddleware<SynthesizeSpeechInput, SynthesizeSpeechOutput>())
        let endpointParams = EndpointParams(endpoint: config.endpoint, region: config.region, useDualStack: config.useDualStack ?? false, useFIPS: config.useFIPS ?? false)
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware<SynthesizeSpeechOutput>(endpointResolver: config.serviceSpecific.endpointResolver, endpointParams: endpointParams))
        operation.serializeStep.intercept(position: .after, middleware: SynthesizeSpeechInputGETQueryItemMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: ClientRuntime.RetryMiddleware<ClientRuntime.DefaultRetryStrategy, AWSClientRuntime.AWSRetryErrorInfoProvider, SynthesizeSpeechOutput>(options: config.retryStrategyOptions))
        let sigv4Config = AWSClientRuntime.SigV4Config(signatureType: .requestQueryParams, expiration: expiration, unsignedBody: false, signingAlgorithm: .sigv4)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware<SynthesizeSpeechOutput>(config: sigv4Config))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware<SynthesizeSpeechOutput>(responseClosure(decoder: decoder), responseErrorClosure(SynthesizeSpeechOutputError.self, decoder: decoder)))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.LoggerMiddleware<SynthesizeSpeechOutput>(clientLogMode: config.clientLogMode))
        let presignedRequestBuilder = try await operation.presignedRequest(context: context, input: input, output: SynthesizeSpeechOutput(), next: ClientRuntime.NoopHandler())
        guard let builtRequest = presignedRequestBuilder?.build(), let presignedURL = builtRequest.endpoint.url else {
            return nil
        }
        return presignedURL
    }
}

extension SynthesizeSpeechInput {
    public func presign(config: PollyClient.PollyClientConfiguration, expiration: Foundation.TimeInterval) async throws -> ClientRuntime.SdkHttpRequest? {
        let serviceName = "Polly"
        let input = self
        let encoder = ClientRuntime.JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        let decoder = ClientRuntime.JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "synthesizeSpeech")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withPartitionID(value: config.partitionID)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "polly")
                      .withSigningRegion(value: config.signingRegion)
                      .build()
        var operation = ClientRuntime.OperationStack<SynthesizeSpeechInput, SynthesizeSpeechOutput>(id: "synthesizeSpeech")
        operation.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLPathMiddleware<SynthesizeSpeechInput, SynthesizeSpeechOutput>(SynthesizeSpeechInput.urlPathProvider(_:)))
        operation.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLHostMiddleware<SynthesizeSpeechInput, SynthesizeSpeechOutput>())
        let endpointParams = EndpointParams(endpoint: config.endpoint, region: config.region, useDualStack: config.useDualStack ?? false, useFIPS: config.useFIPS ?? false)
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware<SynthesizeSpeechOutput>(endpointResolver: config.serviceSpecific.endpointResolver, endpointParams: endpointParams))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromConfig(serviceID: serviceName, version: "1.0", config: config)))
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<SynthesizeSpeechInput, SynthesizeSpeechOutput>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .after, middleware: ClientRuntime.BodyMiddleware<SynthesizeSpeechInput, SynthesizeSpeechOutput, ClientRuntime.JSONWriter>(documentWritingClosure: ClientRuntime.JSONReadWrite.documentWritingClosure(encoder: encoder), inputWritingClosure: JSONReadWrite.writingClosure()))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: ClientRuntime.RetryMiddleware<ClientRuntime.DefaultRetryStrategy, AWSClientRuntime.AWSRetryErrorInfoProvider, SynthesizeSpeechOutput>(options: config.retryStrategyOptions))
        let sigv4Config = AWSClientRuntime.SigV4Config(expiration: expiration, unsignedBody: false, signingAlgorithm: .sigv4)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware<SynthesizeSpeechOutput>(config: sigv4Config))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware<SynthesizeSpeechOutput>(responseClosure(decoder: decoder), responseErrorClosure(SynthesizeSpeechOutputError.self, decoder: decoder)))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.LoggerMiddleware<SynthesizeSpeechOutput>(clientLogMode: config.clientLogMode))
        let presignedRequestBuilder = try await operation.presignedRequest(context: context, input: input, output: SynthesizeSpeechOutput(), next: ClientRuntime.NoopHandler())
        guard let builtRequest = presignedRequestBuilder?.build() else {
            return nil
        }
        return builtRequest
    }
}

public struct SynthesizeSpeechInputGETQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SynthesizeSpeechInputGETQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SynthesizeSpeechInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<SynthesizeSpeechOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let engine = input.operationInput.engine {
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "Engine".urlPercentEncoding(), value: Swift.String(engine.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(queryItem)
        }
        if let languageCode = input.operationInput.languageCode {
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "LanguageCode".urlPercentEncoding(), value: Swift.String(languageCode.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(queryItem)
        }
        if let lexiconNames = input.operationInput.lexiconNames {
            lexiconNames.forEach { item in
                let queryItem = ClientRuntime.SDKURLQueryItem(name: "LexiconNames".urlPercentEncoding(), value: Swift.String(item).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let outputFormat = input.operationInput.outputFormat {
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "OutputFormat".urlPercentEncoding(), value: Swift.String(outputFormat.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(queryItem)
        }
        if let sampleRate = input.operationInput.sampleRate {
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "SampleRate".urlPercentEncoding(), value: Swift.String(sampleRate).urlPercentEncoding())
            input.builder.withQueryItem(queryItem)
        }
        if let speechMarkTypes = input.operationInput.speechMarkTypes {
            speechMarkTypes.forEach { item in
                let queryItem = ClientRuntime.SDKURLQueryItem(name: "SpeechMarkTypes".urlPercentEncoding(), value: Swift.String(item.rawValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let text = input.operationInput.text {
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "Text".urlPercentEncoding(), value: Swift.String(text).urlPercentEncoding())
            input.builder.withQueryItem(queryItem)
        }
        if let textType = input.operationInput.textType {
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "TextType".urlPercentEncoding(), value: Swift.String(textType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(queryItem)
        }
        if let voiceId = input.operationInput.voiceId {
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "VoiceId".urlPercentEncoding(), value: Swift.String(voiceId.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(queryItem)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SynthesizeSpeechInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SynthesizeSpeechOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension SynthesizeSpeechInput {

    static func urlPathProvider(_ value: SynthesizeSpeechInput) -> Swift.String? {
        return "/v1/speech"
    }
}

public struct SynthesizeSpeechInput: Swift.Equatable {
    /// Specifies the engine (standard, neural or long-form) for Amazon Polly to use when processing input text for speech synthesis. For information on Amazon Polly voices and which voices are available for each engine, see [Available Voices](https://docs.aws.amazon.com/polly/latest/dg/voicelist.html). NTTS-only voices When using NTTS-only voices such as Kevin (en-US), this parameter is required and must be set to neural. If the engine is not specified, or is set to standard, this will result in an error. long-form-only voices When using long-form-only voices such as Danielle (en-US), this parameter is required and must be set to long-form. If the engine is not specified, or is set to standard or neural, this will result in an error. Type: String Valid Values: standard | neural | long-form Required: Yes Standard voices For standard voices, this is not required; the engine parameter defaults to standard. If the engine is not specified, or is set to standard and an NTTS-only voice is selected, this will result in an error.
    public var engine: PollyClientTypes.Engine?
    /// Optional language code for the Synthesize Speech request. This is only necessary if using a bilingual voice, such as Aditi, which can be used for either Indian English (en-IN) or Hindi (hi-IN). If a bilingual voice is used and no language code is specified, Amazon Polly uses the default language of the bilingual voice. The default language for any voice is the one returned by the [DescribeVoices](https://docs.aws.amazon.com/polly/latest/dg/API_DescribeVoices.html) operation for the LanguageCode parameter. For example, if no language code is specified, Aditi will use Indian English rather than Hindi.
    public var languageCode: PollyClientTypes.LanguageCode?
    /// List of one or more pronunciation lexicon names you want the service to apply during synthesis. Lexicons are applied only if the language of the lexicon is the same as the language of the voice. For information about storing lexicons, see [PutLexicon](https://docs.aws.amazon.com/polly/latest/dg/API_PutLexicon.html).
    public var lexiconNames: [Swift.String]?
    /// The format in which the returned output will be encoded. For audio stream, this will be mp3, ogg_vorbis, or pcm. For speech marks, this will be json. When pcm is used, the content returned is audio/pcm in a signed 16-bit, 1 channel (mono), little-endian format.
    /// This member is required.
    public var outputFormat: PollyClientTypes.OutputFormat?
    /// The audio frequency specified in Hz. The valid values for mp3 and ogg_vorbis are "8000", "16000", "22050", and "24000". The default value for standard voices is "22050". The default value for neural voices is "24000". The default value for long-form voices is "24000". Valid values for pcm are "8000" and "16000" The default value is "16000".
    public var sampleRate: Swift.String?
    /// The type of speech marks returned for the input text.
    public var speechMarkTypes: [PollyClientTypes.SpeechMarkType]?
    /// Input text to synthesize. If you specify ssml as the TextType, follow the SSML format for the input text.
    /// This member is required.
    public var text: Swift.String?
    /// Specifies whether the input text is plain text or SSML. The default value is plain text. For more information, see [Using SSML](https://docs.aws.amazon.com/polly/latest/dg/ssml.html).
    public var textType: PollyClientTypes.TextType?
    /// Voice ID to use for the synthesis. You can get a list of available voice IDs by calling the [DescribeVoices](https://docs.aws.amazon.com/polly/latest/dg/API_DescribeVoices.html) operation.
    /// This member is required.
    public var voiceId: PollyClientTypes.VoiceId?

    public init(
        engine: PollyClientTypes.Engine? = nil,
        languageCode: PollyClientTypes.LanguageCode? = nil,
        lexiconNames: [Swift.String]? = nil,
        outputFormat: PollyClientTypes.OutputFormat? = nil,
        sampleRate: Swift.String? = nil,
        speechMarkTypes: [PollyClientTypes.SpeechMarkType]? = nil,
        text: Swift.String? = nil,
        textType: PollyClientTypes.TextType? = nil,
        voiceId: PollyClientTypes.VoiceId? = nil
    )
    {
        self.engine = engine
        self.languageCode = languageCode
        self.lexiconNames = lexiconNames
        self.outputFormat = outputFormat
        self.sampleRate = sampleRate
        self.speechMarkTypes = speechMarkTypes
        self.text = text
        self.textType = textType
        self.voiceId = voiceId
    }
}

struct SynthesizeSpeechInputBody: Swift.Equatable {
    let engine: PollyClientTypes.Engine?
    let languageCode: PollyClientTypes.LanguageCode?
    let lexiconNames: [Swift.String]?
    let outputFormat: PollyClientTypes.OutputFormat?
    let sampleRate: Swift.String?
    let speechMarkTypes: [PollyClientTypes.SpeechMarkType]?
    let text: Swift.String?
    let textType: PollyClientTypes.TextType?
    let voiceId: PollyClientTypes.VoiceId?
}

extension SynthesizeSpeechInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engine = "Engine"
        case languageCode = "LanguageCode"
        case lexiconNames = "LexiconNames"
        case outputFormat = "OutputFormat"
        case sampleRate = "SampleRate"
        case speechMarkTypes = "SpeechMarkTypes"
        case text = "Text"
        case textType = "TextType"
        case voiceId = "VoiceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineDecoded = try containerValues.decodeIfPresent(PollyClientTypes.Engine.self, forKey: .engine)
        engine = engineDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(PollyClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let lexiconNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .lexiconNames)
        var lexiconNamesDecoded0:[Swift.String]? = nil
        if let lexiconNamesContainer = lexiconNamesContainer {
            lexiconNamesDecoded0 = [Swift.String]()
            for string0 in lexiconNamesContainer {
                if let string0 = string0 {
                    lexiconNamesDecoded0?.append(string0)
                }
            }
        }
        lexiconNames = lexiconNamesDecoded0
        let outputFormatDecoded = try containerValues.decodeIfPresent(PollyClientTypes.OutputFormat.self, forKey: .outputFormat)
        outputFormat = outputFormatDecoded
        let sampleRateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sampleRate)
        sampleRate = sampleRateDecoded
        let speechMarkTypesContainer = try containerValues.decodeIfPresent([PollyClientTypes.SpeechMarkType?].self, forKey: .speechMarkTypes)
        var speechMarkTypesDecoded0:[PollyClientTypes.SpeechMarkType]? = nil
        if let speechMarkTypesContainer = speechMarkTypesContainer {
            speechMarkTypesDecoded0 = [PollyClientTypes.SpeechMarkType]()
            for enum0 in speechMarkTypesContainer {
                if let enum0 = enum0 {
                    speechMarkTypesDecoded0?.append(enum0)
                }
            }
        }
        speechMarkTypes = speechMarkTypesDecoded0
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let textTypeDecoded = try containerValues.decodeIfPresent(PollyClientTypes.TextType.self, forKey: .textType)
        textType = textTypeDecoded
        let voiceIdDecoded = try containerValues.decodeIfPresent(PollyClientTypes.VoiceId.self, forKey: .voiceId)
        voiceId = voiceIdDecoded
    }
}

extension SynthesizeSpeechOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let requestCharactersHeaderValue = httpResponse.headers.value(for: "x-amzn-RequestCharacters") {
            self.requestCharacters = Swift.Int(requestCharactersHeaderValue) ?? 0
        } else {
            self.requestCharacters = 0
        }
        switch httpResponse.body {
        case .data(let data):
            self.audioStream = .data(data)
        case .stream(let stream):
            self.audioStream = .stream(stream)
        case .noStream:
            self.audioStream = nil
        }
    }
}

public struct SynthesizeSpeechOutput: Swift.Equatable {
    /// Stream containing the synthesized speech.
    public var audioStream: ClientRuntime.ByteStream?
    /// Specifies the type audio stream. This should reflect the OutputFormat parameter in your request.
    ///
    /// * If you request mp3 as the OutputFormat, the ContentType returned is audio/mpeg.
    ///
    /// * If you request ogg_vorbis as the OutputFormat, the ContentType returned is audio/ogg.
    ///
    /// * If you request pcm as the OutputFormat, the ContentType returned is audio/pcm in a signed 16-bit, 1 channel (mono), little-endian format.
    ///
    /// * If you request json as the OutputFormat, the ContentType returned is application/x-json-stream.
    public var contentType: Swift.String?
    /// Number of characters synthesized.
    public var requestCharacters: Swift.Int

    public init(
        audioStream: ClientRuntime.ByteStream? = nil,
        contentType: Swift.String? = nil,
        requestCharacters: Swift.Int = 0
    )
    {
        self.audioStream = audioStream
        self.contentType = contentType
        self.requestCharacters = requestCharacters
    }
}

struct SynthesizeSpeechOutputBody: Swift.Equatable {
    let audioStream: ClientRuntime.ByteStream?
}

extension SynthesizeSpeechOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioStream = "AudioStream"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioStreamDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .audioStream)
        audioStream = audioStreamDecoded
    }
}

enum SynthesizeSpeechOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EngineNotSupportedException": return try await EngineNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidSampleRateException": return try await InvalidSampleRateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidSsmlException": return try await InvalidSsmlException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LanguageNotSupportedException": return try await LanguageNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LexiconNotFoundException": return try await LexiconNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MarksNotSupportedForFormatException": return try await MarksNotSupportedForFormatException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SsmlMarksNotSupportedForTextTypeException": return try await SsmlMarksNotSupportedForTextTypeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TextLengthExceededException": return try await TextLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PollyClientTypes {
    public enum TaskStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case scheduled
        case sdkUnknown(Swift.String)

        public static var allCases: [TaskStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .scheduled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "completed"
            case .failed: return "failed"
            case .inProgress: return "inProgress"
            case .scheduled: return "scheduled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TaskStatus(rawValue: rawValue) ?? TaskStatus.sdkUnknown(rawValue)
        }
    }
}

extension TextLengthExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TextLengthExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The value of the "Text" parameter is longer than the accepted limits. For the SynthesizeSpeech API, the limit for input text is a maximum of 6000 characters total, of which no more than 3000 can be billed characters. For the StartSpeechSynthesisTask API, the maximum is 200,000 characters, of which no more than 100,000 can be billed characters. SSML tags are not counted as billed characters.
public struct TextLengthExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TextLengthExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TextLengthExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TextLengthExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PollyClientTypes {
    public enum TextType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ssml
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [TextType] {
            return [
                .ssml,
                .text,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ssml: return "ssml"
            case .text: return "text"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TextType(rawValue: rawValue) ?? TextType.sdkUnknown(rawValue)
        }
    }
}

extension UnsupportedPlsAlphabetException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnsupportedPlsAlphabetExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The alphabet specified by the lexicon is not a supported alphabet. Valid values are x-sampa and ipa.
public struct UnsupportedPlsAlphabetException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedPlsAlphabetException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UnsupportedPlsAlphabetExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedPlsAlphabetExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedPlsLanguageException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnsupportedPlsLanguageExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The language specified in the lexicon is unsupported. For a list of supported languages, see [Lexicon Attributes](https://docs.aws.amazon.com/polly/latest/dg/API_LexiconAttributes.html).
public struct UnsupportedPlsLanguageException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedPlsLanguageException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UnsupportedPlsLanguageExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedPlsLanguageExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PollyClientTypes.Voice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalLanguageCodes = "AdditionalLanguageCodes"
        case gender = "Gender"
        case id = "Id"
        case languageCode = "LanguageCode"
        case languageName = "LanguageName"
        case name = "Name"
        case supportedEngines = "SupportedEngines"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalLanguageCodes = additionalLanguageCodes {
            var additionalLanguageCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalLanguageCodes)
            for languagecode0 in additionalLanguageCodes {
                try additionalLanguageCodesContainer.encode(languagecode0.rawValue)
            }
        }
        if let gender = self.gender {
            try encodeContainer.encode(gender.rawValue, forKey: .gender)
        }
        if let id = self.id {
            try encodeContainer.encode(id.rawValue, forKey: .id)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let languageName = self.languageName {
            try encodeContainer.encode(languageName, forKey: .languageName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let supportedEngines = supportedEngines {
            var supportedEnginesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedEngines)
            for engine0 in supportedEngines {
                try supportedEnginesContainer.encode(engine0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let genderDecoded = try containerValues.decodeIfPresent(PollyClientTypes.Gender.self, forKey: .gender)
        gender = genderDecoded
        let idDecoded = try containerValues.decodeIfPresent(PollyClientTypes.VoiceId.self, forKey: .id)
        id = idDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(PollyClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let languageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .languageName)
        languageName = languageNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let additionalLanguageCodesContainer = try containerValues.decodeIfPresent([PollyClientTypes.LanguageCode?].self, forKey: .additionalLanguageCodes)
        var additionalLanguageCodesDecoded0:[PollyClientTypes.LanguageCode]? = nil
        if let additionalLanguageCodesContainer = additionalLanguageCodesContainer {
            additionalLanguageCodesDecoded0 = [PollyClientTypes.LanguageCode]()
            for enum0 in additionalLanguageCodesContainer {
                if let enum0 = enum0 {
                    additionalLanguageCodesDecoded0?.append(enum0)
                }
            }
        }
        additionalLanguageCodes = additionalLanguageCodesDecoded0
        let supportedEnginesContainer = try containerValues.decodeIfPresent([PollyClientTypes.Engine?].self, forKey: .supportedEngines)
        var supportedEnginesDecoded0:[PollyClientTypes.Engine]? = nil
        if let supportedEnginesContainer = supportedEnginesContainer {
            supportedEnginesDecoded0 = [PollyClientTypes.Engine]()
            for enum0 in supportedEnginesContainer {
                if let enum0 = enum0 {
                    supportedEnginesDecoded0?.append(enum0)
                }
            }
        }
        supportedEngines = supportedEnginesDecoded0
    }
}

extension PollyClientTypes {
    /// Description of the voice.
    public struct Voice: Swift.Equatable {
        /// Additional codes for languages available for the specified voice in addition to its default language. For example, the default language for Aditi is Indian English (en-IN) because it was first used for that language. Since Aditi is bilingual and fluent in both Indian English and Hindi, this parameter would show the code hi-IN.
        public var additionalLanguageCodes: [PollyClientTypes.LanguageCode]?
        /// Gender of the voice.
        public var gender: PollyClientTypes.Gender?
        /// Amazon Polly assigned voice ID. This is the ID that you specify when calling the SynthesizeSpeech operation.
        public var id: PollyClientTypes.VoiceId?
        /// Language code of the voice.
        public var languageCode: PollyClientTypes.LanguageCode?
        /// Human readable name of the language in English.
        public var languageName: Swift.String?
        /// Name of the voice (for example, Salli, Kendra, etc.). This provides a human readable voice name that you might display in your application.
        public var name: Swift.String?
        /// Specifies which engines (standard, neural or long-form) are supported by a given voice.
        public var supportedEngines: [PollyClientTypes.Engine]?

        public init(
            additionalLanguageCodes: [PollyClientTypes.LanguageCode]? = nil,
            gender: PollyClientTypes.Gender? = nil,
            id: PollyClientTypes.VoiceId? = nil,
            languageCode: PollyClientTypes.LanguageCode? = nil,
            languageName: Swift.String? = nil,
            name: Swift.String? = nil,
            supportedEngines: [PollyClientTypes.Engine]? = nil
        )
        {
            self.additionalLanguageCodes = additionalLanguageCodes
            self.gender = gender
            self.id = id
            self.languageCode = languageCode
            self.languageName = languageName
            self.name = name
            self.supportedEngines = supportedEngines
        }
    }

}

extension PollyClientTypes {
    public enum VoiceId: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aditi
        case adriano
        case amy
        case andres
        case aria
        case arlet
        case arthur
        case astrid
        case ayanda
        case bianca
        case brian
        case camila
        case carla
        case carmen
        case celine
        case chantal
        case conchita
        case cristiano
        case daniel
        case danielle
        case dora
        case elin
        case emma
        case enrique
        case ewa
        case filiz
        case gabrielle
        case geraint
        case giorgio
        case gregory
        case gwyneth
        case hala
        case hannah
        case hans
        case hiujin
        case ida
        case ines
        case isabelle
        case ivy
        case jacek
        case jan
        case joanna
        case joey
        case justin
        case kajal
        case karl
        case kazuha
        case kendra
        case kevin
        case kimberly
        case laura
        case lea
        case liam
        case lisa
        case liv
        case lotte
        case lucia
        case lupe
        case mads
        case maja
        case marlene
        case mathieu
        case matthew
        case maxim
        case mia
        case miguel
        case mizuki
        case naja
        case niamh
        case nicole
        case ola
        case olivia
        case pedro
        case penelope
        case raveena
        case remi
        case ricardo
        case ruben
        case russell
        case ruth
        case salli
        case seoyeon
        case sergio
        case sofie
        case stephen
        case suvi
        case takumi
        case tatyana
        case thiago
        case tomoko
        case vicki
        case vitoria
        case zayd
        case zeina
        case zhiyu
        case sdkUnknown(Swift.String)

        public static var allCases: [VoiceId] {
            return [
                .aditi,
                .adriano,
                .amy,
                .andres,
                .aria,
                .arlet,
                .arthur,
                .astrid,
                .ayanda,
                .bianca,
                .brian,
                .camila,
                .carla,
                .carmen,
                .celine,
                .chantal,
                .conchita,
                .cristiano,
                .daniel,
                .danielle,
                .dora,
                .elin,
                .emma,
                .enrique,
                .ewa,
                .filiz,
                .gabrielle,
                .geraint,
                .giorgio,
                .gregory,
                .gwyneth,
                .hala,
                .hannah,
                .hans,
                .hiujin,
                .ida,
                .ines,
                .isabelle,
                .ivy,
                .jacek,
                .jan,
                .joanna,
                .joey,
                .justin,
                .kajal,
                .karl,
                .kazuha,
                .kendra,
                .kevin,
                .kimberly,
                .laura,
                .lea,
                .liam,
                .lisa,
                .liv,
                .lotte,
                .lucia,
                .lupe,
                .mads,
                .maja,
                .marlene,
                .mathieu,
                .matthew,
                .maxim,
                .mia,
                .miguel,
                .mizuki,
                .naja,
                .niamh,
                .nicole,
                .ola,
                .olivia,
                .pedro,
                .penelope,
                .raveena,
                .remi,
                .ricardo,
                .ruben,
                .russell,
                .ruth,
                .salli,
                .seoyeon,
                .sergio,
                .sofie,
                .stephen,
                .suvi,
                .takumi,
                .tatyana,
                .thiago,
                .tomoko,
                .vicki,
                .vitoria,
                .zayd,
                .zeina,
                .zhiyu,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aditi: return "Aditi"
            case .adriano: return "Adriano"
            case .amy: return "Amy"
            case .andres: return "Andres"
            case .aria: return "Aria"
            case .arlet: return "Arlet"
            case .arthur: return "Arthur"
            case .astrid: return "Astrid"
            case .ayanda: return "Ayanda"
            case .bianca: return "Bianca"
            case .brian: return "Brian"
            case .camila: return "Camila"
            case .carla: return "Carla"
            case .carmen: return "Carmen"
            case .celine: return "Celine"
            case .chantal: return "Chantal"
            case .conchita: return "Conchita"
            case .cristiano: return "Cristiano"
            case .daniel: return "Daniel"
            case .danielle: return "Danielle"
            case .dora: return "Dora"
            case .elin: return "Elin"
            case .emma: return "Emma"
            case .enrique: return "Enrique"
            case .ewa: return "Ewa"
            case .filiz: return "Filiz"
            case .gabrielle: return "Gabrielle"
            case .geraint: return "Geraint"
            case .giorgio: return "Giorgio"
            case .gregory: return "Gregory"
            case .gwyneth: return "Gwyneth"
            case .hala: return "Hala"
            case .hannah: return "Hannah"
            case .hans: return "Hans"
            case .hiujin: return "Hiujin"
            case .ida: return "Ida"
            case .ines: return "Ines"
            case .isabelle: return "Isabelle"
            case .ivy: return "Ivy"
            case .jacek: return "Jacek"
            case .jan: return "Jan"
            case .joanna: return "Joanna"
            case .joey: return "Joey"
            case .justin: return "Justin"
            case .kajal: return "Kajal"
            case .karl: return "Karl"
            case .kazuha: return "Kazuha"
            case .kendra: return "Kendra"
            case .kevin: return "Kevin"
            case .kimberly: return "Kimberly"
            case .laura: return "Laura"
            case .lea: return "Lea"
            case .liam: return "Liam"
            case .lisa: return "Lisa"
            case .liv: return "Liv"
            case .lotte: return "Lotte"
            case .lucia: return "Lucia"
            case .lupe: return "Lupe"
            case .mads: return "Mads"
            case .maja: return "Maja"
            case .marlene: return "Marlene"
            case .mathieu: return "Mathieu"
            case .matthew: return "Matthew"
            case .maxim: return "Maxim"
            case .mia: return "Mia"
            case .miguel: return "Miguel"
            case .mizuki: return "Mizuki"
            case .naja: return "Naja"
            case .niamh: return "Niamh"
            case .nicole: return "Nicole"
            case .ola: return "Ola"
            case .olivia: return "Olivia"
            case .pedro: return "Pedro"
            case .penelope: return "Penelope"
            case .raveena: return "Raveena"
            case .remi: return "Remi"
            case .ricardo: return "Ricardo"
            case .ruben: return "Ruben"
            case .russell: return "Russell"
            case .ruth: return "Ruth"
            case .salli: return "Salli"
            case .seoyeon: return "Seoyeon"
            case .sergio: return "Sergio"
            case .sofie: return "Sofie"
            case .stephen: return "Stephen"
            case .suvi: return "Suvi"
            case .takumi: return "Takumi"
            case .tatyana: return "Tatyana"
            case .thiago: return "Thiago"
            case .tomoko: return "Tomoko"
            case .vicki: return "Vicki"
            case .vitoria: return "Vitoria"
            case .zayd: return "Zayd"
            case .zeina: return "Zeina"
            case .zhiyu: return "Zhiyu"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VoiceId(rawValue: rawValue) ?? VoiceId.sdkUnknown(rawValue)
        }
    }
}
