//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.listWritingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

public struct DeleteConnectorOutput {

    public init() { }
}

public struct DeleteVcenterClientOutput {

    public init() { }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceOutput {

    public init() { }
}

/// Operating denied due to a file permission or access check error.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

extension MgnClientTypes {

    public enum ActionCategory: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case backup
        case configuration
        case disasterRecovery
        case licenseAndSubscription
        case networking
        case observability
        case operatingSystem
        case other
        case refactoring
        case security
        case validation
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionCategory] {
            return [
                .backup,
                .configuration,
                .disasterRecovery,
                .licenseAndSubscription,
                .networking,
                .observability,
                .operatingSystem,
                .other,
                .refactoring,
                .security,
                .validation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .backup: return "BACKUP"
            case .configuration: return "CONFIGURATION"
            case .disasterRecovery: return "DISASTER_RECOVERY"
            case .licenseAndSubscription: return "LICENSE_AND_SUBSCRIPTION"
            case .networking: return "NETWORKING"
            case .observability: return "OBSERVABILITY"
            case .operatingSystem: return "OPERATING_SYSTEM"
            case .other: return "OTHER"
            case .refactoring: return "REFACTORING"
            case .security: return "SECURITY"
            case .validation: return "VALIDATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MgnClientTypes {

    public enum ApplicationHealthStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case error
        case healthy
        case lagging
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationHealthStatus] {
            return [
                .error,
                .healthy,
                .lagging
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .healthy: return "HEALTHY"
            case .lagging: return "LAGGING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MgnClientTypes {

    public enum ApplicationProgressStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case inProgress
        case notStarted
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationProgressStatus] {
            return [
                .completed,
                .inProgress,
                .notStarted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MgnClientTypes {
    /// Application aggregated status.
    public struct ApplicationAggregatedStatus {
        /// Application aggregated status health status.
        public var healthStatus: MgnClientTypes.ApplicationHealthStatus?
        /// Application aggregated status last update dateTime.
        public var lastUpdateDateTime: Swift.String?
        /// Application aggregated status progress status.
        public var progressStatus: MgnClientTypes.ApplicationProgressStatus?
        /// Application aggregated status total source servers amount.
        public var totalSourceServers: Swift.Int

        public init(
            healthStatus: MgnClientTypes.ApplicationHealthStatus? = nil,
            lastUpdateDateTime: Swift.String? = nil,
            progressStatus: MgnClientTypes.ApplicationProgressStatus? = nil,
            totalSourceServers: Swift.Int = 0
        )
        {
            self.healthStatus = healthStatus
            self.lastUpdateDateTime = lastUpdateDateTime
            self.progressStatus = progressStatus
            self.totalSourceServers = totalSourceServers
        }
    }

}

extension MgnClientTypes {
    public struct Application {
        /// Application aggregated status.
        public var applicationAggregatedStatus: MgnClientTypes.ApplicationAggregatedStatus?
        /// Application ID.
        public var applicationID: Swift.String?
        /// Application ARN.
        public var arn: Swift.String?
        /// Application creation dateTime.
        public var creationDateTime: Swift.String?
        /// Application description.
        public var description: Swift.String?
        /// Application archival status.
        public var isArchived: Swift.Bool?
        /// Application last modified dateTime.
        public var lastModifiedDateTime: Swift.String?
        /// Application name.
        public var name: Swift.String?
        /// Application tags.
        public var tags: [Swift.String: Swift.String]?
        /// Application wave ID.
        public var waveID: Swift.String?

        public init(
            applicationAggregatedStatus: MgnClientTypes.ApplicationAggregatedStatus? = nil,
            applicationID: Swift.String? = nil,
            arn: Swift.String? = nil,
            creationDateTime: Swift.String? = nil,
            description: Swift.String? = nil,
            isArchived: Swift.Bool? = nil,
            lastModifiedDateTime: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            waveID: Swift.String? = nil
        )
        {
            self.applicationAggregatedStatus = applicationAggregatedStatus
            self.applicationID = applicationID
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.description = description
            self.isArchived = isArchived
            self.lastModifiedDateTime = lastModifiedDateTime
            self.name = name
            self.tags = tags
            self.waveID = waveID
        }
    }

}

extension MgnClientTypes.Application: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Application(applicationAggregatedStatus: \(Swift.String(describing: applicationAggregatedStatus)), applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), creationDateTime: \(Swift.String(describing: creationDateTime)), description: \(Swift.String(describing: description)), isArchived: \(Swift.String(describing: isArchived)), lastModifiedDateTime: \(Swift.String(describing: lastModifiedDateTime)), name: \(Swift.String(describing: name)), waveID: \(Swift.String(describing: waveID)), tags: \"CONTENT_REDACTED\")"}
}

extension MgnClientTypes {
    /// Error details.
    public struct ErrorDetails {
        /// Error details code.
        public var code: Swift.String?
        /// Error details message.
        public var message: Swift.String?
        /// Error details resourceId.
        public var resourceId: Swift.String?
        /// Error details resourceType.
        public var resourceType: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }
    }

}

/// The request could not be completed due to a conflict with the current state of the target resource.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        /// Conflict Exception specific errors.
        public internal(set) var errors: [MgnClientTypes.ErrorDetails]? = nil
        public internal(set) var message: Swift.String? = nil
        /// A conflict occurred when prompting for the Resource ID.
        public internal(set) var resourceId: Swift.String? = nil
        /// A conflict occurred when prompting for resource type.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        errors: [MgnClientTypes.ErrorDetails]? = nil,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.errors = errors
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// Resource not found exception.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        /// Resource ID not found error.
        public internal(set) var resourceId: Swift.String? = nil
        /// Resource type not found error.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// The request could not be completed because its exceeded the service quota.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        /// Exceeded the service quota code.
        public internal(set) var quotaCode: Swift.String? = nil
        /// Exceeded the service quota value.
        public internal(set) var quotaValue: Swift.Int? = nil
        /// Exceeded the service quota resource ID.
        public internal(set) var resourceId: Swift.String? = nil
        /// Exceeded the service quota resource type.
        public internal(set) var resourceType: Swift.String? = nil
        /// Exceeded the service quota service code.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        quotaValue: Swift.Int? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.quotaValue = quotaValue
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

/// Uninitialized account exception.
public struct UninitializedAccountException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UninitializedAccountException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

public struct ArchiveApplicationInput {
    /// Account ID.
    public var accountID: Swift.String?
    /// Application ID.
    /// This member is required.
    public var applicationID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        applicationID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.applicationID = applicationID
    }
}

public struct ArchiveApplicationOutput {
    /// Application aggregated status.
    public var applicationAggregatedStatus: MgnClientTypes.ApplicationAggregatedStatus?
    /// Application ID.
    public var applicationID: Swift.String?
    /// Application ARN.
    public var arn: Swift.String?
    /// Application creation dateTime.
    public var creationDateTime: Swift.String?
    /// Application description.
    public var description: Swift.String?
    /// Application archival status.
    public var isArchived: Swift.Bool?
    /// Application last modified dateTime.
    public var lastModifiedDateTime: Swift.String?
    /// Application name.
    public var name: Swift.String?
    /// Application tags.
    public var tags: [Swift.String: Swift.String]?
    /// Application wave ID.
    public var waveID: Swift.String?

    public init(
        applicationAggregatedStatus: MgnClientTypes.ApplicationAggregatedStatus? = nil,
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        creationDateTime: Swift.String? = nil,
        description: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        lastModifiedDateTime: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        waveID: Swift.String? = nil
    )
    {
        self.applicationAggregatedStatus = applicationAggregatedStatus
        self.applicationID = applicationID
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.description = description
        self.isArchived = isArchived
        self.lastModifiedDateTime = lastModifiedDateTime
        self.name = name
        self.tags = tags
        self.waveID = waveID
    }
}

extension ArchiveApplicationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ArchiveApplicationOutput(applicationAggregatedStatus: \(Swift.String(describing: applicationAggregatedStatus)), applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), creationDateTime: \(Swift.String(describing: creationDateTime)), description: \(Swift.String(describing: description)), isArchived: \(Swift.String(describing: isArchived)), lastModifiedDateTime: \(Swift.String(describing: lastModifiedDateTime)), name: \(Swift.String(describing: name)), waveID: \(Swift.String(describing: waveID)), tags: \"CONTENT_REDACTED\")"}
}

public struct AssociateSourceServersInput {
    /// Account ID.
    public var accountID: Swift.String?
    /// Application ID.
    /// This member is required.
    public var applicationID: Swift.String?
    /// Source server IDs list.
    /// This member is required.
    public var sourceServerIDs: [Swift.String]?

    public init(
        accountID: Swift.String? = nil,
        applicationID: Swift.String? = nil,
        sourceServerIDs: [Swift.String]? = nil
    )
    {
        self.accountID = accountID
        self.applicationID = applicationID
        self.sourceServerIDs = sourceServerIDs
    }
}

public struct AssociateSourceServersOutput {

    public init() { }
}

public struct CreateApplicationInput {
    /// Account ID.
    public var accountID: Swift.String?
    /// Application description.
    public var description: Swift.String?
    /// Application name.
    /// This member is required.
    public var name: Swift.String?
    /// Application tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        accountID: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.accountID = accountID
        self.description = description
        self.name = name
        self.tags = tags
    }
}

extension CreateApplicationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateApplicationInput(accountID: \(Swift.String(describing: accountID)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), tags: \"CONTENT_REDACTED\")"}
}

public struct CreateApplicationOutput {
    /// Application aggregated status.
    public var applicationAggregatedStatus: MgnClientTypes.ApplicationAggregatedStatus?
    /// Application ID.
    public var applicationID: Swift.String?
    /// Application ARN.
    public var arn: Swift.String?
    /// Application creation dateTime.
    public var creationDateTime: Swift.String?
    /// Application description.
    public var description: Swift.String?
    /// Application archival status.
    public var isArchived: Swift.Bool?
    /// Application last modified dateTime.
    public var lastModifiedDateTime: Swift.String?
    /// Application name.
    public var name: Swift.String?
    /// Application tags.
    public var tags: [Swift.String: Swift.String]?
    /// Application wave ID.
    public var waveID: Swift.String?

    public init(
        applicationAggregatedStatus: MgnClientTypes.ApplicationAggregatedStatus? = nil,
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        creationDateTime: Swift.String? = nil,
        description: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        lastModifiedDateTime: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        waveID: Swift.String? = nil
    )
    {
        self.applicationAggregatedStatus = applicationAggregatedStatus
        self.applicationID = applicationID
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.description = description
        self.isArchived = isArchived
        self.lastModifiedDateTime = lastModifiedDateTime
        self.name = name
        self.tags = tags
        self.waveID = waveID
    }
}

extension CreateApplicationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateApplicationOutput(applicationAggregatedStatus: \(Swift.String(describing: applicationAggregatedStatus)), applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), creationDateTime: \(Swift.String(describing: creationDateTime)), description: \(Swift.String(describing: description)), isArchived: \(Swift.String(describing: isArchived)), lastModifiedDateTime: \(Swift.String(describing: lastModifiedDateTime)), name: \(Swift.String(describing: name)), waveID: \(Swift.String(describing: waveID)), tags: \"CONTENT_REDACTED\")"}
}

public struct DeleteApplicationInput {
    /// Account ID.
    public var accountID: Swift.String?
    /// Application ID.
    /// This member is required.
    public var applicationID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        applicationID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.applicationID = applicationID
    }
}

public struct DeleteApplicationOutput {

    public init() { }
}

public struct DisassociateSourceServersInput {
    /// Account ID.
    public var accountID: Swift.String?
    /// Application ID.
    /// This member is required.
    public var applicationID: Swift.String?
    /// Source server IDs list.
    /// This member is required.
    public var sourceServerIDs: [Swift.String]?

    public init(
        accountID: Swift.String? = nil,
        applicationID: Swift.String? = nil,
        sourceServerIDs: [Swift.String]? = nil
    )
    {
        self.accountID = accountID
        self.applicationID = applicationID
        self.sourceServerIDs = sourceServerIDs
    }
}

public struct DisassociateSourceServersOutput {

    public init() { }
}

extension MgnClientTypes {
    /// Applications list filters.
    public struct ListApplicationsRequestFilters {
        /// Filter applications list by application ID.
        public var applicationIDs: [Swift.String]?
        /// Filter applications list by archival status.
        public var isArchived: Swift.Bool?
        /// Filter applications list by wave ID.
        public var waveIDs: [Swift.String]?

        public init(
            applicationIDs: [Swift.String]? = nil,
            isArchived: Swift.Bool? = nil,
            waveIDs: [Swift.String]? = nil
        )
        {
            self.applicationIDs = applicationIDs
            self.isArchived = isArchived
            self.waveIDs = waveIDs
        }
    }

}

public struct ListApplicationsInput {
    /// Applications list Account ID.
    public var accountID: Swift.String?
    /// Applications list filters.
    public var filters: MgnClientTypes.ListApplicationsRequestFilters?
    /// Maximum results to return when listing applications.
    public var maxResults: Swift.Int?
    /// Request next token.
    public var nextToken: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        filters: MgnClientTypes.ListApplicationsRequestFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListApplicationsOutput {
    /// Applications list.
    public var items: [MgnClientTypes.Application]?
    /// Response next token.
    public var nextToken: Swift.String?

    public init(
        items: [MgnClientTypes.Application]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct UnarchiveApplicationInput {
    /// Account ID.
    public var accountID: Swift.String?
    /// Application ID.
    /// This member is required.
    public var applicationID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        applicationID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.applicationID = applicationID
    }
}

public struct UnarchiveApplicationOutput {
    /// Application aggregated status.
    public var applicationAggregatedStatus: MgnClientTypes.ApplicationAggregatedStatus?
    /// Application ID.
    public var applicationID: Swift.String?
    /// Application ARN.
    public var arn: Swift.String?
    /// Application creation dateTime.
    public var creationDateTime: Swift.String?
    /// Application description.
    public var description: Swift.String?
    /// Application archival status.
    public var isArchived: Swift.Bool?
    /// Application last modified dateTime.
    public var lastModifiedDateTime: Swift.String?
    /// Application name.
    public var name: Swift.String?
    /// Application tags.
    public var tags: [Swift.String: Swift.String]?
    /// Application wave ID.
    public var waveID: Swift.String?

    public init(
        applicationAggregatedStatus: MgnClientTypes.ApplicationAggregatedStatus? = nil,
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        creationDateTime: Swift.String? = nil,
        description: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        lastModifiedDateTime: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        waveID: Swift.String? = nil
    )
    {
        self.applicationAggregatedStatus = applicationAggregatedStatus
        self.applicationID = applicationID
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.description = description
        self.isArchived = isArchived
        self.lastModifiedDateTime = lastModifiedDateTime
        self.name = name
        self.tags = tags
        self.waveID = waveID
    }
}

extension UnarchiveApplicationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnarchiveApplicationOutput(applicationAggregatedStatus: \(Swift.String(describing: applicationAggregatedStatus)), applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), creationDateTime: \(Swift.String(describing: creationDateTime)), description: \(Swift.String(describing: description)), isArchived: \(Swift.String(describing: isArchived)), lastModifiedDateTime: \(Swift.String(describing: lastModifiedDateTime)), name: \(Swift.String(describing: name)), waveID: \(Swift.String(describing: waveID)), tags: \"CONTENT_REDACTED\")"}
}

public struct UpdateApplicationInput {
    /// Account ID.
    public var accountID: Swift.String?
    /// Application ID.
    /// This member is required.
    public var applicationID: Swift.String?
    /// Application description.
    public var description: Swift.String?
    /// Application name.
    public var name: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        applicationID: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.applicationID = applicationID
        self.description = description
        self.name = name
    }
}

public struct UpdateApplicationOutput {
    /// Application aggregated status.
    public var applicationAggregatedStatus: MgnClientTypes.ApplicationAggregatedStatus?
    /// Application ID.
    public var applicationID: Swift.String?
    /// Application ARN.
    public var arn: Swift.String?
    /// Application creation dateTime.
    public var creationDateTime: Swift.String?
    /// Application description.
    public var description: Swift.String?
    /// Application archival status.
    public var isArchived: Swift.Bool?
    /// Application last modified dateTime.
    public var lastModifiedDateTime: Swift.String?
    /// Application name.
    public var name: Swift.String?
    /// Application tags.
    public var tags: [Swift.String: Swift.String]?
    /// Application wave ID.
    public var waveID: Swift.String?

    public init(
        applicationAggregatedStatus: MgnClientTypes.ApplicationAggregatedStatus? = nil,
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        creationDateTime: Swift.String? = nil,
        description: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        lastModifiedDateTime: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        waveID: Swift.String? = nil
    )
    {
        self.applicationAggregatedStatus = applicationAggregatedStatus
        self.applicationID = applicationID
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.description = description
        self.isArchived = isArchived
        self.lastModifiedDateTime = lastModifiedDateTime
        self.name = name
        self.tags = tags
        self.waveID = waveID
    }
}

extension UpdateApplicationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateApplicationOutput(applicationAggregatedStatus: \(Swift.String(describing: applicationAggregatedStatus)), applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), creationDateTime: \(Swift.String(describing: creationDateTime)), description: \(Swift.String(describing: description)), isArchived: \(Swift.String(describing: isArchived)), lastModifiedDateTime: \(Swift.String(describing: lastModifiedDateTime)), name: \(Swift.String(describing: name)), waveID: \(Swift.String(describing: waveID)), tags: \"CONTENT_REDACTED\")"}
}

extension MgnClientTypes {
    /// Validate exception field.
    public struct ValidationExceptionField {
        /// Validate exception field message.
        public var message: Swift.String?
        /// Validate exception field name.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension MgnClientTypes {

    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Validate exception.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        /// Validate exception field list.
        public internal(set) var fieldList: [MgnClientTypes.ValidationExceptionField]? = nil
        public internal(set) var message: Swift.String? = nil
        /// Validate exception reason.
        public internal(set) var reason: MgnClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        fieldList: [MgnClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: MgnClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.code = code
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension MgnClientTypes {
    /// Connector SSM command config.
    public struct ConnectorSsmCommandConfig {
        /// Connector SSM command config CloudWatch log group name.
        public var cloudWatchLogGroupName: Swift.String?
        /// Connector SSM command config CloudWatch output enabled.
        /// This member is required.
        public var cloudWatchOutputEnabled: Swift.Bool?
        /// Connector SSM command config output S3 bucket name.
        public var outputS3BucketName: Swift.String?
        /// Connector SSM command config S3 output enabled.
        /// This member is required.
        public var s3OutputEnabled: Swift.Bool?

        public init(
            cloudWatchLogGroupName: Swift.String? = nil,
            cloudWatchOutputEnabled: Swift.Bool? = nil,
            outputS3BucketName: Swift.String? = nil,
            s3OutputEnabled: Swift.Bool? = nil
        )
        {
            self.cloudWatchLogGroupName = cloudWatchLogGroupName
            self.cloudWatchOutputEnabled = cloudWatchOutputEnabled
            self.outputS3BucketName = outputS3BucketName
            self.s3OutputEnabled = s3OutputEnabled
        }
    }

}

public struct CreateConnectorInput {
    /// Create Connector request name.
    /// This member is required.
    public var name: Swift.String?
    /// Create Connector request SSM command config.
    public var ssmCommandConfig: MgnClientTypes.ConnectorSsmCommandConfig?
    /// Create Connector request SSM instance ID.
    /// This member is required.
    public var ssmInstanceID: Swift.String?
    /// Create Connector request tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        name: Swift.String? = nil,
        ssmCommandConfig: MgnClientTypes.ConnectorSsmCommandConfig? = nil,
        ssmInstanceID: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.name = name
        self.ssmCommandConfig = ssmCommandConfig
        self.ssmInstanceID = ssmInstanceID
        self.tags = tags
    }
}

extension CreateConnectorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConnectorInput(name: \(Swift.String(describing: name)), ssmCommandConfig: \(Swift.String(describing: ssmCommandConfig)), ssmInstanceID: \(Swift.String(describing: ssmInstanceID)), tags: \"CONTENT_REDACTED\")"}
}

public struct CreateConnectorOutput {
    /// Connector arn.
    public var arn: Swift.String?
    /// Connector ID.
    public var connectorID: Swift.String?
    /// Connector name.
    public var name: Swift.String?
    /// Connector SSM command config.
    public var ssmCommandConfig: MgnClientTypes.ConnectorSsmCommandConfig?
    /// Connector SSM instance ID.
    public var ssmInstanceID: Swift.String?
    /// Connector tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        connectorID: Swift.String? = nil,
        name: Swift.String? = nil,
        ssmCommandConfig: MgnClientTypes.ConnectorSsmCommandConfig? = nil,
        ssmInstanceID: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.connectorID = connectorID
        self.name = name
        self.ssmCommandConfig = ssmCommandConfig
        self.ssmInstanceID = ssmInstanceID
        self.tags = tags
    }
}

extension CreateConnectorOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConnectorOutput(arn: \(Swift.String(describing: arn)), connectorID: \(Swift.String(describing: connectorID)), name: \(Swift.String(describing: name)), ssmCommandConfig: \(Swift.String(describing: ssmCommandConfig)), ssmInstanceID: \(Swift.String(describing: ssmInstanceID)), tags: \"CONTENT_REDACTED\")"}
}

public struct DeleteConnectorInput {
    /// Delete Connector request connector ID.
    /// This member is required.
    public var connectorID: Swift.String?

    public init(
        connectorID: Swift.String? = nil
    )
    {
        self.connectorID = connectorID
    }
}

extension MgnClientTypes {
    /// List Connectors Request Filters.
    public struct ListConnectorsRequestFilters {
        /// List Connectors Request Filters connector IDs.
        public var connectorIDs: [Swift.String]?

        public init(
            connectorIDs: [Swift.String]? = nil
        )
        {
            self.connectorIDs = connectorIDs
        }
    }

}

public struct ListConnectorsInput {
    /// List Connectors Request filters.
    public var filters: MgnClientTypes.ListConnectorsRequestFilters?
    /// List Connectors Request max results.
    public var maxResults: Swift.Int?
    /// List Connectors Request next token.
    public var nextToken: Swift.String?

    public init(
        filters: MgnClientTypes.ListConnectorsRequestFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension MgnClientTypes {
    public struct Connector {
        /// Connector arn.
        public var arn: Swift.String?
        /// Connector ID.
        public var connectorID: Swift.String?
        /// Connector name.
        public var name: Swift.String?
        /// Connector SSM command config.
        public var ssmCommandConfig: MgnClientTypes.ConnectorSsmCommandConfig?
        /// Connector SSM instance ID.
        public var ssmInstanceID: Swift.String?
        /// Connector tags.
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            connectorID: Swift.String? = nil,
            name: Swift.String? = nil,
            ssmCommandConfig: MgnClientTypes.ConnectorSsmCommandConfig? = nil,
            ssmInstanceID: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.connectorID = connectorID
            self.name = name
            self.ssmCommandConfig = ssmCommandConfig
            self.ssmInstanceID = ssmInstanceID
            self.tags = tags
        }
    }

}

extension MgnClientTypes.Connector: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Connector(arn: \(Swift.String(describing: arn)), connectorID: \(Swift.String(describing: connectorID)), name: \(Swift.String(describing: name)), ssmCommandConfig: \(Swift.String(describing: ssmCommandConfig)), ssmInstanceID: \(Swift.String(describing: ssmInstanceID)), tags: \"CONTENT_REDACTED\")"}
}

public struct ListConnectorsOutput {
    /// List connectors response items.
    public var items: [MgnClientTypes.Connector]?
    /// List connectors response next token.
    public var nextToken: Swift.String?

    public init(
        items: [MgnClientTypes.Connector]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct UpdateConnectorInput {
    /// Update Connector request connector ID.
    /// This member is required.
    public var connectorID: Swift.String?
    /// Update Connector request name.
    public var name: Swift.String?
    /// Update Connector request SSM command config.
    public var ssmCommandConfig: MgnClientTypes.ConnectorSsmCommandConfig?

    public init(
        connectorID: Swift.String? = nil,
        name: Swift.String? = nil,
        ssmCommandConfig: MgnClientTypes.ConnectorSsmCommandConfig? = nil
    )
    {
        self.connectorID = connectorID
        self.name = name
        self.ssmCommandConfig = ssmCommandConfig
    }
}

public struct UpdateConnectorOutput {
    /// Connector arn.
    public var arn: Swift.String?
    /// Connector ID.
    public var connectorID: Swift.String?
    /// Connector name.
    public var name: Swift.String?
    /// Connector SSM command config.
    public var ssmCommandConfig: MgnClientTypes.ConnectorSsmCommandConfig?
    /// Connector SSM instance ID.
    public var ssmInstanceID: Swift.String?
    /// Connector tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        connectorID: Swift.String? = nil,
        name: Swift.String? = nil,
        ssmCommandConfig: MgnClientTypes.ConnectorSsmCommandConfig? = nil,
        ssmInstanceID: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.connectorID = connectorID
        self.name = name
        self.ssmCommandConfig = ssmCommandConfig
        self.ssmInstanceID = ssmInstanceID
        self.tags = tags
    }
}

extension UpdateConnectorOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateConnectorOutput(arn: \(Swift.String(describing: arn)), connectorID: \(Swift.String(describing: connectorID)), name: \(Swift.String(describing: name)), ssmCommandConfig: \(Swift.String(describing: ssmCommandConfig)), ssmInstanceID: \(Swift.String(describing: ssmInstanceID)), tags: \"CONTENT_REDACTED\")"}
}

/// List export errors request.
public struct ListExportErrorsInput {
    /// List export errors request export id.
    /// This member is required.
    public var exportID: Swift.String?
    /// List export errors request max results.
    public var maxResults: Swift.Int?
    /// List export errors request next token.
    public var nextToken: Swift.String?

    public init(
        exportID: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.exportID = exportID
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension MgnClientTypes {
    /// Export errors data.
    public struct ExportErrorData {
        /// Export errors data raw error.
        public var rawError: Swift.String?

        public init(
            rawError: Swift.String? = nil
        )
        {
            self.rawError = rawError
        }
    }

}

extension MgnClientTypes {
    /// Export task error.
    public struct ExportTaskError {
        /// Export task error data.
        public var errorData: MgnClientTypes.ExportErrorData?
        /// Export task error datetime.
        public var errorDateTime: Swift.String?

        public init(
            errorData: MgnClientTypes.ExportErrorData? = nil,
            errorDateTime: Swift.String? = nil
        )
        {
            self.errorData = errorData
            self.errorDateTime = errorDateTime
        }
    }

}

/// List export errors response.
public struct ListExportErrorsOutput {
    /// List export errors response items.
    public var items: [MgnClientTypes.ExportTaskError]?
    /// List export errors response next token.
    public var nextToken: Swift.String?

    public init(
        items: [MgnClientTypes.ExportTaskError]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

extension MgnClientTypes {
    /// List exports request filters.
    public struct ListExportsRequestFilters {
        /// List exports request filters export ids.
        public var exportIDs: [Swift.String]?

        public init(
            exportIDs: [Swift.String]? = nil
        )
        {
            self.exportIDs = exportIDs
        }
    }

}

/// List export request.
public struct ListExportsInput {
    /// List exports request filters.
    public var filters: MgnClientTypes.ListExportsRequestFilters?
    /// List export request max results.
    public var maxResults: Swift.Int?
    /// List export request next token.
    public var nextToken: Swift.String?

    public init(
        filters: MgnClientTypes.ListExportsRequestFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension MgnClientTypes {

    public enum ExportStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case pending
        case started
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ExportStatus] {
            return [
                .failed,
                .pending,
                .started,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .started: return "STARTED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MgnClientTypes {
    /// Export task summary.
    public struct ExportTaskSummary {
        /// Export task summary applications count.
        public var applicationsCount: Swift.Int
        /// Export task summary servers count.
        public var serversCount: Swift.Int
        /// Export task summary waves count.
        public var wavesCount: Swift.Int

        public init(
            applicationsCount: Swift.Int = 0,
            serversCount: Swift.Int = 0,
            wavesCount: Swift.Int = 0
        )
        {
            self.applicationsCount = applicationsCount
            self.serversCount = serversCount
            self.wavesCount = wavesCount
        }
    }

}

extension MgnClientTypes {
    /// Export task.
    public struct ExportTask {
        /// Export task creation datetime.
        public var creationDateTime: Swift.String?
        /// Export task end datetime.
        public var endDateTime: Swift.String?
        /// Export task id.
        public var exportID: Swift.String?
        /// Export task progress percentage.
        public var progressPercentage: Swift.Float?
        /// Export task s3 bucket.
        public var s3Bucket: Swift.String?
        /// Export task s3 bucket owner.
        public var s3BucketOwner: Swift.String?
        /// Export task s3 key.
        public var s3Key: Swift.String?
        /// Export task status.
        public var status: MgnClientTypes.ExportStatus?
        /// Export task summary.
        public var summary: MgnClientTypes.ExportTaskSummary?

        public init(
            creationDateTime: Swift.String? = nil,
            endDateTime: Swift.String? = nil,
            exportID: Swift.String? = nil,
            progressPercentage: Swift.Float? = nil,
            s3Bucket: Swift.String? = nil,
            s3BucketOwner: Swift.String? = nil,
            s3Key: Swift.String? = nil,
            status: MgnClientTypes.ExportStatus? = nil,
            summary: MgnClientTypes.ExportTaskSummary? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.endDateTime = endDateTime
            self.exportID = exportID
            self.progressPercentage = progressPercentage
            self.s3Bucket = s3Bucket
            self.s3BucketOwner = s3BucketOwner
            self.s3Key = s3Key
            self.status = status
            self.summary = summary
        }
    }

}

/// List export response.
public struct ListExportsOutput {
    /// List export response items.
    public var items: [MgnClientTypes.ExportTask]?
    /// List export response next token.
    public var nextToken: Swift.String?

    public init(
        items: [MgnClientTypes.ExportTask]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

/// Start export request.
public struct StartExportInput {
    /// Start export request s3 bucket.
    /// This member is required.
    public var s3Bucket: Swift.String?
    /// Start export request s3 bucket owner.
    public var s3BucketOwner: Swift.String?
    /// Start export request s3key.
    /// This member is required.
    public var s3Key: Swift.String?

    public init(
        s3Bucket: Swift.String? = nil,
        s3BucketOwner: Swift.String? = nil,
        s3Key: Swift.String? = nil
    )
    {
        self.s3Bucket = s3Bucket
        self.s3BucketOwner = s3BucketOwner
        self.s3Key = s3Key
    }
}

/// Start export response.
public struct StartExportOutput {
    /// Start export response export task.
    public var exportTask: MgnClientTypes.ExportTask?

    public init(
        exportTask: MgnClientTypes.ExportTask? = nil
    )
    {
        self.exportTask = exportTask
    }
}

/// List import errors request.
public struct ListImportErrorsInput {
    /// List import errors request import id.
    /// This member is required.
    public var importID: Swift.String?
    /// List import errors request max results.
    public var maxResults: Swift.Int?
    /// List import errors request next token.
    public var nextToken: Swift.String?

    public init(
        importID: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.importID = importID
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension MgnClientTypes {
    /// Import error data.
    public struct ImportErrorData {
        /// Import error data source account ID.
        public var accountID: Swift.String?
        /// Import error data application ID.
        public var applicationID: Swift.String?
        /// Import error data ec2 LaunchTemplate ID.
        public var ec2LaunchTemplateID: Swift.String?
        /// Import error data raw error.
        public var rawError: Swift.String?
        /// Import error data row number.
        public var rowNumber: Swift.Int
        /// Import error data source server ID.
        public var sourceServerID: Swift.String?
        /// Import error data wave id.
        public var waveID: Swift.String?

        public init(
            accountID: Swift.String? = nil,
            applicationID: Swift.String? = nil,
            ec2LaunchTemplateID: Swift.String? = nil,
            rawError: Swift.String? = nil,
            rowNumber: Swift.Int = 0,
            sourceServerID: Swift.String? = nil,
            waveID: Swift.String? = nil
        )
        {
            self.accountID = accountID
            self.applicationID = applicationID
            self.ec2LaunchTemplateID = ec2LaunchTemplateID
            self.rawError = rawError
            self.rowNumber = rowNumber
            self.sourceServerID = sourceServerID
            self.waveID = waveID
        }
    }

}

extension MgnClientTypes {

    public enum ImportErrorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case processingError
        case validationError
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportErrorType] {
            return [
                .processingError,
                .validationError
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .processingError: return "PROCESSING_ERROR"
            case .validationError: return "VALIDATION_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MgnClientTypes {
    /// Import task error.
    public struct ImportTaskError {
        /// Import task error data.
        public var errorData: MgnClientTypes.ImportErrorData?
        /// Import task error datetime.
        public var errorDateTime: Swift.String?
        /// Import task error type.
        public var errorType: MgnClientTypes.ImportErrorType?

        public init(
            errorData: MgnClientTypes.ImportErrorData? = nil,
            errorDateTime: Swift.String? = nil,
            errorType: MgnClientTypes.ImportErrorType? = nil
        )
        {
            self.errorData = errorData
            self.errorDateTime = errorDateTime
            self.errorType = errorType
        }
    }

}

/// List imports errors response.
public struct ListImportErrorsOutput {
    /// List imports errors response items.
    public var items: [MgnClientTypes.ImportTaskError]?
    /// List imports errors response next token.
    public var nextToken: Swift.String?

    public init(
        items: [MgnClientTypes.ImportTaskError]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

extension MgnClientTypes {
    /// List imports request filters.
    public struct ListImportsRequestFilters {
        /// List imports request filters import IDs.
        public var importIDs: [Swift.String]?

        public init(
            importIDs: [Swift.String]? = nil
        )
        {
            self.importIDs = importIDs
        }
    }

}

/// List imports request.
public struct ListImportsInput {
    /// List imports request filters.
    public var filters: MgnClientTypes.ListImportsRequestFilters?
    /// List imports request max results.
    public var maxResults: Swift.Int?
    /// List imports request next token.
    public var nextToken: Swift.String?

    public init(
        filters: MgnClientTypes.ListImportsRequestFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension MgnClientTypes {
    /// S3 bucket source.
    public struct S3BucketSource {
        /// S3 bucket source s3 bucket.
        /// This member is required.
        public var s3Bucket: Swift.String?
        /// S3 bucket source s3 bucket owner.
        public var s3BucketOwner: Swift.String?
        /// S3 bucket source s3 key.
        /// This member is required.
        public var s3Key: Swift.String?

        public init(
            s3Bucket: Swift.String? = nil,
            s3BucketOwner: Swift.String? = nil,
            s3Key: Swift.String? = nil
        )
        {
            self.s3Bucket = s3Bucket
            self.s3BucketOwner = s3BucketOwner
            self.s3Key = s3Key
        }
    }

}

extension MgnClientTypes {

    public enum ImportStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case pending
        case started
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportStatus] {
            return [
                .failed,
                .pending,
                .started,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .started: return "STARTED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MgnClientTypes {
    /// Import task summary applications.
    public struct ImportTaskSummaryApplications {
        /// Import task summary applications created count.
        public var createdCount: Swift.Int
        /// Import task summary applications modified count.
        public var modifiedCount: Swift.Int

        public init(
            createdCount: Swift.Int = 0,
            modifiedCount: Swift.Int = 0
        )
        {
            self.createdCount = createdCount
            self.modifiedCount = modifiedCount
        }
    }

}

extension MgnClientTypes {
    /// Import task summary servers.
    public struct ImportTaskSummaryServers {
        /// Import task summary servers created count.
        public var createdCount: Swift.Int
        /// Import task summary servers modified count.
        public var modifiedCount: Swift.Int

        public init(
            createdCount: Swift.Int = 0,
            modifiedCount: Swift.Int = 0
        )
        {
            self.createdCount = createdCount
            self.modifiedCount = modifiedCount
        }
    }

}

extension MgnClientTypes {
    /// Import task summery waves.
    public struct ImportTaskSummaryWaves {
        /// Import task summery waves created count.
        public var createdCount: Swift.Int
        /// Import task summery waves modified count.
        public var modifiedCount: Swift.Int

        public init(
            createdCount: Swift.Int = 0,
            modifiedCount: Swift.Int = 0
        )
        {
            self.createdCount = createdCount
            self.modifiedCount = modifiedCount
        }
    }

}

extension MgnClientTypes {
    /// Import task summary.
    public struct ImportTaskSummary {
        /// Import task summary applications.
        public var applications: MgnClientTypes.ImportTaskSummaryApplications?
        /// Import task summary servers.
        public var servers: MgnClientTypes.ImportTaskSummaryServers?
        /// Import task summary waves.
        public var waves: MgnClientTypes.ImportTaskSummaryWaves?

        public init(
            applications: MgnClientTypes.ImportTaskSummaryApplications? = nil,
            servers: MgnClientTypes.ImportTaskSummaryServers? = nil,
            waves: MgnClientTypes.ImportTaskSummaryWaves? = nil
        )
        {
            self.applications = applications
            self.servers = servers
            self.waves = waves
        }
    }

}

extension MgnClientTypes {
    /// Import task.
    public struct ImportTask {
        /// Import task creation datetime.
        public var creationDateTime: Swift.String?
        /// Import task end datetime.
        public var endDateTime: Swift.String?
        /// Import task id.
        public var importID: Swift.String?
        /// Import task progress percentage.
        public var progressPercentage: Swift.Float?
        /// Import task s3 bucket source.
        public var s3BucketSource: MgnClientTypes.S3BucketSource?
        /// Import task status.
        public var status: MgnClientTypes.ImportStatus?
        /// Import task summary.
        public var summary: MgnClientTypes.ImportTaskSummary?

        public init(
            creationDateTime: Swift.String? = nil,
            endDateTime: Swift.String? = nil,
            importID: Swift.String? = nil,
            progressPercentage: Swift.Float? = nil,
            s3BucketSource: MgnClientTypes.S3BucketSource? = nil,
            status: MgnClientTypes.ImportStatus? = nil,
            summary: MgnClientTypes.ImportTaskSummary? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.endDateTime = endDateTime
            self.importID = importID
            self.progressPercentage = progressPercentage
            self.s3BucketSource = s3BucketSource
            self.status = status
            self.summary = summary
        }
    }

}

/// List import response.
public struct ListImportsOutput {
    /// List import response items.
    public var items: [MgnClientTypes.ImportTask]?
    /// List import response next token.
    public var nextToken: Swift.String?

    public init(
        items: [MgnClientTypes.ImportTask]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

/// Start import request.
public struct StartImportInput {
    /// Start import request client token.
    public var clientToken: Swift.String?
    /// Start import request s3 bucket source.
    /// This member is required.
    public var s3BucketSource: MgnClientTypes.S3BucketSource?

    public init(
        clientToken: Swift.String? = nil,
        s3BucketSource: MgnClientTypes.S3BucketSource? = nil
    )
    {
        self.clientToken = clientToken
        self.s3BucketSource = s3BucketSource
    }
}

/// Start import response.
public struct StartImportOutput {
    /// Start import response import task.
    public var importTask: MgnClientTypes.ImportTask?

    public init(
        importTask: MgnClientTypes.ImportTask? = nil
    )
    {
        self.importTask = importTask
    }
}

public struct InitializeServiceInput {

    public init() { }
}

public struct InitializeServiceOutput {

    public init() { }
}

public struct DeleteJobInput {
    /// Request to delete Job from service by Account ID.
    public var accountID: Swift.String?
    /// Request to delete Job from service by Job ID.
    /// This member is required.
    public var jobID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        jobID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.jobID = jobID
    }
}

public struct DeleteJobOutput {

    public init() { }
}

public struct DescribeJobLogItemsInput {
    /// Request to describe Job log Account ID.
    public var accountID: Swift.String?
    /// Request to describe Job log job ID.
    /// This member is required.
    public var jobID: Swift.String?
    /// Request to describe Job log item maximum results.
    public var maxResults: Swift.Int?
    /// Request to describe Job log next token.
    public var nextToken: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        jobID: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.jobID = jobID
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension MgnClientTypes {

    public enum JobLogEvent: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cleanupEnd
        case cleanupFail
        case cleanupStart
        case conversionEnd
        case conversionFail
        case conversionStart
        case jobCancel
        case jobEnd
        case jobStart
        case launchFailed
        case launchStart
        case serverSkipped
        case snapshotEnd
        case snapshotFail
        case snapshotStart
        case usingPreviousSnapshot
        case sdkUnknown(Swift.String)

        public static var allCases: [JobLogEvent] {
            return [
                .cleanupEnd,
                .cleanupFail,
                .cleanupStart,
                .conversionEnd,
                .conversionFail,
                .conversionStart,
                .jobCancel,
                .jobEnd,
                .jobStart,
                .launchFailed,
                .launchStart,
                .serverSkipped,
                .snapshotEnd,
                .snapshotFail,
                .snapshotStart,
                .usingPreviousSnapshot
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cleanupEnd: return "CLEANUP_END"
            case .cleanupFail: return "CLEANUP_FAIL"
            case .cleanupStart: return "CLEANUP_START"
            case .conversionEnd: return "CONVERSION_END"
            case .conversionFail: return "CONVERSION_FAIL"
            case .conversionStart: return "CONVERSION_START"
            case .jobCancel: return "JOB_CANCEL"
            case .jobEnd: return "JOB_END"
            case .jobStart: return "JOB_START"
            case .launchFailed: return "LAUNCH_FAILED"
            case .launchStart: return "LAUNCH_START"
            case .serverSkipped: return "SERVER_SKIPPED"
            case .snapshotEnd: return "SNAPSHOT_END"
            case .snapshotFail: return "SNAPSHOT_FAIL"
            case .snapshotStart: return "SNAPSHOT_START"
            case .usingPreviousSnapshot: return "USING_PREVIOUS_SNAPSHOT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MgnClientTypes {
    /// Job log data
    public struct JobLogEventData {
        /// Job Event conversion Server ID.
        public var conversionServerID: Swift.String?
        /// Job error.
        public var rawError: Swift.String?
        /// Job Event Source Server ID.
        public var sourceServerID: Swift.String?
        /// Job Event Target instance ID.
        public var targetInstanceID: Swift.String?

        public init(
            conversionServerID: Swift.String? = nil,
            rawError: Swift.String? = nil,
            sourceServerID: Swift.String? = nil,
            targetInstanceID: Swift.String? = nil
        )
        {
            self.conversionServerID = conversionServerID
            self.rawError = rawError
            self.sourceServerID = sourceServerID
            self.targetInstanceID = targetInstanceID
        }
    }

}

extension MgnClientTypes {
    /// Job log.
    public struct JobLog {
        /// Job log event.
        public var event: MgnClientTypes.JobLogEvent?
        /// Job event data
        public var eventData: MgnClientTypes.JobLogEventData?
        /// Job log event date and time.
        public var logDateTime: Swift.String?

        public init(
            event: MgnClientTypes.JobLogEvent? = nil,
            eventData: MgnClientTypes.JobLogEventData? = nil,
            logDateTime: Swift.String? = nil
        )
        {
            self.event = event
            self.eventData = eventData
            self.logDateTime = logDateTime
        }
    }

}

public struct DescribeJobLogItemsOutput {
    /// Request to describe Job log response items.
    public var items: [MgnClientTypes.JobLog]?
    /// Request to describe Job log response next token.
    public var nextToken: Swift.String?

    public init(
        items: [MgnClientTypes.JobLog]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

extension MgnClientTypes {
    /// Request to describe Job log filters.
    public struct DescribeJobsRequestFilters {
        /// Request to describe Job log filters by date.
        public var fromDate: Swift.String?
        /// Request to describe Job log filters by job ID.
        public var jobIDs: [Swift.String]?
        /// Request to describe job log items by last date.
        public var toDate: Swift.String?

        public init(
            fromDate: Swift.String? = nil,
            jobIDs: [Swift.String]? = nil,
            toDate: Swift.String? = nil
        )
        {
            self.fromDate = fromDate
            self.jobIDs = jobIDs
            self.toDate = toDate
        }
    }

}

public struct DescribeJobsInput {
    /// Request to describe job log items by Account ID.
    public var accountID: Swift.String?
    /// Request to describe Job log filters.
    public var filters: MgnClientTypes.DescribeJobsRequestFilters?
    /// Request to describe job log items by max results.
    public var maxResults: Swift.Int?
    /// Request to describe job log items by next token.
    public var nextToken: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        filters: MgnClientTypes.DescribeJobsRequestFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension MgnClientTypes {

    public enum InitiatedBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case diagnostic
        case startCutover
        case startTest
        case terminate
        case sdkUnknown(Swift.String)

        public static var allCases: [InitiatedBy] {
            return [
                .diagnostic,
                .startCutover,
                .startTest,
                .terminate
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .diagnostic: return "DIAGNOSTIC"
            case .startCutover: return "START_CUTOVER"
            case .startTest: return "START_TEST"
            case .terminate: return "TERMINATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MgnClientTypes {

    public enum LaunchStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inProgress
        case launched
        case pending
        case terminated
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchStatus] {
            return [
                .failed,
                .inProgress,
                .launched,
                .pending,
                .terminated
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .launched: return "LAUNCHED"
            case .pending: return "PENDING"
            case .terminated: return "TERMINATED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MgnClientTypes {

    public enum PostLaunchActionExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inProgress
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [PostLaunchActionExecutionStatus] {
            return [
                .failed,
                .inProgress,
                .success
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MgnClientTypes {
    /// AWS Systems Manager Document external parameter.
    public enum SsmExternalParameter {
        /// AWS Systems Manager Document external parameters dynamic path.
        case dynamicpath(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension MgnClientTypes {

    public enum SsmParameterStoreParameterType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [SsmParameterStoreParameterType] {
            return [
                .string
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MgnClientTypes {
    /// AWS Systems Manager Parameter Store parameter.
    public struct SsmParameterStoreParameter {
        /// AWS Systems Manager Parameter Store parameter name.
        /// This member is required.
        public var parameterName: Swift.String?
        /// AWS Systems Manager Parameter Store parameter type.
        /// This member is required.
        public var parameterType: MgnClientTypes.SsmParameterStoreParameterType?

        public init(
            parameterName: Swift.String? = nil,
            parameterType: MgnClientTypes.SsmParameterStoreParameterType? = nil
        )
        {
            self.parameterName = parameterName
            self.parameterType = parameterType
        }
    }

}

extension MgnClientTypes {
    /// AWS Systems Manager Document.
    public struct SsmDocument {
        /// User-friendly name for the AWS Systems Manager Document.
        /// This member is required.
        public var actionName: Swift.String?
        /// AWS Systems Manager Document external parameters.
        public var externalParameters: [Swift.String: MgnClientTypes.SsmExternalParameter]?
        /// If true, Cutover will not be enabled if the document has failed.
        public var mustSucceedForCutover: Swift.Bool?
        /// AWS Systems Manager Document parameters.
        public var parameters: [Swift.String: [MgnClientTypes.SsmParameterStoreParameter]]?
        /// AWS Systems Manager Document name or full ARN.
        /// This member is required.
        public var ssmDocumentName: Swift.String?
        /// AWS Systems Manager Document timeout seconds.
        public var timeoutSeconds: Swift.Int?

        public init(
            actionName: Swift.String? = nil,
            externalParameters: [Swift.String: MgnClientTypes.SsmExternalParameter]? = nil,
            mustSucceedForCutover: Swift.Bool? = nil,
            parameters: [Swift.String: [MgnClientTypes.SsmParameterStoreParameter]]? = nil,
            ssmDocumentName: Swift.String? = nil,
            timeoutSeconds: Swift.Int? = nil
        )
        {
            self.actionName = actionName
            self.externalParameters = externalParameters
            self.mustSucceedForCutover = mustSucceedForCutover
            self.parameters = parameters
            self.ssmDocumentName = ssmDocumentName
            self.timeoutSeconds = timeoutSeconds
        }
    }

}

extension MgnClientTypes {

    public enum SsmDocumentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case automation
        case command
        case sdkUnknown(Swift.String)

        public static var allCases: [SsmDocumentType] {
            return [
                .automation,
                .command
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .automation: return "AUTOMATION"
            case .command: return "COMMAND"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MgnClientTypes {
    /// Launch Status of the Job Post Launch Actions.
    public struct JobPostLaunchActionsLaunchStatus {
        /// AWS Systems Manager Document's execution ID of the of the Job Post Launch Actions.
        public var executionID: Swift.String?
        /// AWS Systems Manager Document's execution status.
        public var executionStatus: MgnClientTypes.PostLaunchActionExecutionStatus?
        /// AWS Systems Manager Document's failure reason.
        public var failureReason: Swift.String?
        /// AWS Systems Manager's Document of the of the Job Post Launch Actions.
        public var ssmDocument: MgnClientTypes.SsmDocument?
        /// AWS Systems Manager Document type.
        public var ssmDocumentType: MgnClientTypes.SsmDocumentType?

        public init(
            executionID: Swift.String? = nil,
            executionStatus: MgnClientTypes.PostLaunchActionExecutionStatus? = nil,
            failureReason: Swift.String? = nil,
            ssmDocument: MgnClientTypes.SsmDocument? = nil,
            ssmDocumentType: MgnClientTypes.SsmDocumentType? = nil
        )
        {
            self.executionID = executionID
            self.executionStatus = executionStatus
            self.failureReason = failureReason
            self.ssmDocument = ssmDocument
            self.ssmDocumentType = ssmDocumentType
        }
    }

}

extension MgnClientTypes {
    /// Status of the Post Launch Actions running on the Test or Cutover instance.
    public struct PostLaunchActionsStatus {
        /// List of Post Launch Action status.
        public var postLaunchActionsLaunchStatusList: [MgnClientTypes.JobPostLaunchActionsLaunchStatus]?
        /// Time where the AWS Systems Manager was detected as running on the Test or Cutover instance.
        public var ssmAgentDiscoveryDatetime: Swift.String?

        public init(
            postLaunchActionsLaunchStatusList: [MgnClientTypes.JobPostLaunchActionsLaunchStatus]? = nil,
            ssmAgentDiscoveryDatetime: Swift.String? = nil
        )
        {
            self.postLaunchActionsLaunchStatusList = postLaunchActionsLaunchStatusList
            self.ssmAgentDiscoveryDatetime = ssmAgentDiscoveryDatetime
        }
    }

}

extension MgnClientTypes {
    /// Server participating in Job.
    public struct ParticipatingServer {
        /// Participating server launch status.
        public var launchStatus: MgnClientTypes.LaunchStatus?
        /// Participating server's launched ec2 instance ID.
        public var launchedEc2InstanceID: Swift.String?
        /// Participating server's Post Launch Actions Status.
        public var postLaunchActionsStatus: MgnClientTypes.PostLaunchActionsStatus?
        /// Participating server Source Server ID.
        /// This member is required.
        public var sourceServerID: Swift.String?

        public init(
            launchStatus: MgnClientTypes.LaunchStatus? = nil,
            launchedEc2InstanceID: Swift.String? = nil,
            postLaunchActionsStatus: MgnClientTypes.PostLaunchActionsStatus? = nil,
            sourceServerID: Swift.String? = nil
        )
        {
            self.launchStatus = launchStatus
            self.launchedEc2InstanceID = launchedEc2InstanceID
            self.postLaunchActionsStatus = postLaunchActionsStatus
            self.sourceServerID = sourceServerID
        }
    }

}

extension MgnClientTypes {

    public enum JobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case pending
        case started
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .completed,
                .pending,
                .started
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .pending: return "PENDING"
            case .started: return "STARTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MgnClientTypes {

    public enum JobType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case launch
        case terminate
        case sdkUnknown(Swift.String)

        public static var allCases: [JobType] {
            return [
                .launch,
                .terminate
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .launch: return "LAUNCH"
            case .terminate: return "TERMINATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MgnClientTypes {
    /// Job.
    public struct Job {
        /// the ARN of the specific Job.
        public var arn: Swift.String?
        /// Job creation time.
        public var creationDateTime: Swift.String?
        /// Job end time.
        public var endDateTime: Swift.String?
        /// Job initiated by field.
        public var initiatedBy: MgnClientTypes.InitiatedBy?
        /// Job ID.
        /// This member is required.
        public var jobID: Swift.String?
        /// Servers participating in a specific Job.
        public var participatingServers: [MgnClientTypes.ParticipatingServer]?
        /// Job status.
        public var status: MgnClientTypes.JobStatus?
        /// Tags associated with specific Job.
        public var tags: [Swift.String: Swift.String]?
        /// Job type.
        public var type: MgnClientTypes.JobType?

        public init(
            arn: Swift.String? = nil,
            creationDateTime: Swift.String? = nil,
            endDateTime: Swift.String? = nil,
            initiatedBy: MgnClientTypes.InitiatedBy? = nil,
            jobID: Swift.String? = nil,
            participatingServers: [MgnClientTypes.ParticipatingServer]? = nil,
            status: MgnClientTypes.JobStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            type: MgnClientTypes.JobType? = nil
        )
        {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.endDateTime = endDateTime
            self.initiatedBy = initiatedBy
            self.jobID = jobID
            self.participatingServers = participatingServers
            self.status = status
            self.tags = tags
            self.type = type
        }
    }

}

extension MgnClientTypes.Job: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Job(arn: \(Swift.String(describing: arn)), creationDateTime: \(Swift.String(describing: creationDateTime)), endDateTime: \(Swift.String(describing: endDateTime)), initiatedBy: \(Swift.String(describing: initiatedBy)), jobID: \(Swift.String(describing: jobID)), participatingServers: \(Swift.String(describing: participatingServers)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), tags: \"CONTENT_REDACTED\")"}
}

public struct DescribeJobsOutput {
    /// Request to describe Job log items.
    public var items: [MgnClientTypes.Job]?
    /// Request to describe Job response by next token.
    public var nextToken: Swift.String?

    public init(
        items: [MgnClientTypes.Job]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

extension MgnClientTypes {

    public enum BootMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case legacyBios
        case uefi
        case useSource
        case sdkUnknown(Swift.String)

        public static var allCases: [BootMode] {
            return [
                .legacyBios,
                .uefi,
                .useSource
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .legacyBios: return "LEGACY_BIOS"
            case .uefi: return "UEFI"
            case .useSource: return "USE_SOURCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MgnClientTypes {

    public enum VolumeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case gp2
        case gp3
        case io1
        case io2
        case sc1
        case st1
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [VolumeType] {
            return [
                .gp2,
                .gp3,
                .io1,
                .io2,
                .sc1,
                .st1,
                .standard
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .gp2: return "gp2"
            case .gp3: return "gp3"
            case .io1: return "io1"
            case .io2: return "io2"
            case .sc1: return "sc1"
            case .st1: return "st1"
            case .standard: return "standard"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MgnClientTypes {
    /// Launch template disk configuration.
    public struct LaunchTemplateDiskConf {
        /// Launch template disk iops configuration.
        public var iops: Swift.Int?
        /// Launch template disk throughput configuration.
        public var throughput: Swift.Int?
        /// Launch template disk volume type configuration.
        public var volumeType: MgnClientTypes.VolumeType?

        public init(
            iops: Swift.Int? = nil,
            throughput: Swift.Int? = nil,
            volumeType: MgnClientTypes.VolumeType? = nil
        )
        {
            self.iops = iops
            self.throughput = throughput
            self.volumeType = volumeType
        }
    }

}

extension MgnClientTypes {

    public enum LaunchDisposition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case started
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchDisposition] {
            return [
                .started,
                .stopped
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .started: return "STARTED"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MgnClientTypes {
    /// Configure Licensing.
    public struct Licensing {
        /// Configure BYOL OS licensing.
        public var osByol: Swift.Bool?

        public init(
            osByol: Swift.Bool? = nil
        )
        {
            self.osByol = osByol
        }
    }

}

extension MgnClientTypes {

    public enum PostLaunchActionsDeploymentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cutoverOnly
        case testAndCutover
        case testOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [PostLaunchActionsDeploymentType] {
            return [
                .cutoverOnly,
                .testAndCutover,
                .testOnly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cutoverOnly: return "CUTOVER_ONLY"
            case .testAndCutover: return "TEST_AND_CUTOVER"
            case .testOnly: return "TEST_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MgnClientTypes {
    /// Post Launch Actions to executed on the Test or Cutover instance.
    public struct PostLaunchActions {
        /// AWS Systems Manager Command's CloudWatch log group name.
        public var cloudWatchLogGroupName: Swift.String?
        /// Deployment type in which AWS Systems Manager Documents will be executed.
        public var deployment: MgnClientTypes.PostLaunchActionsDeploymentType?
        /// AWS Systems Manager Command's logs S3 log bucket.
        public var s3LogBucket: Swift.String?
        /// AWS Systems Manager Command's logs S3 output key prefix.
        public var s3OutputKeyPrefix: Swift.String?
        /// AWS Systems Manager Documents.
        public var ssmDocuments: [MgnClientTypes.SsmDocument]?

        public init(
            cloudWatchLogGroupName: Swift.String? = nil,
            deployment: MgnClientTypes.PostLaunchActionsDeploymentType? = nil,
            s3LogBucket: Swift.String? = nil,
            s3OutputKeyPrefix: Swift.String? = nil,
            ssmDocuments: [MgnClientTypes.SsmDocument]? = nil
        )
        {
            self.cloudWatchLogGroupName = cloudWatchLogGroupName
            self.deployment = deployment
            self.s3LogBucket = s3LogBucket
            self.s3OutputKeyPrefix = s3OutputKeyPrefix
            self.ssmDocuments = ssmDocuments
        }
    }

}

extension MgnClientTypes {

    public enum TargetInstanceTypeRightSizingMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case basic
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetInstanceTypeRightSizingMethod] {
            return [
                .basic,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .basic: return "BASIC"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateLaunchConfigurationTemplateInput {
    /// Associate public Ip address.
    public var associatePublicIpAddress: Swift.Bool?
    /// Launch configuration template boot mode.
    public var bootMode: MgnClientTypes.BootMode?
    /// Copy private Ip.
    public var copyPrivateIp: Swift.Bool?
    /// Copy tags.
    public var copyTags: Swift.Bool?
    /// Enable map auto tagging.
    public var enableMapAutoTagging: Swift.Bool?
    /// Large volume config.
    public var largeVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
    /// Launch disposition.
    public var launchDisposition: MgnClientTypes.LaunchDisposition?
    /// Configure Licensing.
    public var licensing: MgnClientTypes.Licensing?
    /// Launch configuration template map auto tagging MPE ID.
    public var mapAutoTaggingMpeID: Swift.String?
    /// Launch configuration template post launch actions.
    public var postLaunchActions: MgnClientTypes.PostLaunchActions?
    /// Small volume config.
    public var smallVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
    /// Small volume maximum size.
    public var smallVolumeMaxSize: Swift.Int
    /// Request to associate tags during creation of a Launch Configuration Template.
    public var tags: [Swift.String: Swift.String]?
    /// Target instance type right-sizing method.
    public var targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?

    public init(
        associatePublicIpAddress: Swift.Bool? = nil,
        bootMode: MgnClientTypes.BootMode? = nil,
        copyPrivateIp: Swift.Bool? = nil,
        copyTags: Swift.Bool? = nil,
        enableMapAutoTagging: Swift.Bool? = nil,
        largeVolumeConf: MgnClientTypes.LaunchTemplateDiskConf? = nil,
        launchDisposition: MgnClientTypes.LaunchDisposition? = nil,
        licensing: MgnClientTypes.Licensing? = nil,
        mapAutoTaggingMpeID: Swift.String? = nil,
        postLaunchActions: MgnClientTypes.PostLaunchActions? = nil,
        smallVolumeConf: MgnClientTypes.LaunchTemplateDiskConf? = nil,
        smallVolumeMaxSize: Swift.Int = 0,
        tags: [Swift.String: Swift.String]? = nil,
        targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod? = nil
    )
    {
        self.associatePublicIpAddress = associatePublicIpAddress
        self.bootMode = bootMode
        self.copyPrivateIp = copyPrivateIp
        self.copyTags = copyTags
        self.enableMapAutoTagging = enableMapAutoTagging
        self.largeVolumeConf = largeVolumeConf
        self.launchDisposition = launchDisposition
        self.licensing = licensing
        self.mapAutoTaggingMpeID = mapAutoTaggingMpeID
        self.postLaunchActions = postLaunchActions
        self.smallVolumeConf = smallVolumeConf
        self.smallVolumeMaxSize = smallVolumeMaxSize
        self.tags = tags
        self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
    }
}

extension CreateLaunchConfigurationTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLaunchConfigurationTemplateInput(associatePublicIpAddress: \(Swift.String(describing: associatePublicIpAddress)), bootMode: \(Swift.String(describing: bootMode)), copyPrivateIp: \(Swift.String(describing: copyPrivateIp)), copyTags: \(Swift.String(describing: copyTags)), enableMapAutoTagging: \(Swift.String(describing: enableMapAutoTagging)), largeVolumeConf: \(Swift.String(describing: largeVolumeConf)), launchDisposition: \(Swift.String(describing: launchDisposition)), licensing: \(Swift.String(describing: licensing)), mapAutoTaggingMpeID: \(Swift.String(describing: mapAutoTaggingMpeID)), postLaunchActions: \(Swift.String(describing: postLaunchActions)), smallVolumeConf: \(Swift.String(describing: smallVolumeConf)), smallVolumeMaxSize: \(Swift.String(describing: smallVolumeMaxSize)), targetInstanceTypeRightSizingMethod: \(Swift.String(describing: targetInstanceTypeRightSizingMethod)), tags: \"CONTENT_REDACTED\")"}
}

public struct CreateLaunchConfigurationTemplateOutput {
    /// ARN of the Launch Configuration Template.
    public var arn: Swift.String?
    /// Associate public Ip address.
    public var associatePublicIpAddress: Swift.Bool?
    /// Launch configuration template boot mode.
    public var bootMode: MgnClientTypes.BootMode?
    /// Copy private Ip.
    public var copyPrivateIp: Swift.Bool?
    /// Copy tags.
    public var copyTags: Swift.Bool?
    /// EC2 launch template ID.
    public var ec2LaunchTemplateID: Swift.String?
    /// Enable map auto tagging.
    public var enableMapAutoTagging: Swift.Bool?
    /// Large volume config.
    public var largeVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
    /// ID of the Launch Configuration Template.
    /// This member is required.
    public var launchConfigurationTemplateID: Swift.String?
    /// Launch disposition.
    public var launchDisposition: MgnClientTypes.LaunchDisposition?
    /// Configure Licensing.
    public var licensing: MgnClientTypes.Licensing?
    /// Launch configuration template map auto tagging MPE ID.
    public var mapAutoTaggingMpeID: Swift.String?
    /// Post Launch Actions of the Launch Configuration Template.
    public var postLaunchActions: MgnClientTypes.PostLaunchActions?
    /// Small volume config.
    public var smallVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
    /// Small volume maximum size.
    public var smallVolumeMaxSize: Swift.Int
    /// Tags of the Launch Configuration Template.
    public var tags: [Swift.String: Swift.String]?
    /// Target instance type right-sizing method.
    public var targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?

    public init(
        arn: Swift.String? = nil,
        associatePublicIpAddress: Swift.Bool? = nil,
        bootMode: MgnClientTypes.BootMode? = nil,
        copyPrivateIp: Swift.Bool? = nil,
        copyTags: Swift.Bool? = nil,
        ec2LaunchTemplateID: Swift.String? = nil,
        enableMapAutoTagging: Swift.Bool? = nil,
        largeVolumeConf: MgnClientTypes.LaunchTemplateDiskConf? = nil,
        launchConfigurationTemplateID: Swift.String? = nil,
        launchDisposition: MgnClientTypes.LaunchDisposition? = nil,
        licensing: MgnClientTypes.Licensing? = nil,
        mapAutoTaggingMpeID: Swift.String? = nil,
        postLaunchActions: MgnClientTypes.PostLaunchActions? = nil,
        smallVolumeConf: MgnClientTypes.LaunchTemplateDiskConf? = nil,
        smallVolumeMaxSize: Swift.Int = 0,
        tags: [Swift.String: Swift.String]? = nil,
        targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod? = nil
    )
    {
        self.arn = arn
        self.associatePublicIpAddress = associatePublicIpAddress
        self.bootMode = bootMode
        self.copyPrivateIp = copyPrivateIp
        self.copyTags = copyTags
        self.ec2LaunchTemplateID = ec2LaunchTemplateID
        self.enableMapAutoTagging = enableMapAutoTagging
        self.largeVolumeConf = largeVolumeConf
        self.launchConfigurationTemplateID = launchConfigurationTemplateID
        self.launchDisposition = launchDisposition
        self.licensing = licensing
        self.mapAutoTaggingMpeID = mapAutoTaggingMpeID
        self.postLaunchActions = postLaunchActions
        self.smallVolumeConf = smallVolumeConf
        self.smallVolumeMaxSize = smallVolumeMaxSize
        self.tags = tags
        self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
    }
}

extension CreateLaunchConfigurationTemplateOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLaunchConfigurationTemplateOutput(arn: \(Swift.String(describing: arn)), associatePublicIpAddress: \(Swift.String(describing: associatePublicIpAddress)), bootMode: \(Swift.String(describing: bootMode)), copyPrivateIp: \(Swift.String(describing: copyPrivateIp)), copyTags: \(Swift.String(describing: copyTags)), ec2LaunchTemplateID: \(Swift.String(describing: ec2LaunchTemplateID)), enableMapAutoTagging: \(Swift.String(describing: enableMapAutoTagging)), largeVolumeConf: \(Swift.String(describing: largeVolumeConf)), launchConfigurationTemplateID: \(Swift.String(describing: launchConfigurationTemplateID)), launchDisposition: \(Swift.String(describing: launchDisposition)), licensing: \(Swift.String(describing: licensing)), mapAutoTaggingMpeID: \(Swift.String(describing: mapAutoTaggingMpeID)), postLaunchActions: \(Swift.String(describing: postLaunchActions)), smallVolumeConf: \(Swift.String(describing: smallVolumeConf)), smallVolumeMaxSize: \(Swift.String(describing: smallVolumeMaxSize)), targetInstanceTypeRightSizingMethod: \(Swift.String(describing: targetInstanceTypeRightSizingMethod)), tags: \"CONTENT_REDACTED\")"}
}

public struct DeleteLaunchConfigurationTemplateInput {
    /// ID of resource to be deleted.
    /// This member is required.
    public var launchConfigurationTemplateID: Swift.String?

    public init(
        launchConfigurationTemplateID: Swift.String? = nil
    )
    {
        self.launchConfigurationTemplateID = launchConfigurationTemplateID
    }
}

public struct DeleteLaunchConfigurationTemplateOutput {

    public init() { }
}

public struct DescribeLaunchConfigurationTemplatesInput {
    /// Request to filter Launch Configuration Templates list by Launch Configuration Template ID.
    public var launchConfigurationTemplateIDs: [Swift.String]?
    /// Maximum results to be returned in DescribeLaunchConfigurationTemplates.
    public var maxResults: Swift.Int?
    /// Next pagination token returned from DescribeLaunchConfigurationTemplates.
    public var nextToken: Swift.String?

    public init(
        launchConfigurationTemplateIDs: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.launchConfigurationTemplateIDs = launchConfigurationTemplateIDs
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension MgnClientTypes {
    public struct LaunchConfigurationTemplate {
        /// ARN of the Launch Configuration Template.
        public var arn: Swift.String?
        /// Associate public Ip address.
        public var associatePublicIpAddress: Swift.Bool?
        /// Launch configuration template boot mode.
        public var bootMode: MgnClientTypes.BootMode?
        /// Copy private Ip.
        public var copyPrivateIp: Swift.Bool?
        /// Copy tags.
        public var copyTags: Swift.Bool?
        /// EC2 launch template ID.
        public var ec2LaunchTemplateID: Swift.String?
        /// Enable map auto tagging.
        public var enableMapAutoTagging: Swift.Bool?
        /// Large volume config.
        public var largeVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
        /// ID of the Launch Configuration Template.
        /// This member is required.
        public var launchConfigurationTemplateID: Swift.String?
        /// Launch disposition.
        public var launchDisposition: MgnClientTypes.LaunchDisposition?
        /// Configure Licensing.
        public var licensing: MgnClientTypes.Licensing?
        /// Launch configuration template map auto tagging MPE ID.
        public var mapAutoTaggingMpeID: Swift.String?
        /// Post Launch Actions of the Launch Configuration Template.
        public var postLaunchActions: MgnClientTypes.PostLaunchActions?
        /// Small volume config.
        public var smallVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
        /// Small volume maximum size.
        public var smallVolumeMaxSize: Swift.Int
        /// Tags of the Launch Configuration Template.
        public var tags: [Swift.String: Swift.String]?
        /// Target instance type right-sizing method.
        public var targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?

        public init(
            arn: Swift.String? = nil,
            associatePublicIpAddress: Swift.Bool? = nil,
            bootMode: MgnClientTypes.BootMode? = nil,
            copyPrivateIp: Swift.Bool? = nil,
            copyTags: Swift.Bool? = nil,
            ec2LaunchTemplateID: Swift.String? = nil,
            enableMapAutoTagging: Swift.Bool? = nil,
            largeVolumeConf: MgnClientTypes.LaunchTemplateDiskConf? = nil,
            launchConfigurationTemplateID: Swift.String? = nil,
            launchDisposition: MgnClientTypes.LaunchDisposition? = nil,
            licensing: MgnClientTypes.Licensing? = nil,
            mapAutoTaggingMpeID: Swift.String? = nil,
            postLaunchActions: MgnClientTypes.PostLaunchActions? = nil,
            smallVolumeConf: MgnClientTypes.LaunchTemplateDiskConf? = nil,
            smallVolumeMaxSize: Swift.Int = 0,
            tags: [Swift.String: Swift.String]? = nil,
            targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod? = nil
        )
        {
            self.arn = arn
            self.associatePublicIpAddress = associatePublicIpAddress
            self.bootMode = bootMode
            self.copyPrivateIp = copyPrivateIp
            self.copyTags = copyTags
            self.ec2LaunchTemplateID = ec2LaunchTemplateID
            self.enableMapAutoTagging = enableMapAutoTagging
            self.largeVolumeConf = largeVolumeConf
            self.launchConfigurationTemplateID = launchConfigurationTemplateID
            self.launchDisposition = launchDisposition
            self.licensing = licensing
            self.mapAutoTaggingMpeID = mapAutoTaggingMpeID
            self.postLaunchActions = postLaunchActions
            self.smallVolumeConf = smallVolumeConf
            self.smallVolumeMaxSize = smallVolumeMaxSize
            self.tags = tags
            self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
        }
    }

}

extension MgnClientTypes.LaunchConfigurationTemplate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LaunchConfigurationTemplate(arn: \(Swift.String(describing: arn)), associatePublicIpAddress: \(Swift.String(describing: associatePublicIpAddress)), bootMode: \(Swift.String(describing: bootMode)), copyPrivateIp: \(Swift.String(describing: copyPrivateIp)), copyTags: \(Swift.String(describing: copyTags)), ec2LaunchTemplateID: \(Swift.String(describing: ec2LaunchTemplateID)), enableMapAutoTagging: \(Swift.String(describing: enableMapAutoTagging)), largeVolumeConf: \(Swift.String(describing: largeVolumeConf)), launchConfigurationTemplateID: \(Swift.String(describing: launchConfigurationTemplateID)), launchDisposition: \(Swift.String(describing: launchDisposition)), licensing: \(Swift.String(describing: licensing)), mapAutoTaggingMpeID: \(Swift.String(describing: mapAutoTaggingMpeID)), postLaunchActions: \(Swift.String(describing: postLaunchActions)), smallVolumeConf: \(Swift.String(describing: smallVolumeConf)), smallVolumeMaxSize: \(Swift.String(describing: smallVolumeMaxSize)), targetInstanceTypeRightSizingMethod: \(Swift.String(describing: targetInstanceTypeRightSizingMethod)), tags: \"CONTENT_REDACTED\")"}
}

public struct DescribeLaunchConfigurationTemplatesOutput {
    /// List of items returned by DescribeLaunchConfigurationTemplates.
    public var items: [MgnClientTypes.LaunchConfigurationTemplate]?
    /// Next pagination token returned from DescribeLaunchConfigurationTemplates.
    public var nextToken: Swift.String?

    public init(
        items: [MgnClientTypes.LaunchConfigurationTemplate]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

extension MgnClientTypes {
    /// Template post migration custom action filters.
    public struct TemplateActionsRequestFilters {
        /// Action IDs to filter template post migration custom actions by.
        public var actionIDs: [Swift.String]?

        public init(
            actionIDs: [Swift.String]? = nil
        )
        {
            self.actionIDs = actionIDs
        }
    }

}

public struct ListTemplateActionsInput {
    /// Filters to apply when listing template post migration custom actions.
    public var filters: MgnClientTypes.TemplateActionsRequestFilters?
    /// Launch configuration template ID.
    /// This member is required.
    public var launchConfigurationTemplateID: Swift.String?
    /// Maximum amount of items to return when listing template post migration custom actions.
    public var maxResults: Swift.Int?
    /// Next token to use when listing template post migration custom actions.
    public var nextToken: Swift.String?

    public init(
        filters: MgnClientTypes.TemplateActionsRequestFilters? = nil,
        launchConfigurationTemplateID: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.launchConfigurationTemplateID = launchConfigurationTemplateID
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension MgnClientTypes {
    public struct TemplateActionDocument {
        /// Template post migration custom action ID.
        public var actionID: Swift.String?
        /// Template post migration custom action name.
        public var actionName: Swift.String?
        /// Template post migration custom action active status.
        public var active: Swift.Bool?
        /// Template post migration custom action category.
        public var category: MgnClientTypes.ActionCategory?
        /// Template post migration custom action description.
        public var description: Swift.String?
        /// Template post migration custom action document identifier.
        public var documentIdentifier: Swift.String?
        /// Template post migration custom action document version.
        public var documentVersion: Swift.String?
        /// Template post migration custom action external parameters.
        public var externalParameters: [Swift.String: MgnClientTypes.SsmExternalParameter]?
        /// Template post migration custom action must succeed for cutover.
        public var mustSucceedForCutover: Swift.Bool?
        /// Operating system eligible for this template post migration custom action.
        public var operatingSystem: Swift.String?
        /// Template post migration custom action order.
        public var order: Swift.Int?
        /// Template post migration custom action parameters.
        public var parameters: [Swift.String: [MgnClientTypes.SsmParameterStoreParameter]]?
        /// Template post migration custom action timeout in seconds.
        public var timeoutSeconds: Swift.Int?

        public init(
            actionID: Swift.String? = nil,
            actionName: Swift.String? = nil,
            active: Swift.Bool? = nil,
            category: MgnClientTypes.ActionCategory? = nil,
            description: Swift.String? = nil,
            documentIdentifier: Swift.String? = nil,
            documentVersion: Swift.String? = nil,
            externalParameters: [Swift.String: MgnClientTypes.SsmExternalParameter]? = nil,
            mustSucceedForCutover: Swift.Bool? = nil,
            operatingSystem: Swift.String? = nil,
            order: Swift.Int? = nil,
            parameters: [Swift.String: [MgnClientTypes.SsmParameterStoreParameter]]? = nil,
            timeoutSeconds: Swift.Int? = nil
        )
        {
            self.actionID = actionID
            self.actionName = actionName
            self.active = active
            self.category = category
            self.description = description
            self.documentIdentifier = documentIdentifier
            self.documentVersion = documentVersion
            self.externalParameters = externalParameters
            self.mustSucceedForCutover = mustSucceedForCutover
            self.operatingSystem = operatingSystem
            self.order = order
            self.parameters = parameters
            self.timeoutSeconds = timeoutSeconds
        }
    }

}

public struct ListTemplateActionsOutput {
    /// List of template post migration custom actions.
    public var items: [MgnClientTypes.TemplateActionDocument]?
    /// Next token returned when listing template post migration custom actions.
    public var nextToken: Swift.String?

    public init(
        items: [MgnClientTypes.TemplateActionDocument]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct PutTemplateActionInput {
    /// Template post migration custom action ID.
    /// This member is required.
    public var actionID: Swift.String?
    /// Template post migration custom action name.
    /// This member is required.
    public var actionName: Swift.String?
    /// Template post migration custom action active status.
    public var active: Swift.Bool?
    /// Template post migration custom action category.
    public var category: MgnClientTypes.ActionCategory?
    /// Template post migration custom action description.
    public var description: Swift.String?
    /// Template post migration custom action document identifier.
    /// This member is required.
    public var documentIdentifier: Swift.String?
    /// Template post migration custom action document version.
    public var documentVersion: Swift.String?
    /// Template post migration custom action external parameters.
    public var externalParameters: [Swift.String: MgnClientTypes.SsmExternalParameter]?
    /// Launch configuration template ID.
    /// This member is required.
    public var launchConfigurationTemplateID: Swift.String?
    /// Template post migration custom action must succeed for cutover.
    public var mustSucceedForCutover: Swift.Bool?
    /// Operating system eligible for this template post migration custom action.
    public var operatingSystem: Swift.String?
    /// Template post migration custom action order.
    /// This member is required.
    public var order: Swift.Int?
    /// Template post migration custom action parameters.
    public var parameters: [Swift.String: [MgnClientTypes.SsmParameterStoreParameter]]?
    /// Template post migration custom action timeout in seconds.
    public var timeoutSeconds: Swift.Int?

    public init(
        actionID: Swift.String? = nil,
        actionName: Swift.String? = nil,
        active: Swift.Bool? = nil,
        category: MgnClientTypes.ActionCategory? = nil,
        description: Swift.String? = nil,
        documentIdentifier: Swift.String? = nil,
        documentVersion: Swift.String? = nil,
        externalParameters: [Swift.String: MgnClientTypes.SsmExternalParameter]? = nil,
        launchConfigurationTemplateID: Swift.String? = nil,
        mustSucceedForCutover: Swift.Bool? = nil,
        operatingSystem: Swift.String? = nil,
        order: Swift.Int? = nil,
        parameters: [Swift.String: [MgnClientTypes.SsmParameterStoreParameter]]? = nil,
        timeoutSeconds: Swift.Int? = nil
    )
    {
        self.actionID = actionID
        self.actionName = actionName
        self.active = active
        self.category = category
        self.description = description
        self.documentIdentifier = documentIdentifier
        self.documentVersion = documentVersion
        self.externalParameters = externalParameters
        self.launchConfigurationTemplateID = launchConfigurationTemplateID
        self.mustSucceedForCutover = mustSucceedForCutover
        self.operatingSystem = operatingSystem
        self.order = order
        self.parameters = parameters
        self.timeoutSeconds = timeoutSeconds
    }
}

public struct PutTemplateActionOutput {
    /// Template post migration custom action ID.
    public var actionID: Swift.String?
    /// Template post migration custom action name.
    public var actionName: Swift.String?
    /// Template post migration custom action active status.
    public var active: Swift.Bool?
    /// Template post migration custom action category.
    public var category: MgnClientTypes.ActionCategory?
    /// Template post migration custom action description.
    public var description: Swift.String?
    /// Template post migration custom action document identifier.
    public var documentIdentifier: Swift.String?
    /// Template post migration custom action document version.
    public var documentVersion: Swift.String?
    /// Template post migration custom action external parameters.
    public var externalParameters: [Swift.String: MgnClientTypes.SsmExternalParameter]?
    /// Template post migration custom action must succeed for cutover.
    public var mustSucceedForCutover: Swift.Bool?
    /// Operating system eligible for this template post migration custom action.
    public var operatingSystem: Swift.String?
    /// Template post migration custom action order.
    public var order: Swift.Int?
    /// Template post migration custom action parameters.
    public var parameters: [Swift.String: [MgnClientTypes.SsmParameterStoreParameter]]?
    /// Template post migration custom action timeout in seconds.
    public var timeoutSeconds: Swift.Int?

    public init(
        actionID: Swift.String? = nil,
        actionName: Swift.String? = nil,
        active: Swift.Bool? = nil,
        category: MgnClientTypes.ActionCategory? = nil,
        description: Swift.String? = nil,
        documentIdentifier: Swift.String? = nil,
        documentVersion: Swift.String? = nil,
        externalParameters: [Swift.String: MgnClientTypes.SsmExternalParameter]? = nil,
        mustSucceedForCutover: Swift.Bool? = nil,
        operatingSystem: Swift.String? = nil,
        order: Swift.Int? = nil,
        parameters: [Swift.String: [MgnClientTypes.SsmParameterStoreParameter]]? = nil,
        timeoutSeconds: Swift.Int? = nil
    )
    {
        self.actionID = actionID
        self.actionName = actionName
        self.active = active
        self.category = category
        self.description = description
        self.documentIdentifier = documentIdentifier
        self.documentVersion = documentVersion
        self.externalParameters = externalParameters
        self.mustSucceedForCutover = mustSucceedForCutover
        self.operatingSystem = operatingSystem
        self.order = order
        self.parameters = parameters
        self.timeoutSeconds = timeoutSeconds
    }
}

public struct RemoveTemplateActionInput {
    /// Template post migration custom action ID to remove.
    /// This member is required.
    public var actionID: Swift.String?
    /// Launch configuration template ID of the post migration custom action to remove.
    /// This member is required.
    public var launchConfigurationTemplateID: Swift.String?

    public init(
        actionID: Swift.String? = nil,
        launchConfigurationTemplateID: Swift.String? = nil
    )
    {
        self.actionID = actionID
        self.launchConfigurationTemplateID = launchConfigurationTemplateID
    }
}

public struct RemoveTemplateActionOutput {

    public init() { }
}

public struct UpdateLaunchConfigurationTemplateInput {
    /// Associate public Ip address.
    public var associatePublicIpAddress: Swift.Bool?
    /// Launch configuration template boot mode.
    public var bootMode: MgnClientTypes.BootMode?
    /// Copy private Ip.
    public var copyPrivateIp: Swift.Bool?
    /// Copy tags.
    public var copyTags: Swift.Bool?
    /// Enable map auto tagging.
    public var enableMapAutoTagging: Swift.Bool?
    /// Large volume config.
    public var largeVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
    /// Launch Configuration Template ID.
    /// This member is required.
    public var launchConfigurationTemplateID: Swift.String?
    /// Launch disposition.
    public var launchDisposition: MgnClientTypes.LaunchDisposition?
    /// Configure Licensing.
    public var licensing: MgnClientTypes.Licensing?
    /// Launch configuration template map auto tagging MPE ID.
    public var mapAutoTaggingMpeID: Swift.String?
    /// Post Launch Action to execute on the Test or Cutover instance.
    public var postLaunchActions: MgnClientTypes.PostLaunchActions?
    /// Small volume config.
    public var smallVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
    /// Small volume maximum size.
    public var smallVolumeMaxSize: Swift.Int
    /// Target instance type right-sizing method.
    public var targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?

    public init(
        associatePublicIpAddress: Swift.Bool? = nil,
        bootMode: MgnClientTypes.BootMode? = nil,
        copyPrivateIp: Swift.Bool? = nil,
        copyTags: Swift.Bool? = nil,
        enableMapAutoTagging: Swift.Bool? = nil,
        largeVolumeConf: MgnClientTypes.LaunchTemplateDiskConf? = nil,
        launchConfigurationTemplateID: Swift.String? = nil,
        launchDisposition: MgnClientTypes.LaunchDisposition? = nil,
        licensing: MgnClientTypes.Licensing? = nil,
        mapAutoTaggingMpeID: Swift.String? = nil,
        postLaunchActions: MgnClientTypes.PostLaunchActions? = nil,
        smallVolumeConf: MgnClientTypes.LaunchTemplateDiskConf? = nil,
        smallVolumeMaxSize: Swift.Int = 0,
        targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod? = nil
    )
    {
        self.associatePublicIpAddress = associatePublicIpAddress
        self.bootMode = bootMode
        self.copyPrivateIp = copyPrivateIp
        self.copyTags = copyTags
        self.enableMapAutoTagging = enableMapAutoTagging
        self.largeVolumeConf = largeVolumeConf
        self.launchConfigurationTemplateID = launchConfigurationTemplateID
        self.launchDisposition = launchDisposition
        self.licensing = licensing
        self.mapAutoTaggingMpeID = mapAutoTaggingMpeID
        self.postLaunchActions = postLaunchActions
        self.smallVolumeConf = smallVolumeConf
        self.smallVolumeMaxSize = smallVolumeMaxSize
        self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
    }
}

public struct UpdateLaunchConfigurationTemplateOutput {
    /// ARN of the Launch Configuration Template.
    public var arn: Swift.String?
    /// Associate public Ip address.
    public var associatePublicIpAddress: Swift.Bool?
    /// Launch configuration template boot mode.
    public var bootMode: MgnClientTypes.BootMode?
    /// Copy private Ip.
    public var copyPrivateIp: Swift.Bool?
    /// Copy tags.
    public var copyTags: Swift.Bool?
    /// EC2 launch template ID.
    public var ec2LaunchTemplateID: Swift.String?
    /// Enable map auto tagging.
    public var enableMapAutoTagging: Swift.Bool?
    /// Large volume config.
    public var largeVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
    /// ID of the Launch Configuration Template.
    /// This member is required.
    public var launchConfigurationTemplateID: Swift.String?
    /// Launch disposition.
    public var launchDisposition: MgnClientTypes.LaunchDisposition?
    /// Configure Licensing.
    public var licensing: MgnClientTypes.Licensing?
    /// Launch configuration template map auto tagging MPE ID.
    public var mapAutoTaggingMpeID: Swift.String?
    /// Post Launch Actions of the Launch Configuration Template.
    public var postLaunchActions: MgnClientTypes.PostLaunchActions?
    /// Small volume config.
    public var smallVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
    /// Small volume maximum size.
    public var smallVolumeMaxSize: Swift.Int
    /// Tags of the Launch Configuration Template.
    public var tags: [Swift.String: Swift.String]?
    /// Target instance type right-sizing method.
    public var targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?

    public init(
        arn: Swift.String? = nil,
        associatePublicIpAddress: Swift.Bool? = nil,
        bootMode: MgnClientTypes.BootMode? = nil,
        copyPrivateIp: Swift.Bool? = nil,
        copyTags: Swift.Bool? = nil,
        ec2LaunchTemplateID: Swift.String? = nil,
        enableMapAutoTagging: Swift.Bool? = nil,
        largeVolumeConf: MgnClientTypes.LaunchTemplateDiskConf? = nil,
        launchConfigurationTemplateID: Swift.String? = nil,
        launchDisposition: MgnClientTypes.LaunchDisposition? = nil,
        licensing: MgnClientTypes.Licensing? = nil,
        mapAutoTaggingMpeID: Swift.String? = nil,
        postLaunchActions: MgnClientTypes.PostLaunchActions? = nil,
        smallVolumeConf: MgnClientTypes.LaunchTemplateDiskConf? = nil,
        smallVolumeMaxSize: Swift.Int = 0,
        tags: [Swift.String: Swift.String]? = nil,
        targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod? = nil
    )
    {
        self.arn = arn
        self.associatePublicIpAddress = associatePublicIpAddress
        self.bootMode = bootMode
        self.copyPrivateIp = copyPrivateIp
        self.copyTags = copyTags
        self.ec2LaunchTemplateID = ec2LaunchTemplateID
        self.enableMapAutoTagging = enableMapAutoTagging
        self.largeVolumeConf = largeVolumeConf
        self.launchConfigurationTemplateID = launchConfigurationTemplateID
        self.launchDisposition = launchDisposition
        self.licensing = licensing
        self.mapAutoTaggingMpeID = mapAutoTaggingMpeID
        self.postLaunchActions = postLaunchActions
        self.smallVolumeConf = smallVolumeConf
        self.smallVolumeMaxSize = smallVolumeMaxSize
        self.tags = tags
        self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
    }
}

extension UpdateLaunchConfigurationTemplateOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateLaunchConfigurationTemplateOutput(arn: \(Swift.String(describing: arn)), associatePublicIpAddress: \(Swift.String(describing: associatePublicIpAddress)), bootMode: \(Swift.String(describing: bootMode)), copyPrivateIp: \(Swift.String(describing: copyPrivateIp)), copyTags: \(Swift.String(describing: copyTags)), ec2LaunchTemplateID: \(Swift.String(describing: ec2LaunchTemplateID)), enableMapAutoTagging: \(Swift.String(describing: enableMapAutoTagging)), largeVolumeConf: \(Swift.String(describing: largeVolumeConf)), launchConfigurationTemplateID: \(Swift.String(describing: launchConfigurationTemplateID)), launchDisposition: \(Swift.String(describing: launchDisposition)), licensing: \(Swift.String(describing: licensing)), mapAutoTaggingMpeID: \(Swift.String(describing: mapAutoTaggingMpeID)), postLaunchActions: \(Swift.String(describing: postLaunchActions)), smallVolumeConf: \(Swift.String(describing: smallVolumeConf)), smallVolumeMaxSize: \(Swift.String(describing: smallVolumeMaxSize)), targetInstanceTypeRightSizingMethod: \(Swift.String(describing: targetInstanceTypeRightSizingMethod)), tags: \"CONTENT_REDACTED\")"}
}

/// List managed accounts request.
public struct ListManagedAccountsInput {
    /// List managed accounts request max results.
    public var maxResults: Swift.Int?
    /// List managed accounts request next token.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension MgnClientTypes {
    /// Managed account.
    public struct ManagedAccount {
        /// Managed account, account ID.
        public var accountId: Swift.String?

        public init(
            accountId: Swift.String? = nil
        )
        {
            self.accountId = accountId
        }
    }

}

/// List managed accounts response.
public struct ListManagedAccountsOutput {
    /// List managed accounts response items.
    /// This member is required.
    public var items: [MgnClientTypes.ManagedAccount]?
    /// List managed accounts response next token.
    public var nextToken: Swift.String?

    public init(
        items: [MgnClientTypes.ManagedAccount]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

/// The server encountered an unexpected condition that prevented it from fulfilling the request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The server encountered an unexpected condition that prevented it from fulfilling the request. The request will be retried again after x seconds.
        public internal(set) var retryAfterSeconds: Swift.Int = 0
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// Reached throttling quota exception.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Reached throttling quota exception.
        public internal(set) var quotaCode: Swift.String? = nil
        /// Reached throttling quota exception will retry after x seconds.
        public internal(set) var retryAfterSeconds: Swift.String? = nil
        /// Reached throttling quota exception service code.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

public struct ListTagsForResourceInput {
    /// List tags for resource request by ARN.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// List tags for resource response.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

extension ListTagsForResourceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutput(tags: \"CONTENT_REDACTED\")"}
}

extension MgnClientTypes {

    public enum ReplicationConfigurationDataPlaneRouting: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case privateIp
        case publicIp
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationConfigurationDataPlaneRouting] {
            return [
                .privateIp,
                .publicIp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .privateIp: return "PRIVATE_IP"
            case .publicIp: return "PUBLIC_IP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MgnClientTypes {

    public enum ReplicationConfigurationDefaultLargeStagingDiskType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case gp2
        case gp3
        case st1
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationConfigurationDefaultLargeStagingDiskType] {
            return [
                .gp2,
                .gp3,
                .st1
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .gp2: return "GP2"
            case .gp3: return "GP3"
            case .st1: return "ST1"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MgnClientTypes {

    public enum ReplicationConfigurationEbsEncryption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case custom
        case `default`
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationConfigurationEbsEncryption] {
            return [
                .custom,
                .default
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .custom: return "CUSTOM"
            case .default: return "DEFAULT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateReplicationConfigurationTemplateInput {
    /// Request to associate the default Application Migration Service Security group with the Replication Settings template.
    /// This member is required.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Request to configure bandwidth throttling during Replication Settings template creation.
    /// This member is required.
    public var bandwidthThrottling: Swift.Int
    /// Request to create Public IP during Replication Settings template creation.
    /// This member is required.
    public var createPublicIP: Swift.Bool?
    /// Request to configure data plane routing during Replication Settings template creation.
    /// This member is required.
    public var dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// Request to configure the default large staging disk EBS volume type during Replication Settings template creation.
    /// This member is required.
    public var defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// Request to configure EBS encryption during Replication Settings template creation.
    /// This member is required.
    public var ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    /// Request to configure an EBS encryption key during Replication Settings template creation.
    public var ebsEncryptionKeyArn: Swift.String?
    /// Request to configure the Replication Server instance type during Replication Settings template creation.
    /// This member is required.
    public var replicationServerInstanceType: Swift.String?
    /// Request to configure the Replication Server Security group ID during Replication Settings template creation.
    /// This member is required.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// Request to configure the Staging Area subnet ID during Replication Settings template creation.
    /// This member is required.
    public var stagingAreaSubnetId: Swift.String?
    /// Request to configure Staging Area tags during Replication Settings template creation.
    /// This member is required.
    public var stagingAreaTags: [Swift.String: Swift.String]?
    /// Request to configure tags during Replication Settings template creation.
    public var tags: [Swift.String: Swift.String]?
    /// Request to use Dedicated Replication Servers during Replication Settings template creation.
    /// This member is required.
    public var useDedicatedReplicationServer: Swift.Bool?
    /// Request to use Fips Endpoint during Replication Settings template creation.
    public var useFipsEndpoint: Swift.Bool?

    public init(
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String: Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil,
        useFipsEndpoint: Swift.Bool? = nil
    )
    {
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.tags = tags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
        self.useFipsEndpoint = useFipsEndpoint
    }
}

extension CreateReplicationConfigurationTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateReplicationConfigurationTemplateInput(associateDefaultSecurityGroup: \(Swift.String(describing: associateDefaultSecurityGroup)), bandwidthThrottling: \(Swift.String(describing: bandwidthThrottling)), createPublicIP: \(Swift.String(describing: createPublicIP)), dataPlaneRouting: \(Swift.String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(Swift.String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(Swift.String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(Swift.String(describing: ebsEncryptionKeyArn)), replicationServerInstanceType: \(Swift.String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(Swift.String(describing: replicationServersSecurityGroupsIDs)), stagingAreaSubnetId: \(Swift.String(describing: stagingAreaSubnetId)), useDedicatedReplicationServer: \(Swift.String(describing: useDedicatedReplicationServer)), useFipsEndpoint: \(Swift.String(describing: useFipsEndpoint)), stagingAreaTags: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

public struct CreateReplicationConfigurationTemplateOutput {
    /// Replication Configuration template ARN.
    public var arn: Swift.String?
    /// Replication Configuration template associate default Application Migration Service Security group.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Replication Configuration template bandwidth throttling.
    public var bandwidthThrottling: Swift.Int
    /// Replication Configuration template create Public IP.
    public var createPublicIP: Swift.Bool?
    /// Replication Configuration template data plane routing.
    public var dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// Replication Configuration template use default large Staging Disk type.
    public var defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// Replication Configuration template EBS encryption.
    public var ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    /// Replication Configuration template EBS encryption key ARN.
    public var ebsEncryptionKeyArn: Swift.String?
    /// Replication Configuration template ID.
    /// This member is required.
    public var replicationConfigurationTemplateID: Swift.String?
    /// Replication Configuration template server instance type.
    public var replicationServerInstanceType: Swift.String?
    /// Replication Configuration template server Security Groups IDs.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// Replication Configuration template Staging Area subnet ID.
    public var stagingAreaSubnetId: Swift.String?
    /// Replication Configuration template Staging Area Tags.
    public var stagingAreaTags: [Swift.String: Swift.String]?
    /// Replication Configuration template Tags.
    public var tags: [Swift.String: Swift.String]?
    /// Replication Configuration template use Dedicated Replication Server.
    public var useDedicatedReplicationServer: Swift.Bool?
    /// Replication Configuration template use Fips Endpoint.
    public var useFipsEndpoint: Swift.Bool?

    public init(
        arn: Swift.String? = nil,
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        replicationConfigurationTemplateID: Swift.String? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String: Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil,
        useFipsEndpoint: Swift.Bool? = nil
    )
    {
        self.arn = arn
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.tags = tags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
        self.useFipsEndpoint = useFipsEndpoint
    }
}

extension CreateReplicationConfigurationTemplateOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateReplicationConfigurationTemplateOutput(arn: \(Swift.String(describing: arn)), associateDefaultSecurityGroup: \(Swift.String(describing: associateDefaultSecurityGroup)), bandwidthThrottling: \(Swift.String(describing: bandwidthThrottling)), createPublicIP: \(Swift.String(describing: createPublicIP)), dataPlaneRouting: \(Swift.String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(Swift.String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(Swift.String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(Swift.String(describing: ebsEncryptionKeyArn)), replicationConfigurationTemplateID: \(Swift.String(describing: replicationConfigurationTemplateID)), replicationServerInstanceType: \(Swift.String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(Swift.String(describing: replicationServersSecurityGroupsIDs)), stagingAreaSubnetId: \(Swift.String(describing: stagingAreaSubnetId)), useDedicatedReplicationServer: \(Swift.String(describing: useDedicatedReplicationServer)), useFipsEndpoint: \(Swift.String(describing: useFipsEndpoint)), stagingAreaTags: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

public struct DeleteReplicationConfigurationTemplateInput {
    /// Request to delete Replication Configuration Template from service by Replication Configuration Template ID.
    /// This member is required.
    public var replicationConfigurationTemplateID: Swift.String?

    public init(
        replicationConfigurationTemplateID: Swift.String? = nil
    )
    {
        self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
    }
}

public struct DeleteReplicationConfigurationTemplateOutput {

    public init() { }
}

public struct DescribeReplicationConfigurationTemplatesInput {
    /// Request to describe Replication Configuration template by max results.
    public var maxResults: Swift.Int?
    /// Request to describe Replication Configuration template by next token.
    public var nextToken: Swift.String?
    /// Request to describe Replication Configuration template by template IDs.
    public var replicationConfigurationTemplateIDs: [Swift.String]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        replicationConfigurationTemplateIDs: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.replicationConfigurationTemplateIDs = replicationConfigurationTemplateIDs
    }
}

extension MgnClientTypes {
    public struct ReplicationConfigurationTemplate {
        /// Replication Configuration template ARN.
        public var arn: Swift.String?
        /// Replication Configuration template associate default Application Migration Service Security group.
        public var associateDefaultSecurityGroup: Swift.Bool?
        /// Replication Configuration template bandwidth throttling.
        public var bandwidthThrottling: Swift.Int
        /// Replication Configuration template create Public IP.
        public var createPublicIP: Swift.Bool?
        /// Replication Configuration template data plane routing.
        public var dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
        /// Replication Configuration template use default large Staging Disk type.
        public var defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
        /// Replication Configuration template EBS encryption.
        public var ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
        /// Replication Configuration template EBS encryption key ARN.
        public var ebsEncryptionKeyArn: Swift.String?
        /// Replication Configuration template ID.
        /// This member is required.
        public var replicationConfigurationTemplateID: Swift.String?
        /// Replication Configuration template server instance type.
        public var replicationServerInstanceType: Swift.String?
        /// Replication Configuration template server Security Groups IDs.
        public var replicationServersSecurityGroupsIDs: [Swift.String]?
        /// Replication Configuration template Staging Area subnet ID.
        public var stagingAreaSubnetId: Swift.String?
        /// Replication Configuration template Staging Area Tags.
        public var stagingAreaTags: [Swift.String: Swift.String]?
        /// Replication Configuration template Tags.
        public var tags: [Swift.String: Swift.String]?
        /// Replication Configuration template use Dedicated Replication Server.
        public var useDedicatedReplicationServer: Swift.Bool?
        /// Replication Configuration template use Fips Endpoint.
        public var useFipsEndpoint: Swift.Bool?

        public init(
            arn: Swift.String? = nil,
            associateDefaultSecurityGroup: Swift.Bool? = nil,
            bandwidthThrottling: Swift.Int = 0,
            createPublicIP: Swift.Bool? = nil,
            dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
            defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
            ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption? = nil,
            ebsEncryptionKeyArn: Swift.String? = nil,
            replicationConfigurationTemplateID: Swift.String? = nil,
            replicationServerInstanceType: Swift.String? = nil,
            replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
            stagingAreaSubnetId: Swift.String? = nil,
            stagingAreaTags: [Swift.String: Swift.String]? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            useDedicatedReplicationServer: Swift.Bool? = nil,
            useFipsEndpoint: Swift.Bool? = nil
        )
        {
            self.arn = arn
            self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
            self.bandwidthThrottling = bandwidthThrottling
            self.createPublicIP = createPublicIP
            self.dataPlaneRouting = dataPlaneRouting
            self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
            self.ebsEncryption = ebsEncryption
            self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
            self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
            self.replicationServerInstanceType = replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
            self.stagingAreaSubnetId = stagingAreaSubnetId
            self.stagingAreaTags = stagingAreaTags
            self.tags = tags
            self.useDedicatedReplicationServer = useDedicatedReplicationServer
            self.useFipsEndpoint = useFipsEndpoint
        }
    }

}

extension MgnClientTypes.ReplicationConfigurationTemplate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReplicationConfigurationTemplate(arn: \(Swift.String(describing: arn)), associateDefaultSecurityGroup: \(Swift.String(describing: associateDefaultSecurityGroup)), bandwidthThrottling: \(Swift.String(describing: bandwidthThrottling)), createPublicIP: \(Swift.String(describing: createPublicIP)), dataPlaneRouting: \(Swift.String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(Swift.String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(Swift.String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(Swift.String(describing: ebsEncryptionKeyArn)), replicationConfigurationTemplateID: \(Swift.String(describing: replicationConfigurationTemplateID)), replicationServerInstanceType: \(Swift.String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(Swift.String(describing: replicationServersSecurityGroupsIDs)), stagingAreaSubnetId: \(Swift.String(describing: stagingAreaSubnetId)), useDedicatedReplicationServer: \(Swift.String(describing: useDedicatedReplicationServer)), useFipsEndpoint: \(Swift.String(describing: useFipsEndpoint)), stagingAreaTags: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

public struct DescribeReplicationConfigurationTemplatesOutput {
    /// Request to describe Replication Configuration template by items.
    public var items: [MgnClientTypes.ReplicationConfigurationTemplate]?
    /// Request to describe Replication Configuration template by next token.
    public var nextToken: Swift.String?

    public init(
        items: [MgnClientTypes.ReplicationConfigurationTemplate]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct UpdateReplicationConfigurationTemplateInput {
    /// Update replication configuration template ARN request.
    public var arn: Swift.String?
    /// Update replication configuration template associate default Application Migration Service Security group request.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Update replication configuration template bandwidth throttling request.
    public var bandwidthThrottling: Swift.Int
    /// Update replication configuration template create Public IP request.
    public var createPublicIP: Swift.Bool?
    /// Update replication configuration template data plane routing request.
    public var dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// Update replication configuration template use default large Staging Disk type request.
    public var defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// Update replication configuration template EBS encryption request.
    public var ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    /// Update replication configuration template EBS encryption key ARN request.
    public var ebsEncryptionKeyArn: Swift.String?
    /// Update replication configuration template template ID request.
    /// This member is required.
    public var replicationConfigurationTemplateID: Swift.String?
    /// Update replication configuration template Replication Server instance type request.
    public var replicationServerInstanceType: Swift.String?
    /// Update replication configuration template Replication Server Security groups IDs request.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// Update replication configuration template Staging Area subnet ID request.
    public var stagingAreaSubnetId: Swift.String?
    /// Update replication configuration template Staging Area Tags request.
    public var stagingAreaTags: [Swift.String: Swift.String]?
    /// Update replication configuration template use dedicated Replication Server request.
    public var useDedicatedReplicationServer: Swift.Bool?
    /// Update replication configuration template use Fips Endpoint request.
    public var useFipsEndpoint: Swift.Bool?

    public init(
        arn: Swift.String? = nil,
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        replicationConfigurationTemplateID: Swift.String? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String: Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil,
        useFipsEndpoint: Swift.Bool? = nil
    )
    {
        self.arn = arn
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
        self.useFipsEndpoint = useFipsEndpoint
    }
}

extension UpdateReplicationConfigurationTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateReplicationConfigurationTemplateInput(arn: \(Swift.String(describing: arn)), associateDefaultSecurityGroup: \(Swift.String(describing: associateDefaultSecurityGroup)), bandwidthThrottling: \(Swift.String(describing: bandwidthThrottling)), createPublicIP: \(Swift.String(describing: createPublicIP)), dataPlaneRouting: \(Swift.String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(Swift.String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(Swift.String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(Swift.String(describing: ebsEncryptionKeyArn)), replicationConfigurationTemplateID: \(Swift.String(describing: replicationConfigurationTemplateID)), replicationServerInstanceType: \(Swift.String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(Swift.String(describing: replicationServersSecurityGroupsIDs)), stagingAreaSubnetId: \(Swift.String(describing: stagingAreaSubnetId)), useDedicatedReplicationServer: \(Swift.String(describing: useDedicatedReplicationServer)), useFipsEndpoint: \(Swift.String(describing: useFipsEndpoint)), stagingAreaTags: \"CONTENT_REDACTED\")"}
}

public struct UpdateReplicationConfigurationTemplateOutput {
    /// Replication Configuration template ARN.
    public var arn: Swift.String?
    /// Replication Configuration template associate default Application Migration Service Security group.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Replication Configuration template bandwidth throttling.
    public var bandwidthThrottling: Swift.Int
    /// Replication Configuration template create Public IP.
    public var createPublicIP: Swift.Bool?
    /// Replication Configuration template data plane routing.
    public var dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// Replication Configuration template use default large Staging Disk type.
    public var defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// Replication Configuration template EBS encryption.
    public var ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    /// Replication Configuration template EBS encryption key ARN.
    public var ebsEncryptionKeyArn: Swift.String?
    /// Replication Configuration template ID.
    /// This member is required.
    public var replicationConfigurationTemplateID: Swift.String?
    /// Replication Configuration template server instance type.
    public var replicationServerInstanceType: Swift.String?
    /// Replication Configuration template server Security Groups IDs.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// Replication Configuration template Staging Area subnet ID.
    public var stagingAreaSubnetId: Swift.String?
    /// Replication Configuration template Staging Area Tags.
    public var stagingAreaTags: [Swift.String: Swift.String]?
    /// Replication Configuration template Tags.
    public var tags: [Swift.String: Swift.String]?
    /// Replication Configuration template use Dedicated Replication Server.
    public var useDedicatedReplicationServer: Swift.Bool?
    /// Replication Configuration template use Fips Endpoint.
    public var useFipsEndpoint: Swift.Bool?

    public init(
        arn: Swift.String? = nil,
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        replicationConfigurationTemplateID: Swift.String? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String: Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil,
        useFipsEndpoint: Swift.Bool? = nil
    )
    {
        self.arn = arn
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.tags = tags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
        self.useFipsEndpoint = useFipsEndpoint
    }
}

extension UpdateReplicationConfigurationTemplateOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateReplicationConfigurationTemplateOutput(arn: \(Swift.String(describing: arn)), associateDefaultSecurityGroup: \(Swift.String(describing: associateDefaultSecurityGroup)), bandwidthThrottling: \(Swift.String(describing: bandwidthThrottling)), createPublicIP: \(Swift.String(describing: createPublicIP)), dataPlaneRouting: \(Swift.String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(Swift.String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(Swift.String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(Swift.String(describing: ebsEncryptionKeyArn)), replicationConfigurationTemplateID: \(Swift.String(describing: replicationConfigurationTemplateID)), replicationServerInstanceType: \(Swift.String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(Swift.String(describing: replicationServersSecurityGroupsIDs)), stagingAreaSubnetId: \(Swift.String(describing: stagingAreaSubnetId)), useDedicatedReplicationServer: \(Swift.String(describing: useDedicatedReplicationServer)), useFipsEndpoint: \(Swift.String(describing: useFipsEndpoint)), stagingAreaTags: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

extension MgnClientTypes {

    public enum ChangeServerLifeCycleStateSourceServerLifecycleState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cutover
        case readyForCutover
        case readyForTest
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeServerLifeCycleStateSourceServerLifecycleState] {
            return [
                .cutover,
                .readyForCutover,
                .readyForTest
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cutover: return "CUTOVER"
            case .readyForCutover: return "READY_FOR_CUTOVER"
            case .readyForTest: return "READY_FOR_TEST"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MgnClientTypes {
    /// The request to change the source server migration lifecycle state.
    public struct ChangeServerLifeCycleStateSourceServerLifecycle {
        /// The request to change the source server migration lifecycle state.
        /// This member is required.
        public var state: MgnClientTypes.ChangeServerLifeCycleStateSourceServerLifecycleState?

        public init(
            state: MgnClientTypes.ChangeServerLifeCycleStateSourceServerLifecycleState? = nil
        )
        {
            self.state = state
        }
    }

}

public struct ChangeServerLifeCycleStateInput {
    /// The request to change the source server migration account ID.
    public var accountID: Swift.String?
    /// The request to change the source server migration lifecycle state.
    /// This member is required.
    public var lifeCycle: MgnClientTypes.ChangeServerLifeCycleStateSourceServerLifecycle?
    /// The request to change the source server migration lifecycle state by source server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        lifeCycle: MgnClientTypes.ChangeServerLifeCycleStateSourceServerLifecycle? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.lifeCycle = lifeCycle
        self.sourceServerID = sourceServerID
    }
}

extension MgnClientTypes {
    /// Source Server connector action.
    public struct SourceServerConnectorAction {
        /// Source Server connector action connector arn.
        public var connectorArn: Swift.String?
        /// Source Server connector action credentials secret arn.
        public var credentialsSecretArn: Swift.String?

        public init(
            connectorArn: Swift.String? = nil,
            credentialsSecretArn: Swift.String? = nil
        )
        {
            self.connectorArn = connectorArn
            self.credentialsSecretArn = credentialsSecretArn
        }
    }

}

extension MgnClientTypes {

    public enum DataReplicationErrorString: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case agentNotSeen
        case failedToAttachStagingDisks
        case failedToAuthenticateWithService
        case failedToBootReplicationServer
        case failedToConnectAgentToReplicationServer
        case failedToCreateSecurityGroup
        case failedToCreateStagingDisks
        case failedToDownloadReplicationSoftware
        case failedToLaunchReplicationServer
        case failedToPairReplicationServerWithAgent
        case failedToStartDataTransfer
        case lastSnapshotJobFailed
        case notConverging
        case snapshotsFailure
        case unstableNetwork
        case unsupportedVmConfiguration
        case sdkUnknown(Swift.String)

        public static var allCases: [DataReplicationErrorString] {
            return [
                .agentNotSeen,
                .failedToAttachStagingDisks,
                .failedToAuthenticateWithService,
                .failedToBootReplicationServer,
                .failedToConnectAgentToReplicationServer,
                .failedToCreateSecurityGroup,
                .failedToCreateStagingDisks,
                .failedToDownloadReplicationSoftware,
                .failedToLaunchReplicationServer,
                .failedToPairReplicationServerWithAgent,
                .failedToStartDataTransfer,
                .lastSnapshotJobFailed,
                .notConverging,
                .snapshotsFailure,
                .unstableNetwork,
                .unsupportedVmConfiguration
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .agentNotSeen: return "AGENT_NOT_SEEN"
            case .failedToAttachStagingDisks: return "FAILED_TO_ATTACH_STAGING_DISKS"
            case .failedToAuthenticateWithService: return "FAILED_TO_AUTHENTICATE_WITH_SERVICE"
            case .failedToBootReplicationServer: return "FAILED_TO_BOOT_REPLICATION_SERVER"
            case .failedToConnectAgentToReplicationServer: return "FAILED_TO_CONNECT_AGENT_TO_REPLICATION_SERVER"
            case .failedToCreateSecurityGroup: return "FAILED_TO_CREATE_SECURITY_GROUP"
            case .failedToCreateStagingDisks: return "FAILED_TO_CREATE_STAGING_DISKS"
            case .failedToDownloadReplicationSoftware: return "FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE"
            case .failedToLaunchReplicationServer: return "FAILED_TO_LAUNCH_REPLICATION_SERVER"
            case .failedToPairReplicationServerWithAgent: return "FAILED_TO_PAIR_REPLICATION_SERVER_WITH_AGENT"
            case .failedToStartDataTransfer: return "FAILED_TO_START_DATA_TRANSFER"
            case .lastSnapshotJobFailed: return "LAST_SNAPSHOT_JOB_FAILED"
            case .notConverging: return "NOT_CONVERGING"
            case .snapshotsFailure: return "SNAPSHOTS_FAILURE"
            case .unstableNetwork: return "UNSTABLE_NETWORK"
            case .unsupportedVmConfiguration: return "UNSUPPORTED_VM_CONFIGURATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MgnClientTypes {
    /// Error in data replication.
    public struct DataReplicationError {
        /// Error in data replication.
        public var error: MgnClientTypes.DataReplicationErrorString?
        /// Error in data replication.
        public var rawError: Swift.String?

        public init(
            error: MgnClientTypes.DataReplicationErrorString? = nil,
            rawError: Swift.String? = nil
        )
        {
            self.error = error
            self.rawError = rawError
        }
    }

}

extension MgnClientTypes {

    public enum DataReplicationInitiationStepName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case attachStagingDisks
        case authenticateWithService
        case bootReplicationServer
        case connectAgentToReplicationServer
        case createSecurityGroup
        case createStagingDisks
        case downloadReplicationSoftware
        case launchReplicationServer
        case pairReplicationServerWithAgent
        case startDataTransfer
        case wait
        case sdkUnknown(Swift.String)

        public static var allCases: [DataReplicationInitiationStepName] {
            return [
                .attachStagingDisks,
                .authenticateWithService,
                .bootReplicationServer,
                .connectAgentToReplicationServer,
                .createSecurityGroup,
                .createStagingDisks,
                .downloadReplicationSoftware,
                .launchReplicationServer,
                .pairReplicationServerWithAgent,
                .startDataTransfer,
                .wait
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .attachStagingDisks: return "ATTACH_STAGING_DISKS"
            case .authenticateWithService: return "AUTHENTICATE_WITH_SERVICE"
            case .bootReplicationServer: return "BOOT_REPLICATION_SERVER"
            case .connectAgentToReplicationServer: return "CONNECT_AGENT_TO_REPLICATION_SERVER"
            case .createSecurityGroup: return "CREATE_SECURITY_GROUP"
            case .createStagingDisks: return "CREATE_STAGING_DISKS"
            case .downloadReplicationSoftware: return "DOWNLOAD_REPLICATION_SOFTWARE"
            case .launchReplicationServer: return "LAUNCH_REPLICATION_SERVER"
            case .pairReplicationServerWithAgent: return "PAIR_REPLICATION_SERVER_WITH_AGENT"
            case .startDataTransfer: return "START_DATA_TRANSFER"
            case .wait: return "WAIT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MgnClientTypes {

    public enum DataReplicationInitiationStepStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inProgress
        case notStarted
        case skipped
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [DataReplicationInitiationStepStatus] {
            return [
                .failed,
                .inProgress,
                .notStarted,
                .skipped,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case .skipped: return "SKIPPED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MgnClientTypes {
    /// Data replication initiation step.
    public struct DataReplicationInitiationStep {
        /// Request to query data initiation step name.
        public var name: MgnClientTypes.DataReplicationInitiationStepName?
        /// Request to query data initiation status.
        public var status: MgnClientTypes.DataReplicationInitiationStepStatus?

        public init(
            name: MgnClientTypes.DataReplicationInitiationStepName? = nil,
            status: MgnClientTypes.DataReplicationInitiationStepStatus? = nil
        )
        {
            self.name = name
            self.status = status
        }
    }

}

extension MgnClientTypes {
    /// Data replication initiation.
    public struct DataReplicationInitiation {
        /// Request to query next data initiation date and time.
        public var nextAttemptDateTime: Swift.String?
        /// Request to query data initiation start date and time.
        public var startDateTime: Swift.String?
        /// Request to query data initiation steps.
        public var steps: [MgnClientTypes.DataReplicationInitiationStep]?

        public init(
            nextAttemptDateTime: Swift.String? = nil,
            startDateTime: Swift.String? = nil,
            steps: [MgnClientTypes.DataReplicationInitiationStep]? = nil
        )
        {
            self.nextAttemptDateTime = nextAttemptDateTime
            self.startDateTime = startDateTime
            self.steps = steps
        }
    }

}

extension MgnClientTypes {

    public enum DataReplicationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case backlog
        case continuous
        case creatingSnapshot
        case disconnected
        case initialSync
        case initiating
        case paused
        case pendingSnapshotShipping
        case rescan
        case shippingSnapshot
        case stalled
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [DataReplicationState] {
            return [
                .backlog,
                .continuous,
                .creatingSnapshot,
                .disconnected,
                .initialSync,
                .initiating,
                .paused,
                .pendingSnapshotShipping,
                .rescan,
                .shippingSnapshot,
                .stalled,
                .stopped
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .backlog: return "BACKLOG"
            case .continuous: return "CONTINUOUS"
            case .creatingSnapshot: return "CREATING_SNAPSHOT"
            case .disconnected: return "DISCONNECTED"
            case .initialSync: return "INITIAL_SYNC"
            case .initiating: return "INITIATING"
            case .paused: return "PAUSED"
            case .pendingSnapshotShipping: return "PENDING_SNAPSHOT_SHIPPING"
            case .rescan: return "RESCAN"
            case .shippingSnapshot: return "SHIPPING_SNAPSHOT"
            case .stalled: return "STALLED"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MgnClientTypes {
    /// Request to query disks replicated.
    public struct DataReplicationInfoReplicatedDisk {
        /// Request to query data replication backlog size in bytes.
        public var backloggedStorageBytes: Swift.Int
        /// Request to query device name.
        public var deviceName: Swift.String?
        /// Request to query amount of data replicated in bytes.
        public var replicatedStorageBytes: Swift.Int
        /// Request to query amount of data rescanned in bytes.
        public var rescannedStorageBytes: Swift.Int
        /// Request to query total amount of data replicated in bytes.
        public var totalStorageBytes: Swift.Int

        public init(
            backloggedStorageBytes: Swift.Int = 0,
            deviceName: Swift.String? = nil,
            replicatedStorageBytes: Swift.Int = 0,
            rescannedStorageBytes: Swift.Int = 0,
            totalStorageBytes: Swift.Int = 0
        )
        {
            self.backloggedStorageBytes = backloggedStorageBytes
            self.deviceName = deviceName
            self.replicatedStorageBytes = replicatedStorageBytes
            self.rescannedStorageBytes = rescannedStorageBytes
            self.totalStorageBytes = totalStorageBytes
        }
    }

}

extension MgnClientTypes {
    /// Request data replication info.
    public struct DataReplicationInfo {
        /// Error in obtaining data replication info.
        public var dataReplicationError: MgnClientTypes.DataReplicationError?
        /// Request to query whether data replication has been initiated.
        public var dataReplicationInitiation: MgnClientTypes.DataReplicationInitiation?
        /// Request to query the data replication state.
        public var dataReplicationState: MgnClientTypes.DataReplicationState?
        /// Request to query the time when data replication will be complete.
        public var etaDateTime: Swift.String?
        /// Request to query data replication lag duration.
        public var lagDuration: Swift.String?
        /// Request to query data replication last snapshot time.
        public var lastSnapshotDateTime: Swift.String?
        /// Request to query disks replicated.
        public var replicatedDisks: [MgnClientTypes.DataReplicationInfoReplicatedDisk]?

        public init(
            dataReplicationError: MgnClientTypes.DataReplicationError? = nil,
            dataReplicationInitiation: MgnClientTypes.DataReplicationInitiation? = nil,
            dataReplicationState: MgnClientTypes.DataReplicationState? = nil,
            etaDateTime: Swift.String? = nil,
            lagDuration: Swift.String? = nil,
            lastSnapshotDateTime: Swift.String? = nil,
            replicatedDisks: [MgnClientTypes.DataReplicationInfoReplicatedDisk]? = nil
        )
        {
            self.dataReplicationError = dataReplicationError
            self.dataReplicationInitiation = dataReplicationInitiation
            self.dataReplicationState = dataReplicationState
            self.etaDateTime = etaDateTime
            self.lagDuration = lagDuration
            self.lastSnapshotDateTime = lastSnapshotDateTime
            self.replicatedDisks = replicatedDisks
        }
    }

}

extension MgnClientTypes {

    public enum FirstBoot: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case stopped
        case succeeded
        case unknown
        case waiting
        case sdkUnknown(Swift.String)

        public static var allCases: [FirstBoot] {
            return [
                .stopped,
                .succeeded,
                .unknown,
                .waiting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .stopped: return "STOPPED"
            case .succeeded: return "SUCCEEDED"
            case .unknown: return "UNKNOWN"
            case .waiting: return "WAITING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MgnClientTypes {
    /// Launched instance.
    public struct LaunchedInstance {
        /// Launched instance EC2 ID.
        public var ec2InstanceID: Swift.String?
        /// Launched instance first boot.
        public var firstBoot: MgnClientTypes.FirstBoot?
        /// Launched instance Job ID.
        public var jobID: Swift.String?

        public init(
            ec2InstanceID: Swift.String? = nil,
            firstBoot: MgnClientTypes.FirstBoot? = nil,
            jobID: Swift.String? = nil
        )
        {
            self.ec2InstanceID = ec2InstanceID
            self.firstBoot = firstBoot
            self.jobID = jobID
        }
    }

}

extension MgnClientTypes {
    /// Lifecycle Cutover finalized
    public struct LifeCycleLastCutoverFinalized {
        /// Lifecycle Cutover finalized date and time.
        public var apiCallDateTime: Swift.String?

        public init(
            apiCallDateTime: Swift.String? = nil
        )
        {
            self.apiCallDateTime = apiCallDateTime
        }
    }

}

extension MgnClientTypes {
    /// Lifecycle last Cutover initiated.
    public struct LifeCycleLastCutoverInitiated {
        ///
        public var apiCallDateTime: Swift.String?
        /// Lifecycle last Cutover initiated by Job ID.
        public var jobID: Swift.String?

        public init(
            apiCallDateTime: Swift.String? = nil,
            jobID: Swift.String? = nil
        )
        {
            self.apiCallDateTime = apiCallDateTime
            self.jobID = jobID
        }
    }

}

extension MgnClientTypes {
    /// Lifecycle last Cutover reverted.
    public struct LifeCycleLastCutoverReverted {
        /// Lifecycle last Cutover reverted API call date time.
        public var apiCallDateTime: Swift.String?

        public init(
            apiCallDateTime: Swift.String? = nil
        )
        {
            self.apiCallDateTime = apiCallDateTime
        }
    }

}

extension MgnClientTypes {
    /// Lifecycle last Cutover .
    public struct LifeCycleLastCutover {
        /// Lifecycle Cutover finalized date and time.
        public var finalized: MgnClientTypes.LifeCycleLastCutoverFinalized?
        /// Lifecycle last Cutover initiated.
        public var initiated: MgnClientTypes.LifeCycleLastCutoverInitiated?
        /// Lifecycle last Cutover reverted.
        public var reverted: MgnClientTypes.LifeCycleLastCutoverReverted?

        public init(
            finalized: MgnClientTypes.LifeCycleLastCutoverFinalized? = nil,
            initiated: MgnClientTypes.LifeCycleLastCutoverInitiated? = nil,
            reverted: MgnClientTypes.LifeCycleLastCutoverReverted? = nil
        )
        {
            self.finalized = finalized
            self.initiated = initiated
            self.reverted = reverted
        }
    }

}

extension MgnClientTypes {
    /// Lifecycle last Test finalized.
    public struct LifeCycleLastTestFinalized {
        /// Lifecycle Test failed API call date and time.
        public var apiCallDateTime: Swift.String?

        public init(
            apiCallDateTime: Swift.String? = nil
        )
        {
            self.apiCallDateTime = apiCallDateTime
        }
    }

}

extension MgnClientTypes {
    /// Lifecycle last Test initiated.
    public struct LifeCycleLastTestInitiated {
        /// Lifecycle last Test initiated API call date and time.
        public var apiCallDateTime: Swift.String?
        /// Lifecycle last Test initiated Job ID.
        public var jobID: Swift.String?

        public init(
            apiCallDateTime: Swift.String? = nil,
            jobID: Swift.String? = nil
        )
        {
            self.apiCallDateTime = apiCallDateTime
            self.jobID = jobID
        }
    }

}

extension MgnClientTypes {
    /// Lifecycle last Test reverted.
    public struct LifeCycleLastTestReverted {
        /// Lifecycle last Test reverted API call date and time.
        public var apiCallDateTime: Swift.String?

        public init(
            apiCallDateTime: Swift.String? = nil
        )
        {
            self.apiCallDateTime = apiCallDateTime
        }
    }

}

extension MgnClientTypes {
    /// Lifecycle last Test.
    public struct LifeCycleLastTest {
        /// Lifecycle last Test finalized.
        public var finalized: MgnClientTypes.LifeCycleLastTestFinalized?
        /// Lifecycle last Test initiated.
        public var initiated: MgnClientTypes.LifeCycleLastTestInitiated?
        /// Lifecycle last Test reverted.
        public var reverted: MgnClientTypes.LifeCycleLastTestReverted?

        public init(
            finalized: MgnClientTypes.LifeCycleLastTestFinalized? = nil,
            initiated: MgnClientTypes.LifeCycleLastTestInitiated? = nil,
            reverted: MgnClientTypes.LifeCycleLastTestReverted? = nil
        )
        {
            self.finalized = finalized
            self.initiated = initiated
            self.reverted = reverted
        }
    }

}

extension MgnClientTypes {

    public enum LifeCycleState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cutover
        case cuttingOver
        case disconnected
        case discovered
        case notReady
        case pendingInstallation
        case readyForCutover
        case readyForTest
        case stopped
        case testing
        case sdkUnknown(Swift.String)

        public static var allCases: [LifeCycleState] {
            return [
                .cutover,
                .cuttingOver,
                .disconnected,
                .discovered,
                .notReady,
                .pendingInstallation,
                .readyForCutover,
                .readyForTest,
                .stopped,
                .testing
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cutover: return "CUTOVER"
            case .cuttingOver: return "CUTTING_OVER"
            case .disconnected: return "DISCONNECTED"
            case .discovered: return "DISCOVERED"
            case .notReady: return "NOT_READY"
            case .pendingInstallation: return "PENDING_INSTALLATION"
            case .readyForCutover: return "READY_FOR_CUTOVER"
            case .readyForTest: return "READY_FOR_TEST"
            case .stopped: return "STOPPED"
            case .testing: return "TESTING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MgnClientTypes {
    /// Lifecycle.
    public struct LifeCycle {
        /// Lifecycle added to service data and time.
        public var addedToServiceDateTime: Swift.String?
        /// Lifecycle elapsed time and duration.
        public var elapsedReplicationDuration: Swift.String?
        /// Lifecycle replication initiation date and time.
        public var firstByteDateTime: Swift.String?
        /// Lifecycle last Cutover.
        public var lastCutover: MgnClientTypes.LifeCycleLastCutover?
        /// Lifecycle last seen date and time.
        public var lastSeenByServiceDateTime: Swift.String?
        /// Lifecycle last Test.
        public var lastTest: MgnClientTypes.LifeCycleLastTest?
        /// Lifecycle state.
        public var state: MgnClientTypes.LifeCycleState?

        public init(
            addedToServiceDateTime: Swift.String? = nil,
            elapsedReplicationDuration: Swift.String? = nil,
            firstByteDateTime: Swift.String? = nil,
            lastCutover: MgnClientTypes.LifeCycleLastCutover? = nil,
            lastSeenByServiceDateTime: Swift.String? = nil,
            lastTest: MgnClientTypes.LifeCycleLastTest? = nil,
            state: MgnClientTypes.LifeCycleState? = nil
        )
        {
            self.addedToServiceDateTime = addedToServiceDateTime
            self.elapsedReplicationDuration = elapsedReplicationDuration
            self.firstByteDateTime = firstByteDateTime
            self.lastCutover = lastCutover
            self.lastSeenByServiceDateTime = lastSeenByServiceDateTime
            self.lastTest = lastTest
            self.state = state
        }
    }

}

extension MgnClientTypes {

    public enum ReplicationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case agentBased
        case snapshotShipping
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationType] {
            return [
                .agentBased,
                .snapshotShipping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .agentBased: return "AGENT_BASED"
            case .snapshotShipping: return "SNAPSHOT_SHIPPING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MgnClientTypes {
    /// Source server CPU information.
    public struct CPU {
        /// The number of CPU cores on the source server.
        public var cores: Swift.Int
        /// The source server's CPU model name.
        public var modelName: Swift.String?

        public init(
            cores: Swift.Int = 0,
            modelName: Swift.String? = nil
        )
        {
            self.cores = cores
            self.modelName = modelName
        }
    }

}

extension MgnClientTypes {
    /// The disk identifier.
    public struct Disk {
        /// The amount of storage on the disk in bytes.
        public var bytes: Swift.Int
        /// The disk or device name.
        public var deviceName: Swift.String?

        public init(
            bytes: Swift.Int = 0,
            deviceName: Swift.String? = nil
        )
        {
            self.bytes = bytes
            self.deviceName = deviceName
        }
    }

}

extension MgnClientTypes {
    /// Identification hints.
    public struct IdentificationHints {
        /// AWS Instance ID identification hint.
        public var awsInstanceID: Swift.String?
        /// FQDN address identification hint.
        public var fqdn: Swift.String?
        /// Hostname identification hint.
        public var hostname: Swift.String?
        /// vCenter VM path identification hint.
        public var vmPath: Swift.String?
        /// vmWare UUID identification hint.
        public var vmWareUuid: Swift.String?

        public init(
            awsInstanceID: Swift.String? = nil,
            fqdn: Swift.String? = nil,
            hostname: Swift.String? = nil,
            vmPath: Swift.String? = nil,
            vmWareUuid: Swift.String? = nil
        )
        {
            self.awsInstanceID = awsInstanceID
            self.fqdn = fqdn
            self.hostname = hostname
            self.vmPath = vmPath
            self.vmWareUuid = vmWareUuid
        }
    }

}

extension MgnClientTypes {
    /// Network interface.
    public struct NetworkInterface {
        /// Network interface IPs.
        public var ips: [Swift.String]?
        /// Network interface primary IP.
        public var isPrimary: Swift.Bool?
        /// Network interface Mac address.
        public var macAddress: Swift.String?

        public init(
            ips: [Swift.String]? = nil,
            isPrimary: Swift.Bool? = nil,
            macAddress: Swift.String? = nil
        )
        {
            self.ips = ips
            self.isPrimary = isPrimary
            self.macAddress = macAddress
        }
    }

}

extension MgnClientTypes {
    /// Operating System.
    public struct OS {
        /// OS full string.
        public var fullString: Swift.String?

        public init(
            fullString: Swift.String? = nil
        )
        {
            self.fullString = fullString
        }
    }

}

extension MgnClientTypes {
    /// Source server properties.
    public struct SourceProperties {
        /// Source Server CPUs.
        public var cpus: [MgnClientTypes.CPU]?
        /// Source Server disks.
        public var disks: [MgnClientTypes.Disk]?
        /// Source server identification hints.
        public var identificationHints: MgnClientTypes.IdentificationHints?
        /// Source server last update date and time.
        public var lastUpdatedDateTime: Swift.String?
        /// Source server network interfaces.
        public var networkInterfaces: [MgnClientTypes.NetworkInterface]?
        /// Source server OS.
        public var os: MgnClientTypes.OS?
        /// Source server RAM in bytes.
        public var ramBytes: Swift.Int
        /// Source server recommended instance type.
        public var recommendedInstanceType: Swift.String?

        public init(
            cpus: [MgnClientTypes.CPU]? = nil,
            disks: [MgnClientTypes.Disk]? = nil,
            identificationHints: MgnClientTypes.IdentificationHints? = nil,
            lastUpdatedDateTime: Swift.String? = nil,
            networkInterfaces: [MgnClientTypes.NetworkInterface]? = nil,
            os: MgnClientTypes.OS? = nil,
            ramBytes: Swift.Int = 0,
            recommendedInstanceType: Swift.String? = nil
        )
        {
            self.cpus = cpus
            self.disks = disks
            self.identificationHints = identificationHints
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.networkInterfaces = networkInterfaces
            self.os = os
            self.ramBytes = ramBytes
            self.recommendedInstanceType = recommendedInstanceType
        }
    }

}

public struct ChangeServerLifeCycleStateOutput {
    /// Source server application ID.
    public var applicationID: Swift.String?
    /// Source server ARN.
    public var arn: Swift.String?
    /// Source Server connector action.
    public var connectorAction: MgnClientTypes.SourceServerConnectorAction?
    /// Source server data replication info.
    public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    /// Source server fqdn for action framework.
    public var fqdnForActionFramework: Swift.String?
    /// Source server archived status.
    public var isArchived: Swift.Bool?
    /// Source server launched instance.
    public var launchedInstance: MgnClientTypes.LaunchedInstance?
    /// Source server lifecycle state.
    public var lifeCycle: MgnClientTypes.LifeCycle?
    /// Source server replication type.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// Source server properties.
    public var sourceProperties: MgnClientTypes.SourceProperties?
    /// Source server ID.
    public var sourceServerID: Swift.String?
    /// Source server Tags.
    public var tags: [Swift.String: Swift.String]?
    /// Source server user provided ID.
    public var userProvidedID: Swift.String?
    /// Source server vCenter client id.
    public var vcenterClientID: Swift.String?

    public init(
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        connectorAction: MgnClientTypes.SourceServerConnectorAction? = nil,
        dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
        fqdnForActionFramework: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
        lifeCycle: MgnClientTypes.LifeCycle? = nil,
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceProperties: MgnClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        userProvidedID: Swift.String? = nil,
        vcenterClientID: Swift.String? = nil
    )
    {
        self.applicationID = applicationID
        self.arn = arn
        self.connectorAction = connectorAction
        self.dataReplicationInfo = dataReplicationInfo
        self.fqdnForActionFramework = fqdnForActionFramework
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.replicationType = replicationType
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
        self.userProvidedID = userProvidedID
        self.vcenterClientID = vcenterClientID
    }
}

extension ChangeServerLifeCycleStateOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChangeServerLifeCycleStateOutput(applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), connectorAction: \(Swift.String(describing: connectorAction)), dataReplicationInfo: \(Swift.String(describing: dataReplicationInfo)), fqdnForActionFramework: \(Swift.String(describing: fqdnForActionFramework)), isArchived: \(Swift.String(describing: isArchived)), launchedInstance: \(Swift.String(describing: launchedInstance)), lifeCycle: \(Swift.String(describing: lifeCycle)), replicationType: \(Swift.String(describing: replicationType)), sourceProperties: \(Swift.String(describing: sourceProperties)), sourceServerID: \(Swift.String(describing: sourceServerID)), userProvidedID: \(Swift.String(describing: userProvidedID)), vcenterClientID: \(Swift.String(describing: vcenterClientID)), tags: \"CONTENT_REDACTED\")"}
}

public struct DeleteSourceServerInput {
    /// Request to delete Source Server from service by Account ID.
    public var accountID: Swift.String?
    /// Request to delete Source Server from service by Server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.sourceServerID = sourceServerID
    }
}

public struct DeleteSourceServerOutput {

    public init() { }
}

extension MgnClientTypes {
    /// Request to filter Source Servers list.
    public struct DescribeSourceServersRequestFilters {
        /// Request to filter Source Servers list by application IDs.
        public var applicationIDs: [Swift.String]?
        /// Request to filter Source Servers list by archived.
        public var isArchived: Swift.Bool?
        /// Request to filter Source Servers list by life cycle states.
        public var lifeCycleStates: [MgnClientTypes.LifeCycleState]?
        /// Request to filter Source Servers list by replication type.
        public var replicationTypes: [MgnClientTypes.ReplicationType]?
        /// Request to filter Source Servers list by Source Server ID.
        public var sourceServerIDs: [Swift.String]?

        public init(
            applicationIDs: [Swift.String]? = nil,
            isArchived: Swift.Bool? = nil,
            lifeCycleStates: [MgnClientTypes.LifeCycleState]? = nil,
            replicationTypes: [MgnClientTypes.ReplicationType]? = nil,
            sourceServerIDs: [Swift.String]? = nil
        )
        {
            self.applicationIDs = applicationIDs
            self.isArchived = isArchived
            self.lifeCycleStates = lifeCycleStates
            self.replicationTypes = replicationTypes
            self.sourceServerIDs = sourceServerIDs
        }
    }

}

public struct DescribeSourceServersInput {
    /// Request to filter Source Servers list by Accoun ID.
    public var accountID: Swift.String?
    /// Request to filter Source Servers list.
    public var filters: MgnClientTypes.DescribeSourceServersRequestFilters?
    /// Request to filter Source Servers list by maximum results.
    public var maxResults: Swift.Int?
    /// Request to filter Source Servers list by next token.
    public var nextToken: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        filters: MgnClientTypes.DescribeSourceServersRequestFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension MgnClientTypes {
    public struct SourceServer {
        /// Source server application ID.
        public var applicationID: Swift.String?
        /// Source server ARN.
        public var arn: Swift.String?
        /// Source Server connector action.
        public var connectorAction: MgnClientTypes.SourceServerConnectorAction?
        /// Source server data replication info.
        public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
        /// Source server fqdn for action framework.
        public var fqdnForActionFramework: Swift.String?
        /// Source server archived status.
        public var isArchived: Swift.Bool?
        /// Source server launched instance.
        public var launchedInstance: MgnClientTypes.LaunchedInstance?
        /// Source server lifecycle state.
        public var lifeCycle: MgnClientTypes.LifeCycle?
        /// Source server replication type.
        public var replicationType: MgnClientTypes.ReplicationType?
        /// Source server properties.
        public var sourceProperties: MgnClientTypes.SourceProperties?
        /// Source server ID.
        public var sourceServerID: Swift.String?
        /// Source server Tags.
        public var tags: [Swift.String: Swift.String]?
        /// Source server user provided ID.
        public var userProvidedID: Swift.String?
        /// Source server vCenter client id.
        public var vcenterClientID: Swift.String?

        public init(
            applicationID: Swift.String? = nil,
            arn: Swift.String? = nil,
            connectorAction: MgnClientTypes.SourceServerConnectorAction? = nil,
            dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
            fqdnForActionFramework: Swift.String? = nil,
            isArchived: Swift.Bool? = nil,
            launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
            lifeCycle: MgnClientTypes.LifeCycle? = nil,
            replicationType: MgnClientTypes.ReplicationType? = nil,
            sourceProperties: MgnClientTypes.SourceProperties? = nil,
            sourceServerID: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            userProvidedID: Swift.String? = nil,
            vcenterClientID: Swift.String? = nil
        )
        {
            self.applicationID = applicationID
            self.arn = arn
            self.connectorAction = connectorAction
            self.dataReplicationInfo = dataReplicationInfo
            self.fqdnForActionFramework = fqdnForActionFramework
            self.isArchived = isArchived
            self.launchedInstance = launchedInstance
            self.lifeCycle = lifeCycle
            self.replicationType = replicationType
            self.sourceProperties = sourceProperties
            self.sourceServerID = sourceServerID
            self.tags = tags
            self.userProvidedID = userProvidedID
            self.vcenterClientID = vcenterClientID
        }
    }

}

extension MgnClientTypes.SourceServer: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SourceServer(applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), connectorAction: \(Swift.String(describing: connectorAction)), dataReplicationInfo: \(Swift.String(describing: dataReplicationInfo)), fqdnForActionFramework: \(Swift.String(describing: fqdnForActionFramework)), isArchived: \(Swift.String(describing: isArchived)), launchedInstance: \(Swift.String(describing: launchedInstance)), lifeCycle: \(Swift.String(describing: lifeCycle)), replicationType: \(Swift.String(describing: replicationType)), sourceProperties: \(Swift.String(describing: sourceProperties)), sourceServerID: \(Swift.String(describing: sourceServerID)), userProvidedID: \(Swift.String(describing: userProvidedID)), vcenterClientID: \(Swift.String(describing: vcenterClientID)), tags: \"CONTENT_REDACTED\")"}
}

public struct DescribeSourceServersOutput {
    /// Request to filter Source Servers list by item.
    public var items: [MgnClientTypes.SourceServer]?
    /// Request to filter Source Servers next token.
    public var nextToken: Swift.String?

    public init(
        items: [MgnClientTypes.SourceServer]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct DisconnectFromServiceInput {
    /// Request to disconnect Source Server from service by Account ID.
    public var accountID: Swift.String?
    /// Request to disconnect Source Server from service by Server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.sourceServerID = sourceServerID
    }
}

public struct DisconnectFromServiceOutput {
    /// Source server application ID.
    public var applicationID: Swift.String?
    /// Source server ARN.
    public var arn: Swift.String?
    /// Source Server connector action.
    public var connectorAction: MgnClientTypes.SourceServerConnectorAction?
    /// Source server data replication info.
    public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    /// Source server fqdn for action framework.
    public var fqdnForActionFramework: Swift.String?
    /// Source server archived status.
    public var isArchived: Swift.Bool?
    /// Source server launched instance.
    public var launchedInstance: MgnClientTypes.LaunchedInstance?
    /// Source server lifecycle state.
    public var lifeCycle: MgnClientTypes.LifeCycle?
    /// Source server replication type.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// Source server properties.
    public var sourceProperties: MgnClientTypes.SourceProperties?
    /// Source server ID.
    public var sourceServerID: Swift.String?
    /// Source server Tags.
    public var tags: [Swift.String: Swift.String]?
    /// Source server user provided ID.
    public var userProvidedID: Swift.String?
    /// Source server vCenter client id.
    public var vcenterClientID: Swift.String?

    public init(
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        connectorAction: MgnClientTypes.SourceServerConnectorAction? = nil,
        dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
        fqdnForActionFramework: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
        lifeCycle: MgnClientTypes.LifeCycle? = nil,
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceProperties: MgnClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        userProvidedID: Swift.String? = nil,
        vcenterClientID: Swift.String? = nil
    )
    {
        self.applicationID = applicationID
        self.arn = arn
        self.connectorAction = connectorAction
        self.dataReplicationInfo = dataReplicationInfo
        self.fqdnForActionFramework = fqdnForActionFramework
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.replicationType = replicationType
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
        self.userProvidedID = userProvidedID
        self.vcenterClientID = vcenterClientID
    }
}

extension DisconnectFromServiceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisconnectFromServiceOutput(applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), connectorAction: \(Swift.String(describing: connectorAction)), dataReplicationInfo: \(Swift.String(describing: dataReplicationInfo)), fqdnForActionFramework: \(Swift.String(describing: fqdnForActionFramework)), isArchived: \(Swift.String(describing: isArchived)), launchedInstance: \(Swift.String(describing: launchedInstance)), lifeCycle: \(Swift.String(describing: lifeCycle)), replicationType: \(Swift.String(describing: replicationType)), sourceProperties: \(Swift.String(describing: sourceProperties)), sourceServerID: \(Swift.String(describing: sourceServerID)), userProvidedID: \(Swift.String(describing: userProvidedID)), vcenterClientID: \(Swift.String(describing: vcenterClientID)), tags: \"CONTENT_REDACTED\")"}
}

public struct FinalizeCutoverInput {
    /// Request to finalize Cutover by Source Account ID.
    public var accountID: Swift.String?
    /// Request to finalize Cutover by Source Server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.sourceServerID = sourceServerID
    }
}

public struct FinalizeCutoverOutput {
    /// Source server application ID.
    public var applicationID: Swift.String?
    /// Source server ARN.
    public var arn: Swift.String?
    /// Source Server connector action.
    public var connectorAction: MgnClientTypes.SourceServerConnectorAction?
    /// Source server data replication info.
    public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    /// Source server fqdn for action framework.
    public var fqdnForActionFramework: Swift.String?
    /// Source server archived status.
    public var isArchived: Swift.Bool?
    /// Source server launched instance.
    public var launchedInstance: MgnClientTypes.LaunchedInstance?
    /// Source server lifecycle state.
    public var lifeCycle: MgnClientTypes.LifeCycle?
    /// Source server replication type.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// Source server properties.
    public var sourceProperties: MgnClientTypes.SourceProperties?
    /// Source server ID.
    public var sourceServerID: Swift.String?
    /// Source server Tags.
    public var tags: [Swift.String: Swift.String]?
    /// Source server user provided ID.
    public var userProvidedID: Swift.String?
    /// Source server vCenter client id.
    public var vcenterClientID: Swift.String?

    public init(
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        connectorAction: MgnClientTypes.SourceServerConnectorAction? = nil,
        dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
        fqdnForActionFramework: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
        lifeCycle: MgnClientTypes.LifeCycle? = nil,
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceProperties: MgnClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        userProvidedID: Swift.String? = nil,
        vcenterClientID: Swift.String? = nil
    )
    {
        self.applicationID = applicationID
        self.arn = arn
        self.connectorAction = connectorAction
        self.dataReplicationInfo = dataReplicationInfo
        self.fqdnForActionFramework = fqdnForActionFramework
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.replicationType = replicationType
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
        self.userProvidedID = userProvidedID
        self.vcenterClientID = vcenterClientID
    }
}

extension FinalizeCutoverOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FinalizeCutoverOutput(applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), connectorAction: \(Swift.String(describing: connectorAction)), dataReplicationInfo: \(Swift.String(describing: dataReplicationInfo)), fqdnForActionFramework: \(Swift.String(describing: fqdnForActionFramework)), isArchived: \(Swift.String(describing: isArchived)), launchedInstance: \(Swift.String(describing: launchedInstance)), lifeCycle: \(Swift.String(describing: lifeCycle)), replicationType: \(Swift.String(describing: replicationType)), sourceProperties: \(Swift.String(describing: sourceProperties)), sourceServerID: \(Swift.String(describing: sourceServerID)), userProvidedID: \(Swift.String(describing: userProvidedID)), vcenterClientID: \(Swift.String(describing: vcenterClientID)), tags: \"CONTENT_REDACTED\")"}
}

public struct GetLaunchConfigurationInput {
    /// Request to get Launch Configuration information by Account ID.
    public var accountID: Swift.String?
    /// Request to get Launch Configuration information by Source Server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.sourceServerID = sourceServerID
    }
}

public struct GetLaunchConfigurationOutput {
    /// Launch configuration boot mode.
    public var bootMode: MgnClientTypes.BootMode?
    /// Copy Private IP during Launch Configuration.
    public var copyPrivateIp: Swift.Bool?
    /// Copy Tags during Launch Configuration.
    public var copyTags: Swift.Bool?
    /// Launch configuration EC2 Launch template ID.
    public var ec2LaunchTemplateID: Swift.String?
    /// Enable map auto tagging.
    public var enableMapAutoTagging: Swift.Bool?
    /// Launch disposition for launch configuration.
    public var launchDisposition: MgnClientTypes.LaunchDisposition?
    /// Launch configuration OS licensing.
    public var licensing: MgnClientTypes.Licensing?
    /// Map auto tagging MPE ID.
    public var mapAutoTaggingMpeID: Swift.String?
    /// Launch configuration name.
    public var name: Swift.String?
    /// Post Launch Actions to executed on the Test or Cutover instance.
    public var postLaunchActions: MgnClientTypes.PostLaunchActions?
    /// Launch configuration Source Server ID.
    public var sourceServerID: Swift.String?
    /// Launch configuration Target instance type right sizing method.
    public var targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?

    public init(
        bootMode: MgnClientTypes.BootMode? = nil,
        copyPrivateIp: Swift.Bool? = nil,
        copyTags: Swift.Bool? = nil,
        ec2LaunchTemplateID: Swift.String? = nil,
        enableMapAutoTagging: Swift.Bool? = nil,
        launchDisposition: MgnClientTypes.LaunchDisposition? = nil,
        licensing: MgnClientTypes.Licensing? = nil,
        mapAutoTaggingMpeID: Swift.String? = nil,
        name: Swift.String? = nil,
        postLaunchActions: MgnClientTypes.PostLaunchActions? = nil,
        sourceServerID: Swift.String? = nil,
        targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod? = nil
    )
    {
        self.bootMode = bootMode
        self.copyPrivateIp = copyPrivateIp
        self.copyTags = copyTags
        self.ec2LaunchTemplateID = ec2LaunchTemplateID
        self.enableMapAutoTagging = enableMapAutoTagging
        self.launchDisposition = launchDisposition
        self.licensing = licensing
        self.mapAutoTaggingMpeID = mapAutoTaggingMpeID
        self.name = name
        self.postLaunchActions = postLaunchActions
        self.sourceServerID = sourceServerID
        self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
    }
}

public struct GetReplicationConfigurationInput {
    /// Request to get Replication Configuration by Account ID.
    public var accountID: Swift.String?
    /// Request to get Replication Configuration by Source Server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.sourceServerID = sourceServerID
    }
}

extension MgnClientTypes {

    public enum ReplicationConfigurationReplicatedDiskStagingDiskType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case auto
        case gp2
        case gp3
        case io1
        case io2
        case sc1
        case st1
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationConfigurationReplicatedDiskStagingDiskType] {
            return [
                .auto,
                .gp2,
                .gp3,
                .io1,
                .io2,
                .sc1,
                .st1,
                .standard
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTO"
            case .gp2: return "GP2"
            case .gp3: return "GP3"
            case .io1: return "IO1"
            case .io2: return "IO2"
            case .sc1: return "SC1"
            case .st1: return "ST1"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MgnClientTypes {
    /// Replication Configuration replicated disk.
    public struct ReplicationConfigurationReplicatedDisk {
        /// Replication Configuration replicated disk device name.
        public var deviceName: Swift.String?
        /// Replication Configuration replicated disk IOPs.
        public var iops: Swift.Int
        /// Replication Configuration replicated disk boot disk.
        public var isBootDisk: Swift.Bool?
        /// Replication Configuration replicated disk staging disk type.
        public var stagingDiskType: MgnClientTypes.ReplicationConfigurationReplicatedDiskStagingDiskType?
        /// Replication Configuration replicated disk throughput.
        public var throughput: Swift.Int

        public init(
            deviceName: Swift.String? = nil,
            iops: Swift.Int = 0,
            isBootDisk: Swift.Bool? = nil,
            stagingDiskType: MgnClientTypes.ReplicationConfigurationReplicatedDiskStagingDiskType? = nil,
            throughput: Swift.Int = 0
        )
        {
            self.deviceName = deviceName
            self.iops = iops
            self.isBootDisk = isBootDisk
            self.stagingDiskType = stagingDiskType
            self.throughput = throughput
        }
    }

}

public struct GetReplicationConfigurationOutput {
    /// Replication Configuration associate default Application Migration Service Security Group.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Replication Configuration set bandwidth throttling.
    public var bandwidthThrottling: Swift.Int
    /// Replication Configuration create Public IP.
    public var createPublicIP: Swift.Bool?
    /// Replication Configuration data plane routing.
    public var dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// Replication Configuration use default large Staging Disks.
    public var defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// Replication Configuration EBS encryption.
    public var ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    /// Replication Configuration EBS encryption key ARN.
    public var ebsEncryptionKeyArn: Swift.String?
    /// Replication Configuration name.
    public var name: Swift.String?
    /// Replication Configuration replicated disks.
    public var replicatedDisks: [MgnClientTypes.ReplicationConfigurationReplicatedDisk]?
    /// Replication Configuration Replication Server instance type.
    public var replicationServerInstanceType: Swift.String?
    /// Replication Configuration Replication Server Security Group IDs.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// Replication Configuration Source Server ID.
    public var sourceServerID: Swift.String?
    /// Replication Configuration Staging Area subnet ID.
    public var stagingAreaSubnetId: Swift.String?
    /// Replication Configuration Staging Area tags.
    public var stagingAreaTags: [Swift.String: Swift.String]?
    /// Replication Configuration use Dedicated Replication Server.
    public var useDedicatedReplicationServer: Swift.Bool?
    /// Replication Configuration use Fips Endpoint.
    public var useFipsEndpoint: Swift.Bool?

    public init(
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        replicatedDisks: [MgnClientTypes.ReplicationConfigurationReplicatedDisk]? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        sourceServerID: Swift.String? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String: Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil,
        useFipsEndpoint: Swift.Bool? = nil
    )
    {
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.name = name
        self.replicatedDisks = replicatedDisks
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.sourceServerID = sourceServerID
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
        self.useFipsEndpoint = useFipsEndpoint
    }
}

extension GetReplicationConfigurationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetReplicationConfigurationOutput(associateDefaultSecurityGroup: \(Swift.String(describing: associateDefaultSecurityGroup)), bandwidthThrottling: \(Swift.String(describing: bandwidthThrottling)), createPublicIP: \(Swift.String(describing: createPublicIP)), dataPlaneRouting: \(Swift.String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(Swift.String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(Swift.String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(Swift.String(describing: ebsEncryptionKeyArn)), name: \(Swift.String(describing: name)), replicatedDisks: \(Swift.String(describing: replicatedDisks)), replicationServerInstanceType: \(Swift.String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(Swift.String(describing: replicationServersSecurityGroupsIDs)), sourceServerID: \(Swift.String(describing: sourceServerID)), stagingAreaSubnetId: \(Swift.String(describing: stagingAreaSubnetId)), useDedicatedReplicationServer: \(Swift.String(describing: useDedicatedReplicationServer)), useFipsEndpoint: \(Swift.String(describing: useFipsEndpoint)), stagingAreaTags: \"CONTENT_REDACTED\")"}
}

extension MgnClientTypes {
    /// Source server post migration custom action filters.
    public struct SourceServerActionsRequestFilters {
        /// Action IDs to filter source server post migration custom actions by.
        public var actionIDs: [Swift.String]?

        public init(
            actionIDs: [Swift.String]? = nil
        )
        {
            self.actionIDs = actionIDs
        }
    }

}

public struct ListSourceServerActionsInput {
    /// Account ID to return when listing source server post migration custom actions.
    public var accountID: Swift.String?
    /// Filters to apply when listing source server post migration custom actions.
    public var filters: MgnClientTypes.SourceServerActionsRequestFilters?
    /// Maximum amount of items to return when listing source server post migration custom actions.
    public var maxResults: Swift.Int?
    /// Next token to use when listing source server post migration custom actions.
    public var nextToken: Swift.String?
    /// Source server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        filters: MgnClientTypes.SourceServerActionsRequestFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sourceServerID = sourceServerID
    }
}

extension MgnClientTypes {
    public struct SourceServerActionDocument {
        /// Source server post migration custom action ID.
        public var actionID: Swift.String?
        /// Source server post migration custom action name.
        public var actionName: Swift.String?
        /// Source server post migration custom action active status.
        public var active: Swift.Bool?
        /// Source server post migration custom action category.
        public var category: MgnClientTypes.ActionCategory?
        /// Source server post migration custom action description.
        public var description: Swift.String?
        /// Source server post migration custom action document identifier.
        public var documentIdentifier: Swift.String?
        /// Source server post migration custom action document version.
        public var documentVersion: Swift.String?
        /// Source server post migration custom action external parameters.
        public var externalParameters: [Swift.String: MgnClientTypes.SsmExternalParameter]?
        /// Source server post migration custom action must succeed for cutover.
        public var mustSucceedForCutover: Swift.Bool?
        /// Source server post migration custom action order.
        public var order: Swift.Int?
        /// Source server post migration custom action parameters.
        public var parameters: [Swift.String: [MgnClientTypes.SsmParameterStoreParameter]]?
        /// Source server post migration custom action timeout in seconds.
        public var timeoutSeconds: Swift.Int?

        public init(
            actionID: Swift.String? = nil,
            actionName: Swift.String? = nil,
            active: Swift.Bool? = nil,
            category: MgnClientTypes.ActionCategory? = nil,
            description: Swift.String? = nil,
            documentIdentifier: Swift.String? = nil,
            documentVersion: Swift.String? = nil,
            externalParameters: [Swift.String: MgnClientTypes.SsmExternalParameter]? = nil,
            mustSucceedForCutover: Swift.Bool? = nil,
            order: Swift.Int? = nil,
            parameters: [Swift.String: [MgnClientTypes.SsmParameterStoreParameter]]? = nil,
            timeoutSeconds: Swift.Int? = nil
        )
        {
            self.actionID = actionID
            self.actionName = actionName
            self.active = active
            self.category = category
            self.description = description
            self.documentIdentifier = documentIdentifier
            self.documentVersion = documentVersion
            self.externalParameters = externalParameters
            self.mustSucceedForCutover = mustSucceedForCutover
            self.order = order
            self.parameters = parameters
            self.timeoutSeconds = timeoutSeconds
        }
    }

}

public struct ListSourceServerActionsOutput {
    /// List of source server post migration custom actions.
    public var items: [MgnClientTypes.SourceServerActionDocument]?
    /// Next token returned when listing source server post migration custom actions.
    public var nextToken: Swift.String?

    public init(
        items: [MgnClientTypes.SourceServerActionDocument]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct MarkAsArchivedInput {
    /// Mark as archived by Account ID.
    public var accountID: Swift.String?
    /// Mark as archived by Source Server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.sourceServerID = sourceServerID
    }
}

public struct MarkAsArchivedOutput {
    /// Source server application ID.
    public var applicationID: Swift.String?
    /// Source server ARN.
    public var arn: Swift.String?
    /// Source Server connector action.
    public var connectorAction: MgnClientTypes.SourceServerConnectorAction?
    /// Source server data replication info.
    public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    /// Source server fqdn for action framework.
    public var fqdnForActionFramework: Swift.String?
    /// Source server archived status.
    public var isArchived: Swift.Bool?
    /// Source server launched instance.
    public var launchedInstance: MgnClientTypes.LaunchedInstance?
    /// Source server lifecycle state.
    public var lifeCycle: MgnClientTypes.LifeCycle?
    /// Source server replication type.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// Source server properties.
    public var sourceProperties: MgnClientTypes.SourceProperties?
    /// Source server ID.
    public var sourceServerID: Swift.String?
    /// Source server Tags.
    public var tags: [Swift.String: Swift.String]?
    /// Source server user provided ID.
    public var userProvidedID: Swift.String?
    /// Source server vCenter client id.
    public var vcenterClientID: Swift.String?

    public init(
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        connectorAction: MgnClientTypes.SourceServerConnectorAction? = nil,
        dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
        fqdnForActionFramework: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
        lifeCycle: MgnClientTypes.LifeCycle? = nil,
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceProperties: MgnClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        userProvidedID: Swift.String? = nil,
        vcenterClientID: Swift.String? = nil
    )
    {
        self.applicationID = applicationID
        self.arn = arn
        self.connectorAction = connectorAction
        self.dataReplicationInfo = dataReplicationInfo
        self.fqdnForActionFramework = fqdnForActionFramework
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.replicationType = replicationType
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
        self.userProvidedID = userProvidedID
        self.vcenterClientID = vcenterClientID
    }
}

extension MarkAsArchivedOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MarkAsArchivedOutput(applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), connectorAction: \(Swift.String(describing: connectorAction)), dataReplicationInfo: \(Swift.String(describing: dataReplicationInfo)), fqdnForActionFramework: \(Swift.String(describing: fqdnForActionFramework)), isArchived: \(Swift.String(describing: isArchived)), launchedInstance: \(Swift.String(describing: launchedInstance)), lifeCycle: \(Swift.String(describing: lifeCycle)), replicationType: \(Swift.String(describing: replicationType)), sourceProperties: \(Swift.String(describing: sourceProperties)), sourceServerID: \(Swift.String(describing: sourceServerID)), userProvidedID: \(Swift.String(describing: userProvidedID)), vcenterClientID: \(Swift.String(describing: vcenterClientID)), tags: \"CONTENT_REDACTED\")"}
}

public struct PauseReplicationInput {
    /// Pause Replication Request account ID.
    public var accountID: Swift.String?
    /// Pause Replication Request source server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.sourceServerID = sourceServerID
    }
}

public struct PauseReplicationOutput {
    /// Source server application ID.
    public var applicationID: Swift.String?
    /// Source server ARN.
    public var arn: Swift.String?
    /// Source Server connector action.
    public var connectorAction: MgnClientTypes.SourceServerConnectorAction?
    /// Source server data replication info.
    public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    /// Source server fqdn for action framework.
    public var fqdnForActionFramework: Swift.String?
    /// Source server archived status.
    public var isArchived: Swift.Bool?
    /// Source server launched instance.
    public var launchedInstance: MgnClientTypes.LaunchedInstance?
    /// Source server lifecycle state.
    public var lifeCycle: MgnClientTypes.LifeCycle?
    /// Source server replication type.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// Source server properties.
    public var sourceProperties: MgnClientTypes.SourceProperties?
    /// Source server ID.
    public var sourceServerID: Swift.String?
    /// Source server Tags.
    public var tags: [Swift.String: Swift.String]?
    /// Source server user provided ID.
    public var userProvidedID: Swift.String?
    /// Source server vCenter client id.
    public var vcenterClientID: Swift.String?

    public init(
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        connectorAction: MgnClientTypes.SourceServerConnectorAction? = nil,
        dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
        fqdnForActionFramework: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
        lifeCycle: MgnClientTypes.LifeCycle? = nil,
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceProperties: MgnClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        userProvidedID: Swift.String? = nil,
        vcenterClientID: Swift.String? = nil
    )
    {
        self.applicationID = applicationID
        self.arn = arn
        self.connectorAction = connectorAction
        self.dataReplicationInfo = dataReplicationInfo
        self.fqdnForActionFramework = fqdnForActionFramework
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.replicationType = replicationType
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
        self.userProvidedID = userProvidedID
        self.vcenterClientID = vcenterClientID
    }
}

extension PauseReplicationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PauseReplicationOutput(applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), connectorAction: \(Swift.String(describing: connectorAction)), dataReplicationInfo: \(Swift.String(describing: dataReplicationInfo)), fqdnForActionFramework: \(Swift.String(describing: fqdnForActionFramework)), isArchived: \(Swift.String(describing: isArchived)), launchedInstance: \(Swift.String(describing: launchedInstance)), lifeCycle: \(Swift.String(describing: lifeCycle)), replicationType: \(Swift.String(describing: replicationType)), sourceProperties: \(Swift.String(describing: sourceProperties)), sourceServerID: \(Swift.String(describing: sourceServerID)), userProvidedID: \(Swift.String(describing: userProvidedID)), vcenterClientID: \(Swift.String(describing: vcenterClientID)), tags: \"CONTENT_REDACTED\")"}
}

public struct PutSourceServerActionInput {
    /// Source server post migration custom account ID.
    public var accountID: Swift.String?
    /// Source server post migration custom action ID.
    /// This member is required.
    public var actionID: Swift.String?
    /// Source server post migration custom action name.
    /// This member is required.
    public var actionName: Swift.String?
    /// Source server post migration custom action active status.
    public var active: Swift.Bool?
    /// Source server post migration custom action category.
    public var category: MgnClientTypes.ActionCategory?
    /// Source server post migration custom action description.
    public var description: Swift.String?
    /// Source server post migration custom action document identifier.
    /// This member is required.
    public var documentIdentifier: Swift.String?
    /// Source server post migration custom action document version.
    public var documentVersion: Swift.String?
    /// Source server post migration custom action external parameters.
    public var externalParameters: [Swift.String: MgnClientTypes.SsmExternalParameter]?
    /// Source server post migration custom action must succeed for cutover.
    public var mustSucceedForCutover: Swift.Bool?
    /// Source server post migration custom action order.
    /// This member is required.
    public var order: Swift.Int?
    /// Source server post migration custom action parameters.
    public var parameters: [Swift.String: [MgnClientTypes.SsmParameterStoreParameter]]?
    /// Source server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?
    /// Source server post migration custom action timeout in seconds.
    public var timeoutSeconds: Swift.Int?

    public init(
        accountID: Swift.String? = nil,
        actionID: Swift.String? = nil,
        actionName: Swift.String? = nil,
        active: Swift.Bool? = nil,
        category: MgnClientTypes.ActionCategory? = nil,
        description: Swift.String? = nil,
        documentIdentifier: Swift.String? = nil,
        documentVersion: Swift.String? = nil,
        externalParameters: [Swift.String: MgnClientTypes.SsmExternalParameter]? = nil,
        mustSucceedForCutover: Swift.Bool? = nil,
        order: Swift.Int? = nil,
        parameters: [Swift.String: [MgnClientTypes.SsmParameterStoreParameter]]? = nil,
        sourceServerID: Swift.String? = nil,
        timeoutSeconds: Swift.Int? = nil
    )
    {
        self.accountID = accountID
        self.actionID = actionID
        self.actionName = actionName
        self.active = active
        self.category = category
        self.description = description
        self.documentIdentifier = documentIdentifier
        self.documentVersion = documentVersion
        self.externalParameters = externalParameters
        self.mustSucceedForCutover = mustSucceedForCutover
        self.order = order
        self.parameters = parameters
        self.sourceServerID = sourceServerID
        self.timeoutSeconds = timeoutSeconds
    }
}

public struct PutSourceServerActionOutput {
    /// Source server post migration custom action ID.
    public var actionID: Swift.String?
    /// Source server post migration custom action name.
    public var actionName: Swift.String?
    /// Source server post migration custom action active status.
    public var active: Swift.Bool?
    /// Source server post migration custom action category.
    public var category: MgnClientTypes.ActionCategory?
    /// Source server post migration custom action description.
    public var description: Swift.String?
    /// Source server post migration custom action document identifier.
    public var documentIdentifier: Swift.String?
    /// Source server post migration custom action document version.
    public var documentVersion: Swift.String?
    /// Source server post migration custom action external parameters.
    public var externalParameters: [Swift.String: MgnClientTypes.SsmExternalParameter]?
    /// Source server post migration custom action must succeed for cutover.
    public var mustSucceedForCutover: Swift.Bool?
    /// Source server post migration custom action order.
    public var order: Swift.Int?
    /// Source server post migration custom action parameters.
    public var parameters: [Swift.String: [MgnClientTypes.SsmParameterStoreParameter]]?
    /// Source server post migration custom action timeout in seconds.
    public var timeoutSeconds: Swift.Int?

    public init(
        actionID: Swift.String? = nil,
        actionName: Swift.String? = nil,
        active: Swift.Bool? = nil,
        category: MgnClientTypes.ActionCategory? = nil,
        description: Swift.String? = nil,
        documentIdentifier: Swift.String? = nil,
        documentVersion: Swift.String? = nil,
        externalParameters: [Swift.String: MgnClientTypes.SsmExternalParameter]? = nil,
        mustSucceedForCutover: Swift.Bool? = nil,
        order: Swift.Int? = nil,
        parameters: [Swift.String: [MgnClientTypes.SsmParameterStoreParameter]]? = nil,
        timeoutSeconds: Swift.Int? = nil
    )
    {
        self.actionID = actionID
        self.actionName = actionName
        self.active = active
        self.category = category
        self.description = description
        self.documentIdentifier = documentIdentifier
        self.documentVersion = documentVersion
        self.externalParameters = externalParameters
        self.mustSucceedForCutover = mustSucceedForCutover
        self.order = order
        self.parameters = parameters
        self.timeoutSeconds = timeoutSeconds
    }
}

public struct RemoveSourceServerActionInput {
    /// Source server post migration account ID.
    public var accountID: Swift.String?
    /// Source server post migration custom action ID to remove.
    /// This member is required.
    public var actionID: Swift.String?
    /// Source server ID of the post migration custom action to remove.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        actionID: Swift.String? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.actionID = actionID
        self.sourceServerID = sourceServerID
    }
}

public struct RemoveSourceServerActionOutput {

    public init() { }
}

public struct ResumeReplicationInput {
    /// Resume Replication Request account ID.
    public var accountID: Swift.String?
    /// Resume Replication Request source server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.sourceServerID = sourceServerID
    }
}

public struct ResumeReplicationOutput {
    /// Source server application ID.
    public var applicationID: Swift.String?
    /// Source server ARN.
    public var arn: Swift.String?
    /// Source Server connector action.
    public var connectorAction: MgnClientTypes.SourceServerConnectorAction?
    /// Source server data replication info.
    public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    /// Source server fqdn for action framework.
    public var fqdnForActionFramework: Swift.String?
    /// Source server archived status.
    public var isArchived: Swift.Bool?
    /// Source server launched instance.
    public var launchedInstance: MgnClientTypes.LaunchedInstance?
    /// Source server lifecycle state.
    public var lifeCycle: MgnClientTypes.LifeCycle?
    /// Source server replication type.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// Source server properties.
    public var sourceProperties: MgnClientTypes.SourceProperties?
    /// Source server ID.
    public var sourceServerID: Swift.String?
    /// Source server Tags.
    public var tags: [Swift.String: Swift.String]?
    /// Source server user provided ID.
    public var userProvidedID: Swift.String?
    /// Source server vCenter client id.
    public var vcenterClientID: Swift.String?

    public init(
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        connectorAction: MgnClientTypes.SourceServerConnectorAction? = nil,
        dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
        fqdnForActionFramework: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
        lifeCycle: MgnClientTypes.LifeCycle? = nil,
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceProperties: MgnClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        userProvidedID: Swift.String? = nil,
        vcenterClientID: Swift.String? = nil
    )
    {
        self.applicationID = applicationID
        self.arn = arn
        self.connectorAction = connectorAction
        self.dataReplicationInfo = dataReplicationInfo
        self.fqdnForActionFramework = fqdnForActionFramework
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.replicationType = replicationType
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
        self.userProvidedID = userProvidedID
        self.vcenterClientID = vcenterClientID
    }
}

extension ResumeReplicationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResumeReplicationOutput(applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), connectorAction: \(Swift.String(describing: connectorAction)), dataReplicationInfo: \(Swift.String(describing: dataReplicationInfo)), fqdnForActionFramework: \(Swift.String(describing: fqdnForActionFramework)), isArchived: \(Swift.String(describing: isArchived)), launchedInstance: \(Swift.String(describing: launchedInstance)), lifeCycle: \(Swift.String(describing: lifeCycle)), replicationType: \(Swift.String(describing: replicationType)), sourceProperties: \(Swift.String(describing: sourceProperties)), sourceServerID: \(Swift.String(describing: sourceServerID)), userProvidedID: \(Swift.String(describing: userProvidedID)), vcenterClientID: \(Swift.String(describing: vcenterClientID)), tags: \"CONTENT_REDACTED\")"}
}

public struct RetryDataReplicationInput {
    /// Retry data replication for Account ID.
    public var accountID: Swift.String?
    /// Retry data replication for Source Server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.sourceServerID = sourceServerID
    }
}

public struct RetryDataReplicationOutput {
    /// Source server application ID.
    public var applicationID: Swift.String?
    /// Source server ARN.
    public var arn: Swift.String?
    /// Source Server connector action.
    public var connectorAction: MgnClientTypes.SourceServerConnectorAction?
    /// Source server data replication info.
    public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    /// Source server fqdn for action framework.
    public var fqdnForActionFramework: Swift.String?
    /// Source server archived status.
    public var isArchived: Swift.Bool?
    /// Source server launched instance.
    public var launchedInstance: MgnClientTypes.LaunchedInstance?
    /// Source server lifecycle state.
    public var lifeCycle: MgnClientTypes.LifeCycle?
    /// Source server replication type.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// Source server properties.
    public var sourceProperties: MgnClientTypes.SourceProperties?
    /// Source server ID.
    public var sourceServerID: Swift.String?
    /// Source server Tags.
    public var tags: [Swift.String: Swift.String]?
    /// Source server user provided ID.
    public var userProvidedID: Swift.String?
    /// Source server vCenter client id.
    public var vcenterClientID: Swift.String?

    public init(
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        connectorAction: MgnClientTypes.SourceServerConnectorAction? = nil,
        dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
        fqdnForActionFramework: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
        lifeCycle: MgnClientTypes.LifeCycle? = nil,
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceProperties: MgnClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        userProvidedID: Swift.String? = nil,
        vcenterClientID: Swift.String? = nil
    )
    {
        self.applicationID = applicationID
        self.arn = arn
        self.connectorAction = connectorAction
        self.dataReplicationInfo = dataReplicationInfo
        self.fqdnForActionFramework = fqdnForActionFramework
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.replicationType = replicationType
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
        self.userProvidedID = userProvidedID
        self.vcenterClientID = vcenterClientID
    }
}

extension RetryDataReplicationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RetryDataReplicationOutput(applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), connectorAction: \(Swift.String(describing: connectorAction)), dataReplicationInfo: \(Swift.String(describing: dataReplicationInfo)), fqdnForActionFramework: \(Swift.String(describing: fqdnForActionFramework)), isArchived: \(Swift.String(describing: isArchived)), launchedInstance: \(Swift.String(describing: launchedInstance)), lifeCycle: \(Swift.String(describing: lifeCycle)), replicationType: \(Swift.String(describing: replicationType)), sourceProperties: \(Swift.String(describing: sourceProperties)), sourceServerID: \(Swift.String(describing: sourceServerID)), userProvidedID: \(Swift.String(describing: userProvidedID)), vcenterClientID: \(Swift.String(describing: vcenterClientID)), tags: \"CONTENT_REDACTED\")"}
}

public struct StartCutoverInput {
    /// Start Cutover by Account IDs
    public var accountID: Swift.String?
    /// Start Cutover by Source Server IDs.
    /// This member is required.
    public var sourceServerIDs: [Swift.String]?
    /// Start Cutover by Tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        accountID: Swift.String? = nil,
        sourceServerIDs: [Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.accountID = accountID
        self.sourceServerIDs = sourceServerIDs
        self.tags = tags
    }
}

extension StartCutoverInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartCutoverInput(accountID: \(Swift.String(describing: accountID)), sourceServerIDs: \(Swift.String(describing: sourceServerIDs)), tags: \"CONTENT_REDACTED\")"}
}

public struct StartCutoverOutput {
    /// Start Cutover Job response.
    public var job: MgnClientTypes.Job?

    public init(
        job: MgnClientTypes.Job? = nil
    )
    {
        self.job = job
    }
}

public struct StartReplicationInput {
    /// Account ID on which to start replication.
    public var accountID: Swift.String?
    /// ID of source server on which to start replication.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.sourceServerID = sourceServerID
    }
}

public struct StartReplicationOutput {
    /// Source server application ID.
    public var applicationID: Swift.String?
    /// Source server ARN.
    public var arn: Swift.String?
    /// Source Server connector action.
    public var connectorAction: MgnClientTypes.SourceServerConnectorAction?
    /// Source server data replication info.
    public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    /// Source server fqdn for action framework.
    public var fqdnForActionFramework: Swift.String?
    /// Source server archived status.
    public var isArchived: Swift.Bool?
    /// Source server launched instance.
    public var launchedInstance: MgnClientTypes.LaunchedInstance?
    /// Source server lifecycle state.
    public var lifeCycle: MgnClientTypes.LifeCycle?
    /// Source server replication type.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// Source server properties.
    public var sourceProperties: MgnClientTypes.SourceProperties?
    /// Source server ID.
    public var sourceServerID: Swift.String?
    /// Source server Tags.
    public var tags: [Swift.String: Swift.String]?
    /// Source server user provided ID.
    public var userProvidedID: Swift.String?
    /// Source server vCenter client id.
    public var vcenterClientID: Swift.String?

    public init(
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        connectorAction: MgnClientTypes.SourceServerConnectorAction? = nil,
        dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
        fqdnForActionFramework: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
        lifeCycle: MgnClientTypes.LifeCycle? = nil,
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceProperties: MgnClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        userProvidedID: Swift.String? = nil,
        vcenterClientID: Swift.String? = nil
    )
    {
        self.applicationID = applicationID
        self.arn = arn
        self.connectorAction = connectorAction
        self.dataReplicationInfo = dataReplicationInfo
        self.fqdnForActionFramework = fqdnForActionFramework
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.replicationType = replicationType
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
        self.userProvidedID = userProvidedID
        self.vcenterClientID = vcenterClientID
    }
}

extension StartReplicationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartReplicationOutput(applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), connectorAction: \(Swift.String(describing: connectorAction)), dataReplicationInfo: \(Swift.String(describing: dataReplicationInfo)), fqdnForActionFramework: \(Swift.String(describing: fqdnForActionFramework)), isArchived: \(Swift.String(describing: isArchived)), launchedInstance: \(Swift.String(describing: launchedInstance)), lifeCycle: \(Swift.String(describing: lifeCycle)), replicationType: \(Swift.String(describing: replicationType)), sourceProperties: \(Swift.String(describing: sourceProperties)), sourceServerID: \(Swift.String(describing: sourceServerID)), userProvidedID: \(Swift.String(describing: userProvidedID)), vcenterClientID: \(Swift.String(describing: vcenterClientID)), tags: \"CONTENT_REDACTED\")"}
}

public struct StartTestInput {
    /// Start Test for Account ID.
    public var accountID: Swift.String?
    /// Start Test for Source Server IDs.
    /// This member is required.
    public var sourceServerIDs: [Swift.String]?
    /// Start Test by Tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        accountID: Swift.String? = nil,
        sourceServerIDs: [Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.accountID = accountID
        self.sourceServerIDs = sourceServerIDs
        self.tags = tags
    }
}

extension StartTestInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartTestInput(accountID: \(Swift.String(describing: accountID)), sourceServerIDs: \(Swift.String(describing: sourceServerIDs)), tags: \"CONTENT_REDACTED\")"}
}

public struct StartTestOutput {
    /// Start Test Job response.
    public var job: MgnClientTypes.Job?

    public init(
        job: MgnClientTypes.Job? = nil
    )
    {
        self.job = job
    }
}

public struct StopReplicationInput {
    /// Stop Replication Request account ID.
    public var accountID: Swift.String?
    /// Stop Replication Request source server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.sourceServerID = sourceServerID
    }
}

public struct StopReplicationOutput {
    /// Source server application ID.
    public var applicationID: Swift.String?
    /// Source server ARN.
    public var arn: Swift.String?
    /// Source Server connector action.
    public var connectorAction: MgnClientTypes.SourceServerConnectorAction?
    /// Source server data replication info.
    public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    /// Source server fqdn for action framework.
    public var fqdnForActionFramework: Swift.String?
    /// Source server archived status.
    public var isArchived: Swift.Bool?
    /// Source server launched instance.
    public var launchedInstance: MgnClientTypes.LaunchedInstance?
    /// Source server lifecycle state.
    public var lifeCycle: MgnClientTypes.LifeCycle?
    /// Source server replication type.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// Source server properties.
    public var sourceProperties: MgnClientTypes.SourceProperties?
    /// Source server ID.
    public var sourceServerID: Swift.String?
    /// Source server Tags.
    public var tags: [Swift.String: Swift.String]?
    /// Source server user provided ID.
    public var userProvidedID: Swift.String?
    /// Source server vCenter client id.
    public var vcenterClientID: Swift.String?

    public init(
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        connectorAction: MgnClientTypes.SourceServerConnectorAction? = nil,
        dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
        fqdnForActionFramework: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
        lifeCycle: MgnClientTypes.LifeCycle? = nil,
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceProperties: MgnClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        userProvidedID: Swift.String? = nil,
        vcenterClientID: Swift.String? = nil
    )
    {
        self.applicationID = applicationID
        self.arn = arn
        self.connectorAction = connectorAction
        self.dataReplicationInfo = dataReplicationInfo
        self.fqdnForActionFramework = fqdnForActionFramework
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.replicationType = replicationType
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
        self.userProvidedID = userProvidedID
        self.vcenterClientID = vcenterClientID
    }
}

extension StopReplicationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopReplicationOutput(applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), connectorAction: \(Swift.String(describing: connectorAction)), dataReplicationInfo: \(Swift.String(describing: dataReplicationInfo)), fqdnForActionFramework: \(Swift.String(describing: fqdnForActionFramework)), isArchived: \(Swift.String(describing: isArchived)), launchedInstance: \(Swift.String(describing: launchedInstance)), lifeCycle: \(Swift.String(describing: lifeCycle)), replicationType: \(Swift.String(describing: replicationType)), sourceProperties: \(Swift.String(describing: sourceProperties)), sourceServerID: \(Swift.String(describing: sourceServerID)), userProvidedID: \(Swift.String(describing: userProvidedID)), vcenterClientID: \(Swift.String(describing: vcenterClientID)), tags: \"CONTENT_REDACTED\")"}
}

public struct TerminateTargetInstancesInput {
    /// Terminate Target instance by Account ID
    public var accountID: Swift.String?
    /// Terminate Target instance by Source Server IDs.
    /// This member is required.
    public var sourceServerIDs: [Swift.String]?
    /// Terminate Target instance by Tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        accountID: Swift.String? = nil,
        sourceServerIDs: [Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.accountID = accountID
        self.sourceServerIDs = sourceServerIDs
        self.tags = tags
    }
}

extension TerminateTargetInstancesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TerminateTargetInstancesInput(accountID: \(Swift.String(describing: accountID)), sourceServerIDs: \(Swift.String(describing: sourceServerIDs)), tags: \"CONTENT_REDACTED\")"}
}

public struct TerminateTargetInstancesOutput {
    /// Terminate Target instance Job response.
    public var job: MgnClientTypes.Job?

    public init(
        job: MgnClientTypes.Job? = nil
    )
    {
        self.job = job
    }
}

public struct UpdateLaunchConfigurationInput {
    /// Update Launch configuration Account ID.
    public var accountID: Swift.String?
    /// Update Launch configuration boot mode request.
    public var bootMode: MgnClientTypes.BootMode?
    /// Update Launch configuration copy Private IP request.
    public var copyPrivateIp: Swift.Bool?
    /// Update Launch configuration copy Tags request.
    public var copyTags: Swift.Bool?
    /// Enable map auto tagging.
    public var enableMapAutoTagging: Swift.Bool?
    /// Update Launch configuration launch disposition request.
    public var launchDisposition: MgnClientTypes.LaunchDisposition?
    /// Update Launch configuration licensing request.
    public var licensing: MgnClientTypes.Licensing?
    /// Launch configuration map auto tagging MPE ID.
    public var mapAutoTaggingMpeID: Swift.String?
    /// Update Launch configuration name request.
    public var name: Swift.String?
    /// Post Launch Actions to executed on the Test or Cutover instance.
    public var postLaunchActions: MgnClientTypes.PostLaunchActions?
    /// Update Launch configuration by Source Server ID request.
    /// This member is required.
    public var sourceServerID: Swift.String?
    /// Update Launch configuration Target instance right sizing request.
    public var targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?

    public init(
        accountID: Swift.String? = nil,
        bootMode: MgnClientTypes.BootMode? = nil,
        copyPrivateIp: Swift.Bool? = nil,
        copyTags: Swift.Bool? = nil,
        enableMapAutoTagging: Swift.Bool? = nil,
        launchDisposition: MgnClientTypes.LaunchDisposition? = nil,
        licensing: MgnClientTypes.Licensing? = nil,
        mapAutoTaggingMpeID: Swift.String? = nil,
        name: Swift.String? = nil,
        postLaunchActions: MgnClientTypes.PostLaunchActions? = nil,
        sourceServerID: Swift.String? = nil,
        targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod? = nil
    )
    {
        self.accountID = accountID
        self.bootMode = bootMode
        self.copyPrivateIp = copyPrivateIp
        self.copyTags = copyTags
        self.enableMapAutoTagging = enableMapAutoTagging
        self.launchDisposition = launchDisposition
        self.licensing = licensing
        self.mapAutoTaggingMpeID = mapAutoTaggingMpeID
        self.name = name
        self.postLaunchActions = postLaunchActions
        self.sourceServerID = sourceServerID
        self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
    }
}

public struct UpdateLaunchConfigurationOutput {
    /// Launch configuration boot mode.
    public var bootMode: MgnClientTypes.BootMode?
    /// Copy Private IP during Launch Configuration.
    public var copyPrivateIp: Swift.Bool?
    /// Copy Tags during Launch Configuration.
    public var copyTags: Swift.Bool?
    /// Launch configuration EC2 Launch template ID.
    public var ec2LaunchTemplateID: Swift.String?
    /// Enable map auto tagging.
    public var enableMapAutoTagging: Swift.Bool?
    /// Launch disposition for launch configuration.
    public var launchDisposition: MgnClientTypes.LaunchDisposition?
    /// Launch configuration OS licensing.
    public var licensing: MgnClientTypes.Licensing?
    /// Map auto tagging MPE ID.
    public var mapAutoTaggingMpeID: Swift.String?
    /// Launch configuration name.
    public var name: Swift.String?
    /// Post Launch Actions to executed on the Test or Cutover instance.
    public var postLaunchActions: MgnClientTypes.PostLaunchActions?
    /// Launch configuration Source Server ID.
    public var sourceServerID: Swift.String?
    /// Launch configuration Target instance type right sizing method.
    public var targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?

    public init(
        bootMode: MgnClientTypes.BootMode? = nil,
        copyPrivateIp: Swift.Bool? = nil,
        copyTags: Swift.Bool? = nil,
        ec2LaunchTemplateID: Swift.String? = nil,
        enableMapAutoTagging: Swift.Bool? = nil,
        launchDisposition: MgnClientTypes.LaunchDisposition? = nil,
        licensing: MgnClientTypes.Licensing? = nil,
        mapAutoTaggingMpeID: Swift.String? = nil,
        name: Swift.String? = nil,
        postLaunchActions: MgnClientTypes.PostLaunchActions? = nil,
        sourceServerID: Swift.String? = nil,
        targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod? = nil
    )
    {
        self.bootMode = bootMode
        self.copyPrivateIp = copyPrivateIp
        self.copyTags = copyTags
        self.ec2LaunchTemplateID = ec2LaunchTemplateID
        self.enableMapAutoTagging = enableMapAutoTagging
        self.launchDisposition = launchDisposition
        self.licensing = licensing
        self.mapAutoTaggingMpeID = mapAutoTaggingMpeID
        self.name = name
        self.postLaunchActions = postLaunchActions
        self.sourceServerID = sourceServerID
        self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
    }
}

public struct UpdateReplicationConfigurationInput {
    /// Update replication configuration Account ID request.
    public var accountID: Swift.String?
    /// Update replication configuration associate default Application Migration Service Security group request.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Update replication configuration bandwidth throttling request.
    public var bandwidthThrottling: Swift.Int
    /// Update replication configuration create Public IP request.
    public var createPublicIP: Swift.Bool?
    /// Update replication configuration data plane routing request.
    public var dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// Update replication configuration use default large Staging Disk type request.
    public var defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// Update replication configuration EBS encryption request.
    public var ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    /// Update replication configuration EBS encryption key ARN request.
    public var ebsEncryptionKeyArn: Swift.String?
    /// Update replication configuration name request.
    public var name: Swift.String?
    /// Update replication configuration replicated disks request.
    public var replicatedDisks: [MgnClientTypes.ReplicationConfigurationReplicatedDisk]?
    /// Update replication configuration Replication Server instance type request.
    public var replicationServerInstanceType: Swift.String?
    /// Update replication configuration Replication Server Security Groups IDs request.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// Update replication configuration Source Server ID request.
    /// This member is required.
    public var sourceServerID: Swift.String?
    /// Update replication configuration Staging Area subnet request.
    public var stagingAreaSubnetId: Swift.String?
    /// Update replication configuration Staging Area Tags request.
    public var stagingAreaTags: [Swift.String: Swift.String]?
    /// Update replication configuration use dedicated Replication Server request.
    public var useDedicatedReplicationServer: Swift.Bool?
    /// Update replication configuration use Fips Endpoint.
    public var useFipsEndpoint: Swift.Bool?

    public init(
        accountID: Swift.String? = nil,
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        replicatedDisks: [MgnClientTypes.ReplicationConfigurationReplicatedDisk]? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        sourceServerID: Swift.String? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String: Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil,
        useFipsEndpoint: Swift.Bool? = nil
    )
    {
        self.accountID = accountID
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.name = name
        self.replicatedDisks = replicatedDisks
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.sourceServerID = sourceServerID
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
        self.useFipsEndpoint = useFipsEndpoint
    }
}

extension UpdateReplicationConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateReplicationConfigurationInput(accountID: \(Swift.String(describing: accountID)), associateDefaultSecurityGroup: \(Swift.String(describing: associateDefaultSecurityGroup)), bandwidthThrottling: \(Swift.String(describing: bandwidthThrottling)), createPublicIP: \(Swift.String(describing: createPublicIP)), dataPlaneRouting: \(Swift.String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(Swift.String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(Swift.String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(Swift.String(describing: ebsEncryptionKeyArn)), name: \(Swift.String(describing: name)), replicatedDisks: \(Swift.String(describing: replicatedDisks)), replicationServerInstanceType: \(Swift.String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(Swift.String(describing: replicationServersSecurityGroupsIDs)), sourceServerID: \(Swift.String(describing: sourceServerID)), stagingAreaSubnetId: \(Swift.String(describing: stagingAreaSubnetId)), useDedicatedReplicationServer: \(Swift.String(describing: useDedicatedReplicationServer)), useFipsEndpoint: \(Swift.String(describing: useFipsEndpoint)), stagingAreaTags: \"CONTENT_REDACTED\")"}
}

public struct UpdateReplicationConfigurationOutput {
    /// Replication Configuration associate default Application Migration Service Security Group.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Replication Configuration set bandwidth throttling.
    public var bandwidthThrottling: Swift.Int
    /// Replication Configuration create Public IP.
    public var createPublicIP: Swift.Bool?
    /// Replication Configuration data plane routing.
    public var dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// Replication Configuration use default large Staging Disks.
    public var defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// Replication Configuration EBS encryption.
    public var ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    /// Replication Configuration EBS encryption key ARN.
    public var ebsEncryptionKeyArn: Swift.String?
    /// Replication Configuration name.
    public var name: Swift.String?
    /// Replication Configuration replicated disks.
    public var replicatedDisks: [MgnClientTypes.ReplicationConfigurationReplicatedDisk]?
    /// Replication Configuration Replication Server instance type.
    public var replicationServerInstanceType: Swift.String?
    /// Replication Configuration Replication Server Security Group IDs.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// Replication Configuration Source Server ID.
    public var sourceServerID: Swift.String?
    /// Replication Configuration Staging Area subnet ID.
    public var stagingAreaSubnetId: Swift.String?
    /// Replication Configuration Staging Area tags.
    public var stagingAreaTags: [Swift.String: Swift.String]?
    /// Replication Configuration use Dedicated Replication Server.
    public var useDedicatedReplicationServer: Swift.Bool?
    /// Replication Configuration use Fips Endpoint.
    public var useFipsEndpoint: Swift.Bool?

    public init(
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        replicatedDisks: [MgnClientTypes.ReplicationConfigurationReplicatedDisk]? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        sourceServerID: Swift.String? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String: Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil,
        useFipsEndpoint: Swift.Bool? = nil
    )
    {
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.name = name
        self.replicatedDisks = replicatedDisks
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.sourceServerID = sourceServerID
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
        self.useFipsEndpoint = useFipsEndpoint
    }
}

extension UpdateReplicationConfigurationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateReplicationConfigurationOutput(associateDefaultSecurityGroup: \(Swift.String(describing: associateDefaultSecurityGroup)), bandwidthThrottling: \(Swift.String(describing: bandwidthThrottling)), createPublicIP: \(Swift.String(describing: createPublicIP)), dataPlaneRouting: \(Swift.String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(Swift.String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(Swift.String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(Swift.String(describing: ebsEncryptionKeyArn)), name: \(Swift.String(describing: name)), replicatedDisks: \(Swift.String(describing: replicatedDisks)), replicationServerInstanceType: \(Swift.String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(Swift.String(describing: replicationServersSecurityGroupsIDs)), sourceServerID: \(Swift.String(describing: sourceServerID)), stagingAreaSubnetId: \(Swift.String(describing: stagingAreaSubnetId)), useDedicatedReplicationServer: \(Swift.String(describing: useDedicatedReplicationServer)), useFipsEndpoint: \(Swift.String(describing: useFipsEndpoint)), stagingAreaTags: \"CONTENT_REDACTED\")"}
}

public struct UpdateSourceServerInput {
    /// Update Source Server request account ID.
    public var accountID: Swift.String?
    /// Update Source Server request connector action.
    public var connectorAction: MgnClientTypes.SourceServerConnectorAction?
    /// Update Source Server request source server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        connectorAction: MgnClientTypes.SourceServerConnectorAction? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.connectorAction = connectorAction
        self.sourceServerID = sourceServerID
    }
}

public struct UpdateSourceServerOutput {
    /// Source server application ID.
    public var applicationID: Swift.String?
    /// Source server ARN.
    public var arn: Swift.String?
    /// Source Server connector action.
    public var connectorAction: MgnClientTypes.SourceServerConnectorAction?
    /// Source server data replication info.
    public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    /// Source server fqdn for action framework.
    public var fqdnForActionFramework: Swift.String?
    /// Source server archived status.
    public var isArchived: Swift.Bool?
    /// Source server launched instance.
    public var launchedInstance: MgnClientTypes.LaunchedInstance?
    /// Source server lifecycle state.
    public var lifeCycle: MgnClientTypes.LifeCycle?
    /// Source server replication type.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// Source server properties.
    public var sourceProperties: MgnClientTypes.SourceProperties?
    /// Source server ID.
    public var sourceServerID: Swift.String?
    /// Source server Tags.
    public var tags: [Swift.String: Swift.String]?
    /// Source server user provided ID.
    public var userProvidedID: Swift.String?
    /// Source server vCenter client id.
    public var vcenterClientID: Swift.String?

    public init(
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        connectorAction: MgnClientTypes.SourceServerConnectorAction? = nil,
        dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
        fqdnForActionFramework: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
        lifeCycle: MgnClientTypes.LifeCycle? = nil,
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceProperties: MgnClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        userProvidedID: Swift.String? = nil,
        vcenterClientID: Swift.String? = nil
    )
    {
        self.applicationID = applicationID
        self.arn = arn
        self.connectorAction = connectorAction
        self.dataReplicationInfo = dataReplicationInfo
        self.fqdnForActionFramework = fqdnForActionFramework
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.replicationType = replicationType
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
        self.userProvidedID = userProvidedID
        self.vcenterClientID = vcenterClientID
    }
}

extension UpdateSourceServerOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSourceServerOutput(applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), connectorAction: \(Swift.String(describing: connectorAction)), dataReplicationInfo: \(Swift.String(describing: dataReplicationInfo)), fqdnForActionFramework: \(Swift.String(describing: fqdnForActionFramework)), isArchived: \(Swift.String(describing: isArchived)), launchedInstance: \(Swift.String(describing: launchedInstance)), lifeCycle: \(Swift.String(describing: lifeCycle)), replicationType: \(Swift.String(describing: replicationType)), sourceProperties: \(Swift.String(describing: sourceProperties)), sourceServerID: \(Swift.String(describing: sourceServerID)), userProvidedID: \(Swift.String(describing: userProvidedID)), vcenterClientID: \(Swift.String(describing: vcenterClientID)), tags: \"CONTENT_REDACTED\")"}
}

public struct UpdateSourceServerReplicationTypeInput {
    /// Account ID on which to update replication type.
    public var accountID: Swift.String?
    /// Replication type to which to update source server.
    /// This member is required.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// ID of source server on which to update replication type.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.replicationType = replicationType
        self.sourceServerID = sourceServerID
    }
}

public struct UpdateSourceServerReplicationTypeOutput {
    /// Source server application ID.
    public var applicationID: Swift.String?
    /// Source server ARN.
    public var arn: Swift.String?
    /// Source Server connector action.
    public var connectorAction: MgnClientTypes.SourceServerConnectorAction?
    /// Source server data replication info.
    public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    /// Source server fqdn for action framework.
    public var fqdnForActionFramework: Swift.String?
    /// Source server archived status.
    public var isArchived: Swift.Bool?
    /// Source server launched instance.
    public var launchedInstance: MgnClientTypes.LaunchedInstance?
    /// Source server lifecycle state.
    public var lifeCycle: MgnClientTypes.LifeCycle?
    /// Source server replication type.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// Source server properties.
    public var sourceProperties: MgnClientTypes.SourceProperties?
    /// Source server ID.
    public var sourceServerID: Swift.String?
    /// Source server Tags.
    public var tags: [Swift.String: Swift.String]?
    /// Source server user provided ID.
    public var userProvidedID: Swift.String?
    /// Source server vCenter client id.
    public var vcenterClientID: Swift.String?

    public init(
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        connectorAction: MgnClientTypes.SourceServerConnectorAction? = nil,
        dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
        fqdnForActionFramework: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
        lifeCycle: MgnClientTypes.LifeCycle? = nil,
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceProperties: MgnClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        userProvidedID: Swift.String? = nil,
        vcenterClientID: Swift.String? = nil
    )
    {
        self.applicationID = applicationID
        self.arn = arn
        self.connectorAction = connectorAction
        self.dataReplicationInfo = dataReplicationInfo
        self.fqdnForActionFramework = fqdnForActionFramework
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.replicationType = replicationType
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
        self.userProvidedID = userProvidedID
        self.vcenterClientID = vcenterClientID
    }
}

extension UpdateSourceServerReplicationTypeOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSourceServerReplicationTypeOutput(applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), connectorAction: \(Swift.String(describing: connectorAction)), dataReplicationInfo: \(Swift.String(describing: dataReplicationInfo)), fqdnForActionFramework: \(Swift.String(describing: fqdnForActionFramework)), isArchived: \(Swift.String(describing: isArchived)), launchedInstance: \(Swift.String(describing: launchedInstance)), lifeCycle: \(Swift.String(describing: lifeCycle)), replicationType: \(Swift.String(describing: replicationType)), sourceProperties: \(Swift.String(describing: sourceProperties)), sourceServerID: \(Swift.String(describing: sourceServerID)), userProvidedID: \(Swift.String(describing: userProvidedID)), vcenterClientID: \(Swift.String(describing: vcenterClientID)), tags: \"CONTENT_REDACTED\")"}
}

public struct TagResourceInput {
    /// Tag resource by ARN.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tag resource by Tags.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \"CONTENT_REDACTED\")"}
}

public struct UntagResourceInput {
    /// Untag resource by ARN.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Untag resource by Keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \"CONTENT_REDACTED\")"}
}

public struct DeleteVcenterClientInput {
    /// ID of resource to be deleted.
    /// This member is required.
    public var vcenterClientID: Swift.String?

    public init(
        vcenterClientID: Swift.String? = nil
    )
    {
        self.vcenterClientID = vcenterClientID
    }
}

public struct DescribeVcenterClientsInput {
    /// Maximum results to be returned in DescribeVcenterClients.
    public var maxResults: Swift.Int?
    /// Next pagination token to be provided for DescribeVcenterClients.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension MgnClientTypes {
    /// vCenter client.
    public struct VcenterClient {
        /// Arn of vCenter client.
        public var arn: Swift.String?
        /// Datacenter name of vCenter client.
        public var datacenterName: Swift.String?
        /// Hostname of vCenter client .
        public var hostname: Swift.String?
        /// Last seen time of vCenter client.
        public var lastSeenDatetime: Swift.String?
        /// Tags for Source Server of vCenter client.
        public var sourceServerTags: [Swift.String: Swift.String]?
        /// Tags for vCenter client.
        public var tags: [Swift.String: Swift.String]?
        /// ID of vCenter client.
        public var vcenterClientID: Swift.String?
        /// Vcenter UUID of vCenter client.
        public var vcenterUUID: Swift.String?

        public init(
            arn: Swift.String? = nil,
            datacenterName: Swift.String? = nil,
            hostname: Swift.String? = nil,
            lastSeenDatetime: Swift.String? = nil,
            sourceServerTags: [Swift.String: Swift.String]? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            vcenterClientID: Swift.String? = nil,
            vcenterUUID: Swift.String? = nil
        )
        {
            self.arn = arn
            self.datacenterName = datacenterName
            self.hostname = hostname
            self.lastSeenDatetime = lastSeenDatetime
            self.sourceServerTags = sourceServerTags
            self.tags = tags
            self.vcenterClientID = vcenterClientID
            self.vcenterUUID = vcenterUUID
        }
    }

}

extension MgnClientTypes.VcenterClient: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VcenterClient(arn: \(Swift.String(describing: arn)), datacenterName: \(Swift.String(describing: datacenterName)), hostname: \(Swift.String(describing: hostname)), lastSeenDatetime: \(Swift.String(describing: lastSeenDatetime)), vcenterClientID: \(Swift.String(describing: vcenterClientID)), vcenterUUID: \(Swift.String(describing: vcenterUUID)), sourceServerTags: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

public struct DescribeVcenterClientsOutput {
    /// List of items returned by DescribeVcenterClients.
    public var items: [MgnClientTypes.VcenterClient]?
    /// Next pagination token returned from DescribeVcenterClients.
    public var nextToken: Swift.String?

    public init(
        items: [MgnClientTypes.VcenterClient]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ArchiveWaveInput {
    /// Account ID.
    public var accountID: Swift.String?
    /// Wave ID.
    /// This member is required.
    public var waveID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        waveID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.waveID = waveID
    }
}

extension MgnClientTypes {

    public enum WaveHealthStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case error
        case healthy
        case lagging
        case sdkUnknown(Swift.String)

        public static var allCases: [WaveHealthStatus] {
            return [
                .error,
                .healthy,
                .lagging
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .healthy: return "HEALTHY"
            case .lagging: return "LAGGING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MgnClientTypes {

    public enum WaveProgressStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case inProgress
        case notStarted
        case sdkUnknown(Swift.String)

        public static var allCases: [WaveProgressStatus] {
            return [
                .completed,
                .inProgress,
                .notStarted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MgnClientTypes {
    /// Wave aggregated status.
    public struct WaveAggregatedStatus {
        /// Wave aggregated status health status.
        public var healthStatus: MgnClientTypes.WaveHealthStatus?
        /// Wave aggregated status last update dateTime.
        public var lastUpdateDateTime: Swift.String?
        /// Wave aggregated status progress status.
        public var progressStatus: MgnClientTypes.WaveProgressStatus?
        /// DateTime marking when the first source server in the wave started replication.
        public var replicationStartedDateTime: Swift.String?
        /// Wave aggregated status total applications amount.
        public var totalApplications: Swift.Int

        public init(
            healthStatus: MgnClientTypes.WaveHealthStatus? = nil,
            lastUpdateDateTime: Swift.String? = nil,
            progressStatus: MgnClientTypes.WaveProgressStatus? = nil,
            replicationStartedDateTime: Swift.String? = nil,
            totalApplications: Swift.Int = 0
        )
        {
            self.healthStatus = healthStatus
            self.lastUpdateDateTime = lastUpdateDateTime
            self.progressStatus = progressStatus
            self.replicationStartedDateTime = replicationStartedDateTime
            self.totalApplications = totalApplications
        }
    }

}

public struct ArchiveWaveOutput {
    /// Wave ARN.
    public var arn: Swift.String?
    /// Wave creation dateTime.
    public var creationDateTime: Swift.String?
    /// Wave description.
    public var description: Swift.String?
    /// Wave archival status.
    public var isArchived: Swift.Bool?
    /// Wave last modified dateTime.
    public var lastModifiedDateTime: Swift.String?
    /// Wave name.
    public var name: Swift.String?
    /// Wave tags.
    public var tags: [Swift.String: Swift.String]?
    /// Wave aggregated status.
    public var waveAggregatedStatus: MgnClientTypes.WaveAggregatedStatus?
    /// Wave ID.
    public var waveID: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationDateTime: Swift.String? = nil,
        description: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        lastModifiedDateTime: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        waveAggregatedStatus: MgnClientTypes.WaveAggregatedStatus? = nil,
        waveID: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.description = description
        self.isArchived = isArchived
        self.lastModifiedDateTime = lastModifiedDateTime
        self.name = name
        self.tags = tags
        self.waveAggregatedStatus = waveAggregatedStatus
        self.waveID = waveID
    }
}

extension ArchiveWaveOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ArchiveWaveOutput(arn: \(Swift.String(describing: arn)), creationDateTime: \(Swift.String(describing: creationDateTime)), description: \(Swift.String(describing: description)), isArchived: \(Swift.String(describing: isArchived)), lastModifiedDateTime: \(Swift.String(describing: lastModifiedDateTime)), name: \(Swift.String(describing: name)), waveAggregatedStatus: \(Swift.String(describing: waveAggregatedStatus)), waveID: \(Swift.String(describing: waveID)), tags: \"CONTENT_REDACTED\")"}
}

public struct AssociateApplicationsInput {
    /// Account ID.
    public var accountID: Swift.String?
    /// Application IDs list.
    /// This member is required.
    public var applicationIDs: [Swift.String]?
    /// Wave ID.
    /// This member is required.
    public var waveID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        applicationIDs: [Swift.String]? = nil,
        waveID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.applicationIDs = applicationIDs
        self.waveID = waveID
    }
}

public struct AssociateApplicationsOutput {

    public init() { }
}

public struct CreateWaveInput {
    /// Account ID.
    public var accountID: Swift.String?
    /// Wave description.
    public var description: Swift.String?
    /// Wave name.
    /// This member is required.
    public var name: Swift.String?
    /// Wave tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        accountID: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.accountID = accountID
        self.description = description
        self.name = name
        self.tags = tags
    }
}

extension CreateWaveInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWaveInput(accountID: \(Swift.String(describing: accountID)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), tags: \"CONTENT_REDACTED\")"}
}

public struct CreateWaveOutput {
    /// Wave ARN.
    public var arn: Swift.String?
    /// Wave creation dateTime.
    public var creationDateTime: Swift.String?
    /// Wave description.
    public var description: Swift.String?
    /// Wave archival status.
    public var isArchived: Swift.Bool?
    /// Wave last modified dateTime.
    public var lastModifiedDateTime: Swift.String?
    /// Wave name.
    public var name: Swift.String?
    /// Wave tags.
    public var tags: [Swift.String: Swift.String]?
    /// Wave aggregated status.
    public var waveAggregatedStatus: MgnClientTypes.WaveAggregatedStatus?
    /// Wave ID.
    public var waveID: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationDateTime: Swift.String? = nil,
        description: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        lastModifiedDateTime: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        waveAggregatedStatus: MgnClientTypes.WaveAggregatedStatus? = nil,
        waveID: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.description = description
        self.isArchived = isArchived
        self.lastModifiedDateTime = lastModifiedDateTime
        self.name = name
        self.tags = tags
        self.waveAggregatedStatus = waveAggregatedStatus
        self.waveID = waveID
    }
}

extension CreateWaveOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWaveOutput(arn: \(Swift.String(describing: arn)), creationDateTime: \(Swift.String(describing: creationDateTime)), description: \(Swift.String(describing: description)), isArchived: \(Swift.String(describing: isArchived)), lastModifiedDateTime: \(Swift.String(describing: lastModifiedDateTime)), name: \(Swift.String(describing: name)), waveAggregatedStatus: \(Swift.String(describing: waveAggregatedStatus)), waveID: \(Swift.String(describing: waveID)), tags: \"CONTENT_REDACTED\")"}
}

public struct DeleteWaveInput {
    /// Account ID.
    public var accountID: Swift.String?
    /// Wave ID.
    /// This member is required.
    public var waveID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        waveID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.waveID = waveID
    }
}

public struct DeleteWaveOutput {

    public init() { }
}

public struct DisassociateApplicationsInput {
    /// Account ID.
    public var accountID: Swift.String?
    /// Application IDs list.
    /// This member is required.
    public var applicationIDs: [Swift.String]?
    /// Wave ID.
    /// This member is required.
    public var waveID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        applicationIDs: [Swift.String]? = nil,
        waveID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.applicationIDs = applicationIDs
        self.waveID = waveID
    }
}

public struct DisassociateApplicationsOutput {

    public init() { }
}

extension MgnClientTypes {
    /// Waves list filters.
    public struct ListWavesRequestFilters {
        /// Filter waves list by archival status.
        public var isArchived: Swift.Bool?
        /// Filter waves list by wave ID.
        public var waveIDs: [Swift.String]?

        public init(
            isArchived: Swift.Bool? = nil,
            waveIDs: [Swift.String]? = nil
        )
        {
            self.isArchived = isArchived
            self.waveIDs = waveIDs
        }
    }

}

public struct ListWavesInput {
    /// Request account ID.
    public var accountID: Swift.String?
    /// Waves list filters.
    public var filters: MgnClientTypes.ListWavesRequestFilters?
    /// Maximum results to return when listing waves.
    public var maxResults: Swift.Int?
    /// Request next token.
    public var nextToken: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        filters: MgnClientTypes.ListWavesRequestFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension MgnClientTypes {
    public struct Wave {
        /// Wave ARN.
        public var arn: Swift.String?
        /// Wave creation dateTime.
        public var creationDateTime: Swift.String?
        /// Wave description.
        public var description: Swift.String?
        /// Wave archival status.
        public var isArchived: Swift.Bool?
        /// Wave last modified dateTime.
        public var lastModifiedDateTime: Swift.String?
        /// Wave name.
        public var name: Swift.String?
        /// Wave tags.
        public var tags: [Swift.String: Swift.String]?
        /// Wave aggregated status.
        public var waveAggregatedStatus: MgnClientTypes.WaveAggregatedStatus?
        /// Wave ID.
        public var waveID: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationDateTime: Swift.String? = nil,
            description: Swift.String? = nil,
            isArchived: Swift.Bool? = nil,
            lastModifiedDateTime: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            waveAggregatedStatus: MgnClientTypes.WaveAggregatedStatus? = nil,
            waveID: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.description = description
            self.isArchived = isArchived
            self.lastModifiedDateTime = lastModifiedDateTime
            self.name = name
            self.tags = tags
            self.waveAggregatedStatus = waveAggregatedStatus
            self.waveID = waveID
        }
    }

}

extension MgnClientTypes.Wave: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Wave(arn: \(Swift.String(describing: arn)), creationDateTime: \(Swift.String(describing: creationDateTime)), description: \(Swift.String(describing: description)), isArchived: \(Swift.String(describing: isArchived)), lastModifiedDateTime: \(Swift.String(describing: lastModifiedDateTime)), name: \(Swift.String(describing: name)), waveAggregatedStatus: \(Swift.String(describing: waveAggregatedStatus)), waveID: \(Swift.String(describing: waveID)), tags: \"CONTENT_REDACTED\")"}
}

public struct ListWavesOutput {
    /// Waves list.
    public var items: [MgnClientTypes.Wave]?
    /// Response next token.
    public var nextToken: Swift.String?

    public init(
        items: [MgnClientTypes.Wave]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct UnarchiveWaveInput {
    /// Account ID.
    public var accountID: Swift.String?
    /// Wave ID.
    /// This member is required.
    public var waveID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        waveID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.waveID = waveID
    }
}

public struct UnarchiveWaveOutput {
    /// Wave ARN.
    public var arn: Swift.String?
    /// Wave creation dateTime.
    public var creationDateTime: Swift.String?
    /// Wave description.
    public var description: Swift.String?
    /// Wave archival status.
    public var isArchived: Swift.Bool?
    /// Wave last modified dateTime.
    public var lastModifiedDateTime: Swift.String?
    /// Wave name.
    public var name: Swift.String?
    /// Wave tags.
    public var tags: [Swift.String: Swift.String]?
    /// Wave aggregated status.
    public var waveAggregatedStatus: MgnClientTypes.WaveAggregatedStatus?
    /// Wave ID.
    public var waveID: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationDateTime: Swift.String? = nil,
        description: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        lastModifiedDateTime: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        waveAggregatedStatus: MgnClientTypes.WaveAggregatedStatus? = nil,
        waveID: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.description = description
        self.isArchived = isArchived
        self.lastModifiedDateTime = lastModifiedDateTime
        self.name = name
        self.tags = tags
        self.waveAggregatedStatus = waveAggregatedStatus
        self.waveID = waveID
    }
}

extension UnarchiveWaveOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnarchiveWaveOutput(arn: \(Swift.String(describing: arn)), creationDateTime: \(Swift.String(describing: creationDateTime)), description: \(Swift.String(describing: description)), isArchived: \(Swift.String(describing: isArchived)), lastModifiedDateTime: \(Swift.String(describing: lastModifiedDateTime)), name: \(Swift.String(describing: name)), waveAggregatedStatus: \(Swift.String(describing: waveAggregatedStatus)), waveID: \(Swift.String(describing: waveID)), tags: \"CONTENT_REDACTED\")"}
}

public struct UpdateWaveInput {
    /// Account ID.
    public var accountID: Swift.String?
    /// Wave description.
    public var description: Swift.String?
    /// Wave name.
    public var name: Swift.String?
    /// Wave ID.
    /// This member is required.
    public var waveID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        waveID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.description = description
        self.name = name
        self.waveID = waveID
    }
}

public struct UpdateWaveOutput {
    /// Wave ARN.
    public var arn: Swift.String?
    /// Wave creation dateTime.
    public var creationDateTime: Swift.String?
    /// Wave description.
    public var description: Swift.String?
    /// Wave archival status.
    public var isArchived: Swift.Bool?
    /// Wave last modified dateTime.
    public var lastModifiedDateTime: Swift.String?
    /// Wave name.
    public var name: Swift.String?
    /// Wave tags.
    public var tags: [Swift.String: Swift.String]?
    /// Wave aggregated status.
    public var waveAggregatedStatus: MgnClientTypes.WaveAggregatedStatus?
    /// Wave ID.
    public var waveID: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationDateTime: Swift.String? = nil,
        description: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        lastModifiedDateTime: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        waveAggregatedStatus: MgnClientTypes.WaveAggregatedStatus? = nil,
        waveID: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.description = description
        self.isArchived = isArchived
        self.lastModifiedDateTime = lastModifiedDateTime
        self.name = name
        self.tags = tags
        self.waveAggregatedStatus = waveAggregatedStatus
        self.waveID = waveID
    }
}

extension UpdateWaveOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateWaveOutput(arn: \(Swift.String(describing: arn)), creationDateTime: \(Swift.String(describing: creationDateTime)), description: \(Swift.String(describing: description)), isArchived: \(Swift.String(describing: isArchived)), lastModifiedDateTime: \(Swift.String(describing: lastModifiedDateTime)), name: \(Swift.String(describing: name)), waveAggregatedStatus: \(Swift.String(describing: waveAggregatedStatus)), waveID: \(Swift.String(describing: waveID)), tags: \"CONTENT_REDACTED\")"}
}

extension ArchiveApplicationInput {

    static func urlPathProvider(_ value: ArchiveApplicationInput) -> Swift.String? {
        return "/ArchiveApplication"
    }
}

extension ArchiveWaveInput {

    static func urlPathProvider(_ value: ArchiveWaveInput) -> Swift.String? {
        return "/ArchiveWave"
    }
}

extension AssociateApplicationsInput {

    static func urlPathProvider(_ value: AssociateApplicationsInput) -> Swift.String? {
        return "/AssociateApplications"
    }
}

extension AssociateSourceServersInput {

    static func urlPathProvider(_ value: AssociateSourceServersInput) -> Swift.String? {
        return "/AssociateSourceServers"
    }
}

extension ChangeServerLifeCycleStateInput {

    static func urlPathProvider(_ value: ChangeServerLifeCycleStateInput) -> Swift.String? {
        return "/ChangeServerLifeCycleState"
    }
}

extension CreateApplicationInput {

    static func urlPathProvider(_ value: CreateApplicationInput) -> Swift.String? {
        return "/CreateApplication"
    }
}

extension CreateConnectorInput {

    static func urlPathProvider(_ value: CreateConnectorInput) -> Swift.String? {
        return "/CreateConnector"
    }
}

extension CreateLaunchConfigurationTemplateInput {

    static func urlPathProvider(_ value: CreateLaunchConfigurationTemplateInput) -> Swift.String? {
        return "/CreateLaunchConfigurationTemplate"
    }
}

extension CreateReplicationConfigurationTemplateInput {

    static func urlPathProvider(_ value: CreateReplicationConfigurationTemplateInput) -> Swift.String? {
        return "/CreateReplicationConfigurationTemplate"
    }
}

extension CreateWaveInput {

    static func urlPathProvider(_ value: CreateWaveInput) -> Swift.String? {
        return "/CreateWave"
    }
}

extension DeleteApplicationInput {

    static func urlPathProvider(_ value: DeleteApplicationInput) -> Swift.String? {
        return "/DeleteApplication"
    }
}

extension DeleteConnectorInput {

    static func urlPathProvider(_ value: DeleteConnectorInput) -> Swift.String? {
        return "/DeleteConnector"
    }
}

extension DeleteJobInput {

    static func urlPathProvider(_ value: DeleteJobInput) -> Swift.String? {
        return "/DeleteJob"
    }
}

extension DeleteLaunchConfigurationTemplateInput {

    static func urlPathProvider(_ value: DeleteLaunchConfigurationTemplateInput) -> Swift.String? {
        return "/DeleteLaunchConfigurationTemplate"
    }
}

extension DeleteReplicationConfigurationTemplateInput {

    static func urlPathProvider(_ value: DeleteReplicationConfigurationTemplateInput) -> Swift.String? {
        return "/DeleteReplicationConfigurationTemplate"
    }
}

extension DeleteSourceServerInput {

    static func urlPathProvider(_ value: DeleteSourceServerInput) -> Swift.String? {
        return "/DeleteSourceServer"
    }
}

extension DeleteVcenterClientInput {

    static func urlPathProvider(_ value: DeleteVcenterClientInput) -> Swift.String? {
        return "/DeleteVcenterClient"
    }
}

extension DeleteWaveInput {

    static func urlPathProvider(_ value: DeleteWaveInput) -> Swift.String? {
        return "/DeleteWave"
    }
}

extension DescribeJobLogItemsInput {

    static func urlPathProvider(_ value: DescribeJobLogItemsInput) -> Swift.String? {
        return "/DescribeJobLogItems"
    }
}

extension DescribeJobsInput {

    static func urlPathProvider(_ value: DescribeJobsInput) -> Swift.String? {
        return "/DescribeJobs"
    }
}

extension DescribeLaunchConfigurationTemplatesInput {

    static func urlPathProvider(_ value: DescribeLaunchConfigurationTemplatesInput) -> Swift.String? {
        return "/DescribeLaunchConfigurationTemplates"
    }
}

extension DescribeReplicationConfigurationTemplatesInput {

    static func urlPathProvider(_ value: DescribeReplicationConfigurationTemplatesInput) -> Swift.String? {
        return "/DescribeReplicationConfigurationTemplates"
    }
}

extension DescribeSourceServersInput {

    static func urlPathProvider(_ value: DescribeSourceServersInput) -> Swift.String? {
        return "/DescribeSourceServers"
    }
}

extension DescribeVcenterClientsInput {

    static func urlPathProvider(_ value: DescribeVcenterClientsInput) -> Swift.String? {
        return "/DescribeVcenterClients"
    }
}

extension DescribeVcenterClientsInput {

    static func queryItemProvider(_ value: DescribeVcenterClientsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension DisassociateApplicationsInput {

    static func urlPathProvider(_ value: DisassociateApplicationsInput) -> Swift.String? {
        return "/DisassociateApplications"
    }
}

extension DisassociateSourceServersInput {

    static func urlPathProvider(_ value: DisassociateSourceServersInput) -> Swift.String? {
        return "/DisassociateSourceServers"
    }
}

extension DisconnectFromServiceInput {

    static func urlPathProvider(_ value: DisconnectFromServiceInput) -> Swift.String? {
        return "/DisconnectFromService"
    }
}

extension FinalizeCutoverInput {

    static func urlPathProvider(_ value: FinalizeCutoverInput) -> Swift.String? {
        return "/FinalizeCutover"
    }
}

extension GetLaunchConfigurationInput {

    static func urlPathProvider(_ value: GetLaunchConfigurationInput) -> Swift.String? {
        return "/GetLaunchConfiguration"
    }
}

extension GetReplicationConfigurationInput {

    static func urlPathProvider(_ value: GetReplicationConfigurationInput) -> Swift.String? {
        return "/GetReplicationConfiguration"
    }
}

extension InitializeServiceInput {

    static func urlPathProvider(_ value: InitializeServiceInput) -> Swift.String? {
        return "/InitializeService"
    }
}

extension ListApplicationsInput {

    static func urlPathProvider(_ value: ListApplicationsInput) -> Swift.String? {
        return "/ListApplications"
    }
}

extension ListConnectorsInput {

    static func urlPathProvider(_ value: ListConnectorsInput) -> Swift.String? {
        return "/ListConnectors"
    }
}

extension ListExportErrorsInput {

    static func urlPathProvider(_ value: ListExportErrorsInput) -> Swift.String? {
        return "/ListExportErrors"
    }
}

extension ListExportsInput {

    static func urlPathProvider(_ value: ListExportsInput) -> Swift.String? {
        return "/ListExports"
    }
}

extension ListImportErrorsInput {

    static func urlPathProvider(_ value: ListImportErrorsInput) -> Swift.String? {
        return "/ListImportErrors"
    }
}

extension ListImportsInput {

    static func urlPathProvider(_ value: ListImportsInput) -> Swift.String? {
        return "/ListImports"
    }
}

extension ListManagedAccountsInput {

    static func urlPathProvider(_ value: ListManagedAccountsInput) -> Swift.String? {
        return "/ListManagedAccounts"
    }
}

extension ListSourceServerActionsInput {

    static func urlPathProvider(_ value: ListSourceServerActionsInput) -> Swift.String? {
        return "/ListSourceServerActions"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension ListTemplateActionsInput {

    static func urlPathProvider(_ value: ListTemplateActionsInput) -> Swift.String? {
        return "/ListTemplateActions"
    }
}

extension ListWavesInput {

    static func urlPathProvider(_ value: ListWavesInput) -> Swift.String? {
        return "/ListWaves"
    }
}

extension MarkAsArchivedInput {

    static func urlPathProvider(_ value: MarkAsArchivedInput) -> Swift.String? {
        return "/MarkAsArchived"
    }
}

extension PauseReplicationInput {

    static func urlPathProvider(_ value: PauseReplicationInput) -> Swift.String? {
        return "/PauseReplication"
    }
}

extension PutSourceServerActionInput {

    static func urlPathProvider(_ value: PutSourceServerActionInput) -> Swift.String? {
        return "/PutSourceServerAction"
    }
}

extension PutTemplateActionInput {

    static func urlPathProvider(_ value: PutTemplateActionInput) -> Swift.String? {
        return "/PutTemplateAction"
    }
}

extension RemoveSourceServerActionInput {

    static func urlPathProvider(_ value: RemoveSourceServerActionInput) -> Swift.String? {
        return "/RemoveSourceServerAction"
    }
}

extension RemoveTemplateActionInput {

    static func urlPathProvider(_ value: RemoveTemplateActionInput) -> Swift.String? {
        return "/RemoveTemplateAction"
    }
}

extension ResumeReplicationInput {

    static func urlPathProvider(_ value: ResumeReplicationInput) -> Swift.String? {
        return "/ResumeReplication"
    }
}

extension RetryDataReplicationInput {

    static func urlPathProvider(_ value: RetryDataReplicationInput) -> Swift.String? {
        return "/RetryDataReplication"
    }
}

extension StartCutoverInput {

    static func urlPathProvider(_ value: StartCutoverInput) -> Swift.String? {
        return "/StartCutover"
    }
}

extension StartExportInput {

    static func urlPathProvider(_ value: StartExportInput) -> Swift.String? {
        return "/StartExport"
    }
}

extension StartImportInput {

    static func urlPathProvider(_ value: StartImportInput) -> Swift.String? {
        return "/StartImport"
    }
}

extension StartReplicationInput {

    static func urlPathProvider(_ value: StartReplicationInput) -> Swift.String? {
        return "/StartReplication"
    }
}

extension StartTestInput {

    static func urlPathProvider(_ value: StartTestInput) -> Swift.String? {
        return "/StartTest"
    }
}

extension StopReplicationInput {

    static func urlPathProvider(_ value: StopReplicationInput) -> Swift.String? {
        return "/StopReplication"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension TerminateTargetInstancesInput {

    static func urlPathProvider(_ value: TerminateTargetInstancesInput) -> Swift.String? {
        return "/TerminateTargetInstances"
    }
}

extension UnarchiveApplicationInput {

    static func urlPathProvider(_ value: UnarchiveApplicationInput) -> Swift.String? {
        return "/UnarchiveApplication"
    }
}

extension UnarchiveWaveInput {

    static func urlPathProvider(_ value: UnarchiveWaveInput) -> Swift.String? {
        return "/UnarchiveWave"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateApplicationInput {

    static func urlPathProvider(_ value: UpdateApplicationInput) -> Swift.String? {
        return "/UpdateApplication"
    }
}

extension UpdateConnectorInput {

    static func urlPathProvider(_ value: UpdateConnectorInput) -> Swift.String? {
        return "/UpdateConnector"
    }
}

extension UpdateLaunchConfigurationInput {

    static func urlPathProvider(_ value: UpdateLaunchConfigurationInput) -> Swift.String? {
        return "/UpdateLaunchConfiguration"
    }
}

extension UpdateLaunchConfigurationTemplateInput {

    static func urlPathProvider(_ value: UpdateLaunchConfigurationTemplateInput) -> Swift.String? {
        return "/UpdateLaunchConfigurationTemplate"
    }
}

extension UpdateReplicationConfigurationInput {

    static func urlPathProvider(_ value: UpdateReplicationConfigurationInput) -> Swift.String? {
        return "/UpdateReplicationConfiguration"
    }
}

extension UpdateReplicationConfigurationTemplateInput {

    static func urlPathProvider(_ value: UpdateReplicationConfigurationTemplateInput) -> Swift.String? {
        return "/UpdateReplicationConfigurationTemplate"
    }
}

extension UpdateSourceServerInput {

    static func urlPathProvider(_ value: UpdateSourceServerInput) -> Swift.String? {
        return "/UpdateSourceServer"
    }
}

extension UpdateSourceServerReplicationTypeInput {

    static func urlPathProvider(_ value: UpdateSourceServerReplicationTypeInput) -> Swift.String? {
        return "/UpdateSourceServerReplicationType"
    }
}

extension UpdateWaveInput {

    static func urlPathProvider(_ value: UpdateWaveInput) -> Swift.String? {
        return "/UpdateWave"
    }
}

extension ArchiveApplicationInput {

    static func write(value: ArchiveApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["applicationID"].write(value.applicationID)
    }
}

extension ArchiveWaveInput {

    static func write(value: ArchiveWaveInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["waveID"].write(value.waveID)
    }
}

extension AssociateApplicationsInput {

    static func write(value: AssociateApplicationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["applicationIDs"].writeList(value.applicationIDs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["waveID"].write(value.waveID)
    }
}

extension AssociateSourceServersInput {

    static func write(value: AssociateSourceServersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["applicationID"].write(value.applicationID)
        try writer["sourceServerIDs"].writeList(value.sourceServerIDs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ChangeServerLifeCycleStateInput {

    static func write(value: ChangeServerLifeCycleStateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["lifeCycle"].write(value.lifeCycle, with: MgnClientTypes.ChangeServerLifeCycleStateSourceServerLifecycle.write(value:to:))
        try writer["sourceServerID"].write(value.sourceServerID)
    }
}

extension CreateApplicationInput {

    static func write(value: CreateApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateConnectorInput {

    static func write(value: CreateConnectorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["ssmCommandConfig"].write(value.ssmCommandConfig, with: MgnClientTypes.ConnectorSsmCommandConfig.write(value:to:))
        try writer["ssmInstanceID"].write(value.ssmInstanceID)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateLaunchConfigurationTemplateInput {

    static func write(value: CreateLaunchConfigurationTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["associatePublicIpAddress"].write(value.associatePublicIpAddress)
        try writer["bootMode"].write(value.bootMode)
        try writer["copyPrivateIp"].write(value.copyPrivateIp)
        try writer["copyTags"].write(value.copyTags)
        try writer["enableMapAutoTagging"].write(value.enableMapAutoTagging)
        try writer["largeVolumeConf"].write(value.largeVolumeConf, with: MgnClientTypes.LaunchTemplateDiskConf.write(value:to:))
        try writer["launchDisposition"].write(value.launchDisposition)
        try writer["licensing"].write(value.licensing, with: MgnClientTypes.Licensing.write(value:to:))
        try writer["mapAutoTaggingMpeID"].write(value.mapAutoTaggingMpeID)
        try writer["postLaunchActions"].write(value.postLaunchActions, with: MgnClientTypes.PostLaunchActions.write(value:to:))
        try writer["smallVolumeConf"].write(value.smallVolumeConf, with: MgnClientTypes.LaunchTemplateDiskConf.write(value:to:))
        try writer["smallVolumeMaxSize"].write(value.smallVolumeMaxSize)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["targetInstanceTypeRightSizingMethod"].write(value.targetInstanceTypeRightSizingMethod)
    }
}

extension CreateReplicationConfigurationTemplateInput {

    static func write(value: CreateReplicationConfigurationTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["associateDefaultSecurityGroup"].write(value.associateDefaultSecurityGroup)
        try writer["bandwidthThrottling"].write(value.bandwidthThrottling)
        try writer["createPublicIP"].write(value.createPublicIP)
        try writer["dataPlaneRouting"].write(value.dataPlaneRouting)
        try writer["defaultLargeStagingDiskType"].write(value.defaultLargeStagingDiskType)
        try writer["ebsEncryption"].write(value.ebsEncryption)
        try writer["ebsEncryptionKeyArn"].write(value.ebsEncryptionKeyArn)
        try writer["replicationServerInstanceType"].write(value.replicationServerInstanceType)
        try writer["replicationServersSecurityGroupsIDs"].writeList(value.replicationServersSecurityGroupsIDs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["stagingAreaSubnetId"].write(value.stagingAreaSubnetId)
        try writer["stagingAreaTags"].writeMap(value.stagingAreaTags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["useDedicatedReplicationServer"].write(value.useDedicatedReplicationServer)
        try writer["useFipsEndpoint"].write(value.useFipsEndpoint)
    }
}

extension CreateWaveInput {

    static func write(value: CreateWaveInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension DeleteApplicationInput {

    static func write(value: DeleteApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["applicationID"].write(value.applicationID)
    }
}

extension DeleteConnectorInput {

    static func write(value: DeleteConnectorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectorID"].write(value.connectorID)
    }
}

extension DeleteJobInput {

    static func write(value: DeleteJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["jobID"].write(value.jobID)
    }
}

extension DeleteLaunchConfigurationTemplateInput {

    static func write(value: DeleteLaunchConfigurationTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["launchConfigurationTemplateID"].write(value.launchConfigurationTemplateID)
    }
}

extension DeleteReplicationConfigurationTemplateInput {

    static func write(value: DeleteReplicationConfigurationTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["replicationConfigurationTemplateID"].write(value.replicationConfigurationTemplateID)
    }
}

extension DeleteSourceServerInput {

    static func write(value: DeleteSourceServerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["sourceServerID"].write(value.sourceServerID)
    }
}

extension DeleteVcenterClientInput {

    static func write(value: DeleteVcenterClientInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["vcenterClientID"].write(value.vcenterClientID)
    }
}

extension DeleteWaveInput {

    static func write(value: DeleteWaveInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["waveID"].write(value.waveID)
    }
}

extension DescribeJobLogItemsInput {

    static func write(value: DescribeJobLogItemsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["jobID"].write(value.jobID)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension DescribeJobsInput {

    static func write(value: DescribeJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["filters"].write(value.filters, with: MgnClientTypes.DescribeJobsRequestFilters.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension DescribeLaunchConfigurationTemplatesInput {

    static func write(value: DescribeLaunchConfigurationTemplatesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["launchConfigurationTemplateIDs"].writeList(value.launchConfigurationTemplateIDs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension DescribeReplicationConfigurationTemplatesInput {

    static func write(value: DescribeReplicationConfigurationTemplatesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["replicationConfigurationTemplateIDs"].writeList(value.replicationConfigurationTemplateIDs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeSourceServersInput {

    static func write(value: DescribeSourceServersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["filters"].write(value.filters, with: MgnClientTypes.DescribeSourceServersRequestFilters.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension DisassociateApplicationsInput {

    static func write(value: DisassociateApplicationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["applicationIDs"].writeList(value.applicationIDs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["waveID"].write(value.waveID)
    }
}

extension DisassociateSourceServersInput {

    static func write(value: DisassociateSourceServersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["applicationID"].write(value.applicationID)
        try writer["sourceServerIDs"].writeList(value.sourceServerIDs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DisconnectFromServiceInput {

    static func write(value: DisconnectFromServiceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["sourceServerID"].write(value.sourceServerID)
    }
}

extension FinalizeCutoverInput {

    static func write(value: FinalizeCutoverInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["sourceServerID"].write(value.sourceServerID)
    }
}

extension GetLaunchConfigurationInput {

    static func write(value: GetLaunchConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["sourceServerID"].write(value.sourceServerID)
    }
}

extension GetReplicationConfigurationInput {

    static func write(value: GetReplicationConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["sourceServerID"].write(value.sourceServerID)
    }
}

extension ListApplicationsInput {

    static func write(value: ListApplicationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["filters"].write(value.filters, with: MgnClientTypes.ListApplicationsRequestFilters.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListConnectorsInput {

    static func write(value: ListConnectorsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].write(value.filters, with: MgnClientTypes.ListConnectorsRequestFilters.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListExportErrorsInput {

    static func write(value: ListExportErrorsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["exportID"].write(value.exportID)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListExportsInput {

    static func write(value: ListExportsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].write(value.filters, with: MgnClientTypes.ListExportsRequestFilters.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListImportErrorsInput {

    static func write(value: ListImportErrorsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["importID"].write(value.importID)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListImportsInput {

    static func write(value: ListImportsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].write(value.filters, with: MgnClientTypes.ListImportsRequestFilters.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListManagedAccountsInput {

    static func write(value: ListManagedAccountsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListSourceServerActionsInput {

    static func write(value: ListSourceServerActionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["filters"].write(value.filters, with: MgnClientTypes.SourceServerActionsRequestFilters.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["sourceServerID"].write(value.sourceServerID)
    }
}

extension ListTemplateActionsInput {

    static func write(value: ListTemplateActionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].write(value.filters, with: MgnClientTypes.TemplateActionsRequestFilters.write(value:to:))
        try writer["launchConfigurationTemplateID"].write(value.launchConfigurationTemplateID)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListWavesInput {

    static func write(value: ListWavesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["filters"].write(value.filters, with: MgnClientTypes.ListWavesRequestFilters.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension MarkAsArchivedInput {

    static func write(value: MarkAsArchivedInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["sourceServerID"].write(value.sourceServerID)
    }
}

extension PauseReplicationInput {

    static func write(value: PauseReplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["sourceServerID"].write(value.sourceServerID)
    }
}

extension PutSourceServerActionInput {

    static func write(value: PutSourceServerActionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["actionID"].write(value.actionID)
        try writer["actionName"].write(value.actionName)
        try writer["active"].write(value.active)
        try writer["category"].write(value.category)
        try writer["description"].write(value.description)
        try writer["documentIdentifier"].write(value.documentIdentifier)
        try writer["documentVersion"].write(value.documentVersion)
        try writer["externalParameters"].writeMap(value.externalParameters, valueWritingClosure: MgnClientTypes.SsmExternalParameter.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["mustSucceedForCutover"].write(value.mustSucceedForCutover)
        try writer["order"].write(value.order)
        try writer["parameters"].writeMap(value.parameters, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: MgnClientTypes.SsmParameterStoreParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["sourceServerID"].write(value.sourceServerID)
        try writer["timeoutSeconds"].write(value.timeoutSeconds)
    }
}

extension PutTemplateActionInput {

    static func write(value: PutTemplateActionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionID"].write(value.actionID)
        try writer["actionName"].write(value.actionName)
        try writer["active"].write(value.active)
        try writer["category"].write(value.category)
        try writer["description"].write(value.description)
        try writer["documentIdentifier"].write(value.documentIdentifier)
        try writer["documentVersion"].write(value.documentVersion)
        try writer["externalParameters"].writeMap(value.externalParameters, valueWritingClosure: MgnClientTypes.SsmExternalParameter.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["launchConfigurationTemplateID"].write(value.launchConfigurationTemplateID)
        try writer["mustSucceedForCutover"].write(value.mustSucceedForCutover)
        try writer["operatingSystem"].write(value.operatingSystem)
        try writer["order"].write(value.order)
        try writer["parameters"].writeMap(value.parameters, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: MgnClientTypes.SsmParameterStoreParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["timeoutSeconds"].write(value.timeoutSeconds)
    }
}

extension RemoveSourceServerActionInput {

    static func write(value: RemoveSourceServerActionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["actionID"].write(value.actionID)
        try writer["sourceServerID"].write(value.sourceServerID)
    }
}

extension RemoveTemplateActionInput {

    static func write(value: RemoveTemplateActionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionID"].write(value.actionID)
        try writer["launchConfigurationTemplateID"].write(value.launchConfigurationTemplateID)
    }
}

extension ResumeReplicationInput {

    static func write(value: ResumeReplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["sourceServerID"].write(value.sourceServerID)
    }
}

extension RetryDataReplicationInput {

    static func write(value: RetryDataReplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["sourceServerID"].write(value.sourceServerID)
    }
}

extension StartCutoverInput {

    static func write(value: StartCutoverInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["sourceServerIDs"].writeList(value.sourceServerIDs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension StartExportInput {

    static func write(value: StartExportInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Bucket"].write(value.s3Bucket)
        try writer["s3BucketOwner"].write(value.s3BucketOwner)
        try writer["s3Key"].write(value.s3Key)
    }
}

extension StartImportInput {

    static func write(value: StartImportInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["s3BucketSource"].write(value.s3BucketSource, with: MgnClientTypes.S3BucketSource.write(value:to:))
    }
}

extension StartReplicationInput {

    static func write(value: StartReplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["sourceServerID"].write(value.sourceServerID)
    }
}

extension StartTestInput {

    static func write(value: StartTestInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["sourceServerIDs"].writeList(value.sourceServerIDs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension StopReplicationInput {

    static func write(value: StopReplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["sourceServerID"].write(value.sourceServerID)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension TerminateTargetInstancesInput {

    static func write(value: TerminateTargetInstancesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["sourceServerIDs"].writeList(value.sourceServerIDs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UnarchiveApplicationInput {

    static func write(value: UnarchiveApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["applicationID"].write(value.applicationID)
    }
}

extension UnarchiveWaveInput {

    static func write(value: UnarchiveWaveInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["waveID"].write(value.waveID)
    }
}

extension UpdateApplicationInput {

    static func write(value: UpdateApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["applicationID"].write(value.applicationID)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
    }
}

extension UpdateConnectorInput {

    static func write(value: UpdateConnectorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectorID"].write(value.connectorID)
        try writer["name"].write(value.name)
        try writer["ssmCommandConfig"].write(value.ssmCommandConfig, with: MgnClientTypes.ConnectorSsmCommandConfig.write(value:to:))
    }
}

extension UpdateLaunchConfigurationInput {

    static func write(value: UpdateLaunchConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["bootMode"].write(value.bootMode)
        try writer["copyPrivateIp"].write(value.copyPrivateIp)
        try writer["copyTags"].write(value.copyTags)
        try writer["enableMapAutoTagging"].write(value.enableMapAutoTagging)
        try writer["launchDisposition"].write(value.launchDisposition)
        try writer["licensing"].write(value.licensing, with: MgnClientTypes.Licensing.write(value:to:))
        try writer["mapAutoTaggingMpeID"].write(value.mapAutoTaggingMpeID)
        try writer["name"].write(value.name)
        try writer["postLaunchActions"].write(value.postLaunchActions, with: MgnClientTypes.PostLaunchActions.write(value:to:))
        try writer["sourceServerID"].write(value.sourceServerID)
        try writer["targetInstanceTypeRightSizingMethod"].write(value.targetInstanceTypeRightSizingMethod)
    }
}

extension UpdateLaunchConfigurationTemplateInput {

    static func write(value: UpdateLaunchConfigurationTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["associatePublicIpAddress"].write(value.associatePublicIpAddress)
        try writer["bootMode"].write(value.bootMode)
        try writer["copyPrivateIp"].write(value.copyPrivateIp)
        try writer["copyTags"].write(value.copyTags)
        try writer["enableMapAutoTagging"].write(value.enableMapAutoTagging)
        try writer["largeVolumeConf"].write(value.largeVolumeConf, with: MgnClientTypes.LaunchTemplateDiskConf.write(value:to:))
        try writer["launchConfigurationTemplateID"].write(value.launchConfigurationTemplateID)
        try writer["launchDisposition"].write(value.launchDisposition)
        try writer["licensing"].write(value.licensing, with: MgnClientTypes.Licensing.write(value:to:))
        try writer["mapAutoTaggingMpeID"].write(value.mapAutoTaggingMpeID)
        try writer["postLaunchActions"].write(value.postLaunchActions, with: MgnClientTypes.PostLaunchActions.write(value:to:))
        try writer["smallVolumeConf"].write(value.smallVolumeConf, with: MgnClientTypes.LaunchTemplateDiskConf.write(value:to:))
        try writer["smallVolumeMaxSize"].write(value.smallVolumeMaxSize)
        try writer["targetInstanceTypeRightSizingMethod"].write(value.targetInstanceTypeRightSizingMethod)
    }
}

extension UpdateReplicationConfigurationInput {

    static func write(value: UpdateReplicationConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["associateDefaultSecurityGroup"].write(value.associateDefaultSecurityGroup)
        try writer["bandwidthThrottling"].write(value.bandwidthThrottling)
        try writer["createPublicIP"].write(value.createPublicIP)
        try writer["dataPlaneRouting"].write(value.dataPlaneRouting)
        try writer["defaultLargeStagingDiskType"].write(value.defaultLargeStagingDiskType)
        try writer["ebsEncryption"].write(value.ebsEncryption)
        try writer["ebsEncryptionKeyArn"].write(value.ebsEncryptionKeyArn)
        try writer["name"].write(value.name)
        try writer["replicatedDisks"].writeList(value.replicatedDisks, memberWritingClosure: MgnClientTypes.ReplicationConfigurationReplicatedDisk.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["replicationServerInstanceType"].write(value.replicationServerInstanceType)
        try writer["replicationServersSecurityGroupsIDs"].writeList(value.replicationServersSecurityGroupsIDs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["sourceServerID"].write(value.sourceServerID)
        try writer["stagingAreaSubnetId"].write(value.stagingAreaSubnetId)
        try writer["stagingAreaTags"].writeMap(value.stagingAreaTags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["useDedicatedReplicationServer"].write(value.useDedicatedReplicationServer)
        try writer["useFipsEndpoint"].write(value.useFipsEndpoint)
    }
}

extension UpdateReplicationConfigurationTemplateInput {

    static func write(value: UpdateReplicationConfigurationTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["associateDefaultSecurityGroup"].write(value.associateDefaultSecurityGroup)
        try writer["bandwidthThrottling"].write(value.bandwidthThrottling)
        try writer["createPublicIP"].write(value.createPublicIP)
        try writer["dataPlaneRouting"].write(value.dataPlaneRouting)
        try writer["defaultLargeStagingDiskType"].write(value.defaultLargeStagingDiskType)
        try writer["ebsEncryption"].write(value.ebsEncryption)
        try writer["ebsEncryptionKeyArn"].write(value.ebsEncryptionKeyArn)
        try writer["replicationConfigurationTemplateID"].write(value.replicationConfigurationTemplateID)
        try writer["replicationServerInstanceType"].write(value.replicationServerInstanceType)
        try writer["replicationServersSecurityGroupsIDs"].writeList(value.replicationServersSecurityGroupsIDs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["stagingAreaSubnetId"].write(value.stagingAreaSubnetId)
        try writer["stagingAreaTags"].writeMap(value.stagingAreaTags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["useDedicatedReplicationServer"].write(value.useDedicatedReplicationServer)
        try writer["useFipsEndpoint"].write(value.useFipsEndpoint)
    }
}

extension UpdateSourceServerInput {

    static func write(value: UpdateSourceServerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["connectorAction"].write(value.connectorAction, with: MgnClientTypes.SourceServerConnectorAction.write(value:to:))
        try writer["sourceServerID"].write(value.sourceServerID)
    }
}

extension UpdateSourceServerReplicationTypeInput {

    static func write(value: UpdateSourceServerReplicationTypeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["replicationType"].write(value.replicationType)
        try writer["sourceServerID"].write(value.sourceServerID)
    }
}

extension UpdateWaveInput {

    static func write(value: UpdateWaveInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountID"].write(value.accountID)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["waveID"].write(value.waveID)
    }
}

extension ArchiveApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ArchiveApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ArchiveApplicationOutput()
        value.applicationAggregatedStatus = try reader["applicationAggregatedStatus"].readIfPresent(with: MgnClientTypes.ApplicationAggregatedStatus.read(from:))
        value.applicationID = try reader["applicationID"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.isArchived = try reader["isArchived"].readIfPresent()
        value.lastModifiedDateTime = try reader["lastModifiedDateTime"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.waveID = try reader["waveID"].readIfPresent()
        return value
    }
}

extension ArchiveWaveOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ArchiveWaveOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ArchiveWaveOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.isArchived = try reader["isArchived"].readIfPresent()
        value.lastModifiedDateTime = try reader["lastModifiedDateTime"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.waveAggregatedStatus = try reader["waveAggregatedStatus"].readIfPresent(with: MgnClientTypes.WaveAggregatedStatus.read(from:))
        value.waveID = try reader["waveID"].readIfPresent()
        return value
    }
}

extension AssociateApplicationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateApplicationsOutput {
        return AssociateApplicationsOutput()
    }
}

extension AssociateSourceServersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateSourceServersOutput {
        return AssociateSourceServersOutput()
    }
}

extension ChangeServerLifeCycleStateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ChangeServerLifeCycleStateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ChangeServerLifeCycleStateOutput()
        value.applicationID = try reader["applicationID"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.connectorAction = try reader["connectorAction"].readIfPresent(with: MgnClientTypes.SourceServerConnectorAction.read(from:))
        value.dataReplicationInfo = try reader["dataReplicationInfo"].readIfPresent(with: MgnClientTypes.DataReplicationInfo.read(from:))
        value.fqdnForActionFramework = try reader["fqdnForActionFramework"].readIfPresent()
        value.isArchived = try reader["isArchived"].readIfPresent()
        value.launchedInstance = try reader["launchedInstance"].readIfPresent(with: MgnClientTypes.LaunchedInstance.read(from:))
        value.lifeCycle = try reader["lifeCycle"].readIfPresent(with: MgnClientTypes.LifeCycle.read(from:))
        value.replicationType = try reader["replicationType"].readIfPresent()
        value.sourceProperties = try reader["sourceProperties"].readIfPresent(with: MgnClientTypes.SourceProperties.read(from:))
        value.sourceServerID = try reader["sourceServerID"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.userProvidedID = try reader["userProvidedID"].readIfPresent()
        value.vcenterClientID = try reader["vcenterClientID"].readIfPresent()
        return value
    }
}

extension CreateApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateApplicationOutput()
        value.applicationAggregatedStatus = try reader["applicationAggregatedStatus"].readIfPresent(with: MgnClientTypes.ApplicationAggregatedStatus.read(from:))
        value.applicationID = try reader["applicationID"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.isArchived = try reader["isArchived"].readIfPresent()
        value.lastModifiedDateTime = try reader["lastModifiedDateTime"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.waveID = try reader["waveID"].readIfPresent()
        return value
    }
}

extension CreateConnectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateConnectorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateConnectorOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.connectorID = try reader["connectorID"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.ssmCommandConfig = try reader["ssmCommandConfig"].readIfPresent(with: MgnClientTypes.ConnectorSsmCommandConfig.read(from:))
        value.ssmInstanceID = try reader["ssmInstanceID"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CreateLaunchConfigurationTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLaunchConfigurationTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateLaunchConfigurationTemplateOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.associatePublicIpAddress = try reader["associatePublicIpAddress"].readIfPresent()
        value.bootMode = try reader["bootMode"].readIfPresent()
        value.copyPrivateIp = try reader["copyPrivateIp"].readIfPresent()
        value.copyTags = try reader["copyTags"].readIfPresent()
        value.ec2LaunchTemplateID = try reader["ec2LaunchTemplateID"].readIfPresent()
        value.enableMapAutoTagging = try reader["enableMapAutoTagging"].readIfPresent()
        value.largeVolumeConf = try reader["largeVolumeConf"].readIfPresent(with: MgnClientTypes.LaunchTemplateDiskConf.read(from:))
        value.launchConfigurationTemplateID = try reader["launchConfigurationTemplateID"].readIfPresent() ?? ""
        value.launchDisposition = try reader["launchDisposition"].readIfPresent()
        value.licensing = try reader["licensing"].readIfPresent(with: MgnClientTypes.Licensing.read(from:))
        value.mapAutoTaggingMpeID = try reader["mapAutoTaggingMpeID"].readIfPresent()
        value.postLaunchActions = try reader["postLaunchActions"].readIfPresent(with: MgnClientTypes.PostLaunchActions.read(from:))
        value.smallVolumeConf = try reader["smallVolumeConf"].readIfPresent(with: MgnClientTypes.LaunchTemplateDiskConf.read(from:))
        value.smallVolumeMaxSize = try reader["smallVolumeMaxSize"].readIfPresent() ?? 0
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.targetInstanceTypeRightSizingMethod = try reader["targetInstanceTypeRightSizingMethod"].readIfPresent()
        return value
    }
}

extension CreateReplicationConfigurationTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateReplicationConfigurationTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateReplicationConfigurationTemplateOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.associateDefaultSecurityGroup = try reader["associateDefaultSecurityGroup"].readIfPresent()
        value.bandwidthThrottling = try reader["bandwidthThrottling"].readIfPresent() ?? 0
        value.createPublicIP = try reader["createPublicIP"].readIfPresent()
        value.dataPlaneRouting = try reader["dataPlaneRouting"].readIfPresent()
        value.defaultLargeStagingDiskType = try reader["defaultLargeStagingDiskType"].readIfPresent()
        value.ebsEncryption = try reader["ebsEncryption"].readIfPresent()
        value.ebsEncryptionKeyArn = try reader["ebsEncryptionKeyArn"].readIfPresent()
        value.replicationConfigurationTemplateID = try reader["replicationConfigurationTemplateID"].readIfPresent() ?? ""
        value.replicationServerInstanceType = try reader["replicationServerInstanceType"].readIfPresent()
        value.replicationServersSecurityGroupsIDs = try reader["replicationServersSecurityGroupsIDs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.stagingAreaSubnetId = try reader["stagingAreaSubnetId"].readIfPresent()
        value.stagingAreaTags = try reader["stagingAreaTags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.useDedicatedReplicationServer = try reader["useDedicatedReplicationServer"].readIfPresent()
        value.useFipsEndpoint = try reader["useFipsEndpoint"].readIfPresent()
        return value
    }
}

extension CreateWaveOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateWaveOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWaveOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.isArchived = try reader["isArchived"].readIfPresent()
        value.lastModifiedDateTime = try reader["lastModifiedDateTime"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.waveAggregatedStatus = try reader["waveAggregatedStatus"].readIfPresent(with: MgnClientTypes.WaveAggregatedStatus.read(from:))
        value.waveID = try reader["waveID"].readIfPresent()
        return value
    }
}

extension DeleteApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteApplicationOutput {
        return DeleteApplicationOutput()
    }
}

extension DeleteConnectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteConnectorOutput {
        return DeleteConnectorOutput()
    }
}

extension DeleteJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteJobOutput {
        return DeleteJobOutput()
    }
}

extension DeleteLaunchConfigurationTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLaunchConfigurationTemplateOutput {
        return DeleteLaunchConfigurationTemplateOutput()
    }
}

extension DeleteReplicationConfigurationTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteReplicationConfigurationTemplateOutput {
        return DeleteReplicationConfigurationTemplateOutput()
    }
}

extension DeleteSourceServerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSourceServerOutput {
        return DeleteSourceServerOutput()
    }
}

extension DeleteVcenterClientOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVcenterClientOutput {
        return DeleteVcenterClientOutput()
    }
}

extension DeleteWaveOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteWaveOutput {
        return DeleteWaveOutput()
    }
}

extension DescribeJobLogItemsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeJobLogItemsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeJobLogItemsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: MgnClientTypes.JobLog.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension DescribeJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeJobsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: MgnClientTypes.Job.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension DescribeLaunchConfigurationTemplatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeLaunchConfigurationTemplatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeLaunchConfigurationTemplatesOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: MgnClientTypes.LaunchConfigurationTemplate.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension DescribeReplicationConfigurationTemplatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeReplicationConfigurationTemplatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeReplicationConfigurationTemplatesOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: MgnClientTypes.ReplicationConfigurationTemplate.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension DescribeSourceServersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeSourceServersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeSourceServersOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: MgnClientTypes.SourceServer.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension DescribeVcenterClientsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeVcenterClientsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeVcenterClientsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: MgnClientTypes.VcenterClient.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension DisassociateApplicationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateApplicationsOutput {
        return DisassociateApplicationsOutput()
    }
}

extension DisassociateSourceServersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateSourceServersOutput {
        return DisassociateSourceServersOutput()
    }
}

extension DisconnectFromServiceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisconnectFromServiceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisconnectFromServiceOutput()
        value.applicationID = try reader["applicationID"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.connectorAction = try reader["connectorAction"].readIfPresent(with: MgnClientTypes.SourceServerConnectorAction.read(from:))
        value.dataReplicationInfo = try reader["dataReplicationInfo"].readIfPresent(with: MgnClientTypes.DataReplicationInfo.read(from:))
        value.fqdnForActionFramework = try reader["fqdnForActionFramework"].readIfPresent()
        value.isArchived = try reader["isArchived"].readIfPresent()
        value.launchedInstance = try reader["launchedInstance"].readIfPresent(with: MgnClientTypes.LaunchedInstance.read(from:))
        value.lifeCycle = try reader["lifeCycle"].readIfPresent(with: MgnClientTypes.LifeCycle.read(from:))
        value.replicationType = try reader["replicationType"].readIfPresent()
        value.sourceProperties = try reader["sourceProperties"].readIfPresent(with: MgnClientTypes.SourceProperties.read(from:))
        value.sourceServerID = try reader["sourceServerID"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.userProvidedID = try reader["userProvidedID"].readIfPresent()
        value.vcenterClientID = try reader["vcenterClientID"].readIfPresent()
        return value
    }
}

extension FinalizeCutoverOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> FinalizeCutoverOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = FinalizeCutoverOutput()
        value.applicationID = try reader["applicationID"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.connectorAction = try reader["connectorAction"].readIfPresent(with: MgnClientTypes.SourceServerConnectorAction.read(from:))
        value.dataReplicationInfo = try reader["dataReplicationInfo"].readIfPresent(with: MgnClientTypes.DataReplicationInfo.read(from:))
        value.fqdnForActionFramework = try reader["fqdnForActionFramework"].readIfPresent()
        value.isArchived = try reader["isArchived"].readIfPresent()
        value.launchedInstance = try reader["launchedInstance"].readIfPresent(with: MgnClientTypes.LaunchedInstance.read(from:))
        value.lifeCycle = try reader["lifeCycle"].readIfPresent(with: MgnClientTypes.LifeCycle.read(from:))
        value.replicationType = try reader["replicationType"].readIfPresent()
        value.sourceProperties = try reader["sourceProperties"].readIfPresent(with: MgnClientTypes.SourceProperties.read(from:))
        value.sourceServerID = try reader["sourceServerID"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.userProvidedID = try reader["userProvidedID"].readIfPresent()
        value.vcenterClientID = try reader["vcenterClientID"].readIfPresent()
        return value
    }
}

extension GetLaunchConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLaunchConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLaunchConfigurationOutput()
        value.bootMode = try reader["bootMode"].readIfPresent()
        value.copyPrivateIp = try reader["copyPrivateIp"].readIfPresent()
        value.copyTags = try reader["copyTags"].readIfPresent()
        value.ec2LaunchTemplateID = try reader["ec2LaunchTemplateID"].readIfPresent()
        value.enableMapAutoTagging = try reader["enableMapAutoTagging"].readIfPresent()
        value.launchDisposition = try reader["launchDisposition"].readIfPresent()
        value.licensing = try reader["licensing"].readIfPresent(with: MgnClientTypes.Licensing.read(from:))
        value.mapAutoTaggingMpeID = try reader["mapAutoTaggingMpeID"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.postLaunchActions = try reader["postLaunchActions"].readIfPresent(with: MgnClientTypes.PostLaunchActions.read(from:))
        value.sourceServerID = try reader["sourceServerID"].readIfPresent()
        value.targetInstanceTypeRightSizingMethod = try reader["targetInstanceTypeRightSizingMethod"].readIfPresent()
        return value
    }
}

extension GetReplicationConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetReplicationConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetReplicationConfigurationOutput()
        value.associateDefaultSecurityGroup = try reader["associateDefaultSecurityGroup"].readIfPresent()
        value.bandwidthThrottling = try reader["bandwidthThrottling"].readIfPresent() ?? 0
        value.createPublicIP = try reader["createPublicIP"].readIfPresent()
        value.dataPlaneRouting = try reader["dataPlaneRouting"].readIfPresent()
        value.defaultLargeStagingDiskType = try reader["defaultLargeStagingDiskType"].readIfPresent()
        value.ebsEncryption = try reader["ebsEncryption"].readIfPresent()
        value.ebsEncryptionKeyArn = try reader["ebsEncryptionKeyArn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.replicatedDisks = try reader["replicatedDisks"].readListIfPresent(memberReadingClosure: MgnClientTypes.ReplicationConfigurationReplicatedDisk.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.replicationServerInstanceType = try reader["replicationServerInstanceType"].readIfPresent()
        value.replicationServersSecurityGroupsIDs = try reader["replicationServersSecurityGroupsIDs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.sourceServerID = try reader["sourceServerID"].readIfPresent()
        value.stagingAreaSubnetId = try reader["stagingAreaSubnetId"].readIfPresent()
        value.stagingAreaTags = try reader["stagingAreaTags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.useDedicatedReplicationServer = try reader["useDedicatedReplicationServer"].readIfPresent()
        value.useFipsEndpoint = try reader["useFipsEndpoint"].readIfPresent()
        return value
    }
}

extension InitializeServiceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> InitializeServiceOutput {
        return InitializeServiceOutput()
    }
}

extension ListApplicationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListApplicationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListApplicationsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: MgnClientTypes.Application.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListConnectorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListConnectorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListConnectorsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: MgnClientTypes.Connector.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListExportErrorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListExportErrorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListExportErrorsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: MgnClientTypes.ExportTaskError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListExportsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListExportsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListExportsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: MgnClientTypes.ExportTask.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListImportErrorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListImportErrorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListImportErrorsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: MgnClientTypes.ImportTaskError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListImportsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListImportsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListImportsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: MgnClientTypes.ImportTask.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListManagedAccountsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListManagedAccountsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListManagedAccountsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: MgnClientTypes.ManagedAccount.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListSourceServerActionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSourceServerActionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSourceServerActionsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: MgnClientTypes.SourceServerActionDocument.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListTemplateActionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTemplateActionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTemplateActionsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: MgnClientTypes.TemplateActionDocument.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListWavesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWavesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWavesOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: MgnClientTypes.Wave.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension MarkAsArchivedOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> MarkAsArchivedOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = MarkAsArchivedOutput()
        value.applicationID = try reader["applicationID"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.connectorAction = try reader["connectorAction"].readIfPresent(with: MgnClientTypes.SourceServerConnectorAction.read(from:))
        value.dataReplicationInfo = try reader["dataReplicationInfo"].readIfPresent(with: MgnClientTypes.DataReplicationInfo.read(from:))
        value.fqdnForActionFramework = try reader["fqdnForActionFramework"].readIfPresent()
        value.isArchived = try reader["isArchived"].readIfPresent()
        value.launchedInstance = try reader["launchedInstance"].readIfPresent(with: MgnClientTypes.LaunchedInstance.read(from:))
        value.lifeCycle = try reader["lifeCycle"].readIfPresent(with: MgnClientTypes.LifeCycle.read(from:))
        value.replicationType = try reader["replicationType"].readIfPresent()
        value.sourceProperties = try reader["sourceProperties"].readIfPresent(with: MgnClientTypes.SourceProperties.read(from:))
        value.sourceServerID = try reader["sourceServerID"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.userProvidedID = try reader["userProvidedID"].readIfPresent()
        value.vcenterClientID = try reader["vcenterClientID"].readIfPresent()
        return value
    }
}

extension PauseReplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PauseReplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PauseReplicationOutput()
        value.applicationID = try reader["applicationID"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.connectorAction = try reader["connectorAction"].readIfPresent(with: MgnClientTypes.SourceServerConnectorAction.read(from:))
        value.dataReplicationInfo = try reader["dataReplicationInfo"].readIfPresent(with: MgnClientTypes.DataReplicationInfo.read(from:))
        value.fqdnForActionFramework = try reader["fqdnForActionFramework"].readIfPresent()
        value.isArchived = try reader["isArchived"].readIfPresent()
        value.launchedInstance = try reader["launchedInstance"].readIfPresent(with: MgnClientTypes.LaunchedInstance.read(from:))
        value.lifeCycle = try reader["lifeCycle"].readIfPresent(with: MgnClientTypes.LifeCycle.read(from:))
        value.replicationType = try reader["replicationType"].readIfPresent()
        value.sourceProperties = try reader["sourceProperties"].readIfPresent(with: MgnClientTypes.SourceProperties.read(from:))
        value.sourceServerID = try reader["sourceServerID"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.userProvidedID = try reader["userProvidedID"].readIfPresent()
        value.vcenterClientID = try reader["vcenterClientID"].readIfPresent()
        return value
    }
}

extension PutSourceServerActionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutSourceServerActionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutSourceServerActionOutput()
        value.actionID = try reader["actionID"].readIfPresent()
        value.actionName = try reader["actionName"].readIfPresent()
        value.active = try reader["active"].readIfPresent()
        value.category = try reader["category"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.documentIdentifier = try reader["documentIdentifier"].readIfPresent()
        value.documentVersion = try reader["documentVersion"].readIfPresent()
        value.externalParameters = try reader["externalParameters"].readMapIfPresent(valueReadingClosure: MgnClientTypes.SsmExternalParameter.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.mustSucceedForCutover = try reader["mustSucceedForCutover"].readIfPresent()
        value.order = try reader["order"].readIfPresent()
        value.parameters = try reader["parameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: MgnClientTypes.SsmParameterStoreParameter.read(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.timeoutSeconds = try reader["timeoutSeconds"].readIfPresent()
        return value
    }
}

extension PutTemplateActionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutTemplateActionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutTemplateActionOutput()
        value.actionID = try reader["actionID"].readIfPresent()
        value.actionName = try reader["actionName"].readIfPresent()
        value.active = try reader["active"].readIfPresent()
        value.category = try reader["category"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.documentIdentifier = try reader["documentIdentifier"].readIfPresent()
        value.documentVersion = try reader["documentVersion"].readIfPresent()
        value.externalParameters = try reader["externalParameters"].readMapIfPresent(valueReadingClosure: MgnClientTypes.SsmExternalParameter.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.mustSucceedForCutover = try reader["mustSucceedForCutover"].readIfPresent()
        value.operatingSystem = try reader["operatingSystem"].readIfPresent()
        value.order = try reader["order"].readIfPresent()
        value.parameters = try reader["parameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: MgnClientTypes.SsmParameterStoreParameter.read(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.timeoutSeconds = try reader["timeoutSeconds"].readIfPresent()
        return value
    }
}

extension RemoveSourceServerActionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveSourceServerActionOutput {
        return RemoveSourceServerActionOutput()
    }
}

extension RemoveTemplateActionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveTemplateActionOutput {
        return RemoveTemplateActionOutput()
    }
}

extension ResumeReplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ResumeReplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ResumeReplicationOutput()
        value.applicationID = try reader["applicationID"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.connectorAction = try reader["connectorAction"].readIfPresent(with: MgnClientTypes.SourceServerConnectorAction.read(from:))
        value.dataReplicationInfo = try reader["dataReplicationInfo"].readIfPresent(with: MgnClientTypes.DataReplicationInfo.read(from:))
        value.fqdnForActionFramework = try reader["fqdnForActionFramework"].readIfPresent()
        value.isArchived = try reader["isArchived"].readIfPresent()
        value.launchedInstance = try reader["launchedInstance"].readIfPresent(with: MgnClientTypes.LaunchedInstance.read(from:))
        value.lifeCycle = try reader["lifeCycle"].readIfPresent(with: MgnClientTypes.LifeCycle.read(from:))
        value.replicationType = try reader["replicationType"].readIfPresent()
        value.sourceProperties = try reader["sourceProperties"].readIfPresent(with: MgnClientTypes.SourceProperties.read(from:))
        value.sourceServerID = try reader["sourceServerID"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.userProvidedID = try reader["userProvidedID"].readIfPresent()
        value.vcenterClientID = try reader["vcenterClientID"].readIfPresent()
        return value
    }
}

extension RetryDataReplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RetryDataReplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RetryDataReplicationOutput()
        value.applicationID = try reader["applicationID"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.connectorAction = try reader["connectorAction"].readIfPresent(with: MgnClientTypes.SourceServerConnectorAction.read(from:))
        value.dataReplicationInfo = try reader["dataReplicationInfo"].readIfPresent(with: MgnClientTypes.DataReplicationInfo.read(from:))
        value.fqdnForActionFramework = try reader["fqdnForActionFramework"].readIfPresent()
        value.isArchived = try reader["isArchived"].readIfPresent()
        value.launchedInstance = try reader["launchedInstance"].readIfPresent(with: MgnClientTypes.LaunchedInstance.read(from:))
        value.lifeCycle = try reader["lifeCycle"].readIfPresent(with: MgnClientTypes.LifeCycle.read(from:))
        value.replicationType = try reader["replicationType"].readIfPresent()
        value.sourceProperties = try reader["sourceProperties"].readIfPresent(with: MgnClientTypes.SourceProperties.read(from:))
        value.sourceServerID = try reader["sourceServerID"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.userProvidedID = try reader["userProvidedID"].readIfPresent()
        value.vcenterClientID = try reader["vcenterClientID"].readIfPresent()
        return value
    }
}

extension StartCutoverOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartCutoverOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartCutoverOutput()
        value.job = try reader["job"].readIfPresent(with: MgnClientTypes.Job.read(from:))
        return value
    }
}

extension StartExportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartExportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartExportOutput()
        value.exportTask = try reader["exportTask"].readIfPresent(with: MgnClientTypes.ExportTask.read(from:))
        return value
    }
}

extension StartImportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartImportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartImportOutput()
        value.importTask = try reader["importTask"].readIfPresent(with: MgnClientTypes.ImportTask.read(from:))
        return value
    }
}

extension StartReplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartReplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartReplicationOutput()
        value.applicationID = try reader["applicationID"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.connectorAction = try reader["connectorAction"].readIfPresent(with: MgnClientTypes.SourceServerConnectorAction.read(from:))
        value.dataReplicationInfo = try reader["dataReplicationInfo"].readIfPresent(with: MgnClientTypes.DataReplicationInfo.read(from:))
        value.fqdnForActionFramework = try reader["fqdnForActionFramework"].readIfPresent()
        value.isArchived = try reader["isArchived"].readIfPresent()
        value.launchedInstance = try reader["launchedInstance"].readIfPresent(with: MgnClientTypes.LaunchedInstance.read(from:))
        value.lifeCycle = try reader["lifeCycle"].readIfPresent(with: MgnClientTypes.LifeCycle.read(from:))
        value.replicationType = try reader["replicationType"].readIfPresent()
        value.sourceProperties = try reader["sourceProperties"].readIfPresent(with: MgnClientTypes.SourceProperties.read(from:))
        value.sourceServerID = try reader["sourceServerID"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.userProvidedID = try reader["userProvidedID"].readIfPresent()
        value.vcenterClientID = try reader["vcenterClientID"].readIfPresent()
        return value
    }
}

extension StartTestOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartTestOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartTestOutput()
        value.job = try reader["job"].readIfPresent(with: MgnClientTypes.Job.read(from:))
        return value
    }
}

extension StopReplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopReplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopReplicationOutput()
        value.applicationID = try reader["applicationID"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.connectorAction = try reader["connectorAction"].readIfPresent(with: MgnClientTypes.SourceServerConnectorAction.read(from:))
        value.dataReplicationInfo = try reader["dataReplicationInfo"].readIfPresent(with: MgnClientTypes.DataReplicationInfo.read(from:))
        value.fqdnForActionFramework = try reader["fqdnForActionFramework"].readIfPresent()
        value.isArchived = try reader["isArchived"].readIfPresent()
        value.launchedInstance = try reader["launchedInstance"].readIfPresent(with: MgnClientTypes.LaunchedInstance.read(from:))
        value.lifeCycle = try reader["lifeCycle"].readIfPresent(with: MgnClientTypes.LifeCycle.read(from:))
        value.replicationType = try reader["replicationType"].readIfPresent()
        value.sourceProperties = try reader["sourceProperties"].readIfPresent(with: MgnClientTypes.SourceProperties.read(from:))
        value.sourceServerID = try reader["sourceServerID"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.userProvidedID = try reader["userProvidedID"].readIfPresent()
        value.vcenterClientID = try reader["vcenterClientID"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension TerminateTargetInstancesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TerminateTargetInstancesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = TerminateTargetInstancesOutput()
        value.job = try reader["job"].readIfPresent(with: MgnClientTypes.Job.read(from:))
        return value
    }
}

extension UnarchiveApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UnarchiveApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UnarchiveApplicationOutput()
        value.applicationAggregatedStatus = try reader["applicationAggregatedStatus"].readIfPresent(with: MgnClientTypes.ApplicationAggregatedStatus.read(from:))
        value.applicationID = try reader["applicationID"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.isArchived = try reader["isArchived"].readIfPresent()
        value.lastModifiedDateTime = try reader["lastModifiedDateTime"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.waveID = try reader["waveID"].readIfPresent()
        return value
    }
}

extension UnarchiveWaveOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UnarchiveWaveOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UnarchiveWaveOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.isArchived = try reader["isArchived"].readIfPresent()
        value.lastModifiedDateTime = try reader["lastModifiedDateTime"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.waveAggregatedStatus = try reader["waveAggregatedStatus"].readIfPresent(with: MgnClientTypes.WaveAggregatedStatus.read(from:))
        value.waveID = try reader["waveID"].readIfPresent()
        return value
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateApplicationOutput()
        value.applicationAggregatedStatus = try reader["applicationAggregatedStatus"].readIfPresent(with: MgnClientTypes.ApplicationAggregatedStatus.read(from:))
        value.applicationID = try reader["applicationID"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.isArchived = try reader["isArchived"].readIfPresent()
        value.lastModifiedDateTime = try reader["lastModifiedDateTime"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.waveID = try reader["waveID"].readIfPresent()
        return value
    }
}

extension UpdateConnectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateConnectorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateConnectorOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.connectorID = try reader["connectorID"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.ssmCommandConfig = try reader["ssmCommandConfig"].readIfPresent(with: MgnClientTypes.ConnectorSsmCommandConfig.read(from:))
        value.ssmInstanceID = try reader["ssmInstanceID"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension UpdateLaunchConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateLaunchConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateLaunchConfigurationOutput()
        value.bootMode = try reader["bootMode"].readIfPresent()
        value.copyPrivateIp = try reader["copyPrivateIp"].readIfPresent()
        value.copyTags = try reader["copyTags"].readIfPresent()
        value.ec2LaunchTemplateID = try reader["ec2LaunchTemplateID"].readIfPresent()
        value.enableMapAutoTagging = try reader["enableMapAutoTagging"].readIfPresent()
        value.launchDisposition = try reader["launchDisposition"].readIfPresent()
        value.licensing = try reader["licensing"].readIfPresent(with: MgnClientTypes.Licensing.read(from:))
        value.mapAutoTaggingMpeID = try reader["mapAutoTaggingMpeID"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.postLaunchActions = try reader["postLaunchActions"].readIfPresent(with: MgnClientTypes.PostLaunchActions.read(from:))
        value.sourceServerID = try reader["sourceServerID"].readIfPresent()
        value.targetInstanceTypeRightSizingMethod = try reader["targetInstanceTypeRightSizingMethod"].readIfPresent()
        return value
    }
}

extension UpdateLaunchConfigurationTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateLaunchConfigurationTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateLaunchConfigurationTemplateOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.associatePublicIpAddress = try reader["associatePublicIpAddress"].readIfPresent()
        value.bootMode = try reader["bootMode"].readIfPresent()
        value.copyPrivateIp = try reader["copyPrivateIp"].readIfPresent()
        value.copyTags = try reader["copyTags"].readIfPresent()
        value.ec2LaunchTemplateID = try reader["ec2LaunchTemplateID"].readIfPresent()
        value.enableMapAutoTagging = try reader["enableMapAutoTagging"].readIfPresent()
        value.largeVolumeConf = try reader["largeVolumeConf"].readIfPresent(with: MgnClientTypes.LaunchTemplateDiskConf.read(from:))
        value.launchConfigurationTemplateID = try reader["launchConfigurationTemplateID"].readIfPresent() ?? ""
        value.launchDisposition = try reader["launchDisposition"].readIfPresent()
        value.licensing = try reader["licensing"].readIfPresent(with: MgnClientTypes.Licensing.read(from:))
        value.mapAutoTaggingMpeID = try reader["mapAutoTaggingMpeID"].readIfPresent()
        value.postLaunchActions = try reader["postLaunchActions"].readIfPresent(with: MgnClientTypes.PostLaunchActions.read(from:))
        value.smallVolumeConf = try reader["smallVolumeConf"].readIfPresent(with: MgnClientTypes.LaunchTemplateDiskConf.read(from:))
        value.smallVolumeMaxSize = try reader["smallVolumeMaxSize"].readIfPresent() ?? 0
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.targetInstanceTypeRightSizingMethod = try reader["targetInstanceTypeRightSizingMethod"].readIfPresent()
        return value
    }
}

extension UpdateReplicationConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateReplicationConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateReplicationConfigurationOutput()
        value.associateDefaultSecurityGroup = try reader["associateDefaultSecurityGroup"].readIfPresent()
        value.bandwidthThrottling = try reader["bandwidthThrottling"].readIfPresent() ?? 0
        value.createPublicIP = try reader["createPublicIP"].readIfPresent()
        value.dataPlaneRouting = try reader["dataPlaneRouting"].readIfPresent()
        value.defaultLargeStagingDiskType = try reader["defaultLargeStagingDiskType"].readIfPresent()
        value.ebsEncryption = try reader["ebsEncryption"].readIfPresent()
        value.ebsEncryptionKeyArn = try reader["ebsEncryptionKeyArn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.replicatedDisks = try reader["replicatedDisks"].readListIfPresent(memberReadingClosure: MgnClientTypes.ReplicationConfigurationReplicatedDisk.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.replicationServerInstanceType = try reader["replicationServerInstanceType"].readIfPresent()
        value.replicationServersSecurityGroupsIDs = try reader["replicationServersSecurityGroupsIDs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.sourceServerID = try reader["sourceServerID"].readIfPresent()
        value.stagingAreaSubnetId = try reader["stagingAreaSubnetId"].readIfPresent()
        value.stagingAreaTags = try reader["stagingAreaTags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.useDedicatedReplicationServer = try reader["useDedicatedReplicationServer"].readIfPresent()
        value.useFipsEndpoint = try reader["useFipsEndpoint"].readIfPresent()
        return value
    }
}

extension UpdateReplicationConfigurationTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateReplicationConfigurationTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateReplicationConfigurationTemplateOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.associateDefaultSecurityGroup = try reader["associateDefaultSecurityGroup"].readIfPresent()
        value.bandwidthThrottling = try reader["bandwidthThrottling"].readIfPresent() ?? 0
        value.createPublicIP = try reader["createPublicIP"].readIfPresent()
        value.dataPlaneRouting = try reader["dataPlaneRouting"].readIfPresent()
        value.defaultLargeStagingDiskType = try reader["defaultLargeStagingDiskType"].readIfPresent()
        value.ebsEncryption = try reader["ebsEncryption"].readIfPresent()
        value.ebsEncryptionKeyArn = try reader["ebsEncryptionKeyArn"].readIfPresent()
        value.replicationConfigurationTemplateID = try reader["replicationConfigurationTemplateID"].readIfPresent() ?? ""
        value.replicationServerInstanceType = try reader["replicationServerInstanceType"].readIfPresent()
        value.replicationServersSecurityGroupsIDs = try reader["replicationServersSecurityGroupsIDs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.stagingAreaSubnetId = try reader["stagingAreaSubnetId"].readIfPresent()
        value.stagingAreaTags = try reader["stagingAreaTags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.useDedicatedReplicationServer = try reader["useDedicatedReplicationServer"].readIfPresent()
        value.useFipsEndpoint = try reader["useFipsEndpoint"].readIfPresent()
        return value
    }
}

extension UpdateSourceServerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSourceServerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSourceServerOutput()
        value.applicationID = try reader["applicationID"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.connectorAction = try reader["connectorAction"].readIfPresent(with: MgnClientTypes.SourceServerConnectorAction.read(from:))
        value.dataReplicationInfo = try reader["dataReplicationInfo"].readIfPresent(with: MgnClientTypes.DataReplicationInfo.read(from:))
        value.fqdnForActionFramework = try reader["fqdnForActionFramework"].readIfPresent()
        value.isArchived = try reader["isArchived"].readIfPresent()
        value.launchedInstance = try reader["launchedInstance"].readIfPresent(with: MgnClientTypes.LaunchedInstance.read(from:))
        value.lifeCycle = try reader["lifeCycle"].readIfPresent(with: MgnClientTypes.LifeCycle.read(from:))
        value.replicationType = try reader["replicationType"].readIfPresent()
        value.sourceProperties = try reader["sourceProperties"].readIfPresent(with: MgnClientTypes.SourceProperties.read(from:))
        value.sourceServerID = try reader["sourceServerID"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.userProvidedID = try reader["userProvidedID"].readIfPresent()
        value.vcenterClientID = try reader["vcenterClientID"].readIfPresent()
        return value
    }
}

extension UpdateSourceServerReplicationTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSourceServerReplicationTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSourceServerReplicationTypeOutput()
        value.applicationID = try reader["applicationID"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.connectorAction = try reader["connectorAction"].readIfPresent(with: MgnClientTypes.SourceServerConnectorAction.read(from:))
        value.dataReplicationInfo = try reader["dataReplicationInfo"].readIfPresent(with: MgnClientTypes.DataReplicationInfo.read(from:))
        value.fqdnForActionFramework = try reader["fqdnForActionFramework"].readIfPresent()
        value.isArchived = try reader["isArchived"].readIfPresent()
        value.launchedInstance = try reader["launchedInstance"].readIfPresent(with: MgnClientTypes.LaunchedInstance.read(from:))
        value.lifeCycle = try reader["lifeCycle"].readIfPresent(with: MgnClientTypes.LifeCycle.read(from:))
        value.replicationType = try reader["replicationType"].readIfPresent()
        value.sourceProperties = try reader["sourceProperties"].readIfPresent(with: MgnClientTypes.SourceProperties.read(from:))
        value.sourceServerID = try reader["sourceServerID"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.userProvidedID = try reader["userProvidedID"].readIfPresent()
        value.vcenterClientID = try reader["vcenterClientID"].readIfPresent()
        return value
    }
}

extension UpdateWaveOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateWaveOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateWaveOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.isArchived = try reader["isArchived"].readIfPresent()
        value.lastModifiedDateTime = try reader["lastModifiedDateTime"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.waveAggregatedStatus = try reader["waveAggregatedStatus"].readIfPresent(with: MgnClientTypes.WaveAggregatedStatus.read(from:))
        value.waveID = try reader["waveID"].readIfPresent()
        return value
    }
}

enum ArchiveApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ArchiveWaveOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateApplicationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateSourceServersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ChangeServerLifeCycleStateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateConnectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLaunchConfigurationTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateReplicationConfigurationTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateWaveOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteConnectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLaunchConfigurationTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteReplicationConfigurationTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSourceServerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVcenterClientOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteWaveOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeJobLogItemsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeLaunchConfigurationTemplatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeReplicationConfigurationTemplatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeSourceServersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeVcenterClientsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateApplicationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateSourceServersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisconnectFromServiceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum FinalizeCutoverOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLaunchConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetReplicationConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum InitializeServiceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListApplicationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListConnectorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListExportErrorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListExportsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListImportErrorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListImportsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListManagedAccountsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSourceServerActionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTemplateActionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWavesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum MarkAsArchivedOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PauseReplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutSourceServerActionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutTemplateActionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveSourceServerActionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveTemplateActionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ResumeReplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RetryDataReplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartCutoverOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartExportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartImportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartReplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartTestOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopReplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TerminateTargetInstancesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UnarchiveApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UnarchiveWaveOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateConnectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateLaunchConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateLaunchConfigurationTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateReplicationConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateReplicationConfigurationTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSourceServerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSourceServerReplicationTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateWaveOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UninitializedAccountException": return try UninitializedAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.code = try reader["code"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.quotaValue = try reader["quotaValue"].readIfPresent()
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.code = try reader["code"].readIfPresent()
        value.properties.errors = try reader["errors"].readListIfPresent(memberReadingClosure: MgnClientTypes.ErrorDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UninitializedAccountException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UninitializedAccountException {
        let reader = baseError.errorBodyReader
        var value = UninitializedAccountException()
        value.properties.code = try reader["code"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.code = try reader["code"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.code = try reader["code"].readIfPresent()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: MgnClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.reason = try reader["reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.code = try reader["code"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = retryAfterSecondsHeaderValue
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MgnClientTypes.ApplicationAggregatedStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.ApplicationAggregatedStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.ApplicationAggregatedStatus()
        value.lastUpdateDateTime = try reader["lastUpdateDateTime"].readIfPresent()
        value.healthStatus = try reader["healthStatus"].readIfPresent()
        value.progressStatus = try reader["progressStatus"].readIfPresent()
        value.totalSourceServers = try reader["totalSourceServers"].readIfPresent() ?? 0
        return value
    }
}

extension MgnClientTypes.WaveAggregatedStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.WaveAggregatedStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.WaveAggregatedStatus()
        value.lastUpdateDateTime = try reader["lastUpdateDateTime"].readIfPresent()
        value.replicationStartedDateTime = try reader["replicationStartedDateTime"].readIfPresent()
        value.healthStatus = try reader["healthStatus"].readIfPresent()
        value.progressStatus = try reader["progressStatus"].readIfPresent()
        value.totalApplications = try reader["totalApplications"].readIfPresent() ?? 0
        return value
    }
}

extension MgnClientTypes.LaunchedInstance {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.LaunchedInstance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.LaunchedInstance()
        value.ec2InstanceID = try reader["ec2InstanceID"].readIfPresent()
        value.jobID = try reader["jobID"].readIfPresent()
        value.firstBoot = try reader["firstBoot"].readIfPresent()
        return value
    }
}

extension MgnClientTypes.DataReplicationInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.DataReplicationInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.DataReplicationInfo()
        value.lagDuration = try reader["lagDuration"].readIfPresent()
        value.etaDateTime = try reader["etaDateTime"].readIfPresent()
        value.replicatedDisks = try reader["replicatedDisks"].readListIfPresent(memberReadingClosure: MgnClientTypes.DataReplicationInfoReplicatedDisk.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dataReplicationState = try reader["dataReplicationState"].readIfPresent()
        value.dataReplicationInitiation = try reader["dataReplicationInitiation"].readIfPresent(with: MgnClientTypes.DataReplicationInitiation.read(from:))
        value.dataReplicationError = try reader["dataReplicationError"].readIfPresent(with: MgnClientTypes.DataReplicationError.read(from:))
        value.lastSnapshotDateTime = try reader["lastSnapshotDateTime"].readIfPresent()
        return value
    }
}

extension MgnClientTypes.DataReplicationError {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.DataReplicationError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.DataReplicationError()
        value.error = try reader["error"].readIfPresent()
        value.rawError = try reader["rawError"].readIfPresent()
        return value
    }
}

extension MgnClientTypes.DataReplicationInitiation {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.DataReplicationInitiation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.DataReplicationInitiation()
        value.startDateTime = try reader["startDateTime"].readIfPresent()
        value.nextAttemptDateTime = try reader["nextAttemptDateTime"].readIfPresent()
        value.steps = try reader["steps"].readListIfPresent(memberReadingClosure: MgnClientTypes.DataReplicationInitiationStep.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension MgnClientTypes.DataReplicationInitiationStep {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.DataReplicationInitiationStep {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.DataReplicationInitiationStep()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension MgnClientTypes.DataReplicationInfoReplicatedDisk {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.DataReplicationInfoReplicatedDisk {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.DataReplicationInfoReplicatedDisk()
        value.deviceName = try reader["deviceName"].readIfPresent()
        value.totalStorageBytes = try reader["totalStorageBytes"].readIfPresent() ?? 0
        value.replicatedStorageBytes = try reader["replicatedStorageBytes"].readIfPresent() ?? 0
        value.rescannedStorageBytes = try reader["rescannedStorageBytes"].readIfPresent() ?? 0
        value.backloggedStorageBytes = try reader["backloggedStorageBytes"].readIfPresent() ?? 0
        return value
    }
}

extension MgnClientTypes.LifeCycle {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.LifeCycle {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.LifeCycle()
        value.addedToServiceDateTime = try reader["addedToServiceDateTime"].readIfPresent()
        value.firstByteDateTime = try reader["firstByteDateTime"].readIfPresent()
        value.elapsedReplicationDuration = try reader["elapsedReplicationDuration"].readIfPresent()
        value.lastSeenByServiceDateTime = try reader["lastSeenByServiceDateTime"].readIfPresent()
        value.lastTest = try reader["lastTest"].readIfPresent(with: MgnClientTypes.LifeCycleLastTest.read(from:))
        value.lastCutover = try reader["lastCutover"].readIfPresent(with: MgnClientTypes.LifeCycleLastCutover.read(from:))
        value.state = try reader["state"].readIfPresent()
        return value
    }
}

extension MgnClientTypes.LifeCycleLastCutover {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.LifeCycleLastCutover {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.LifeCycleLastCutover()
        value.initiated = try reader["initiated"].readIfPresent(with: MgnClientTypes.LifeCycleLastCutoverInitiated.read(from:))
        value.reverted = try reader["reverted"].readIfPresent(with: MgnClientTypes.LifeCycleLastCutoverReverted.read(from:))
        value.finalized = try reader["finalized"].readIfPresent(with: MgnClientTypes.LifeCycleLastCutoverFinalized.read(from:))
        return value
    }
}

extension MgnClientTypes.LifeCycleLastCutoverFinalized {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.LifeCycleLastCutoverFinalized {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.LifeCycleLastCutoverFinalized()
        value.apiCallDateTime = try reader["apiCallDateTime"].readIfPresent()
        return value
    }
}

extension MgnClientTypes.LifeCycleLastCutoverReverted {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.LifeCycleLastCutoverReverted {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.LifeCycleLastCutoverReverted()
        value.apiCallDateTime = try reader["apiCallDateTime"].readIfPresent()
        return value
    }
}

extension MgnClientTypes.LifeCycleLastCutoverInitiated {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.LifeCycleLastCutoverInitiated {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.LifeCycleLastCutoverInitiated()
        value.apiCallDateTime = try reader["apiCallDateTime"].readIfPresent()
        value.jobID = try reader["jobID"].readIfPresent()
        return value
    }
}

extension MgnClientTypes.LifeCycleLastTest {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.LifeCycleLastTest {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.LifeCycleLastTest()
        value.initiated = try reader["initiated"].readIfPresent(with: MgnClientTypes.LifeCycleLastTestInitiated.read(from:))
        value.reverted = try reader["reverted"].readIfPresent(with: MgnClientTypes.LifeCycleLastTestReverted.read(from:))
        value.finalized = try reader["finalized"].readIfPresent(with: MgnClientTypes.LifeCycleLastTestFinalized.read(from:))
        return value
    }
}

extension MgnClientTypes.LifeCycleLastTestFinalized {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.LifeCycleLastTestFinalized {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.LifeCycleLastTestFinalized()
        value.apiCallDateTime = try reader["apiCallDateTime"].readIfPresent()
        return value
    }
}

extension MgnClientTypes.LifeCycleLastTestReverted {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.LifeCycleLastTestReverted {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.LifeCycleLastTestReverted()
        value.apiCallDateTime = try reader["apiCallDateTime"].readIfPresent()
        return value
    }
}

extension MgnClientTypes.LifeCycleLastTestInitiated {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.LifeCycleLastTestInitiated {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.LifeCycleLastTestInitiated()
        value.apiCallDateTime = try reader["apiCallDateTime"].readIfPresent()
        value.jobID = try reader["jobID"].readIfPresent()
        return value
    }
}

extension MgnClientTypes.SourceProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.SourceProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.SourceProperties()
        value.lastUpdatedDateTime = try reader["lastUpdatedDateTime"].readIfPresent()
        value.recommendedInstanceType = try reader["recommendedInstanceType"].readIfPresent()
        value.identificationHints = try reader["identificationHints"].readIfPresent(with: MgnClientTypes.IdentificationHints.read(from:))
        value.networkInterfaces = try reader["networkInterfaces"].readListIfPresent(memberReadingClosure: MgnClientTypes.NetworkInterface.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.disks = try reader["disks"].readListIfPresent(memberReadingClosure: MgnClientTypes.Disk.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.cpus = try reader["cpus"].readListIfPresent(memberReadingClosure: MgnClientTypes.CPU.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ramBytes = try reader["ramBytes"].readIfPresent() ?? 0
        value.os = try reader["os"].readIfPresent(with: MgnClientTypes.OS.read(from:))
        return value
    }
}

extension MgnClientTypes.OS {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.OS {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.OS()
        value.fullString = try reader["fullString"].readIfPresent()
        return value
    }
}

extension MgnClientTypes.CPU {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.CPU {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.CPU()
        value.cores = try reader["cores"].readIfPresent() ?? 0
        value.modelName = try reader["modelName"].readIfPresent()
        return value
    }
}

extension MgnClientTypes.Disk {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.Disk {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.Disk()
        value.deviceName = try reader["deviceName"].readIfPresent()
        value.bytes = try reader["bytes"].readIfPresent() ?? 0
        return value
    }
}

extension MgnClientTypes.NetworkInterface {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.NetworkInterface {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.NetworkInterface()
        value.macAddress = try reader["macAddress"].readIfPresent()
        value.ips = try reader["ips"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.isPrimary = try reader["isPrimary"].readIfPresent()
        return value
    }
}

extension MgnClientTypes.IdentificationHints {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.IdentificationHints {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.IdentificationHints()
        value.fqdn = try reader["fqdn"].readIfPresent()
        value.hostname = try reader["hostname"].readIfPresent()
        value.vmWareUuid = try reader["vmWareUuid"].readIfPresent()
        value.awsInstanceID = try reader["awsInstanceID"].readIfPresent()
        value.vmPath = try reader["vmPath"].readIfPresent()
        return value
    }
}

extension MgnClientTypes.SourceServerConnectorAction {

    static func write(value: MgnClientTypes.SourceServerConnectorAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectorArn"].write(value.connectorArn)
        try writer["credentialsSecretArn"].write(value.credentialsSecretArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.SourceServerConnectorAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.SourceServerConnectorAction()
        value.credentialsSecretArn = try reader["credentialsSecretArn"].readIfPresent()
        value.connectorArn = try reader["connectorArn"].readIfPresent()
        return value
    }
}

extension MgnClientTypes.ConnectorSsmCommandConfig {

    static func write(value: MgnClientTypes.ConnectorSsmCommandConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudWatchLogGroupName"].write(value.cloudWatchLogGroupName)
        try writer["cloudWatchOutputEnabled"].write(value.cloudWatchOutputEnabled)
        try writer["outputS3BucketName"].write(value.outputS3BucketName)
        try writer["s3OutputEnabled"].write(value.s3OutputEnabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.ConnectorSsmCommandConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.ConnectorSsmCommandConfig()
        value.s3OutputEnabled = try reader["s3OutputEnabled"].readIfPresent() ?? false
        value.outputS3BucketName = try reader["outputS3BucketName"].readIfPresent()
        value.cloudWatchOutputEnabled = try reader["cloudWatchOutputEnabled"].readIfPresent() ?? false
        value.cloudWatchLogGroupName = try reader["cloudWatchLogGroupName"].readIfPresent()
        return value
    }
}

extension MgnClientTypes.PostLaunchActions {

    static func write(value: MgnClientTypes.PostLaunchActions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudWatchLogGroupName"].write(value.cloudWatchLogGroupName)
        try writer["deployment"].write(value.deployment)
        try writer["s3LogBucket"].write(value.s3LogBucket)
        try writer["s3OutputKeyPrefix"].write(value.s3OutputKeyPrefix)
        try writer["ssmDocuments"].writeList(value.ssmDocuments, memberWritingClosure: MgnClientTypes.SsmDocument.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.PostLaunchActions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.PostLaunchActions()
        value.deployment = try reader["deployment"].readIfPresent()
        value.s3LogBucket = try reader["s3LogBucket"].readIfPresent()
        value.s3OutputKeyPrefix = try reader["s3OutputKeyPrefix"].readIfPresent()
        value.cloudWatchLogGroupName = try reader["cloudWatchLogGroupName"].readIfPresent()
        value.ssmDocuments = try reader["ssmDocuments"].readListIfPresent(memberReadingClosure: MgnClientTypes.SsmDocument.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension MgnClientTypes.SsmDocument {

    static func write(value: MgnClientTypes.SsmDocument?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionName"].write(value.actionName)
        try writer["externalParameters"].writeMap(value.externalParameters, valueWritingClosure: MgnClientTypes.SsmExternalParameter.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["mustSucceedForCutover"].write(value.mustSucceedForCutover)
        try writer["parameters"].writeMap(value.parameters, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: MgnClientTypes.SsmParameterStoreParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ssmDocumentName"].write(value.ssmDocumentName)
        try writer["timeoutSeconds"].write(value.timeoutSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.SsmDocument {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.SsmDocument()
        value.actionName = try reader["actionName"].readIfPresent() ?? ""
        value.ssmDocumentName = try reader["ssmDocumentName"].readIfPresent() ?? ""
        value.timeoutSeconds = try reader["timeoutSeconds"].readIfPresent()
        value.mustSucceedForCutover = try reader["mustSucceedForCutover"].readIfPresent()
        value.parameters = try reader["parameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: MgnClientTypes.SsmParameterStoreParameter.read(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.externalParameters = try reader["externalParameters"].readMapIfPresent(valueReadingClosure: MgnClientTypes.SsmExternalParameter.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension MgnClientTypes.SsmExternalParameter {

    static func write(value: MgnClientTypes.SsmExternalParameter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .dynamicpath(dynamicpath):
                try writer["dynamicPath"].write(dynamicpath)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.SsmExternalParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "dynamicPath":
                return .dynamicpath(try reader["dynamicPath"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MgnClientTypes.SsmParameterStoreParameter {

    static func write(value: MgnClientTypes.SsmParameterStoreParameter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["parameterName"].write(value.parameterName)
        try writer["parameterType"].write(value.parameterType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.SsmParameterStoreParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.SsmParameterStoreParameter()
        value.parameterType = try reader["parameterType"].readIfPresent() ?? .sdkUnknown("")
        value.parameterName = try reader["parameterName"].readIfPresent() ?? ""
        return value
    }
}

extension MgnClientTypes.Licensing {

    static func write(value: MgnClientTypes.Licensing?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["osByol"].write(value.osByol)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.Licensing {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.Licensing()
        value.osByol = try reader["osByol"].readIfPresent()
        return value
    }
}

extension MgnClientTypes.LaunchTemplateDiskConf {

    static func write(value: MgnClientTypes.LaunchTemplateDiskConf?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["iops"].write(value.iops)
        try writer["throughput"].write(value.throughput)
        try writer["volumeType"].write(value.volumeType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.LaunchTemplateDiskConf {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.LaunchTemplateDiskConf()
        value.volumeType = try reader["volumeType"].readIfPresent()
        value.iops = try reader["iops"].readIfPresent()
        value.throughput = try reader["throughput"].readIfPresent()
        return value
    }
}

extension MgnClientTypes.JobLog {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.JobLog {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.JobLog()
        value.logDateTime = try reader["logDateTime"].readIfPresent()
        value.event = try reader["event"].readIfPresent()
        value.eventData = try reader["eventData"].readIfPresent(with: MgnClientTypes.JobLogEventData.read(from:))
        return value
    }
}

extension MgnClientTypes.JobLogEventData {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.JobLogEventData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.JobLogEventData()
        value.sourceServerID = try reader["sourceServerID"].readIfPresent()
        value.conversionServerID = try reader["conversionServerID"].readIfPresent()
        value.targetInstanceID = try reader["targetInstanceID"].readIfPresent()
        value.rawError = try reader["rawError"].readIfPresent()
        return value
    }
}

extension MgnClientTypes.Job {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.Job {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.Job()
        value.jobID = try reader["jobID"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.initiatedBy = try reader["initiatedBy"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readIfPresent()
        value.endDateTime = try reader["endDateTime"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.participatingServers = try reader["participatingServers"].readListIfPresent(memberReadingClosure: MgnClientTypes.ParticipatingServer.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension MgnClientTypes.ParticipatingServer {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.ParticipatingServer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.ParticipatingServer()
        value.sourceServerID = try reader["sourceServerID"].readIfPresent() ?? ""
        value.launchStatus = try reader["launchStatus"].readIfPresent()
        value.launchedEc2InstanceID = try reader["launchedEc2InstanceID"].readIfPresent()
        value.postLaunchActionsStatus = try reader["postLaunchActionsStatus"].readIfPresent(with: MgnClientTypes.PostLaunchActionsStatus.read(from:))
        return value
    }
}

extension MgnClientTypes.PostLaunchActionsStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.PostLaunchActionsStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.PostLaunchActionsStatus()
        value.ssmAgentDiscoveryDatetime = try reader["ssmAgentDiscoveryDatetime"].readIfPresent()
        value.postLaunchActionsLaunchStatusList = try reader["postLaunchActionsLaunchStatusList"].readListIfPresent(memberReadingClosure: MgnClientTypes.JobPostLaunchActionsLaunchStatus.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension MgnClientTypes.JobPostLaunchActionsLaunchStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.JobPostLaunchActionsLaunchStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.JobPostLaunchActionsLaunchStatus()
        value.ssmDocument = try reader["ssmDocument"].readIfPresent(with: MgnClientTypes.SsmDocument.read(from:))
        value.ssmDocumentType = try reader["ssmDocumentType"].readIfPresent()
        value.executionID = try reader["executionID"].readIfPresent()
        value.executionStatus = try reader["executionStatus"].readIfPresent()
        value.failureReason = try reader["failureReason"].readIfPresent()
        return value
    }
}

extension MgnClientTypes.LaunchConfigurationTemplate {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.LaunchConfigurationTemplate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.LaunchConfigurationTemplate()
        value.launchConfigurationTemplateID = try reader["launchConfigurationTemplateID"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent()
        value.postLaunchActions = try reader["postLaunchActions"].readIfPresent(with: MgnClientTypes.PostLaunchActions.read(from:))
        value.enableMapAutoTagging = try reader["enableMapAutoTagging"].readIfPresent()
        value.mapAutoTaggingMpeID = try reader["mapAutoTaggingMpeID"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.ec2LaunchTemplateID = try reader["ec2LaunchTemplateID"].readIfPresent()
        value.launchDisposition = try reader["launchDisposition"].readIfPresent()
        value.targetInstanceTypeRightSizingMethod = try reader["targetInstanceTypeRightSizingMethod"].readIfPresent()
        value.copyPrivateIp = try reader["copyPrivateIp"].readIfPresent()
        value.associatePublicIpAddress = try reader["associatePublicIpAddress"].readIfPresent()
        value.copyTags = try reader["copyTags"].readIfPresent()
        value.licensing = try reader["licensing"].readIfPresent(with: MgnClientTypes.Licensing.read(from:))
        value.bootMode = try reader["bootMode"].readIfPresent()
        value.smallVolumeMaxSize = try reader["smallVolumeMaxSize"].readIfPresent() ?? 0
        value.smallVolumeConf = try reader["smallVolumeConf"].readIfPresent(with: MgnClientTypes.LaunchTemplateDiskConf.read(from:))
        value.largeVolumeConf = try reader["largeVolumeConf"].readIfPresent(with: MgnClientTypes.LaunchTemplateDiskConf.read(from:))
        return value
    }
}

extension MgnClientTypes.ReplicationConfigurationTemplate {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.ReplicationConfigurationTemplate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.ReplicationConfigurationTemplate()
        value.replicationConfigurationTemplateID = try reader["replicationConfigurationTemplateID"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent()
        value.stagingAreaSubnetId = try reader["stagingAreaSubnetId"].readIfPresent()
        value.associateDefaultSecurityGroup = try reader["associateDefaultSecurityGroup"].readIfPresent()
        value.replicationServersSecurityGroupsIDs = try reader["replicationServersSecurityGroupsIDs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.replicationServerInstanceType = try reader["replicationServerInstanceType"].readIfPresent()
        value.useDedicatedReplicationServer = try reader["useDedicatedReplicationServer"].readIfPresent()
        value.defaultLargeStagingDiskType = try reader["defaultLargeStagingDiskType"].readIfPresent()
        value.ebsEncryption = try reader["ebsEncryption"].readIfPresent()
        value.ebsEncryptionKeyArn = try reader["ebsEncryptionKeyArn"].readIfPresent()
        value.bandwidthThrottling = try reader["bandwidthThrottling"].readIfPresent() ?? 0
        value.dataPlaneRouting = try reader["dataPlaneRouting"].readIfPresent()
        value.createPublicIP = try reader["createPublicIP"].readIfPresent()
        value.stagingAreaTags = try reader["stagingAreaTags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.useFipsEndpoint = try reader["useFipsEndpoint"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension MgnClientTypes.SourceServer {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.SourceServer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.SourceServer()
        value.sourceServerID = try reader["sourceServerID"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.isArchived = try reader["isArchived"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.launchedInstance = try reader["launchedInstance"].readIfPresent(with: MgnClientTypes.LaunchedInstance.read(from:))
        value.dataReplicationInfo = try reader["dataReplicationInfo"].readIfPresent(with: MgnClientTypes.DataReplicationInfo.read(from:))
        value.lifeCycle = try reader["lifeCycle"].readIfPresent(with: MgnClientTypes.LifeCycle.read(from:))
        value.sourceProperties = try reader["sourceProperties"].readIfPresent(with: MgnClientTypes.SourceProperties.read(from:))
        value.replicationType = try reader["replicationType"].readIfPresent()
        value.vcenterClientID = try reader["vcenterClientID"].readIfPresent()
        value.applicationID = try reader["applicationID"].readIfPresent()
        value.userProvidedID = try reader["userProvidedID"].readIfPresent()
        value.fqdnForActionFramework = try reader["fqdnForActionFramework"].readIfPresent()
        value.connectorAction = try reader["connectorAction"].readIfPresent(with: MgnClientTypes.SourceServerConnectorAction.read(from:))
        return value
    }
}

extension MgnClientTypes.VcenterClient {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.VcenterClient {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.VcenterClient()
        value.vcenterClientID = try reader["vcenterClientID"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.hostname = try reader["hostname"].readIfPresent()
        value.vcenterUUID = try reader["vcenterUUID"].readIfPresent()
        value.datacenterName = try reader["datacenterName"].readIfPresent()
        value.lastSeenDatetime = try reader["lastSeenDatetime"].readIfPresent()
        value.sourceServerTags = try reader["sourceServerTags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension MgnClientTypes.ReplicationConfigurationReplicatedDisk {

    static func write(value: MgnClientTypes.ReplicationConfigurationReplicatedDisk?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["deviceName"].write(value.deviceName)
        try writer["iops"].write(value.iops)
        try writer["isBootDisk"].write(value.isBootDisk)
        try writer["stagingDiskType"].write(value.stagingDiskType)
        try writer["throughput"].write(value.throughput)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.ReplicationConfigurationReplicatedDisk {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.ReplicationConfigurationReplicatedDisk()
        value.deviceName = try reader["deviceName"].readIfPresent()
        value.isBootDisk = try reader["isBootDisk"].readIfPresent()
        value.stagingDiskType = try reader["stagingDiskType"].readIfPresent()
        value.iops = try reader["iops"].readIfPresent() ?? 0
        value.throughput = try reader["throughput"].readIfPresent() ?? 0
        return value
    }
}

extension MgnClientTypes.Application {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.Application {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.Application()
        value.applicationID = try reader["applicationID"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.isArchived = try reader["isArchived"].readIfPresent()
        value.applicationAggregatedStatus = try reader["applicationAggregatedStatus"].readIfPresent(with: MgnClientTypes.ApplicationAggregatedStatus.read(from:))
        value.creationDateTime = try reader["creationDateTime"].readIfPresent()
        value.lastModifiedDateTime = try reader["lastModifiedDateTime"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.waveID = try reader["waveID"].readIfPresent()
        return value
    }
}

extension MgnClientTypes.Connector {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.Connector {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.Connector()
        value.connectorID = try reader["connectorID"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.ssmInstanceID = try reader["ssmInstanceID"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.ssmCommandConfig = try reader["ssmCommandConfig"].readIfPresent(with: MgnClientTypes.ConnectorSsmCommandConfig.read(from:))
        return value
    }
}

extension MgnClientTypes.ExportTaskError {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.ExportTaskError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.ExportTaskError()
        value.errorDateTime = try reader["errorDateTime"].readIfPresent()
        value.errorData = try reader["errorData"].readIfPresent(with: MgnClientTypes.ExportErrorData.read(from:))
        return value
    }
}

extension MgnClientTypes.ExportErrorData {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.ExportErrorData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.ExportErrorData()
        value.rawError = try reader["rawError"].readIfPresent()
        return value
    }
}

extension MgnClientTypes.ExportTask {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.ExportTask {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.ExportTask()
        value.exportID = try reader["exportID"].readIfPresent()
        value.s3Bucket = try reader["s3Bucket"].readIfPresent()
        value.s3Key = try reader["s3Key"].readIfPresent()
        value.s3BucketOwner = try reader["s3BucketOwner"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readIfPresent()
        value.endDateTime = try reader["endDateTime"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.progressPercentage = try reader["progressPercentage"].readIfPresent()
        value.summary = try reader["summary"].readIfPresent(with: MgnClientTypes.ExportTaskSummary.read(from:))
        return value
    }
}

extension MgnClientTypes.ExportTaskSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.ExportTaskSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.ExportTaskSummary()
        value.serversCount = try reader["serversCount"].readIfPresent() ?? 0
        value.applicationsCount = try reader["applicationsCount"].readIfPresent() ?? 0
        value.wavesCount = try reader["wavesCount"].readIfPresent() ?? 0
        return value
    }
}

extension MgnClientTypes.ImportTaskError {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.ImportTaskError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.ImportTaskError()
        value.errorDateTime = try reader["errorDateTime"].readIfPresent()
        value.errorType = try reader["errorType"].readIfPresent()
        value.errorData = try reader["errorData"].readIfPresent(with: MgnClientTypes.ImportErrorData.read(from:))
        return value
    }
}

extension MgnClientTypes.ImportErrorData {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.ImportErrorData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.ImportErrorData()
        value.sourceServerID = try reader["sourceServerID"].readIfPresent()
        value.applicationID = try reader["applicationID"].readIfPresent()
        value.waveID = try reader["waveID"].readIfPresent()
        value.ec2LaunchTemplateID = try reader["ec2LaunchTemplateID"].readIfPresent()
        value.rowNumber = try reader["rowNumber"].readIfPresent() ?? 0
        value.rawError = try reader["rawError"].readIfPresent()
        value.accountID = try reader["accountID"].readIfPresent()
        return value
    }
}

extension MgnClientTypes.ImportTask {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.ImportTask {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.ImportTask()
        value.importID = try reader["importID"].readIfPresent()
        value.s3BucketSource = try reader["s3BucketSource"].readIfPresent(with: MgnClientTypes.S3BucketSource.read(from:))
        value.creationDateTime = try reader["creationDateTime"].readIfPresent()
        value.endDateTime = try reader["endDateTime"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.progressPercentage = try reader["progressPercentage"].readIfPresent()
        value.summary = try reader["summary"].readIfPresent(with: MgnClientTypes.ImportTaskSummary.read(from:))
        return value
    }
}

extension MgnClientTypes.ImportTaskSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.ImportTaskSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.ImportTaskSummary()
        value.waves = try reader["waves"].readIfPresent(with: MgnClientTypes.ImportTaskSummaryWaves.read(from:))
        value.applications = try reader["applications"].readIfPresent(with: MgnClientTypes.ImportTaskSummaryApplications.read(from:))
        value.servers = try reader["servers"].readIfPresent(with: MgnClientTypes.ImportTaskSummaryServers.read(from:))
        return value
    }
}

extension MgnClientTypes.ImportTaskSummaryServers {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.ImportTaskSummaryServers {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.ImportTaskSummaryServers()
        value.createdCount = try reader["createdCount"].readIfPresent() ?? 0
        value.modifiedCount = try reader["modifiedCount"].readIfPresent() ?? 0
        return value
    }
}

extension MgnClientTypes.ImportTaskSummaryApplications {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.ImportTaskSummaryApplications {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.ImportTaskSummaryApplications()
        value.createdCount = try reader["createdCount"].readIfPresent() ?? 0
        value.modifiedCount = try reader["modifiedCount"].readIfPresent() ?? 0
        return value
    }
}

extension MgnClientTypes.ImportTaskSummaryWaves {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.ImportTaskSummaryWaves {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.ImportTaskSummaryWaves()
        value.createdCount = try reader["createdCount"].readIfPresent() ?? 0
        value.modifiedCount = try reader["modifiedCount"].readIfPresent() ?? 0
        return value
    }
}

extension MgnClientTypes.S3BucketSource {

    static func write(value: MgnClientTypes.S3BucketSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Bucket"].write(value.s3Bucket)
        try writer["s3BucketOwner"].write(value.s3BucketOwner)
        try writer["s3Key"].write(value.s3Key)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.S3BucketSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.S3BucketSource()
        value.s3Bucket = try reader["s3Bucket"].readIfPresent() ?? ""
        value.s3Key = try reader["s3Key"].readIfPresent() ?? ""
        value.s3BucketOwner = try reader["s3BucketOwner"].readIfPresent()
        return value
    }
}

extension MgnClientTypes.ManagedAccount {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.ManagedAccount {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.ManagedAccount()
        value.accountId = try reader["accountId"].readIfPresent()
        return value
    }
}

extension MgnClientTypes.SourceServerActionDocument {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.SourceServerActionDocument {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.SourceServerActionDocument()
        value.actionID = try reader["actionID"].readIfPresent()
        value.actionName = try reader["actionName"].readIfPresent()
        value.documentIdentifier = try reader["documentIdentifier"].readIfPresent()
        value.order = try reader["order"].readIfPresent()
        value.documentVersion = try reader["documentVersion"].readIfPresent()
        value.active = try reader["active"].readIfPresent()
        value.timeoutSeconds = try reader["timeoutSeconds"].readIfPresent()
        value.mustSucceedForCutover = try reader["mustSucceedForCutover"].readIfPresent()
        value.parameters = try reader["parameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: MgnClientTypes.SsmParameterStoreParameter.read(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.externalParameters = try reader["externalParameters"].readMapIfPresent(valueReadingClosure: MgnClientTypes.SsmExternalParameter.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.description = try reader["description"].readIfPresent()
        value.category = try reader["category"].readIfPresent()
        return value
    }
}

extension MgnClientTypes.TemplateActionDocument {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.TemplateActionDocument {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.TemplateActionDocument()
        value.actionID = try reader["actionID"].readIfPresent()
        value.actionName = try reader["actionName"].readIfPresent()
        value.documentIdentifier = try reader["documentIdentifier"].readIfPresent()
        value.order = try reader["order"].readIfPresent()
        value.documentVersion = try reader["documentVersion"].readIfPresent()
        value.active = try reader["active"].readIfPresent()
        value.timeoutSeconds = try reader["timeoutSeconds"].readIfPresent()
        value.mustSucceedForCutover = try reader["mustSucceedForCutover"].readIfPresent()
        value.parameters = try reader["parameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: MgnClientTypes.SsmParameterStoreParameter.read(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.operatingSystem = try reader["operatingSystem"].readIfPresent()
        value.externalParameters = try reader["externalParameters"].readMapIfPresent(valueReadingClosure: MgnClientTypes.SsmExternalParameter.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.description = try reader["description"].readIfPresent()
        value.category = try reader["category"].readIfPresent()
        return value
    }
}

extension MgnClientTypes.Wave {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.Wave {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.Wave()
        value.waveID = try reader["waveID"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.isArchived = try reader["isArchived"].readIfPresent()
        value.waveAggregatedStatus = try reader["waveAggregatedStatus"].readIfPresent(with: MgnClientTypes.WaveAggregatedStatus.read(from:))
        value.creationDateTime = try reader["creationDateTime"].readIfPresent()
        value.lastModifiedDateTime = try reader["lastModifiedDateTime"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension MgnClientTypes.ErrorDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.ErrorDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.ErrorDetails()
        value.message = try reader["message"].readIfPresent()
        value.code = try reader["code"].readIfPresent()
        value.resourceId = try reader["resourceId"].readIfPresent()
        value.resourceType = try reader["resourceType"].readIfPresent()
        return value
    }
}

extension MgnClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> MgnClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MgnClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension MgnClientTypes.ChangeServerLifeCycleStateSourceServerLifecycle {

    static func write(value: MgnClientTypes.ChangeServerLifeCycleStateSourceServerLifecycle?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["state"].write(value.state)
    }
}

extension MgnClientTypes.DescribeJobsRequestFilters {

    static func write(value: MgnClientTypes.DescribeJobsRequestFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fromDate"].write(value.fromDate)
        try writer["jobIDs"].writeList(value.jobIDs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["toDate"].write(value.toDate)
    }
}

extension MgnClientTypes.DescribeSourceServersRequestFilters {

    static func write(value: MgnClientTypes.DescribeSourceServersRequestFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["applicationIDs"].writeList(value.applicationIDs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["isArchived"].write(value.isArchived)
        try writer["lifeCycleStates"].writeList(value.lifeCycleStates, memberWritingClosure: SmithyReadWrite.WritingClosureBox<MgnClientTypes.LifeCycleState>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["replicationTypes"].writeList(value.replicationTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<MgnClientTypes.ReplicationType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["sourceServerIDs"].writeList(value.sourceServerIDs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension MgnClientTypes.ListApplicationsRequestFilters {

    static func write(value: MgnClientTypes.ListApplicationsRequestFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["applicationIDs"].writeList(value.applicationIDs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["isArchived"].write(value.isArchived)
        try writer["waveIDs"].writeList(value.waveIDs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension MgnClientTypes.ListConnectorsRequestFilters {

    static func write(value: MgnClientTypes.ListConnectorsRequestFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectorIDs"].writeList(value.connectorIDs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension MgnClientTypes.ListExportsRequestFilters {

    static func write(value: MgnClientTypes.ListExportsRequestFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["exportIDs"].writeList(value.exportIDs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension MgnClientTypes.ListImportsRequestFilters {

    static func write(value: MgnClientTypes.ListImportsRequestFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["importIDs"].writeList(value.importIDs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension MgnClientTypes.SourceServerActionsRequestFilters {

    static func write(value: MgnClientTypes.SourceServerActionsRequestFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionIDs"].writeList(value.actionIDs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension MgnClientTypes.TemplateActionsRequestFilters {

    static func write(value: MgnClientTypes.TemplateActionsRequestFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionIDs"].writeList(value.actionIDs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension MgnClientTypes.ListWavesRequestFilters {

    static func write(value: MgnClientTypes.ListWavesRequestFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["isArchived"].write(value.isArchived)
        try writer["waveIDs"].writeList(value.waveIDs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public enum MgnClientTypes {}
