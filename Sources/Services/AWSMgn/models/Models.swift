// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Operating denied due to a file permission or access check error.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody {
    let message: Swift.String?
    let code: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension MgnClientTypes {
    public enum ActionCategory: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case backup
        case configuration
        case disasterRecovery
        case licenseAndSubscription
        case networking
        case observability
        case operatingSystem
        case other
        case refactoring
        case security
        case validation
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionCategory] {
            return [
                .backup,
                .configuration,
                .disasterRecovery,
                .licenseAndSubscription,
                .networking,
                .observability,
                .operatingSystem,
                .other,
                .refactoring,
                .security,
                .validation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .backup: return "BACKUP"
            case .configuration: return "CONFIGURATION"
            case .disasterRecovery: return "DISASTER_RECOVERY"
            case .licenseAndSubscription: return "LICENSE_AND_SUBSCRIPTION"
            case .networking: return "NETWORKING"
            case .observability: return "OBSERVABILITY"
            case .operatingSystem: return "OPERATING_SYSTEM"
            case .other: return "OTHER"
            case .refactoring: return "REFACTORING"
            case .security: return "SECURITY"
            case .validation: return "VALIDATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActionCategory(rawValue: rawValue) ?? ActionCategory.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes.Application: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationAggregatedStatus
        case applicationID
        case arn
        case creationDateTime
        case description
        case isArchived
        case lastModifiedDateTime
        case name
        case tags
        case waveID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationAggregatedStatus = self.applicationAggregatedStatus {
            try encodeContainer.encode(applicationAggregatedStatus, forKey: .applicationAggregatedStatus)
        }
        if let applicationID = self.applicationID {
            try encodeContainer.encode(applicationID, forKey: .applicationID)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encode(creationDateTime, forKey: .creationDateTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let isArchived = self.isArchived {
            try encodeContainer.encode(isArchived, forKey: .isArchived)
        }
        if let lastModifiedDateTime = self.lastModifiedDateTime {
            try encodeContainer.encode(lastModifiedDateTime, forKey: .lastModifiedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let waveID = self.waveID {
            try encodeContainer.encode(waveID, forKey: .waveID)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let applicationAggregatedStatusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ApplicationAggregatedStatus.self, forKey: .applicationAggregatedStatus)
        applicationAggregatedStatus = applicationAggregatedStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastModifiedDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedDateTime)
        lastModifiedDateTime = lastModifiedDateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let waveIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .waveID)
        waveID = waveIDDecoded
    }
}

extension MgnClientTypes.Application: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Application(applicationAggregatedStatus: \(Swift.String(describing: applicationAggregatedStatus)), applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), creationDateTime: \(Swift.String(describing: creationDateTime)), description: \(Swift.String(describing: description)), isArchived: \(Swift.String(describing: isArchived)), lastModifiedDateTime: \(Swift.String(describing: lastModifiedDateTime)), name: \(Swift.String(describing: name)), waveID: \(Swift.String(describing: waveID)), tags: \"CONTENT_REDACTED\")"}
}

extension MgnClientTypes {
    public struct Application {
        /// Application aggregated status.
        public var applicationAggregatedStatus: MgnClientTypes.ApplicationAggregatedStatus?
        /// Application ID.
        public var applicationID: Swift.String?
        /// Application ARN.
        public var arn: Swift.String?
        /// Application creation dateTime.
        public var creationDateTime: Swift.String?
        /// Application description.
        public var description: Swift.String?
        /// Application archival status.
        public var isArchived: Swift.Bool?
        /// Application last modified dateTime.
        public var lastModifiedDateTime: Swift.String?
        /// Application name.
        public var name: Swift.String?
        /// Application tags.
        public var tags: [Swift.String:Swift.String]?
        /// Application wave ID.
        public var waveID: Swift.String?

        public init(
            applicationAggregatedStatus: MgnClientTypes.ApplicationAggregatedStatus? = nil,
            applicationID: Swift.String? = nil,
            arn: Swift.String? = nil,
            creationDateTime: Swift.String? = nil,
            description: Swift.String? = nil,
            isArchived: Swift.Bool? = nil,
            lastModifiedDateTime: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            waveID: Swift.String? = nil
        )
        {
            self.applicationAggregatedStatus = applicationAggregatedStatus
            self.applicationID = applicationID
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.description = description
            self.isArchived = isArchived
            self.lastModifiedDateTime = lastModifiedDateTime
            self.name = name
            self.tags = tags
            self.waveID = waveID
        }
    }

}

extension MgnClientTypes.ApplicationAggregatedStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthStatus
        case lastUpdateDateTime
        case progressStatus
        case totalSourceServers
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let healthStatus = self.healthStatus {
            try encodeContainer.encode(healthStatus.rawValue, forKey: .healthStatus)
        }
        if let lastUpdateDateTime = self.lastUpdateDateTime {
            try encodeContainer.encode(lastUpdateDateTime, forKey: .lastUpdateDateTime)
        }
        if let progressStatus = self.progressStatus {
            try encodeContainer.encode(progressStatus.rawValue, forKey: .progressStatus)
        }
        if totalSourceServers != 0 {
            try encodeContainer.encode(totalSourceServers, forKey: .totalSourceServers)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastUpdateDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdateDateTime)
        lastUpdateDateTime = lastUpdateDateTimeDecoded
        let healthStatusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ApplicationHealthStatus.self, forKey: .healthStatus)
        healthStatus = healthStatusDecoded
        let progressStatusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ApplicationProgressStatus.self, forKey: .progressStatus)
        progressStatus = progressStatusDecoded
        let totalSourceServersDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalSourceServers) ?? 0
        totalSourceServers = totalSourceServersDecoded
    }
}

extension MgnClientTypes {
    /// Application aggregated status.
    public struct ApplicationAggregatedStatus {
        /// Application aggregated status health status.
        public var healthStatus: MgnClientTypes.ApplicationHealthStatus?
        /// Application aggregated status last update dateTime.
        public var lastUpdateDateTime: Swift.String?
        /// Application aggregated status progress status.
        public var progressStatus: MgnClientTypes.ApplicationProgressStatus?
        /// Application aggregated status total source servers amount.
        public var totalSourceServers: Swift.Int

        public init(
            healthStatus: MgnClientTypes.ApplicationHealthStatus? = nil,
            lastUpdateDateTime: Swift.String? = nil,
            progressStatus: MgnClientTypes.ApplicationProgressStatus? = nil,
            totalSourceServers: Swift.Int = 0
        )
        {
            self.healthStatus = healthStatus
            self.lastUpdateDateTime = lastUpdateDateTime
            self.progressStatus = progressStatus
            self.totalSourceServers = totalSourceServers
        }
    }

}

extension MgnClientTypes {
    public enum ApplicationHealthStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case healthy
        case lagging
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationHealthStatus] {
            return [
                .error,
                .healthy,
                .lagging,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .healthy: return "HEALTHY"
            case .lagging: return "LAGGING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationHealthStatus(rawValue: rawValue) ?? ApplicationHealthStatus.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes {
    public enum ApplicationProgressStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case inProgress
        case notStarted
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationProgressStatus] {
            return [
                .completed,
                .inProgress,
                .notStarted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationProgressStatus(rawValue: rawValue) ?? ApplicationProgressStatus.sdkUnknown(rawValue)
        }
    }
}

extension ArchiveApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case applicationID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let applicationID = self.applicationID {
            try encodeContainer.encode(applicationID, forKey: .applicationID)
        }
    }
}

extension ArchiveApplicationInput {

    static func urlPathProvider(_ value: ArchiveApplicationInput) -> Swift.String? {
        return "/ArchiveApplication"
    }
}

public struct ArchiveApplicationInput {
    /// Account ID.
    public var accountID: Swift.String?
    /// Application ID.
    /// This member is required.
    public var applicationID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        applicationID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.applicationID = applicationID
    }
}

struct ArchiveApplicationInputBody {
    let applicationID: Swift.String?
    let accountID: Swift.String?
}

extension ArchiveApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case applicationID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension ArchiveApplicationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ArchiveApplicationOutput(applicationAggregatedStatus: \(Swift.String(describing: applicationAggregatedStatus)), applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), creationDateTime: \(Swift.String(describing: creationDateTime)), description: \(Swift.String(describing: description)), isArchived: \(Swift.String(describing: isArchived)), lastModifiedDateTime: \(Swift.String(describing: lastModifiedDateTime)), name: \(Swift.String(describing: name)), waveID: \(Swift.String(describing: waveID)), tags: \"CONTENT_REDACTED\")"}
}

extension ArchiveApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ArchiveApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationAggregatedStatus = output.applicationAggregatedStatus
            self.applicationID = output.applicationID
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.isArchived = output.isArchived
            self.lastModifiedDateTime = output.lastModifiedDateTime
            self.name = output.name
            self.tags = output.tags
            self.waveID = output.waveID
        } else {
            self.applicationAggregatedStatus = nil
            self.applicationID = nil
            self.arn = nil
            self.creationDateTime = nil
            self.description = nil
            self.isArchived = nil
            self.lastModifiedDateTime = nil
            self.name = nil
            self.tags = nil
            self.waveID = nil
        }
    }
}

public struct ArchiveApplicationOutput {
    /// Application aggregated status.
    public var applicationAggregatedStatus: MgnClientTypes.ApplicationAggregatedStatus?
    /// Application ID.
    public var applicationID: Swift.String?
    /// Application ARN.
    public var arn: Swift.String?
    /// Application creation dateTime.
    public var creationDateTime: Swift.String?
    /// Application description.
    public var description: Swift.String?
    /// Application archival status.
    public var isArchived: Swift.Bool?
    /// Application last modified dateTime.
    public var lastModifiedDateTime: Swift.String?
    /// Application name.
    public var name: Swift.String?
    /// Application tags.
    public var tags: [Swift.String:Swift.String]?
    /// Application wave ID.
    public var waveID: Swift.String?

    public init(
        applicationAggregatedStatus: MgnClientTypes.ApplicationAggregatedStatus? = nil,
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        creationDateTime: Swift.String? = nil,
        description: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        lastModifiedDateTime: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        waveID: Swift.String? = nil
    )
    {
        self.applicationAggregatedStatus = applicationAggregatedStatus
        self.applicationID = applicationID
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.description = description
        self.isArchived = isArchived
        self.lastModifiedDateTime = lastModifiedDateTime
        self.name = name
        self.tags = tags
        self.waveID = waveID
    }
}

struct ArchiveApplicationOutputBody {
    let applicationID: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let isArchived: Swift.Bool?
    let applicationAggregatedStatus: MgnClientTypes.ApplicationAggregatedStatus?
    let creationDateTime: Swift.String?
    let lastModifiedDateTime: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let waveID: Swift.String?
}

extension ArchiveApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationAggregatedStatus
        case applicationID
        case arn
        case creationDateTime
        case description
        case isArchived
        case lastModifiedDateTime
        case name
        case tags
        case waveID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let applicationAggregatedStatusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ApplicationAggregatedStatus.self, forKey: .applicationAggregatedStatus)
        applicationAggregatedStatus = applicationAggregatedStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastModifiedDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedDateTime)
        lastModifiedDateTime = lastModifiedDateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let waveIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .waveID)
        waveID = waveIDDecoded
    }
}

enum ArchiveApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ArchiveWaveInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case waveID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let waveID = self.waveID {
            try encodeContainer.encode(waveID, forKey: .waveID)
        }
    }
}

extension ArchiveWaveInput {

    static func urlPathProvider(_ value: ArchiveWaveInput) -> Swift.String? {
        return "/ArchiveWave"
    }
}

public struct ArchiveWaveInput {
    /// Account ID.
    public var accountID: Swift.String?
    /// Wave ID.
    /// This member is required.
    public var waveID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        waveID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.waveID = waveID
    }
}

struct ArchiveWaveInputBody {
    let waveID: Swift.String?
    let accountID: Swift.String?
}

extension ArchiveWaveInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case waveID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let waveIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .waveID)
        waveID = waveIDDecoded
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension ArchiveWaveOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ArchiveWaveOutput(arn: \(Swift.String(describing: arn)), creationDateTime: \(Swift.String(describing: creationDateTime)), description: \(Swift.String(describing: description)), isArchived: \(Swift.String(describing: isArchived)), lastModifiedDateTime: \(Swift.String(describing: lastModifiedDateTime)), name: \(Swift.String(describing: name)), waveAggregatedStatus: \(Swift.String(describing: waveAggregatedStatus)), waveID: \(Swift.String(describing: waveID)), tags: \"CONTENT_REDACTED\")"}
}

extension ArchiveWaveOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ArchiveWaveOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.isArchived = output.isArchived
            self.lastModifiedDateTime = output.lastModifiedDateTime
            self.name = output.name
            self.tags = output.tags
            self.waveAggregatedStatus = output.waveAggregatedStatus
            self.waveID = output.waveID
        } else {
            self.arn = nil
            self.creationDateTime = nil
            self.description = nil
            self.isArchived = nil
            self.lastModifiedDateTime = nil
            self.name = nil
            self.tags = nil
            self.waveAggregatedStatus = nil
            self.waveID = nil
        }
    }
}

public struct ArchiveWaveOutput {
    /// Wave ARN.
    public var arn: Swift.String?
    /// Wave creation dateTime.
    public var creationDateTime: Swift.String?
    /// Wave description.
    public var description: Swift.String?
    /// Wave archival status.
    public var isArchived: Swift.Bool?
    /// Wave last modified dateTime.
    public var lastModifiedDateTime: Swift.String?
    /// Wave name.
    public var name: Swift.String?
    /// Wave tags.
    public var tags: [Swift.String:Swift.String]?
    /// Wave aggregated status.
    public var waveAggregatedStatus: MgnClientTypes.WaveAggregatedStatus?
    /// Wave ID.
    public var waveID: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationDateTime: Swift.String? = nil,
        description: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        lastModifiedDateTime: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        waveAggregatedStatus: MgnClientTypes.WaveAggregatedStatus? = nil,
        waveID: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.description = description
        self.isArchived = isArchived
        self.lastModifiedDateTime = lastModifiedDateTime
        self.name = name
        self.tags = tags
        self.waveAggregatedStatus = waveAggregatedStatus
        self.waveID = waveID
    }
}

struct ArchiveWaveOutputBody {
    let waveID: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let isArchived: Swift.Bool?
    let waveAggregatedStatus: MgnClientTypes.WaveAggregatedStatus?
    let creationDateTime: Swift.String?
    let lastModifiedDateTime: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension ArchiveWaveOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
        case description
        case isArchived
        case lastModifiedDateTime
        case name
        case tags
        case waveAggregatedStatus
        case waveID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let waveIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .waveID)
        waveID = waveIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let waveAggregatedStatusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.WaveAggregatedStatus.self, forKey: .waveAggregatedStatus)
        waveAggregatedStatus = waveAggregatedStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastModifiedDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedDateTime)
        lastModifiedDateTime = lastModifiedDateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ArchiveWaveOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateApplicationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case applicationIDs
        case waveID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let applicationIDs = applicationIDs {
            var applicationIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applicationIDs)
            for applicationid0 in applicationIDs {
                try applicationIDsContainer.encode(applicationid0)
            }
        }
        if let waveID = self.waveID {
            try encodeContainer.encode(waveID, forKey: .waveID)
        }
    }
}

extension AssociateApplicationsInput {

    static func urlPathProvider(_ value: AssociateApplicationsInput) -> Swift.String? {
        return "/AssociateApplications"
    }
}

public struct AssociateApplicationsInput {
    /// Account ID.
    public var accountID: Swift.String?
    /// Application IDs list.
    /// This member is required.
    public var applicationIDs: [Swift.String]?
    /// Wave ID.
    /// This member is required.
    public var waveID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        applicationIDs: [Swift.String]? = nil,
        waveID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.applicationIDs = applicationIDs
        self.waveID = waveID
    }
}

struct AssociateApplicationsInputBody {
    let waveID: Swift.String?
    let applicationIDs: [Swift.String]?
    let accountID: Swift.String?
}

extension AssociateApplicationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case applicationIDs
        case waveID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let waveIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .waveID)
        waveID = waveIDDecoded
        let applicationIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .applicationIDs)
        var applicationIDsDecoded0:[Swift.String]? = nil
        if let applicationIDsContainer = applicationIDsContainer {
            applicationIDsDecoded0 = [Swift.String]()
            for string0 in applicationIDsContainer {
                if let string0 = string0 {
                    applicationIDsDecoded0?.append(string0)
                }
            }
        }
        applicationIDs = applicationIDsDecoded0
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension AssociateApplicationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateApplicationsOutput {

    public init() { }
}

enum AssociateApplicationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateSourceServersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case applicationID
        case sourceServerIDs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let applicationID = self.applicationID {
            try encodeContainer.encode(applicationID, forKey: .applicationID)
        }
        if let sourceServerIDs = sourceServerIDs {
            var sourceServerIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceServerIDs)
            for sourceserverid0 in sourceServerIDs {
                try sourceServerIDsContainer.encode(sourceserverid0)
            }
        }
    }
}

extension AssociateSourceServersInput {

    static func urlPathProvider(_ value: AssociateSourceServersInput) -> Swift.String? {
        return "/AssociateSourceServers"
    }
}

public struct AssociateSourceServersInput {
    /// Account ID.
    public var accountID: Swift.String?
    /// Application ID.
    /// This member is required.
    public var applicationID: Swift.String?
    /// Source server IDs list.
    /// This member is required.
    public var sourceServerIDs: [Swift.String]?

    public init(
        accountID: Swift.String? = nil,
        applicationID: Swift.String? = nil,
        sourceServerIDs: [Swift.String]? = nil
    )
    {
        self.accountID = accountID
        self.applicationID = applicationID
        self.sourceServerIDs = sourceServerIDs
    }
}

struct AssociateSourceServersInputBody {
    let applicationID: Swift.String?
    let sourceServerIDs: [Swift.String]?
    let accountID: Swift.String?
}

extension AssociateSourceServersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case applicationID
        case sourceServerIDs
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
        let sourceServerIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceServerIDs)
        var sourceServerIDsDecoded0:[Swift.String]? = nil
        if let sourceServerIDsContainer = sourceServerIDsContainer {
            sourceServerIDsDecoded0 = [Swift.String]()
            for string0 in sourceServerIDsContainer {
                if let string0 = string0 {
                    sourceServerIDsDecoded0?.append(string0)
                }
            }
        }
        sourceServerIDs = sourceServerIDsDecoded0
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension AssociateSourceServersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateSourceServersOutput {

    public init() { }
}

enum AssociateSourceServersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MgnClientTypes {
    public enum BootMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case legacyBios
        case uefi
        case useSource
        case sdkUnknown(Swift.String)

        public static var allCases: [BootMode] {
            return [
                .legacyBios,
                .uefi,
                .useSource,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .legacyBios: return "LEGACY_BIOS"
            case .uefi: return "UEFI"
            case .useSource: return "USE_SOURCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BootMode(rawValue: rawValue) ?? BootMode.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes.CPU: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cores
        case modelName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cores != 0 {
            try encodeContainer.encode(cores, forKey: .cores)
        }
        if let modelName = self.modelName {
            try encodeContainer.encode(modelName, forKey: .modelName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coresDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cores) ?? 0
        cores = coresDecoded
        let modelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelName)
        modelName = modelNameDecoded
    }
}

extension MgnClientTypes {
    /// Source server CPU information.
    public struct CPU {
        /// The number of CPU cores on the source server.
        public var cores: Swift.Int
        /// The source server's CPU model name.
        public var modelName: Swift.String?

        public init(
            cores: Swift.Int = 0,
            modelName: Swift.String? = nil
        )
        {
            self.cores = cores
            self.modelName = modelName
        }
    }

}

extension ChangeServerLifeCycleStateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case lifeCycle
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let lifeCycle = self.lifeCycle {
            try encodeContainer.encode(lifeCycle, forKey: .lifeCycle)
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension ChangeServerLifeCycleStateInput {

    static func urlPathProvider(_ value: ChangeServerLifeCycleStateInput) -> Swift.String? {
        return "/ChangeServerLifeCycleState"
    }
}

public struct ChangeServerLifeCycleStateInput {
    /// The request to change the source server migration account ID.
    public var accountID: Swift.String?
    /// The request to change the source server migration lifecycle state.
    /// This member is required.
    public var lifeCycle: MgnClientTypes.ChangeServerLifeCycleStateSourceServerLifecycle?
    /// The request to change the source server migration lifecycle state by source server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        lifeCycle: MgnClientTypes.ChangeServerLifeCycleStateSourceServerLifecycle? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.lifeCycle = lifeCycle
        self.sourceServerID = sourceServerID
    }
}

struct ChangeServerLifeCycleStateInputBody {
    let sourceServerID: Swift.String?
    let lifeCycle: MgnClientTypes.ChangeServerLifeCycleStateSourceServerLifecycle?
    let accountID: Swift.String?
}

extension ChangeServerLifeCycleStateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case lifeCycle
        case sourceServerID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ChangeServerLifeCycleStateSourceServerLifecycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension ChangeServerLifeCycleStateOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChangeServerLifeCycleStateOutput(applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), connectorAction: \(Swift.String(describing: connectorAction)), dataReplicationInfo: \(Swift.String(describing: dataReplicationInfo)), fqdnForActionFramework: \(Swift.String(describing: fqdnForActionFramework)), isArchived: \(Swift.String(describing: isArchived)), launchedInstance: \(Swift.String(describing: launchedInstance)), lifeCycle: \(Swift.String(describing: lifeCycle)), replicationType: \(Swift.String(describing: replicationType)), sourceProperties: \(Swift.String(describing: sourceProperties)), sourceServerID: \(Swift.String(describing: sourceServerID)), userProvidedID: \(Swift.String(describing: userProvidedID)), vcenterClientID: \(Swift.String(describing: vcenterClientID)), tags: \"CONTENT_REDACTED\")"}
}

extension ChangeServerLifeCycleStateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ChangeServerLifeCycleStateOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationID = output.applicationID
            self.arn = output.arn
            self.connectorAction = output.connectorAction
            self.dataReplicationInfo = output.dataReplicationInfo
            self.fqdnForActionFramework = output.fqdnForActionFramework
            self.isArchived = output.isArchived
            self.launchedInstance = output.launchedInstance
            self.lifeCycle = output.lifeCycle
            self.replicationType = output.replicationType
            self.sourceProperties = output.sourceProperties
            self.sourceServerID = output.sourceServerID
            self.tags = output.tags
            self.userProvidedID = output.userProvidedID
            self.vcenterClientID = output.vcenterClientID
        } else {
            self.applicationID = nil
            self.arn = nil
            self.connectorAction = nil
            self.dataReplicationInfo = nil
            self.fqdnForActionFramework = nil
            self.isArchived = nil
            self.launchedInstance = nil
            self.lifeCycle = nil
            self.replicationType = nil
            self.sourceProperties = nil
            self.sourceServerID = nil
            self.tags = nil
            self.userProvidedID = nil
            self.vcenterClientID = nil
        }
    }
}

public struct ChangeServerLifeCycleStateOutput {
    /// Source server application ID.
    public var applicationID: Swift.String?
    /// Source server ARN.
    public var arn: Swift.String?
    /// Source Server connector action.
    public var connectorAction: MgnClientTypes.SourceServerConnectorAction?
    /// Source server data replication info.
    public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    /// Source server fqdn for action framework.
    public var fqdnForActionFramework: Swift.String?
    /// Source server archived status.
    public var isArchived: Swift.Bool?
    /// Source server launched instance.
    public var launchedInstance: MgnClientTypes.LaunchedInstance?
    /// Source server lifecycle state.
    public var lifeCycle: MgnClientTypes.LifeCycle?
    /// Source server replication type.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// Source server properties.
    public var sourceProperties: MgnClientTypes.SourceProperties?
    /// Source server ID.
    public var sourceServerID: Swift.String?
    /// Source server Tags.
    public var tags: [Swift.String:Swift.String]?
    /// Source server user provided ID.
    public var userProvidedID: Swift.String?
    /// Source server vCenter client id.
    public var vcenterClientID: Swift.String?

    public init(
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        connectorAction: MgnClientTypes.SourceServerConnectorAction? = nil,
        dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
        fqdnForActionFramework: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
        lifeCycle: MgnClientTypes.LifeCycle? = nil,
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceProperties: MgnClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        userProvidedID: Swift.String? = nil,
        vcenterClientID: Swift.String? = nil
    )
    {
        self.applicationID = applicationID
        self.arn = arn
        self.connectorAction = connectorAction
        self.dataReplicationInfo = dataReplicationInfo
        self.fqdnForActionFramework = fqdnForActionFramework
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.replicationType = replicationType
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
        self.userProvidedID = userProvidedID
        self.vcenterClientID = vcenterClientID
    }
}

struct ChangeServerLifeCycleStateOutputBody {
    let sourceServerID: Swift.String?
    let arn: Swift.String?
    let isArchived: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
    let launchedInstance: MgnClientTypes.LaunchedInstance?
    let dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    let lifeCycle: MgnClientTypes.LifeCycle?
    let sourceProperties: MgnClientTypes.SourceProperties?
    let replicationType: MgnClientTypes.ReplicationType?
    let vcenterClientID: Swift.String?
    let applicationID: Swift.String?
    let userProvidedID: Swift.String?
    let fqdnForActionFramework: Swift.String?
    let connectorAction: MgnClientTypes.SourceServerConnectorAction?
}

extension ChangeServerLifeCycleStateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationID
        case arn
        case connectorAction
        case dataReplicationInfo
        case fqdnForActionFramework
        case isArchived
        case launchedInstance
        case lifeCycle
        case replicationType
        case sourceProperties
        case sourceServerID
        case tags
        case userProvidedID
        case vcenterClientID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let launchedInstanceDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchedInstance.self, forKey: .launchedInstance)
        launchedInstance = launchedInstanceDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
        let replicationTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationType.self, forKey: .replicationType)
        replicationType = replicationTypeDecoded
        let vcenterClientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcenterClientID)
        vcenterClientID = vcenterClientIDDecoded
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
        let userProvidedIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userProvidedID)
        userProvidedID = userProvidedIDDecoded
        let fqdnForActionFrameworkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fqdnForActionFramework)
        fqdnForActionFramework = fqdnForActionFrameworkDecoded
        let connectorActionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceServerConnectorAction.self, forKey: .connectorAction)
        connectorAction = connectorActionDecoded
    }
}

enum ChangeServerLifeCycleStateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MgnClientTypes.ChangeServerLifeCycleStateSourceServerLifecycle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ChangeServerLifeCycleStateSourceServerLifecycleState.self, forKey: .state)
        state = stateDecoded
    }
}

extension MgnClientTypes {
    /// The request to change the source server migration lifecycle state.
    public struct ChangeServerLifeCycleStateSourceServerLifecycle {
        /// The request to change the source server migration lifecycle state.
        /// This member is required.
        public var state: MgnClientTypes.ChangeServerLifeCycleStateSourceServerLifecycleState?

        public init(
            state: MgnClientTypes.ChangeServerLifeCycleStateSourceServerLifecycleState? = nil
        )
        {
            self.state = state
        }
    }

}

extension MgnClientTypes {
    public enum ChangeServerLifeCycleStateSourceServerLifecycleState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cutover
        case readyForCutover
        case readyForTest
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeServerLifeCycleStateSourceServerLifecycleState] {
            return [
                .cutover,
                .readyForCutover,
                .readyForTest,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cutover: return "CUTOVER"
            case .readyForCutover: return "READY_FOR_CUTOVER"
            case .readyForTest: return "READY_FOR_TEST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChangeServerLifeCycleStateSourceServerLifecycleState(rawValue: rawValue) ?? ChangeServerLifeCycleStateSourceServerLifecycleState.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.errors = output.errors
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.code = nil
            self.properties.errors = nil
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request could not be completed due to a conflict with the current state of the target resource.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        /// Conflict Exception specific errors.
        public internal(set) var errors: [MgnClientTypes.ErrorDetails]? = nil
        public internal(set) var message: Swift.String? = nil
        /// A conflict occurred when prompting for the Resource ID.
        public internal(set) var resourceId: Swift.String? = nil
        /// A conflict occurred when prompting for resource type.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        errors: [MgnClientTypes.ErrorDetails]? = nil,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.errors = errors
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ConflictExceptionBody {
    let message: Swift.String?
    let code: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let errors: [MgnClientTypes.ErrorDetails]?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case errors
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let errorsContainer = try containerValues.decodeIfPresent([MgnClientTypes.ErrorDetails?].self, forKey: .errors)
        var errorsDecoded0:[MgnClientTypes.ErrorDetails]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [MgnClientTypes.ErrorDetails]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension MgnClientTypes.Connector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case connectorID
        case name
        case ssmCommandConfig
        case ssmInstanceID
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let connectorID = self.connectorID {
            try encodeContainer.encode(connectorID, forKey: .connectorID)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ssmCommandConfig = self.ssmCommandConfig {
            try encodeContainer.encode(ssmCommandConfig, forKey: .ssmCommandConfig)
        }
        if let ssmInstanceID = self.ssmInstanceID {
            try encodeContainer.encode(ssmInstanceID, forKey: .ssmInstanceID)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorID)
        connectorID = connectorIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ssmInstanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ssmInstanceID)
        ssmInstanceID = ssmInstanceIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let ssmCommandConfigDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ConnectorSsmCommandConfig.self, forKey: .ssmCommandConfig)
        ssmCommandConfig = ssmCommandConfigDecoded
    }
}

extension MgnClientTypes.Connector: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Connector(arn: \(Swift.String(describing: arn)), connectorID: \(Swift.String(describing: connectorID)), name: \(Swift.String(describing: name)), ssmCommandConfig: \(Swift.String(describing: ssmCommandConfig)), ssmInstanceID: \(Swift.String(describing: ssmInstanceID)), tags: \"CONTENT_REDACTED\")"}
}

extension MgnClientTypes {
    public struct Connector {
        /// Connector arn.
        public var arn: Swift.String?
        /// Connector ID.
        public var connectorID: Swift.String?
        /// Connector name.
        public var name: Swift.String?
        /// Connector SSM command config.
        public var ssmCommandConfig: MgnClientTypes.ConnectorSsmCommandConfig?
        /// Connector SSM instance ID.
        public var ssmInstanceID: Swift.String?
        /// Connector tags.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            connectorID: Swift.String? = nil,
            name: Swift.String? = nil,
            ssmCommandConfig: MgnClientTypes.ConnectorSsmCommandConfig? = nil,
            ssmInstanceID: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.connectorID = connectorID
            self.name = name
            self.ssmCommandConfig = ssmCommandConfig
            self.ssmInstanceID = ssmInstanceID
            self.tags = tags
        }
    }

}

extension MgnClientTypes.ConnectorSsmCommandConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogGroupName
        case cloudWatchOutputEnabled
        case outputS3BucketName
        case s3OutputEnabled
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogGroupName = self.cloudWatchLogGroupName {
            try encodeContainer.encode(cloudWatchLogGroupName, forKey: .cloudWatchLogGroupName)
        }
        if let cloudWatchOutputEnabled = self.cloudWatchOutputEnabled {
            try encodeContainer.encode(cloudWatchOutputEnabled, forKey: .cloudWatchOutputEnabled)
        }
        if let outputS3BucketName = self.outputS3BucketName {
            try encodeContainer.encode(outputS3BucketName, forKey: .outputS3BucketName)
        }
        if let s3OutputEnabled = self.s3OutputEnabled {
            try encodeContainer.encode(s3OutputEnabled, forKey: .s3OutputEnabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3OutputEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .s3OutputEnabled)
        s3OutputEnabled = s3OutputEnabledDecoded
        let outputS3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3BucketName)
        outputS3BucketName = outputS3BucketNameDecoded
        let cloudWatchOutputEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cloudWatchOutputEnabled)
        cloudWatchOutputEnabled = cloudWatchOutputEnabledDecoded
        let cloudWatchLogGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogGroupName)
        cloudWatchLogGroupName = cloudWatchLogGroupNameDecoded
    }
}

extension MgnClientTypes {
    /// Connector SSM command config.
    public struct ConnectorSsmCommandConfig {
        /// Connector SSM command config CloudWatch log group name.
        public var cloudWatchLogGroupName: Swift.String?
        /// Connector SSM command config CloudWatch output enabled.
        /// This member is required.
        public var cloudWatchOutputEnabled: Swift.Bool?
        /// Connector SSM command config output S3 bucket name.
        public var outputS3BucketName: Swift.String?
        /// Connector SSM command config S3 output enabled.
        /// This member is required.
        public var s3OutputEnabled: Swift.Bool?

        public init(
            cloudWatchLogGroupName: Swift.String? = nil,
            cloudWatchOutputEnabled: Swift.Bool? = nil,
            outputS3BucketName: Swift.String? = nil,
            s3OutputEnabled: Swift.Bool? = nil
        )
        {
            self.cloudWatchLogGroupName = cloudWatchLogGroupName
            self.cloudWatchOutputEnabled = cloudWatchOutputEnabled
            self.outputS3BucketName = outputS3BucketName
            self.s3OutputEnabled = s3OutputEnabled
        }
    }

}

extension CreateApplicationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateApplicationInput(accountID: \(Swift.String(describing: accountID)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case description
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateApplicationInput {

    static func urlPathProvider(_ value: CreateApplicationInput) -> Swift.String? {
        return "/CreateApplication"
    }
}

public struct CreateApplicationInput {
    /// Account ID.
    public var accountID: Swift.String?
    /// Application description.
    public var description: Swift.String?
    /// Application name.
    /// This member is required.
    public var name: Swift.String?
    /// Application tags.
    public var tags: [Swift.String:Swift.String]?

    public init(
        accountID: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.accountID = accountID
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateApplicationInputBody {
    let name: Swift.String?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let accountID: Swift.String?
}

extension CreateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case description
        case name
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension CreateApplicationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateApplicationOutput(applicationAggregatedStatus: \(Swift.String(describing: applicationAggregatedStatus)), applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), creationDateTime: \(Swift.String(describing: creationDateTime)), description: \(Swift.String(describing: description)), isArchived: \(Swift.String(describing: isArchived)), lastModifiedDateTime: \(Swift.String(describing: lastModifiedDateTime)), name: \(Swift.String(describing: name)), waveID: \(Swift.String(describing: waveID)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationAggregatedStatus = output.applicationAggregatedStatus
            self.applicationID = output.applicationID
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.isArchived = output.isArchived
            self.lastModifiedDateTime = output.lastModifiedDateTime
            self.name = output.name
            self.tags = output.tags
            self.waveID = output.waveID
        } else {
            self.applicationAggregatedStatus = nil
            self.applicationID = nil
            self.arn = nil
            self.creationDateTime = nil
            self.description = nil
            self.isArchived = nil
            self.lastModifiedDateTime = nil
            self.name = nil
            self.tags = nil
            self.waveID = nil
        }
    }
}

public struct CreateApplicationOutput {
    /// Application aggregated status.
    public var applicationAggregatedStatus: MgnClientTypes.ApplicationAggregatedStatus?
    /// Application ID.
    public var applicationID: Swift.String?
    /// Application ARN.
    public var arn: Swift.String?
    /// Application creation dateTime.
    public var creationDateTime: Swift.String?
    /// Application description.
    public var description: Swift.String?
    /// Application archival status.
    public var isArchived: Swift.Bool?
    /// Application last modified dateTime.
    public var lastModifiedDateTime: Swift.String?
    /// Application name.
    public var name: Swift.String?
    /// Application tags.
    public var tags: [Swift.String:Swift.String]?
    /// Application wave ID.
    public var waveID: Swift.String?

    public init(
        applicationAggregatedStatus: MgnClientTypes.ApplicationAggregatedStatus? = nil,
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        creationDateTime: Swift.String? = nil,
        description: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        lastModifiedDateTime: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        waveID: Swift.String? = nil
    )
    {
        self.applicationAggregatedStatus = applicationAggregatedStatus
        self.applicationID = applicationID
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.description = description
        self.isArchived = isArchived
        self.lastModifiedDateTime = lastModifiedDateTime
        self.name = name
        self.tags = tags
        self.waveID = waveID
    }
}

struct CreateApplicationOutputBody {
    let applicationID: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let isArchived: Swift.Bool?
    let applicationAggregatedStatus: MgnClientTypes.ApplicationAggregatedStatus?
    let creationDateTime: Swift.String?
    let lastModifiedDateTime: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let waveID: Swift.String?
}

extension CreateApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationAggregatedStatus
        case applicationID
        case arn
        case creationDateTime
        case description
        case isArchived
        case lastModifiedDateTime
        case name
        case tags
        case waveID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let applicationAggregatedStatusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ApplicationAggregatedStatus.self, forKey: .applicationAggregatedStatus)
        applicationAggregatedStatus = applicationAggregatedStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastModifiedDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedDateTime)
        lastModifiedDateTime = lastModifiedDateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let waveIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .waveID)
        waveID = waveIDDecoded
    }
}

enum CreateApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateConnectorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConnectorInput(name: \(Swift.String(describing: name)), ssmCommandConfig: \(Swift.String(describing: ssmCommandConfig)), ssmInstanceID: \(Swift.String(describing: ssmInstanceID)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateConnectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case ssmCommandConfig
        case ssmInstanceID
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ssmCommandConfig = self.ssmCommandConfig {
            try encodeContainer.encode(ssmCommandConfig, forKey: .ssmCommandConfig)
        }
        if let ssmInstanceID = self.ssmInstanceID {
            try encodeContainer.encode(ssmInstanceID, forKey: .ssmInstanceID)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateConnectorInput {

    static func urlPathProvider(_ value: CreateConnectorInput) -> Swift.String? {
        return "/CreateConnector"
    }
}

public struct CreateConnectorInput {
    /// Create Connector request name.
    /// This member is required.
    public var name: Swift.String?
    /// Create Connector request SSM command config.
    public var ssmCommandConfig: MgnClientTypes.ConnectorSsmCommandConfig?
    /// Create Connector request SSM instance ID.
    /// This member is required.
    public var ssmInstanceID: Swift.String?
    /// Create Connector request tags.
    public var tags: [Swift.String:Swift.String]?

    public init(
        name: Swift.String? = nil,
        ssmCommandConfig: MgnClientTypes.ConnectorSsmCommandConfig? = nil,
        ssmInstanceID: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.name = name
        self.ssmCommandConfig = ssmCommandConfig
        self.ssmInstanceID = ssmInstanceID
        self.tags = tags
    }
}

struct CreateConnectorInputBody {
    let name: Swift.String?
    let ssmInstanceID: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let ssmCommandConfig: MgnClientTypes.ConnectorSsmCommandConfig?
}

extension CreateConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case ssmCommandConfig
        case ssmInstanceID
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ssmInstanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ssmInstanceID)
        ssmInstanceID = ssmInstanceIDDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let ssmCommandConfigDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ConnectorSsmCommandConfig.self, forKey: .ssmCommandConfig)
        ssmCommandConfig = ssmCommandConfigDecoded
    }
}

extension CreateConnectorOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConnectorOutput(arn: \(Swift.String(describing: arn)), connectorID: \(Swift.String(describing: connectorID)), name: \(Swift.String(describing: name)), ssmCommandConfig: \(Swift.String(describing: ssmCommandConfig)), ssmInstanceID: \(Swift.String(describing: ssmInstanceID)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateConnectorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateConnectorOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.connectorID = output.connectorID
            self.name = output.name
            self.ssmCommandConfig = output.ssmCommandConfig
            self.ssmInstanceID = output.ssmInstanceID
            self.tags = output.tags
        } else {
            self.arn = nil
            self.connectorID = nil
            self.name = nil
            self.ssmCommandConfig = nil
            self.ssmInstanceID = nil
            self.tags = nil
        }
    }
}

public struct CreateConnectorOutput {
    /// Connector arn.
    public var arn: Swift.String?
    /// Connector ID.
    public var connectorID: Swift.String?
    /// Connector name.
    public var name: Swift.String?
    /// Connector SSM command config.
    public var ssmCommandConfig: MgnClientTypes.ConnectorSsmCommandConfig?
    /// Connector SSM instance ID.
    public var ssmInstanceID: Swift.String?
    /// Connector tags.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        connectorID: Swift.String? = nil,
        name: Swift.String? = nil,
        ssmCommandConfig: MgnClientTypes.ConnectorSsmCommandConfig? = nil,
        ssmInstanceID: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.connectorID = connectorID
        self.name = name
        self.ssmCommandConfig = ssmCommandConfig
        self.ssmInstanceID = ssmInstanceID
        self.tags = tags
    }
}

struct CreateConnectorOutputBody {
    let connectorID: Swift.String?
    let name: Swift.String?
    let ssmInstanceID: Swift.String?
    let arn: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let ssmCommandConfig: MgnClientTypes.ConnectorSsmCommandConfig?
}

extension CreateConnectorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case connectorID
        case name
        case ssmCommandConfig
        case ssmInstanceID
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorID)
        connectorID = connectorIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ssmInstanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ssmInstanceID)
        ssmInstanceID = ssmInstanceIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let ssmCommandConfigDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ConnectorSsmCommandConfig.self, forKey: .ssmCommandConfig)
        ssmCommandConfig = ssmCommandConfigDecoded
    }
}

enum CreateConnectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateLaunchConfigurationTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLaunchConfigurationTemplateInput(associatePublicIpAddress: \(Swift.String(describing: associatePublicIpAddress)), bootMode: \(Swift.String(describing: bootMode)), copyPrivateIp: \(Swift.String(describing: copyPrivateIp)), copyTags: \(Swift.String(describing: copyTags)), enableMapAutoTagging: \(Swift.String(describing: enableMapAutoTagging)), largeVolumeConf: \(Swift.String(describing: largeVolumeConf)), launchDisposition: \(Swift.String(describing: launchDisposition)), licensing: \(Swift.String(describing: licensing)), mapAutoTaggingMpeID: \(Swift.String(describing: mapAutoTaggingMpeID)), postLaunchActions: \(Swift.String(describing: postLaunchActions)), smallVolumeConf: \(Swift.String(describing: smallVolumeConf)), smallVolumeMaxSize: \(Swift.String(describing: smallVolumeMaxSize)), targetInstanceTypeRightSizingMethod: \(Swift.String(describing: targetInstanceTypeRightSizingMethod)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateLaunchConfigurationTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatePublicIpAddress
        case bootMode
        case copyPrivateIp
        case copyTags
        case enableMapAutoTagging
        case largeVolumeConf
        case launchDisposition
        case licensing
        case mapAutoTaggingMpeID
        case postLaunchActions
        case smallVolumeConf
        case smallVolumeMaxSize
        case tags
        case targetInstanceTypeRightSizingMethod
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatePublicIpAddress = self.associatePublicIpAddress {
            try encodeContainer.encode(associatePublicIpAddress, forKey: .associatePublicIpAddress)
        }
        if let bootMode = self.bootMode {
            try encodeContainer.encode(bootMode.rawValue, forKey: .bootMode)
        }
        if let copyPrivateIp = self.copyPrivateIp {
            try encodeContainer.encode(copyPrivateIp, forKey: .copyPrivateIp)
        }
        if let copyTags = self.copyTags {
            try encodeContainer.encode(copyTags, forKey: .copyTags)
        }
        if let enableMapAutoTagging = self.enableMapAutoTagging {
            try encodeContainer.encode(enableMapAutoTagging, forKey: .enableMapAutoTagging)
        }
        if let largeVolumeConf = self.largeVolumeConf {
            try encodeContainer.encode(largeVolumeConf, forKey: .largeVolumeConf)
        }
        if let launchDisposition = self.launchDisposition {
            try encodeContainer.encode(launchDisposition.rawValue, forKey: .launchDisposition)
        }
        if let licensing = self.licensing {
            try encodeContainer.encode(licensing, forKey: .licensing)
        }
        if let mapAutoTaggingMpeID = self.mapAutoTaggingMpeID {
            try encodeContainer.encode(mapAutoTaggingMpeID, forKey: .mapAutoTaggingMpeID)
        }
        if let postLaunchActions = self.postLaunchActions {
            try encodeContainer.encode(postLaunchActions, forKey: .postLaunchActions)
        }
        if let smallVolumeConf = self.smallVolumeConf {
            try encodeContainer.encode(smallVolumeConf, forKey: .smallVolumeConf)
        }
        if smallVolumeMaxSize != 0 {
            try encodeContainer.encode(smallVolumeMaxSize, forKey: .smallVolumeMaxSize)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targetInstanceTypeRightSizingMethod = self.targetInstanceTypeRightSizingMethod {
            try encodeContainer.encode(targetInstanceTypeRightSizingMethod.rawValue, forKey: .targetInstanceTypeRightSizingMethod)
        }
    }
}

extension CreateLaunchConfigurationTemplateInput {

    static func urlPathProvider(_ value: CreateLaunchConfigurationTemplateInput) -> Swift.String? {
        return "/CreateLaunchConfigurationTemplate"
    }
}

public struct CreateLaunchConfigurationTemplateInput {
    /// Associate public Ip address.
    public var associatePublicIpAddress: Swift.Bool?
    /// Launch configuration template boot mode.
    public var bootMode: MgnClientTypes.BootMode?
    /// Copy private Ip.
    public var copyPrivateIp: Swift.Bool?
    /// Copy tags.
    public var copyTags: Swift.Bool?
    /// Enable map auto tagging.
    public var enableMapAutoTagging: Swift.Bool?
    /// Large volume config.
    public var largeVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
    /// Launch disposition.
    public var launchDisposition: MgnClientTypes.LaunchDisposition?
    /// Configure Licensing.
    public var licensing: MgnClientTypes.Licensing?
    /// Launch configuration template map auto tagging MPE ID.
    public var mapAutoTaggingMpeID: Swift.String?
    /// Launch configuration template post launch actions.
    public var postLaunchActions: MgnClientTypes.PostLaunchActions?
    /// Small volume config.
    public var smallVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
    /// Small volume maximum size.
    public var smallVolumeMaxSize: Swift.Int
    /// Request to associate tags during creation of a Launch Configuration Template.
    public var tags: [Swift.String:Swift.String]?
    /// Target instance type right-sizing method.
    public var targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?

    public init(
        associatePublicIpAddress: Swift.Bool? = nil,
        bootMode: MgnClientTypes.BootMode? = nil,
        copyPrivateIp: Swift.Bool? = nil,
        copyTags: Swift.Bool? = nil,
        enableMapAutoTagging: Swift.Bool? = nil,
        largeVolumeConf: MgnClientTypes.LaunchTemplateDiskConf? = nil,
        launchDisposition: MgnClientTypes.LaunchDisposition? = nil,
        licensing: MgnClientTypes.Licensing? = nil,
        mapAutoTaggingMpeID: Swift.String? = nil,
        postLaunchActions: MgnClientTypes.PostLaunchActions? = nil,
        smallVolumeConf: MgnClientTypes.LaunchTemplateDiskConf? = nil,
        smallVolumeMaxSize: Swift.Int = 0,
        tags: [Swift.String:Swift.String]? = nil,
        targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod? = nil
    )
    {
        self.associatePublicIpAddress = associatePublicIpAddress
        self.bootMode = bootMode
        self.copyPrivateIp = copyPrivateIp
        self.copyTags = copyTags
        self.enableMapAutoTagging = enableMapAutoTagging
        self.largeVolumeConf = largeVolumeConf
        self.launchDisposition = launchDisposition
        self.licensing = licensing
        self.mapAutoTaggingMpeID = mapAutoTaggingMpeID
        self.postLaunchActions = postLaunchActions
        self.smallVolumeConf = smallVolumeConf
        self.smallVolumeMaxSize = smallVolumeMaxSize
        self.tags = tags
        self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
    }
}

struct CreateLaunchConfigurationTemplateInputBody {
    let postLaunchActions: MgnClientTypes.PostLaunchActions?
    let enableMapAutoTagging: Swift.Bool?
    let mapAutoTaggingMpeID: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let launchDisposition: MgnClientTypes.LaunchDisposition?
    let targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?
    let copyPrivateIp: Swift.Bool?
    let associatePublicIpAddress: Swift.Bool?
    let copyTags: Swift.Bool?
    let licensing: MgnClientTypes.Licensing?
    let bootMode: MgnClientTypes.BootMode?
    let smallVolumeMaxSize: Swift.Int
    let smallVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
    let largeVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
}

extension CreateLaunchConfigurationTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatePublicIpAddress
        case bootMode
        case copyPrivateIp
        case copyTags
        case enableMapAutoTagging
        case largeVolumeConf
        case launchDisposition
        case licensing
        case mapAutoTaggingMpeID
        case postLaunchActions
        case smallVolumeConf
        case smallVolumeMaxSize
        case tags
        case targetInstanceTypeRightSizingMethod
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let postLaunchActionsDecoded = try containerValues.decodeIfPresent(MgnClientTypes.PostLaunchActions.self, forKey: .postLaunchActions)
        postLaunchActions = postLaunchActionsDecoded
        let enableMapAutoTaggingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableMapAutoTagging)
        enableMapAutoTagging = enableMapAutoTaggingDecoded
        let mapAutoTaggingMpeIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapAutoTaggingMpeID)
        mapAutoTaggingMpeID = mapAutoTaggingMpeIDDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let launchDispositionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchDisposition.self, forKey: .launchDisposition)
        launchDisposition = launchDispositionDecoded
        let targetInstanceTypeRightSizingMethodDecoded = try containerValues.decodeIfPresent(MgnClientTypes.TargetInstanceTypeRightSizingMethod.self, forKey: .targetInstanceTypeRightSizingMethod)
        targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethodDecoded
        let copyPrivateIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyPrivateIp)
        copyPrivateIp = copyPrivateIpDecoded
        let associatePublicIpAddressDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associatePublicIpAddress)
        associatePublicIpAddress = associatePublicIpAddressDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let licensingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.Licensing.self, forKey: .licensing)
        licensing = licensingDecoded
        let bootModeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.BootMode.self, forKey: .bootMode)
        bootMode = bootModeDecoded
        let smallVolumeMaxSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .smallVolumeMaxSize) ?? 0
        smallVolumeMaxSize = smallVolumeMaxSizeDecoded
        let smallVolumeConfDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchTemplateDiskConf.self, forKey: .smallVolumeConf)
        smallVolumeConf = smallVolumeConfDecoded
        let largeVolumeConfDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchTemplateDiskConf.self, forKey: .largeVolumeConf)
        largeVolumeConf = largeVolumeConfDecoded
    }
}

extension CreateLaunchConfigurationTemplateOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLaunchConfigurationTemplateOutput(arn: \(Swift.String(describing: arn)), associatePublicIpAddress: \(Swift.String(describing: associatePublicIpAddress)), bootMode: \(Swift.String(describing: bootMode)), copyPrivateIp: \(Swift.String(describing: copyPrivateIp)), copyTags: \(Swift.String(describing: copyTags)), ec2LaunchTemplateID: \(Swift.String(describing: ec2LaunchTemplateID)), enableMapAutoTagging: \(Swift.String(describing: enableMapAutoTagging)), largeVolumeConf: \(Swift.String(describing: largeVolumeConf)), launchConfigurationTemplateID: \(Swift.String(describing: launchConfigurationTemplateID)), launchDisposition: \(Swift.String(describing: launchDisposition)), licensing: \(Swift.String(describing: licensing)), mapAutoTaggingMpeID: \(Swift.String(describing: mapAutoTaggingMpeID)), postLaunchActions: \(Swift.String(describing: postLaunchActions)), smallVolumeConf: \(Swift.String(describing: smallVolumeConf)), smallVolumeMaxSize: \(Swift.String(describing: smallVolumeMaxSize)), targetInstanceTypeRightSizingMethod: \(Swift.String(describing: targetInstanceTypeRightSizingMethod)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateLaunchConfigurationTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateLaunchConfigurationTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.associatePublicIpAddress = output.associatePublicIpAddress
            self.bootMode = output.bootMode
            self.copyPrivateIp = output.copyPrivateIp
            self.copyTags = output.copyTags
            self.ec2LaunchTemplateID = output.ec2LaunchTemplateID
            self.enableMapAutoTagging = output.enableMapAutoTagging
            self.largeVolumeConf = output.largeVolumeConf
            self.launchConfigurationTemplateID = output.launchConfigurationTemplateID
            self.launchDisposition = output.launchDisposition
            self.licensing = output.licensing
            self.mapAutoTaggingMpeID = output.mapAutoTaggingMpeID
            self.postLaunchActions = output.postLaunchActions
            self.smallVolumeConf = output.smallVolumeConf
            self.smallVolumeMaxSize = output.smallVolumeMaxSize
            self.tags = output.tags
            self.targetInstanceTypeRightSizingMethod = output.targetInstanceTypeRightSizingMethod
        } else {
            self.arn = nil
            self.associatePublicIpAddress = nil
            self.bootMode = nil
            self.copyPrivateIp = nil
            self.copyTags = nil
            self.ec2LaunchTemplateID = nil
            self.enableMapAutoTagging = nil
            self.largeVolumeConf = nil
            self.launchConfigurationTemplateID = nil
            self.launchDisposition = nil
            self.licensing = nil
            self.mapAutoTaggingMpeID = nil
            self.postLaunchActions = nil
            self.smallVolumeConf = nil
            self.smallVolumeMaxSize = 0
            self.tags = nil
            self.targetInstanceTypeRightSizingMethod = nil
        }
    }
}

public struct CreateLaunchConfigurationTemplateOutput {
    /// ARN of the Launch Configuration Template.
    public var arn: Swift.String?
    /// Associate public Ip address.
    public var associatePublicIpAddress: Swift.Bool?
    /// Launch configuration template boot mode.
    public var bootMode: MgnClientTypes.BootMode?
    /// Copy private Ip.
    public var copyPrivateIp: Swift.Bool?
    /// Copy tags.
    public var copyTags: Swift.Bool?
    /// EC2 launch template ID.
    public var ec2LaunchTemplateID: Swift.String?
    /// Enable map auto tagging.
    public var enableMapAutoTagging: Swift.Bool?
    /// Large volume config.
    public var largeVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
    /// ID of the Launch Configuration Template.
    /// This member is required.
    public var launchConfigurationTemplateID: Swift.String?
    /// Launch disposition.
    public var launchDisposition: MgnClientTypes.LaunchDisposition?
    /// Configure Licensing.
    public var licensing: MgnClientTypes.Licensing?
    /// Launch configuration template map auto tagging MPE ID.
    public var mapAutoTaggingMpeID: Swift.String?
    /// Post Launch Actions of the Launch Configuration Template.
    public var postLaunchActions: MgnClientTypes.PostLaunchActions?
    /// Small volume config.
    public var smallVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
    /// Small volume maximum size.
    public var smallVolumeMaxSize: Swift.Int
    /// Tags of the Launch Configuration Template.
    public var tags: [Swift.String:Swift.String]?
    /// Target instance type right-sizing method.
    public var targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?

    public init(
        arn: Swift.String? = nil,
        associatePublicIpAddress: Swift.Bool? = nil,
        bootMode: MgnClientTypes.BootMode? = nil,
        copyPrivateIp: Swift.Bool? = nil,
        copyTags: Swift.Bool? = nil,
        ec2LaunchTemplateID: Swift.String? = nil,
        enableMapAutoTagging: Swift.Bool? = nil,
        largeVolumeConf: MgnClientTypes.LaunchTemplateDiskConf? = nil,
        launchConfigurationTemplateID: Swift.String? = nil,
        launchDisposition: MgnClientTypes.LaunchDisposition? = nil,
        licensing: MgnClientTypes.Licensing? = nil,
        mapAutoTaggingMpeID: Swift.String? = nil,
        postLaunchActions: MgnClientTypes.PostLaunchActions? = nil,
        smallVolumeConf: MgnClientTypes.LaunchTemplateDiskConf? = nil,
        smallVolumeMaxSize: Swift.Int = 0,
        tags: [Swift.String:Swift.String]? = nil,
        targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod? = nil
    )
    {
        self.arn = arn
        self.associatePublicIpAddress = associatePublicIpAddress
        self.bootMode = bootMode
        self.copyPrivateIp = copyPrivateIp
        self.copyTags = copyTags
        self.ec2LaunchTemplateID = ec2LaunchTemplateID
        self.enableMapAutoTagging = enableMapAutoTagging
        self.largeVolumeConf = largeVolumeConf
        self.launchConfigurationTemplateID = launchConfigurationTemplateID
        self.launchDisposition = launchDisposition
        self.licensing = licensing
        self.mapAutoTaggingMpeID = mapAutoTaggingMpeID
        self.postLaunchActions = postLaunchActions
        self.smallVolumeConf = smallVolumeConf
        self.smallVolumeMaxSize = smallVolumeMaxSize
        self.tags = tags
        self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
    }
}

struct CreateLaunchConfigurationTemplateOutputBody {
    let launchConfigurationTemplateID: Swift.String?
    let arn: Swift.String?
    let postLaunchActions: MgnClientTypes.PostLaunchActions?
    let enableMapAutoTagging: Swift.Bool?
    let mapAutoTaggingMpeID: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let ec2LaunchTemplateID: Swift.String?
    let launchDisposition: MgnClientTypes.LaunchDisposition?
    let targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?
    let copyPrivateIp: Swift.Bool?
    let associatePublicIpAddress: Swift.Bool?
    let copyTags: Swift.Bool?
    let licensing: MgnClientTypes.Licensing?
    let bootMode: MgnClientTypes.BootMode?
    let smallVolumeMaxSize: Swift.Int
    let smallVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
    let largeVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
}

extension CreateLaunchConfigurationTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case associatePublicIpAddress
        case bootMode
        case copyPrivateIp
        case copyTags
        case ec2LaunchTemplateID
        case enableMapAutoTagging
        case largeVolumeConf
        case launchConfigurationTemplateID
        case launchDisposition
        case licensing
        case mapAutoTaggingMpeID
        case postLaunchActions
        case smallVolumeConf
        case smallVolumeMaxSize
        case tags
        case targetInstanceTypeRightSizingMethod
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchConfigurationTemplateID)
        launchConfigurationTemplateID = launchConfigurationTemplateIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let postLaunchActionsDecoded = try containerValues.decodeIfPresent(MgnClientTypes.PostLaunchActions.self, forKey: .postLaunchActions)
        postLaunchActions = postLaunchActionsDecoded
        let enableMapAutoTaggingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableMapAutoTagging)
        enableMapAutoTagging = enableMapAutoTaggingDecoded
        let mapAutoTaggingMpeIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapAutoTaggingMpeID)
        mapAutoTaggingMpeID = mapAutoTaggingMpeIDDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let ec2LaunchTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2LaunchTemplateID)
        ec2LaunchTemplateID = ec2LaunchTemplateIDDecoded
        let launchDispositionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchDisposition.self, forKey: .launchDisposition)
        launchDisposition = launchDispositionDecoded
        let targetInstanceTypeRightSizingMethodDecoded = try containerValues.decodeIfPresent(MgnClientTypes.TargetInstanceTypeRightSizingMethod.self, forKey: .targetInstanceTypeRightSizingMethod)
        targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethodDecoded
        let copyPrivateIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyPrivateIp)
        copyPrivateIp = copyPrivateIpDecoded
        let associatePublicIpAddressDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associatePublicIpAddress)
        associatePublicIpAddress = associatePublicIpAddressDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let licensingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.Licensing.self, forKey: .licensing)
        licensing = licensingDecoded
        let bootModeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.BootMode.self, forKey: .bootMode)
        bootMode = bootModeDecoded
        let smallVolumeMaxSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .smallVolumeMaxSize) ?? 0
        smallVolumeMaxSize = smallVolumeMaxSizeDecoded
        let smallVolumeConfDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchTemplateDiskConf.self, forKey: .smallVolumeConf)
        smallVolumeConf = smallVolumeConfDecoded
        let largeVolumeConfDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchTemplateDiskConf.self, forKey: .largeVolumeConf)
        largeVolumeConf = largeVolumeConfDecoded
    }
}

enum CreateLaunchConfigurationTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateReplicationConfigurationTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateReplicationConfigurationTemplateInput(associateDefaultSecurityGroup: \(Swift.String(describing: associateDefaultSecurityGroup)), bandwidthThrottling: \(Swift.String(describing: bandwidthThrottling)), createPublicIP: \(Swift.String(describing: createPublicIP)), dataPlaneRouting: \(Swift.String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(Swift.String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(Swift.String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(Swift.String(describing: ebsEncryptionKeyArn)), replicationServerInstanceType: \(Swift.String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(Swift.String(describing: replicationServersSecurityGroupsIDs)), stagingAreaSubnetId: \(Swift.String(describing: stagingAreaSubnetId)), useDedicatedReplicationServer: \(Swift.String(describing: useDedicatedReplicationServer)), useFipsEndpoint: \(Swift.String(describing: useFipsEndpoint)), stagingAreaTags: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

extension CreateReplicationConfigurationTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case tags
        case useDedicatedReplicationServer
        case useFipsEndpoint
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associateDefaultSecurityGroup = self.associateDefaultSecurityGroup {
            try encodeContainer.encode(associateDefaultSecurityGroup, forKey: .associateDefaultSecurityGroup)
        }
        if bandwidthThrottling != 0 {
            try encodeContainer.encode(bandwidthThrottling, forKey: .bandwidthThrottling)
        }
        if let createPublicIP = self.createPublicIP {
            try encodeContainer.encode(createPublicIP, forKey: .createPublicIP)
        }
        if let dataPlaneRouting = self.dataPlaneRouting {
            try encodeContainer.encode(dataPlaneRouting.rawValue, forKey: .dataPlaneRouting)
        }
        if let defaultLargeStagingDiskType = self.defaultLargeStagingDiskType {
            try encodeContainer.encode(defaultLargeStagingDiskType.rawValue, forKey: .defaultLargeStagingDiskType)
        }
        if let ebsEncryption = self.ebsEncryption {
            try encodeContainer.encode(ebsEncryption.rawValue, forKey: .ebsEncryption)
        }
        if let ebsEncryptionKeyArn = self.ebsEncryptionKeyArn {
            try encodeContainer.encode(ebsEncryptionKeyArn, forKey: .ebsEncryptionKeyArn)
        }
        if let replicationServerInstanceType = self.replicationServerInstanceType {
            try encodeContainer.encode(replicationServerInstanceType, forKey: .replicationServerInstanceType)
        }
        if let replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs {
            var replicationServersSecurityGroupsIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationServersSecurityGroupsIDs)
            for securitygroupid0 in replicationServersSecurityGroupsIDs {
                try replicationServersSecurityGroupsIDsContainer.encode(securitygroupid0)
            }
        }
        if let stagingAreaSubnetId = self.stagingAreaSubnetId {
            try encodeContainer.encode(stagingAreaSubnetId, forKey: .stagingAreaSubnetId)
        }
        if let stagingAreaTags = stagingAreaTags {
            var stagingAreaTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .stagingAreaTags)
            for (dictKey0, tagsMap0) in stagingAreaTags {
                try stagingAreaTagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let useDedicatedReplicationServer = self.useDedicatedReplicationServer {
            try encodeContainer.encode(useDedicatedReplicationServer, forKey: .useDedicatedReplicationServer)
        }
        if let useFipsEndpoint = self.useFipsEndpoint {
            try encodeContainer.encode(useFipsEndpoint, forKey: .useFipsEndpoint)
        }
    }
}

extension CreateReplicationConfigurationTemplateInput {

    static func urlPathProvider(_ value: CreateReplicationConfigurationTemplateInput) -> Swift.String? {
        return "/CreateReplicationConfigurationTemplate"
    }
}

public struct CreateReplicationConfigurationTemplateInput {
    /// Request to associate the default Application Migration Service Security group with the Replication Settings template.
    /// This member is required.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Request to configure bandwidth throttling during Replication Settings template creation.
    /// This member is required.
    public var bandwidthThrottling: Swift.Int
    /// Request to create Public IP during Replication Settings template creation.
    /// This member is required.
    public var createPublicIP: Swift.Bool?
    /// Request to configure data plane routing during Replication Settings template creation.
    /// This member is required.
    public var dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// Request to configure the default large staging disk EBS volume type during Replication Settings template creation.
    /// This member is required.
    public var defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// Request to configure EBS encryption during Replication Settings template creation.
    /// This member is required.
    public var ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    /// Request to configure an EBS encryption key during Replication Settings template creation.
    public var ebsEncryptionKeyArn: Swift.String?
    /// Request to configure the Replication Server instance type during Replication Settings template creation.
    /// This member is required.
    public var replicationServerInstanceType: Swift.String?
    /// Request to configure the Replication Server Security group ID during Replication Settings template creation.
    /// This member is required.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// Request to configure the Staging Area subnet ID during Replication Settings template creation.
    /// This member is required.
    public var stagingAreaSubnetId: Swift.String?
    /// Request to configure Staging Area tags during Replication Settings template creation.
    /// This member is required.
    public var stagingAreaTags: [Swift.String:Swift.String]?
    /// Request to configure tags during Replication Settings template creation.
    public var tags: [Swift.String:Swift.String]?
    /// Request to use Dedicated Replication Servers during Replication Settings template creation.
    /// This member is required.
    public var useDedicatedReplicationServer: Swift.Bool?
    /// Request to use Fips Endpoint during Replication Settings template creation.
    public var useFipsEndpoint: Swift.Bool?

    public init(
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String:Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil,
        useFipsEndpoint: Swift.Bool? = nil
    )
    {
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.tags = tags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
        self.useFipsEndpoint = useFipsEndpoint
    }
}

struct CreateReplicationConfigurationTemplateInputBody {
    let stagingAreaSubnetId: Swift.String?
    let associateDefaultSecurityGroup: Swift.Bool?
    let replicationServersSecurityGroupsIDs: [Swift.String]?
    let replicationServerInstanceType: Swift.String?
    let useDedicatedReplicationServer: Swift.Bool?
    let defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    let ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    let ebsEncryptionKeyArn: Swift.String?
    let bandwidthThrottling: Swift.Int
    let dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    let createPublicIP: Swift.Bool?
    let stagingAreaTags: [Swift.String:Swift.String]?
    let useFipsEndpoint: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
}

extension CreateReplicationConfigurationTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case tags
        case useDedicatedReplicationServer
        case useFipsEndpoint
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bandwidthThrottling) ?? 0
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
        let useFipsEndpointDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useFipsEndpoint)
        useFipsEndpoint = useFipsEndpointDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateReplicationConfigurationTemplateOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateReplicationConfigurationTemplateOutput(arn: \(Swift.String(describing: arn)), associateDefaultSecurityGroup: \(Swift.String(describing: associateDefaultSecurityGroup)), bandwidthThrottling: \(Swift.String(describing: bandwidthThrottling)), createPublicIP: \(Swift.String(describing: createPublicIP)), dataPlaneRouting: \(Swift.String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(Swift.String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(Swift.String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(Swift.String(describing: ebsEncryptionKeyArn)), replicationConfigurationTemplateID: \(Swift.String(describing: replicationConfigurationTemplateID)), replicationServerInstanceType: \(Swift.String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(Swift.String(describing: replicationServersSecurityGroupsIDs)), stagingAreaSubnetId: \(Swift.String(describing: stagingAreaSubnetId)), useDedicatedReplicationServer: \(Swift.String(describing: useDedicatedReplicationServer)), useFipsEndpoint: \(Swift.String(describing: useFipsEndpoint)), stagingAreaTags: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

extension CreateReplicationConfigurationTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateReplicationConfigurationTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.associateDefaultSecurityGroup = output.associateDefaultSecurityGroup
            self.bandwidthThrottling = output.bandwidthThrottling
            self.createPublicIP = output.createPublicIP
            self.dataPlaneRouting = output.dataPlaneRouting
            self.defaultLargeStagingDiskType = output.defaultLargeStagingDiskType
            self.ebsEncryption = output.ebsEncryption
            self.ebsEncryptionKeyArn = output.ebsEncryptionKeyArn
            self.replicationConfigurationTemplateID = output.replicationConfigurationTemplateID
            self.replicationServerInstanceType = output.replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = output.replicationServersSecurityGroupsIDs
            self.stagingAreaSubnetId = output.stagingAreaSubnetId
            self.stagingAreaTags = output.stagingAreaTags
            self.tags = output.tags
            self.useDedicatedReplicationServer = output.useDedicatedReplicationServer
            self.useFipsEndpoint = output.useFipsEndpoint
        } else {
            self.arn = nil
            self.associateDefaultSecurityGroup = nil
            self.bandwidthThrottling = 0
            self.createPublicIP = nil
            self.dataPlaneRouting = nil
            self.defaultLargeStagingDiskType = nil
            self.ebsEncryption = nil
            self.ebsEncryptionKeyArn = nil
            self.replicationConfigurationTemplateID = nil
            self.replicationServerInstanceType = nil
            self.replicationServersSecurityGroupsIDs = nil
            self.stagingAreaSubnetId = nil
            self.stagingAreaTags = nil
            self.tags = nil
            self.useDedicatedReplicationServer = nil
            self.useFipsEndpoint = nil
        }
    }
}

public struct CreateReplicationConfigurationTemplateOutput {
    /// Replication Configuration template ARN.
    public var arn: Swift.String?
    /// Replication Configuration template associate default Application Migration Service Security group.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Replication Configuration template bandwidth throttling.
    public var bandwidthThrottling: Swift.Int
    /// Replication Configuration template create Public IP.
    public var createPublicIP: Swift.Bool?
    /// Replication Configuration template data plane routing.
    public var dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// Replication Configuration template use default large Staging Disk type.
    public var defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// Replication Configuration template EBS encryption.
    public var ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    /// Replication Configuration template EBS encryption key ARN.
    public var ebsEncryptionKeyArn: Swift.String?
    /// Replication Configuration template ID.
    /// This member is required.
    public var replicationConfigurationTemplateID: Swift.String?
    /// Replication Configuration template server instance type.
    public var replicationServerInstanceType: Swift.String?
    /// Replication Configuration template server Security Groups IDs.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// Replication Configuration template Staging Area subnet ID.
    public var stagingAreaSubnetId: Swift.String?
    /// Replication Configuration template Staging Area Tags.
    public var stagingAreaTags: [Swift.String:Swift.String]?
    /// Replication Configuration template Tags.
    public var tags: [Swift.String:Swift.String]?
    /// Replication Configuration template use Dedicated Replication Server.
    public var useDedicatedReplicationServer: Swift.Bool?
    /// Replication Configuration template use Fips Endpoint.
    public var useFipsEndpoint: Swift.Bool?

    public init(
        arn: Swift.String? = nil,
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        replicationConfigurationTemplateID: Swift.String? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String:Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil,
        useFipsEndpoint: Swift.Bool? = nil
    )
    {
        self.arn = arn
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.tags = tags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
        self.useFipsEndpoint = useFipsEndpoint
    }
}

struct CreateReplicationConfigurationTemplateOutputBody {
    let replicationConfigurationTemplateID: Swift.String?
    let arn: Swift.String?
    let stagingAreaSubnetId: Swift.String?
    let associateDefaultSecurityGroup: Swift.Bool?
    let replicationServersSecurityGroupsIDs: [Swift.String]?
    let replicationServerInstanceType: Swift.String?
    let useDedicatedReplicationServer: Swift.Bool?
    let defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    let ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    let ebsEncryptionKeyArn: Swift.String?
    let bandwidthThrottling: Swift.Int
    let dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    let createPublicIP: Swift.Bool?
    let stagingAreaTags: [Swift.String:Swift.String]?
    let useFipsEndpoint: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
}

extension CreateReplicationConfigurationTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case replicationConfigurationTemplateID
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case tags
        case useDedicatedReplicationServer
        case useFipsEndpoint
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationConfigurationTemplateID)
        replicationConfigurationTemplateID = replicationConfigurationTemplateIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bandwidthThrottling) ?? 0
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
        let useFipsEndpointDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useFipsEndpoint)
        useFipsEndpoint = useFipsEndpointDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateReplicationConfigurationTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateWaveInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWaveInput(accountID: \(Swift.String(describing: accountID)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateWaveInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case description
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateWaveInput {

    static func urlPathProvider(_ value: CreateWaveInput) -> Swift.String? {
        return "/CreateWave"
    }
}

public struct CreateWaveInput {
    /// Account ID.
    public var accountID: Swift.String?
    /// Wave description.
    public var description: Swift.String?
    /// Wave name.
    /// This member is required.
    public var name: Swift.String?
    /// Wave tags.
    public var tags: [Swift.String:Swift.String]?

    public init(
        accountID: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.accountID = accountID
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateWaveInputBody {
    let name: Swift.String?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let accountID: Swift.String?
}

extension CreateWaveInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case description
        case name
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension CreateWaveOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWaveOutput(arn: \(Swift.String(describing: arn)), creationDateTime: \(Swift.String(describing: creationDateTime)), description: \(Swift.String(describing: description)), isArchived: \(Swift.String(describing: isArchived)), lastModifiedDateTime: \(Swift.String(describing: lastModifiedDateTime)), name: \(Swift.String(describing: name)), waveAggregatedStatus: \(Swift.String(describing: waveAggregatedStatus)), waveID: \(Swift.String(describing: waveID)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateWaveOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateWaveOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.isArchived = output.isArchived
            self.lastModifiedDateTime = output.lastModifiedDateTime
            self.name = output.name
            self.tags = output.tags
            self.waveAggregatedStatus = output.waveAggregatedStatus
            self.waveID = output.waveID
        } else {
            self.arn = nil
            self.creationDateTime = nil
            self.description = nil
            self.isArchived = nil
            self.lastModifiedDateTime = nil
            self.name = nil
            self.tags = nil
            self.waveAggregatedStatus = nil
            self.waveID = nil
        }
    }
}

public struct CreateWaveOutput {
    /// Wave ARN.
    public var arn: Swift.String?
    /// Wave creation dateTime.
    public var creationDateTime: Swift.String?
    /// Wave description.
    public var description: Swift.String?
    /// Wave archival status.
    public var isArchived: Swift.Bool?
    /// Wave last modified dateTime.
    public var lastModifiedDateTime: Swift.String?
    /// Wave name.
    public var name: Swift.String?
    /// Wave tags.
    public var tags: [Swift.String:Swift.String]?
    /// Wave aggregated status.
    public var waveAggregatedStatus: MgnClientTypes.WaveAggregatedStatus?
    /// Wave ID.
    public var waveID: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationDateTime: Swift.String? = nil,
        description: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        lastModifiedDateTime: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        waveAggregatedStatus: MgnClientTypes.WaveAggregatedStatus? = nil,
        waveID: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.description = description
        self.isArchived = isArchived
        self.lastModifiedDateTime = lastModifiedDateTime
        self.name = name
        self.tags = tags
        self.waveAggregatedStatus = waveAggregatedStatus
        self.waveID = waveID
    }
}

struct CreateWaveOutputBody {
    let waveID: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let isArchived: Swift.Bool?
    let waveAggregatedStatus: MgnClientTypes.WaveAggregatedStatus?
    let creationDateTime: Swift.String?
    let lastModifiedDateTime: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateWaveOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
        case description
        case isArchived
        case lastModifiedDateTime
        case name
        case tags
        case waveAggregatedStatus
        case waveID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let waveIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .waveID)
        waveID = waveIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let waveAggregatedStatusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.WaveAggregatedStatus.self, forKey: .waveAggregatedStatus)
        waveAggregatedStatus = waveAggregatedStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastModifiedDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedDateTime)
        lastModifiedDateTime = lastModifiedDateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateWaveOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MgnClientTypes.DataReplicationError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case rawError
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = self.error {
            try encodeContainer.encode(error.rawValue, forKey: .error)
        }
        if let rawError = self.rawError {
            try encodeContainer.encode(rawError, forKey: .rawError)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationErrorString.self, forKey: .error)
        error = errorDecoded
        let rawErrorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rawError)
        rawError = rawErrorDecoded
    }
}

extension MgnClientTypes {
    /// Error in data replication.
    public struct DataReplicationError {
        /// Error in data replication.
        public var error: MgnClientTypes.DataReplicationErrorString?
        /// Error in data replication.
        public var rawError: Swift.String?

        public init(
            error: MgnClientTypes.DataReplicationErrorString? = nil,
            rawError: Swift.String? = nil
        )
        {
            self.error = error
            self.rawError = rawError
        }
    }

}

extension MgnClientTypes {
    public enum DataReplicationErrorString: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case agentNotSeen
        case failedToAttachStagingDisks
        case failedToAuthenticateWithService
        case failedToBootReplicationServer
        case failedToConnectAgentToReplicationServer
        case failedToCreateSecurityGroup
        case failedToCreateStagingDisks
        case failedToDownloadReplicationSoftware
        case failedToLaunchReplicationServer
        case failedToPairReplicationServerWithAgent
        case failedToStartDataTransfer
        case lastSnapshotJobFailed
        case notConverging
        case snapshotsFailure
        case unstableNetwork
        case unsupportedVmConfiguration
        case sdkUnknown(Swift.String)

        public static var allCases: [DataReplicationErrorString] {
            return [
                .agentNotSeen,
                .failedToAttachStagingDisks,
                .failedToAuthenticateWithService,
                .failedToBootReplicationServer,
                .failedToConnectAgentToReplicationServer,
                .failedToCreateSecurityGroup,
                .failedToCreateStagingDisks,
                .failedToDownloadReplicationSoftware,
                .failedToLaunchReplicationServer,
                .failedToPairReplicationServerWithAgent,
                .failedToStartDataTransfer,
                .lastSnapshotJobFailed,
                .notConverging,
                .snapshotsFailure,
                .unstableNetwork,
                .unsupportedVmConfiguration,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agentNotSeen: return "AGENT_NOT_SEEN"
            case .failedToAttachStagingDisks: return "FAILED_TO_ATTACH_STAGING_DISKS"
            case .failedToAuthenticateWithService: return "FAILED_TO_AUTHENTICATE_WITH_SERVICE"
            case .failedToBootReplicationServer: return "FAILED_TO_BOOT_REPLICATION_SERVER"
            case .failedToConnectAgentToReplicationServer: return "FAILED_TO_CONNECT_AGENT_TO_REPLICATION_SERVER"
            case .failedToCreateSecurityGroup: return "FAILED_TO_CREATE_SECURITY_GROUP"
            case .failedToCreateStagingDisks: return "FAILED_TO_CREATE_STAGING_DISKS"
            case .failedToDownloadReplicationSoftware: return "FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE"
            case .failedToLaunchReplicationServer: return "FAILED_TO_LAUNCH_REPLICATION_SERVER"
            case .failedToPairReplicationServerWithAgent: return "FAILED_TO_PAIR_REPLICATION_SERVER_WITH_AGENT"
            case .failedToStartDataTransfer: return "FAILED_TO_START_DATA_TRANSFER"
            case .lastSnapshotJobFailed: return "LAST_SNAPSHOT_JOB_FAILED"
            case .notConverging: return "NOT_CONVERGING"
            case .snapshotsFailure: return "SNAPSHOTS_FAILURE"
            case .unstableNetwork: return "UNSTABLE_NETWORK"
            case .unsupportedVmConfiguration: return "UNSUPPORTED_VM_CONFIGURATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataReplicationErrorString(rawValue: rawValue) ?? DataReplicationErrorString.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes.DataReplicationInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataReplicationError
        case dataReplicationInitiation
        case dataReplicationState
        case etaDateTime
        case lagDuration
        case lastSnapshotDateTime
        case replicatedDisks
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataReplicationError = self.dataReplicationError {
            try encodeContainer.encode(dataReplicationError, forKey: .dataReplicationError)
        }
        if let dataReplicationInitiation = self.dataReplicationInitiation {
            try encodeContainer.encode(dataReplicationInitiation, forKey: .dataReplicationInitiation)
        }
        if let dataReplicationState = self.dataReplicationState {
            try encodeContainer.encode(dataReplicationState.rawValue, forKey: .dataReplicationState)
        }
        if let etaDateTime = self.etaDateTime {
            try encodeContainer.encode(etaDateTime, forKey: .etaDateTime)
        }
        if let lagDuration = self.lagDuration {
            try encodeContainer.encode(lagDuration, forKey: .lagDuration)
        }
        if let lastSnapshotDateTime = self.lastSnapshotDateTime {
            try encodeContainer.encode(lastSnapshotDateTime, forKey: .lastSnapshotDateTime)
        }
        if let replicatedDisks = replicatedDisks {
            var replicatedDisksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicatedDisks)
            for datareplicationinforeplicateddisk0 in replicatedDisks {
                try replicatedDisksContainer.encode(datareplicationinforeplicateddisk0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lagDurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lagDuration)
        lagDuration = lagDurationDecoded
        let etaDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .etaDateTime)
        etaDateTime = etaDateTimeDecoded
        let replicatedDisksContainer = try containerValues.decodeIfPresent([MgnClientTypes.DataReplicationInfoReplicatedDisk?].self, forKey: .replicatedDisks)
        var replicatedDisksDecoded0:[MgnClientTypes.DataReplicationInfoReplicatedDisk]? = nil
        if let replicatedDisksContainer = replicatedDisksContainer {
            replicatedDisksDecoded0 = [MgnClientTypes.DataReplicationInfoReplicatedDisk]()
            for structure0 in replicatedDisksContainer {
                if let structure0 = structure0 {
                    replicatedDisksDecoded0?.append(structure0)
                }
            }
        }
        replicatedDisks = replicatedDisksDecoded0
        let dataReplicationStateDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationState.self, forKey: .dataReplicationState)
        dataReplicationState = dataReplicationStateDecoded
        let dataReplicationInitiationDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationInitiation.self, forKey: .dataReplicationInitiation)
        dataReplicationInitiation = dataReplicationInitiationDecoded
        let dataReplicationErrorDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationError.self, forKey: .dataReplicationError)
        dataReplicationError = dataReplicationErrorDecoded
        let lastSnapshotDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastSnapshotDateTime)
        lastSnapshotDateTime = lastSnapshotDateTimeDecoded
    }
}

extension MgnClientTypes {
    /// Request data replication info.
    public struct DataReplicationInfo {
        /// Error in obtaining data replication info.
        public var dataReplicationError: MgnClientTypes.DataReplicationError?
        /// Request to query whether data replication has been initiated.
        public var dataReplicationInitiation: MgnClientTypes.DataReplicationInitiation?
        /// Request to query the data replication state.
        public var dataReplicationState: MgnClientTypes.DataReplicationState?
        /// Request to query the time when data replication will be complete.
        public var etaDateTime: Swift.String?
        /// Request to query data replication lag duration.
        public var lagDuration: Swift.String?
        /// Request to query data replication last snapshot time.
        public var lastSnapshotDateTime: Swift.String?
        /// Request to query disks replicated.
        public var replicatedDisks: [MgnClientTypes.DataReplicationInfoReplicatedDisk]?

        public init(
            dataReplicationError: MgnClientTypes.DataReplicationError? = nil,
            dataReplicationInitiation: MgnClientTypes.DataReplicationInitiation? = nil,
            dataReplicationState: MgnClientTypes.DataReplicationState? = nil,
            etaDateTime: Swift.String? = nil,
            lagDuration: Swift.String? = nil,
            lastSnapshotDateTime: Swift.String? = nil,
            replicatedDisks: [MgnClientTypes.DataReplicationInfoReplicatedDisk]? = nil
        )
        {
            self.dataReplicationError = dataReplicationError
            self.dataReplicationInitiation = dataReplicationInitiation
            self.dataReplicationState = dataReplicationState
            self.etaDateTime = etaDateTime
            self.lagDuration = lagDuration
            self.lastSnapshotDateTime = lastSnapshotDateTime
            self.replicatedDisks = replicatedDisks
        }
    }

}

extension MgnClientTypes.DataReplicationInfoReplicatedDisk: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backloggedStorageBytes
        case deviceName
        case replicatedStorageBytes
        case rescannedStorageBytes
        case totalStorageBytes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if backloggedStorageBytes != 0 {
            try encodeContainer.encode(backloggedStorageBytes, forKey: .backloggedStorageBytes)
        }
        if let deviceName = self.deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if replicatedStorageBytes != 0 {
            try encodeContainer.encode(replicatedStorageBytes, forKey: .replicatedStorageBytes)
        }
        if rescannedStorageBytes != 0 {
            try encodeContainer.encode(rescannedStorageBytes, forKey: .rescannedStorageBytes)
        }
        if totalStorageBytes != 0 {
            try encodeContainer.encode(totalStorageBytes, forKey: .totalStorageBytes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let totalStorageBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalStorageBytes) ?? 0
        totalStorageBytes = totalStorageBytesDecoded
        let replicatedStorageBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .replicatedStorageBytes) ?? 0
        replicatedStorageBytes = replicatedStorageBytesDecoded
        let rescannedStorageBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rescannedStorageBytes) ?? 0
        rescannedStorageBytes = rescannedStorageBytesDecoded
        let backloggedStorageBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backloggedStorageBytes) ?? 0
        backloggedStorageBytes = backloggedStorageBytesDecoded
    }
}

extension MgnClientTypes {
    /// Request to query disks replicated.
    public struct DataReplicationInfoReplicatedDisk {
        /// Request to query data replication backlog size in bytes.
        public var backloggedStorageBytes: Swift.Int
        /// Request to query device name.
        public var deviceName: Swift.String?
        /// Request to query amount of data replicated in bytes.
        public var replicatedStorageBytes: Swift.Int
        /// Request to query amount of data rescanned in bytes.
        public var rescannedStorageBytes: Swift.Int
        /// Request to query total amount of data replicated in bytes.
        public var totalStorageBytes: Swift.Int

        public init(
            backloggedStorageBytes: Swift.Int = 0,
            deviceName: Swift.String? = nil,
            replicatedStorageBytes: Swift.Int = 0,
            rescannedStorageBytes: Swift.Int = 0,
            totalStorageBytes: Swift.Int = 0
        )
        {
            self.backloggedStorageBytes = backloggedStorageBytes
            self.deviceName = deviceName
            self.replicatedStorageBytes = replicatedStorageBytes
            self.rescannedStorageBytes = rescannedStorageBytes
            self.totalStorageBytes = totalStorageBytes
        }
    }

}

extension MgnClientTypes.DataReplicationInitiation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextAttemptDateTime
        case startDateTime
        case steps
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextAttemptDateTime = self.nextAttemptDateTime {
            try encodeContainer.encode(nextAttemptDateTime, forKey: .nextAttemptDateTime)
        }
        if let startDateTime = self.startDateTime {
            try encodeContainer.encode(startDateTime, forKey: .startDateTime)
        }
        if let steps = steps {
            var stepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .steps)
            for datareplicationinitiationstep0 in steps {
                try stepsContainer.encode(datareplicationinitiationstep0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startDateTime)
        startDateTime = startDateTimeDecoded
        let nextAttemptDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextAttemptDateTime)
        nextAttemptDateTime = nextAttemptDateTimeDecoded
        let stepsContainer = try containerValues.decodeIfPresent([MgnClientTypes.DataReplicationInitiationStep?].self, forKey: .steps)
        var stepsDecoded0:[MgnClientTypes.DataReplicationInitiationStep]? = nil
        if let stepsContainer = stepsContainer {
            stepsDecoded0 = [MgnClientTypes.DataReplicationInitiationStep]()
            for structure0 in stepsContainer {
                if let structure0 = structure0 {
                    stepsDecoded0?.append(structure0)
                }
            }
        }
        steps = stepsDecoded0
    }
}

extension MgnClientTypes {
    /// Data replication initiation.
    public struct DataReplicationInitiation {
        /// Request to query next data initiation date and time.
        public var nextAttemptDateTime: Swift.String?
        /// Request to query data initiation start date and time.
        public var startDateTime: Swift.String?
        /// Request to query data initiation steps.
        public var steps: [MgnClientTypes.DataReplicationInitiationStep]?

        public init(
            nextAttemptDateTime: Swift.String? = nil,
            startDateTime: Swift.String? = nil,
            steps: [MgnClientTypes.DataReplicationInitiationStep]? = nil
        )
        {
            self.nextAttemptDateTime = nextAttemptDateTime
            self.startDateTime = startDateTime
            self.steps = steps
        }
    }

}

extension MgnClientTypes.DataReplicationInitiationStep: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationInitiationStepName.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationInitiationStepStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension MgnClientTypes {
    /// Data replication initiation step.
    public struct DataReplicationInitiationStep {
        /// Request to query data initiation step name.
        public var name: MgnClientTypes.DataReplicationInitiationStepName?
        /// Request to query data initiation status.
        public var status: MgnClientTypes.DataReplicationInitiationStepStatus?

        public init(
            name: MgnClientTypes.DataReplicationInitiationStepName? = nil,
            status: MgnClientTypes.DataReplicationInitiationStepStatus? = nil
        )
        {
            self.name = name
            self.status = status
        }
    }

}

extension MgnClientTypes {
    public enum DataReplicationInitiationStepName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case attachStagingDisks
        case authenticateWithService
        case bootReplicationServer
        case connectAgentToReplicationServer
        case createSecurityGroup
        case createStagingDisks
        case downloadReplicationSoftware
        case launchReplicationServer
        case pairReplicationServerWithAgent
        case startDataTransfer
        case wait
        case sdkUnknown(Swift.String)

        public static var allCases: [DataReplicationInitiationStepName] {
            return [
                .attachStagingDisks,
                .authenticateWithService,
                .bootReplicationServer,
                .connectAgentToReplicationServer,
                .createSecurityGroup,
                .createStagingDisks,
                .downloadReplicationSoftware,
                .launchReplicationServer,
                .pairReplicationServerWithAgent,
                .startDataTransfer,
                .wait,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .attachStagingDisks: return "ATTACH_STAGING_DISKS"
            case .authenticateWithService: return "AUTHENTICATE_WITH_SERVICE"
            case .bootReplicationServer: return "BOOT_REPLICATION_SERVER"
            case .connectAgentToReplicationServer: return "CONNECT_AGENT_TO_REPLICATION_SERVER"
            case .createSecurityGroup: return "CREATE_SECURITY_GROUP"
            case .createStagingDisks: return "CREATE_STAGING_DISKS"
            case .downloadReplicationSoftware: return "DOWNLOAD_REPLICATION_SOFTWARE"
            case .launchReplicationServer: return "LAUNCH_REPLICATION_SERVER"
            case .pairReplicationServerWithAgent: return "PAIR_REPLICATION_SERVER_WITH_AGENT"
            case .startDataTransfer: return "START_DATA_TRANSFER"
            case .wait: return "WAIT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataReplicationInitiationStepName(rawValue: rawValue) ?? DataReplicationInitiationStepName.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes {
    public enum DataReplicationInitiationStepStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case notStarted
        case skipped
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [DataReplicationInitiationStepStatus] {
            return [
                .failed,
                .inProgress,
                .notStarted,
                .skipped,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case .skipped: return "SKIPPED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataReplicationInitiationStepStatus(rawValue: rawValue) ?? DataReplicationInitiationStepStatus.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes {
    public enum DataReplicationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case backlog
        case continuous
        case creatingSnapshot
        case disconnected
        case initialSync
        case initiating
        case paused
        case pendingSnapshotShipping
        case rescan
        case shippingSnapshot
        case stalled
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [DataReplicationState] {
            return [
                .backlog,
                .continuous,
                .creatingSnapshot,
                .disconnected,
                .initialSync,
                .initiating,
                .paused,
                .pendingSnapshotShipping,
                .rescan,
                .shippingSnapshot,
                .stalled,
                .stopped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .backlog: return "BACKLOG"
            case .continuous: return "CONTINUOUS"
            case .creatingSnapshot: return "CREATING_SNAPSHOT"
            case .disconnected: return "DISCONNECTED"
            case .initialSync: return "INITIAL_SYNC"
            case .initiating: return "INITIATING"
            case .paused: return "PAUSED"
            case .pendingSnapshotShipping: return "PENDING_SNAPSHOT_SHIPPING"
            case .rescan: return "RESCAN"
            case .shippingSnapshot: return "SHIPPING_SNAPSHOT"
            case .stalled: return "STALLED"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataReplicationState(rawValue: rawValue) ?? DataReplicationState.sdkUnknown(rawValue)
        }
    }
}

extension DeleteApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case applicationID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let applicationID = self.applicationID {
            try encodeContainer.encode(applicationID, forKey: .applicationID)
        }
    }
}

extension DeleteApplicationInput {

    static func urlPathProvider(_ value: DeleteApplicationInput) -> Swift.String? {
        return "/DeleteApplication"
    }
}

public struct DeleteApplicationInput {
    /// Account ID.
    public var accountID: Swift.String?
    /// Application ID.
    /// This member is required.
    public var applicationID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        applicationID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.applicationID = applicationID
    }
}

struct DeleteApplicationInputBody {
    let applicationID: Swift.String?
    let accountID: Swift.String?
}

extension DeleteApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case applicationID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension DeleteApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteApplicationOutput {

    public init() { }
}

enum DeleteApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteConnectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorID = self.connectorID {
            try encodeContainer.encode(connectorID, forKey: .connectorID)
        }
    }
}

extension DeleteConnectorInput {

    static func urlPathProvider(_ value: DeleteConnectorInput) -> Swift.String? {
        return "/DeleteConnector"
    }
}

public struct DeleteConnectorInput {
    /// Delete Connector request connector ID.
    /// This member is required.
    public var connectorID: Swift.String?

    public init(
        connectorID: Swift.String? = nil
    )
    {
        self.connectorID = connectorID
    }
}

struct DeleteConnectorInputBody {
    let connectorID: Swift.String?
}

extension DeleteConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorID)
        connectorID = connectorIDDecoded
    }
}

extension DeleteConnectorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteConnectorOutput {

    public init() { }
}

enum DeleteConnectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case jobID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let jobID = self.jobID {
            try encodeContainer.encode(jobID, forKey: .jobID)
        }
    }
}

extension DeleteJobInput {

    static func urlPathProvider(_ value: DeleteJobInput) -> Swift.String? {
        return "/DeleteJob"
    }
}

public struct DeleteJobInput {
    /// Request to delete Job from service by Account ID.
    public var accountID: Swift.String?
    /// Request to delete Job from service by Job ID.
    /// This member is required.
    public var jobID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        jobID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.jobID = jobID
    }
}

struct DeleteJobInputBody {
    let jobID: Swift.String?
    let accountID: Swift.String?
}

extension DeleteJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case jobID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobID)
        jobID = jobIDDecoded
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension DeleteJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteJobOutput {

    public init() { }
}

enum DeleteJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteLaunchConfigurationTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchConfigurationTemplateID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let launchConfigurationTemplateID = self.launchConfigurationTemplateID {
            try encodeContainer.encode(launchConfigurationTemplateID, forKey: .launchConfigurationTemplateID)
        }
    }
}

extension DeleteLaunchConfigurationTemplateInput {

    static func urlPathProvider(_ value: DeleteLaunchConfigurationTemplateInput) -> Swift.String? {
        return "/DeleteLaunchConfigurationTemplate"
    }
}

public struct DeleteLaunchConfigurationTemplateInput {
    /// ID of resource to be deleted.
    /// This member is required.
    public var launchConfigurationTemplateID: Swift.String?

    public init(
        launchConfigurationTemplateID: Swift.String? = nil
    )
    {
        self.launchConfigurationTemplateID = launchConfigurationTemplateID
    }
}

struct DeleteLaunchConfigurationTemplateInputBody {
    let launchConfigurationTemplateID: Swift.String?
}

extension DeleteLaunchConfigurationTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchConfigurationTemplateID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchConfigurationTemplateID)
        launchConfigurationTemplateID = launchConfigurationTemplateIDDecoded
    }
}

extension DeleteLaunchConfigurationTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteLaunchConfigurationTemplateOutput {

    public init() { }
}

enum DeleteLaunchConfigurationTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteReplicationConfigurationTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationConfigurationTemplateID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationConfigurationTemplateID = self.replicationConfigurationTemplateID {
            try encodeContainer.encode(replicationConfigurationTemplateID, forKey: .replicationConfigurationTemplateID)
        }
    }
}

extension DeleteReplicationConfigurationTemplateInput {

    static func urlPathProvider(_ value: DeleteReplicationConfigurationTemplateInput) -> Swift.String? {
        return "/DeleteReplicationConfigurationTemplate"
    }
}

public struct DeleteReplicationConfigurationTemplateInput {
    /// Request to delete Replication Configuration Template from service by Replication Configuration Template ID.
    /// This member is required.
    public var replicationConfigurationTemplateID: Swift.String?

    public init(
        replicationConfigurationTemplateID: Swift.String? = nil
    )
    {
        self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
    }
}

struct DeleteReplicationConfigurationTemplateInputBody {
    let replicationConfigurationTemplateID: Swift.String?
}

extension DeleteReplicationConfigurationTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationConfigurationTemplateID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationConfigurationTemplateID)
        replicationConfigurationTemplateID = replicationConfigurationTemplateIDDecoded
    }
}

extension DeleteReplicationConfigurationTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteReplicationConfigurationTemplateOutput {

    public init() { }
}

enum DeleteReplicationConfigurationTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSourceServerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension DeleteSourceServerInput {

    static func urlPathProvider(_ value: DeleteSourceServerInput) -> Swift.String? {
        return "/DeleteSourceServer"
    }
}

public struct DeleteSourceServerInput {
    /// Request to delete Source Server from service by Account ID.
    public var accountID: Swift.String?
    /// Request to delete Source Server from service by Server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.sourceServerID = sourceServerID
    }
}

struct DeleteSourceServerInputBody {
    let sourceServerID: Swift.String?
    let accountID: Swift.String?
}

extension DeleteSourceServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case sourceServerID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension DeleteSourceServerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSourceServerOutput {

    public init() { }
}

enum DeleteSourceServerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVcenterClientInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vcenterClientID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vcenterClientID = self.vcenterClientID {
            try encodeContainer.encode(vcenterClientID, forKey: .vcenterClientID)
        }
    }
}

extension DeleteVcenterClientInput {

    static func urlPathProvider(_ value: DeleteVcenterClientInput) -> Swift.String? {
        return "/DeleteVcenterClient"
    }
}

public struct DeleteVcenterClientInput {
    /// ID of resource to be deleted.
    /// This member is required.
    public var vcenterClientID: Swift.String?

    public init(
        vcenterClientID: Swift.String? = nil
    )
    {
        self.vcenterClientID = vcenterClientID
    }
}

struct DeleteVcenterClientInputBody {
    let vcenterClientID: Swift.String?
}

extension DeleteVcenterClientInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vcenterClientID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vcenterClientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcenterClientID)
        vcenterClientID = vcenterClientIDDecoded
    }
}

extension DeleteVcenterClientOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteVcenterClientOutput {

    public init() { }
}

enum DeleteVcenterClientOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteWaveInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case waveID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let waveID = self.waveID {
            try encodeContainer.encode(waveID, forKey: .waveID)
        }
    }
}

extension DeleteWaveInput {

    static func urlPathProvider(_ value: DeleteWaveInput) -> Swift.String? {
        return "/DeleteWave"
    }
}

public struct DeleteWaveInput {
    /// Account ID.
    public var accountID: Swift.String?
    /// Wave ID.
    /// This member is required.
    public var waveID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        waveID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.waveID = waveID
    }
}

struct DeleteWaveInputBody {
    let waveID: Swift.String?
    let accountID: Swift.String?
}

extension DeleteWaveInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case waveID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let waveIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .waveID)
        waveID = waveIDDecoded
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension DeleteWaveOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteWaveOutput {

    public init() { }
}

enum DeleteWaveOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeJobLogItemsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case jobID
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let jobID = self.jobID {
            try encodeContainer.encode(jobID, forKey: .jobID)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeJobLogItemsInput {

    static func urlPathProvider(_ value: DescribeJobLogItemsInput) -> Swift.String? {
        return "/DescribeJobLogItems"
    }
}

public struct DescribeJobLogItemsInput {
    /// Request to describe Job log Account ID.
    public var accountID: Swift.String?
    /// Request to describe Job log job ID.
    /// This member is required.
    public var jobID: Swift.String?
    /// Request to describe Job log item maximum results.
    public var maxResults: Swift.Int?
    /// Request to describe Job log next token.
    public var nextToken: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        jobID: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.jobID = jobID
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeJobLogItemsInputBody {
    let jobID: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let accountID: Swift.String?
}

extension DescribeJobLogItemsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case jobID
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobID)
        jobID = jobIDDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension DescribeJobLogItemsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeJobLogItemsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeJobLogItemsOutput {
    /// Request to describe Job log response items.
    public var items: [MgnClientTypes.JobLog]?
    /// Request to describe Job log response next token.
    public var nextToken: Swift.String?

    public init(
        items: [MgnClientTypes.JobLog]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct DescribeJobLogItemsOutputBody {
    let items: [MgnClientTypes.JobLog]?
    let nextToken: Swift.String?
}

extension DescribeJobLogItemsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MgnClientTypes.JobLog?].self, forKey: .items)
        var itemsDecoded0:[MgnClientTypes.JobLog]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MgnClientTypes.JobLog]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeJobLogItemsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeJobsInput {

    static func urlPathProvider(_ value: DescribeJobsInput) -> Swift.String? {
        return "/DescribeJobs"
    }
}

public struct DescribeJobsInput {
    /// Request to describe job log items by Account ID.
    public var accountID: Swift.String?
    /// Request to describe Job log filters.
    public var filters: MgnClientTypes.DescribeJobsRequestFilters?
    /// Request to describe job log items by max results.
    public var maxResults: Swift.Int?
    /// Request to describe job log items by next token.
    public var nextToken: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        filters: MgnClientTypes.DescribeJobsRequestFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeJobsInputBody {
    let filters: MgnClientTypes.DescribeJobsRequestFilters?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let accountID: Swift.String?
}

extension DescribeJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DescribeJobsRequestFilters.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension DescribeJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeJobsOutput {
    /// Request to describe Job log items.
    public var items: [MgnClientTypes.Job]?
    /// Request to describe Job response by next token.
    public var nextToken: Swift.String?

    public init(
        items: [MgnClientTypes.Job]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct DescribeJobsOutputBody {
    let items: [MgnClientTypes.Job]?
    let nextToken: Swift.String?
}

extension DescribeJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MgnClientTypes.Job?].self, forKey: .items)
        var itemsDecoded0:[MgnClientTypes.Job]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MgnClientTypes.Job]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MgnClientTypes.DescribeJobsRequestFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromDate
        case jobIDs
        case toDate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromDate = self.fromDate {
            try encodeContainer.encode(fromDate, forKey: .fromDate)
        }
        if let jobIDs = jobIDs {
            var jobIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .jobIDs)
            for jobid0 in jobIDs {
                try jobIDsContainer.encode(jobid0)
            }
        }
        if let toDate = self.toDate {
            try encodeContainer.encode(toDate, forKey: .toDate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .jobIDs)
        var jobIDsDecoded0:[Swift.String]? = nil
        if let jobIDsContainer = jobIDsContainer {
            jobIDsDecoded0 = [Swift.String]()
            for string0 in jobIDsContainer {
                if let string0 = string0 {
                    jobIDsDecoded0?.append(string0)
                }
            }
        }
        jobIDs = jobIDsDecoded0
        let fromDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fromDate)
        fromDate = fromDateDecoded
        let toDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .toDate)
        toDate = toDateDecoded
    }
}

extension MgnClientTypes {
    /// Request to describe Job log filters.
    public struct DescribeJobsRequestFilters {
        /// Request to describe Job log filters by date.
        public var fromDate: Swift.String?
        /// Request to describe Job log filters by job ID.
        public var jobIDs: [Swift.String]?
        /// Request to describe job log items by last date.
        public var toDate: Swift.String?

        public init(
            fromDate: Swift.String? = nil,
            jobIDs: [Swift.String]? = nil,
            toDate: Swift.String? = nil
        )
        {
            self.fromDate = fromDate
            self.jobIDs = jobIDs
            self.toDate = toDate
        }
    }

}

extension DescribeLaunchConfigurationTemplatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchConfigurationTemplateIDs
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let launchConfigurationTemplateIDs = launchConfigurationTemplateIDs {
            var launchConfigurationTemplateIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .launchConfigurationTemplateIDs)
            for launchconfigurationtemplateid0 in launchConfigurationTemplateIDs {
                try launchConfigurationTemplateIDsContainer.encode(launchconfigurationtemplateid0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeLaunchConfigurationTemplatesInput {

    static func urlPathProvider(_ value: DescribeLaunchConfigurationTemplatesInput) -> Swift.String? {
        return "/DescribeLaunchConfigurationTemplates"
    }
}

public struct DescribeLaunchConfigurationTemplatesInput {
    /// Request to filter Launch Configuration Templates list by Launch Configuration Template ID.
    public var launchConfigurationTemplateIDs: [Swift.String]?
    /// Maximum results to be returned in DescribeLaunchConfigurationTemplates.
    public var maxResults: Swift.Int?
    /// Next pagination token returned from DescribeLaunchConfigurationTemplates.
    public var nextToken: Swift.String?

    public init(
        launchConfigurationTemplateIDs: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.launchConfigurationTemplateIDs = launchConfigurationTemplateIDs
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeLaunchConfigurationTemplatesInputBody {
    let launchConfigurationTemplateIDs: [Swift.String]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeLaunchConfigurationTemplatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchConfigurationTemplateIDs
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchConfigurationTemplateIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .launchConfigurationTemplateIDs)
        var launchConfigurationTemplateIDsDecoded0:[Swift.String]? = nil
        if let launchConfigurationTemplateIDsContainer = launchConfigurationTemplateIDsContainer {
            launchConfigurationTemplateIDsDecoded0 = [Swift.String]()
            for string0 in launchConfigurationTemplateIDsContainer {
                if let string0 = string0 {
                    launchConfigurationTemplateIDsDecoded0?.append(string0)
                }
            }
        }
        launchConfigurationTemplateIDs = launchConfigurationTemplateIDsDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeLaunchConfigurationTemplatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeLaunchConfigurationTemplatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeLaunchConfigurationTemplatesOutput {
    /// List of items returned by DescribeLaunchConfigurationTemplates.
    public var items: [MgnClientTypes.LaunchConfigurationTemplate]?
    /// Next pagination token returned from DescribeLaunchConfigurationTemplates.
    public var nextToken: Swift.String?

    public init(
        items: [MgnClientTypes.LaunchConfigurationTemplate]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct DescribeLaunchConfigurationTemplatesOutputBody {
    let items: [MgnClientTypes.LaunchConfigurationTemplate]?
    let nextToken: Swift.String?
}

extension DescribeLaunchConfigurationTemplatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MgnClientTypes.LaunchConfigurationTemplate?].self, forKey: .items)
        var itemsDecoded0:[MgnClientTypes.LaunchConfigurationTemplate]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MgnClientTypes.LaunchConfigurationTemplate]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeLaunchConfigurationTemplatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeReplicationConfigurationTemplatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case replicationConfigurationTemplateIDs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let replicationConfigurationTemplateIDs = replicationConfigurationTemplateIDs {
            var replicationConfigurationTemplateIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationConfigurationTemplateIDs)
            for replicationconfigurationtemplateid0 in replicationConfigurationTemplateIDs {
                try replicationConfigurationTemplateIDsContainer.encode(replicationconfigurationtemplateid0)
            }
        }
    }
}

extension DescribeReplicationConfigurationTemplatesInput {

    static func urlPathProvider(_ value: DescribeReplicationConfigurationTemplatesInput) -> Swift.String? {
        return "/DescribeReplicationConfigurationTemplates"
    }
}

public struct DescribeReplicationConfigurationTemplatesInput {
    /// Request to describe Replication Configuration template by max results.
    public var maxResults: Swift.Int?
    /// Request to describe Replication Configuration template by next token.
    public var nextToken: Swift.String?
    /// Request to describe Replication Configuration template by template IDs.
    public var replicationConfigurationTemplateIDs: [Swift.String]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        replicationConfigurationTemplateIDs: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.replicationConfigurationTemplateIDs = replicationConfigurationTemplateIDs
    }
}

struct DescribeReplicationConfigurationTemplatesInputBody {
    let replicationConfigurationTemplateIDs: [Swift.String]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeReplicationConfigurationTemplatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case replicationConfigurationTemplateIDs
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationTemplateIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationConfigurationTemplateIDs)
        var replicationConfigurationTemplateIDsDecoded0:[Swift.String]? = nil
        if let replicationConfigurationTemplateIDsContainer = replicationConfigurationTemplateIDsContainer {
            replicationConfigurationTemplateIDsDecoded0 = [Swift.String]()
            for string0 in replicationConfigurationTemplateIDsContainer {
                if let string0 = string0 {
                    replicationConfigurationTemplateIDsDecoded0?.append(string0)
                }
            }
        }
        replicationConfigurationTemplateIDs = replicationConfigurationTemplateIDsDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeReplicationConfigurationTemplatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeReplicationConfigurationTemplatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeReplicationConfigurationTemplatesOutput {
    /// Request to describe Replication Configuration template by items.
    public var items: [MgnClientTypes.ReplicationConfigurationTemplate]?
    /// Request to describe Replication Configuration template by next token.
    public var nextToken: Swift.String?

    public init(
        items: [MgnClientTypes.ReplicationConfigurationTemplate]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct DescribeReplicationConfigurationTemplatesOutputBody {
    let items: [MgnClientTypes.ReplicationConfigurationTemplate]?
    let nextToken: Swift.String?
}

extension DescribeReplicationConfigurationTemplatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MgnClientTypes.ReplicationConfigurationTemplate?].self, forKey: .items)
        var itemsDecoded0:[MgnClientTypes.ReplicationConfigurationTemplate]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MgnClientTypes.ReplicationConfigurationTemplate]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeReplicationConfigurationTemplatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeSourceServersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeSourceServersInput {

    static func urlPathProvider(_ value: DescribeSourceServersInput) -> Swift.String? {
        return "/DescribeSourceServers"
    }
}

public struct DescribeSourceServersInput {
    /// Request to filter Source Servers list by Accoun ID.
    public var accountID: Swift.String?
    /// Request to filter Source Servers list.
    public var filters: MgnClientTypes.DescribeSourceServersRequestFilters?
    /// Request to filter Source Servers list by maximum results.
    public var maxResults: Swift.Int?
    /// Request to filter Source Servers list by next token.
    public var nextToken: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        filters: MgnClientTypes.DescribeSourceServersRequestFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeSourceServersInputBody {
    let filters: MgnClientTypes.DescribeSourceServersRequestFilters?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let accountID: Swift.String?
}

extension DescribeSourceServersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DescribeSourceServersRequestFilters.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension DescribeSourceServersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSourceServersOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeSourceServersOutput {
    /// Request to filter Source Servers list by item.
    public var items: [MgnClientTypes.SourceServer]?
    /// Request to filter Source Servers next token.
    public var nextToken: Swift.String?

    public init(
        items: [MgnClientTypes.SourceServer]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct DescribeSourceServersOutputBody {
    let items: [MgnClientTypes.SourceServer]?
    let nextToken: Swift.String?
}

extension DescribeSourceServersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MgnClientTypes.SourceServer?].self, forKey: .items)
        var itemsDecoded0:[MgnClientTypes.SourceServer]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MgnClientTypes.SourceServer]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeSourceServersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MgnClientTypes.DescribeSourceServersRequestFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationIDs
        case isArchived
        case lifeCycleStates
        case replicationTypes
        case sourceServerIDs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationIDs = applicationIDs {
            var applicationIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applicationIDs)
            for applicationid0 in applicationIDs {
                try applicationIDsContainer.encode(applicationid0)
            }
        }
        if let isArchived = self.isArchived {
            try encodeContainer.encode(isArchived, forKey: .isArchived)
        }
        if let lifeCycleStates = lifeCycleStates {
            var lifeCycleStatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lifeCycleStates)
            for lifecyclestate0 in lifeCycleStates {
                try lifeCycleStatesContainer.encode(lifecyclestate0.rawValue)
            }
        }
        if let replicationTypes = replicationTypes {
            var replicationTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationTypes)
            for replicationtype0 in replicationTypes {
                try replicationTypesContainer.encode(replicationtype0.rawValue)
            }
        }
        if let sourceServerIDs = sourceServerIDs {
            var sourceServerIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceServerIDs)
            for sourceserverid0 in sourceServerIDs {
                try sourceServerIDsContainer.encode(sourceserverid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceServerIDs)
        var sourceServerIDsDecoded0:[Swift.String]? = nil
        if let sourceServerIDsContainer = sourceServerIDsContainer {
            sourceServerIDsDecoded0 = [Swift.String]()
            for string0 in sourceServerIDsContainer {
                if let string0 = string0 {
                    sourceServerIDsDecoded0?.append(string0)
                }
            }
        }
        sourceServerIDs = sourceServerIDsDecoded0
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let replicationTypesContainer = try containerValues.decodeIfPresent([MgnClientTypes.ReplicationType?].self, forKey: .replicationTypes)
        var replicationTypesDecoded0:[MgnClientTypes.ReplicationType]? = nil
        if let replicationTypesContainer = replicationTypesContainer {
            replicationTypesDecoded0 = [MgnClientTypes.ReplicationType]()
            for string0 in replicationTypesContainer {
                if let string0 = string0 {
                    replicationTypesDecoded0?.append(string0)
                }
            }
        }
        replicationTypes = replicationTypesDecoded0
        let lifeCycleStatesContainer = try containerValues.decodeIfPresent([MgnClientTypes.LifeCycleState?].self, forKey: .lifeCycleStates)
        var lifeCycleStatesDecoded0:[MgnClientTypes.LifeCycleState]? = nil
        if let lifeCycleStatesContainer = lifeCycleStatesContainer {
            lifeCycleStatesDecoded0 = [MgnClientTypes.LifeCycleState]()
            for string0 in lifeCycleStatesContainer {
                if let string0 = string0 {
                    lifeCycleStatesDecoded0?.append(string0)
                }
            }
        }
        lifeCycleStates = lifeCycleStatesDecoded0
        let applicationIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .applicationIDs)
        var applicationIDsDecoded0:[Swift.String]? = nil
        if let applicationIDsContainer = applicationIDsContainer {
            applicationIDsDecoded0 = [Swift.String]()
            for string0 in applicationIDsContainer {
                if let string0 = string0 {
                    applicationIDsDecoded0?.append(string0)
                }
            }
        }
        applicationIDs = applicationIDsDecoded0
    }
}

extension MgnClientTypes {
    /// Request to filter Source Servers list.
    public struct DescribeSourceServersRequestFilters {
        /// Request to filter Source Servers list by application IDs.
        public var applicationIDs: [Swift.String]?
        /// Request to filter Source Servers list by archived.
        public var isArchived: Swift.Bool?
        /// Request to filter Source Servers list by life cycle states.
        public var lifeCycleStates: [MgnClientTypes.LifeCycleState]?
        /// Request to filter Source Servers list by replication type.
        public var replicationTypes: [MgnClientTypes.ReplicationType]?
        /// Request to filter Source Servers list by Source Server ID.
        public var sourceServerIDs: [Swift.String]?

        public init(
            applicationIDs: [Swift.String]? = nil,
            isArchived: Swift.Bool? = nil,
            lifeCycleStates: [MgnClientTypes.LifeCycleState]? = nil,
            replicationTypes: [MgnClientTypes.ReplicationType]? = nil,
            sourceServerIDs: [Swift.String]? = nil
        )
        {
            self.applicationIDs = applicationIDs
            self.isArchived = isArchived
            self.lifeCycleStates = lifeCycleStates
            self.replicationTypes = replicationTypes
            self.sourceServerIDs = sourceServerIDs
        }
    }

}

extension DescribeVcenterClientsInput {

    static func queryItemProvider(_ value: DescribeVcenterClientsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension DescribeVcenterClientsInput {

    static func urlPathProvider(_ value: DescribeVcenterClientsInput) -> Swift.String? {
        return "/DescribeVcenterClients"
    }
}

public struct DescribeVcenterClientsInput {
    /// Maximum results to be returned in DescribeVcenterClients.
    public var maxResults: Swift.Int?
    /// Next pagination token to be provided for DescribeVcenterClients.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeVcenterClientsInputBody {
}

extension DescribeVcenterClientsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeVcenterClientsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeVcenterClientsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeVcenterClientsOutput {
    /// List of items returned by DescribeVcenterClients.
    public var items: [MgnClientTypes.VcenterClient]?
    /// Next pagination token returned from DescribeVcenterClients.
    public var nextToken: Swift.String?

    public init(
        items: [MgnClientTypes.VcenterClient]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct DescribeVcenterClientsOutputBody {
    let items: [MgnClientTypes.VcenterClient]?
    let nextToken: Swift.String?
}

extension DescribeVcenterClientsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MgnClientTypes.VcenterClient?].self, forKey: .items)
        var itemsDecoded0:[MgnClientTypes.VcenterClient]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MgnClientTypes.VcenterClient]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeVcenterClientsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateApplicationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case applicationIDs
        case waveID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let applicationIDs = applicationIDs {
            var applicationIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applicationIDs)
            for applicationid0 in applicationIDs {
                try applicationIDsContainer.encode(applicationid0)
            }
        }
        if let waveID = self.waveID {
            try encodeContainer.encode(waveID, forKey: .waveID)
        }
    }
}

extension DisassociateApplicationsInput {

    static func urlPathProvider(_ value: DisassociateApplicationsInput) -> Swift.String? {
        return "/DisassociateApplications"
    }
}

public struct DisassociateApplicationsInput {
    /// Account ID.
    public var accountID: Swift.String?
    /// Application IDs list.
    /// This member is required.
    public var applicationIDs: [Swift.String]?
    /// Wave ID.
    /// This member is required.
    public var waveID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        applicationIDs: [Swift.String]? = nil,
        waveID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.applicationIDs = applicationIDs
        self.waveID = waveID
    }
}

struct DisassociateApplicationsInputBody {
    let waveID: Swift.String?
    let applicationIDs: [Swift.String]?
    let accountID: Swift.String?
}

extension DisassociateApplicationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case applicationIDs
        case waveID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let waveIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .waveID)
        waveID = waveIDDecoded
        let applicationIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .applicationIDs)
        var applicationIDsDecoded0:[Swift.String]? = nil
        if let applicationIDsContainer = applicationIDsContainer {
            applicationIDsDecoded0 = [Swift.String]()
            for string0 in applicationIDsContainer {
                if let string0 = string0 {
                    applicationIDsDecoded0?.append(string0)
                }
            }
        }
        applicationIDs = applicationIDsDecoded0
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension DisassociateApplicationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateApplicationsOutput {

    public init() { }
}

enum DisassociateApplicationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateSourceServersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case applicationID
        case sourceServerIDs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let applicationID = self.applicationID {
            try encodeContainer.encode(applicationID, forKey: .applicationID)
        }
        if let sourceServerIDs = sourceServerIDs {
            var sourceServerIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceServerIDs)
            for sourceserverid0 in sourceServerIDs {
                try sourceServerIDsContainer.encode(sourceserverid0)
            }
        }
    }
}

extension DisassociateSourceServersInput {

    static func urlPathProvider(_ value: DisassociateSourceServersInput) -> Swift.String? {
        return "/DisassociateSourceServers"
    }
}

public struct DisassociateSourceServersInput {
    /// Account ID.
    public var accountID: Swift.String?
    /// Application ID.
    /// This member is required.
    public var applicationID: Swift.String?
    /// Source server IDs list.
    /// This member is required.
    public var sourceServerIDs: [Swift.String]?

    public init(
        accountID: Swift.String? = nil,
        applicationID: Swift.String? = nil,
        sourceServerIDs: [Swift.String]? = nil
    )
    {
        self.accountID = accountID
        self.applicationID = applicationID
        self.sourceServerIDs = sourceServerIDs
    }
}

struct DisassociateSourceServersInputBody {
    let applicationID: Swift.String?
    let sourceServerIDs: [Swift.String]?
    let accountID: Swift.String?
}

extension DisassociateSourceServersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case applicationID
        case sourceServerIDs
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
        let sourceServerIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceServerIDs)
        var sourceServerIDsDecoded0:[Swift.String]? = nil
        if let sourceServerIDsContainer = sourceServerIDsContainer {
            sourceServerIDsDecoded0 = [Swift.String]()
            for string0 in sourceServerIDsContainer {
                if let string0 = string0 {
                    sourceServerIDsDecoded0?.append(string0)
                }
            }
        }
        sourceServerIDs = sourceServerIDsDecoded0
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension DisassociateSourceServersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateSourceServersOutput {

    public init() { }
}

enum DisassociateSourceServersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisconnectFromServiceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension DisconnectFromServiceInput {

    static func urlPathProvider(_ value: DisconnectFromServiceInput) -> Swift.String? {
        return "/DisconnectFromService"
    }
}

public struct DisconnectFromServiceInput {
    /// Request to disconnect Source Server from service by Account ID.
    public var accountID: Swift.String?
    /// Request to disconnect Source Server from service by Server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.sourceServerID = sourceServerID
    }
}

struct DisconnectFromServiceInputBody {
    let sourceServerID: Swift.String?
    let accountID: Swift.String?
}

extension DisconnectFromServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case sourceServerID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension DisconnectFromServiceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisconnectFromServiceOutput(applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), connectorAction: \(Swift.String(describing: connectorAction)), dataReplicationInfo: \(Swift.String(describing: dataReplicationInfo)), fqdnForActionFramework: \(Swift.String(describing: fqdnForActionFramework)), isArchived: \(Swift.String(describing: isArchived)), launchedInstance: \(Swift.String(describing: launchedInstance)), lifeCycle: \(Swift.String(describing: lifeCycle)), replicationType: \(Swift.String(describing: replicationType)), sourceProperties: \(Swift.String(describing: sourceProperties)), sourceServerID: \(Swift.String(describing: sourceServerID)), userProvidedID: \(Swift.String(describing: userProvidedID)), vcenterClientID: \(Swift.String(describing: vcenterClientID)), tags: \"CONTENT_REDACTED\")"}
}

extension DisconnectFromServiceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisconnectFromServiceOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationID = output.applicationID
            self.arn = output.arn
            self.connectorAction = output.connectorAction
            self.dataReplicationInfo = output.dataReplicationInfo
            self.fqdnForActionFramework = output.fqdnForActionFramework
            self.isArchived = output.isArchived
            self.launchedInstance = output.launchedInstance
            self.lifeCycle = output.lifeCycle
            self.replicationType = output.replicationType
            self.sourceProperties = output.sourceProperties
            self.sourceServerID = output.sourceServerID
            self.tags = output.tags
            self.userProvidedID = output.userProvidedID
            self.vcenterClientID = output.vcenterClientID
        } else {
            self.applicationID = nil
            self.arn = nil
            self.connectorAction = nil
            self.dataReplicationInfo = nil
            self.fqdnForActionFramework = nil
            self.isArchived = nil
            self.launchedInstance = nil
            self.lifeCycle = nil
            self.replicationType = nil
            self.sourceProperties = nil
            self.sourceServerID = nil
            self.tags = nil
            self.userProvidedID = nil
            self.vcenterClientID = nil
        }
    }
}

public struct DisconnectFromServiceOutput {
    /// Source server application ID.
    public var applicationID: Swift.String?
    /// Source server ARN.
    public var arn: Swift.String?
    /// Source Server connector action.
    public var connectorAction: MgnClientTypes.SourceServerConnectorAction?
    /// Source server data replication info.
    public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    /// Source server fqdn for action framework.
    public var fqdnForActionFramework: Swift.String?
    /// Source server archived status.
    public var isArchived: Swift.Bool?
    /// Source server launched instance.
    public var launchedInstance: MgnClientTypes.LaunchedInstance?
    /// Source server lifecycle state.
    public var lifeCycle: MgnClientTypes.LifeCycle?
    /// Source server replication type.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// Source server properties.
    public var sourceProperties: MgnClientTypes.SourceProperties?
    /// Source server ID.
    public var sourceServerID: Swift.String?
    /// Source server Tags.
    public var tags: [Swift.String:Swift.String]?
    /// Source server user provided ID.
    public var userProvidedID: Swift.String?
    /// Source server vCenter client id.
    public var vcenterClientID: Swift.String?

    public init(
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        connectorAction: MgnClientTypes.SourceServerConnectorAction? = nil,
        dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
        fqdnForActionFramework: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
        lifeCycle: MgnClientTypes.LifeCycle? = nil,
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceProperties: MgnClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        userProvidedID: Swift.String? = nil,
        vcenterClientID: Swift.String? = nil
    )
    {
        self.applicationID = applicationID
        self.arn = arn
        self.connectorAction = connectorAction
        self.dataReplicationInfo = dataReplicationInfo
        self.fqdnForActionFramework = fqdnForActionFramework
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.replicationType = replicationType
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
        self.userProvidedID = userProvidedID
        self.vcenterClientID = vcenterClientID
    }
}

struct DisconnectFromServiceOutputBody {
    let sourceServerID: Swift.String?
    let arn: Swift.String?
    let isArchived: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
    let launchedInstance: MgnClientTypes.LaunchedInstance?
    let dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    let lifeCycle: MgnClientTypes.LifeCycle?
    let sourceProperties: MgnClientTypes.SourceProperties?
    let replicationType: MgnClientTypes.ReplicationType?
    let vcenterClientID: Swift.String?
    let applicationID: Swift.String?
    let userProvidedID: Swift.String?
    let fqdnForActionFramework: Swift.String?
    let connectorAction: MgnClientTypes.SourceServerConnectorAction?
}

extension DisconnectFromServiceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationID
        case arn
        case connectorAction
        case dataReplicationInfo
        case fqdnForActionFramework
        case isArchived
        case launchedInstance
        case lifeCycle
        case replicationType
        case sourceProperties
        case sourceServerID
        case tags
        case userProvidedID
        case vcenterClientID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let launchedInstanceDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchedInstance.self, forKey: .launchedInstance)
        launchedInstance = launchedInstanceDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
        let replicationTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationType.self, forKey: .replicationType)
        replicationType = replicationTypeDecoded
        let vcenterClientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcenterClientID)
        vcenterClientID = vcenterClientIDDecoded
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
        let userProvidedIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userProvidedID)
        userProvidedID = userProvidedIDDecoded
        let fqdnForActionFrameworkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fqdnForActionFramework)
        fqdnForActionFramework = fqdnForActionFrameworkDecoded
        let connectorActionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceServerConnectorAction.self, forKey: .connectorAction)
        connectorAction = connectorActionDecoded
    }
}

enum DisconnectFromServiceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MgnClientTypes.Disk: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bytes
        case deviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if bytes != 0 {
            try encodeContainer.encode(bytes, forKey: .bytes)
        }
        if let deviceName = self.deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let bytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bytes) ?? 0
        bytes = bytesDecoded
    }
}

extension MgnClientTypes {
    /// The disk identifier.
    public struct Disk {
        /// The amount of storage on the disk in bytes.
        public var bytes: Swift.Int
        /// The disk or device name.
        public var deviceName: Swift.String?

        public init(
            bytes: Swift.Int = 0,
            deviceName: Swift.String? = nil
        )
        {
            self.bytes = bytes
            self.deviceName = deviceName
        }
    }

}

extension MgnClientTypes.ErrorDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case resourceId
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension MgnClientTypes {
    /// Error details.
    public struct ErrorDetails {
        /// Error details code.
        public var code: Swift.String?
        /// Error details message.
        public var message: Swift.String?
        /// Error details resourceId.
        public var resourceId: Swift.String?
        /// Error details resourceType.
        public var resourceType: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }
    }

}

extension MgnClientTypes.ExportErrorData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rawError
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rawError = self.rawError {
            try encodeContainer.encode(rawError, forKey: .rawError)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rawErrorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rawError)
        rawError = rawErrorDecoded
    }
}

extension MgnClientTypes {
    /// Export errors data.
    public struct ExportErrorData {
        /// Export errors data raw error.
        public var rawError: Swift.String?

        public init(
            rawError: Swift.String? = nil
        )
        {
            self.rawError = rawError
        }
    }

}

extension MgnClientTypes {
    public enum ExportStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case pending
        case started
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ExportStatus] {
            return [
                .failed,
                .pending,
                .started,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .started: return "STARTED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExportStatus(rawValue: rawValue) ?? ExportStatus.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes.ExportTask: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case endDateTime
        case exportID
        case progressPercentage
        case s3Bucket
        case s3BucketOwner
        case s3Key
        case status
        case summary
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encode(creationDateTime, forKey: .creationDateTime)
        }
        if let endDateTime = self.endDateTime {
            try encodeContainer.encode(endDateTime, forKey: .endDateTime)
        }
        if let exportID = self.exportID {
            try encodeContainer.encode(exportID, forKey: .exportID)
        }
        if let progressPercentage = self.progressPercentage {
            try encodeContainer.encode(progressPercentage, forKey: .progressPercentage)
        }
        if let s3Bucket = self.s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3BucketOwner = self.s3BucketOwner {
            try encodeContainer.encode(s3BucketOwner, forKey: .s3BucketOwner)
        }
        if let s3Key = self.s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let summary = self.summary {
            try encodeContainer.encode(summary, forKey: .summary)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportID)
        exportID = exportIDDecoded
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
        let s3BucketOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketOwner)
        s3BucketOwner = s3BucketOwnerDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let endDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endDateTime)
        endDateTime = endDateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ExportStatus.self, forKey: .status)
        status = statusDecoded
        let progressPercentageDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .progressPercentage)
        progressPercentage = progressPercentageDecoded
        let summaryDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ExportTaskSummary.self, forKey: .summary)
        summary = summaryDecoded
    }
}

extension MgnClientTypes {
    /// Export task.
    public struct ExportTask {
        /// Export task creation datetime.
        public var creationDateTime: Swift.String?
        /// Export task end datetime.
        public var endDateTime: Swift.String?
        /// Export task id.
        public var exportID: Swift.String?
        /// Export task progress percentage.
        public var progressPercentage: Swift.Float?
        /// Export task s3 bucket.
        public var s3Bucket: Swift.String?
        /// Export task s3 bucket owner.
        public var s3BucketOwner: Swift.String?
        /// Export task s3 key.
        public var s3Key: Swift.String?
        /// Export task status.
        public var status: MgnClientTypes.ExportStatus?
        /// Export task summary.
        public var summary: MgnClientTypes.ExportTaskSummary?

        public init(
            creationDateTime: Swift.String? = nil,
            endDateTime: Swift.String? = nil,
            exportID: Swift.String? = nil,
            progressPercentage: Swift.Float? = nil,
            s3Bucket: Swift.String? = nil,
            s3BucketOwner: Swift.String? = nil,
            s3Key: Swift.String? = nil,
            status: MgnClientTypes.ExportStatus? = nil,
            summary: MgnClientTypes.ExportTaskSummary? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.endDateTime = endDateTime
            self.exportID = exportID
            self.progressPercentage = progressPercentage
            self.s3Bucket = s3Bucket
            self.s3BucketOwner = s3BucketOwner
            self.s3Key = s3Key
            self.status = status
            self.summary = summary
        }
    }

}

extension MgnClientTypes.ExportTaskError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorData
        case errorDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorData = self.errorData {
            try encodeContainer.encode(errorData, forKey: .errorData)
        }
        if let errorDateTime = self.errorDateTime {
            try encodeContainer.encode(errorDateTime, forKey: .errorDateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorDateTime)
        errorDateTime = errorDateTimeDecoded
        let errorDataDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ExportErrorData.self, forKey: .errorData)
        errorData = errorDataDecoded
    }
}

extension MgnClientTypes {
    /// Export task error.
    public struct ExportTaskError {
        /// Export task error data.
        public var errorData: MgnClientTypes.ExportErrorData?
        /// Export task error datetime.
        public var errorDateTime: Swift.String?

        public init(
            errorData: MgnClientTypes.ExportErrorData? = nil,
            errorDateTime: Swift.String? = nil
        )
        {
            self.errorData = errorData
            self.errorDateTime = errorDateTime
        }
    }

}

extension MgnClientTypes.ExportTaskSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationsCount
        case serversCount
        case wavesCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if applicationsCount != 0 {
            try encodeContainer.encode(applicationsCount, forKey: .applicationsCount)
        }
        if serversCount != 0 {
            try encodeContainer.encode(serversCount, forKey: .serversCount)
        }
        if wavesCount != 0 {
            try encodeContainer.encode(wavesCount, forKey: .wavesCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serversCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .serversCount) ?? 0
        serversCount = serversCountDecoded
        let applicationsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .applicationsCount) ?? 0
        applicationsCount = applicationsCountDecoded
        let wavesCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .wavesCount) ?? 0
        wavesCount = wavesCountDecoded
    }
}

extension MgnClientTypes {
    /// Export task summary.
    public struct ExportTaskSummary {
        /// Export task summary applications count.
        public var applicationsCount: Swift.Int
        /// Export task summary servers count.
        public var serversCount: Swift.Int
        /// Export task summary waves count.
        public var wavesCount: Swift.Int

        public init(
            applicationsCount: Swift.Int = 0,
            serversCount: Swift.Int = 0,
            wavesCount: Swift.Int = 0
        )
        {
            self.applicationsCount = applicationsCount
            self.serversCount = serversCount
            self.wavesCount = wavesCount
        }
    }

}

extension FinalizeCutoverInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension FinalizeCutoverInput {

    static func urlPathProvider(_ value: FinalizeCutoverInput) -> Swift.String? {
        return "/FinalizeCutover"
    }
}

public struct FinalizeCutoverInput {
    /// Request to finalize Cutover by Source Account ID.
    public var accountID: Swift.String?
    /// Request to finalize Cutover by Source Server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.sourceServerID = sourceServerID
    }
}

struct FinalizeCutoverInputBody {
    let sourceServerID: Swift.String?
    let accountID: Swift.String?
}

extension FinalizeCutoverInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case sourceServerID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension FinalizeCutoverOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FinalizeCutoverOutput(applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), connectorAction: \(Swift.String(describing: connectorAction)), dataReplicationInfo: \(Swift.String(describing: dataReplicationInfo)), fqdnForActionFramework: \(Swift.String(describing: fqdnForActionFramework)), isArchived: \(Swift.String(describing: isArchived)), launchedInstance: \(Swift.String(describing: launchedInstance)), lifeCycle: \(Swift.String(describing: lifeCycle)), replicationType: \(Swift.String(describing: replicationType)), sourceProperties: \(Swift.String(describing: sourceProperties)), sourceServerID: \(Swift.String(describing: sourceServerID)), userProvidedID: \(Swift.String(describing: userProvidedID)), vcenterClientID: \(Swift.String(describing: vcenterClientID)), tags: \"CONTENT_REDACTED\")"}
}

extension FinalizeCutoverOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: FinalizeCutoverOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationID = output.applicationID
            self.arn = output.arn
            self.connectorAction = output.connectorAction
            self.dataReplicationInfo = output.dataReplicationInfo
            self.fqdnForActionFramework = output.fqdnForActionFramework
            self.isArchived = output.isArchived
            self.launchedInstance = output.launchedInstance
            self.lifeCycle = output.lifeCycle
            self.replicationType = output.replicationType
            self.sourceProperties = output.sourceProperties
            self.sourceServerID = output.sourceServerID
            self.tags = output.tags
            self.userProvidedID = output.userProvidedID
            self.vcenterClientID = output.vcenterClientID
        } else {
            self.applicationID = nil
            self.arn = nil
            self.connectorAction = nil
            self.dataReplicationInfo = nil
            self.fqdnForActionFramework = nil
            self.isArchived = nil
            self.launchedInstance = nil
            self.lifeCycle = nil
            self.replicationType = nil
            self.sourceProperties = nil
            self.sourceServerID = nil
            self.tags = nil
            self.userProvidedID = nil
            self.vcenterClientID = nil
        }
    }
}

public struct FinalizeCutoverOutput {
    /// Source server application ID.
    public var applicationID: Swift.String?
    /// Source server ARN.
    public var arn: Swift.String?
    /// Source Server connector action.
    public var connectorAction: MgnClientTypes.SourceServerConnectorAction?
    /// Source server data replication info.
    public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    /// Source server fqdn for action framework.
    public var fqdnForActionFramework: Swift.String?
    /// Source server archived status.
    public var isArchived: Swift.Bool?
    /// Source server launched instance.
    public var launchedInstance: MgnClientTypes.LaunchedInstance?
    /// Source server lifecycle state.
    public var lifeCycle: MgnClientTypes.LifeCycle?
    /// Source server replication type.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// Source server properties.
    public var sourceProperties: MgnClientTypes.SourceProperties?
    /// Source server ID.
    public var sourceServerID: Swift.String?
    /// Source server Tags.
    public var tags: [Swift.String:Swift.String]?
    /// Source server user provided ID.
    public var userProvidedID: Swift.String?
    /// Source server vCenter client id.
    public var vcenterClientID: Swift.String?

    public init(
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        connectorAction: MgnClientTypes.SourceServerConnectorAction? = nil,
        dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
        fqdnForActionFramework: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
        lifeCycle: MgnClientTypes.LifeCycle? = nil,
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceProperties: MgnClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        userProvidedID: Swift.String? = nil,
        vcenterClientID: Swift.String? = nil
    )
    {
        self.applicationID = applicationID
        self.arn = arn
        self.connectorAction = connectorAction
        self.dataReplicationInfo = dataReplicationInfo
        self.fqdnForActionFramework = fqdnForActionFramework
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.replicationType = replicationType
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
        self.userProvidedID = userProvidedID
        self.vcenterClientID = vcenterClientID
    }
}

struct FinalizeCutoverOutputBody {
    let sourceServerID: Swift.String?
    let arn: Swift.String?
    let isArchived: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
    let launchedInstance: MgnClientTypes.LaunchedInstance?
    let dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    let lifeCycle: MgnClientTypes.LifeCycle?
    let sourceProperties: MgnClientTypes.SourceProperties?
    let replicationType: MgnClientTypes.ReplicationType?
    let vcenterClientID: Swift.String?
    let applicationID: Swift.String?
    let userProvidedID: Swift.String?
    let fqdnForActionFramework: Swift.String?
    let connectorAction: MgnClientTypes.SourceServerConnectorAction?
}

extension FinalizeCutoverOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationID
        case arn
        case connectorAction
        case dataReplicationInfo
        case fqdnForActionFramework
        case isArchived
        case launchedInstance
        case lifeCycle
        case replicationType
        case sourceProperties
        case sourceServerID
        case tags
        case userProvidedID
        case vcenterClientID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let launchedInstanceDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchedInstance.self, forKey: .launchedInstance)
        launchedInstance = launchedInstanceDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
        let replicationTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationType.self, forKey: .replicationType)
        replicationType = replicationTypeDecoded
        let vcenterClientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcenterClientID)
        vcenterClientID = vcenterClientIDDecoded
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
        let userProvidedIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userProvidedID)
        userProvidedID = userProvidedIDDecoded
        let fqdnForActionFrameworkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fqdnForActionFramework)
        fqdnForActionFramework = fqdnForActionFrameworkDecoded
        let connectorActionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceServerConnectorAction.self, forKey: .connectorAction)
        connectorAction = connectorActionDecoded
    }
}

enum FinalizeCutoverOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MgnClientTypes {
    public enum FirstBoot: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case stopped
        case succeeded
        case unknown
        case waiting
        case sdkUnknown(Swift.String)

        public static var allCases: [FirstBoot] {
            return [
                .stopped,
                .succeeded,
                .unknown,
                .waiting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .stopped: return "STOPPED"
            case .succeeded: return "SUCCEEDED"
            case .unknown: return "UNKNOWN"
            case .waiting: return "WAITING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FirstBoot(rawValue: rawValue) ?? FirstBoot.sdkUnknown(rawValue)
        }
    }
}

extension GetLaunchConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension GetLaunchConfigurationInput {

    static func urlPathProvider(_ value: GetLaunchConfigurationInput) -> Swift.String? {
        return "/GetLaunchConfiguration"
    }
}

public struct GetLaunchConfigurationInput {
    /// Request to get Launch Configuration information by Account ID.
    public var accountID: Swift.String?
    /// Request to get Launch Configuration information by Source Server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.sourceServerID = sourceServerID
    }
}

struct GetLaunchConfigurationInputBody {
    let sourceServerID: Swift.String?
    let accountID: Swift.String?
}

extension GetLaunchConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case sourceServerID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension GetLaunchConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLaunchConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.bootMode = output.bootMode
            self.copyPrivateIp = output.copyPrivateIp
            self.copyTags = output.copyTags
            self.ec2LaunchTemplateID = output.ec2LaunchTemplateID
            self.enableMapAutoTagging = output.enableMapAutoTagging
            self.launchDisposition = output.launchDisposition
            self.licensing = output.licensing
            self.mapAutoTaggingMpeID = output.mapAutoTaggingMpeID
            self.name = output.name
            self.postLaunchActions = output.postLaunchActions
            self.sourceServerID = output.sourceServerID
            self.targetInstanceTypeRightSizingMethod = output.targetInstanceTypeRightSizingMethod
        } else {
            self.bootMode = nil
            self.copyPrivateIp = nil
            self.copyTags = nil
            self.ec2LaunchTemplateID = nil
            self.enableMapAutoTagging = nil
            self.launchDisposition = nil
            self.licensing = nil
            self.mapAutoTaggingMpeID = nil
            self.name = nil
            self.postLaunchActions = nil
            self.sourceServerID = nil
            self.targetInstanceTypeRightSizingMethod = nil
        }
    }
}

public struct GetLaunchConfigurationOutput {
    /// Launch configuration boot mode.
    public var bootMode: MgnClientTypes.BootMode?
    /// Copy Private IP during Launch Configuration.
    public var copyPrivateIp: Swift.Bool?
    /// Copy Tags during Launch Configuration.
    public var copyTags: Swift.Bool?
    /// Launch configuration EC2 Launch template ID.
    public var ec2LaunchTemplateID: Swift.String?
    /// Enable map auto tagging.
    public var enableMapAutoTagging: Swift.Bool?
    /// Launch disposition for launch configuration.
    public var launchDisposition: MgnClientTypes.LaunchDisposition?
    /// Launch configuration OS licensing.
    public var licensing: MgnClientTypes.Licensing?
    /// Map auto tagging MPE ID.
    public var mapAutoTaggingMpeID: Swift.String?
    /// Launch configuration name.
    public var name: Swift.String?
    /// Post Launch Actions to executed on the Test or Cutover instance.
    public var postLaunchActions: MgnClientTypes.PostLaunchActions?
    /// Launch configuration Source Server ID.
    public var sourceServerID: Swift.String?
    /// Launch configuration Target instance type right sizing method.
    public var targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?

    public init(
        bootMode: MgnClientTypes.BootMode? = nil,
        copyPrivateIp: Swift.Bool? = nil,
        copyTags: Swift.Bool? = nil,
        ec2LaunchTemplateID: Swift.String? = nil,
        enableMapAutoTagging: Swift.Bool? = nil,
        launchDisposition: MgnClientTypes.LaunchDisposition? = nil,
        licensing: MgnClientTypes.Licensing? = nil,
        mapAutoTaggingMpeID: Swift.String? = nil,
        name: Swift.String? = nil,
        postLaunchActions: MgnClientTypes.PostLaunchActions? = nil,
        sourceServerID: Swift.String? = nil,
        targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod? = nil
    )
    {
        self.bootMode = bootMode
        self.copyPrivateIp = copyPrivateIp
        self.copyTags = copyTags
        self.ec2LaunchTemplateID = ec2LaunchTemplateID
        self.enableMapAutoTagging = enableMapAutoTagging
        self.launchDisposition = launchDisposition
        self.licensing = licensing
        self.mapAutoTaggingMpeID = mapAutoTaggingMpeID
        self.name = name
        self.postLaunchActions = postLaunchActions
        self.sourceServerID = sourceServerID
        self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
    }
}

struct GetLaunchConfigurationOutputBody {
    let sourceServerID: Swift.String?
    let name: Swift.String?
    let ec2LaunchTemplateID: Swift.String?
    let launchDisposition: MgnClientTypes.LaunchDisposition?
    let targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?
    let copyPrivateIp: Swift.Bool?
    let copyTags: Swift.Bool?
    let licensing: MgnClientTypes.Licensing?
    let bootMode: MgnClientTypes.BootMode?
    let postLaunchActions: MgnClientTypes.PostLaunchActions?
    let enableMapAutoTagging: Swift.Bool?
    let mapAutoTaggingMpeID: Swift.String?
}

extension GetLaunchConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bootMode
        case copyPrivateIp
        case copyTags
        case ec2LaunchTemplateID
        case enableMapAutoTagging
        case launchDisposition
        case licensing
        case mapAutoTaggingMpeID
        case name
        case postLaunchActions
        case sourceServerID
        case targetInstanceTypeRightSizingMethod
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ec2LaunchTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2LaunchTemplateID)
        ec2LaunchTemplateID = ec2LaunchTemplateIDDecoded
        let launchDispositionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchDisposition.self, forKey: .launchDisposition)
        launchDisposition = launchDispositionDecoded
        let targetInstanceTypeRightSizingMethodDecoded = try containerValues.decodeIfPresent(MgnClientTypes.TargetInstanceTypeRightSizingMethod.self, forKey: .targetInstanceTypeRightSizingMethod)
        targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethodDecoded
        let copyPrivateIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyPrivateIp)
        copyPrivateIp = copyPrivateIpDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let licensingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.Licensing.self, forKey: .licensing)
        licensing = licensingDecoded
        let bootModeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.BootMode.self, forKey: .bootMode)
        bootMode = bootModeDecoded
        let postLaunchActionsDecoded = try containerValues.decodeIfPresent(MgnClientTypes.PostLaunchActions.self, forKey: .postLaunchActions)
        postLaunchActions = postLaunchActionsDecoded
        let enableMapAutoTaggingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableMapAutoTagging)
        enableMapAutoTagging = enableMapAutoTaggingDecoded
        let mapAutoTaggingMpeIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapAutoTaggingMpeID)
        mapAutoTaggingMpeID = mapAutoTaggingMpeIDDecoded
    }
}

enum GetLaunchConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetReplicationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension GetReplicationConfigurationInput {

    static func urlPathProvider(_ value: GetReplicationConfigurationInput) -> Swift.String? {
        return "/GetReplicationConfiguration"
    }
}

public struct GetReplicationConfigurationInput {
    /// Request to get Replication Configuration by Account ID.
    public var accountID: Swift.String?
    /// Request to get Replication Configuration by Source Server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.sourceServerID = sourceServerID
    }
}

struct GetReplicationConfigurationInputBody {
    let sourceServerID: Swift.String?
    let accountID: Swift.String?
}

extension GetReplicationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case sourceServerID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension GetReplicationConfigurationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetReplicationConfigurationOutput(associateDefaultSecurityGroup: \(Swift.String(describing: associateDefaultSecurityGroup)), bandwidthThrottling: \(Swift.String(describing: bandwidthThrottling)), createPublicIP: \(Swift.String(describing: createPublicIP)), dataPlaneRouting: \(Swift.String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(Swift.String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(Swift.String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(Swift.String(describing: ebsEncryptionKeyArn)), name: \(Swift.String(describing: name)), replicatedDisks: \(Swift.String(describing: replicatedDisks)), replicationServerInstanceType: \(Swift.String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(Swift.String(describing: replicationServersSecurityGroupsIDs)), sourceServerID: \(Swift.String(describing: sourceServerID)), stagingAreaSubnetId: \(Swift.String(describing: stagingAreaSubnetId)), useDedicatedReplicationServer: \(Swift.String(describing: useDedicatedReplicationServer)), useFipsEndpoint: \(Swift.String(describing: useFipsEndpoint)), stagingAreaTags: \"CONTENT_REDACTED\")"}
}

extension GetReplicationConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetReplicationConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.associateDefaultSecurityGroup = output.associateDefaultSecurityGroup
            self.bandwidthThrottling = output.bandwidthThrottling
            self.createPublicIP = output.createPublicIP
            self.dataPlaneRouting = output.dataPlaneRouting
            self.defaultLargeStagingDiskType = output.defaultLargeStagingDiskType
            self.ebsEncryption = output.ebsEncryption
            self.ebsEncryptionKeyArn = output.ebsEncryptionKeyArn
            self.name = output.name
            self.replicatedDisks = output.replicatedDisks
            self.replicationServerInstanceType = output.replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = output.replicationServersSecurityGroupsIDs
            self.sourceServerID = output.sourceServerID
            self.stagingAreaSubnetId = output.stagingAreaSubnetId
            self.stagingAreaTags = output.stagingAreaTags
            self.useDedicatedReplicationServer = output.useDedicatedReplicationServer
            self.useFipsEndpoint = output.useFipsEndpoint
        } else {
            self.associateDefaultSecurityGroup = nil
            self.bandwidthThrottling = 0
            self.createPublicIP = nil
            self.dataPlaneRouting = nil
            self.defaultLargeStagingDiskType = nil
            self.ebsEncryption = nil
            self.ebsEncryptionKeyArn = nil
            self.name = nil
            self.replicatedDisks = nil
            self.replicationServerInstanceType = nil
            self.replicationServersSecurityGroupsIDs = nil
            self.sourceServerID = nil
            self.stagingAreaSubnetId = nil
            self.stagingAreaTags = nil
            self.useDedicatedReplicationServer = nil
            self.useFipsEndpoint = nil
        }
    }
}

public struct GetReplicationConfigurationOutput {
    /// Replication Configuration associate default Application Migration Service Security Group.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Replication Configuration set bandwidth throttling.
    public var bandwidthThrottling: Swift.Int
    /// Replication Configuration create Public IP.
    public var createPublicIP: Swift.Bool?
    /// Replication Configuration data plane routing.
    public var dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// Replication Configuration use default large Staging Disks.
    public var defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// Replication Configuration EBS encryption.
    public var ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    /// Replication Configuration EBS encryption key ARN.
    public var ebsEncryptionKeyArn: Swift.String?
    /// Replication Configuration name.
    public var name: Swift.String?
    /// Replication Configuration replicated disks.
    public var replicatedDisks: [MgnClientTypes.ReplicationConfigurationReplicatedDisk]?
    /// Replication Configuration Replication Server instance type.
    public var replicationServerInstanceType: Swift.String?
    /// Replication Configuration Replication Server Security Group IDs.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// Replication Configuration Source Server ID.
    public var sourceServerID: Swift.String?
    /// Replication Configuration Staging Area subnet ID.
    public var stagingAreaSubnetId: Swift.String?
    /// Replication Configuration Staging Area tags.
    public var stagingAreaTags: [Swift.String:Swift.String]?
    /// Replication Configuration use Dedicated Replication Server.
    public var useDedicatedReplicationServer: Swift.Bool?
    /// Replication Configuration use Fips Endpoint.
    public var useFipsEndpoint: Swift.Bool?

    public init(
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        replicatedDisks: [MgnClientTypes.ReplicationConfigurationReplicatedDisk]? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        sourceServerID: Swift.String? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String:Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil,
        useFipsEndpoint: Swift.Bool? = nil
    )
    {
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.name = name
        self.replicatedDisks = replicatedDisks
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.sourceServerID = sourceServerID
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
        self.useFipsEndpoint = useFipsEndpoint
    }
}

struct GetReplicationConfigurationOutputBody {
    let sourceServerID: Swift.String?
    let name: Swift.String?
    let stagingAreaSubnetId: Swift.String?
    let associateDefaultSecurityGroup: Swift.Bool?
    let replicationServersSecurityGroupsIDs: [Swift.String]?
    let replicationServerInstanceType: Swift.String?
    let useDedicatedReplicationServer: Swift.Bool?
    let defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    let replicatedDisks: [MgnClientTypes.ReplicationConfigurationReplicatedDisk]?
    let ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    let ebsEncryptionKeyArn: Swift.String?
    let bandwidthThrottling: Swift.Int
    let dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    let createPublicIP: Swift.Bool?
    let stagingAreaTags: [Swift.String:Swift.String]?
    let useFipsEndpoint: Swift.Bool?
}

extension GetReplicationConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case name
        case replicatedDisks
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case sourceServerID
        case stagingAreaSubnetId
        case stagingAreaTags
        case useDedicatedReplicationServer
        case useFipsEndpoint
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let replicatedDisksContainer = try containerValues.decodeIfPresent([MgnClientTypes.ReplicationConfigurationReplicatedDisk?].self, forKey: .replicatedDisks)
        var replicatedDisksDecoded0:[MgnClientTypes.ReplicationConfigurationReplicatedDisk]? = nil
        if let replicatedDisksContainer = replicatedDisksContainer {
            replicatedDisksDecoded0 = [MgnClientTypes.ReplicationConfigurationReplicatedDisk]()
            for structure0 in replicatedDisksContainer {
                if let structure0 = structure0 {
                    replicatedDisksDecoded0?.append(structure0)
                }
            }
        }
        replicatedDisks = replicatedDisksDecoded0
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bandwidthThrottling) ?? 0
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
        let useFipsEndpointDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useFipsEndpoint)
        useFipsEndpoint = useFipsEndpointDecoded
    }
}

enum GetReplicationConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MgnClientTypes.IdentificationHints: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsInstanceID
        case fqdn
        case hostname
        case vmPath
        case vmWareUuid
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsInstanceID = self.awsInstanceID {
            try encodeContainer.encode(awsInstanceID, forKey: .awsInstanceID)
        }
        if let fqdn = self.fqdn {
            try encodeContainer.encode(fqdn, forKey: .fqdn)
        }
        if let hostname = self.hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let vmPath = self.vmPath {
            try encodeContainer.encode(vmPath, forKey: .vmPath)
        }
        if let vmWareUuid = self.vmWareUuid {
            try encodeContainer.encode(vmWareUuid, forKey: .vmWareUuid)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fqdnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fqdn)
        fqdn = fqdnDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let vmWareUuidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vmWareUuid)
        vmWareUuid = vmWareUuidDecoded
        let awsInstanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsInstanceID)
        awsInstanceID = awsInstanceIDDecoded
        let vmPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vmPath)
        vmPath = vmPathDecoded
    }
}

extension MgnClientTypes {
    /// Identification hints.
    public struct IdentificationHints {
        /// AWS Instance ID identification hint.
        public var awsInstanceID: Swift.String?
        /// FQDN address identification hint.
        public var fqdn: Swift.String?
        /// Hostname identification hint.
        public var hostname: Swift.String?
        /// vCenter VM path identification hint.
        public var vmPath: Swift.String?
        /// vmWare UUID identification hint.
        public var vmWareUuid: Swift.String?

        public init(
            awsInstanceID: Swift.String? = nil,
            fqdn: Swift.String? = nil,
            hostname: Swift.String? = nil,
            vmPath: Swift.String? = nil,
            vmWareUuid: Swift.String? = nil
        )
        {
            self.awsInstanceID = awsInstanceID
            self.fqdn = fqdn
            self.hostname = hostname
            self.vmPath = vmPath
            self.vmWareUuid = vmWareUuid
        }
    }

}

extension MgnClientTypes.ImportErrorData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case applicationID
        case ec2LaunchTemplateID
        case rawError
        case rowNumber
        case sourceServerID
        case waveID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let applicationID = self.applicationID {
            try encodeContainer.encode(applicationID, forKey: .applicationID)
        }
        if let ec2LaunchTemplateID = self.ec2LaunchTemplateID {
            try encodeContainer.encode(ec2LaunchTemplateID, forKey: .ec2LaunchTemplateID)
        }
        if let rawError = self.rawError {
            try encodeContainer.encode(rawError, forKey: .rawError)
        }
        if rowNumber != 0 {
            try encodeContainer.encode(rowNumber, forKey: .rowNumber)
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
        if let waveID = self.waveID {
            try encodeContainer.encode(waveID, forKey: .waveID)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
        let waveIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .waveID)
        waveID = waveIDDecoded
        let ec2LaunchTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2LaunchTemplateID)
        ec2LaunchTemplateID = ec2LaunchTemplateIDDecoded
        let rowNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rowNumber) ?? 0
        rowNumber = rowNumberDecoded
        let rawErrorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rawError)
        rawError = rawErrorDecoded
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension MgnClientTypes {
    /// Import error data.
    public struct ImportErrorData {
        /// Import error data source account ID.
        public var accountID: Swift.String?
        /// Import error data application ID.
        public var applicationID: Swift.String?
        /// Import error data ec2 LaunchTemplate ID.
        public var ec2LaunchTemplateID: Swift.String?
        /// Import error data raw error.
        public var rawError: Swift.String?
        /// Import error data row number.
        public var rowNumber: Swift.Int
        /// Import error data source server ID.
        public var sourceServerID: Swift.String?
        /// Import error data wave id.
        public var waveID: Swift.String?

        public init(
            accountID: Swift.String? = nil,
            applicationID: Swift.String? = nil,
            ec2LaunchTemplateID: Swift.String? = nil,
            rawError: Swift.String? = nil,
            rowNumber: Swift.Int = 0,
            sourceServerID: Swift.String? = nil,
            waveID: Swift.String? = nil
        )
        {
            self.accountID = accountID
            self.applicationID = applicationID
            self.ec2LaunchTemplateID = ec2LaunchTemplateID
            self.rawError = rawError
            self.rowNumber = rowNumber
            self.sourceServerID = sourceServerID
            self.waveID = waveID
        }
    }

}

extension MgnClientTypes {
    public enum ImportErrorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case processingError
        case validationError
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportErrorType] {
            return [
                .processingError,
                .validationError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .processingError: return "PROCESSING_ERROR"
            case .validationError: return "VALIDATION_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImportErrorType(rawValue: rawValue) ?? ImportErrorType.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes {
    public enum ImportStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case pending
        case started
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportStatus] {
            return [
                .failed,
                .pending,
                .started,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .started: return "STARTED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImportStatus(rawValue: rawValue) ?? ImportStatus.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes.ImportTask: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case endDateTime
        case importID
        case progressPercentage
        case s3BucketSource
        case status
        case summary
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encode(creationDateTime, forKey: .creationDateTime)
        }
        if let endDateTime = self.endDateTime {
            try encodeContainer.encode(endDateTime, forKey: .endDateTime)
        }
        if let importID = self.importID {
            try encodeContainer.encode(importID, forKey: .importID)
        }
        if let progressPercentage = self.progressPercentage {
            try encodeContainer.encode(progressPercentage, forKey: .progressPercentage)
        }
        if let s3BucketSource = self.s3BucketSource {
            try encodeContainer.encode(s3BucketSource, forKey: .s3BucketSource)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let summary = self.summary {
            try encodeContainer.encode(summary, forKey: .summary)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importID)
        importID = importIDDecoded
        let s3BucketSourceDecoded = try containerValues.decodeIfPresent(MgnClientTypes.S3BucketSource.self, forKey: .s3BucketSource)
        s3BucketSource = s3BucketSourceDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let endDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endDateTime)
        endDateTime = endDateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ImportStatus.self, forKey: .status)
        status = statusDecoded
        let progressPercentageDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .progressPercentage)
        progressPercentage = progressPercentageDecoded
        let summaryDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ImportTaskSummary.self, forKey: .summary)
        summary = summaryDecoded
    }
}

extension MgnClientTypes {
    /// Import task.
    public struct ImportTask {
        /// Import task creation datetime.
        public var creationDateTime: Swift.String?
        /// Import task end datetime.
        public var endDateTime: Swift.String?
        /// Import task id.
        public var importID: Swift.String?
        /// Import task progress percentage.
        public var progressPercentage: Swift.Float?
        /// Import task s3 bucket source.
        public var s3BucketSource: MgnClientTypes.S3BucketSource?
        /// Import task status.
        public var status: MgnClientTypes.ImportStatus?
        /// Import task summary.
        public var summary: MgnClientTypes.ImportTaskSummary?

        public init(
            creationDateTime: Swift.String? = nil,
            endDateTime: Swift.String? = nil,
            importID: Swift.String? = nil,
            progressPercentage: Swift.Float? = nil,
            s3BucketSource: MgnClientTypes.S3BucketSource? = nil,
            status: MgnClientTypes.ImportStatus? = nil,
            summary: MgnClientTypes.ImportTaskSummary? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.endDateTime = endDateTime
            self.importID = importID
            self.progressPercentage = progressPercentage
            self.s3BucketSource = s3BucketSource
            self.status = status
            self.summary = summary
        }
    }

}

extension MgnClientTypes.ImportTaskError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorData
        case errorDateTime
        case errorType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorData = self.errorData {
            try encodeContainer.encode(errorData, forKey: .errorData)
        }
        if let errorDateTime = self.errorDateTime {
            try encodeContainer.encode(errorDateTime, forKey: .errorDateTime)
        }
        if let errorType = self.errorType {
            try encodeContainer.encode(errorType.rawValue, forKey: .errorType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorDateTime)
        errorDateTime = errorDateTimeDecoded
        let errorTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ImportErrorType.self, forKey: .errorType)
        errorType = errorTypeDecoded
        let errorDataDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ImportErrorData.self, forKey: .errorData)
        errorData = errorDataDecoded
    }
}

extension MgnClientTypes {
    /// Import task error.
    public struct ImportTaskError {
        /// Import task error data.
        public var errorData: MgnClientTypes.ImportErrorData?
        /// Import task error datetime.
        public var errorDateTime: Swift.String?
        /// Import task error type.
        public var errorType: MgnClientTypes.ImportErrorType?

        public init(
            errorData: MgnClientTypes.ImportErrorData? = nil,
            errorDateTime: Swift.String? = nil,
            errorType: MgnClientTypes.ImportErrorType? = nil
        )
        {
            self.errorData = errorData
            self.errorDateTime = errorDateTime
            self.errorType = errorType
        }
    }

}

extension MgnClientTypes.ImportTaskSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applications
        case servers
        case waves
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applications = self.applications {
            try encodeContainer.encode(applications, forKey: .applications)
        }
        if let servers = self.servers {
            try encodeContainer.encode(servers, forKey: .servers)
        }
        if let waves = self.waves {
            try encodeContainer.encode(waves, forKey: .waves)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wavesDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ImportTaskSummaryWaves.self, forKey: .waves)
        waves = wavesDecoded
        let applicationsDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ImportTaskSummaryApplications.self, forKey: .applications)
        applications = applicationsDecoded
        let serversDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ImportTaskSummaryServers.self, forKey: .servers)
        servers = serversDecoded
    }
}

extension MgnClientTypes {
    /// Import task summary.
    public struct ImportTaskSummary {
        /// Import task summary applications.
        public var applications: MgnClientTypes.ImportTaskSummaryApplications?
        /// Import task summary servers.
        public var servers: MgnClientTypes.ImportTaskSummaryServers?
        /// Import task summary waves.
        public var waves: MgnClientTypes.ImportTaskSummaryWaves?

        public init(
            applications: MgnClientTypes.ImportTaskSummaryApplications? = nil,
            servers: MgnClientTypes.ImportTaskSummaryServers? = nil,
            waves: MgnClientTypes.ImportTaskSummaryWaves? = nil
        )
        {
            self.applications = applications
            self.servers = servers
            self.waves = waves
        }
    }

}

extension MgnClientTypes.ImportTaskSummaryApplications: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdCount
        case modifiedCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if createdCount != 0 {
            try encodeContainer.encode(createdCount, forKey: .createdCount)
        }
        if modifiedCount != 0 {
            try encodeContainer.encode(modifiedCount, forKey: .modifiedCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createdCount) ?? 0
        createdCount = createdCountDecoded
        let modifiedCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .modifiedCount) ?? 0
        modifiedCount = modifiedCountDecoded
    }
}

extension MgnClientTypes {
    /// Import task summary applications.
    public struct ImportTaskSummaryApplications {
        /// Import task summary applications created count.
        public var createdCount: Swift.Int
        /// Import task summary applications modified count.
        public var modifiedCount: Swift.Int

        public init(
            createdCount: Swift.Int = 0,
            modifiedCount: Swift.Int = 0
        )
        {
            self.createdCount = createdCount
            self.modifiedCount = modifiedCount
        }
    }

}

extension MgnClientTypes.ImportTaskSummaryServers: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdCount
        case modifiedCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if createdCount != 0 {
            try encodeContainer.encode(createdCount, forKey: .createdCount)
        }
        if modifiedCount != 0 {
            try encodeContainer.encode(modifiedCount, forKey: .modifiedCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createdCount) ?? 0
        createdCount = createdCountDecoded
        let modifiedCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .modifiedCount) ?? 0
        modifiedCount = modifiedCountDecoded
    }
}

extension MgnClientTypes {
    /// Import task summary servers.
    public struct ImportTaskSummaryServers {
        /// Import task summary servers created count.
        public var createdCount: Swift.Int
        /// Import task summary servers modified count.
        public var modifiedCount: Swift.Int

        public init(
            createdCount: Swift.Int = 0,
            modifiedCount: Swift.Int = 0
        )
        {
            self.createdCount = createdCount
            self.modifiedCount = modifiedCount
        }
    }

}

extension MgnClientTypes.ImportTaskSummaryWaves: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdCount
        case modifiedCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if createdCount != 0 {
            try encodeContainer.encode(createdCount, forKey: .createdCount)
        }
        if modifiedCount != 0 {
            try encodeContainer.encode(modifiedCount, forKey: .modifiedCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createdCount) ?? 0
        createdCount = createdCountDecoded
        let modifiedCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .modifiedCount) ?? 0
        modifiedCount = modifiedCountDecoded
    }
}

extension MgnClientTypes {
    /// Import task summery waves.
    public struct ImportTaskSummaryWaves {
        /// Import task summery waves created count.
        public var createdCount: Swift.Int
        /// Import task summery waves modified count.
        public var modifiedCount: Swift.Int

        public init(
            createdCount: Swift.Int = 0,
            modifiedCount: Swift.Int = 0
        )
        {
            self.createdCount = createdCount
            self.modifiedCount = modifiedCount
        }
    }

}

extension InitializeServiceInput {

    static func urlPathProvider(_ value: InitializeServiceInput) -> Swift.String? {
        return "/InitializeService"
    }
}

public struct InitializeServiceInput {

    public init() { }
}

struct InitializeServiceInputBody {
}

extension InitializeServiceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension InitializeServiceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct InitializeServiceOutput {

    public init() { }
}

enum InitializeServiceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MgnClientTypes {
    public enum InitiatedBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case diagnostic
        case startCutover
        case startTest
        case terminate
        case sdkUnknown(Swift.String)

        public static var allCases: [InitiatedBy] {
            return [
                .diagnostic,
                .startCutover,
                .startTest,
                .terminate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .diagnostic: return "DIAGNOSTIC"
            case .startCutover: return "START_CUTOVER"
            case .startTest: return "START_TEST"
            case .terminate: return "TERMINATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InitiatedBy(rawValue: rawValue) ?? InitiatedBy.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = 0
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The server encountered an unexpected condition that prevented it from fulfilling the request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The server encountered an unexpected condition that prevented it from fulfilling the request. The request will be retried again after x seconds.
        public internal(set) var retryAfterSeconds: Swift.Int = 0
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MgnClientTypes.Job: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
        case endDateTime
        case initiatedBy
        case jobID
        case participatingServers
        case status
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encode(creationDateTime, forKey: .creationDateTime)
        }
        if let endDateTime = self.endDateTime {
            try encodeContainer.encode(endDateTime, forKey: .endDateTime)
        }
        if let initiatedBy = self.initiatedBy {
            try encodeContainer.encode(initiatedBy.rawValue, forKey: .initiatedBy)
        }
        if let jobID = self.jobID {
            try encodeContainer.encode(jobID, forKey: .jobID)
        }
        if let participatingServers = participatingServers {
            var participatingServersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .participatingServers)
            for participatingserver0 in participatingServers {
                try participatingServersContainer.encode(participatingserver0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobID)
        jobID = jobIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.JobType.self, forKey: .type)
        type = typeDecoded
        let initiatedByDecoded = try containerValues.decodeIfPresent(MgnClientTypes.InitiatedBy.self, forKey: .initiatedBy)
        initiatedBy = initiatedByDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let endDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endDateTime)
        endDateTime = endDateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let participatingServersContainer = try containerValues.decodeIfPresent([MgnClientTypes.ParticipatingServer?].self, forKey: .participatingServers)
        var participatingServersDecoded0:[MgnClientTypes.ParticipatingServer]? = nil
        if let participatingServersContainer = participatingServersContainer {
            participatingServersDecoded0 = [MgnClientTypes.ParticipatingServer]()
            for structure0 in participatingServersContainer {
                if let structure0 = structure0 {
                    participatingServersDecoded0?.append(structure0)
                }
            }
        }
        participatingServers = participatingServersDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MgnClientTypes.Job: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Job(arn: \(Swift.String(describing: arn)), creationDateTime: \(Swift.String(describing: creationDateTime)), endDateTime: \(Swift.String(describing: endDateTime)), initiatedBy: \(Swift.String(describing: initiatedBy)), jobID: \(Swift.String(describing: jobID)), participatingServers: \(Swift.String(describing: participatingServers)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), tags: \"CONTENT_REDACTED\")"}
}

extension MgnClientTypes {
    /// Job.
    public struct Job {
        /// the ARN of the specific Job.
        public var arn: Swift.String?
        /// Job creation time.
        public var creationDateTime: Swift.String?
        /// Job end time.
        public var endDateTime: Swift.String?
        /// Job initiated by field.
        public var initiatedBy: MgnClientTypes.InitiatedBy?
        /// Job ID.
        /// This member is required.
        public var jobID: Swift.String?
        /// Servers participating in a specific Job.
        public var participatingServers: [MgnClientTypes.ParticipatingServer]?
        /// Job status.
        public var status: MgnClientTypes.JobStatus?
        /// Tags associated with specific Job.
        public var tags: [Swift.String:Swift.String]?
        /// Job type.
        public var type: MgnClientTypes.JobType?

        public init(
            arn: Swift.String? = nil,
            creationDateTime: Swift.String? = nil,
            endDateTime: Swift.String? = nil,
            initiatedBy: MgnClientTypes.InitiatedBy? = nil,
            jobID: Swift.String? = nil,
            participatingServers: [MgnClientTypes.ParticipatingServer]? = nil,
            status: MgnClientTypes.JobStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: MgnClientTypes.JobType? = nil
        )
        {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.endDateTime = endDateTime
            self.initiatedBy = initiatedBy
            self.jobID = jobID
            self.participatingServers = participatingServers
            self.status = status
            self.tags = tags
            self.type = type
        }
    }

}

extension MgnClientTypes.JobLog: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case event
        case eventData
        case logDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let event = self.event {
            try encodeContainer.encode(event.rawValue, forKey: .event)
        }
        if let eventData = self.eventData {
            try encodeContainer.encode(eventData, forKey: .eventData)
        }
        if let logDateTime = self.logDateTime {
            try encodeContainer.encode(logDateTime, forKey: .logDateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logDateTime)
        logDateTime = logDateTimeDecoded
        let eventDecoded = try containerValues.decodeIfPresent(MgnClientTypes.JobLogEvent.self, forKey: .event)
        event = eventDecoded
        let eventDataDecoded = try containerValues.decodeIfPresent(MgnClientTypes.JobLogEventData.self, forKey: .eventData)
        eventData = eventDataDecoded
    }
}

extension MgnClientTypes {
    /// Job log.
    public struct JobLog {
        /// Job log event.
        public var event: MgnClientTypes.JobLogEvent?
        /// Job event data
        public var eventData: MgnClientTypes.JobLogEventData?
        /// Job log event date and time.
        public var logDateTime: Swift.String?

        public init(
            event: MgnClientTypes.JobLogEvent? = nil,
            eventData: MgnClientTypes.JobLogEventData? = nil,
            logDateTime: Swift.String? = nil
        )
        {
            self.event = event
            self.eventData = eventData
            self.logDateTime = logDateTime
        }
    }

}

extension MgnClientTypes {
    public enum JobLogEvent: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cleanupEnd
        case cleanupFail
        case cleanupStart
        case conversionEnd
        case conversionFail
        case conversionStart
        case jobCancel
        case jobEnd
        case jobStart
        case launchFailed
        case launchStart
        case serverSkipped
        case snapshotEnd
        case snapshotFail
        case snapshotStart
        case usingPreviousSnapshot
        case sdkUnknown(Swift.String)

        public static var allCases: [JobLogEvent] {
            return [
                .cleanupEnd,
                .cleanupFail,
                .cleanupStart,
                .conversionEnd,
                .conversionFail,
                .conversionStart,
                .jobCancel,
                .jobEnd,
                .jobStart,
                .launchFailed,
                .launchStart,
                .serverSkipped,
                .snapshotEnd,
                .snapshotFail,
                .snapshotStart,
                .usingPreviousSnapshot,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cleanupEnd: return "CLEANUP_END"
            case .cleanupFail: return "CLEANUP_FAIL"
            case .cleanupStart: return "CLEANUP_START"
            case .conversionEnd: return "CONVERSION_END"
            case .conversionFail: return "CONVERSION_FAIL"
            case .conversionStart: return "CONVERSION_START"
            case .jobCancel: return "JOB_CANCEL"
            case .jobEnd: return "JOB_END"
            case .jobStart: return "JOB_START"
            case .launchFailed: return "LAUNCH_FAILED"
            case .launchStart: return "LAUNCH_START"
            case .serverSkipped: return "SERVER_SKIPPED"
            case .snapshotEnd: return "SNAPSHOT_END"
            case .snapshotFail: return "SNAPSHOT_FAIL"
            case .snapshotStart: return "SNAPSHOT_START"
            case .usingPreviousSnapshot: return "USING_PREVIOUS_SNAPSHOT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobLogEvent(rawValue: rawValue) ?? JobLogEvent.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes.JobLogEventData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conversionServerID
        case rawError
        case sourceServerID
        case targetInstanceID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conversionServerID = self.conversionServerID {
            try encodeContainer.encode(conversionServerID, forKey: .conversionServerID)
        }
        if let rawError = self.rawError {
            try encodeContainer.encode(rawError, forKey: .rawError)
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
        if let targetInstanceID = self.targetInstanceID {
            try encodeContainer.encode(targetInstanceID, forKey: .targetInstanceID)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let conversionServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conversionServerID)
        conversionServerID = conversionServerIDDecoded
        let targetInstanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetInstanceID)
        targetInstanceID = targetInstanceIDDecoded
        let rawErrorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rawError)
        rawError = rawErrorDecoded
    }
}

extension MgnClientTypes {
    /// Job log data
    public struct JobLogEventData {
        /// Job Event conversion Server ID.
        public var conversionServerID: Swift.String?
        /// Job error.
        public var rawError: Swift.String?
        /// Job Event Source Server ID.
        public var sourceServerID: Swift.String?
        /// Job Event Target instance ID.
        public var targetInstanceID: Swift.String?

        public init(
            conversionServerID: Swift.String? = nil,
            rawError: Swift.String? = nil,
            sourceServerID: Swift.String? = nil,
            targetInstanceID: Swift.String? = nil
        )
        {
            self.conversionServerID = conversionServerID
            self.rawError = rawError
            self.sourceServerID = sourceServerID
            self.targetInstanceID = targetInstanceID
        }
    }

}

extension MgnClientTypes.JobPostLaunchActionsLaunchStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionID
        case executionStatus
        case failureReason
        case ssmDocument
        case ssmDocumentType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionID = self.executionID {
            try encodeContainer.encode(executionID, forKey: .executionID)
        }
        if let executionStatus = self.executionStatus {
            try encodeContainer.encode(executionStatus.rawValue, forKey: .executionStatus)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let ssmDocument = self.ssmDocument {
            try encodeContainer.encode(ssmDocument, forKey: .ssmDocument)
        }
        if let ssmDocumentType = self.ssmDocumentType {
            try encodeContainer.encode(ssmDocumentType.rawValue, forKey: .ssmDocumentType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ssmDocumentDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SsmDocument.self, forKey: .ssmDocument)
        ssmDocument = ssmDocumentDecoded
        let ssmDocumentTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SsmDocumentType.self, forKey: .ssmDocumentType)
        ssmDocumentType = ssmDocumentTypeDecoded
        let executionIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionID)
        executionID = executionIDDecoded
        let executionStatusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.PostLaunchActionExecutionStatus.self, forKey: .executionStatus)
        executionStatus = executionStatusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension MgnClientTypes {
    /// Launch Status of the Job Post Launch Actions.
    public struct JobPostLaunchActionsLaunchStatus {
        /// AWS Systems Manager Document's execution ID of the of the Job Post Launch Actions.
        public var executionID: Swift.String?
        /// AWS Systems Manager Document's execution status.
        public var executionStatus: MgnClientTypes.PostLaunchActionExecutionStatus?
        /// AWS Systems Manager Document's failure reason.
        public var failureReason: Swift.String?
        /// AWS Systems Manager's Document of the of the Job Post Launch Actions.
        public var ssmDocument: MgnClientTypes.SsmDocument?
        /// AWS Systems Manager Document type.
        public var ssmDocumentType: MgnClientTypes.SsmDocumentType?

        public init(
            executionID: Swift.String? = nil,
            executionStatus: MgnClientTypes.PostLaunchActionExecutionStatus? = nil,
            failureReason: Swift.String? = nil,
            ssmDocument: MgnClientTypes.SsmDocument? = nil,
            ssmDocumentType: MgnClientTypes.SsmDocumentType? = nil
        )
        {
            self.executionID = executionID
            self.executionStatus = executionStatus
            self.failureReason = failureReason
            self.ssmDocument = ssmDocument
            self.ssmDocumentType = ssmDocumentType
        }
    }

}

extension MgnClientTypes {
    public enum JobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case pending
        case started
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .completed,
                .pending,
                .started,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .pending: return "PENDING"
            case .started: return "STARTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes {
    public enum JobType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case launch
        case terminate
        case sdkUnknown(Swift.String)

        public static var allCases: [JobType] {
            return [
                .launch,
                .terminate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .launch: return "LAUNCH"
            case .terminate: return "TERMINATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobType(rawValue: rawValue) ?? JobType.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes.LaunchConfigurationTemplate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case associatePublicIpAddress
        case bootMode
        case copyPrivateIp
        case copyTags
        case ec2LaunchTemplateID
        case enableMapAutoTagging
        case largeVolumeConf
        case launchConfigurationTemplateID
        case launchDisposition
        case licensing
        case mapAutoTaggingMpeID
        case postLaunchActions
        case smallVolumeConf
        case smallVolumeMaxSize
        case tags
        case targetInstanceTypeRightSizingMethod
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let associatePublicIpAddress = self.associatePublicIpAddress {
            try encodeContainer.encode(associatePublicIpAddress, forKey: .associatePublicIpAddress)
        }
        if let bootMode = self.bootMode {
            try encodeContainer.encode(bootMode.rawValue, forKey: .bootMode)
        }
        if let copyPrivateIp = self.copyPrivateIp {
            try encodeContainer.encode(copyPrivateIp, forKey: .copyPrivateIp)
        }
        if let copyTags = self.copyTags {
            try encodeContainer.encode(copyTags, forKey: .copyTags)
        }
        if let ec2LaunchTemplateID = self.ec2LaunchTemplateID {
            try encodeContainer.encode(ec2LaunchTemplateID, forKey: .ec2LaunchTemplateID)
        }
        if let enableMapAutoTagging = self.enableMapAutoTagging {
            try encodeContainer.encode(enableMapAutoTagging, forKey: .enableMapAutoTagging)
        }
        if let largeVolumeConf = self.largeVolumeConf {
            try encodeContainer.encode(largeVolumeConf, forKey: .largeVolumeConf)
        }
        if let launchConfigurationTemplateID = self.launchConfigurationTemplateID {
            try encodeContainer.encode(launchConfigurationTemplateID, forKey: .launchConfigurationTemplateID)
        }
        if let launchDisposition = self.launchDisposition {
            try encodeContainer.encode(launchDisposition.rawValue, forKey: .launchDisposition)
        }
        if let licensing = self.licensing {
            try encodeContainer.encode(licensing, forKey: .licensing)
        }
        if let mapAutoTaggingMpeID = self.mapAutoTaggingMpeID {
            try encodeContainer.encode(mapAutoTaggingMpeID, forKey: .mapAutoTaggingMpeID)
        }
        if let postLaunchActions = self.postLaunchActions {
            try encodeContainer.encode(postLaunchActions, forKey: .postLaunchActions)
        }
        if let smallVolumeConf = self.smallVolumeConf {
            try encodeContainer.encode(smallVolumeConf, forKey: .smallVolumeConf)
        }
        if smallVolumeMaxSize != 0 {
            try encodeContainer.encode(smallVolumeMaxSize, forKey: .smallVolumeMaxSize)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targetInstanceTypeRightSizingMethod = self.targetInstanceTypeRightSizingMethod {
            try encodeContainer.encode(targetInstanceTypeRightSizingMethod.rawValue, forKey: .targetInstanceTypeRightSizingMethod)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchConfigurationTemplateID)
        launchConfigurationTemplateID = launchConfigurationTemplateIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let postLaunchActionsDecoded = try containerValues.decodeIfPresent(MgnClientTypes.PostLaunchActions.self, forKey: .postLaunchActions)
        postLaunchActions = postLaunchActionsDecoded
        let enableMapAutoTaggingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableMapAutoTagging)
        enableMapAutoTagging = enableMapAutoTaggingDecoded
        let mapAutoTaggingMpeIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapAutoTaggingMpeID)
        mapAutoTaggingMpeID = mapAutoTaggingMpeIDDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let ec2LaunchTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2LaunchTemplateID)
        ec2LaunchTemplateID = ec2LaunchTemplateIDDecoded
        let launchDispositionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchDisposition.self, forKey: .launchDisposition)
        launchDisposition = launchDispositionDecoded
        let targetInstanceTypeRightSizingMethodDecoded = try containerValues.decodeIfPresent(MgnClientTypes.TargetInstanceTypeRightSizingMethod.self, forKey: .targetInstanceTypeRightSizingMethod)
        targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethodDecoded
        let copyPrivateIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyPrivateIp)
        copyPrivateIp = copyPrivateIpDecoded
        let associatePublicIpAddressDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associatePublicIpAddress)
        associatePublicIpAddress = associatePublicIpAddressDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let licensingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.Licensing.self, forKey: .licensing)
        licensing = licensingDecoded
        let bootModeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.BootMode.self, forKey: .bootMode)
        bootMode = bootModeDecoded
        let smallVolumeMaxSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .smallVolumeMaxSize) ?? 0
        smallVolumeMaxSize = smallVolumeMaxSizeDecoded
        let smallVolumeConfDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchTemplateDiskConf.self, forKey: .smallVolumeConf)
        smallVolumeConf = smallVolumeConfDecoded
        let largeVolumeConfDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchTemplateDiskConf.self, forKey: .largeVolumeConf)
        largeVolumeConf = largeVolumeConfDecoded
    }
}

extension MgnClientTypes.LaunchConfigurationTemplate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LaunchConfigurationTemplate(arn: \(Swift.String(describing: arn)), associatePublicIpAddress: \(Swift.String(describing: associatePublicIpAddress)), bootMode: \(Swift.String(describing: bootMode)), copyPrivateIp: \(Swift.String(describing: copyPrivateIp)), copyTags: \(Swift.String(describing: copyTags)), ec2LaunchTemplateID: \(Swift.String(describing: ec2LaunchTemplateID)), enableMapAutoTagging: \(Swift.String(describing: enableMapAutoTagging)), largeVolumeConf: \(Swift.String(describing: largeVolumeConf)), launchConfigurationTemplateID: \(Swift.String(describing: launchConfigurationTemplateID)), launchDisposition: \(Swift.String(describing: launchDisposition)), licensing: \(Swift.String(describing: licensing)), mapAutoTaggingMpeID: \(Swift.String(describing: mapAutoTaggingMpeID)), postLaunchActions: \(Swift.String(describing: postLaunchActions)), smallVolumeConf: \(Swift.String(describing: smallVolumeConf)), smallVolumeMaxSize: \(Swift.String(describing: smallVolumeMaxSize)), targetInstanceTypeRightSizingMethod: \(Swift.String(describing: targetInstanceTypeRightSizingMethod)), tags: \"CONTENT_REDACTED\")"}
}

extension MgnClientTypes {
    public struct LaunchConfigurationTemplate {
        /// ARN of the Launch Configuration Template.
        public var arn: Swift.String?
        /// Associate public Ip address.
        public var associatePublicIpAddress: Swift.Bool?
        /// Launch configuration template boot mode.
        public var bootMode: MgnClientTypes.BootMode?
        /// Copy private Ip.
        public var copyPrivateIp: Swift.Bool?
        /// Copy tags.
        public var copyTags: Swift.Bool?
        /// EC2 launch template ID.
        public var ec2LaunchTemplateID: Swift.String?
        /// Enable map auto tagging.
        public var enableMapAutoTagging: Swift.Bool?
        /// Large volume config.
        public var largeVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
        /// ID of the Launch Configuration Template.
        /// This member is required.
        public var launchConfigurationTemplateID: Swift.String?
        /// Launch disposition.
        public var launchDisposition: MgnClientTypes.LaunchDisposition?
        /// Configure Licensing.
        public var licensing: MgnClientTypes.Licensing?
        /// Launch configuration template map auto tagging MPE ID.
        public var mapAutoTaggingMpeID: Swift.String?
        /// Post Launch Actions of the Launch Configuration Template.
        public var postLaunchActions: MgnClientTypes.PostLaunchActions?
        /// Small volume config.
        public var smallVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
        /// Small volume maximum size.
        public var smallVolumeMaxSize: Swift.Int
        /// Tags of the Launch Configuration Template.
        public var tags: [Swift.String:Swift.String]?
        /// Target instance type right-sizing method.
        public var targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?

        public init(
            arn: Swift.String? = nil,
            associatePublicIpAddress: Swift.Bool? = nil,
            bootMode: MgnClientTypes.BootMode? = nil,
            copyPrivateIp: Swift.Bool? = nil,
            copyTags: Swift.Bool? = nil,
            ec2LaunchTemplateID: Swift.String? = nil,
            enableMapAutoTagging: Swift.Bool? = nil,
            largeVolumeConf: MgnClientTypes.LaunchTemplateDiskConf? = nil,
            launchConfigurationTemplateID: Swift.String? = nil,
            launchDisposition: MgnClientTypes.LaunchDisposition? = nil,
            licensing: MgnClientTypes.Licensing? = nil,
            mapAutoTaggingMpeID: Swift.String? = nil,
            postLaunchActions: MgnClientTypes.PostLaunchActions? = nil,
            smallVolumeConf: MgnClientTypes.LaunchTemplateDiskConf? = nil,
            smallVolumeMaxSize: Swift.Int = 0,
            tags: [Swift.String:Swift.String]? = nil,
            targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod? = nil
        )
        {
            self.arn = arn
            self.associatePublicIpAddress = associatePublicIpAddress
            self.bootMode = bootMode
            self.copyPrivateIp = copyPrivateIp
            self.copyTags = copyTags
            self.ec2LaunchTemplateID = ec2LaunchTemplateID
            self.enableMapAutoTagging = enableMapAutoTagging
            self.largeVolumeConf = largeVolumeConf
            self.launchConfigurationTemplateID = launchConfigurationTemplateID
            self.launchDisposition = launchDisposition
            self.licensing = licensing
            self.mapAutoTaggingMpeID = mapAutoTaggingMpeID
            self.postLaunchActions = postLaunchActions
            self.smallVolumeConf = smallVolumeConf
            self.smallVolumeMaxSize = smallVolumeMaxSize
            self.tags = tags
            self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
        }
    }

}

extension MgnClientTypes {
    public enum LaunchDisposition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case started
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchDisposition] {
            return [
                .started,
                .stopped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .started: return "STARTED"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LaunchDisposition(rawValue: rawValue) ?? LaunchDisposition.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes {
    public enum LaunchStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case launched
        case pending
        case terminated
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchStatus] {
            return [
                .failed,
                .inProgress,
                .launched,
                .pending,
                .terminated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .launched: return "LAUNCHED"
            case .pending: return "PENDING"
            case .terminated: return "TERMINATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LaunchStatus(rawValue: rawValue) ?? LaunchStatus.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes.LaunchTemplateDiskConf: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iops
        case throughput
        case volumeType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iops = self.iops {
            try encodeContainer.encode(iops, forKey: .iops)
        }
        if let throughput = self.throughput {
            try encodeContainer.encode(throughput, forKey: .throughput)
        }
        if let volumeType = self.volumeType {
            try encodeContainer.encode(volumeType.rawValue, forKey: .volumeType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.VolumeType.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops)
        iops = iopsDecoded
        let throughputDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .throughput)
        throughput = throughputDecoded
    }
}

extension MgnClientTypes {
    /// Launch template disk configuration.
    public struct LaunchTemplateDiskConf {
        /// Launch template disk iops configuration.
        public var iops: Swift.Int?
        /// Launch template disk throughput configuration.
        public var throughput: Swift.Int?
        /// Launch template disk volume type configuration.
        public var volumeType: MgnClientTypes.VolumeType?

        public init(
            iops: Swift.Int? = nil,
            throughput: Swift.Int? = nil,
            volumeType: MgnClientTypes.VolumeType? = nil
        )
        {
            self.iops = iops
            self.throughput = throughput
            self.volumeType = volumeType
        }
    }

}

extension MgnClientTypes.LaunchedInstance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ec2InstanceID
        case firstBoot
        case jobID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ec2InstanceID = self.ec2InstanceID {
            try encodeContainer.encode(ec2InstanceID, forKey: .ec2InstanceID)
        }
        if let firstBoot = self.firstBoot {
            try encodeContainer.encode(firstBoot.rawValue, forKey: .firstBoot)
        }
        if let jobID = self.jobID {
            try encodeContainer.encode(jobID, forKey: .jobID)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ec2InstanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2InstanceID)
        ec2InstanceID = ec2InstanceIDDecoded
        let jobIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobID)
        jobID = jobIDDecoded
        let firstBootDecoded = try containerValues.decodeIfPresent(MgnClientTypes.FirstBoot.self, forKey: .firstBoot)
        firstBoot = firstBootDecoded
    }
}

extension MgnClientTypes {
    /// Launched instance.
    public struct LaunchedInstance {
        /// Launched instance EC2 ID.
        public var ec2InstanceID: Swift.String?
        /// Launched instance first boot.
        public var firstBoot: MgnClientTypes.FirstBoot?
        /// Launched instance Job ID.
        public var jobID: Swift.String?

        public init(
            ec2InstanceID: Swift.String? = nil,
            firstBoot: MgnClientTypes.FirstBoot? = nil,
            jobID: Swift.String? = nil
        )
        {
            self.ec2InstanceID = ec2InstanceID
            self.firstBoot = firstBoot
            self.jobID = jobID
        }
    }

}

extension MgnClientTypes.Licensing: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case osByol
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let osByol = self.osByol {
            try encodeContainer.encode(osByol, forKey: .osByol)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let osByolDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .osByol)
        osByol = osByolDecoded
    }
}

extension MgnClientTypes {
    /// Configure Licensing.
    public struct Licensing {
        /// Configure BYOL OS licensing.
        public var osByol: Swift.Bool?

        public init(
            osByol: Swift.Bool? = nil
        )
        {
            self.osByol = osByol
        }
    }

}

extension MgnClientTypes.LifeCycle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addedToServiceDateTime
        case elapsedReplicationDuration
        case firstByteDateTime
        case lastCutover
        case lastSeenByServiceDateTime
        case lastTest
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addedToServiceDateTime = self.addedToServiceDateTime {
            try encodeContainer.encode(addedToServiceDateTime, forKey: .addedToServiceDateTime)
        }
        if let elapsedReplicationDuration = self.elapsedReplicationDuration {
            try encodeContainer.encode(elapsedReplicationDuration, forKey: .elapsedReplicationDuration)
        }
        if let firstByteDateTime = self.firstByteDateTime {
            try encodeContainer.encode(firstByteDateTime, forKey: .firstByteDateTime)
        }
        if let lastCutover = self.lastCutover {
            try encodeContainer.encode(lastCutover, forKey: .lastCutover)
        }
        if let lastSeenByServiceDateTime = self.lastSeenByServiceDateTime {
            try encodeContainer.encode(lastSeenByServiceDateTime, forKey: .lastSeenByServiceDateTime)
        }
        if let lastTest = self.lastTest {
            try encodeContainer.encode(lastTest, forKey: .lastTest)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addedToServiceDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addedToServiceDateTime)
        addedToServiceDateTime = addedToServiceDateTimeDecoded
        let firstByteDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstByteDateTime)
        firstByteDateTime = firstByteDateTimeDecoded
        let elapsedReplicationDurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .elapsedReplicationDuration)
        elapsedReplicationDuration = elapsedReplicationDurationDecoded
        let lastSeenByServiceDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastSeenByServiceDateTime)
        lastSeenByServiceDateTime = lastSeenByServiceDateTimeDecoded
        let lastTestDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycleLastTest.self, forKey: .lastTest)
        lastTest = lastTestDecoded
        let lastCutoverDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycleLastCutover.self, forKey: .lastCutover)
        lastCutover = lastCutoverDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycleState.self, forKey: .state)
        state = stateDecoded
    }
}

extension MgnClientTypes {
    /// Lifecycle.
    public struct LifeCycle {
        /// Lifecycle added to service data and time.
        public var addedToServiceDateTime: Swift.String?
        /// Lifecycle elapsed time and duration.
        public var elapsedReplicationDuration: Swift.String?
        /// Lifecycle replication initiation date and time.
        public var firstByteDateTime: Swift.String?
        /// Lifecycle last Cutover.
        public var lastCutover: MgnClientTypes.LifeCycleLastCutover?
        /// Lifecycle last seen date and time.
        public var lastSeenByServiceDateTime: Swift.String?
        /// Lifecycle last Test.
        public var lastTest: MgnClientTypes.LifeCycleLastTest?
        /// Lifecycle state.
        public var state: MgnClientTypes.LifeCycleState?

        public init(
            addedToServiceDateTime: Swift.String? = nil,
            elapsedReplicationDuration: Swift.String? = nil,
            firstByteDateTime: Swift.String? = nil,
            lastCutover: MgnClientTypes.LifeCycleLastCutover? = nil,
            lastSeenByServiceDateTime: Swift.String? = nil,
            lastTest: MgnClientTypes.LifeCycleLastTest? = nil,
            state: MgnClientTypes.LifeCycleState? = nil
        )
        {
            self.addedToServiceDateTime = addedToServiceDateTime
            self.elapsedReplicationDuration = elapsedReplicationDuration
            self.firstByteDateTime = firstByteDateTime
            self.lastCutover = lastCutover
            self.lastSeenByServiceDateTime = lastSeenByServiceDateTime
            self.lastTest = lastTest
            self.state = state
        }
    }

}

extension MgnClientTypes.LifeCycleLastCutover: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case finalized
        case initiated
        case reverted
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let finalized = self.finalized {
            try encodeContainer.encode(finalized, forKey: .finalized)
        }
        if let initiated = self.initiated {
            try encodeContainer.encode(initiated, forKey: .initiated)
        }
        if let reverted = self.reverted {
            try encodeContainer.encode(reverted, forKey: .reverted)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initiatedDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycleLastCutoverInitiated.self, forKey: .initiated)
        initiated = initiatedDecoded
        let revertedDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycleLastCutoverReverted.self, forKey: .reverted)
        reverted = revertedDecoded
        let finalizedDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycleLastCutoverFinalized.self, forKey: .finalized)
        finalized = finalizedDecoded
    }
}

extension MgnClientTypes {
    /// Lifecycle last Cutover .
    public struct LifeCycleLastCutover {
        /// Lifecycle Cutover finalized date and time.
        public var finalized: MgnClientTypes.LifeCycleLastCutoverFinalized?
        /// Lifecycle last Cutover initiated.
        public var initiated: MgnClientTypes.LifeCycleLastCutoverInitiated?
        /// Lifecycle last Cutover reverted.
        public var reverted: MgnClientTypes.LifeCycleLastCutoverReverted?

        public init(
            finalized: MgnClientTypes.LifeCycleLastCutoverFinalized? = nil,
            initiated: MgnClientTypes.LifeCycleLastCutoverInitiated? = nil,
            reverted: MgnClientTypes.LifeCycleLastCutoverReverted? = nil
        )
        {
            self.finalized = finalized
            self.initiated = initiated
            self.reverted = reverted
        }
    }

}

extension MgnClientTypes.LifeCycleLastCutoverFinalized: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCallDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiCallDateTime = self.apiCallDateTime {
            try encodeContainer.encode(apiCallDateTime, forKey: .apiCallDateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiCallDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiCallDateTime)
        apiCallDateTime = apiCallDateTimeDecoded
    }
}

extension MgnClientTypes {
    /// Lifecycle Cutover finalized
    public struct LifeCycleLastCutoverFinalized {
        /// Lifecycle Cutover finalized date and time.
        public var apiCallDateTime: Swift.String?

        public init(
            apiCallDateTime: Swift.String? = nil
        )
        {
            self.apiCallDateTime = apiCallDateTime
        }
    }

}

extension MgnClientTypes.LifeCycleLastCutoverInitiated: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCallDateTime
        case jobID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiCallDateTime = self.apiCallDateTime {
            try encodeContainer.encode(apiCallDateTime, forKey: .apiCallDateTime)
        }
        if let jobID = self.jobID {
            try encodeContainer.encode(jobID, forKey: .jobID)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiCallDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiCallDateTime)
        apiCallDateTime = apiCallDateTimeDecoded
        let jobIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobID)
        jobID = jobIDDecoded
    }
}

extension MgnClientTypes {
    /// Lifecycle last Cutover initiated.
    public struct LifeCycleLastCutoverInitiated {
        ///
        public var apiCallDateTime: Swift.String?
        /// Lifecycle last Cutover initiated by Job ID.
        public var jobID: Swift.String?

        public init(
            apiCallDateTime: Swift.String? = nil,
            jobID: Swift.String? = nil
        )
        {
            self.apiCallDateTime = apiCallDateTime
            self.jobID = jobID
        }
    }

}

extension MgnClientTypes.LifeCycleLastCutoverReverted: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCallDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiCallDateTime = self.apiCallDateTime {
            try encodeContainer.encode(apiCallDateTime, forKey: .apiCallDateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiCallDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiCallDateTime)
        apiCallDateTime = apiCallDateTimeDecoded
    }
}

extension MgnClientTypes {
    /// Lifecycle last Cutover reverted.
    public struct LifeCycleLastCutoverReverted {
        /// Lifecycle last Cutover reverted API call date time.
        public var apiCallDateTime: Swift.String?

        public init(
            apiCallDateTime: Swift.String? = nil
        )
        {
            self.apiCallDateTime = apiCallDateTime
        }
    }

}

extension MgnClientTypes.LifeCycleLastTest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case finalized
        case initiated
        case reverted
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let finalized = self.finalized {
            try encodeContainer.encode(finalized, forKey: .finalized)
        }
        if let initiated = self.initiated {
            try encodeContainer.encode(initiated, forKey: .initiated)
        }
        if let reverted = self.reverted {
            try encodeContainer.encode(reverted, forKey: .reverted)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initiatedDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycleLastTestInitiated.self, forKey: .initiated)
        initiated = initiatedDecoded
        let revertedDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycleLastTestReverted.self, forKey: .reverted)
        reverted = revertedDecoded
        let finalizedDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycleLastTestFinalized.self, forKey: .finalized)
        finalized = finalizedDecoded
    }
}

extension MgnClientTypes {
    /// Lifecycle last Test.
    public struct LifeCycleLastTest {
        /// Lifecycle last Test finalized.
        public var finalized: MgnClientTypes.LifeCycleLastTestFinalized?
        /// Lifecycle last Test initiated.
        public var initiated: MgnClientTypes.LifeCycleLastTestInitiated?
        /// Lifecycle last Test reverted.
        public var reverted: MgnClientTypes.LifeCycleLastTestReverted?

        public init(
            finalized: MgnClientTypes.LifeCycleLastTestFinalized? = nil,
            initiated: MgnClientTypes.LifeCycleLastTestInitiated? = nil,
            reverted: MgnClientTypes.LifeCycleLastTestReverted? = nil
        )
        {
            self.finalized = finalized
            self.initiated = initiated
            self.reverted = reverted
        }
    }

}

extension MgnClientTypes.LifeCycleLastTestFinalized: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCallDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiCallDateTime = self.apiCallDateTime {
            try encodeContainer.encode(apiCallDateTime, forKey: .apiCallDateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiCallDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiCallDateTime)
        apiCallDateTime = apiCallDateTimeDecoded
    }
}

extension MgnClientTypes {
    /// Lifecycle last Test finalized.
    public struct LifeCycleLastTestFinalized {
        /// Lifecycle Test failed API call date and time.
        public var apiCallDateTime: Swift.String?

        public init(
            apiCallDateTime: Swift.String? = nil
        )
        {
            self.apiCallDateTime = apiCallDateTime
        }
    }

}

extension MgnClientTypes.LifeCycleLastTestInitiated: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCallDateTime
        case jobID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiCallDateTime = self.apiCallDateTime {
            try encodeContainer.encode(apiCallDateTime, forKey: .apiCallDateTime)
        }
        if let jobID = self.jobID {
            try encodeContainer.encode(jobID, forKey: .jobID)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiCallDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiCallDateTime)
        apiCallDateTime = apiCallDateTimeDecoded
        let jobIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobID)
        jobID = jobIDDecoded
    }
}

extension MgnClientTypes {
    /// Lifecycle last Test initiated.
    public struct LifeCycleLastTestInitiated {
        /// Lifecycle last Test initiated API call date and time.
        public var apiCallDateTime: Swift.String?
        /// Lifecycle last Test initiated Job ID.
        public var jobID: Swift.String?

        public init(
            apiCallDateTime: Swift.String? = nil,
            jobID: Swift.String? = nil
        )
        {
            self.apiCallDateTime = apiCallDateTime
            self.jobID = jobID
        }
    }

}

extension MgnClientTypes.LifeCycleLastTestReverted: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCallDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiCallDateTime = self.apiCallDateTime {
            try encodeContainer.encode(apiCallDateTime, forKey: .apiCallDateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiCallDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiCallDateTime)
        apiCallDateTime = apiCallDateTimeDecoded
    }
}

extension MgnClientTypes {
    /// Lifecycle last Test reverted.
    public struct LifeCycleLastTestReverted {
        /// Lifecycle last Test reverted API call date and time.
        public var apiCallDateTime: Swift.String?

        public init(
            apiCallDateTime: Swift.String? = nil
        )
        {
            self.apiCallDateTime = apiCallDateTime
        }
    }

}

extension MgnClientTypes {
    public enum LifeCycleState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cutover
        case cuttingOver
        case disconnected
        case discovered
        case notReady
        case pendingInstallation
        case readyForCutover
        case readyForTest
        case stopped
        case testing
        case sdkUnknown(Swift.String)

        public static var allCases: [LifeCycleState] {
            return [
                .cutover,
                .cuttingOver,
                .disconnected,
                .discovered,
                .notReady,
                .pendingInstallation,
                .readyForCutover,
                .readyForTest,
                .stopped,
                .testing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cutover: return "CUTOVER"
            case .cuttingOver: return "CUTTING_OVER"
            case .disconnected: return "DISCONNECTED"
            case .discovered: return "DISCOVERED"
            case .notReady: return "NOT_READY"
            case .pendingInstallation: return "PENDING_INSTALLATION"
            case .readyForCutover: return "READY_FOR_CUTOVER"
            case .readyForTest: return "READY_FOR_TEST"
            case .stopped: return "STOPPED"
            case .testing: return "TESTING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LifeCycleState(rawValue: rawValue) ?? LifeCycleState.sdkUnknown(rawValue)
        }
    }
}

extension ListApplicationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListApplicationsInput {

    static func urlPathProvider(_ value: ListApplicationsInput) -> Swift.String? {
        return "/ListApplications"
    }
}

public struct ListApplicationsInput {
    /// Applications list Account ID.
    public var accountID: Swift.String?
    /// Applications list filters.
    public var filters: MgnClientTypes.ListApplicationsRequestFilters?
    /// Maximum results to return when listing applications.
    public var maxResults: Swift.Int?
    /// Request next token.
    public var nextToken: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        filters: MgnClientTypes.ListApplicationsRequestFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApplicationsInputBody {
    let filters: MgnClientTypes.ListApplicationsRequestFilters?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let accountID: Swift.String?
}

extension ListApplicationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ListApplicationsRequestFilters.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension ListApplicationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListApplicationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationsOutput {
    /// Applications list.
    public var items: [MgnClientTypes.Application]?
    /// Response next token.
    public var nextToken: Swift.String?

    public init(
        items: [MgnClientTypes.Application]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListApplicationsOutputBody {
    let items: [MgnClientTypes.Application]?
    let nextToken: Swift.String?
}

extension ListApplicationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MgnClientTypes.Application?].self, forKey: .items)
        var itemsDecoded0:[MgnClientTypes.Application]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MgnClientTypes.Application]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListApplicationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MgnClientTypes.ListApplicationsRequestFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationIDs
        case isArchived
        case waveIDs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationIDs = applicationIDs {
            var applicationIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applicationIDs)
            for applicationid0 in applicationIDs {
                try applicationIDsContainer.encode(applicationid0)
            }
        }
        if let isArchived = self.isArchived {
            try encodeContainer.encode(isArchived, forKey: .isArchived)
        }
        if let waveIDs = waveIDs {
            var waveIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .waveIDs)
            for waveid0 in waveIDs {
                try waveIDsContainer.encode(waveid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .applicationIDs)
        var applicationIDsDecoded0:[Swift.String]? = nil
        if let applicationIDsContainer = applicationIDsContainer {
            applicationIDsDecoded0 = [Swift.String]()
            for string0 in applicationIDsContainer {
                if let string0 = string0 {
                    applicationIDsDecoded0?.append(string0)
                }
            }
        }
        applicationIDs = applicationIDsDecoded0
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let waveIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .waveIDs)
        var waveIDsDecoded0:[Swift.String]? = nil
        if let waveIDsContainer = waveIDsContainer {
            waveIDsDecoded0 = [Swift.String]()
            for string0 in waveIDsContainer {
                if let string0 = string0 {
                    waveIDsDecoded0?.append(string0)
                }
            }
        }
        waveIDs = waveIDsDecoded0
    }
}

extension MgnClientTypes {
    /// Applications list filters.
    public struct ListApplicationsRequestFilters {
        /// Filter applications list by application ID.
        public var applicationIDs: [Swift.String]?
        /// Filter applications list by archival status.
        public var isArchived: Swift.Bool?
        /// Filter applications list by wave ID.
        public var waveIDs: [Swift.String]?

        public init(
            applicationIDs: [Swift.String]? = nil,
            isArchived: Swift.Bool? = nil,
            waveIDs: [Swift.String]? = nil
        )
        {
            self.applicationIDs = applicationIDs
            self.isArchived = isArchived
            self.waveIDs = waveIDs
        }
    }

}

extension ListConnectorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListConnectorsInput {

    static func urlPathProvider(_ value: ListConnectorsInput) -> Swift.String? {
        return "/ListConnectors"
    }
}

public struct ListConnectorsInput {
    /// List Connectors Request filters.
    public var filters: MgnClientTypes.ListConnectorsRequestFilters?
    /// List Connectors Request max results.
    public var maxResults: Swift.Int?
    /// List Connectors Request next token.
    public var nextToken: Swift.String?

    public init(
        filters: MgnClientTypes.ListConnectorsRequestFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConnectorsInputBody {
    let filters: MgnClientTypes.ListConnectorsRequestFilters?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListConnectorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ListConnectorsRequestFilters.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListConnectorsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListConnectorsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListConnectorsOutput {
    /// List connectors response items.
    public var items: [MgnClientTypes.Connector]?
    /// List connectors response next token.
    public var nextToken: Swift.String?

    public init(
        items: [MgnClientTypes.Connector]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListConnectorsOutputBody {
    let items: [MgnClientTypes.Connector]?
    let nextToken: Swift.String?
}

extension ListConnectorsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MgnClientTypes.Connector?].self, forKey: .items)
        var itemsDecoded0:[MgnClientTypes.Connector]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MgnClientTypes.Connector]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListConnectorsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MgnClientTypes.ListConnectorsRequestFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorIDs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorIDs = connectorIDs {
            var connectorIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .connectorIDs)
            for connectorid0 in connectorIDs {
                try connectorIDsContainer.encode(connectorid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .connectorIDs)
        var connectorIDsDecoded0:[Swift.String]? = nil
        if let connectorIDsContainer = connectorIDsContainer {
            connectorIDsDecoded0 = [Swift.String]()
            for string0 in connectorIDsContainer {
                if let string0 = string0 {
                    connectorIDsDecoded0?.append(string0)
                }
            }
        }
        connectorIDs = connectorIDsDecoded0
    }
}

extension MgnClientTypes {
    /// List Connectors Request Filters.
    public struct ListConnectorsRequestFilters {
        /// List Connectors Request Filters connector IDs.
        public var connectorIDs: [Swift.String]?

        public init(
            connectorIDs: [Swift.String]? = nil
        )
        {
            self.connectorIDs = connectorIDs
        }
    }

}

extension ListExportErrorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportID
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exportID = self.exportID {
            try encodeContainer.encode(exportID, forKey: .exportID)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListExportErrorsInput {

    static func urlPathProvider(_ value: ListExportErrorsInput) -> Swift.String? {
        return "/ListExportErrors"
    }
}

/// List export errors request.
public struct ListExportErrorsInput {
    /// List export errors request export id.
    /// This member is required.
    public var exportID: Swift.String?
    /// List export errors request max results.
    public var maxResults: Swift.Int?
    /// List export errors request next token.
    public var nextToken: Swift.String?

    public init(
        exportID: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.exportID = exportID
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListExportErrorsInputBody {
    let exportID: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListExportErrorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportID
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportID)
        exportID = exportIDDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListExportErrorsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListExportErrorsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

/// List export errors response.
public struct ListExportErrorsOutput {
    /// List export errors response items.
    public var items: [MgnClientTypes.ExportTaskError]?
    /// List export errors response next token.
    public var nextToken: Swift.String?

    public init(
        items: [MgnClientTypes.ExportTaskError]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListExportErrorsOutputBody {
    let items: [MgnClientTypes.ExportTaskError]?
    let nextToken: Swift.String?
}

extension ListExportErrorsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MgnClientTypes.ExportTaskError?].self, forKey: .items)
        var itemsDecoded0:[MgnClientTypes.ExportTaskError]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MgnClientTypes.ExportTaskError]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListExportErrorsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListExportsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListExportsInput {

    static func urlPathProvider(_ value: ListExportsInput) -> Swift.String? {
        return "/ListExports"
    }
}

/// List export request.
public struct ListExportsInput {
    /// List exports request filters.
    public var filters: MgnClientTypes.ListExportsRequestFilters?
    /// List export request max results.
    public var maxResults: Swift.Int?
    /// List export request next token.
    public var nextToken: Swift.String?

    public init(
        filters: MgnClientTypes.ListExportsRequestFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListExportsInputBody {
    let filters: MgnClientTypes.ListExportsRequestFilters?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListExportsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ListExportsRequestFilters.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListExportsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListExportsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

/// List export response.
public struct ListExportsOutput {
    /// List export response items.
    public var items: [MgnClientTypes.ExportTask]?
    /// List export response next token.
    public var nextToken: Swift.String?

    public init(
        items: [MgnClientTypes.ExportTask]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListExportsOutputBody {
    let items: [MgnClientTypes.ExportTask]?
    let nextToken: Swift.String?
}

extension ListExportsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MgnClientTypes.ExportTask?].self, forKey: .items)
        var itemsDecoded0:[MgnClientTypes.ExportTask]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MgnClientTypes.ExportTask]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListExportsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MgnClientTypes.ListExportsRequestFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportIDs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exportIDs = exportIDs {
            var exportIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exportIDs)
            for exportid0 in exportIDs {
                try exportIDsContainer.encode(exportid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .exportIDs)
        var exportIDsDecoded0:[Swift.String]? = nil
        if let exportIDsContainer = exportIDsContainer {
            exportIDsDecoded0 = [Swift.String]()
            for string0 in exportIDsContainer {
                if let string0 = string0 {
                    exportIDsDecoded0?.append(string0)
                }
            }
        }
        exportIDs = exportIDsDecoded0
    }
}

extension MgnClientTypes {
    /// List exports request filters.
    public struct ListExportsRequestFilters {
        /// List exports request filters export ids.
        public var exportIDs: [Swift.String]?

        public init(
            exportIDs: [Swift.String]? = nil
        )
        {
            self.exportIDs = exportIDs
        }
    }

}

extension ListImportErrorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importID
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let importID = self.importID {
            try encodeContainer.encode(importID, forKey: .importID)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListImportErrorsInput {

    static func urlPathProvider(_ value: ListImportErrorsInput) -> Swift.String? {
        return "/ListImportErrors"
    }
}

/// List import errors request.
public struct ListImportErrorsInput {
    /// List import errors request import id.
    /// This member is required.
    public var importID: Swift.String?
    /// List import errors request max results.
    public var maxResults: Swift.Int?
    /// List import errors request next token.
    public var nextToken: Swift.String?

    public init(
        importID: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.importID = importID
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListImportErrorsInputBody {
    let importID: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListImportErrorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importID
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importID)
        importID = importIDDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListImportErrorsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListImportErrorsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

/// List imports errors response.
public struct ListImportErrorsOutput {
    /// List imports errors response items.
    public var items: [MgnClientTypes.ImportTaskError]?
    /// List imports errors response next token.
    public var nextToken: Swift.String?

    public init(
        items: [MgnClientTypes.ImportTaskError]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListImportErrorsOutputBody {
    let items: [MgnClientTypes.ImportTaskError]?
    let nextToken: Swift.String?
}

extension ListImportErrorsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MgnClientTypes.ImportTaskError?].self, forKey: .items)
        var itemsDecoded0:[MgnClientTypes.ImportTaskError]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MgnClientTypes.ImportTaskError]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListImportErrorsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListImportsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListImportsInput {

    static func urlPathProvider(_ value: ListImportsInput) -> Swift.String? {
        return "/ListImports"
    }
}

/// List imports request.
public struct ListImportsInput {
    /// List imports request filters.
    public var filters: MgnClientTypes.ListImportsRequestFilters?
    /// List imports request max results.
    public var maxResults: Swift.Int?
    /// List imports request next token.
    public var nextToken: Swift.String?

    public init(
        filters: MgnClientTypes.ListImportsRequestFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListImportsInputBody {
    let filters: MgnClientTypes.ListImportsRequestFilters?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListImportsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ListImportsRequestFilters.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListImportsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListImportsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

/// List import response.
public struct ListImportsOutput {
    /// List import response items.
    public var items: [MgnClientTypes.ImportTask]?
    /// List import response next token.
    public var nextToken: Swift.String?

    public init(
        items: [MgnClientTypes.ImportTask]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListImportsOutputBody {
    let items: [MgnClientTypes.ImportTask]?
    let nextToken: Swift.String?
}

extension ListImportsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MgnClientTypes.ImportTask?].self, forKey: .items)
        var itemsDecoded0:[MgnClientTypes.ImportTask]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MgnClientTypes.ImportTask]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListImportsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MgnClientTypes.ListImportsRequestFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importIDs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let importIDs = importIDs {
            var importIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .importIDs)
            for importid0 in importIDs {
                try importIDsContainer.encode(importid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .importIDs)
        var importIDsDecoded0:[Swift.String]? = nil
        if let importIDsContainer = importIDsContainer {
            importIDsDecoded0 = [Swift.String]()
            for string0 in importIDsContainer {
                if let string0 = string0 {
                    importIDsDecoded0?.append(string0)
                }
            }
        }
        importIDs = importIDsDecoded0
    }
}

extension MgnClientTypes {
    /// List imports request filters.
    public struct ListImportsRequestFilters {
        /// List imports request filters import IDs.
        public var importIDs: [Swift.String]?

        public init(
            importIDs: [Swift.String]? = nil
        )
        {
            self.importIDs = importIDs
        }
    }

}

extension ListManagedAccountsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListManagedAccountsInput {

    static func urlPathProvider(_ value: ListManagedAccountsInput) -> Swift.String? {
        return "/ListManagedAccounts"
    }
}

/// List managed accounts request.
public struct ListManagedAccountsInput {
    /// List managed accounts request max results.
    public var maxResults: Swift.Int?
    /// List managed accounts request next token.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListManagedAccountsInputBody {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListManagedAccountsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListManagedAccountsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListManagedAccountsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

/// List managed accounts response.
public struct ListManagedAccountsOutput {
    /// List managed accounts response items.
    /// This member is required.
    public var items: [MgnClientTypes.ManagedAccount]?
    /// List managed accounts response next token.
    public var nextToken: Swift.String?

    public init(
        items: [MgnClientTypes.ManagedAccount]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListManagedAccountsOutputBody {
    let items: [MgnClientTypes.ManagedAccount]?
    let nextToken: Swift.String?
}

extension ListManagedAccountsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MgnClientTypes.ManagedAccount?].self, forKey: .items)
        var itemsDecoded0:[MgnClientTypes.ManagedAccount]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MgnClientTypes.ManagedAccount]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListManagedAccountsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSourceServerActionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case filters
        case maxResults
        case nextToken
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension ListSourceServerActionsInput {

    static func urlPathProvider(_ value: ListSourceServerActionsInput) -> Swift.String? {
        return "/ListSourceServerActions"
    }
}

public struct ListSourceServerActionsInput {
    /// Account ID to return when listing source server post migration custom actions.
    public var accountID: Swift.String?
    /// Filters to apply when listing source server post migration custom actions.
    public var filters: MgnClientTypes.SourceServerActionsRequestFilters?
    /// Maximum amount of items to return when listing source server post migration custom actions.
    public var maxResults: Swift.Int?
    /// Next token to use when listing source server post migration custom actions.
    public var nextToken: Swift.String?
    /// Source server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        filters: MgnClientTypes.SourceServerActionsRequestFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sourceServerID = sourceServerID
    }
}

struct ListSourceServerActionsInputBody {
    let sourceServerID: Swift.String?
    let filters: MgnClientTypes.SourceServerActionsRequestFilters?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let accountID: Swift.String?
}

extension ListSourceServerActionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case filters
        case maxResults
        case nextToken
        case sourceServerID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceServerActionsRequestFilters.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension ListSourceServerActionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSourceServerActionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListSourceServerActionsOutput {
    /// List of source server post migration custom actions.
    public var items: [MgnClientTypes.SourceServerActionDocument]?
    /// Next token returned when listing source server post migration custom actions.
    public var nextToken: Swift.String?

    public init(
        items: [MgnClientTypes.SourceServerActionDocument]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListSourceServerActionsOutputBody {
    let items: [MgnClientTypes.SourceServerActionDocument]?
    let nextToken: Swift.String?
}

extension ListSourceServerActionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MgnClientTypes.SourceServerActionDocument?].self, forKey: .items)
        var itemsDecoded0:[MgnClientTypes.SourceServerActionDocument]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MgnClientTypes.SourceServerActionDocument]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSourceServerActionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput {
    /// List tags for resource request by ARN.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutput(tags: \"CONTENT_REDACTED\")"}
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput {
    /// List tags for resource response.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTemplateActionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case launchConfigurationTemplateID
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let launchConfigurationTemplateID = self.launchConfigurationTemplateID {
            try encodeContainer.encode(launchConfigurationTemplateID, forKey: .launchConfigurationTemplateID)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListTemplateActionsInput {

    static func urlPathProvider(_ value: ListTemplateActionsInput) -> Swift.String? {
        return "/ListTemplateActions"
    }
}

public struct ListTemplateActionsInput {
    /// Filters to apply when listing template post migration custom actions.
    public var filters: MgnClientTypes.TemplateActionsRequestFilters?
    /// Launch configuration template ID.
    /// This member is required.
    public var launchConfigurationTemplateID: Swift.String?
    /// Maximum amount of items to return when listing template post migration custom actions.
    public var maxResults: Swift.Int?
    /// Next token to use when listing template post migration custom actions.
    public var nextToken: Swift.String?

    public init(
        filters: MgnClientTypes.TemplateActionsRequestFilters? = nil,
        launchConfigurationTemplateID: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.launchConfigurationTemplateID = launchConfigurationTemplateID
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTemplateActionsInputBody {
    let launchConfigurationTemplateID: Swift.String?
    let filters: MgnClientTypes.TemplateActionsRequestFilters?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListTemplateActionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case launchConfigurationTemplateID
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchConfigurationTemplateID)
        launchConfigurationTemplateID = launchConfigurationTemplateIDDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(MgnClientTypes.TemplateActionsRequestFilters.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTemplateActionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTemplateActionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListTemplateActionsOutput {
    /// List of template post migration custom actions.
    public var items: [MgnClientTypes.TemplateActionDocument]?
    /// Next token returned when listing template post migration custom actions.
    public var nextToken: Swift.String?

    public init(
        items: [MgnClientTypes.TemplateActionDocument]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListTemplateActionsOutputBody {
    let items: [MgnClientTypes.TemplateActionDocument]?
    let nextToken: Swift.String?
}

extension ListTemplateActionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MgnClientTypes.TemplateActionDocument?].self, forKey: .items)
        var itemsDecoded0:[MgnClientTypes.TemplateActionDocument]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MgnClientTypes.TemplateActionDocument]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTemplateActionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWavesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListWavesInput {

    static func urlPathProvider(_ value: ListWavesInput) -> Swift.String? {
        return "/ListWaves"
    }
}

public struct ListWavesInput {
    /// Request account ID.
    public var accountID: Swift.String?
    /// Waves list filters.
    public var filters: MgnClientTypes.ListWavesRequestFilters?
    /// Maximum results to return when listing waves.
    public var maxResults: Swift.Int?
    /// Request next token.
    public var nextToken: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        filters: MgnClientTypes.ListWavesRequestFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWavesInputBody {
    let filters: MgnClientTypes.ListWavesRequestFilters?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let accountID: Swift.String?
}

extension ListWavesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ListWavesRequestFilters.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension ListWavesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWavesOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListWavesOutput {
    /// Waves list.
    public var items: [MgnClientTypes.Wave]?
    /// Response next token.
    public var nextToken: Swift.String?

    public init(
        items: [MgnClientTypes.Wave]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListWavesOutputBody {
    let items: [MgnClientTypes.Wave]?
    let nextToken: Swift.String?
}

extension ListWavesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MgnClientTypes.Wave?].self, forKey: .items)
        var itemsDecoded0:[MgnClientTypes.Wave]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MgnClientTypes.Wave]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListWavesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MgnClientTypes.ListWavesRequestFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isArchived
        case waveIDs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isArchived = self.isArchived {
            try encodeContainer.encode(isArchived, forKey: .isArchived)
        }
        if let waveIDs = waveIDs {
            var waveIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .waveIDs)
            for waveid0 in waveIDs {
                try waveIDsContainer.encode(waveid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let waveIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .waveIDs)
        var waveIDsDecoded0:[Swift.String]? = nil
        if let waveIDsContainer = waveIDsContainer {
            waveIDsDecoded0 = [Swift.String]()
            for string0 in waveIDsContainer {
                if let string0 = string0 {
                    waveIDsDecoded0?.append(string0)
                }
            }
        }
        waveIDs = waveIDsDecoded0
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
    }
}

extension MgnClientTypes {
    /// Waves list filters.
    public struct ListWavesRequestFilters {
        /// Filter waves list by archival status.
        public var isArchived: Swift.Bool?
        /// Filter waves list by wave ID.
        public var waveIDs: [Swift.String]?

        public init(
            isArchived: Swift.Bool? = nil,
            waveIDs: [Swift.String]? = nil
        )
        {
            self.isArchived = isArchived
            self.waveIDs = waveIDs
        }
    }

}

extension MgnClientTypes.ManagedAccount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension MgnClientTypes {
    /// Managed account.
    public struct ManagedAccount {
        /// Managed account, account ID.
        public var accountId: Swift.String?

        public init(
            accountId: Swift.String? = nil
        )
        {
            self.accountId = accountId
        }
    }

}

extension MarkAsArchivedInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension MarkAsArchivedInput {

    static func urlPathProvider(_ value: MarkAsArchivedInput) -> Swift.String? {
        return "/MarkAsArchived"
    }
}

public struct MarkAsArchivedInput {
    /// Mark as archived by Account ID.
    public var accountID: Swift.String?
    /// Mark as archived by Source Server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.sourceServerID = sourceServerID
    }
}

struct MarkAsArchivedInputBody {
    let sourceServerID: Swift.String?
    let accountID: Swift.String?
}

extension MarkAsArchivedInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case sourceServerID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension MarkAsArchivedOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MarkAsArchivedOutput(applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), connectorAction: \(Swift.String(describing: connectorAction)), dataReplicationInfo: \(Swift.String(describing: dataReplicationInfo)), fqdnForActionFramework: \(Swift.String(describing: fqdnForActionFramework)), isArchived: \(Swift.String(describing: isArchived)), launchedInstance: \(Swift.String(describing: launchedInstance)), lifeCycle: \(Swift.String(describing: lifeCycle)), replicationType: \(Swift.String(describing: replicationType)), sourceProperties: \(Swift.String(describing: sourceProperties)), sourceServerID: \(Swift.String(describing: sourceServerID)), userProvidedID: \(Swift.String(describing: userProvidedID)), vcenterClientID: \(Swift.String(describing: vcenterClientID)), tags: \"CONTENT_REDACTED\")"}
}

extension MarkAsArchivedOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MarkAsArchivedOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationID = output.applicationID
            self.arn = output.arn
            self.connectorAction = output.connectorAction
            self.dataReplicationInfo = output.dataReplicationInfo
            self.fqdnForActionFramework = output.fqdnForActionFramework
            self.isArchived = output.isArchived
            self.launchedInstance = output.launchedInstance
            self.lifeCycle = output.lifeCycle
            self.replicationType = output.replicationType
            self.sourceProperties = output.sourceProperties
            self.sourceServerID = output.sourceServerID
            self.tags = output.tags
            self.userProvidedID = output.userProvidedID
            self.vcenterClientID = output.vcenterClientID
        } else {
            self.applicationID = nil
            self.arn = nil
            self.connectorAction = nil
            self.dataReplicationInfo = nil
            self.fqdnForActionFramework = nil
            self.isArchived = nil
            self.launchedInstance = nil
            self.lifeCycle = nil
            self.replicationType = nil
            self.sourceProperties = nil
            self.sourceServerID = nil
            self.tags = nil
            self.userProvidedID = nil
            self.vcenterClientID = nil
        }
    }
}

public struct MarkAsArchivedOutput {
    /// Source server application ID.
    public var applicationID: Swift.String?
    /// Source server ARN.
    public var arn: Swift.String?
    /// Source Server connector action.
    public var connectorAction: MgnClientTypes.SourceServerConnectorAction?
    /// Source server data replication info.
    public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    /// Source server fqdn for action framework.
    public var fqdnForActionFramework: Swift.String?
    /// Source server archived status.
    public var isArchived: Swift.Bool?
    /// Source server launched instance.
    public var launchedInstance: MgnClientTypes.LaunchedInstance?
    /// Source server lifecycle state.
    public var lifeCycle: MgnClientTypes.LifeCycle?
    /// Source server replication type.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// Source server properties.
    public var sourceProperties: MgnClientTypes.SourceProperties?
    /// Source server ID.
    public var sourceServerID: Swift.String?
    /// Source server Tags.
    public var tags: [Swift.String:Swift.String]?
    /// Source server user provided ID.
    public var userProvidedID: Swift.String?
    /// Source server vCenter client id.
    public var vcenterClientID: Swift.String?

    public init(
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        connectorAction: MgnClientTypes.SourceServerConnectorAction? = nil,
        dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
        fqdnForActionFramework: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
        lifeCycle: MgnClientTypes.LifeCycle? = nil,
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceProperties: MgnClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        userProvidedID: Swift.String? = nil,
        vcenterClientID: Swift.String? = nil
    )
    {
        self.applicationID = applicationID
        self.arn = arn
        self.connectorAction = connectorAction
        self.dataReplicationInfo = dataReplicationInfo
        self.fqdnForActionFramework = fqdnForActionFramework
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.replicationType = replicationType
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
        self.userProvidedID = userProvidedID
        self.vcenterClientID = vcenterClientID
    }
}

struct MarkAsArchivedOutputBody {
    let sourceServerID: Swift.String?
    let arn: Swift.String?
    let isArchived: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
    let launchedInstance: MgnClientTypes.LaunchedInstance?
    let dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    let lifeCycle: MgnClientTypes.LifeCycle?
    let sourceProperties: MgnClientTypes.SourceProperties?
    let replicationType: MgnClientTypes.ReplicationType?
    let vcenterClientID: Swift.String?
    let applicationID: Swift.String?
    let userProvidedID: Swift.String?
    let fqdnForActionFramework: Swift.String?
    let connectorAction: MgnClientTypes.SourceServerConnectorAction?
}

extension MarkAsArchivedOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationID
        case arn
        case connectorAction
        case dataReplicationInfo
        case fqdnForActionFramework
        case isArchived
        case launchedInstance
        case lifeCycle
        case replicationType
        case sourceProperties
        case sourceServerID
        case tags
        case userProvidedID
        case vcenterClientID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let launchedInstanceDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchedInstance.self, forKey: .launchedInstance)
        launchedInstance = launchedInstanceDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
        let replicationTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationType.self, forKey: .replicationType)
        replicationType = replicationTypeDecoded
        let vcenterClientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcenterClientID)
        vcenterClientID = vcenterClientIDDecoded
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
        let userProvidedIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userProvidedID)
        userProvidedID = userProvidedIDDecoded
        let fqdnForActionFrameworkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fqdnForActionFramework)
        fqdnForActionFramework = fqdnForActionFrameworkDecoded
        let connectorActionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceServerConnectorAction.self, forKey: .connectorAction)
        connectorAction = connectorActionDecoded
    }
}

enum MarkAsArchivedOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

public enum MgnClientTypes {}

extension MgnClientTypes.NetworkInterface: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ips
        case isPrimary
        case macAddress
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ips = ips {
            var ipsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ips)
            for boundedstring0 in ips {
                try ipsContainer.encode(boundedstring0)
            }
        }
        if let isPrimary = self.isPrimary {
            try encodeContainer.encode(isPrimary, forKey: .isPrimary)
        }
        if let macAddress = self.macAddress {
            try encodeContainer.encode(macAddress, forKey: .macAddress)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let macAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .macAddress)
        macAddress = macAddressDecoded
        let ipsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ips)
        var ipsDecoded0:[Swift.String]? = nil
        if let ipsContainer = ipsContainer {
            ipsDecoded0 = [Swift.String]()
            for string0 in ipsContainer {
                if let string0 = string0 {
                    ipsDecoded0?.append(string0)
                }
            }
        }
        ips = ipsDecoded0
        let isPrimaryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isPrimary)
        isPrimary = isPrimaryDecoded
    }
}

extension MgnClientTypes {
    /// Network interface.
    public struct NetworkInterface {
        /// Network interface IPs.
        public var ips: [Swift.String]?
        /// Network interface primary IP.
        public var isPrimary: Swift.Bool?
        /// Network interface Mac address.
        public var macAddress: Swift.String?

        public init(
            ips: [Swift.String]? = nil,
            isPrimary: Swift.Bool? = nil,
            macAddress: Swift.String? = nil
        )
        {
            self.ips = ips
            self.isPrimary = isPrimary
            self.macAddress = macAddress
        }
    }

}

extension MgnClientTypes.OS: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fullString
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fullString = self.fullString {
            try encodeContainer.encode(fullString, forKey: .fullString)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fullStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fullString)
        fullString = fullStringDecoded
    }
}

extension MgnClientTypes {
    /// Operating System.
    public struct OS {
        /// OS full string.
        public var fullString: Swift.String?

        public init(
            fullString: Swift.String? = nil
        )
        {
            self.fullString = fullString
        }
    }

}

extension MgnClientTypes.ParticipatingServer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchStatus
        case launchedEc2InstanceID
        case postLaunchActionsStatus
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let launchStatus = self.launchStatus {
            try encodeContainer.encode(launchStatus.rawValue, forKey: .launchStatus)
        }
        if let launchedEc2InstanceID = self.launchedEc2InstanceID {
            try encodeContainer.encode(launchedEc2InstanceID, forKey: .launchedEc2InstanceID)
        }
        if let postLaunchActionsStatus = self.postLaunchActionsStatus {
            try encodeContainer.encode(postLaunchActionsStatus, forKey: .postLaunchActionsStatus)
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let launchStatusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchStatus.self, forKey: .launchStatus)
        launchStatus = launchStatusDecoded
        let launchedEc2InstanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchedEc2InstanceID)
        launchedEc2InstanceID = launchedEc2InstanceIDDecoded
        let postLaunchActionsStatusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.PostLaunchActionsStatus.self, forKey: .postLaunchActionsStatus)
        postLaunchActionsStatus = postLaunchActionsStatusDecoded
    }
}

extension MgnClientTypes {
    /// Server participating in Job.
    public struct ParticipatingServer {
        /// Participating server launch status.
        public var launchStatus: MgnClientTypes.LaunchStatus?
        /// Participating server's launched ec2 instance ID.
        public var launchedEc2InstanceID: Swift.String?
        /// Participating server's Post Launch Actions Status.
        public var postLaunchActionsStatus: MgnClientTypes.PostLaunchActionsStatus?
        /// Participating server Source Server ID.
        /// This member is required.
        public var sourceServerID: Swift.String?

        public init(
            launchStatus: MgnClientTypes.LaunchStatus? = nil,
            launchedEc2InstanceID: Swift.String? = nil,
            postLaunchActionsStatus: MgnClientTypes.PostLaunchActionsStatus? = nil,
            sourceServerID: Swift.String? = nil
        )
        {
            self.launchStatus = launchStatus
            self.launchedEc2InstanceID = launchedEc2InstanceID
            self.postLaunchActionsStatus = postLaunchActionsStatus
            self.sourceServerID = sourceServerID
        }
    }

}

extension PauseReplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension PauseReplicationInput {

    static func urlPathProvider(_ value: PauseReplicationInput) -> Swift.String? {
        return "/PauseReplication"
    }
}

public struct PauseReplicationInput {
    /// Pause Replication Request account ID.
    public var accountID: Swift.String?
    /// Pause Replication Request source server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.sourceServerID = sourceServerID
    }
}

struct PauseReplicationInputBody {
    let sourceServerID: Swift.String?
    let accountID: Swift.String?
}

extension PauseReplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case sourceServerID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension PauseReplicationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PauseReplicationOutput(applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), connectorAction: \(Swift.String(describing: connectorAction)), dataReplicationInfo: \(Swift.String(describing: dataReplicationInfo)), fqdnForActionFramework: \(Swift.String(describing: fqdnForActionFramework)), isArchived: \(Swift.String(describing: isArchived)), launchedInstance: \(Swift.String(describing: launchedInstance)), lifeCycle: \(Swift.String(describing: lifeCycle)), replicationType: \(Swift.String(describing: replicationType)), sourceProperties: \(Swift.String(describing: sourceProperties)), sourceServerID: \(Swift.String(describing: sourceServerID)), userProvidedID: \(Swift.String(describing: userProvidedID)), vcenterClientID: \(Swift.String(describing: vcenterClientID)), tags: \"CONTENT_REDACTED\")"}
}

extension PauseReplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PauseReplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationID = output.applicationID
            self.arn = output.arn
            self.connectorAction = output.connectorAction
            self.dataReplicationInfo = output.dataReplicationInfo
            self.fqdnForActionFramework = output.fqdnForActionFramework
            self.isArchived = output.isArchived
            self.launchedInstance = output.launchedInstance
            self.lifeCycle = output.lifeCycle
            self.replicationType = output.replicationType
            self.sourceProperties = output.sourceProperties
            self.sourceServerID = output.sourceServerID
            self.tags = output.tags
            self.userProvidedID = output.userProvidedID
            self.vcenterClientID = output.vcenterClientID
        } else {
            self.applicationID = nil
            self.arn = nil
            self.connectorAction = nil
            self.dataReplicationInfo = nil
            self.fqdnForActionFramework = nil
            self.isArchived = nil
            self.launchedInstance = nil
            self.lifeCycle = nil
            self.replicationType = nil
            self.sourceProperties = nil
            self.sourceServerID = nil
            self.tags = nil
            self.userProvidedID = nil
            self.vcenterClientID = nil
        }
    }
}

public struct PauseReplicationOutput {
    /// Source server application ID.
    public var applicationID: Swift.String?
    /// Source server ARN.
    public var arn: Swift.String?
    /// Source Server connector action.
    public var connectorAction: MgnClientTypes.SourceServerConnectorAction?
    /// Source server data replication info.
    public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    /// Source server fqdn for action framework.
    public var fqdnForActionFramework: Swift.String?
    /// Source server archived status.
    public var isArchived: Swift.Bool?
    /// Source server launched instance.
    public var launchedInstance: MgnClientTypes.LaunchedInstance?
    /// Source server lifecycle state.
    public var lifeCycle: MgnClientTypes.LifeCycle?
    /// Source server replication type.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// Source server properties.
    public var sourceProperties: MgnClientTypes.SourceProperties?
    /// Source server ID.
    public var sourceServerID: Swift.String?
    /// Source server Tags.
    public var tags: [Swift.String:Swift.String]?
    /// Source server user provided ID.
    public var userProvidedID: Swift.String?
    /// Source server vCenter client id.
    public var vcenterClientID: Swift.String?

    public init(
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        connectorAction: MgnClientTypes.SourceServerConnectorAction? = nil,
        dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
        fqdnForActionFramework: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
        lifeCycle: MgnClientTypes.LifeCycle? = nil,
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceProperties: MgnClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        userProvidedID: Swift.String? = nil,
        vcenterClientID: Swift.String? = nil
    )
    {
        self.applicationID = applicationID
        self.arn = arn
        self.connectorAction = connectorAction
        self.dataReplicationInfo = dataReplicationInfo
        self.fqdnForActionFramework = fqdnForActionFramework
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.replicationType = replicationType
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
        self.userProvidedID = userProvidedID
        self.vcenterClientID = vcenterClientID
    }
}

struct PauseReplicationOutputBody {
    let sourceServerID: Swift.String?
    let arn: Swift.String?
    let isArchived: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
    let launchedInstance: MgnClientTypes.LaunchedInstance?
    let dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    let lifeCycle: MgnClientTypes.LifeCycle?
    let sourceProperties: MgnClientTypes.SourceProperties?
    let replicationType: MgnClientTypes.ReplicationType?
    let vcenterClientID: Swift.String?
    let applicationID: Swift.String?
    let userProvidedID: Swift.String?
    let fqdnForActionFramework: Swift.String?
    let connectorAction: MgnClientTypes.SourceServerConnectorAction?
}

extension PauseReplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationID
        case arn
        case connectorAction
        case dataReplicationInfo
        case fqdnForActionFramework
        case isArchived
        case launchedInstance
        case lifeCycle
        case replicationType
        case sourceProperties
        case sourceServerID
        case tags
        case userProvidedID
        case vcenterClientID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let launchedInstanceDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchedInstance.self, forKey: .launchedInstance)
        launchedInstance = launchedInstanceDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
        let replicationTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationType.self, forKey: .replicationType)
        replicationType = replicationTypeDecoded
        let vcenterClientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcenterClientID)
        vcenterClientID = vcenterClientIDDecoded
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
        let userProvidedIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userProvidedID)
        userProvidedID = userProvidedIDDecoded
        let fqdnForActionFrameworkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fqdnForActionFramework)
        fqdnForActionFramework = fqdnForActionFrameworkDecoded
        let connectorActionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceServerConnectorAction.self, forKey: .connectorAction)
        connectorAction = connectorActionDecoded
    }
}

enum PauseReplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MgnClientTypes {
    public enum PostLaunchActionExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [PostLaunchActionExecutionStatus] {
            return [
                .failed,
                .inProgress,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PostLaunchActionExecutionStatus(rawValue: rawValue) ?? PostLaunchActionExecutionStatus.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes.PostLaunchActions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogGroupName
        case deployment
        case s3LogBucket
        case s3OutputKeyPrefix
        case ssmDocuments
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogGroupName = self.cloudWatchLogGroupName {
            try encodeContainer.encode(cloudWatchLogGroupName, forKey: .cloudWatchLogGroupName)
        }
        if let deployment = self.deployment {
            try encodeContainer.encode(deployment.rawValue, forKey: .deployment)
        }
        if let s3LogBucket = self.s3LogBucket {
            try encodeContainer.encode(s3LogBucket, forKey: .s3LogBucket)
        }
        if let s3OutputKeyPrefix = self.s3OutputKeyPrefix {
            try encodeContainer.encode(s3OutputKeyPrefix, forKey: .s3OutputKeyPrefix)
        }
        if let ssmDocuments = ssmDocuments {
            var ssmDocumentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ssmDocuments)
            for ssmdocument0 in ssmDocuments {
                try ssmDocumentsContainer.encode(ssmdocument0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentDecoded = try containerValues.decodeIfPresent(MgnClientTypes.PostLaunchActionsDeploymentType.self, forKey: .deployment)
        deployment = deploymentDecoded
        let s3LogBucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3LogBucket)
        s3LogBucket = s3LogBucketDecoded
        let s3OutputKeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3OutputKeyPrefix)
        s3OutputKeyPrefix = s3OutputKeyPrefixDecoded
        let cloudWatchLogGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogGroupName)
        cloudWatchLogGroupName = cloudWatchLogGroupNameDecoded
        let ssmDocumentsContainer = try containerValues.decodeIfPresent([MgnClientTypes.SsmDocument?].self, forKey: .ssmDocuments)
        var ssmDocumentsDecoded0:[MgnClientTypes.SsmDocument]? = nil
        if let ssmDocumentsContainer = ssmDocumentsContainer {
            ssmDocumentsDecoded0 = [MgnClientTypes.SsmDocument]()
            for structure0 in ssmDocumentsContainer {
                if let structure0 = structure0 {
                    ssmDocumentsDecoded0?.append(structure0)
                }
            }
        }
        ssmDocuments = ssmDocumentsDecoded0
    }
}

extension MgnClientTypes {
    /// Post Launch Actions to executed on the Test or Cutover instance.
    public struct PostLaunchActions {
        /// AWS Systems Manager Command's CloudWatch log group name.
        public var cloudWatchLogGroupName: Swift.String?
        /// Deployment type in which AWS Systems Manager Documents will be executed.
        public var deployment: MgnClientTypes.PostLaunchActionsDeploymentType?
        /// AWS Systems Manager Command's logs S3 log bucket.
        public var s3LogBucket: Swift.String?
        /// AWS Systems Manager Command's logs S3 output key prefix.
        public var s3OutputKeyPrefix: Swift.String?
        /// AWS Systems Manager Documents.
        public var ssmDocuments: [MgnClientTypes.SsmDocument]?

        public init(
            cloudWatchLogGroupName: Swift.String? = nil,
            deployment: MgnClientTypes.PostLaunchActionsDeploymentType? = nil,
            s3LogBucket: Swift.String? = nil,
            s3OutputKeyPrefix: Swift.String? = nil,
            ssmDocuments: [MgnClientTypes.SsmDocument]? = nil
        )
        {
            self.cloudWatchLogGroupName = cloudWatchLogGroupName
            self.deployment = deployment
            self.s3LogBucket = s3LogBucket
            self.s3OutputKeyPrefix = s3OutputKeyPrefix
            self.ssmDocuments = ssmDocuments
        }
    }

}

extension MgnClientTypes {
    public enum PostLaunchActionsDeploymentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cutoverOnly
        case testAndCutover
        case testOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [PostLaunchActionsDeploymentType] {
            return [
                .cutoverOnly,
                .testAndCutover,
                .testOnly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cutoverOnly: return "CUTOVER_ONLY"
            case .testAndCutover: return "TEST_AND_CUTOVER"
            case .testOnly: return "TEST_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PostLaunchActionsDeploymentType(rawValue: rawValue) ?? PostLaunchActionsDeploymentType.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes.PostLaunchActionsStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case postLaunchActionsLaunchStatusList
        case ssmAgentDiscoveryDatetime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let postLaunchActionsLaunchStatusList = postLaunchActionsLaunchStatusList {
            var postLaunchActionsLaunchStatusListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .postLaunchActionsLaunchStatusList)
            for jobpostlaunchactionslaunchstatus0 in postLaunchActionsLaunchStatusList {
                try postLaunchActionsLaunchStatusListContainer.encode(jobpostlaunchactionslaunchstatus0)
            }
        }
        if let ssmAgentDiscoveryDatetime = self.ssmAgentDiscoveryDatetime {
            try encodeContainer.encode(ssmAgentDiscoveryDatetime, forKey: .ssmAgentDiscoveryDatetime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ssmAgentDiscoveryDatetimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ssmAgentDiscoveryDatetime)
        ssmAgentDiscoveryDatetime = ssmAgentDiscoveryDatetimeDecoded
        let postLaunchActionsLaunchStatusListContainer = try containerValues.decodeIfPresent([MgnClientTypes.JobPostLaunchActionsLaunchStatus?].self, forKey: .postLaunchActionsLaunchStatusList)
        var postLaunchActionsLaunchStatusListDecoded0:[MgnClientTypes.JobPostLaunchActionsLaunchStatus]? = nil
        if let postLaunchActionsLaunchStatusListContainer = postLaunchActionsLaunchStatusListContainer {
            postLaunchActionsLaunchStatusListDecoded0 = [MgnClientTypes.JobPostLaunchActionsLaunchStatus]()
            for structure0 in postLaunchActionsLaunchStatusListContainer {
                if let structure0 = structure0 {
                    postLaunchActionsLaunchStatusListDecoded0?.append(structure0)
                }
            }
        }
        postLaunchActionsLaunchStatusList = postLaunchActionsLaunchStatusListDecoded0
    }
}

extension MgnClientTypes {
    /// Status of the Post Launch Actions running on the Test or Cutover instance.
    public struct PostLaunchActionsStatus {
        /// List of Post Launch Action status.
        public var postLaunchActionsLaunchStatusList: [MgnClientTypes.JobPostLaunchActionsLaunchStatus]?
        /// Time where the AWS Systems Manager was detected as running on the Test or Cutover instance.
        public var ssmAgentDiscoveryDatetime: Swift.String?

        public init(
            postLaunchActionsLaunchStatusList: [MgnClientTypes.JobPostLaunchActionsLaunchStatus]? = nil,
            ssmAgentDiscoveryDatetime: Swift.String? = nil
        )
        {
            self.postLaunchActionsLaunchStatusList = postLaunchActionsLaunchStatusList
            self.ssmAgentDiscoveryDatetime = ssmAgentDiscoveryDatetime
        }
    }

}

extension PutSourceServerActionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case actionID
        case actionName
        case active
        case category
        case description
        case documentIdentifier
        case documentVersion
        case externalParameters
        case mustSucceedForCutover
        case order
        case parameters
        case sourceServerID
        case timeoutSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let actionID = self.actionID {
            try encodeContainer.encode(actionID, forKey: .actionID)
        }
        if let actionName = self.actionName {
            try encodeContainer.encode(actionName, forKey: .actionName)
        }
        if let active = self.active {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let category = self.category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let documentIdentifier = self.documentIdentifier {
            try encodeContainer.encode(documentIdentifier, forKey: .documentIdentifier)
        }
        if let documentVersion = self.documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let externalParameters = externalParameters {
            var externalParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .externalParameters)
            for (dictKey0, ssmDocumentExternalParameters0) in externalParameters {
                try externalParametersContainer.encode(ssmDocumentExternalParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let mustSucceedForCutover = self.mustSucceedForCutover {
            try encodeContainer.encode(mustSucceedForCutover, forKey: .mustSucceedForCutover)
        }
        if let order = self.order {
            try encodeContainer.encode(order, forKey: .order)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, ssmDocumentParameters0) in parameters {
                var ssmDocumentParameters0Container = parametersContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for ssmparameterstoreparameter1 in ssmDocumentParameters0 {
                    try ssmDocumentParameters0Container.encode(ssmparameterstoreparameter1)
                }
            }
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
        if let timeoutSeconds = self.timeoutSeconds {
            try encodeContainer.encode(timeoutSeconds, forKey: .timeoutSeconds)
        }
    }
}

extension PutSourceServerActionInput {

    static func urlPathProvider(_ value: PutSourceServerActionInput) -> Swift.String? {
        return "/PutSourceServerAction"
    }
}

public struct PutSourceServerActionInput {
    /// Source server post migration custom account ID.
    public var accountID: Swift.String?
    /// Source server post migration custom action ID.
    /// This member is required.
    public var actionID: Swift.String?
    /// Source server post migration custom action name.
    /// This member is required.
    public var actionName: Swift.String?
    /// Source server post migration custom action active status.
    public var active: Swift.Bool?
    /// Source server post migration custom action category.
    public var category: MgnClientTypes.ActionCategory?
    /// Source server post migration custom action description.
    public var description: Swift.String?
    /// Source server post migration custom action document identifier.
    /// This member is required.
    public var documentIdentifier: Swift.String?
    /// Source server post migration custom action document version.
    public var documentVersion: Swift.String?
    /// Source server post migration custom action external parameters.
    public var externalParameters: [Swift.String:MgnClientTypes.SsmExternalParameter]?
    /// Source server post migration custom action must succeed for cutover.
    public var mustSucceedForCutover: Swift.Bool?
    /// Source server post migration custom action order.
    /// This member is required.
    public var order: Swift.Int?
    /// Source server post migration custom action parameters.
    public var parameters: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]?
    /// Source server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?
    /// Source server post migration custom action timeout in seconds.
    public var timeoutSeconds: Swift.Int?

    public init(
        accountID: Swift.String? = nil,
        actionID: Swift.String? = nil,
        actionName: Swift.String? = nil,
        active: Swift.Bool? = nil,
        category: MgnClientTypes.ActionCategory? = nil,
        description: Swift.String? = nil,
        documentIdentifier: Swift.String? = nil,
        documentVersion: Swift.String? = nil,
        externalParameters: [Swift.String:MgnClientTypes.SsmExternalParameter]? = nil,
        mustSucceedForCutover: Swift.Bool? = nil,
        order: Swift.Int? = nil,
        parameters: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]? = nil,
        sourceServerID: Swift.String? = nil,
        timeoutSeconds: Swift.Int? = nil
    )
    {
        self.accountID = accountID
        self.actionID = actionID
        self.actionName = actionName
        self.active = active
        self.category = category
        self.description = description
        self.documentIdentifier = documentIdentifier
        self.documentVersion = documentVersion
        self.externalParameters = externalParameters
        self.mustSucceedForCutover = mustSucceedForCutover
        self.order = order
        self.parameters = parameters
        self.sourceServerID = sourceServerID
        self.timeoutSeconds = timeoutSeconds
    }
}

struct PutSourceServerActionInputBody {
    let sourceServerID: Swift.String?
    let actionName: Swift.String?
    let documentIdentifier: Swift.String?
    let order: Swift.Int?
    let actionID: Swift.String?
    let documentVersion: Swift.String?
    let active: Swift.Bool?
    let timeoutSeconds: Swift.Int?
    let mustSucceedForCutover: Swift.Bool?
    let parameters: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]?
    let externalParameters: [Swift.String:MgnClientTypes.SsmExternalParameter]?
    let description: Swift.String?
    let category: MgnClientTypes.ActionCategory?
    let accountID: Swift.String?
}

extension PutSourceServerActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case actionID
        case actionName
        case active
        case category
        case description
        case documentIdentifier
        case documentVersion
        case externalParameters
        case mustSucceedForCutover
        case order
        case parameters
        case sourceServerID
        case timeoutSeconds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let actionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let documentIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentIdentifier)
        documentIdentifier = documentIdentifierDecoded
        let orderDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .order)
        order = orderDecoded
        let actionIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionID)
        actionID = actionIDDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .active)
        active = activeDecoded
        let timeoutSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutSeconds)
        timeoutSeconds = timeoutSecondsDecoded
        let mustSucceedForCutoverDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .mustSucceedForCutover)
        mustSucceedForCutover = mustSucceedForCutoverDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [MgnClientTypes.SsmParameterStoreParameter?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]()
            for (key0, ssmparameterstoreparameters0) in parametersContainer {
                var ssmparameterstoreparameters0Decoded0: [MgnClientTypes.SsmParameterStoreParameter]? = nil
                if let ssmparameterstoreparameters0 = ssmparameterstoreparameters0 {
                    ssmparameterstoreparameters0Decoded0 = [MgnClientTypes.SsmParameterStoreParameter]()
                    for structure1 in ssmparameterstoreparameters0 {
                        if let structure1 = structure1 {
                            ssmparameterstoreparameters0Decoded0?.append(structure1)
                        }
                    }
                }
                parametersDecoded0?[key0] = ssmparameterstoreparameters0Decoded0
            }
        }
        parameters = parametersDecoded0
        let externalParametersContainer = try containerValues.decodeIfPresent([Swift.String: MgnClientTypes.SsmExternalParameter?].self, forKey: .externalParameters)
        var externalParametersDecoded0: [Swift.String:MgnClientTypes.SsmExternalParameter]? = nil
        if let externalParametersContainer = externalParametersContainer {
            externalParametersDecoded0 = [Swift.String:MgnClientTypes.SsmExternalParameter]()
            for (key0, ssmexternalparameter0) in externalParametersContainer {
                if let ssmexternalparameter0 = ssmexternalparameter0 {
                    externalParametersDecoded0?[key0] = ssmexternalparameter0
                }
            }
        }
        externalParameters = externalParametersDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ActionCategory.self, forKey: .category)
        category = categoryDecoded
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension PutSourceServerActionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutSourceServerActionOutputBody = try responseDecoder.decode(responseBody: data)
            self.actionID = output.actionID
            self.actionName = output.actionName
            self.active = output.active
            self.category = output.category
            self.description = output.description
            self.documentIdentifier = output.documentIdentifier
            self.documentVersion = output.documentVersion
            self.externalParameters = output.externalParameters
            self.mustSucceedForCutover = output.mustSucceedForCutover
            self.order = output.order
            self.parameters = output.parameters
            self.timeoutSeconds = output.timeoutSeconds
        } else {
            self.actionID = nil
            self.actionName = nil
            self.active = nil
            self.category = nil
            self.description = nil
            self.documentIdentifier = nil
            self.documentVersion = nil
            self.externalParameters = nil
            self.mustSucceedForCutover = nil
            self.order = nil
            self.parameters = nil
            self.timeoutSeconds = nil
        }
    }
}

public struct PutSourceServerActionOutput {
    /// Source server post migration custom action ID.
    public var actionID: Swift.String?
    /// Source server post migration custom action name.
    public var actionName: Swift.String?
    /// Source server post migration custom action active status.
    public var active: Swift.Bool?
    /// Source server post migration custom action category.
    public var category: MgnClientTypes.ActionCategory?
    /// Source server post migration custom action description.
    public var description: Swift.String?
    /// Source server post migration custom action document identifier.
    public var documentIdentifier: Swift.String?
    /// Source server post migration custom action document version.
    public var documentVersion: Swift.String?
    /// Source server post migration custom action external parameters.
    public var externalParameters: [Swift.String:MgnClientTypes.SsmExternalParameter]?
    /// Source server post migration custom action must succeed for cutover.
    public var mustSucceedForCutover: Swift.Bool?
    /// Source server post migration custom action order.
    public var order: Swift.Int?
    /// Source server post migration custom action parameters.
    public var parameters: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]?
    /// Source server post migration custom action timeout in seconds.
    public var timeoutSeconds: Swift.Int?

    public init(
        actionID: Swift.String? = nil,
        actionName: Swift.String? = nil,
        active: Swift.Bool? = nil,
        category: MgnClientTypes.ActionCategory? = nil,
        description: Swift.String? = nil,
        documentIdentifier: Swift.String? = nil,
        documentVersion: Swift.String? = nil,
        externalParameters: [Swift.String:MgnClientTypes.SsmExternalParameter]? = nil,
        mustSucceedForCutover: Swift.Bool? = nil,
        order: Swift.Int? = nil,
        parameters: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]? = nil,
        timeoutSeconds: Swift.Int? = nil
    )
    {
        self.actionID = actionID
        self.actionName = actionName
        self.active = active
        self.category = category
        self.description = description
        self.documentIdentifier = documentIdentifier
        self.documentVersion = documentVersion
        self.externalParameters = externalParameters
        self.mustSucceedForCutover = mustSucceedForCutover
        self.order = order
        self.parameters = parameters
        self.timeoutSeconds = timeoutSeconds
    }
}

struct PutSourceServerActionOutputBody {
    let actionID: Swift.String?
    let actionName: Swift.String?
    let documentIdentifier: Swift.String?
    let order: Swift.Int?
    let documentVersion: Swift.String?
    let active: Swift.Bool?
    let timeoutSeconds: Swift.Int?
    let mustSucceedForCutover: Swift.Bool?
    let parameters: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]?
    let externalParameters: [Swift.String:MgnClientTypes.SsmExternalParameter]?
    let description: Swift.String?
    let category: MgnClientTypes.ActionCategory?
}

extension PutSourceServerActionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionID
        case actionName
        case active
        case category
        case description
        case documentIdentifier
        case documentVersion
        case externalParameters
        case mustSucceedForCutover
        case order
        case parameters
        case timeoutSeconds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionID)
        actionID = actionIDDecoded
        let actionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let documentIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentIdentifier)
        documentIdentifier = documentIdentifierDecoded
        let orderDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .order)
        order = orderDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .active)
        active = activeDecoded
        let timeoutSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutSeconds)
        timeoutSeconds = timeoutSecondsDecoded
        let mustSucceedForCutoverDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .mustSucceedForCutover)
        mustSucceedForCutover = mustSucceedForCutoverDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [MgnClientTypes.SsmParameterStoreParameter?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]()
            for (key0, ssmparameterstoreparameters0) in parametersContainer {
                var ssmparameterstoreparameters0Decoded0: [MgnClientTypes.SsmParameterStoreParameter]? = nil
                if let ssmparameterstoreparameters0 = ssmparameterstoreparameters0 {
                    ssmparameterstoreparameters0Decoded0 = [MgnClientTypes.SsmParameterStoreParameter]()
                    for structure1 in ssmparameterstoreparameters0 {
                        if let structure1 = structure1 {
                            ssmparameterstoreparameters0Decoded0?.append(structure1)
                        }
                    }
                }
                parametersDecoded0?[key0] = ssmparameterstoreparameters0Decoded0
            }
        }
        parameters = parametersDecoded0
        let externalParametersContainer = try containerValues.decodeIfPresent([Swift.String: MgnClientTypes.SsmExternalParameter?].self, forKey: .externalParameters)
        var externalParametersDecoded0: [Swift.String:MgnClientTypes.SsmExternalParameter]? = nil
        if let externalParametersContainer = externalParametersContainer {
            externalParametersDecoded0 = [Swift.String:MgnClientTypes.SsmExternalParameter]()
            for (key0, ssmexternalparameter0) in externalParametersContainer {
                if let ssmexternalparameter0 = ssmexternalparameter0 {
                    externalParametersDecoded0?[key0] = ssmexternalparameter0
                }
            }
        }
        externalParameters = externalParametersDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ActionCategory.self, forKey: .category)
        category = categoryDecoded
    }
}

enum PutSourceServerActionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutTemplateActionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionID
        case actionName
        case active
        case category
        case description
        case documentIdentifier
        case documentVersion
        case externalParameters
        case launchConfigurationTemplateID
        case mustSucceedForCutover
        case operatingSystem
        case order
        case parameters
        case timeoutSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionID = self.actionID {
            try encodeContainer.encode(actionID, forKey: .actionID)
        }
        if let actionName = self.actionName {
            try encodeContainer.encode(actionName, forKey: .actionName)
        }
        if let active = self.active {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let category = self.category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let documentIdentifier = self.documentIdentifier {
            try encodeContainer.encode(documentIdentifier, forKey: .documentIdentifier)
        }
        if let documentVersion = self.documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let externalParameters = externalParameters {
            var externalParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .externalParameters)
            for (dictKey0, ssmDocumentExternalParameters0) in externalParameters {
                try externalParametersContainer.encode(ssmDocumentExternalParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let launchConfigurationTemplateID = self.launchConfigurationTemplateID {
            try encodeContainer.encode(launchConfigurationTemplateID, forKey: .launchConfigurationTemplateID)
        }
        if let mustSucceedForCutover = self.mustSucceedForCutover {
            try encodeContainer.encode(mustSucceedForCutover, forKey: .mustSucceedForCutover)
        }
        if let operatingSystem = self.operatingSystem {
            try encodeContainer.encode(operatingSystem, forKey: .operatingSystem)
        }
        if let order = self.order {
            try encodeContainer.encode(order, forKey: .order)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, ssmDocumentParameters0) in parameters {
                var ssmDocumentParameters0Container = parametersContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for ssmparameterstoreparameter1 in ssmDocumentParameters0 {
                    try ssmDocumentParameters0Container.encode(ssmparameterstoreparameter1)
                }
            }
        }
        if let timeoutSeconds = self.timeoutSeconds {
            try encodeContainer.encode(timeoutSeconds, forKey: .timeoutSeconds)
        }
    }
}

extension PutTemplateActionInput {

    static func urlPathProvider(_ value: PutTemplateActionInput) -> Swift.String? {
        return "/PutTemplateAction"
    }
}

public struct PutTemplateActionInput {
    /// Template post migration custom action ID.
    /// This member is required.
    public var actionID: Swift.String?
    /// Template post migration custom action name.
    /// This member is required.
    public var actionName: Swift.String?
    /// Template post migration custom action active status.
    public var active: Swift.Bool?
    /// Template post migration custom action category.
    public var category: MgnClientTypes.ActionCategory?
    /// Template post migration custom action description.
    public var description: Swift.String?
    /// Template post migration custom action document identifier.
    /// This member is required.
    public var documentIdentifier: Swift.String?
    /// Template post migration custom action document version.
    public var documentVersion: Swift.String?
    /// Template post migration custom action external parameters.
    public var externalParameters: [Swift.String:MgnClientTypes.SsmExternalParameter]?
    /// Launch configuration template ID.
    /// This member is required.
    public var launchConfigurationTemplateID: Swift.String?
    /// Template post migration custom action must succeed for cutover.
    public var mustSucceedForCutover: Swift.Bool?
    /// Operating system eligible for this template post migration custom action.
    public var operatingSystem: Swift.String?
    /// Template post migration custom action order.
    /// This member is required.
    public var order: Swift.Int?
    /// Template post migration custom action parameters.
    public var parameters: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]?
    /// Template post migration custom action timeout in seconds.
    public var timeoutSeconds: Swift.Int?

    public init(
        actionID: Swift.String? = nil,
        actionName: Swift.String? = nil,
        active: Swift.Bool? = nil,
        category: MgnClientTypes.ActionCategory? = nil,
        description: Swift.String? = nil,
        documentIdentifier: Swift.String? = nil,
        documentVersion: Swift.String? = nil,
        externalParameters: [Swift.String:MgnClientTypes.SsmExternalParameter]? = nil,
        launchConfigurationTemplateID: Swift.String? = nil,
        mustSucceedForCutover: Swift.Bool? = nil,
        operatingSystem: Swift.String? = nil,
        order: Swift.Int? = nil,
        parameters: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]? = nil,
        timeoutSeconds: Swift.Int? = nil
    )
    {
        self.actionID = actionID
        self.actionName = actionName
        self.active = active
        self.category = category
        self.description = description
        self.documentIdentifier = documentIdentifier
        self.documentVersion = documentVersion
        self.externalParameters = externalParameters
        self.launchConfigurationTemplateID = launchConfigurationTemplateID
        self.mustSucceedForCutover = mustSucceedForCutover
        self.operatingSystem = operatingSystem
        self.order = order
        self.parameters = parameters
        self.timeoutSeconds = timeoutSeconds
    }
}

struct PutTemplateActionInputBody {
    let launchConfigurationTemplateID: Swift.String?
    let actionName: Swift.String?
    let documentIdentifier: Swift.String?
    let order: Swift.Int?
    let actionID: Swift.String?
    let documentVersion: Swift.String?
    let active: Swift.Bool?
    let timeoutSeconds: Swift.Int?
    let mustSucceedForCutover: Swift.Bool?
    let parameters: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]?
    let operatingSystem: Swift.String?
    let externalParameters: [Swift.String:MgnClientTypes.SsmExternalParameter]?
    let description: Swift.String?
    let category: MgnClientTypes.ActionCategory?
}

extension PutTemplateActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionID
        case actionName
        case active
        case category
        case description
        case documentIdentifier
        case documentVersion
        case externalParameters
        case launchConfigurationTemplateID
        case mustSucceedForCutover
        case operatingSystem
        case order
        case parameters
        case timeoutSeconds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchConfigurationTemplateID)
        launchConfigurationTemplateID = launchConfigurationTemplateIDDecoded
        let actionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let documentIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentIdentifier)
        documentIdentifier = documentIdentifierDecoded
        let orderDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .order)
        order = orderDecoded
        let actionIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionID)
        actionID = actionIDDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .active)
        active = activeDecoded
        let timeoutSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutSeconds)
        timeoutSeconds = timeoutSecondsDecoded
        let mustSucceedForCutoverDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .mustSucceedForCutover)
        mustSucceedForCutover = mustSucceedForCutoverDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [MgnClientTypes.SsmParameterStoreParameter?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]()
            for (key0, ssmparameterstoreparameters0) in parametersContainer {
                var ssmparameterstoreparameters0Decoded0: [MgnClientTypes.SsmParameterStoreParameter]? = nil
                if let ssmparameterstoreparameters0 = ssmparameterstoreparameters0 {
                    ssmparameterstoreparameters0Decoded0 = [MgnClientTypes.SsmParameterStoreParameter]()
                    for structure1 in ssmparameterstoreparameters0 {
                        if let structure1 = structure1 {
                            ssmparameterstoreparameters0Decoded0?.append(structure1)
                        }
                    }
                }
                parametersDecoded0?[key0] = ssmparameterstoreparameters0Decoded0
            }
        }
        parameters = parametersDecoded0
        let operatingSystemDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
        let externalParametersContainer = try containerValues.decodeIfPresent([Swift.String: MgnClientTypes.SsmExternalParameter?].self, forKey: .externalParameters)
        var externalParametersDecoded0: [Swift.String:MgnClientTypes.SsmExternalParameter]? = nil
        if let externalParametersContainer = externalParametersContainer {
            externalParametersDecoded0 = [Swift.String:MgnClientTypes.SsmExternalParameter]()
            for (key0, ssmexternalparameter0) in externalParametersContainer {
                if let ssmexternalparameter0 = ssmexternalparameter0 {
                    externalParametersDecoded0?[key0] = ssmexternalparameter0
                }
            }
        }
        externalParameters = externalParametersDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ActionCategory.self, forKey: .category)
        category = categoryDecoded
    }
}

extension PutTemplateActionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutTemplateActionOutputBody = try responseDecoder.decode(responseBody: data)
            self.actionID = output.actionID
            self.actionName = output.actionName
            self.active = output.active
            self.category = output.category
            self.description = output.description
            self.documentIdentifier = output.documentIdentifier
            self.documentVersion = output.documentVersion
            self.externalParameters = output.externalParameters
            self.mustSucceedForCutover = output.mustSucceedForCutover
            self.operatingSystem = output.operatingSystem
            self.order = output.order
            self.parameters = output.parameters
            self.timeoutSeconds = output.timeoutSeconds
        } else {
            self.actionID = nil
            self.actionName = nil
            self.active = nil
            self.category = nil
            self.description = nil
            self.documentIdentifier = nil
            self.documentVersion = nil
            self.externalParameters = nil
            self.mustSucceedForCutover = nil
            self.operatingSystem = nil
            self.order = nil
            self.parameters = nil
            self.timeoutSeconds = nil
        }
    }
}

public struct PutTemplateActionOutput {
    /// Template post migration custom action ID.
    public var actionID: Swift.String?
    /// Template post migration custom action name.
    public var actionName: Swift.String?
    /// Template post migration custom action active status.
    public var active: Swift.Bool?
    /// Template post migration custom action category.
    public var category: MgnClientTypes.ActionCategory?
    /// Template post migration custom action description.
    public var description: Swift.String?
    /// Template post migration custom action document identifier.
    public var documentIdentifier: Swift.String?
    /// Template post migration custom action document version.
    public var documentVersion: Swift.String?
    /// Template post migration custom action external parameters.
    public var externalParameters: [Swift.String:MgnClientTypes.SsmExternalParameter]?
    /// Template post migration custom action must succeed for cutover.
    public var mustSucceedForCutover: Swift.Bool?
    /// Operating system eligible for this template post migration custom action.
    public var operatingSystem: Swift.String?
    /// Template post migration custom action order.
    public var order: Swift.Int?
    /// Template post migration custom action parameters.
    public var parameters: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]?
    /// Template post migration custom action timeout in seconds.
    public var timeoutSeconds: Swift.Int?

    public init(
        actionID: Swift.String? = nil,
        actionName: Swift.String? = nil,
        active: Swift.Bool? = nil,
        category: MgnClientTypes.ActionCategory? = nil,
        description: Swift.String? = nil,
        documentIdentifier: Swift.String? = nil,
        documentVersion: Swift.String? = nil,
        externalParameters: [Swift.String:MgnClientTypes.SsmExternalParameter]? = nil,
        mustSucceedForCutover: Swift.Bool? = nil,
        operatingSystem: Swift.String? = nil,
        order: Swift.Int? = nil,
        parameters: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]? = nil,
        timeoutSeconds: Swift.Int? = nil
    )
    {
        self.actionID = actionID
        self.actionName = actionName
        self.active = active
        self.category = category
        self.description = description
        self.documentIdentifier = documentIdentifier
        self.documentVersion = documentVersion
        self.externalParameters = externalParameters
        self.mustSucceedForCutover = mustSucceedForCutover
        self.operatingSystem = operatingSystem
        self.order = order
        self.parameters = parameters
        self.timeoutSeconds = timeoutSeconds
    }
}

struct PutTemplateActionOutputBody {
    let actionID: Swift.String?
    let actionName: Swift.String?
    let documentIdentifier: Swift.String?
    let order: Swift.Int?
    let documentVersion: Swift.String?
    let active: Swift.Bool?
    let timeoutSeconds: Swift.Int?
    let mustSucceedForCutover: Swift.Bool?
    let parameters: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]?
    let operatingSystem: Swift.String?
    let externalParameters: [Swift.String:MgnClientTypes.SsmExternalParameter]?
    let description: Swift.String?
    let category: MgnClientTypes.ActionCategory?
}

extension PutTemplateActionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionID
        case actionName
        case active
        case category
        case description
        case documentIdentifier
        case documentVersion
        case externalParameters
        case mustSucceedForCutover
        case operatingSystem
        case order
        case parameters
        case timeoutSeconds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionID)
        actionID = actionIDDecoded
        let actionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let documentIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentIdentifier)
        documentIdentifier = documentIdentifierDecoded
        let orderDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .order)
        order = orderDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .active)
        active = activeDecoded
        let timeoutSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutSeconds)
        timeoutSeconds = timeoutSecondsDecoded
        let mustSucceedForCutoverDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .mustSucceedForCutover)
        mustSucceedForCutover = mustSucceedForCutoverDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [MgnClientTypes.SsmParameterStoreParameter?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]()
            for (key0, ssmparameterstoreparameters0) in parametersContainer {
                var ssmparameterstoreparameters0Decoded0: [MgnClientTypes.SsmParameterStoreParameter]? = nil
                if let ssmparameterstoreparameters0 = ssmparameterstoreparameters0 {
                    ssmparameterstoreparameters0Decoded0 = [MgnClientTypes.SsmParameterStoreParameter]()
                    for structure1 in ssmparameterstoreparameters0 {
                        if let structure1 = structure1 {
                            ssmparameterstoreparameters0Decoded0?.append(structure1)
                        }
                    }
                }
                parametersDecoded0?[key0] = ssmparameterstoreparameters0Decoded0
            }
        }
        parameters = parametersDecoded0
        let operatingSystemDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
        let externalParametersContainer = try containerValues.decodeIfPresent([Swift.String: MgnClientTypes.SsmExternalParameter?].self, forKey: .externalParameters)
        var externalParametersDecoded0: [Swift.String:MgnClientTypes.SsmExternalParameter]? = nil
        if let externalParametersContainer = externalParametersContainer {
            externalParametersDecoded0 = [Swift.String:MgnClientTypes.SsmExternalParameter]()
            for (key0, ssmexternalparameter0) in externalParametersContainer {
                if let ssmexternalparameter0 = ssmexternalparameter0 {
                    externalParametersDecoded0?[key0] = ssmexternalparameter0
                }
            }
        }
        externalParameters = externalParametersDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ActionCategory.self, forKey: .category)
        category = categoryDecoded
    }
}

enum PutTemplateActionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RemoveSourceServerActionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case actionID
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let actionID = self.actionID {
            try encodeContainer.encode(actionID, forKey: .actionID)
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension RemoveSourceServerActionInput {

    static func urlPathProvider(_ value: RemoveSourceServerActionInput) -> Swift.String? {
        return "/RemoveSourceServerAction"
    }
}

public struct RemoveSourceServerActionInput {
    /// Source server post migration account ID.
    public var accountID: Swift.String?
    /// Source server post migration custom action ID to remove.
    /// This member is required.
    public var actionID: Swift.String?
    /// Source server ID of the post migration custom action to remove.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        actionID: Swift.String? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.actionID = actionID
        self.sourceServerID = sourceServerID
    }
}

struct RemoveSourceServerActionInputBody {
    let sourceServerID: Swift.String?
    let actionID: Swift.String?
    let accountID: Swift.String?
}

extension RemoveSourceServerActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case actionID
        case sourceServerID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let actionIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionID)
        actionID = actionIDDecoded
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension RemoveSourceServerActionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RemoveSourceServerActionOutput {

    public init() { }
}

enum RemoveSourceServerActionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RemoveTemplateActionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionID
        case launchConfigurationTemplateID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionID = self.actionID {
            try encodeContainer.encode(actionID, forKey: .actionID)
        }
        if let launchConfigurationTemplateID = self.launchConfigurationTemplateID {
            try encodeContainer.encode(launchConfigurationTemplateID, forKey: .launchConfigurationTemplateID)
        }
    }
}

extension RemoveTemplateActionInput {

    static func urlPathProvider(_ value: RemoveTemplateActionInput) -> Swift.String? {
        return "/RemoveTemplateAction"
    }
}

public struct RemoveTemplateActionInput {
    /// Template post migration custom action ID to remove.
    /// This member is required.
    public var actionID: Swift.String?
    /// Launch configuration template ID of the post migration custom action to remove.
    /// This member is required.
    public var launchConfigurationTemplateID: Swift.String?

    public init(
        actionID: Swift.String? = nil,
        launchConfigurationTemplateID: Swift.String? = nil
    )
    {
        self.actionID = actionID
        self.launchConfigurationTemplateID = launchConfigurationTemplateID
    }
}

struct RemoveTemplateActionInputBody {
    let launchConfigurationTemplateID: Swift.String?
    let actionID: Swift.String?
}

extension RemoveTemplateActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionID
        case launchConfigurationTemplateID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchConfigurationTemplateID)
        launchConfigurationTemplateID = launchConfigurationTemplateIDDecoded
        let actionIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionID)
        actionID = actionIDDecoded
    }
}

extension RemoveTemplateActionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RemoveTemplateActionOutput {

    public init() { }
}

enum RemoveTemplateActionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MgnClientTypes {
    public enum ReplicationConfigurationDataPlaneRouting: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case privateIp
        case publicIp
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationConfigurationDataPlaneRouting] {
            return [
                .privateIp,
                .publicIp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .privateIp: return "PRIVATE_IP"
            case .publicIp: return "PUBLIC_IP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationConfigurationDataPlaneRouting(rawValue: rawValue) ?? ReplicationConfigurationDataPlaneRouting.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes {
    public enum ReplicationConfigurationDefaultLargeStagingDiskType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gp2
        case gp3
        case st1
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationConfigurationDefaultLargeStagingDiskType] {
            return [
                .gp2,
                .gp3,
                .st1,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gp2: return "GP2"
            case .gp3: return "GP3"
            case .st1: return "ST1"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationConfigurationDefaultLargeStagingDiskType(rawValue: rawValue) ?? ReplicationConfigurationDefaultLargeStagingDiskType.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes {
    public enum ReplicationConfigurationEbsEncryption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case `default`
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationConfigurationEbsEncryption] {
            return [
                .custom,
                .default,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "CUSTOM"
            case .default: return "DEFAULT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationConfigurationEbsEncryption(rawValue: rawValue) ?? ReplicationConfigurationEbsEncryption.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes.ReplicationConfigurationReplicatedDisk: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceName
        case iops
        case isBootDisk
        case stagingDiskType
        case throughput
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceName = self.deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if iops != 0 {
            try encodeContainer.encode(iops, forKey: .iops)
        }
        if let isBootDisk = self.isBootDisk {
            try encodeContainer.encode(isBootDisk, forKey: .isBootDisk)
        }
        if let stagingDiskType = self.stagingDiskType {
            try encodeContainer.encode(stagingDiskType.rawValue, forKey: .stagingDiskType)
        }
        if throughput != 0 {
            try encodeContainer.encode(throughput, forKey: .throughput)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let isBootDiskDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isBootDisk)
        isBootDisk = isBootDiskDecoded
        let stagingDiskTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationReplicatedDiskStagingDiskType.self, forKey: .stagingDiskType)
        stagingDiskType = stagingDiskTypeDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops) ?? 0
        iops = iopsDecoded
        let throughputDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .throughput) ?? 0
        throughput = throughputDecoded
    }
}

extension MgnClientTypes {
    /// Replication Configuration replicated disk.
    public struct ReplicationConfigurationReplicatedDisk {
        /// Replication Configuration replicated disk device name.
        public var deviceName: Swift.String?
        /// Replication Configuration replicated disk IOPs.
        public var iops: Swift.Int
        /// Replication Configuration replicated disk boot disk.
        public var isBootDisk: Swift.Bool?
        /// Replication Configuration replicated disk staging disk type.
        public var stagingDiskType: MgnClientTypes.ReplicationConfigurationReplicatedDiskStagingDiskType?
        /// Replication Configuration replicated disk throughput.
        public var throughput: Swift.Int

        public init(
            deviceName: Swift.String? = nil,
            iops: Swift.Int = 0,
            isBootDisk: Swift.Bool? = nil,
            stagingDiskType: MgnClientTypes.ReplicationConfigurationReplicatedDiskStagingDiskType? = nil,
            throughput: Swift.Int = 0
        )
        {
            self.deviceName = deviceName
            self.iops = iops
            self.isBootDisk = isBootDisk
            self.stagingDiskType = stagingDiskType
            self.throughput = throughput
        }
    }

}

extension MgnClientTypes {
    public enum ReplicationConfigurationReplicatedDiskStagingDiskType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case auto
        case gp2
        case gp3
        case io1
        case io2
        case sc1
        case st1
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationConfigurationReplicatedDiskStagingDiskType] {
            return [
                .auto,
                .gp2,
                .gp3,
                .io1,
                .io2,
                .sc1,
                .st1,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTO"
            case .gp2: return "GP2"
            case .gp3: return "GP3"
            case .io1: return "IO1"
            case .io2: return "IO2"
            case .sc1: return "SC1"
            case .st1: return "ST1"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationConfigurationReplicatedDiskStagingDiskType(rawValue: rawValue) ?? ReplicationConfigurationReplicatedDiskStagingDiskType.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes.ReplicationConfigurationTemplate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case replicationConfigurationTemplateID
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case tags
        case useDedicatedReplicationServer
        case useFipsEndpoint
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let associateDefaultSecurityGroup = self.associateDefaultSecurityGroup {
            try encodeContainer.encode(associateDefaultSecurityGroup, forKey: .associateDefaultSecurityGroup)
        }
        if bandwidthThrottling != 0 {
            try encodeContainer.encode(bandwidthThrottling, forKey: .bandwidthThrottling)
        }
        if let createPublicIP = self.createPublicIP {
            try encodeContainer.encode(createPublicIP, forKey: .createPublicIP)
        }
        if let dataPlaneRouting = self.dataPlaneRouting {
            try encodeContainer.encode(dataPlaneRouting.rawValue, forKey: .dataPlaneRouting)
        }
        if let defaultLargeStagingDiskType = self.defaultLargeStagingDiskType {
            try encodeContainer.encode(defaultLargeStagingDiskType.rawValue, forKey: .defaultLargeStagingDiskType)
        }
        if let ebsEncryption = self.ebsEncryption {
            try encodeContainer.encode(ebsEncryption.rawValue, forKey: .ebsEncryption)
        }
        if let ebsEncryptionKeyArn = self.ebsEncryptionKeyArn {
            try encodeContainer.encode(ebsEncryptionKeyArn, forKey: .ebsEncryptionKeyArn)
        }
        if let replicationConfigurationTemplateID = self.replicationConfigurationTemplateID {
            try encodeContainer.encode(replicationConfigurationTemplateID, forKey: .replicationConfigurationTemplateID)
        }
        if let replicationServerInstanceType = self.replicationServerInstanceType {
            try encodeContainer.encode(replicationServerInstanceType, forKey: .replicationServerInstanceType)
        }
        if let replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs {
            var replicationServersSecurityGroupsIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationServersSecurityGroupsIDs)
            for securitygroupid0 in replicationServersSecurityGroupsIDs {
                try replicationServersSecurityGroupsIDsContainer.encode(securitygroupid0)
            }
        }
        if let stagingAreaSubnetId = self.stagingAreaSubnetId {
            try encodeContainer.encode(stagingAreaSubnetId, forKey: .stagingAreaSubnetId)
        }
        if let stagingAreaTags = stagingAreaTags {
            var stagingAreaTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .stagingAreaTags)
            for (dictKey0, tagsMap0) in stagingAreaTags {
                try stagingAreaTagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let useDedicatedReplicationServer = self.useDedicatedReplicationServer {
            try encodeContainer.encode(useDedicatedReplicationServer, forKey: .useDedicatedReplicationServer)
        }
        if let useFipsEndpoint = self.useFipsEndpoint {
            try encodeContainer.encode(useFipsEndpoint, forKey: .useFipsEndpoint)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationConfigurationTemplateID)
        replicationConfigurationTemplateID = replicationConfigurationTemplateIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bandwidthThrottling) ?? 0
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
        let useFipsEndpointDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useFipsEndpoint)
        useFipsEndpoint = useFipsEndpointDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MgnClientTypes.ReplicationConfigurationTemplate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReplicationConfigurationTemplate(arn: \(Swift.String(describing: arn)), associateDefaultSecurityGroup: \(Swift.String(describing: associateDefaultSecurityGroup)), bandwidthThrottling: \(Swift.String(describing: bandwidthThrottling)), createPublicIP: \(Swift.String(describing: createPublicIP)), dataPlaneRouting: \(Swift.String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(Swift.String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(Swift.String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(Swift.String(describing: ebsEncryptionKeyArn)), replicationConfigurationTemplateID: \(Swift.String(describing: replicationConfigurationTemplateID)), replicationServerInstanceType: \(Swift.String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(Swift.String(describing: replicationServersSecurityGroupsIDs)), stagingAreaSubnetId: \(Swift.String(describing: stagingAreaSubnetId)), useDedicatedReplicationServer: \(Swift.String(describing: useDedicatedReplicationServer)), useFipsEndpoint: \(Swift.String(describing: useFipsEndpoint)), stagingAreaTags: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

extension MgnClientTypes {
    public struct ReplicationConfigurationTemplate {
        /// Replication Configuration template ARN.
        public var arn: Swift.String?
        /// Replication Configuration template associate default Application Migration Service Security group.
        public var associateDefaultSecurityGroup: Swift.Bool?
        /// Replication Configuration template bandwidth throttling.
        public var bandwidthThrottling: Swift.Int
        /// Replication Configuration template create Public IP.
        public var createPublicIP: Swift.Bool?
        /// Replication Configuration template data plane routing.
        public var dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
        /// Replication Configuration template use default large Staging Disk type.
        public var defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
        /// Replication Configuration template EBS encryption.
        public var ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
        /// Replication Configuration template EBS encryption key ARN.
        public var ebsEncryptionKeyArn: Swift.String?
        /// Replication Configuration template ID.
        /// This member is required.
        public var replicationConfigurationTemplateID: Swift.String?
        /// Replication Configuration template server instance type.
        public var replicationServerInstanceType: Swift.String?
        /// Replication Configuration template server Security Groups IDs.
        public var replicationServersSecurityGroupsIDs: [Swift.String]?
        /// Replication Configuration template Staging Area subnet ID.
        public var stagingAreaSubnetId: Swift.String?
        /// Replication Configuration template Staging Area Tags.
        public var stagingAreaTags: [Swift.String:Swift.String]?
        /// Replication Configuration template Tags.
        public var tags: [Swift.String:Swift.String]?
        /// Replication Configuration template use Dedicated Replication Server.
        public var useDedicatedReplicationServer: Swift.Bool?
        /// Replication Configuration template use Fips Endpoint.
        public var useFipsEndpoint: Swift.Bool?

        public init(
            arn: Swift.String? = nil,
            associateDefaultSecurityGroup: Swift.Bool? = nil,
            bandwidthThrottling: Swift.Int = 0,
            createPublicIP: Swift.Bool? = nil,
            dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
            defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
            ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption? = nil,
            ebsEncryptionKeyArn: Swift.String? = nil,
            replicationConfigurationTemplateID: Swift.String? = nil,
            replicationServerInstanceType: Swift.String? = nil,
            replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
            stagingAreaSubnetId: Swift.String? = nil,
            stagingAreaTags: [Swift.String:Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            useDedicatedReplicationServer: Swift.Bool? = nil,
            useFipsEndpoint: Swift.Bool? = nil
        )
        {
            self.arn = arn
            self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
            self.bandwidthThrottling = bandwidthThrottling
            self.createPublicIP = createPublicIP
            self.dataPlaneRouting = dataPlaneRouting
            self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
            self.ebsEncryption = ebsEncryption
            self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
            self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
            self.replicationServerInstanceType = replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
            self.stagingAreaSubnetId = stagingAreaSubnetId
            self.stagingAreaTags = stagingAreaTags
            self.tags = tags
            self.useDedicatedReplicationServer = useDedicatedReplicationServer
            self.useFipsEndpoint = useFipsEndpoint
        }
    }

}

extension MgnClientTypes {
    public enum ReplicationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case agentBased
        case snapshotShipping
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationType] {
            return [
                .agentBased,
                .snapshotShipping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agentBased: return "AGENT_BASED"
            case .snapshotShipping: return "SNAPSHOT_SHIPPING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationType(rawValue: rawValue) ?? ReplicationType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.code = nil
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Resource not found exception.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        /// Resource ID not found error.
        public internal(set) var resourceId: Swift.String? = nil
        /// Resource type not found error.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody {
    let message: Swift.String?
    let code: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ResumeReplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension ResumeReplicationInput {

    static func urlPathProvider(_ value: ResumeReplicationInput) -> Swift.String? {
        return "/ResumeReplication"
    }
}

public struct ResumeReplicationInput {
    /// Resume Replication Request account ID.
    public var accountID: Swift.String?
    /// Resume Replication Request source server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.sourceServerID = sourceServerID
    }
}

struct ResumeReplicationInputBody {
    let sourceServerID: Swift.String?
    let accountID: Swift.String?
}

extension ResumeReplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case sourceServerID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension ResumeReplicationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResumeReplicationOutput(applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), connectorAction: \(Swift.String(describing: connectorAction)), dataReplicationInfo: \(Swift.String(describing: dataReplicationInfo)), fqdnForActionFramework: \(Swift.String(describing: fqdnForActionFramework)), isArchived: \(Swift.String(describing: isArchived)), launchedInstance: \(Swift.String(describing: launchedInstance)), lifeCycle: \(Swift.String(describing: lifeCycle)), replicationType: \(Swift.String(describing: replicationType)), sourceProperties: \(Swift.String(describing: sourceProperties)), sourceServerID: \(Swift.String(describing: sourceServerID)), userProvidedID: \(Swift.String(describing: userProvidedID)), vcenterClientID: \(Swift.String(describing: vcenterClientID)), tags: \"CONTENT_REDACTED\")"}
}

extension ResumeReplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResumeReplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationID = output.applicationID
            self.arn = output.arn
            self.connectorAction = output.connectorAction
            self.dataReplicationInfo = output.dataReplicationInfo
            self.fqdnForActionFramework = output.fqdnForActionFramework
            self.isArchived = output.isArchived
            self.launchedInstance = output.launchedInstance
            self.lifeCycle = output.lifeCycle
            self.replicationType = output.replicationType
            self.sourceProperties = output.sourceProperties
            self.sourceServerID = output.sourceServerID
            self.tags = output.tags
            self.userProvidedID = output.userProvidedID
            self.vcenterClientID = output.vcenterClientID
        } else {
            self.applicationID = nil
            self.arn = nil
            self.connectorAction = nil
            self.dataReplicationInfo = nil
            self.fqdnForActionFramework = nil
            self.isArchived = nil
            self.launchedInstance = nil
            self.lifeCycle = nil
            self.replicationType = nil
            self.sourceProperties = nil
            self.sourceServerID = nil
            self.tags = nil
            self.userProvidedID = nil
            self.vcenterClientID = nil
        }
    }
}

public struct ResumeReplicationOutput {
    /// Source server application ID.
    public var applicationID: Swift.String?
    /// Source server ARN.
    public var arn: Swift.String?
    /// Source Server connector action.
    public var connectorAction: MgnClientTypes.SourceServerConnectorAction?
    /// Source server data replication info.
    public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    /// Source server fqdn for action framework.
    public var fqdnForActionFramework: Swift.String?
    /// Source server archived status.
    public var isArchived: Swift.Bool?
    /// Source server launched instance.
    public var launchedInstance: MgnClientTypes.LaunchedInstance?
    /// Source server lifecycle state.
    public var lifeCycle: MgnClientTypes.LifeCycle?
    /// Source server replication type.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// Source server properties.
    public var sourceProperties: MgnClientTypes.SourceProperties?
    /// Source server ID.
    public var sourceServerID: Swift.String?
    /// Source server Tags.
    public var tags: [Swift.String:Swift.String]?
    /// Source server user provided ID.
    public var userProvidedID: Swift.String?
    /// Source server vCenter client id.
    public var vcenterClientID: Swift.String?

    public init(
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        connectorAction: MgnClientTypes.SourceServerConnectorAction? = nil,
        dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
        fqdnForActionFramework: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
        lifeCycle: MgnClientTypes.LifeCycle? = nil,
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceProperties: MgnClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        userProvidedID: Swift.String? = nil,
        vcenterClientID: Swift.String? = nil
    )
    {
        self.applicationID = applicationID
        self.arn = arn
        self.connectorAction = connectorAction
        self.dataReplicationInfo = dataReplicationInfo
        self.fqdnForActionFramework = fqdnForActionFramework
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.replicationType = replicationType
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
        self.userProvidedID = userProvidedID
        self.vcenterClientID = vcenterClientID
    }
}

struct ResumeReplicationOutputBody {
    let sourceServerID: Swift.String?
    let arn: Swift.String?
    let isArchived: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
    let launchedInstance: MgnClientTypes.LaunchedInstance?
    let dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    let lifeCycle: MgnClientTypes.LifeCycle?
    let sourceProperties: MgnClientTypes.SourceProperties?
    let replicationType: MgnClientTypes.ReplicationType?
    let vcenterClientID: Swift.String?
    let applicationID: Swift.String?
    let userProvidedID: Swift.String?
    let fqdnForActionFramework: Swift.String?
    let connectorAction: MgnClientTypes.SourceServerConnectorAction?
}

extension ResumeReplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationID
        case arn
        case connectorAction
        case dataReplicationInfo
        case fqdnForActionFramework
        case isArchived
        case launchedInstance
        case lifeCycle
        case replicationType
        case sourceProperties
        case sourceServerID
        case tags
        case userProvidedID
        case vcenterClientID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let launchedInstanceDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchedInstance.self, forKey: .launchedInstance)
        launchedInstance = launchedInstanceDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
        let replicationTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationType.self, forKey: .replicationType)
        replicationType = replicationTypeDecoded
        let vcenterClientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcenterClientID)
        vcenterClientID = vcenterClientIDDecoded
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
        let userProvidedIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userProvidedID)
        userProvidedID = userProvidedIDDecoded
        let fqdnForActionFrameworkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fqdnForActionFramework)
        fqdnForActionFramework = fqdnForActionFrameworkDecoded
        let connectorActionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceServerConnectorAction.self, forKey: .connectorAction)
        connectorAction = connectorActionDecoded
    }
}

enum ResumeReplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RetryDataReplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension RetryDataReplicationInput {

    static func urlPathProvider(_ value: RetryDataReplicationInput) -> Swift.String? {
        return "/RetryDataReplication"
    }
}

public struct RetryDataReplicationInput {
    /// Retry data replication for Account ID.
    public var accountID: Swift.String?
    /// Retry data replication for Source Server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.sourceServerID = sourceServerID
    }
}

struct RetryDataReplicationInputBody {
    let sourceServerID: Swift.String?
    let accountID: Swift.String?
}

extension RetryDataReplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case sourceServerID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension RetryDataReplicationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RetryDataReplicationOutput(applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), connectorAction: \(Swift.String(describing: connectorAction)), dataReplicationInfo: \(Swift.String(describing: dataReplicationInfo)), fqdnForActionFramework: \(Swift.String(describing: fqdnForActionFramework)), isArchived: \(Swift.String(describing: isArchived)), launchedInstance: \(Swift.String(describing: launchedInstance)), lifeCycle: \(Swift.String(describing: lifeCycle)), replicationType: \(Swift.String(describing: replicationType)), sourceProperties: \(Swift.String(describing: sourceProperties)), sourceServerID: \(Swift.String(describing: sourceServerID)), userProvidedID: \(Swift.String(describing: userProvidedID)), vcenterClientID: \(Swift.String(describing: vcenterClientID)), tags: \"CONTENT_REDACTED\")"}
}

extension RetryDataReplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RetryDataReplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationID = output.applicationID
            self.arn = output.arn
            self.connectorAction = output.connectorAction
            self.dataReplicationInfo = output.dataReplicationInfo
            self.fqdnForActionFramework = output.fqdnForActionFramework
            self.isArchived = output.isArchived
            self.launchedInstance = output.launchedInstance
            self.lifeCycle = output.lifeCycle
            self.replicationType = output.replicationType
            self.sourceProperties = output.sourceProperties
            self.sourceServerID = output.sourceServerID
            self.tags = output.tags
            self.userProvidedID = output.userProvidedID
            self.vcenterClientID = output.vcenterClientID
        } else {
            self.applicationID = nil
            self.arn = nil
            self.connectorAction = nil
            self.dataReplicationInfo = nil
            self.fqdnForActionFramework = nil
            self.isArchived = nil
            self.launchedInstance = nil
            self.lifeCycle = nil
            self.replicationType = nil
            self.sourceProperties = nil
            self.sourceServerID = nil
            self.tags = nil
            self.userProvidedID = nil
            self.vcenterClientID = nil
        }
    }
}

public struct RetryDataReplicationOutput {
    /// Source server application ID.
    public var applicationID: Swift.String?
    /// Source server ARN.
    public var arn: Swift.String?
    /// Source Server connector action.
    public var connectorAction: MgnClientTypes.SourceServerConnectorAction?
    /// Source server data replication info.
    public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    /// Source server fqdn for action framework.
    public var fqdnForActionFramework: Swift.String?
    /// Source server archived status.
    public var isArchived: Swift.Bool?
    /// Source server launched instance.
    public var launchedInstance: MgnClientTypes.LaunchedInstance?
    /// Source server lifecycle state.
    public var lifeCycle: MgnClientTypes.LifeCycle?
    /// Source server replication type.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// Source server properties.
    public var sourceProperties: MgnClientTypes.SourceProperties?
    /// Source server ID.
    public var sourceServerID: Swift.String?
    /// Source server Tags.
    public var tags: [Swift.String:Swift.String]?
    /// Source server user provided ID.
    public var userProvidedID: Swift.String?
    /// Source server vCenter client id.
    public var vcenterClientID: Swift.String?

    public init(
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        connectorAction: MgnClientTypes.SourceServerConnectorAction? = nil,
        dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
        fqdnForActionFramework: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
        lifeCycle: MgnClientTypes.LifeCycle? = nil,
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceProperties: MgnClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        userProvidedID: Swift.String? = nil,
        vcenterClientID: Swift.String? = nil
    )
    {
        self.applicationID = applicationID
        self.arn = arn
        self.connectorAction = connectorAction
        self.dataReplicationInfo = dataReplicationInfo
        self.fqdnForActionFramework = fqdnForActionFramework
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.replicationType = replicationType
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
        self.userProvidedID = userProvidedID
        self.vcenterClientID = vcenterClientID
    }
}

struct RetryDataReplicationOutputBody {
    let sourceServerID: Swift.String?
    let arn: Swift.String?
    let isArchived: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
    let launchedInstance: MgnClientTypes.LaunchedInstance?
    let dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    let lifeCycle: MgnClientTypes.LifeCycle?
    let sourceProperties: MgnClientTypes.SourceProperties?
    let replicationType: MgnClientTypes.ReplicationType?
    let vcenterClientID: Swift.String?
    let applicationID: Swift.String?
    let userProvidedID: Swift.String?
    let fqdnForActionFramework: Swift.String?
    let connectorAction: MgnClientTypes.SourceServerConnectorAction?
}

extension RetryDataReplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationID
        case arn
        case connectorAction
        case dataReplicationInfo
        case fqdnForActionFramework
        case isArchived
        case launchedInstance
        case lifeCycle
        case replicationType
        case sourceProperties
        case sourceServerID
        case tags
        case userProvidedID
        case vcenterClientID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let launchedInstanceDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchedInstance.self, forKey: .launchedInstance)
        launchedInstance = launchedInstanceDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
        let replicationTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationType.self, forKey: .replicationType)
        replicationType = replicationTypeDecoded
        let vcenterClientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcenterClientID)
        vcenterClientID = vcenterClientIDDecoded
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
        let userProvidedIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userProvidedID)
        userProvidedID = userProvidedIDDecoded
        let fqdnForActionFrameworkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fqdnForActionFramework)
        fqdnForActionFramework = fqdnForActionFrameworkDecoded
        let connectorActionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceServerConnectorAction.self, forKey: .connectorAction)
        connectorAction = connectorActionDecoded
    }
}

enum RetryDataReplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MgnClientTypes.S3BucketSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Bucket
        case s3BucketOwner
        case s3Key
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Bucket = self.s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3BucketOwner = self.s3BucketOwner {
            try encodeContainer.encode(s3BucketOwner, forKey: .s3BucketOwner)
        }
        if let s3Key = self.s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
        let s3BucketOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketOwner)
        s3BucketOwner = s3BucketOwnerDecoded
    }
}

extension MgnClientTypes {
    /// S3 bucket source.
    public struct S3BucketSource {
        /// S3 bucket source s3 bucket.
        /// This member is required.
        public var s3Bucket: Swift.String?
        /// S3 bucket source s3 bucket owner.
        public var s3BucketOwner: Swift.String?
        /// S3 bucket source s3 key.
        /// This member is required.
        public var s3Key: Swift.String?

        public init(
            s3Bucket: Swift.String? = nil,
            s3BucketOwner: Swift.String? = nil,
            s3Key: Swift.String? = nil
        )
        {
            self.s3Bucket = s3Bucket
            self.s3BucketOwner = s3BucketOwner
            self.s3Key = s3Key
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.quotaValue = output.quotaValue
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.code = nil
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.quotaValue = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request could not be completed because its exceeded the service quota.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        /// Exceeded the service quota code.
        public internal(set) var quotaCode: Swift.String? = nil
        /// Exceeded the service quota value.
        public internal(set) var quotaValue: Swift.Int? = nil
        /// Exceeded the service quota resource ID.
        public internal(set) var resourceId: Swift.String? = nil
        /// Exceeded the service quota resource type.
        public internal(set) var resourceType: Swift.String? = nil
        /// Exceeded the service quota service code.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        quotaValue: Swift.Int? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.quotaValue = quotaValue
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody {
    let message: Swift.String?
    let code: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
    let quotaValue: Swift.Int?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case quotaCode
        case quotaValue
        case resourceId
        case resourceType
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let quotaValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quotaValue)
        quotaValue = quotaValueDecoded
    }
}

extension MgnClientTypes.SourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cpus
        case disks
        case identificationHints
        case lastUpdatedDateTime
        case networkInterfaces
        case os
        case ramBytes
        case recommendedInstanceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cpus = cpus {
            var cpusContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cpus)
            for cpu0 in cpus {
                try cpusContainer.encode(cpu0)
            }
        }
        if let disks = disks {
            var disksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .disks)
            for disk0 in disks {
                try disksContainer.encode(disk0)
            }
        }
        if let identificationHints = self.identificationHints {
            try encodeContainer.encode(identificationHints, forKey: .identificationHints)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime, forKey: .lastUpdatedDateTime)
        }
        if let networkInterfaces = networkInterfaces {
            var networkInterfacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkInterfaces)
            for networkinterface0 in networkInterfaces {
                try networkInterfacesContainer.encode(networkinterface0)
            }
        }
        if let os = self.os {
            try encodeContainer.encode(os, forKey: .os)
        }
        if ramBytes != 0 {
            try encodeContainer.encode(ramBytes, forKey: .ramBytes)
        }
        if let recommendedInstanceType = self.recommendedInstanceType {
            try encodeContainer.encode(recommendedInstanceType, forKey: .recommendedInstanceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let recommendedInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendedInstanceType)
        recommendedInstanceType = recommendedInstanceTypeDecoded
        let identificationHintsDecoded = try containerValues.decodeIfPresent(MgnClientTypes.IdentificationHints.self, forKey: .identificationHints)
        identificationHints = identificationHintsDecoded
        let networkInterfacesContainer = try containerValues.decodeIfPresent([MgnClientTypes.NetworkInterface?].self, forKey: .networkInterfaces)
        var networkInterfacesDecoded0:[MgnClientTypes.NetworkInterface]? = nil
        if let networkInterfacesContainer = networkInterfacesContainer {
            networkInterfacesDecoded0 = [MgnClientTypes.NetworkInterface]()
            for structure0 in networkInterfacesContainer {
                if let structure0 = structure0 {
                    networkInterfacesDecoded0?.append(structure0)
                }
            }
        }
        networkInterfaces = networkInterfacesDecoded0
        let disksContainer = try containerValues.decodeIfPresent([MgnClientTypes.Disk?].self, forKey: .disks)
        var disksDecoded0:[MgnClientTypes.Disk]? = nil
        if let disksContainer = disksContainer {
            disksDecoded0 = [MgnClientTypes.Disk]()
            for structure0 in disksContainer {
                if let structure0 = structure0 {
                    disksDecoded0?.append(structure0)
                }
            }
        }
        disks = disksDecoded0
        let cpusContainer = try containerValues.decodeIfPresent([MgnClientTypes.CPU?].self, forKey: .cpus)
        var cpusDecoded0:[MgnClientTypes.CPU]? = nil
        if let cpusContainer = cpusContainer {
            cpusDecoded0 = [MgnClientTypes.CPU]()
            for structure0 in cpusContainer {
                if let structure0 = structure0 {
                    cpusDecoded0?.append(structure0)
                }
            }
        }
        cpus = cpusDecoded0
        let ramBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ramBytes) ?? 0
        ramBytes = ramBytesDecoded
        let osDecoded = try containerValues.decodeIfPresent(MgnClientTypes.OS.self, forKey: .os)
        os = osDecoded
    }
}

extension MgnClientTypes {
    /// Source server properties.
    public struct SourceProperties {
        /// Source Server CPUs.
        public var cpus: [MgnClientTypes.CPU]?
        /// Source Server disks.
        public var disks: [MgnClientTypes.Disk]?
        /// Source server identification hints.
        public var identificationHints: MgnClientTypes.IdentificationHints?
        /// Source server last update date and time.
        public var lastUpdatedDateTime: Swift.String?
        /// Source server network interfaces.
        public var networkInterfaces: [MgnClientTypes.NetworkInterface]?
        /// Source server OS.
        public var os: MgnClientTypes.OS?
        /// Source server RAM in bytes.
        public var ramBytes: Swift.Int
        /// Source server recommended instance type.
        public var recommendedInstanceType: Swift.String?

        public init(
            cpus: [MgnClientTypes.CPU]? = nil,
            disks: [MgnClientTypes.Disk]? = nil,
            identificationHints: MgnClientTypes.IdentificationHints? = nil,
            lastUpdatedDateTime: Swift.String? = nil,
            networkInterfaces: [MgnClientTypes.NetworkInterface]? = nil,
            os: MgnClientTypes.OS? = nil,
            ramBytes: Swift.Int = 0,
            recommendedInstanceType: Swift.String? = nil
        )
        {
            self.cpus = cpus
            self.disks = disks
            self.identificationHints = identificationHints
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.networkInterfaces = networkInterfaces
            self.os = os
            self.ramBytes = ramBytes
            self.recommendedInstanceType = recommendedInstanceType
        }
    }

}

extension MgnClientTypes.SourceServer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationID
        case arn
        case connectorAction
        case dataReplicationInfo
        case fqdnForActionFramework
        case isArchived
        case launchedInstance
        case lifeCycle
        case replicationType
        case sourceProperties
        case sourceServerID
        case tags
        case userProvidedID
        case vcenterClientID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationID = self.applicationID {
            try encodeContainer.encode(applicationID, forKey: .applicationID)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let connectorAction = self.connectorAction {
            try encodeContainer.encode(connectorAction, forKey: .connectorAction)
        }
        if let dataReplicationInfo = self.dataReplicationInfo {
            try encodeContainer.encode(dataReplicationInfo, forKey: .dataReplicationInfo)
        }
        if let fqdnForActionFramework = self.fqdnForActionFramework {
            try encodeContainer.encode(fqdnForActionFramework, forKey: .fqdnForActionFramework)
        }
        if let isArchived = self.isArchived {
            try encodeContainer.encode(isArchived, forKey: .isArchived)
        }
        if let launchedInstance = self.launchedInstance {
            try encodeContainer.encode(launchedInstance, forKey: .launchedInstance)
        }
        if let lifeCycle = self.lifeCycle {
            try encodeContainer.encode(lifeCycle, forKey: .lifeCycle)
        }
        if let replicationType = self.replicationType {
            try encodeContainer.encode(replicationType.rawValue, forKey: .replicationType)
        }
        if let sourceProperties = self.sourceProperties {
            try encodeContainer.encode(sourceProperties, forKey: .sourceProperties)
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let userProvidedID = self.userProvidedID {
            try encodeContainer.encode(userProvidedID, forKey: .userProvidedID)
        }
        if let vcenterClientID = self.vcenterClientID {
            try encodeContainer.encode(vcenterClientID, forKey: .vcenterClientID)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let launchedInstanceDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchedInstance.self, forKey: .launchedInstance)
        launchedInstance = launchedInstanceDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
        let replicationTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationType.self, forKey: .replicationType)
        replicationType = replicationTypeDecoded
        let vcenterClientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcenterClientID)
        vcenterClientID = vcenterClientIDDecoded
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
        let userProvidedIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userProvidedID)
        userProvidedID = userProvidedIDDecoded
        let fqdnForActionFrameworkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fqdnForActionFramework)
        fqdnForActionFramework = fqdnForActionFrameworkDecoded
        let connectorActionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceServerConnectorAction.self, forKey: .connectorAction)
        connectorAction = connectorActionDecoded
    }
}

extension MgnClientTypes.SourceServer: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SourceServer(applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), connectorAction: \(Swift.String(describing: connectorAction)), dataReplicationInfo: \(Swift.String(describing: dataReplicationInfo)), fqdnForActionFramework: \(Swift.String(describing: fqdnForActionFramework)), isArchived: \(Swift.String(describing: isArchived)), launchedInstance: \(Swift.String(describing: launchedInstance)), lifeCycle: \(Swift.String(describing: lifeCycle)), replicationType: \(Swift.String(describing: replicationType)), sourceProperties: \(Swift.String(describing: sourceProperties)), sourceServerID: \(Swift.String(describing: sourceServerID)), userProvidedID: \(Swift.String(describing: userProvidedID)), vcenterClientID: \(Swift.String(describing: vcenterClientID)), tags: \"CONTENT_REDACTED\")"}
}

extension MgnClientTypes {
    public struct SourceServer {
        /// Source server application ID.
        public var applicationID: Swift.String?
        /// Source server ARN.
        public var arn: Swift.String?
        /// Source Server connector action.
        public var connectorAction: MgnClientTypes.SourceServerConnectorAction?
        /// Source server data replication info.
        public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
        /// Source server fqdn for action framework.
        public var fqdnForActionFramework: Swift.String?
        /// Source server archived status.
        public var isArchived: Swift.Bool?
        /// Source server launched instance.
        public var launchedInstance: MgnClientTypes.LaunchedInstance?
        /// Source server lifecycle state.
        public var lifeCycle: MgnClientTypes.LifeCycle?
        /// Source server replication type.
        public var replicationType: MgnClientTypes.ReplicationType?
        /// Source server properties.
        public var sourceProperties: MgnClientTypes.SourceProperties?
        /// Source server ID.
        public var sourceServerID: Swift.String?
        /// Source server Tags.
        public var tags: [Swift.String:Swift.String]?
        /// Source server user provided ID.
        public var userProvidedID: Swift.String?
        /// Source server vCenter client id.
        public var vcenterClientID: Swift.String?

        public init(
            applicationID: Swift.String? = nil,
            arn: Swift.String? = nil,
            connectorAction: MgnClientTypes.SourceServerConnectorAction? = nil,
            dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
            fqdnForActionFramework: Swift.String? = nil,
            isArchived: Swift.Bool? = nil,
            launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
            lifeCycle: MgnClientTypes.LifeCycle? = nil,
            replicationType: MgnClientTypes.ReplicationType? = nil,
            sourceProperties: MgnClientTypes.SourceProperties? = nil,
            sourceServerID: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            userProvidedID: Swift.String? = nil,
            vcenterClientID: Swift.String? = nil
        )
        {
            self.applicationID = applicationID
            self.arn = arn
            self.connectorAction = connectorAction
            self.dataReplicationInfo = dataReplicationInfo
            self.fqdnForActionFramework = fqdnForActionFramework
            self.isArchived = isArchived
            self.launchedInstance = launchedInstance
            self.lifeCycle = lifeCycle
            self.replicationType = replicationType
            self.sourceProperties = sourceProperties
            self.sourceServerID = sourceServerID
            self.tags = tags
            self.userProvidedID = userProvidedID
            self.vcenterClientID = vcenterClientID
        }
    }

}

extension MgnClientTypes.SourceServerActionDocument: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionID
        case actionName
        case active
        case category
        case description
        case documentIdentifier
        case documentVersion
        case externalParameters
        case mustSucceedForCutover
        case order
        case parameters
        case timeoutSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionID = self.actionID {
            try encodeContainer.encode(actionID, forKey: .actionID)
        }
        if let actionName = self.actionName {
            try encodeContainer.encode(actionName, forKey: .actionName)
        }
        if let active = self.active {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let category = self.category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let documentIdentifier = self.documentIdentifier {
            try encodeContainer.encode(documentIdentifier, forKey: .documentIdentifier)
        }
        if let documentVersion = self.documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let externalParameters = externalParameters {
            var externalParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .externalParameters)
            for (dictKey0, ssmDocumentExternalParameters0) in externalParameters {
                try externalParametersContainer.encode(ssmDocumentExternalParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let mustSucceedForCutover = self.mustSucceedForCutover {
            try encodeContainer.encode(mustSucceedForCutover, forKey: .mustSucceedForCutover)
        }
        if let order = self.order {
            try encodeContainer.encode(order, forKey: .order)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, ssmDocumentParameters0) in parameters {
                var ssmDocumentParameters0Container = parametersContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for ssmparameterstoreparameter1 in ssmDocumentParameters0 {
                    try ssmDocumentParameters0Container.encode(ssmparameterstoreparameter1)
                }
            }
        }
        if let timeoutSeconds = self.timeoutSeconds {
            try encodeContainer.encode(timeoutSeconds, forKey: .timeoutSeconds)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionID)
        actionID = actionIDDecoded
        let actionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let documentIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentIdentifier)
        documentIdentifier = documentIdentifierDecoded
        let orderDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .order)
        order = orderDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .active)
        active = activeDecoded
        let timeoutSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutSeconds)
        timeoutSeconds = timeoutSecondsDecoded
        let mustSucceedForCutoverDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .mustSucceedForCutover)
        mustSucceedForCutover = mustSucceedForCutoverDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [MgnClientTypes.SsmParameterStoreParameter?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]()
            for (key0, ssmparameterstoreparameters0) in parametersContainer {
                var ssmparameterstoreparameters0Decoded0: [MgnClientTypes.SsmParameterStoreParameter]? = nil
                if let ssmparameterstoreparameters0 = ssmparameterstoreparameters0 {
                    ssmparameterstoreparameters0Decoded0 = [MgnClientTypes.SsmParameterStoreParameter]()
                    for structure1 in ssmparameterstoreparameters0 {
                        if let structure1 = structure1 {
                            ssmparameterstoreparameters0Decoded0?.append(structure1)
                        }
                    }
                }
                parametersDecoded0?[key0] = ssmparameterstoreparameters0Decoded0
            }
        }
        parameters = parametersDecoded0
        let externalParametersContainer = try containerValues.decodeIfPresent([Swift.String: MgnClientTypes.SsmExternalParameter?].self, forKey: .externalParameters)
        var externalParametersDecoded0: [Swift.String:MgnClientTypes.SsmExternalParameter]? = nil
        if let externalParametersContainer = externalParametersContainer {
            externalParametersDecoded0 = [Swift.String:MgnClientTypes.SsmExternalParameter]()
            for (key0, ssmexternalparameter0) in externalParametersContainer {
                if let ssmexternalparameter0 = ssmexternalparameter0 {
                    externalParametersDecoded0?[key0] = ssmexternalparameter0
                }
            }
        }
        externalParameters = externalParametersDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ActionCategory.self, forKey: .category)
        category = categoryDecoded
    }
}

extension MgnClientTypes {
    public struct SourceServerActionDocument {
        /// Source server post migration custom action ID.
        public var actionID: Swift.String?
        /// Source server post migration custom action name.
        public var actionName: Swift.String?
        /// Source server post migration custom action active status.
        public var active: Swift.Bool?
        /// Source server post migration custom action category.
        public var category: MgnClientTypes.ActionCategory?
        /// Source server post migration custom action description.
        public var description: Swift.String?
        /// Source server post migration custom action document identifier.
        public var documentIdentifier: Swift.String?
        /// Source server post migration custom action document version.
        public var documentVersion: Swift.String?
        /// Source server post migration custom action external parameters.
        public var externalParameters: [Swift.String:MgnClientTypes.SsmExternalParameter]?
        /// Source server post migration custom action must succeed for cutover.
        public var mustSucceedForCutover: Swift.Bool?
        /// Source server post migration custom action order.
        public var order: Swift.Int?
        /// Source server post migration custom action parameters.
        public var parameters: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]?
        /// Source server post migration custom action timeout in seconds.
        public var timeoutSeconds: Swift.Int?

        public init(
            actionID: Swift.String? = nil,
            actionName: Swift.String? = nil,
            active: Swift.Bool? = nil,
            category: MgnClientTypes.ActionCategory? = nil,
            description: Swift.String? = nil,
            documentIdentifier: Swift.String? = nil,
            documentVersion: Swift.String? = nil,
            externalParameters: [Swift.String:MgnClientTypes.SsmExternalParameter]? = nil,
            mustSucceedForCutover: Swift.Bool? = nil,
            order: Swift.Int? = nil,
            parameters: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]? = nil,
            timeoutSeconds: Swift.Int? = nil
        )
        {
            self.actionID = actionID
            self.actionName = actionName
            self.active = active
            self.category = category
            self.description = description
            self.documentIdentifier = documentIdentifier
            self.documentVersion = documentVersion
            self.externalParameters = externalParameters
            self.mustSucceedForCutover = mustSucceedForCutover
            self.order = order
            self.parameters = parameters
            self.timeoutSeconds = timeoutSeconds
        }
    }

}

extension MgnClientTypes.SourceServerActionsRequestFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionIDs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionIDs = actionIDs {
            var actionIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actionIDs)
            for actionid0 in actionIDs {
                try actionIDsContainer.encode(actionid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .actionIDs)
        var actionIDsDecoded0:[Swift.String]? = nil
        if let actionIDsContainer = actionIDsContainer {
            actionIDsDecoded0 = [Swift.String]()
            for string0 in actionIDsContainer {
                if let string0 = string0 {
                    actionIDsDecoded0?.append(string0)
                }
            }
        }
        actionIDs = actionIDsDecoded0
    }
}

extension MgnClientTypes {
    /// Source server post migration custom action filters.
    public struct SourceServerActionsRequestFilters {
        /// Action IDs to filter source server post migration custom actions by.
        public var actionIDs: [Swift.String]?

        public init(
            actionIDs: [Swift.String]? = nil
        )
        {
            self.actionIDs = actionIDs
        }
    }

}

extension MgnClientTypes.SourceServerConnectorAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorArn
        case credentialsSecretArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorArn = self.connectorArn {
            try encodeContainer.encode(connectorArn, forKey: .connectorArn)
        }
        if let credentialsSecretArn = self.credentialsSecretArn {
            try encodeContainer.encode(credentialsSecretArn, forKey: .credentialsSecretArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let credentialsSecretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentialsSecretArn)
        credentialsSecretArn = credentialsSecretArnDecoded
        let connectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorArn)
        connectorArn = connectorArnDecoded
    }
}

extension MgnClientTypes {
    /// Source Server connector action.
    public struct SourceServerConnectorAction {
        /// Source Server connector action connector arn.
        public var connectorArn: Swift.String?
        /// Source Server connector action credentials secret arn.
        public var credentialsSecretArn: Swift.String?

        public init(
            connectorArn: Swift.String? = nil,
            credentialsSecretArn: Swift.String? = nil
        )
        {
            self.connectorArn = connectorArn
            self.credentialsSecretArn = credentialsSecretArn
        }
    }

}

extension MgnClientTypes.SsmDocument: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionName
        case externalParameters
        case mustSucceedForCutover
        case parameters
        case ssmDocumentName
        case timeoutSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionName = self.actionName {
            try encodeContainer.encode(actionName, forKey: .actionName)
        }
        if let externalParameters = externalParameters {
            var externalParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .externalParameters)
            for (dictKey0, ssmDocumentExternalParameters0) in externalParameters {
                try externalParametersContainer.encode(ssmDocumentExternalParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let mustSucceedForCutover = self.mustSucceedForCutover {
            try encodeContainer.encode(mustSucceedForCutover, forKey: .mustSucceedForCutover)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, ssmDocumentParameters0) in parameters {
                var ssmDocumentParameters0Container = parametersContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for ssmparameterstoreparameter1 in ssmDocumentParameters0 {
                    try ssmDocumentParameters0Container.encode(ssmparameterstoreparameter1)
                }
            }
        }
        if let ssmDocumentName = self.ssmDocumentName {
            try encodeContainer.encode(ssmDocumentName, forKey: .ssmDocumentName)
        }
        if let timeoutSeconds = self.timeoutSeconds {
            try encodeContainer.encode(timeoutSeconds, forKey: .timeoutSeconds)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let ssmDocumentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ssmDocumentName)
        ssmDocumentName = ssmDocumentNameDecoded
        let timeoutSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutSeconds)
        timeoutSeconds = timeoutSecondsDecoded
        let mustSucceedForCutoverDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .mustSucceedForCutover)
        mustSucceedForCutover = mustSucceedForCutoverDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [MgnClientTypes.SsmParameterStoreParameter?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]()
            for (key0, ssmparameterstoreparameters0) in parametersContainer {
                var ssmparameterstoreparameters0Decoded0: [MgnClientTypes.SsmParameterStoreParameter]? = nil
                if let ssmparameterstoreparameters0 = ssmparameterstoreparameters0 {
                    ssmparameterstoreparameters0Decoded0 = [MgnClientTypes.SsmParameterStoreParameter]()
                    for structure1 in ssmparameterstoreparameters0 {
                        if let structure1 = structure1 {
                            ssmparameterstoreparameters0Decoded0?.append(structure1)
                        }
                    }
                }
                parametersDecoded0?[key0] = ssmparameterstoreparameters0Decoded0
            }
        }
        parameters = parametersDecoded0
        let externalParametersContainer = try containerValues.decodeIfPresent([Swift.String: MgnClientTypes.SsmExternalParameter?].self, forKey: .externalParameters)
        var externalParametersDecoded0: [Swift.String:MgnClientTypes.SsmExternalParameter]? = nil
        if let externalParametersContainer = externalParametersContainer {
            externalParametersDecoded0 = [Swift.String:MgnClientTypes.SsmExternalParameter]()
            for (key0, ssmexternalparameter0) in externalParametersContainer {
                if let ssmexternalparameter0 = ssmexternalparameter0 {
                    externalParametersDecoded0?[key0] = ssmexternalparameter0
                }
            }
        }
        externalParameters = externalParametersDecoded0
    }
}

extension MgnClientTypes {
    /// AWS Systems Manager Document.
    public struct SsmDocument {
        /// User-friendly name for the AWS Systems Manager Document.
        /// This member is required.
        public var actionName: Swift.String?
        /// AWS Systems Manager Document external parameters.
        public var externalParameters: [Swift.String:MgnClientTypes.SsmExternalParameter]?
        /// If true, Cutover will not be enabled if the document has failed.
        public var mustSucceedForCutover: Swift.Bool?
        /// AWS Systems Manager Document parameters.
        public var parameters: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]?
        /// AWS Systems Manager Document name or full ARN.
        /// This member is required.
        public var ssmDocumentName: Swift.String?
        /// AWS Systems Manager Document timeout seconds.
        public var timeoutSeconds: Swift.Int?

        public init(
            actionName: Swift.String? = nil,
            externalParameters: [Swift.String:MgnClientTypes.SsmExternalParameter]? = nil,
            mustSucceedForCutover: Swift.Bool? = nil,
            parameters: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]? = nil,
            ssmDocumentName: Swift.String? = nil,
            timeoutSeconds: Swift.Int? = nil
        )
        {
            self.actionName = actionName
            self.externalParameters = externalParameters
            self.mustSucceedForCutover = mustSucceedForCutover
            self.parameters = parameters
            self.ssmDocumentName = ssmDocumentName
            self.timeoutSeconds = timeoutSeconds
        }
    }

}

extension MgnClientTypes {
    public enum SsmDocumentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case automation
        case command
        case sdkUnknown(Swift.String)

        public static var allCases: [SsmDocumentType] {
            return [
                .automation,
                .command,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .automation: return "AUTOMATION"
            case .command: return "COMMAND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SsmDocumentType(rawValue: rawValue) ?? SsmDocumentType.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes.SsmExternalParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dynamicpath = "dynamicPath"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .dynamicpath(dynamicpath):
                try container.encode(dynamicpath, forKey: .dynamicpath)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let dynamicpathDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .dynamicpath)
        if let dynamicpath = dynamicpathDecoded {
            self = .dynamicpath(dynamicpath)
            return
        }
        self = .sdkUnknown("")
    }
}

extension MgnClientTypes {
    /// AWS Systems Manager Document external parameter.
    public enum SsmExternalParameter {
        /// AWS Systems Manager Document external parameters dynamic path.
        case dynamicpath(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension MgnClientTypes.SsmParameterStoreParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterName
        case parameterType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterName = self.parameterName {
            try encodeContainer.encode(parameterName, forKey: .parameterName)
        }
        if let parameterType = self.parameterType {
            try encodeContainer.encode(parameterType.rawValue, forKey: .parameterType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SsmParameterStoreParameterType.self, forKey: .parameterType)
        parameterType = parameterTypeDecoded
        let parameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
    }
}

extension MgnClientTypes {
    /// AWS Systems Manager Parameter Store parameter.
    public struct SsmParameterStoreParameter {
        /// AWS Systems Manager Parameter Store parameter name.
        /// This member is required.
        public var parameterName: Swift.String?
        /// AWS Systems Manager Parameter Store parameter type.
        /// This member is required.
        public var parameterType: MgnClientTypes.SsmParameterStoreParameterType?

        public init(
            parameterName: Swift.String? = nil,
            parameterType: MgnClientTypes.SsmParameterStoreParameterType? = nil
        )
        {
            self.parameterName = parameterName
            self.parameterType = parameterType
        }
    }

}

extension MgnClientTypes {
    public enum SsmParameterStoreParameterType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [SsmParameterStoreParameterType] {
            return [
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SsmParameterStoreParameterType(rawValue: rawValue) ?? SsmParameterStoreParameterType.sdkUnknown(rawValue)
        }
    }
}

extension StartCutoverInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartCutoverInput(accountID: \(Swift.String(describing: accountID)), sourceServerIDs: \(Swift.String(describing: sourceServerIDs)), tags: \"CONTENT_REDACTED\")"}
}

extension StartCutoverInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case sourceServerIDs
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let sourceServerIDs = sourceServerIDs {
            var sourceServerIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceServerIDs)
            for sourceserverid0 in sourceServerIDs {
                try sourceServerIDsContainer.encode(sourceserverid0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension StartCutoverInput {

    static func urlPathProvider(_ value: StartCutoverInput) -> Swift.String? {
        return "/StartCutover"
    }
}

public struct StartCutoverInput {
    /// Start Cutover by Account IDs
    public var accountID: Swift.String?
    /// Start Cutover by Source Server IDs.
    /// This member is required.
    public var sourceServerIDs: [Swift.String]?
    /// Start Cutover by Tags.
    public var tags: [Swift.String:Swift.String]?

    public init(
        accountID: Swift.String? = nil,
        sourceServerIDs: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.accountID = accountID
        self.sourceServerIDs = sourceServerIDs
        self.tags = tags
    }
}

struct StartCutoverInputBody {
    let sourceServerIDs: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
    let accountID: Swift.String?
}

extension StartCutoverInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case sourceServerIDs
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceServerIDs)
        var sourceServerIDsDecoded0:[Swift.String]? = nil
        if let sourceServerIDsContainer = sourceServerIDsContainer {
            sourceServerIDsDecoded0 = [Swift.String]()
            for string0 in sourceServerIDsContainer {
                if let string0 = string0 {
                    sourceServerIDsDecoded0?.append(string0)
                }
            }
        }
        sourceServerIDs = sourceServerIDsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension StartCutoverOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartCutoverOutputBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct StartCutoverOutput {
    /// Start Cutover Job response.
    public var job: MgnClientTypes.Job?

    public init(
        job: MgnClientTypes.Job? = nil
    )
    {
        self.job = job
    }
}

struct StartCutoverOutputBody {
    let job: MgnClientTypes.Job?
}

extension StartCutoverOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(MgnClientTypes.Job.self, forKey: .job)
        job = jobDecoded
    }
}

enum StartCutoverOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartExportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Bucket
        case s3BucketOwner
        case s3Key
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Bucket = self.s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3BucketOwner = self.s3BucketOwner {
            try encodeContainer.encode(s3BucketOwner, forKey: .s3BucketOwner)
        }
        if let s3Key = self.s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
    }
}

extension StartExportInput {

    static func urlPathProvider(_ value: StartExportInput) -> Swift.String? {
        return "/StartExport"
    }
}

/// Start export request.
public struct StartExportInput {
    /// Start export request s3 bucket.
    /// This member is required.
    public var s3Bucket: Swift.String?
    /// Start export request s3 bucket owner.
    public var s3BucketOwner: Swift.String?
    /// Start export request s3key.
    /// This member is required.
    public var s3Key: Swift.String?

    public init(
        s3Bucket: Swift.String? = nil,
        s3BucketOwner: Swift.String? = nil,
        s3Key: Swift.String? = nil
    )
    {
        self.s3Bucket = s3Bucket
        self.s3BucketOwner = s3BucketOwner
        self.s3Key = s3Key
    }
}

struct StartExportInputBody {
    let s3Bucket: Swift.String?
    let s3Key: Swift.String?
    let s3BucketOwner: Swift.String?
}

extension StartExportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Bucket
        case s3BucketOwner
        case s3Key
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
        let s3BucketOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketOwner)
        s3BucketOwner = s3BucketOwnerDecoded
    }
}

extension StartExportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartExportOutputBody = try responseDecoder.decode(responseBody: data)
            self.exportTask = output.exportTask
        } else {
            self.exportTask = nil
        }
    }
}

/// Start export response.
public struct StartExportOutput {
    /// Start export response export task.
    public var exportTask: MgnClientTypes.ExportTask?

    public init(
        exportTask: MgnClientTypes.ExportTask? = nil
    )
    {
        self.exportTask = exportTask
    }
}

struct StartExportOutputBody {
    let exportTask: MgnClientTypes.ExportTask?
}

extension StartExportOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportTask
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportTaskDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ExportTask.self, forKey: .exportTask)
        exportTask = exportTaskDecoded
    }
}

enum StartExportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartImportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case s3BucketSource
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let s3BucketSource = self.s3BucketSource {
            try encodeContainer.encode(s3BucketSource, forKey: .s3BucketSource)
        }
    }
}

extension StartImportInput {

    static func urlPathProvider(_ value: StartImportInput) -> Swift.String? {
        return "/StartImport"
    }
}

/// Start import request.
public struct StartImportInput {
    /// Start import request client token.
    public var clientToken: Swift.String?
    /// Start import request s3 bucket source.
    /// This member is required.
    public var s3BucketSource: MgnClientTypes.S3BucketSource?

    public init(
        clientToken: Swift.String? = nil,
        s3BucketSource: MgnClientTypes.S3BucketSource? = nil
    )
    {
        self.clientToken = clientToken
        self.s3BucketSource = s3BucketSource
    }
}

struct StartImportInputBody {
    let clientToken: Swift.String?
    let s3BucketSource: MgnClientTypes.S3BucketSource?
}

extension StartImportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case s3BucketSource
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let s3BucketSourceDecoded = try containerValues.decodeIfPresent(MgnClientTypes.S3BucketSource.self, forKey: .s3BucketSource)
        s3BucketSource = s3BucketSourceDecoded
    }
}

extension StartImportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartImportOutputBody = try responseDecoder.decode(responseBody: data)
            self.importTask = output.importTask
        } else {
            self.importTask = nil
        }
    }
}

/// Start import response.
public struct StartImportOutput {
    /// Start import response import task.
    public var importTask: MgnClientTypes.ImportTask?

    public init(
        importTask: MgnClientTypes.ImportTask? = nil
    )
    {
        self.importTask = importTask
    }
}

struct StartImportOutputBody {
    let importTask: MgnClientTypes.ImportTask?
}

extension StartImportOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importTask
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importTaskDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ImportTask.self, forKey: .importTask)
        importTask = importTaskDecoded
    }
}

enum StartImportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartReplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension StartReplicationInput {

    static func urlPathProvider(_ value: StartReplicationInput) -> Swift.String? {
        return "/StartReplication"
    }
}

public struct StartReplicationInput {
    /// Account ID on which to start replication.
    public var accountID: Swift.String?
    /// ID of source server on which to start replication.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.sourceServerID = sourceServerID
    }
}

struct StartReplicationInputBody {
    let sourceServerID: Swift.String?
    let accountID: Swift.String?
}

extension StartReplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case sourceServerID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension StartReplicationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartReplicationOutput(applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), connectorAction: \(Swift.String(describing: connectorAction)), dataReplicationInfo: \(Swift.String(describing: dataReplicationInfo)), fqdnForActionFramework: \(Swift.String(describing: fqdnForActionFramework)), isArchived: \(Swift.String(describing: isArchived)), launchedInstance: \(Swift.String(describing: launchedInstance)), lifeCycle: \(Swift.String(describing: lifeCycle)), replicationType: \(Swift.String(describing: replicationType)), sourceProperties: \(Swift.String(describing: sourceProperties)), sourceServerID: \(Swift.String(describing: sourceServerID)), userProvidedID: \(Swift.String(describing: userProvidedID)), vcenterClientID: \(Swift.String(describing: vcenterClientID)), tags: \"CONTENT_REDACTED\")"}
}

extension StartReplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartReplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationID = output.applicationID
            self.arn = output.arn
            self.connectorAction = output.connectorAction
            self.dataReplicationInfo = output.dataReplicationInfo
            self.fqdnForActionFramework = output.fqdnForActionFramework
            self.isArchived = output.isArchived
            self.launchedInstance = output.launchedInstance
            self.lifeCycle = output.lifeCycle
            self.replicationType = output.replicationType
            self.sourceProperties = output.sourceProperties
            self.sourceServerID = output.sourceServerID
            self.tags = output.tags
            self.userProvidedID = output.userProvidedID
            self.vcenterClientID = output.vcenterClientID
        } else {
            self.applicationID = nil
            self.arn = nil
            self.connectorAction = nil
            self.dataReplicationInfo = nil
            self.fqdnForActionFramework = nil
            self.isArchived = nil
            self.launchedInstance = nil
            self.lifeCycle = nil
            self.replicationType = nil
            self.sourceProperties = nil
            self.sourceServerID = nil
            self.tags = nil
            self.userProvidedID = nil
            self.vcenterClientID = nil
        }
    }
}

public struct StartReplicationOutput {
    /// Source server application ID.
    public var applicationID: Swift.String?
    /// Source server ARN.
    public var arn: Swift.String?
    /// Source Server connector action.
    public var connectorAction: MgnClientTypes.SourceServerConnectorAction?
    /// Source server data replication info.
    public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    /// Source server fqdn for action framework.
    public var fqdnForActionFramework: Swift.String?
    /// Source server archived status.
    public var isArchived: Swift.Bool?
    /// Source server launched instance.
    public var launchedInstance: MgnClientTypes.LaunchedInstance?
    /// Source server lifecycle state.
    public var lifeCycle: MgnClientTypes.LifeCycle?
    /// Source server replication type.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// Source server properties.
    public var sourceProperties: MgnClientTypes.SourceProperties?
    /// Source server ID.
    public var sourceServerID: Swift.String?
    /// Source server Tags.
    public var tags: [Swift.String:Swift.String]?
    /// Source server user provided ID.
    public var userProvidedID: Swift.String?
    /// Source server vCenter client id.
    public var vcenterClientID: Swift.String?

    public init(
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        connectorAction: MgnClientTypes.SourceServerConnectorAction? = nil,
        dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
        fqdnForActionFramework: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
        lifeCycle: MgnClientTypes.LifeCycle? = nil,
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceProperties: MgnClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        userProvidedID: Swift.String? = nil,
        vcenterClientID: Swift.String? = nil
    )
    {
        self.applicationID = applicationID
        self.arn = arn
        self.connectorAction = connectorAction
        self.dataReplicationInfo = dataReplicationInfo
        self.fqdnForActionFramework = fqdnForActionFramework
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.replicationType = replicationType
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
        self.userProvidedID = userProvidedID
        self.vcenterClientID = vcenterClientID
    }
}

struct StartReplicationOutputBody {
    let sourceServerID: Swift.String?
    let arn: Swift.String?
    let isArchived: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
    let launchedInstance: MgnClientTypes.LaunchedInstance?
    let dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    let lifeCycle: MgnClientTypes.LifeCycle?
    let sourceProperties: MgnClientTypes.SourceProperties?
    let replicationType: MgnClientTypes.ReplicationType?
    let vcenterClientID: Swift.String?
    let applicationID: Swift.String?
    let userProvidedID: Swift.String?
    let fqdnForActionFramework: Swift.String?
    let connectorAction: MgnClientTypes.SourceServerConnectorAction?
}

extension StartReplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationID
        case arn
        case connectorAction
        case dataReplicationInfo
        case fqdnForActionFramework
        case isArchived
        case launchedInstance
        case lifeCycle
        case replicationType
        case sourceProperties
        case sourceServerID
        case tags
        case userProvidedID
        case vcenterClientID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let launchedInstanceDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchedInstance.self, forKey: .launchedInstance)
        launchedInstance = launchedInstanceDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
        let replicationTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationType.self, forKey: .replicationType)
        replicationType = replicationTypeDecoded
        let vcenterClientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcenterClientID)
        vcenterClientID = vcenterClientIDDecoded
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
        let userProvidedIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userProvidedID)
        userProvidedID = userProvidedIDDecoded
        let fqdnForActionFrameworkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fqdnForActionFramework)
        fqdnForActionFramework = fqdnForActionFrameworkDecoded
        let connectorActionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceServerConnectorAction.self, forKey: .connectorAction)
        connectorAction = connectorActionDecoded
    }
}

enum StartReplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartTestInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartTestInput(accountID: \(Swift.String(describing: accountID)), sourceServerIDs: \(Swift.String(describing: sourceServerIDs)), tags: \"CONTENT_REDACTED\")"}
}

extension StartTestInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case sourceServerIDs
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let sourceServerIDs = sourceServerIDs {
            var sourceServerIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceServerIDs)
            for sourceserverid0 in sourceServerIDs {
                try sourceServerIDsContainer.encode(sourceserverid0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension StartTestInput {

    static func urlPathProvider(_ value: StartTestInput) -> Swift.String? {
        return "/StartTest"
    }
}

public struct StartTestInput {
    /// Start Test for Account ID.
    public var accountID: Swift.String?
    /// Start Test for Source Server IDs.
    /// This member is required.
    public var sourceServerIDs: [Swift.String]?
    /// Start Test by Tags.
    public var tags: [Swift.String:Swift.String]?

    public init(
        accountID: Swift.String? = nil,
        sourceServerIDs: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.accountID = accountID
        self.sourceServerIDs = sourceServerIDs
        self.tags = tags
    }
}

struct StartTestInputBody {
    let sourceServerIDs: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
    let accountID: Swift.String?
}

extension StartTestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case sourceServerIDs
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceServerIDs)
        var sourceServerIDsDecoded0:[Swift.String]? = nil
        if let sourceServerIDsContainer = sourceServerIDsContainer {
            sourceServerIDsDecoded0 = [Swift.String]()
            for string0 in sourceServerIDsContainer {
                if let string0 = string0 {
                    sourceServerIDsDecoded0?.append(string0)
                }
            }
        }
        sourceServerIDs = sourceServerIDsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension StartTestOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartTestOutputBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct StartTestOutput {
    /// Start Test Job response.
    public var job: MgnClientTypes.Job?

    public init(
        job: MgnClientTypes.Job? = nil
    )
    {
        self.job = job
    }
}

struct StartTestOutputBody {
    let job: MgnClientTypes.Job?
}

extension StartTestOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(MgnClientTypes.Job.self, forKey: .job)
        job = jobDecoded
    }
}

enum StartTestOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopReplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension StopReplicationInput {

    static func urlPathProvider(_ value: StopReplicationInput) -> Swift.String? {
        return "/StopReplication"
    }
}

public struct StopReplicationInput {
    /// Stop Replication Request account ID.
    public var accountID: Swift.String?
    /// Stop Replication Request source server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.sourceServerID = sourceServerID
    }
}

struct StopReplicationInputBody {
    let sourceServerID: Swift.String?
    let accountID: Swift.String?
}

extension StopReplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case sourceServerID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension StopReplicationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopReplicationOutput(applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), connectorAction: \(Swift.String(describing: connectorAction)), dataReplicationInfo: \(Swift.String(describing: dataReplicationInfo)), fqdnForActionFramework: \(Swift.String(describing: fqdnForActionFramework)), isArchived: \(Swift.String(describing: isArchived)), launchedInstance: \(Swift.String(describing: launchedInstance)), lifeCycle: \(Swift.String(describing: lifeCycle)), replicationType: \(Swift.String(describing: replicationType)), sourceProperties: \(Swift.String(describing: sourceProperties)), sourceServerID: \(Swift.String(describing: sourceServerID)), userProvidedID: \(Swift.String(describing: userProvidedID)), vcenterClientID: \(Swift.String(describing: vcenterClientID)), tags: \"CONTENT_REDACTED\")"}
}

extension StopReplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StopReplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationID = output.applicationID
            self.arn = output.arn
            self.connectorAction = output.connectorAction
            self.dataReplicationInfo = output.dataReplicationInfo
            self.fqdnForActionFramework = output.fqdnForActionFramework
            self.isArchived = output.isArchived
            self.launchedInstance = output.launchedInstance
            self.lifeCycle = output.lifeCycle
            self.replicationType = output.replicationType
            self.sourceProperties = output.sourceProperties
            self.sourceServerID = output.sourceServerID
            self.tags = output.tags
            self.userProvidedID = output.userProvidedID
            self.vcenterClientID = output.vcenterClientID
        } else {
            self.applicationID = nil
            self.arn = nil
            self.connectorAction = nil
            self.dataReplicationInfo = nil
            self.fqdnForActionFramework = nil
            self.isArchived = nil
            self.launchedInstance = nil
            self.lifeCycle = nil
            self.replicationType = nil
            self.sourceProperties = nil
            self.sourceServerID = nil
            self.tags = nil
            self.userProvidedID = nil
            self.vcenterClientID = nil
        }
    }
}

public struct StopReplicationOutput {
    /// Source server application ID.
    public var applicationID: Swift.String?
    /// Source server ARN.
    public var arn: Swift.String?
    /// Source Server connector action.
    public var connectorAction: MgnClientTypes.SourceServerConnectorAction?
    /// Source server data replication info.
    public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    /// Source server fqdn for action framework.
    public var fqdnForActionFramework: Swift.String?
    /// Source server archived status.
    public var isArchived: Swift.Bool?
    /// Source server launched instance.
    public var launchedInstance: MgnClientTypes.LaunchedInstance?
    /// Source server lifecycle state.
    public var lifeCycle: MgnClientTypes.LifeCycle?
    /// Source server replication type.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// Source server properties.
    public var sourceProperties: MgnClientTypes.SourceProperties?
    /// Source server ID.
    public var sourceServerID: Swift.String?
    /// Source server Tags.
    public var tags: [Swift.String:Swift.String]?
    /// Source server user provided ID.
    public var userProvidedID: Swift.String?
    /// Source server vCenter client id.
    public var vcenterClientID: Swift.String?

    public init(
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        connectorAction: MgnClientTypes.SourceServerConnectorAction? = nil,
        dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
        fqdnForActionFramework: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
        lifeCycle: MgnClientTypes.LifeCycle? = nil,
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceProperties: MgnClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        userProvidedID: Swift.String? = nil,
        vcenterClientID: Swift.String? = nil
    )
    {
        self.applicationID = applicationID
        self.arn = arn
        self.connectorAction = connectorAction
        self.dataReplicationInfo = dataReplicationInfo
        self.fqdnForActionFramework = fqdnForActionFramework
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.replicationType = replicationType
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
        self.userProvidedID = userProvidedID
        self.vcenterClientID = vcenterClientID
    }
}

struct StopReplicationOutputBody {
    let sourceServerID: Swift.String?
    let arn: Swift.String?
    let isArchived: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
    let launchedInstance: MgnClientTypes.LaunchedInstance?
    let dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    let lifeCycle: MgnClientTypes.LifeCycle?
    let sourceProperties: MgnClientTypes.SourceProperties?
    let replicationType: MgnClientTypes.ReplicationType?
    let vcenterClientID: Swift.String?
    let applicationID: Swift.String?
    let userProvidedID: Swift.String?
    let fqdnForActionFramework: Swift.String?
    let connectorAction: MgnClientTypes.SourceServerConnectorAction?
}

extension StopReplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationID
        case arn
        case connectorAction
        case dataReplicationInfo
        case fqdnForActionFramework
        case isArchived
        case launchedInstance
        case lifeCycle
        case replicationType
        case sourceProperties
        case sourceServerID
        case tags
        case userProvidedID
        case vcenterClientID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let launchedInstanceDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchedInstance.self, forKey: .launchedInstance)
        launchedInstance = launchedInstanceDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
        let replicationTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationType.self, forKey: .replicationType)
        replicationType = replicationTypeDecoded
        let vcenterClientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcenterClientID)
        vcenterClientID = vcenterClientIDDecoded
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
        let userProvidedIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userProvidedID)
        userProvidedID = userProvidedIDDecoded
        let fqdnForActionFrameworkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fqdnForActionFramework)
        fqdnForActionFramework = fqdnForActionFrameworkDecoded
        let connectorActionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceServerConnectorAction.self, forKey: .connectorAction)
        connectorAction = connectorActionDecoded
    }
}

enum StopReplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \"CONTENT_REDACTED\")"}
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput {
    /// Tag resource by ARN.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tag resource by Tags.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MgnClientTypes {
    public enum TargetInstanceTypeRightSizingMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case basic
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetInstanceTypeRightSizingMethod] {
            return [
                .basic,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .basic: return "BASIC"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetInstanceTypeRightSizingMethod(rawValue: rawValue) ?? TargetInstanceTypeRightSizingMethod.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes.TemplateActionDocument: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionID
        case actionName
        case active
        case category
        case description
        case documentIdentifier
        case documentVersion
        case externalParameters
        case mustSucceedForCutover
        case operatingSystem
        case order
        case parameters
        case timeoutSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionID = self.actionID {
            try encodeContainer.encode(actionID, forKey: .actionID)
        }
        if let actionName = self.actionName {
            try encodeContainer.encode(actionName, forKey: .actionName)
        }
        if let active = self.active {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let category = self.category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let documentIdentifier = self.documentIdentifier {
            try encodeContainer.encode(documentIdentifier, forKey: .documentIdentifier)
        }
        if let documentVersion = self.documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let externalParameters = externalParameters {
            var externalParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .externalParameters)
            for (dictKey0, ssmDocumentExternalParameters0) in externalParameters {
                try externalParametersContainer.encode(ssmDocumentExternalParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let mustSucceedForCutover = self.mustSucceedForCutover {
            try encodeContainer.encode(mustSucceedForCutover, forKey: .mustSucceedForCutover)
        }
        if let operatingSystem = self.operatingSystem {
            try encodeContainer.encode(operatingSystem, forKey: .operatingSystem)
        }
        if let order = self.order {
            try encodeContainer.encode(order, forKey: .order)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, ssmDocumentParameters0) in parameters {
                var ssmDocumentParameters0Container = parametersContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for ssmparameterstoreparameter1 in ssmDocumentParameters0 {
                    try ssmDocumentParameters0Container.encode(ssmparameterstoreparameter1)
                }
            }
        }
        if let timeoutSeconds = self.timeoutSeconds {
            try encodeContainer.encode(timeoutSeconds, forKey: .timeoutSeconds)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionID)
        actionID = actionIDDecoded
        let actionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let documentIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentIdentifier)
        documentIdentifier = documentIdentifierDecoded
        let orderDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .order)
        order = orderDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .active)
        active = activeDecoded
        let timeoutSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutSeconds)
        timeoutSeconds = timeoutSecondsDecoded
        let mustSucceedForCutoverDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .mustSucceedForCutover)
        mustSucceedForCutover = mustSucceedForCutoverDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [MgnClientTypes.SsmParameterStoreParameter?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]()
            for (key0, ssmparameterstoreparameters0) in parametersContainer {
                var ssmparameterstoreparameters0Decoded0: [MgnClientTypes.SsmParameterStoreParameter]? = nil
                if let ssmparameterstoreparameters0 = ssmparameterstoreparameters0 {
                    ssmparameterstoreparameters0Decoded0 = [MgnClientTypes.SsmParameterStoreParameter]()
                    for structure1 in ssmparameterstoreparameters0 {
                        if let structure1 = structure1 {
                            ssmparameterstoreparameters0Decoded0?.append(structure1)
                        }
                    }
                }
                parametersDecoded0?[key0] = ssmparameterstoreparameters0Decoded0
            }
        }
        parameters = parametersDecoded0
        let operatingSystemDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
        let externalParametersContainer = try containerValues.decodeIfPresent([Swift.String: MgnClientTypes.SsmExternalParameter?].self, forKey: .externalParameters)
        var externalParametersDecoded0: [Swift.String:MgnClientTypes.SsmExternalParameter]? = nil
        if let externalParametersContainer = externalParametersContainer {
            externalParametersDecoded0 = [Swift.String:MgnClientTypes.SsmExternalParameter]()
            for (key0, ssmexternalparameter0) in externalParametersContainer {
                if let ssmexternalparameter0 = ssmexternalparameter0 {
                    externalParametersDecoded0?[key0] = ssmexternalparameter0
                }
            }
        }
        externalParameters = externalParametersDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ActionCategory.self, forKey: .category)
        category = categoryDecoded
    }
}

extension MgnClientTypes {
    public struct TemplateActionDocument {
        /// Template post migration custom action ID.
        public var actionID: Swift.String?
        /// Template post migration custom action name.
        public var actionName: Swift.String?
        /// Template post migration custom action active status.
        public var active: Swift.Bool?
        /// Template post migration custom action category.
        public var category: MgnClientTypes.ActionCategory?
        /// Template post migration custom action description.
        public var description: Swift.String?
        /// Template post migration custom action document identifier.
        public var documentIdentifier: Swift.String?
        /// Template post migration custom action document version.
        public var documentVersion: Swift.String?
        /// Template post migration custom action external parameters.
        public var externalParameters: [Swift.String:MgnClientTypes.SsmExternalParameter]?
        /// Template post migration custom action must succeed for cutover.
        public var mustSucceedForCutover: Swift.Bool?
        /// Operating system eligible for this template post migration custom action.
        public var operatingSystem: Swift.String?
        /// Template post migration custom action order.
        public var order: Swift.Int?
        /// Template post migration custom action parameters.
        public var parameters: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]?
        /// Template post migration custom action timeout in seconds.
        public var timeoutSeconds: Swift.Int?

        public init(
            actionID: Swift.String? = nil,
            actionName: Swift.String? = nil,
            active: Swift.Bool? = nil,
            category: MgnClientTypes.ActionCategory? = nil,
            description: Swift.String? = nil,
            documentIdentifier: Swift.String? = nil,
            documentVersion: Swift.String? = nil,
            externalParameters: [Swift.String:MgnClientTypes.SsmExternalParameter]? = nil,
            mustSucceedForCutover: Swift.Bool? = nil,
            operatingSystem: Swift.String? = nil,
            order: Swift.Int? = nil,
            parameters: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]? = nil,
            timeoutSeconds: Swift.Int? = nil
        )
        {
            self.actionID = actionID
            self.actionName = actionName
            self.active = active
            self.category = category
            self.description = description
            self.documentIdentifier = documentIdentifier
            self.documentVersion = documentVersion
            self.externalParameters = externalParameters
            self.mustSucceedForCutover = mustSucceedForCutover
            self.operatingSystem = operatingSystem
            self.order = order
            self.parameters = parameters
            self.timeoutSeconds = timeoutSeconds
        }
    }

}

extension MgnClientTypes.TemplateActionsRequestFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionIDs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionIDs = actionIDs {
            var actionIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actionIDs)
            for actionid0 in actionIDs {
                try actionIDsContainer.encode(actionid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .actionIDs)
        var actionIDsDecoded0:[Swift.String]? = nil
        if let actionIDsContainer = actionIDsContainer {
            actionIDsDecoded0 = [Swift.String]()
            for string0 in actionIDsContainer {
                if let string0 = string0 {
                    actionIDsDecoded0?.append(string0)
                }
            }
        }
        actionIDs = actionIDsDecoded0
    }
}

extension MgnClientTypes {
    /// Template post migration custom action filters.
    public struct TemplateActionsRequestFilters {
        /// Action IDs to filter template post migration custom actions by.
        public var actionIDs: [Swift.String]?

        public init(
            actionIDs: [Swift.String]? = nil
        )
        {
            self.actionIDs = actionIDs
        }
    }

}

extension TerminateTargetInstancesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TerminateTargetInstancesInput(accountID: \(Swift.String(describing: accountID)), sourceServerIDs: \(Swift.String(describing: sourceServerIDs)), tags: \"CONTENT_REDACTED\")"}
}

extension TerminateTargetInstancesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case sourceServerIDs
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let sourceServerIDs = sourceServerIDs {
            var sourceServerIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceServerIDs)
            for sourceserverid0 in sourceServerIDs {
                try sourceServerIDsContainer.encode(sourceserverid0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TerminateTargetInstancesInput {

    static func urlPathProvider(_ value: TerminateTargetInstancesInput) -> Swift.String? {
        return "/TerminateTargetInstances"
    }
}

public struct TerminateTargetInstancesInput {
    /// Terminate Target instance by Account ID
    public var accountID: Swift.String?
    /// Terminate Target instance by Source Server IDs.
    /// This member is required.
    public var sourceServerIDs: [Swift.String]?
    /// Terminate Target instance by Tags.
    public var tags: [Swift.String:Swift.String]?

    public init(
        accountID: Swift.String? = nil,
        sourceServerIDs: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.accountID = accountID
        self.sourceServerIDs = sourceServerIDs
        self.tags = tags
    }
}

struct TerminateTargetInstancesInputBody {
    let sourceServerIDs: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
    let accountID: Swift.String?
}

extension TerminateTargetInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case sourceServerIDs
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceServerIDs)
        var sourceServerIDsDecoded0:[Swift.String]? = nil
        if let sourceServerIDsContainer = sourceServerIDsContainer {
            sourceServerIDsDecoded0 = [Swift.String]()
            for string0 in sourceServerIDsContainer {
                if let string0 = string0 {
                    sourceServerIDsDecoded0?.append(string0)
                }
            }
        }
        sourceServerIDs = sourceServerIDsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension TerminateTargetInstancesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TerminateTargetInstancesOutputBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct TerminateTargetInstancesOutput {
    /// Terminate Target instance Job response.
    public var job: MgnClientTypes.Job?

    public init(
        job: MgnClientTypes.Job? = nil
    )
    {
        self.job = job
    }
}

struct TerminateTargetInstancesOutputBody {
    let job: MgnClientTypes.Job?
}

extension TerminateTargetInstancesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(MgnClientTypes.Job.self, forKey: .job)
        job = jobDecoded
    }
}

enum TerminateTargetInstancesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Reached throttling quota exception.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Reached throttling quota exception.
        public internal(set) var quotaCode: Swift.String? = nil
        /// Reached throttling quota exception will retry after x seconds.
        public internal(set) var retryAfterSeconds: Swift.String? = nil
        /// Reached throttling quota exception service code.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody {
    let message: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension UnarchiveApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case applicationID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let applicationID = self.applicationID {
            try encodeContainer.encode(applicationID, forKey: .applicationID)
        }
    }
}

extension UnarchiveApplicationInput {

    static func urlPathProvider(_ value: UnarchiveApplicationInput) -> Swift.String? {
        return "/UnarchiveApplication"
    }
}

public struct UnarchiveApplicationInput {
    /// Account ID.
    public var accountID: Swift.String?
    /// Application ID.
    /// This member is required.
    public var applicationID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        applicationID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.applicationID = applicationID
    }
}

struct UnarchiveApplicationInputBody {
    let applicationID: Swift.String?
    let accountID: Swift.String?
}

extension UnarchiveApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case applicationID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension UnarchiveApplicationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnarchiveApplicationOutput(applicationAggregatedStatus: \(Swift.String(describing: applicationAggregatedStatus)), applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), creationDateTime: \(Swift.String(describing: creationDateTime)), description: \(Swift.String(describing: description)), isArchived: \(Swift.String(describing: isArchived)), lastModifiedDateTime: \(Swift.String(describing: lastModifiedDateTime)), name: \(Swift.String(describing: name)), waveID: \(Swift.String(describing: waveID)), tags: \"CONTENT_REDACTED\")"}
}

extension UnarchiveApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnarchiveApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationAggregatedStatus = output.applicationAggregatedStatus
            self.applicationID = output.applicationID
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.isArchived = output.isArchived
            self.lastModifiedDateTime = output.lastModifiedDateTime
            self.name = output.name
            self.tags = output.tags
            self.waveID = output.waveID
        } else {
            self.applicationAggregatedStatus = nil
            self.applicationID = nil
            self.arn = nil
            self.creationDateTime = nil
            self.description = nil
            self.isArchived = nil
            self.lastModifiedDateTime = nil
            self.name = nil
            self.tags = nil
            self.waveID = nil
        }
    }
}

public struct UnarchiveApplicationOutput {
    /// Application aggregated status.
    public var applicationAggregatedStatus: MgnClientTypes.ApplicationAggregatedStatus?
    /// Application ID.
    public var applicationID: Swift.String?
    /// Application ARN.
    public var arn: Swift.String?
    /// Application creation dateTime.
    public var creationDateTime: Swift.String?
    /// Application description.
    public var description: Swift.String?
    /// Application archival status.
    public var isArchived: Swift.Bool?
    /// Application last modified dateTime.
    public var lastModifiedDateTime: Swift.String?
    /// Application name.
    public var name: Swift.String?
    /// Application tags.
    public var tags: [Swift.String:Swift.String]?
    /// Application wave ID.
    public var waveID: Swift.String?

    public init(
        applicationAggregatedStatus: MgnClientTypes.ApplicationAggregatedStatus? = nil,
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        creationDateTime: Swift.String? = nil,
        description: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        lastModifiedDateTime: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        waveID: Swift.String? = nil
    )
    {
        self.applicationAggregatedStatus = applicationAggregatedStatus
        self.applicationID = applicationID
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.description = description
        self.isArchived = isArchived
        self.lastModifiedDateTime = lastModifiedDateTime
        self.name = name
        self.tags = tags
        self.waveID = waveID
    }
}

struct UnarchiveApplicationOutputBody {
    let applicationID: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let isArchived: Swift.Bool?
    let applicationAggregatedStatus: MgnClientTypes.ApplicationAggregatedStatus?
    let creationDateTime: Swift.String?
    let lastModifiedDateTime: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let waveID: Swift.String?
}

extension UnarchiveApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationAggregatedStatus
        case applicationID
        case arn
        case creationDateTime
        case description
        case isArchived
        case lastModifiedDateTime
        case name
        case tags
        case waveID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let applicationAggregatedStatusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ApplicationAggregatedStatus.self, forKey: .applicationAggregatedStatus)
        applicationAggregatedStatus = applicationAggregatedStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastModifiedDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedDateTime)
        lastModifiedDateTime = lastModifiedDateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let waveIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .waveID)
        waveID = waveIDDecoded
    }
}

enum UnarchiveApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UnarchiveWaveInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case waveID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let waveID = self.waveID {
            try encodeContainer.encode(waveID, forKey: .waveID)
        }
    }
}

extension UnarchiveWaveInput {

    static func urlPathProvider(_ value: UnarchiveWaveInput) -> Swift.String? {
        return "/UnarchiveWave"
    }
}

public struct UnarchiveWaveInput {
    /// Account ID.
    public var accountID: Swift.String?
    /// Wave ID.
    /// This member is required.
    public var waveID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        waveID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.waveID = waveID
    }
}

struct UnarchiveWaveInputBody {
    let waveID: Swift.String?
    let accountID: Swift.String?
}

extension UnarchiveWaveInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case waveID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let waveIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .waveID)
        waveID = waveIDDecoded
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension UnarchiveWaveOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnarchiveWaveOutput(arn: \(Swift.String(describing: arn)), creationDateTime: \(Swift.String(describing: creationDateTime)), description: \(Swift.String(describing: description)), isArchived: \(Swift.String(describing: isArchived)), lastModifiedDateTime: \(Swift.String(describing: lastModifiedDateTime)), name: \(Swift.String(describing: name)), waveAggregatedStatus: \(Swift.String(describing: waveAggregatedStatus)), waveID: \(Swift.String(describing: waveID)), tags: \"CONTENT_REDACTED\")"}
}

extension UnarchiveWaveOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnarchiveWaveOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.isArchived = output.isArchived
            self.lastModifiedDateTime = output.lastModifiedDateTime
            self.name = output.name
            self.tags = output.tags
            self.waveAggregatedStatus = output.waveAggregatedStatus
            self.waveID = output.waveID
        } else {
            self.arn = nil
            self.creationDateTime = nil
            self.description = nil
            self.isArchived = nil
            self.lastModifiedDateTime = nil
            self.name = nil
            self.tags = nil
            self.waveAggregatedStatus = nil
            self.waveID = nil
        }
    }
}

public struct UnarchiveWaveOutput {
    /// Wave ARN.
    public var arn: Swift.String?
    /// Wave creation dateTime.
    public var creationDateTime: Swift.String?
    /// Wave description.
    public var description: Swift.String?
    /// Wave archival status.
    public var isArchived: Swift.Bool?
    /// Wave last modified dateTime.
    public var lastModifiedDateTime: Swift.String?
    /// Wave name.
    public var name: Swift.String?
    /// Wave tags.
    public var tags: [Swift.String:Swift.String]?
    /// Wave aggregated status.
    public var waveAggregatedStatus: MgnClientTypes.WaveAggregatedStatus?
    /// Wave ID.
    public var waveID: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationDateTime: Swift.String? = nil,
        description: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        lastModifiedDateTime: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        waveAggregatedStatus: MgnClientTypes.WaveAggregatedStatus? = nil,
        waveID: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.description = description
        self.isArchived = isArchived
        self.lastModifiedDateTime = lastModifiedDateTime
        self.name = name
        self.tags = tags
        self.waveAggregatedStatus = waveAggregatedStatus
        self.waveID = waveID
    }
}

struct UnarchiveWaveOutputBody {
    let waveID: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let isArchived: Swift.Bool?
    let waveAggregatedStatus: MgnClientTypes.WaveAggregatedStatus?
    let creationDateTime: Swift.String?
    let lastModifiedDateTime: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension UnarchiveWaveOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
        case description
        case isArchived
        case lastModifiedDateTime
        case name
        case tags
        case waveAggregatedStatus
        case waveID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let waveIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .waveID)
        waveID = waveIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let waveAggregatedStatusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.WaveAggregatedStatus.self, forKey: .waveAggregatedStatus)
        waveAggregatedStatus = waveAggregatedStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastModifiedDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedDateTime)
        lastModifiedDateTime = lastModifiedDateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum UnarchiveWaveOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UninitializedAccountException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UninitializedAccountExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Uninitialized account exception.
public struct UninitializedAccountException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UninitializedAccountException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct UninitializedAccountExceptionBody {
    let message: Swift.String?
    let code: Swift.String?
}

extension UninitializedAccountExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \"CONTENT_REDACTED\")"}
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput {
    /// Untag resource by ARN.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Untag resource by Keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case applicationID
        case description
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let applicationID = self.applicationID {
            try encodeContainer.encode(applicationID, forKey: .applicationID)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateApplicationInput {

    static func urlPathProvider(_ value: UpdateApplicationInput) -> Swift.String? {
        return "/UpdateApplication"
    }
}

public struct UpdateApplicationInput {
    /// Account ID.
    public var accountID: Swift.String?
    /// Application ID.
    /// This member is required.
    public var applicationID: Swift.String?
    /// Application description.
    public var description: Swift.String?
    /// Application name.
    public var name: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        applicationID: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.applicationID = applicationID
        self.description = description
        self.name = name
    }
}

struct UpdateApplicationInputBody {
    let applicationID: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let accountID: Swift.String?
}

extension UpdateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case applicationID
        case description
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension UpdateApplicationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateApplicationOutput(applicationAggregatedStatus: \(Swift.String(describing: applicationAggregatedStatus)), applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), creationDateTime: \(Swift.String(describing: creationDateTime)), description: \(Swift.String(describing: description)), isArchived: \(Swift.String(describing: isArchived)), lastModifiedDateTime: \(Swift.String(describing: lastModifiedDateTime)), name: \(Swift.String(describing: name)), waveID: \(Swift.String(describing: waveID)), tags: \"CONTENT_REDACTED\")"}
}

extension UpdateApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationAggregatedStatus = output.applicationAggregatedStatus
            self.applicationID = output.applicationID
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.isArchived = output.isArchived
            self.lastModifiedDateTime = output.lastModifiedDateTime
            self.name = output.name
            self.tags = output.tags
            self.waveID = output.waveID
        } else {
            self.applicationAggregatedStatus = nil
            self.applicationID = nil
            self.arn = nil
            self.creationDateTime = nil
            self.description = nil
            self.isArchived = nil
            self.lastModifiedDateTime = nil
            self.name = nil
            self.tags = nil
            self.waveID = nil
        }
    }
}

public struct UpdateApplicationOutput {
    /// Application aggregated status.
    public var applicationAggregatedStatus: MgnClientTypes.ApplicationAggregatedStatus?
    /// Application ID.
    public var applicationID: Swift.String?
    /// Application ARN.
    public var arn: Swift.String?
    /// Application creation dateTime.
    public var creationDateTime: Swift.String?
    /// Application description.
    public var description: Swift.String?
    /// Application archival status.
    public var isArchived: Swift.Bool?
    /// Application last modified dateTime.
    public var lastModifiedDateTime: Swift.String?
    /// Application name.
    public var name: Swift.String?
    /// Application tags.
    public var tags: [Swift.String:Swift.String]?
    /// Application wave ID.
    public var waveID: Swift.String?

    public init(
        applicationAggregatedStatus: MgnClientTypes.ApplicationAggregatedStatus? = nil,
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        creationDateTime: Swift.String? = nil,
        description: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        lastModifiedDateTime: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        waveID: Swift.String? = nil
    )
    {
        self.applicationAggregatedStatus = applicationAggregatedStatus
        self.applicationID = applicationID
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.description = description
        self.isArchived = isArchived
        self.lastModifiedDateTime = lastModifiedDateTime
        self.name = name
        self.tags = tags
        self.waveID = waveID
    }
}

struct UpdateApplicationOutputBody {
    let applicationID: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let isArchived: Swift.Bool?
    let applicationAggregatedStatus: MgnClientTypes.ApplicationAggregatedStatus?
    let creationDateTime: Swift.String?
    let lastModifiedDateTime: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let waveID: Swift.String?
}

extension UpdateApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationAggregatedStatus
        case applicationID
        case arn
        case creationDateTime
        case description
        case isArchived
        case lastModifiedDateTime
        case name
        case tags
        case waveID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let applicationAggregatedStatusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ApplicationAggregatedStatus.self, forKey: .applicationAggregatedStatus)
        applicationAggregatedStatus = applicationAggregatedStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastModifiedDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedDateTime)
        lastModifiedDateTime = lastModifiedDateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let waveIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .waveID)
        waveID = waveIDDecoded
    }
}

enum UpdateApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateConnectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorID
        case name
        case ssmCommandConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorID = self.connectorID {
            try encodeContainer.encode(connectorID, forKey: .connectorID)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ssmCommandConfig = self.ssmCommandConfig {
            try encodeContainer.encode(ssmCommandConfig, forKey: .ssmCommandConfig)
        }
    }
}

extension UpdateConnectorInput {

    static func urlPathProvider(_ value: UpdateConnectorInput) -> Swift.String? {
        return "/UpdateConnector"
    }
}

public struct UpdateConnectorInput {
    /// Update Connector request connector ID.
    /// This member is required.
    public var connectorID: Swift.String?
    /// Update Connector request name.
    public var name: Swift.String?
    /// Update Connector request SSM command config.
    public var ssmCommandConfig: MgnClientTypes.ConnectorSsmCommandConfig?

    public init(
        connectorID: Swift.String? = nil,
        name: Swift.String? = nil,
        ssmCommandConfig: MgnClientTypes.ConnectorSsmCommandConfig? = nil
    )
    {
        self.connectorID = connectorID
        self.name = name
        self.ssmCommandConfig = ssmCommandConfig
    }
}

struct UpdateConnectorInputBody {
    let connectorID: Swift.String?
    let name: Swift.String?
    let ssmCommandConfig: MgnClientTypes.ConnectorSsmCommandConfig?
}

extension UpdateConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorID
        case name
        case ssmCommandConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorID)
        connectorID = connectorIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ssmCommandConfigDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ConnectorSsmCommandConfig.self, forKey: .ssmCommandConfig)
        ssmCommandConfig = ssmCommandConfigDecoded
    }
}

extension UpdateConnectorOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateConnectorOutput(arn: \(Swift.String(describing: arn)), connectorID: \(Swift.String(describing: connectorID)), name: \(Swift.String(describing: name)), ssmCommandConfig: \(Swift.String(describing: ssmCommandConfig)), ssmInstanceID: \(Swift.String(describing: ssmInstanceID)), tags: \"CONTENT_REDACTED\")"}
}

extension UpdateConnectorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateConnectorOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.connectorID = output.connectorID
            self.name = output.name
            self.ssmCommandConfig = output.ssmCommandConfig
            self.ssmInstanceID = output.ssmInstanceID
            self.tags = output.tags
        } else {
            self.arn = nil
            self.connectorID = nil
            self.name = nil
            self.ssmCommandConfig = nil
            self.ssmInstanceID = nil
            self.tags = nil
        }
    }
}

public struct UpdateConnectorOutput {
    /// Connector arn.
    public var arn: Swift.String?
    /// Connector ID.
    public var connectorID: Swift.String?
    /// Connector name.
    public var name: Swift.String?
    /// Connector SSM command config.
    public var ssmCommandConfig: MgnClientTypes.ConnectorSsmCommandConfig?
    /// Connector SSM instance ID.
    public var ssmInstanceID: Swift.String?
    /// Connector tags.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        connectorID: Swift.String? = nil,
        name: Swift.String? = nil,
        ssmCommandConfig: MgnClientTypes.ConnectorSsmCommandConfig? = nil,
        ssmInstanceID: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.connectorID = connectorID
        self.name = name
        self.ssmCommandConfig = ssmCommandConfig
        self.ssmInstanceID = ssmInstanceID
        self.tags = tags
    }
}

struct UpdateConnectorOutputBody {
    let connectorID: Swift.String?
    let name: Swift.String?
    let ssmInstanceID: Swift.String?
    let arn: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let ssmCommandConfig: MgnClientTypes.ConnectorSsmCommandConfig?
}

extension UpdateConnectorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case connectorID
        case name
        case ssmCommandConfig
        case ssmInstanceID
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorID)
        connectorID = connectorIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ssmInstanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ssmInstanceID)
        ssmInstanceID = ssmInstanceIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let ssmCommandConfigDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ConnectorSsmCommandConfig.self, forKey: .ssmCommandConfig)
        ssmCommandConfig = ssmCommandConfigDecoded
    }
}

enum UpdateConnectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateLaunchConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case bootMode
        case copyPrivateIp
        case copyTags
        case enableMapAutoTagging
        case launchDisposition
        case licensing
        case mapAutoTaggingMpeID
        case name
        case postLaunchActions
        case sourceServerID
        case targetInstanceTypeRightSizingMethod
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let bootMode = self.bootMode {
            try encodeContainer.encode(bootMode.rawValue, forKey: .bootMode)
        }
        if let copyPrivateIp = self.copyPrivateIp {
            try encodeContainer.encode(copyPrivateIp, forKey: .copyPrivateIp)
        }
        if let copyTags = self.copyTags {
            try encodeContainer.encode(copyTags, forKey: .copyTags)
        }
        if let enableMapAutoTagging = self.enableMapAutoTagging {
            try encodeContainer.encode(enableMapAutoTagging, forKey: .enableMapAutoTagging)
        }
        if let launchDisposition = self.launchDisposition {
            try encodeContainer.encode(launchDisposition.rawValue, forKey: .launchDisposition)
        }
        if let licensing = self.licensing {
            try encodeContainer.encode(licensing, forKey: .licensing)
        }
        if let mapAutoTaggingMpeID = self.mapAutoTaggingMpeID {
            try encodeContainer.encode(mapAutoTaggingMpeID, forKey: .mapAutoTaggingMpeID)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let postLaunchActions = self.postLaunchActions {
            try encodeContainer.encode(postLaunchActions, forKey: .postLaunchActions)
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
        if let targetInstanceTypeRightSizingMethod = self.targetInstanceTypeRightSizingMethod {
            try encodeContainer.encode(targetInstanceTypeRightSizingMethod.rawValue, forKey: .targetInstanceTypeRightSizingMethod)
        }
    }
}

extension UpdateLaunchConfigurationInput {

    static func urlPathProvider(_ value: UpdateLaunchConfigurationInput) -> Swift.String? {
        return "/UpdateLaunchConfiguration"
    }
}

public struct UpdateLaunchConfigurationInput {
    /// Update Launch configuration Account ID.
    public var accountID: Swift.String?
    /// Update Launch configuration boot mode request.
    public var bootMode: MgnClientTypes.BootMode?
    /// Update Launch configuration copy Private IP request.
    public var copyPrivateIp: Swift.Bool?
    /// Update Launch configuration copy Tags request.
    public var copyTags: Swift.Bool?
    /// Enable map auto tagging.
    public var enableMapAutoTagging: Swift.Bool?
    /// Update Launch configuration launch disposition request.
    public var launchDisposition: MgnClientTypes.LaunchDisposition?
    /// Update Launch configuration licensing request.
    public var licensing: MgnClientTypes.Licensing?
    /// Launch configuration map auto tagging MPE ID.
    public var mapAutoTaggingMpeID: Swift.String?
    /// Update Launch configuration name request.
    public var name: Swift.String?
    /// Post Launch Actions to executed on the Test or Cutover instance.
    public var postLaunchActions: MgnClientTypes.PostLaunchActions?
    /// Update Launch configuration by Source Server ID request.
    /// This member is required.
    public var sourceServerID: Swift.String?
    /// Update Launch configuration Target instance right sizing request.
    public var targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?

    public init(
        accountID: Swift.String? = nil,
        bootMode: MgnClientTypes.BootMode? = nil,
        copyPrivateIp: Swift.Bool? = nil,
        copyTags: Swift.Bool? = nil,
        enableMapAutoTagging: Swift.Bool? = nil,
        launchDisposition: MgnClientTypes.LaunchDisposition? = nil,
        licensing: MgnClientTypes.Licensing? = nil,
        mapAutoTaggingMpeID: Swift.String? = nil,
        name: Swift.String? = nil,
        postLaunchActions: MgnClientTypes.PostLaunchActions? = nil,
        sourceServerID: Swift.String? = nil,
        targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod? = nil
    )
    {
        self.accountID = accountID
        self.bootMode = bootMode
        self.copyPrivateIp = copyPrivateIp
        self.copyTags = copyTags
        self.enableMapAutoTagging = enableMapAutoTagging
        self.launchDisposition = launchDisposition
        self.licensing = licensing
        self.mapAutoTaggingMpeID = mapAutoTaggingMpeID
        self.name = name
        self.postLaunchActions = postLaunchActions
        self.sourceServerID = sourceServerID
        self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
    }
}

struct UpdateLaunchConfigurationInputBody {
    let sourceServerID: Swift.String?
    let name: Swift.String?
    let launchDisposition: MgnClientTypes.LaunchDisposition?
    let targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?
    let copyPrivateIp: Swift.Bool?
    let copyTags: Swift.Bool?
    let licensing: MgnClientTypes.Licensing?
    let bootMode: MgnClientTypes.BootMode?
    let postLaunchActions: MgnClientTypes.PostLaunchActions?
    let enableMapAutoTagging: Swift.Bool?
    let mapAutoTaggingMpeID: Swift.String?
    let accountID: Swift.String?
}

extension UpdateLaunchConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case bootMode
        case copyPrivateIp
        case copyTags
        case enableMapAutoTagging
        case launchDisposition
        case licensing
        case mapAutoTaggingMpeID
        case name
        case postLaunchActions
        case sourceServerID
        case targetInstanceTypeRightSizingMethod
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let launchDispositionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchDisposition.self, forKey: .launchDisposition)
        launchDisposition = launchDispositionDecoded
        let targetInstanceTypeRightSizingMethodDecoded = try containerValues.decodeIfPresent(MgnClientTypes.TargetInstanceTypeRightSizingMethod.self, forKey: .targetInstanceTypeRightSizingMethod)
        targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethodDecoded
        let copyPrivateIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyPrivateIp)
        copyPrivateIp = copyPrivateIpDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let licensingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.Licensing.self, forKey: .licensing)
        licensing = licensingDecoded
        let bootModeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.BootMode.self, forKey: .bootMode)
        bootMode = bootModeDecoded
        let postLaunchActionsDecoded = try containerValues.decodeIfPresent(MgnClientTypes.PostLaunchActions.self, forKey: .postLaunchActions)
        postLaunchActions = postLaunchActionsDecoded
        let enableMapAutoTaggingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableMapAutoTagging)
        enableMapAutoTagging = enableMapAutoTaggingDecoded
        let mapAutoTaggingMpeIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapAutoTaggingMpeID)
        mapAutoTaggingMpeID = mapAutoTaggingMpeIDDecoded
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension UpdateLaunchConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateLaunchConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.bootMode = output.bootMode
            self.copyPrivateIp = output.copyPrivateIp
            self.copyTags = output.copyTags
            self.ec2LaunchTemplateID = output.ec2LaunchTemplateID
            self.enableMapAutoTagging = output.enableMapAutoTagging
            self.launchDisposition = output.launchDisposition
            self.licensing = output.licensing
            self.mapAutoTaggingMpeID = output.mapAutoTaggingMpeID
            self.name = output.name
            self.postLaunchActions = output.postLaunchActions
            self.sourceServerID = output.sourceServerID
            self.targetInstanceTypeRightSizingMethod = output.targetInstanceTypeRightSizingMethod
        } else {
            self.bootMode = nil
            self.copyPrivateIp = nil
            self.copyTags = nil
            self.ec2LaunchTemplateID = nil
            self.enableMapAutoTagging = nil
            self.launchDisposition = nil
            self.licensing = nil
            self.mapAutoTaggingMpeID = nil
            self.name = nil
            self.postLaunchActions = nil
            self.sourceServerID = nil
            self.targetInstanceTypeRightSizingMethod = nil
        }
    }
}

public struct UpdateLaunchConfigurationOutput {
    /// Launch configuration boot mode.
    public var bootMode: MgnClientTypes.BootMode?
    /// Copy Private IP during Launch Configuration.
    public var copyPrivateIp: Swift.Bool?
    /// Copy Tags during Launch Configuration.
    public var copyTags: Swift.Bool?
    /// Launch configuration EC2 Launch template ID.
    public var ec2LaunchTemplateID: Swift.String?
    /// Enable map auto tagging.
    public var enableMapAutoTagging: Swift.Bool?
    /// Launch disposition for launch configuration.
    public var launchDisposition: MgnClientTypes.LaunchDisposition?
    /// Launch configuration OS licensing.
    public var licensing: MgnClientTypes.Licensing?
    /// Map auto tagging MPE ID.
    public var mapAutoTaggingMpeID: Swift.String?
    /// Launch configuration name.
    public var name: Swift.String?
    /// Post Launch Actions to executed on the Test or Cutover instance.
    public var postLaunchActions: MgnClientTypes.PostLaunchActions?
    /// Launch configuration Source Server ID.
    public var sourceServerID: Swift.String?
    /// Launch configuration Target instance type right sizing method.
    public var targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?

    public init(
        bootMode: MgnClientTypes.BootMode? = nil,
        copyPrivateIp: Swift.Bool? = nil,
        copyTags: Swift.Bool? = nil,
        ec2LaunchTemplateID: Swift.String? = nil,
        enableMapAutoTagging: Swift.Bool? = nil,
        launchDisposition: MgnClientTypes.LaunchDisposition? = nil,
        licensing: MgnClientTypes.Licensing? = nil,
        mapAutoTaggingMpeID: Swift.String? = nil,
        name: Swift.String? = nil,
        postLaunchActions: MgnClientTypes.PostLaunchActions? = nil,
        sourceServerID: Swift.String? = nil,
        targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod? = nil
    )
    {
        self.bootMode = bootMode
        self.copyPrivateIp = copyPrivateIp
        self.copyTags = copyTags
        self.ec2LaunchTemplateID = ec2LaunchTemplateID
        self.enableMapAutoTagging = enableMapAutoTagging
        self.launchDisposition = launchDisposition
        self.licensing = licensing
        self.mapAutoTaggingMpeID = mapAutoTaggingMpeID
        self.name = name
        self.postLaunchActions = postLaunchActions
        self.sourceServerID = sourceServerID
        self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
    }
}

struct UpdateLaunchConfigurationOutputBody {
    let sourceServerID: Swift.String?
    let name: Swift.String?
    let ec2LaunchTemplateID: Swift.String?
    let launchDisposition: MgnClientTypes.LaunchDisposition?
    let targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?
    let copyPrivateIp: Swift.Bool?
    let copyTags: Swift.Bool?
    let licensing: MgnClientTypes.Licensing?
    let bootMode: MgnClientTypes.BootMode?
    let postLaunchActions: MgnClientTypes.PostLaunchActions?
    let enableMapAutoTagging: Swift.Bool?
    let mapAutoTaggingMpeID: Swift.String?
}

extension UpdateLaunchConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bootMode
        case copyPrivateIp
        case copyTags
        case ec2LaunchTemplateID
        case enableMapAutoTagging
        case launchDisposition
        case licensing
        case mapAutoTaggingMpeID
        case name
        case postLaunchActions
        case sourceServerID
        case targetInstanceTypeRightSizingMethod
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ec2LaunchTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2LaunchTemplateID)
        ec2LaunchTemplateID = ec2LaunchTemplateIDDecoded
        let launchDispositionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchDisposition.self, forKey: .launchDisposition)
        launchDisposition = launchDispositionDecoded
        let targetInstanceTypeRightSizingMethodDecoded = try containerValues.decodeIfPresent(MgnClientTypes.TargetInstanceTypeRightSizingMethod.self, forKey: .targetInstanceTypeRightSizingMethod)
        targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethodDecoded
        let copyPrivateIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyPrivateIp)
        copyPrivateIp = copyPrivateIpDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let licensingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.Licensing.self, forKey: .licensing)
        licensing = licensingDecoded
        let bootModeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.BootMode.self, forKey: .bootMode)
        bootMode = bootModeDecoded
        let postLaunchActionsDecoded = try containerValues.decodeIfPresent(MgnClientTypes.PostLaunchActions.self, forKey: .postLaunchActions)
        postLaunchActions = postLaunchActionsDecoded
        let enableMapAutoTaggingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableMapAutoTagging)
        enableMapAutoTagging = enableMapAutoTaggingDecoded
        let mapAutoTaggingMpeIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapAutoTaggingMpeID)
        mapAutoTaggingMpeID = mapAutoTaggingMpeIDDecoded
    }
}

enum UpdateLaunchConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateLaunchConfigurationTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatePublicIpAddress
        case bootMode
        case copyPrivateIp
        case copyTags
        case enableMapAutoTagging
        case largeVolumeConf
        case launchConfigurationTemplateID
        case launchDisposition
        case licensing
        case mapAutoTaggingMpeID
        case postLaunchActions
        case smallVolumeConf
        case smallVolumeMaxSize
        case targetInstanceTypeRightSizingMethod
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatePublicIpAddress = self.associatePublicIpAddress {
            try encodeContainer.encode(associatePublicIpAddress, forKey: .associatePublicIpAddress)
        }
        if let bootMode = self.bootMode {
            try encodeContainer.encode(bootMode.rawValue, forKey: .bootMode)
        }
        if let copyPrivateIp = self.copyPrivateIp {
            try encodeContainer.encode(copyPrivateIp, forKey: .copyPrivateIp)
        }
        if let copyTags = self.copyTags {
            try encodeContainer.encode(copyTags, forKey: .copyTags)
        }
        if let enableMapAutoTagging = self.enableMapAutoTagging {
            try encodeContainer.encode(enableMapAutoTagging, forKey: .enableMapAutoTagging)
        }
        if let largeVolumeConf = self.largeVolumeConf {
            try encodeContainer.encode(largeVolumeConf, forKey: .largeVolumeConf)
        }
        if let launchConfigurationTemplateID = self.launchConfigurationTemplateID {
            try encodeContainer.encode(launchConfigurationTemplateID, forKey: .launchConfigurationTemplateID)
        }
        if let launchDisposition = self.launchDisposition {
            try encodeContainer.encode(launchDisposition.rawValue, forKey: .launchDisposition)
        }
        if let licensing = self.licensing {
            try encodeContainer.encode(licensing, forKey: .licensing)
        }
        if let mapAutoTaggingMpeID = self.mapAutoTaggingMpeID {
            try encodeContainer.encode(mapAutoTaggingMpeID, forKey: .mapAutoTaggingMpeID)
        }
        if let postLaunchActions = self.postLaunchActions {
            try encodeContainer.encode(postLaunchActions, forKey: .postLaunchActions)
        }
        if let smallVolumeConf = self.smallVolumeConf {
            try encodeContainer.encode(smallVolumeConf, forKey: .smallVolumeConf)
        }
        if smallVolumeMaxSize != 0 {
            try encodeContainer.encode(smallVolumeMaxSize, forKey: .smallVolumeMaxSize)
        }
        if let targetInstanceTypeRightSizingMethod = self.targetInstanceTypeRightSizingMethod {
            try encodeContainer.encode(targetInstanceTypeRightSizingMethod.rawValue, forKey: .targetInstanceTypeRightSizingMethod)
        }
    }
}

extension UpdateLaunchConfigurationTemplateInput {

    static func urlPathProvider(_ value: UpdateLaunchConfigurationTemplateInput) -> Swift.String? {
        return "/UpdateLaunchConfigurationTemplate"
    }
}

public struct UpdateLaunchConfigurationTemplateInput {
    /// Associate public Ip address.
    public var associatePublicIpAddress: Swift.Bool?
    /// Launch configuration template boot mode.
    public var bootMode: MgnClientTypes.BootMode?
    /// Copy private Ip.
    public var copyPrivateIp: Swift.Bool?
    /// Copy tags.
    public var copyTags: Swift.Bool?
    /// Enable map auto tagging.
    public var enableMapAutoTagging: Swift.Bool?
    /// Large volume config.
    public var largeVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
    /// Launch Configuration Template ID.
    /// This member is required.
    public var launchConfigurationTemplateID: Swift.String?
    /// Launch disposition.
    public var launchDisposition: MgnClientTypes.LaunchDisposition?
    /// Configure Licensing.
    public var licensing: MgnClientTypes.Licensing?
    /// Launch configuration template map auto tagging MPE ID.
    public var mapAutoTaggingMpeID: Swift.String?
    /// Post Launch Action to execute on the Test or Cutover instance.
    public var postLaunchActions: MgnClientTypes.PostLaunchActions?
    /// Small volume config.
    public var smallVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
    /// Small volume maximum size.
    public var smallVolumeMaxSize: Swift.Int
    /// Target instance type right-sizing method.
    public var targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?

    public init(
        associatePublicIpAddress: Swift.Bool? = nil,
        bootMode: MgnClientTypes.BootMode? = nil,
        copyPrivateIp: Swift.Bool? = nil,
        copyTags: Swift.Bool? = nil,
        enableMapAutoTagging: Swift.Bool? = nil,
        largeVolumeConf: MgnClientTypes.LaunchTemplateDiskConf? = nil,
        launchConfigurationTemplateID: Swift.String? = nil,
        launchDisposition: MgnClientTypes.LaunchDisposition? = nil,
        licensing: MgnClientTypes.Licensing? = nil,
        mapAutoTaggingMpeID: Swift.String? = nil,
        postLaunchActions: MgnClientTypes.PostLaunchActions? = nil,
        smallVolumeConf: MgnClientTypes.LaunchTemplateDiskConf? = nil,
        smallVolumeMaxSize: Swift.Int = 0,
        targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod? = nil
    )
    {
        self.associatePublicIpAddress = associatePublicIpAddress
        self.bootMode = bootMode
        self.copyPrivateIp = copyPrivateIp
        self.copyTags = copyTags
        self.enableMapAutoTagging = enableMapAutoTagging
        self.largeVolumeConf = largeVolumeConf
        self.launchConfigurationTemplateID = launchConfigurationTemplateID
        self.launchDisposition = launchDisposition
        self.licensing = licensing
        self.mapAutoTaggingMpeID = mapAutoTaggingMpeID
        self.postLaunchActions = postLaunchActions
        self.smallVolumeConf = smallVolumeConf
        self.smallVolumeMaxSize = smallVolumeMaxSize
        self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
    }
}

struct UpdateLaunchConfigurationTemplateInputBody {
    let launchConfigurationTemplateID: Swift.String?
    let postLaunchActions: MgnClientTypes.PostLaunchActions?
    let enableMapAutoTagging: Swift.Bool?
    let mapAutoTaggingMpeID: Swift.String?
    let launchDisposition: MgnClientTypes.LaunchDisposition?
    let targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?
    let copyPrivateIp: Swift.Bool?
    let associatePublicIpAddress: Swift.Bool?
    let copyTags: Swift.Bool?
    let licensing: MgnClientTypes.Licensing?
    let bootMode: MgnClientTypes.BootMode?
    let smallVolumeMaxSize: Swift.Int
    let smallVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
    let largeVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
}

extension UpdateLaunchConfigurationTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatePublicIpAddress
        case bootMode
        case copyPrivateIp
        case copyTags
        case enableMapAutoTagging
        case largeVolumeConf
        case launchConfigurationTemplateID
        case launchDisposition
        case licensing
        case mapAutoTaggingMpeID
        case postLaunchActions
        case smallVolumeConf
        case smallVolumeMaxSize
        case targetInstanceTypeRightSizingMethod
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchConfigurationTemplateID)
        launchConfigurationTemplateID = launchConfigurationTemplateIDDecoded
        let postLaunchActionsDecoded = try containerValues.decodeIfPresent(MgnClientTypes.PostLaunchActions.self, forKey: .postLaunchActions)
        postLaunchActions = postLaunchActionsDecoded
        let enableMapAutoTaggingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableMapAutoTagging)
        enableMapAutoTagging = enableMapAutoTaggingDecoded
        let mapAutoTaggingMpeIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapAutoTaggingMpeID)
        mapAutoTaggingMpeID = mapAutoTaggingMpeIDDecoded
        let launchDispositionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchDisposition.self, forKey: .launchDisposition)
        launchDisposition = launchDispositionDecoded
        let targetInstanceTypeRightSizingMethodDecoded = try containerValues.decodeIfPresent(MgnClientTypes.TargetInstanceTypeRightSizingMethod.self, forKey: .targetInstanceTypeRightSizingMethod)
        targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethodDecoded
        let copyPrivateIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyPrivateIp)
        copyPrivateIp = copyPrivateIpDecoded
        let associatePublicIpAddressDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associatePublicIpAddress)
        associatePublicIpAddress = associatePublicIpAddressDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let licensingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.Licensing.self, forKey: .licensing)
        licensing = licensingDecoded
        let bootModeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.BootMode.self, forKey: .bootMode)
        bootMode = bootModeDecoded
        let smallVolumeMaxSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .smallVolumeMaxSize) ?? 0
        smallVolumeMaxSize = smallVolumeMaxSizeDecoded
        let smallVolumeConfDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchTemplateDiskConf.self, forKey: .smallVolumeConf)
        smallVolumeConf = smallVolumeConfDecoded
        let largeVolumeConfDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchTemplateDiskConf.self, forKey: .largeVolumeConf)
        largeVolumeConf = largeVolumeConfDecoded
    }
}

extension UpdateLaunchConfigurationTemplateOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateLaunchConfigurationTemplateOutput(arn: \(Swift.String(describing: arn)), associatePublicIpAddress: \(Swift.String(describing: associatePublicIpAddress)), bootMode: \(Swift.String(describing: bootMode)), copyPrivateIp: \(Swift.String(describing: copyPrivateIp)), copyTags: \(Swift.String(describing: copyTags)), ec2LaunchTemplateID: \(Swift.String(describing: ec2LaunchTemplateID)), enableMapAutoTagging: \(Swift.String(describing: enableMapAutoTagging)), largeVolumeConf: \(Swift.String(describing: largeVolumeConf)), launchConfigurationTemplateID: \(Swift.String(describing: launchConfigurationTemplateID)), launchDisposition: \(Swift.String(describing: launchDisposition)), licensing: \(Swift.String(describing: licensing)), mapAutoTaggingMpeID: \(Swift.String(describing: mapAutoTaggingMpeID)), postLaunchActions: \(Swift.String(describing: postLaunchActions)), smallVolumeConf: \(Swift.String(describing: smallVolumeConf)), smallVolumeMaxSize: \(Swift.String(describing: smallVolumeMaxSize)), targetInstanceTypeRightSizingMethod: \(Swift.String(describing: targetInstanceTypeRightSizingMethod)), tags: \"CONTENT_REDACTED\")"}
}

extension UpdateLaunchConfigurationTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateLaunchConfigurationTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.associatePublicIpAddress = output.associatePublicIpAddress
            self.bootMode = output.bootMode
            self.copyPrivateIp = output.copyPrivateIp
            self.copyTags = output.copyTags
            self.ec2LaunchTemplateID = output.ec2LaunchTemplateID
            self.enableMapAutoTagging = output.enableMapAutoTagging
            self.largeVolumeConf = output.largeVolumeConf
            self.launchConfigurationTemplateID = output.launchConfigurationTemplateID
            self.launchDisposition = output.launchDisposition
            self.licensing = output.licensing
            self.mapAutoTaggingMpeID = output.mapAutoTaggingMpeID
            self.postLaunchActions = output.postLaunchActions
            self.smallVolumeConf = output.smallVolumeConf
            self.smallVolumeMaxSize = output.smallVolumeMaxSize
            self.tags = output.tags
            self.targetInstanceTypeRightSizingMethod = output.targetInstanceTypeRightSizingMethod
        } else {
            self.arn = nil
            self.associatePublicIpAddress = nil
            self.bootMode = nil
            self.copyPrivateIp = nil
            self.copyTags = nil
            self.ec2LaunchTemplateID = nil
            self.enableMapAutoTagging = nil
            self.largeVolumeConf = nil
            self.launchConfigurationTemplateID = nil
            self.launchDisposition = nil
            self.licensing = nil
            self.mapAutoTaggingMpeID = nil
            self.postLaunchActions = nil
            self.smallVolumeConf = nil
            self.smallVolumeMaxSize = 0
            self.tags = nil
            self.targetInstanceTypeRightSizingMethod = nil
        }
    }
}

public struct UpdateLaunchConfigurationTemplateOutput {
    /// ARN of the Launch Configuration Template.
    public var arn: Swift.String?
    /// Associate public Ip address.
    public var associatePublicIpAddress: Swift.Bool?
    /// Launch configuration template boot mode.
    public var bootMode: MgnClientTypes.BootMode?
    /// Copy private Ip.
    public var copyPrivateIp: Swift.Bool?
    /// Copy tags.
    public var copyTags: Swift.Bool?
    /// EC2 launch template ID.
    public var ec2LaunchTemplateID: Swift.String?
    /// Enable map auto tagging.
    public var enableMapAutoTagging: Swift.Bool?
    /// Large volume config.
    public var largeVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
    /// ID of the Launch Configuration Template.
    /// This member is required.
    public var launchConfigurationTemplateID: Swift.String?
    /// Launch disposition.
    public var launchDisposition: MgnClientTypes.LaunchDisposition?
    /// Configure Licensing.
    public var licensing: MgnClientTypes.Licensing?
    /// Launch configuration template map auto tagging MPE ID.
    public var mapAutoTaggingMpeID: Swift.String?
    /// Post Launch Actions of the Launch Configuration Template.
    public var postLaunchActions: MgnClientTypes.PostLaunchActions?
    /// Small volume config.
    public var smallVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
    /// Small volume maximum size.
    public var smallVolumeMaxSize: Swift.Int
    /// Tags of the Launch Configuration Template.
    public var tags: [Swift.String:Swift.String]?
    /// Target instance type right-sizing method.
    public var targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?

    public init(
        arn: Swift.String? = nil,
        associatePublicIpAddress: Swift.Bool? = nil,
        bootMode: MgnClientTypes.BootMode? = nil,
        copyPrivateIp: Swift.Bool? = nil,
        copyTags: Swift.Bool? = nil,
        ec2LaunchTemplateID: Swift.String? = nil,
        enableMapAutoTagging: Swift.Bool? = nil,
        largeVolumeConf: MgnClientTypes.LaunchTemplateDiskConf? = nil,
        launchConfigurationTemplateID: Swift.String? = nil,
        launchDisposition: MgnClientTypes.LaunchDisposition? = nil,
        licensing: MgnClientTypes.Licensing? = nil,
        mapAutoTaggingMpeID: Swift.String? = nil,
        postLaunchActions: MgnClientTypes.PostLaunchActions? = nil,
        smallVolumeConf: MgnClientTypes.LaunchTemplateDiskConf? = nil,
        smallVolumeMaxSize: Swift.Int = 0,
        tags: [Swift.String:Swift.String]? = nil,
        targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod? = nil
    )
    {
        self.arn = arn
        self.associatePublicIpAddress = associatePublicIpAddress
        self.bootMode = bootMode
        self.copyPrivateIp = copyPrivateIp
        self.copyTags = copyTags
        self.ec2LaunchTemplateID = ec2LaunchTemplateID
        self.enableMapAutoTagging = enableMapAutoTagging
        self.largeVolumeConf = largeVolumeConf
        self.launchConfigurationTemplateID = launchConfigurationTemplateID
        self.launchDisposition = launchDisposition
        self.licensing = licensing
        self.mapAutoTaggingMpeID = mapAutoTaggingMpeID
        self.postLaunchActions = postLaunchActions
        self.smallVolumeConf = smallVolumeConf
        self.smallVolumeMaxSize = smallVolumeMaxSize
        self.tags = tags
        self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
    }
}

struct UpdateLaunchConfigurationTemplateOutputBody {
    let launchConfigurationTemplateID: Swift.String?
    let arn: Swift.String?
    let postLaunchActions: MgnClientTypes.PostLaunchActions?
    let enableMapAutoTagging: Swift.Bool?
    let mapAutoTaggingMpeID: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let ec2LaunchTemplateID: Swift.String?
    let launchDisposition: MgnClientTypes.LaunchDisposition?
    let targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?
    let copyPrivateIp: Swift.Bool?
    let associatePublicIpAddress: Swift.Bool?
    let copyTags: Swift.Bool?
    let licensing: MgnClientTypes.Licensing?
    let bootMode: MgnClientTypes.BootMode?
    let smallVolumeMaxSize: Swift.Int
    let smallVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
    let largeVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
}

extension UpdateLaunchConfigurationTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case associatePublicIpAddress
        case bootMode
        case copyPrivateIp
        case copyTags
        case ec2LaunchTemplateID
        case enableMapAutoTagging
        case largeVolumeConf
        case launchConfigurationTemplateID
        case launchDisposition
        case licensing
        case mapAutoTaggingMpeID
        case postLaunchActions
        case smallVolumeConf
        case smallVolumeMaxSize
        case tags
        case targetInstanceTypeRightSizingMethod
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchConfigurationTemplateID)
        launchConfigurationTemplateID = launchConfigurationTemplateIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let postLaunchActionsDecoded = try containerValues.decodeIfPresent(MgnClientTypes.PostLaunchActions.self, forKey: .postLaunchActions)
        postLaunchActions = postLaunchActionsDecoded
        let enableMapAutoTaggingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableMapAutoTagging)
        enableMapAutoTagging = enableMapAutoTaggingDecoded
        let mapAutoTaggingMpeIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapAutoTaggingMpeID)
        mapAutoTaggingMpeID = mapAutoTaggingMpeIDDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let ec2LaunchTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2LaunchTemplateID)
        ec2LaunchTemplateID = ec2LaunchTemplateIDDecoded
        let launchDispositionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchDisposition.self, forKey: .launchDisposition)
        launchDisposition = launchDispositionDecoded
        let targetInstanceTypeRightSizingMethodDecoded = try containerValues.decodeIfPresent(MgnClientTypes.TargetInstanceTypeRightSizingMethod.self, forKey: .targetInstanceTypeRightSizingMethod)
        targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethodDecoded
        let copyPrivateIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyPrivateIp)
        copyPrivateIp = copyPrivateIpDecoded
        let associatePublicIpAddressDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associatePublicIpAddress)
        associatePublicIpAddress = associatePublicIpAddressDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let licensingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.Licensing.self, forKey: .licensing)
        licensing = licensingDecoded
        let bootModeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.BootMode.self, forKey: .bootMode)
        bootMode = bootModeDecoded
        let smallVolumeMaxSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .smallVolumeMaxSize) ?? 0
        smallVolumeMaxSize = smallVolumeMaxSizeDecoded
        let smallVolumeConfDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchTemplateDiskConf.self, forKey: .smallVolumeConf)
        smallVolumeConf = smallVolumeConfDecoded
        let largeVolumeConfDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchTemplateDiskConf.self, forKey: .largeVolumeConf)
        largeVolumeConf = largeVolumeConfDecoded
    }
}

enum UpdateLaunchConfigurationTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateReplicationConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateReplicationConfigurationInput(accountID: \(Swift.String(describing: accountID)), associateDefaultSecurityGroup: \(Swift.String(describing: associateDefaultSecurityGroup)), bandwidthThrottling: \(Swift.String(describing: bandwidthThrottling)), createPublicIP: \(Swift.String(describing: createPublicIP)), dataPlaneRouting: \(Swift.String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(Swift.String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(Swift.String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(Swift.String(describing: ebsEncryptionKeyArn)), name: \(Swift.String(describing: name)), replicatedDisks: \(Swift.String(describing: replicatedDisks)), replicationServerInstanceType: \(Swift.String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(Swift.String(describing: replicationServersSecurityGroupsIDs)), sourceServerID: \(Swift.String(describing: sourceServerID)), stagingAreaSubnetId: \(Swift.String(describing: stagingAreaSubnetId)), useDedicatedReplicationServer: \(Swift.String(describing: useDedicatedReplicationServer)), useFipsEndpoint: \(Swift.String(describing: useFipsEndpoint)), stagingAreaTags: \"CONTENT_REDACTED\")"}
}

extension UpdateReplicationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case name
        case replicatedDisks
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case sourceServerID
        case stagingAreaSubnetId
        case stagingAreaTags
        case useDedicatedReplicationServer
        case useFipsEndpoint
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let associateDefaultSecurityGroup = self.associateDefaultSecurityGroup {
            try encodeContainer.encode(associateDefaultSecurityGroup, forKey: .associateDefaultSecurityGroup)
        }
        if bandwidthThrottling != 0 {
            try encodeContainer.encode(bandwidthThrottling, forKey: .bandwidthThrottling)
        }
        if let createPublicIP = self.createPublicIP {
            try encodeContainer.encode(createPublicIP, forKey: .createPublicIP)
        }
        if let dataPlaneRouting = self.dataPlaneRouting {
            try encodeContainer.encode(dataPlaneRouting.rawValue, forKey: .dataPlaneRouting)
        }
        if let defaultLargeStagingDiskType = self.defaultLargeStagingDiskType {
            try encodeContainer.encode(defaultLargeStagingDiskType.rawValue, forKey: .defaultLargeStagingDiskType)
        }
        if let ebsEncryption = self.ebsEncryption {
            try encodeContainer.encode(ebsEncryption.rawValue, forKey: .ebsEncryption)
        }
        if let ebsEncryptionKeyArn = self.ebsEncryptionKeyArn {
            try encodeContainer.encode(ebsEncryptionKeyArn, forKey: .ebsEncryptionKeyArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let replicatedDisks = replicatedDisks {
            var replicatedDisksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicatedDisks)
            for replicationconfigurationreplicateddisk0 in replicatedDisks {
                try replicatedDisksContainer.encode(replicationconfigurationreplicateddisk0)
            }
        }
        if let replicationServerInstanceType = self.replicationServerInstanceType {
            try encodeContainer.encode(replicationServerInstanceType, forKey: .replicationServerInstanceType)
        }
        if let replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs {
            var replicationServersSecurityGroupsIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationServersSecurityGroupsIDs)
            for securitygroupid0 in replicationServersSecurityGroupsIDs {
                try replicationServersSecurityGroupsIDsContainer.encode(securitygroupid0)
            }
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
        if let stagingAreaSubnetId = self.stagingAreaSubnetId {
            try encodeContainer.encode(stagingAreaSubnetId, forKey: .stagingAreaSubnetId)
        }
        if let stagingAreaTags = stagingAreaTags {
            var stagingAreaTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .stagingAreaTags)
            for (dictKey0, tagsMap0) in stagingAreaTags {
                try stagingAreaTagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let useDedicatedReplicationServer = self.useDedicatedReplicationServer {
            try encodeContainer.encode(useDedicatedReplicationServer, forKey: .useDedicatedReplicationServer)
        }
        if let useFipsEndpoint = self.useFipsEndpoint {
            try encodeContainer.encode(useFipsEndpoint, forKey: .useFipsEndpoint)
        }
    }
}

extension UpdateReplicationConfigurationInput {

    static func urlPathProvider(_ value: UpdateReplicationConfigurationInput) -> Swift.String? {
        return "/UpdateReplicationConfiguration"
    }
}

public struct UpdateReplicationConfigurationInput {
    /// Update replication configuration Account ID request.
    public var accountID: Swift.String?
    /// Update replication configuration associate default Application Migration Service Security group request.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Update replication configuration bandwidth throttling request.
    public var bandwidthThrottling: Swift.Int
    /// Update replication configuration create Public IP request.
    public var createPublicIP: Swift.Bool?
    /// Update replication configuration data plane routing request.
    public var dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// Update replication configuration use default large Staging Disk type request.
    public var defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// Update replication configuration EBS encryption request.
    public var ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    /// Update replication configuration EBS encryption key ARN request.
    public var ebsEncryptionKeyArn: Swift.String?
    /// Update replication configuration name request.
    public var name: Swift.String?
    /// Update replication configuration replicated disks request.
    public var replicatedDisks: [MgnClientTypes.ReplicationConfigurationReplicatedDisk]?
    /// Update replication configuration Replication Server instance type request.
    public var replicationServerInstanceType: Swift.String?
    /// Update replication configuration Replication Server Security Groups IDs request.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// Update replication configuration Source Server ID request.
    /// This member is required.
    public var sourceServerID: Swift.String?
    /// Update replication configuration Staging Area subnet request.
    public var stagingAreaSubnetId: Swift.String?
    /// Update replication configuration Staging Area Tags request.
    public var stagingAreaTags: [Swift.String:Swift.String]?
    /// Update replication configuration use dedicated Replication Server request.
    public var useDedicatedReplicationServer: Swift.Bool?
    /// Update replication configuration use Fips Endpoint.
    public var useFipsEndpoint: Swift.Bool?

    public init(
        accountID: Swift.String? = nil,
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        replicatedDisks: [MgnClientTypes.ReplicationConfigurationReplicatedDisk]? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        sourceServerID: Swift.String? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String:Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil,
        useFipsEndpoint: Swift.Bool? = nil
    )
    {
        self.accountID = accountID
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.name = name
        self.replicatedDisks = replicatedDisks
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.sourceServerID = sourceServerID
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
        self.useFipsEndpoint = useFipsEndpoint
    }
}

struct UpdateReplicationConfigurationInputBody {
    let sourceServerID: Swift.String?
    let name: Swift.String?
    let stagingAreaSubnetId: Swift.String?
    let associateDefaultSecurityGroup: Swift.Bool?
    let replicationServersSecurityGroupsIDs: [Swift.String]?
    let replicationServerInstanceType: Swift.String?
    let useDedicatedReplicationServer: Swift.Bool?
    let defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    let replicatedDisks: [MgnClientTypes.ReplicationConfigurationReplicatedDisk]?
    let ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    let ebsEncryptionKeyArn: Swift.String?
    let bandwidthThrottling: Swift.Int
    let dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    let createPublicIP: Swift.Bool?
    let stagingAreaTags: [Swift.String:Swift.String]?
    let useFipsEndpoint: Swift.Bool?
    let accountID: Swift.String?
}

extension UpdateReplicationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case name
        case replicatedDisks
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case sourceServerID
        case stagingAreaSubnetId
        case stagingAreaTags
        case useDedicatedReplicationServer
        case useFipsEndpoint
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let replicatedDisksContainer = try containerValues.decodeIfPresent([MgnClientTypes.ReplicationConfigurationReplicatedDisk?].self, forKey: .replicatedDisks)
        var replicatedDisksDecoded0:[MgnClientTypes.ReplicationConfigurationReplicatedDisk]? = nil
        if let replicatedDisksContainer = replicatedDisksContainer {
            replicatedDisksDecoded0 = [MgnClientTypes.ReplicationConfigurationReplicatedDisk]()
            for structure0 in replicatedDisksContainer {
                if let structure0 = structure0 {
                    replicatedDisksDecoded0?.append(structure0)
                }
            }
        }
        replicatedDisks = replicatedDisksDecoded0
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bandwidthThrottling) ?? 0
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
        let useFipsEndpointDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useFipsEndpoint)
        useFipsEndpoint = useFipsEndpointDecoded
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension UpdateReplicationConfigurationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateReplicationConfigurationOutput(associateDefaultSecurityGroup: \(Swift.String(describing: associateDefaultSecurityGroup)), bandwidthThrottling: \(Swift.String(describing: bandwidthThrottling)), createPublicIP: \(Swift.String(describing: createPublicIP)), dataPlaneRouting: \(Swift.String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(Swift.String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(Swift.String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(Swift.String(describing: ebsEncryptionKeyArn)), name: \(Swift.String(describing: name)), replicatedDisks: \(Swift.String(describing: replicatedDisks)), replicationServerInstanceType: \(Swift.String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(Swift.String(describing: replicationServersSecurityGroupsIDs)), sourceServerID: \(Swift.String(describing: sourceServerID)), stagingAreaSubnetId: \(Swift.String(describing: stagingAreaSubnetId)), useDedicatedReplicationServer: \(Swift.String(describing: useDedicatedReplicationServer)), useFipsEndpoint: \(Swift.String(describing: useFipsEndpoint)), stagingAreaTags: \"CONTENT_REDACTED\")"}
}

extension UpdateReplicationConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateReplicationConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.associateDefaultSecurityGroup = output.associateDefaultSecurityGroup
            self.bandwidthThrottling = output.bandwidthThrottling
            self.createPublicIP = output.createPublicIP
            self.dataPlaneRouting = output.dataPlaneRouting
            self.defaultLargeStagingDiskType = output.defaultLargeStagingDiskType
            self.ebsEncryption = output.ebsEncryption
            self.ebsEncryptionKeyArn = output.ebsEncryptionKeyArn
            self.name = output.name
            self.replicatedDisks = output.replicatedDisks
            self.replicationServerInstanceType = output.replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = output.replicationServersSecurityGroupsIDs
            self.sourceServerID = output.sourceServerID
            self.stagingAreaSubnetId = output.stagingAreaSubnetId
            self.stagingAreaTags = output.stagingAreaTags
            self.useDedicatedReplicationServer = output.useDedicatedReplicationServer
            self.useFipsEndpoint = output.useFipsEndpoint
        } else {
            self.associateDefaultSecurityGroup = nil
            self.bandwidthThrottling = 0
            self.createPublicIP = nil
            self.dataPlaneRouting = nil
            self.defaultLargeStagingDiskType = nil
            self.ebsEncryption = nil
            self.ebsEncryptionKeyArn = nil
            self.name = nil
            self.replicatedDisks = nil
            self.replicationServerInstanceType = nil
            self.replicationServersSecurityGroupsIDs = nil
            self.sourceServerID = nil
            self.stagingAreaSubnetId = nil
            self.stagingAreaTags = nil
            self.useDedicatedReplicationServer = nil
            self.useFipsEndpoint = nil
        }
    }
}

public struct UpdateReplicationConfigurationOutput {
    /// Replication Configuration associate default Application Migration Service Security Group.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Replication Configuration set bandwidth throttling.
    public var bandwidthThrottling: Swift.Int
    /// Replication Configuration create Public IP.
    public var createPublicIP: Swift.Bool?
    /// Replication Configuration data plane routing.
    public var dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// Replication Configuration use default large Staging Disks.
    public var defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// Replication Configuration EBS encryption.
    public var ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    /// Replication Configuration EBS encryption key ARN.
    public var ebsEncryptionKeyArn: Swift.String?
    /// Replication Configuration name.
    public var name: Swift.String?
    /// Replication Configuration replicated disks.
    public var replicatedDisks: [MgnClientTypes.ReplicationConfigurationReplicatedDisk]?
    /// Replication Configuration Replication Server instance type.
    public var replicationServerInstanceType: Swift.String?
    /// Replication Configuration Replication Server Security Group IDs.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// Replication Configuration Source Server ID.
    public var sourceServerID: Swift.String?
    /// Replication Configuration Staging Area subnet ID.
    public var stagingAreaSubnetId: Swift.String?
    /// Replication Configuration Staging Area tags.
    public var stagingAreaTags: [Swift.String:Swift.String]?
    /// Replication Configuration use Dedicated Replication Server.
    public var useDedicatedReplicationServer: Swift.Bool?
    /// Replication Configuration use Fips Endpoint.
    public var useFipsEndpoint: Swift.Bool?

    public init(
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        replicatedDisks: [MgnClientTypes.ReplicationConfigurationReplicatedDisk]? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        sourceServerID: Swift.String? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String:Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil,
        useFipsEndpoint: Swift.Bool? = nil
    )
    {
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.name = name
        self.replicatedDisks = replicatedDisks
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.sourceServerID = sourceServerID
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
        self.useFipsEndpoint = useFipsEndpoint
    }
}

struct UpdateReplicationConfigurationOutputBody {
    let sourceServerID: Swift.String?
    let name: Swift.String?
    let stagingAreaSubnetId: Swift.String?
    let associateDefaultSecurityGroup: Swift.Bool?
    let replicationServersSecurityGroupsIDs: [Swift.String]?
    let replicationServerInstanceType: Swift.String?
    let useDedicatedReplicationServer: Swift.Bool?
    let defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    let replicatedDisks: [MgnClientTypes.ReplicationConfigurationReplicatedDisk]?
    let ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    let ebsEncryptionKeyArn: Swift.String?
    let bandwidthThrottling: Swift.Int
    let dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    let createPublicIP: Swift.Bool?
    let stagingAreaTags: [Swift.String:Swift.String]?
    let useFipsEndpoint: Swift.Bool?
}

extension UpdateReplicationConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case name
        case replicatedDisks
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case sourceServerID
        case stagingAreaSubnetId
        case stagingAreaTags
        case useDedicatedReplicationServer
        case useFipsEndpoint
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let replicatedDisksContainer = try containerValues.decodeIfPresent([MgnClientTypes.ReplicationConfigurationReplicatedDisk?].self, forKey: .replicatedDisks)
        var replicatedDisksDecoded0:[MgnClientTypes.ReplicationConfigurationReplicatedDisk]? = nil
        if let replicatedDisksContainer = replicatedDisksContainer {
            replicatedDisksDecoded0 = [MgnClientTypes.ReplicationConfigurationReplicatedDisk]()
            for structure0 in replicatedDisksContainer {
                if let structure0 = structure0 {
                    replicatedDisksDecoded0?.append(structure0)
                }
            }
        }
        replicatedDisks = replicatedDisksDecoded0
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bandwidthThrottling) ?? 0
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
        let useFipsEndpointDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useFipsEndpoint)
        useFipsEndpoint = useFipsEndpointDecoded
    }
}

enum UpdateReplicationConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateReplicationConfigurationTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateReplicationConfigurationTemplateInput(arn: \(Swift.String(describing: arn)), associateDefaultSecurityGroup: \(Swift.String(describing: associateDefaultSecurityGroup)), bandwidthThrottling: \(Swift.String(describing: bandwidthThrottling)), createPublicIP: \(Swift.String(describing: createPublicIP)), dataPlaneRouting: \(Swift.String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(Swift.String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(Swift.String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(Swift.String(describing: ebsEncryptionKeyArn)), replicationConfigurationTemplateID: \(Swift.String(describing: replicationConfigurationTemplateID)), replicationServerInstanceType: \(Swift.String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(Swift.String(describing: replicationServersSecurityGroupsIDs)), stagingAreaSubnetId: \(Swift.String(describing: stagingAreaSubnetId)), useDedicatedReplicationServer: \(Swift.String(describing: useDedicatedReplicationServer)), useFipsEndpoint: \(Swift.String(describing: useFipsEndpoint)), stagingAreaTags: \"CONTENT_REDACTED\")"}
}

extension UpdateReplicationConfigurationTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case replicationConfigurationTemplateID
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case useDedicatedReplicationServer
        case useFipsEndpoint
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let associateDefaultSecurityGroup = self.associateDefaultSecurityGroup {
            try encodeContainer.encode(associateDefaultSecurityGroup, forKey: .associateDefaultSecurityGroup)
        }
        if bandwidthThrottling != 0 {
            try encodeContainer.encode(bandwidthThrottling, forKey: .bandwidthThrottling)
        }
        if let createPublicIP = self.createPublicIP {
            try encodeContainer.encode(createPublicIP, forKey: .createPublicIP)
        }
        if let dataPlaneRouting = self.dataPlaneRouting {
            try encodeContainer.encode(dataPlaneRouting.rawValue, forKey: .dataPlaneRouting)
        }
        if let defaultLargeStagingDiskType = self.defaultLargeStagingDiskType {
            try encodeContainer.encode(defaultLargeStagingDiskType.rawValue, forKey: .defaultLargeStagingDiskType)
        }
        if let ebsEncryption = self.ebsEncryption {
            try encodeContainer.encode(ebsEncryption.rawValue, forKey: .ebsEncryption)
        }
        if let ebsEncryptionKeyArn = self.ebsEncryptionKeyArn {
            try encodeContainer.encode(ebsEncryptionKeyArn, forKey: .ebsEncryptionKeyArn)
        }
        if let replicationConfigurationTemplateID = self.replicationConfigurationTemplateID {
            try encodeContainer.encode(replicationConfigurationTemplateID, forKey: .replicationConfigurationTemplateID)
        }
        if let replicationServerInstanceType = self.replicationServerInstanceType {
            try encodeContainer.encode(replicationServerInstanceType, forKey: .replicationServerInstanceType)
        }
        if let replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs {
            var replicationServersSecurityGroupsIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationServersSecurityGroupsIDs)
            for securitygroupid0 in replicationServersSecurityGroupsIDs {
                try replicationServersSecurityGroupsIDsContainer.encode(securitygroupid0)
            }
        }
        if let stagingAreaSubnetId = self.stagingAreaSubnetId {
            try encodeContainer.encode(stagingAreaSubnetId, forKey: .stagingAreaSubnetId)
        }
        if let stagingAreaTags = stagingAreaTags {
            var stagingAreaTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .stagingAreaTags)
            for (dictKey0, tagsMap0) in stagingAreaTags {
                try stagingAreaTagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let useDedicatedReplicationServer = self.useDedicatedReplicationServer {
            try encodeContainer.encode(useDedicatedReplicationServer, forKey: .useDedicatedReplicationServer)
        }
        if let useFipsEndpoint = self.useFipsEndpoint {
            try encodeContainer.encode(useFipsEndpoint, forKey: .useFipsEndpoint)
        }
    }
}

extension UpdateReplicationConfigurationTemplateInput {

    static func urlPathProvider(_ value: UpdateReplicationConfigurationTemplateInput) -> Swift.String? {
        return "/UpdateReplicationConfigurationTemplate"
    }
}

public struct UpdateReplicationConfigurationTemplateInput {
    /// Update replication configuration template ARN request.
    public var arn: Swift.String?
    /// Update replication configuration template associate default Application Migration Service Security group request.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Update replication configuration template bandwidth throttling request.
    public var bandwidthThrottling: Swift.Int
    /// Update replication configuration template create Public IP request.
    public var createPublicIP: Swift.Bool?
    /// Update replication configuration template data plane routing request.
    public var dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// Update replication configuration template use default large Staging Disk type request.
    public var defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// Update replication configuration template EBS encryption request.
    public var ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    /// Update replication configuration template EBS encryption key ARN request.
    public var ebsEncryptionKeyArn: Swift.String?
    /// Update replication configuration template template ID request.
    /// This member is required.
    public var replicationConfigurationTemplateID: Swift.String?
    /// Update replication configuration template Replication Server instance type request.
    public var replicationServerInstanceType: Swift.String?
    /// Update replication configuration template Replication Server Security groups IDs request.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// Update replication configuration template Staging Area subnet ID request.
    public var stagingAreaSubnetId: Swift.String?
    /// Update replication configuration template Staging Area Tags request.
    public var stagingAreaTags: [Swift.String:Swift.String]?
    /// Update replication configuration template use dedicated Replication Server request.
    public var useDedicatedReplicationServer: Swift.Bool?
    /// Update replication configuration template use Fips Endpoint request.
    public var useFipsEndpoint: Swift.Bool?

    public init(
        arn: Swift.String? = nil,
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        replicationConfigurationTemplateID: Swift.String? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String:Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil,
        useFipsEndpoint: Swift.Bool? = nil
    )
    {
        self.arn = arn
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
        self.useFipsEndpoint = useFipsEndpoint
    }
}

struct UpdateReplicationConfigurationTemplateInputBody {
    let replicationConfigurationTemplateID: Swift.String?
    let arn: Swift.String?
    let stagingAreaSubnetId: Swift.String?
    let associateDefaultSecurityGroup: Swift.Bool?
    let replicationServersSecurityGroupsIDs: [Swift.String]?
    let replicationServerInstanceType: Swift.String?
    let useDedicatedReplicationServer: Swift.Bool?
    let defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    let ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    let ebsEncryptionKeyArn: Swift.String?
    let bandwidthThrottling: Swift.Int
    let dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    let createPublicIP: Swift.Bool?
    let stagingAreaTags: [Swift.String:Swift.String]?
    let useFipsEndpoint: Swift.Bool?
}

extension UpdateReplicationConfigurationTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case replicationConfigurationTemplateID
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case useDedicatedReplicationServer
        case useFipsEndpoint
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationConfigurationTemplateID)
        replicationConfigurationTemplateID = replicationConfigurationTemplateIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bandwidthThrottling) ?? 0
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
        let useFipsEndpointDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useFipsEndpoint)
        useFipsEndpoint = useFipsEndpointDecoded
    }
}

extension UpdateReplicationConfigurationTemplateOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateReplicationConfigurationTemplateOutput(arn: \(Swift.String(describing: arn)), associateDefaultSecurityGroup: \(Swift.String(describing: associateDefaultSecurityGroup)), bandwidthThrottling: \(Swift.String(describing: bandwidthThrottling)), createPublicIP: \(Swift.String(describing: createPublicIP)), dataPlaneRouting: \(Swift.String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(Swift.String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(Swift.String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(Swift.String(describing: ebsEncryptionKeyArn)), replicationConfigurationTemplateID: \(Swift.String(describing: replicationConfigurationTemplateID)), replicationServerInstanceType: \(Swift.String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(Swift.String(describing: replicationServersSecurityGroupsIDs)), stagingAreaSubnetId: \(Swift.String(describing: stagingAreaSubnetId)), useDedicatedReplicationServer: \(Swift.String(describing: useDedicatedReplicationServer)), useFipsEndpoint: \(Swift.String(describing: useFipsEndpoint)), stagingAreaTags: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

extension UpdateReplicationConfigurationTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateReplicationConfigurationTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.associateDefaultSecurityGroup = output.associateDefaultSecurityGroup
            self.bandwidthThrottling = output.bandwidthThrottling
            self.createPublicIP = output.createPublicIP
            self.dataPlaneRouting = output.dataPlaneRouting
            self.defaultLargeStagingDiskType = output.defaultLargeStagingDiskType
            self.ebsEncryption = output.ebsEncryption
            self.ebsEncryptionKeyArn = output.ebsEncryptionKeyArn
            self.replicationConfigurationTemplateID = output.replicationConfigurationTemplateID
            self.replicationServerInstanceType = output.replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = output.replicationServersSecurityGroupsIDs
            self.stagingAreaSubnetId = output.stagingAreaSubnetId
            self.stagingAreaTags = output.stagingAreaTags
            self.tags = output.tags
            self.useDedicatedReplicationServer = output.useDedicatedReplicationServer
            self.useFipsEndpoint = output.useFipsEndpoint
        } else {
            self.arn = nil
            self.associateDefaultSecurityGroup = nil
            self.bandwidthThrottling = 0
            self.createPublicIP = nil
            self.dataPlaneRouting = nil
            self.defaultLargeStagingDiskType = nil
            self.ebsEncryption = nil
            self.ebsEncryptionKeyArn = nil
            self.replicationConfigurationTemplateID = nil
            self.replicationServerInstanceType = nil
            self.replicationServersSecurityGroupsIDs = nil
            self.stagingAreaSubnetId = nil
            self.stagingAreaTags = nil
            self.tags = nil
            self.useDedicatedReplicationServer = nil
            self.useFipsEndpoint = nil
        }
    }
}

public struct UpdateReplicationConfigurationTemplateOutput {
    /// Replication Configuration template ARN.
    public var arn: Swift.String?
    /// Replication Configuration template associate default Application Migration Service Security group.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Replication Configuration template bandwidth throttling.
    public var bandwidthThrottling: Swift.Int
    /// Replication Configuration template create Public IP.
    public var createPublicIP: Swift.Bool?
    /// Replication Configuration template data plane routing.
    public var dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// Replication Configuration template use default large Staging Disk type.
    public var defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// Replication Configuration template EBS encryption.
    public var ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    /// Replication Configuration template EBS encryption key ARN.
    public var ebsEncryptionKeyArn: Swift.String?
    /// Replication Configuration template ID.
    /// This member is required.
    public var replicationConfigurationTemplateID: Swift.String?
    /// Replication Configuration template server instance type.
    public var replicationServerInstanceType: Swift.String?
    /// Replication Configuration template server Security Groups IDs.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// Replication Configuration template Staging Area subnet ID.
    public var stagingAreaSubnetId: Swift.String?
    /// Replication Configuration template Staging Area Tags.
    public var stagingAreaTags: [Swift.String:Swift.String]?
    /// Replication Configuration template Tags.
    public var tags: [Swift.String:Swift.String]?
    /// Replication Configuration template use Dedicated Replication Server.
    public var useDedicatedReplicationServer: Swift.Bool?
    /// Replication Configuration template use Fips Endpoint.
    public var useFipsEndpoint: Swift.Bool?

    public init(
        arn: Swift.String? = nil,
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        replicationConfigurationTemplateID: Swift.String? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String:Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil,
        useFipsEndpoint: Swift.Bool? = nil
    )
    {
        self.arn = arn
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.tags = tags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
        self.useFipsEndpoint = useFipsEndpoint
    }
}

struct UpdateReplicationConfigurationTemplateOutputBody {
    let replicationConfigurationTemplateID: Swift.String?
    let arn: Swift.String?
    let stagingAreaSubnetId: Swift.String?
    let associateDefaultSecurityGroup: Swift.Bool?
    let replicationServersSecurityGroupsIDs: [Swift.String]?
    let replicationServerInstanceType: Swift.String?
    let useDedicatedReplicationServer: Swift.Bool?
    let defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    let ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    let ebsEncryptionKeyArn: Swift.String?
    let bandwidthThrottling: Swift.Int
    let dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    let createPublicIP: Swift.Bool?
    let stagingAreaTags: [Swift.String:Swift.String]?
    let useFipsEndpoint: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateReplicationConfigurationTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case replicationConfigurationTemplateID
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case tags
        case useDedicatedReplicationServer
        case useFipsEndpoint
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationConfigurationTemplateID)
        replicationConfigurationTemplateID = replicationConfigurationTemplateIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bandwidthThrottling) ?? 0
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
        let useFipsEndpointDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useFipsEndpoint)
        useFipsEndpoint = useFipsEndpointDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum UpdateReplicationConfigurationTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSourceServerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case connectorAction
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let connectorAction = self.connectorAction {
            try encodeContainer.encode(connectorAction, forKey: .connectorAction)
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension UpdateSourceServerInput {

    static func urlPathProvider(_ value: UpdateSourceServerInput) -> Swift.String? {
        return "/UpdateSourceServer"
    }
}

public struct UpdateSourceServerInput {
    /// Update Source Server request account ID.
    public var accountID: Swift.String?
    /// Update Source Server request connector action.
    public var connectorAction: MgnClientTypes.SourceServerConnectorAction?
    /// Update Source Server request source server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        connectorAction: MgnClientTypes.SourceServerConnectorAction? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.connectorAction = connectorAction
        self.sourceServerID = sourceServerID
    }
}

struct UpdateSourceServerInputBody {
    let accountID: Swift.String?
    let sourceServerID: Swift.String?
    let connectorAction: MgnClientTypes.SourceServerConnectorAction?
}

extension UpdateSourceServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case connectorAction
        case sourceServerID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let connectorActionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceServerConnectorAction.self, forKey: .connectorAction)
        connectorAction = connectorActionDecoded
    }
}

extension UpdateSourceServerOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSourceServerOutput(applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), connectorAction: \(Swift.String(describing: connectorAction)), dataReplicationInfo: \(Swift.String(describing: dataReplicationInfo)), fqdnForActionFramework: \(Swift.String(describing: fqdnForActionFramework)), isArchived: \(Swift.String(describing: isArchived)), launchedInstance: \(Swift.String(describing: launchedInstance)), lifeCycle: \(Swift.String(describing: lifeCycle)), replicationType: \(Swift.String(describing: replicationType)), sourceProperties: \(Swift.String(describing: sourceProperties)), sourceServerID: \(Swift.String(describing: sourceServerID)), userProvidedID: \(Swift.String(describing: userProvidedID)), vcenterClientID: \(Swift.String(describing: vcenterClientID)), tags: \"CONTENT_REDACTED\")"}
}

extension UpdateSourceServerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSourceServerOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationID = output.applicationID
            self.arn = output.arn
            self.connectorAction = output.connectorAction
            self.dataReplicationInfo = output.dataReplicationInfo
            self.fqdnForActionFramework = output.fqdnForActionFramework
            self.isArchived = output.isArchived
            self.launchedInstance = output.launchedInstance
            self.lifeCycle = output.lifeCycle
            self.replicationType = output.replicationType
            self.sourceProperties = output.sourceProperties
            self.sourceServerID = output.sourceServerID
            self.tags = output.tags
            self.userProvidedID = output.userProvidedID
            self.vcenterClientID = output.vcenterClientID
        } else {
            self.applicationID = nil
            self.arn = nil
            self.connectorAction = nil
            self.dataReplicationInfo = nil
            self.fqdnForActionFramework = nil
            self.isArchived = nil
            self.launchedInstance = nil
            self.lifeCycle = nil
            self.replicationType = nil
            self.sourceProperties = nil
            self.sourceServerID = nil
            self.tags = nil
            self.userProvidedID = nil
            self.vcenterClientID = nil
        }
    }
}

public struct UpdateSourceServerOutput {
    /// Source server application ID.
    public var applicationID: Swift.String?
    /// Source server ARN.
    public var arn: Swift.String?
    /// Source Server connector action.
    public var connectorAction: MgnClientTypes.SourceServerConnectorAction?
    /// Source server data replication info.
    public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    /// Source server fqdn for action framework.
    public var fqdnForActionFramework: Swift.String?
    /// Source server archived status.
    public var isArchived: Swift.Bool?
    /// Source server launched instance.
    public var launchedInstance: MgnClientTypes.LaunchedInstance?
    /// Source server lifecycle state.
    public var lifeCycle: MgnClientTypes.LifeCycle?
    /// Source server replication type.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// Source server properties.
    public var sourceProperties: MgnClientTypes.SourceProperties?
    /// Source server ID.
    public var sourceServerID: Swift.String?
    /// Source server Tags.
    public var tags: [Swift.String:Swift.String]?
    /// Source server user provided ID.
    public var userProvidedID: Swift.String?
    /// Source server vCenter client id.
    public var vcenterClientID: Swift.String?

    public init(
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        connectorAction: MgnClientTypes.SourceServerConnectorAction? = nil,
        dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
        fqdnForActionFramework: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
        lifeCycle: MgnClientTypes.LifeCycle? = nil,
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceProperties: MgnClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        userProvidedID: Swift.String? = nil,
        vcenterClientID: Swift.String? = nil
    )
    {
        self.applicationID = applicationID
        self.arn = arn
        self.connectorAction = connectorAction
        self.dataReplicationInfo = dataReplicationInfo
        self.fqdnForActionFramework = fqdnForActionFramework
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.replicationType = replicationType
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
        self.userProvidedID = userProvidedID
        self.vcenterClientID = vcenterClientID
    }
}

struct UpdateSourceServerOutputBody {
    let sourceServerID: Swift.String?
    let arn: Swift.String?
    let isArchived: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
    let launchedInstance: MgnClientTypes.LaunchedInstance?
    let dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    let lifeCycle: MgnClientTypes.LifeCycle?
    let sourceProperties: MgnClientTypes.SourceProperties?
    let replicationType: MgnClientTypes.ReplicationType?
    let vcenterClientID: Swift.String?
    let applicationID: Swift.String?
    let userProvidedID: Swift.String?
    let fqdnForActionFramework: Swift.String?
    let connectorAction: MgnClientTypes.SourceServerConnectorAction?
}

extension UpdateSourceServerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationID
        case arn
        case connectorAction
        case dataReplicationInfo
        case fqdnForActionFramework
        case isArchived
        case launchedInstance
        case lifeCycle
        case replicationType
        case sourceProperties
        case sourceServerID
        case tags
        case userProvidedID
        case vcenterClientID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let launchedInstanceDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchedInstance.self, forKey: .launchedInstance)
        launchedInstance = launchedInstanceDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
        let replicationTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationType.self, forKey: .replicationType)
        replicationType = replicationTypeDecoded
        let vcenterClientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcenterClientID)
        vcenterClientID = vcenterClientIDDecoded
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
        let userProvidedIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userProvidedID)
        userProvidedID = userProvidedIDDecoded
        let fqdnForActionFrameworkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fqdnForActionFramework)
        fqdnForActionFramework = fqdnForActionFrameworkDecoded
        let connectorActionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceServerConnectorAction.self, forKey: .connectorAction)
        connectorAction = connectorActionDecoded
    }
}

enum UpdateSourceServerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSourceServerReplicationTypeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case replicationType
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let replicationType = self.replicationType {
            try encodeContainer.encode(replicationType.rawValue, forKey: .replicationType)
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension UpdateSourceServerReplicationTypeInput {

    static func urlPathProvider(_ value: UpdateSourceServerReplicationTypeInput) -> Swift.String? {
        return "/UpdateSourceServerReplicationType"
    }
}

public struct UpdateSourceServerReplicationTypeInput {
    /// Account ID on which to update replication type.
    public var accountID: Swift.String?
    /// Replication type to which to update source server.
    /// This member is required.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// ID of source server on which to update replication type.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.replicationType = replicationType
        self.sourceServerID = sourceServerID
    }
}

struct UpdateSourceServerReplicationTypeInputBody {
    let sourceServerID: Swift.String?
    let replicationType: MgnClientTypes.ReplicationType?
    let accountID: Swift.String?
}

extension UpdateSourceServerReplicationTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case replicationType
        case sourceServerID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let replicationTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationType.self, forKey: .replicationType)
        replicationType = replicationTypeDecoded
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension UpdateSourceServerReplicationTypeOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSourceServerReplicationTypeOutput(applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), connectorAction: \(Swift.String(describing: connectorAction)), dataReplicationInfo: \(Swift.String(describing: dataReplicationInfo)), fqdnForActionFramework: \(Swift.String(describing: fqdnForActionFramework)), isArchived: \(Swift.String(describing: isArchived)), launchedInstance: \(Swift.String(describing: launchedInstance)), lifeCycle: \(Swift.String(describing: lifeCycle)), replicationType: \(Swift.String(describing: replicationType)), sourceProperties: \(Swift.String(describing: sourceProperties)), sourceServerID: \(Swift.String(describing: sourceServerID)), userProvidedID: \(Swift.String(describing: userProvidedID)), vcenterClientID: \(Swift.String(describing: vcenterClientID)), tags: \"CONTENT_REDACTED\")"}
}

extension UpdateSourceServerReplicationTypeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSourceServerReplicationTypeOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationID = output.applicationID
            self.arn = output.arn
            self.connectorAction = output.connectorAction
            self.dataReplicationInfo = output.dataReplicationInfo
            self.fqdnForActionFramework = output.fqdnForActionFramework
            self.isArchived = output.isArchived
            self.launchedInstance = output.launchedInstance
            self.lifeCycle = output.lifeCycle
            self.replicationType = output.replicationType
            self.sourceProperties = output.sourceProperties
            self.sourceServerID = output.sourceServerID
            self.tags = output.tags
            self.userProvidedID = output.userProvidedID
            self.vcenterClientID = output.vcenterClientID
        } else {
            self.applicationID = nil
            self.arn = nil
            self.connectorAction = nil
            self.dataReplicationInfo = nil
            self.fqdnForActionFramework = nil
            self.isArchived = nil
            self.launchedInstance = nil
            self.lifeCycle = nil
            self.replicationType = nil
            self.sourceProperties = nil
            self.sourceServerID = nil
            self.tags = nil
            self.userProvidedID = nil
            self.vcenterClientID = nil
        }
    }
}

public struct UpdateSourceServerReplicationTypeOutput {
    /// Source server application ID.
    public var applicationID: Swift.String?
    /// Source server ARN.
    public var arn: Swift.String?
    /// Source Server connector action.
    public var connectorAction: MgnClientTypes.SourceServerConnectorAction?
    /// Source server data replication info.
    public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    /// Source server fqdn for action framework.
    public var fqdnForActionFramework: Swift.String?
    /// Source server archived status.
    public var isArchived: Swift.Bool?
    /// Source server launched instance.
    public var launchedInstance: MgnClientTypes.LaunchedInstance?
    /// Source server lifecycle state.
    public var lifeCycle: MgnClientTypes.LifeCycle?
    /// Source server replication type.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// Source server properties.
    public var sourceProperties: MgnClientTypes.SourceProperties?
    /// Source server ID.
    public var sourceServerID: Swift.String?
    /// Source server Tags.
    public var tags: [Swift.String:Swift.String]?
    /// Source server user provided ID.
    public var userProvidedID: Swift.String?
    /// Source server vCenter client id.
    public var vcenterClientID: Swift.String?

    public init(
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        connectorAction: MgnClientTypes.SourceServerConnectorAction? = nil,
        dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
        fqdnForActionFramework: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
        lifeCycle: MgnClientTypes.LifeCycle? = nil,
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceProperties: MgnClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        userProvidedID: Swift.String? = nil,
        vcenterClientID: Swift.String? = nil
    )
    {
        self.applicationID = applicationID
        self.arn = arn
        self.connectorAction = connectorAction
        self.dataReplicationInfo = dataReplicationInfo
        self.fqdnForActionFramework = fqdnForActionFramework
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.replicationType = replicationType
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
        self.userProvidedID = userProvidedID
        self.vcenterClientID = vcenterClientID
    }
}

struct UpdateSourceServerReplicationTypeOutputBody {
    let sourceServerID: Swift.String?
    let arn: Swift.String?
    let isArchived: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
    let launchedInstance: MgnClientTypes.LaunchedInstance?
    let dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    let lifeCycle: MgnClientTypes.LifeCycle?
    let sourceProperties: MgnClientTypes.SourceProperties?
    let replicationType: MgnClientTypes.ReplicationType?
    let vcenterClientID: Swift.String?
    let applicationID: Swift.String?
    let userProvidedID: Swift.String?
    let fqdnForActionFramework: Swift.String?
    let connectorAction: MgnClientTypes.SourceServerConnectorAction?
}

extension UpdateSourceServerReplicationTypeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationID
        case arn
        case connectorAction
        case dataReplicationInfo
        case fqdnForActionFramework
        case isArchived
        case launchedInstance
        case lifeCycle
        case replicationType
        case sourceProperties
        case sourceServerID
        case tags
        case userProvidedID
        case vcenterClientID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let launchedInstanceDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchedInstance.self, forKey: .launchedInstance)
        launchedInstance = launchedInstanceDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
        let replicationTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationType.self, forKey: .replicationType)
        replicationType = replicationTypeDecoded
        let vcenterClientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcenterClientID)
        vcenterClientID = vcenterClientIDDecoded
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
        let userProvidedIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userProvidedID)
        userProvidedID = userProvidedIDDecoded
        let fqdnForActionFrameworkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fqdnForActionFramework)
        fqdnForActionFramework = fqdnForActionFrameworkDecoded
        let connectorActionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceServerConnectorAction.self, forKey: .connectorAction)
        connectorAction = connectorActionDecoded
    }
}

enum UpdateSourceServerReplicationTypeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateWaveInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case description
        case name
        case waveID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let waveID = self.waveID {
            try encodeContainer.encode(waveID, forKey: .waveID)
        }
    }
}

extension UpdateWaveInput {

    static func urlPathProvider(_ value: UpdateWaveInput) -> Swift.String? {
        return "/UpdateWave"
    }
}

public struct UpdateWaveInput {
    /// Account ID.
    public var accountID: Swift.String?
    /// Wave description.
    public var description: Swift.String?
    /// Wave name.
    public var name: Swift.String?
    /// Wave ID.
    /// This member is required.
    public var waveID: Swift.String?

    public init(
        accountID: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        waveID: Swift.String? = nil
    )
    {
        self.accountID = accountID
        self.description = description
        self.name = name
        self.waveID = waveID
    }
}

struct UpdateWaveInputBody {
    let waveID: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let accountID: Swift.String?
}

extension UpdateWaveInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
        case description
        case name
        case waveID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let waveIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .waveID)
        waveID = waveIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension UpdateWaveOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateWaveOutput(arn: \(Swift.String(describing: arn)), creationDateTime: \(Swift.String(describing: creationDateTime)), description: \(Swift.String(describing: description)), isArchived: \(Swift.String(describing: isArchived)), lastModifiedDateTime: \(Swift.String(describing: lastModifiedDateTime)), name: \(Swift.String(describing: name)), waveAggregatedStatus: \(Swift.String(describing: waveAggregatedStatus)), waveID: \(Swift.String(describing: waveID)), tags: \"CONTENT_REDACTED\")"}
}

extension UpdateWaveOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateWaveOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.isArchived = output.isArchived
            self.lastModifiedDateTime = output.lastModifiedDateTime
            self.name = output.name
            self.tags = output.tags
            self.waveAggregatedStatus = output.waveAggregatedStatus
            self.waveID = output.waveID
        } else {
            self.arn = nil
            self.creationDateTime = nil
            self.description = nil
            self.isArchived = nil
            self.lastModifiedDateTime = nil
            self.name = nil
            self.tags = nil
            self.waveAggregatedStatus = nil
            self.waveID = nil
        }
    }
}

public struct UpdateWaveOutput {
    /// Wave ARN.
    public var arn: Swift.String?
    /// Wave creation dateTime.
    public var creationDateTime: Swift.String?
    /// Wave description.
    public var description: Swift.String?
    /// Wave archival status.
    public var isArchived: Swift.Bool?
    /// Wave last modified dateTime.
    public var lastModifiedDateTime: Swift.String?
    /// Wave name.
    public var name: Swift.String?
    /// Wave tags.
    public var tags: [Swift.String:Swift.String]?
    /// Wave aggregated status.
    public var waveAggregatedStatus: MgnClientTypes.WaveAggregatedStatus?
    /// Wave ID.
    public var waveID: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationDateTime: Swift.String? = nil,
        description: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        lastModifiedDateTime: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        waveAggregatedStatus: MgnClientTypes.WaveAggregatedStatus? = nil,
        waveID: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.description = description
        self.isArchived = isArchived
        self.lastModifiedDateTime = lastModifiedDateTime
        self.name = name
        self.tags = tags
        self.waveAggregatedStatus = waveAggregatedStatus
        self.waveID = waveID
    }
}

struct UpdateWaveOutputBody {
    let waveID: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let isArchived: Swift.Bool?
    let waveAggregatedStatus: MgnClientTypes.WaveAggregatedStatus?
    let creationDateTime: Swift.String?
    let lastModifiedDateTime: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateWaveOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
        case description
        case isArchived
        case lastModifiedDateTime
        case name
        case tags
        case waveAggregatedStatus
        case waveID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let waveIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .waveID)
        waveID = waveIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let waveAggregatedStatusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.WaveAggregatedStatus.self, forKey: .waveAggregatedStatus)
        waveAggregatedStatus = waveAggregatedStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastModifiedDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedDateTime)
        lastModifiedDateTime = lastModifiedDateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum UpdateWaveOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.fieldList = output.fieldList
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.code = nil
            self.properties.fieldList = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Validate exception.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        /// Validate exception field list.
        public internal(set) var fieldList: [MgnClientTypes.ValidationExceptionField]? = nil
        public internal(set) var message: Swift.String? = nil
        /// Validate exception reason.
        public internal(set) var reason: MgnClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        fieldList: [MgnClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: MgnClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.code = code
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody {
    let message: Swift.String?
    let code: Swift.String?
    let reason: MgnClientTypes.ValidationExceptionReason?
    let fieldList: [MgnClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case fieldList
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([MgnClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[MgnClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [MgnClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension MgnClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MgnClientTypes {
    /// Validate exception field.
    public struct ValidationExceptionField {
        /// Validate exception field message.
        public var message: Swift.String?
        /// Validate exception field name.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension MgnClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes.VcenterClient: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case datacenterName
        case hostname
        case lastSeenDatetime
        case sourceServerTags
        case tags
        case vcenterClientID
        case vcenterUUID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let datacenterName = self.datacenterName {
            try encodeContainer.encode(datacenterName, forKey: .datacenterName)
        }
        if let hostname = self.hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let lastSeenDatetime = self.lastSeenDatetime {
            try encodeContainer.encode(lastSeenDatetime, forKey: .lastSeenDatetime)
        }
        if let sourceServerTags = sourceServerTags {
            var sourceServerTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sourceServerTags)
            for (dictKey0, tagsMap0) in sourceServerTags {
                try sourceServerTagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vcenterClientID = self.vcenterClientID {
            try encodeContainer.encode(vcenterClientID, forKey: .vcenterClientID)
        }
        if let vcenterUUID = self.vcenterUUID {
            try encodeContainer.encode(vcenterUUID, forKey: .vcenterUUID)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vcenterClientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcenterClientID)
        vcenterClientID = vcenterClientIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let vcenterUUIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcenterUUID)
        vcenterUUID = vcenterUUIDDecoded
        let datacenterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datacenterName)
        datacenterName = datacenterNameDecoded
        let lastSeenDatetimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastSeenDatetime)
        lastSeenDatetime = lastSeenDatetimeDecoded
        let sourceServerTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .sourceServerTags)
        var sourceServerTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let sourceServerTagsContainer = sourceServerTagsContainer {
            sourceServerTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in sourceServerTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    sourceServerTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        sourceServerTags = sourceServerTagsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MgnClientTypes.VcenterClient: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VcenterClient(arn: \(Swift.String(describing: arn)), datacenterName: \(Swift.String(describing: datacenterName)), hostname: \(Swift.String(describing: hostname)), lastSeenDatetime: \(Swift.String(describing: lastSeenDatetime)), vcenterClientID: \(Swift.String(describing: vcenterClientID)), vcenterUUID: \(Swift.String(describing: vcenterUUID)), sourceServerTags: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

extension MgnClientTypes {
    /// vCenter client.
    public struct VcenterClient {
        /// Arn of vCenter client.
        public var arn: Swift.String?
        /// Datacenter name of vCenter client.
        public var datacenterName: Swift.String?
        /// Hostname of vCenter client .
        public var hostname: Swift.String?
        /// Last seen time of vCenter client.
        public var lastSeenDatetime: Swift.String?
        /// Tags for Source Server of vCenter client.
        public var sourceServerTags: [Swift.String:Swift.String]?
        /// Tags for vCenter client.
        public var tags: [Swift.String:Swift.String]?
        /// ID of vCenter client.
        public var vcenterClientID: Swift.String?
        /// Vcenter UUID of vCenter client.
        public var vcenterUUID: Swift.String?

        public init(
            arn: Swift.String? = nil,
            datacenterName: Swift.String? = nil,
            hostname: Swift.String? = nil,
            lastSeenDatetime: Swift.String? = nil,
            sourceServerTags: [Swift.String:Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            vcenterClientID: Swift.String? = nil,
            vcenterUUID: Swift.String? = nil
        )
        {
            self.arn = arn
            self.datacenterName = datacenterName
            self.hostname = hostname
            self.lastSeenDatetime = lastSeenDatetime
            self.sourceServerTags = sourceServerTags
            self.tags = tags
            self.vcenterClientID = vcenterClientID
            self.vcenterUUID = vcenterUUID
        }
    }

}

extension MgnClientTypes {
    public enum VolumeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gp2
        case gp3
        case io1
        case io2
        case sc1
        case st1
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [VolumeType] {
            return [
                .gp2,
                .gp3,
                .io1,
                .io2,
                .sc1,
                .st1,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gp2: return "gp2"
            case .gp3: return "gp3"
            case .io1: return "io1"
            case .io2: return "io2"
            case .sc1: return "sc1"
            case .st1: return "st1"
            case .standard: return "standard"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VolumeType(rawValue: rawValue) ?? VolumeType.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes.Wave: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
        case description
        case isArchived
        case lastModifiedDateTime
        case name
        case tags
        case waveAggregatedStatus
        case waveID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encode(creationDateTime, forKey: .creationDateTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let isArchived = self.isArchived {
            try encodeContainer.encode(isArchived, forKey: .isArchived)
        }
        if let lastModifiedDateTime = self.lastModifiedDateTime {
            try encodeContainer.encode(lastModifiedDateTime, forKey: .lastModifiedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let waveAggregatedStatus = self.waveAggregatedStatus {
            try encodeContainer.encode(waveAggregatedStatus, forKey: .waveAggregatedStatus)
        }
        if let waveID = self.waveID {
            try encodeContainer.encode(waveID, forKey: .waveID)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let waveIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .waveID)
        waveID = waveIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let waveAggregatedStatusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.WaveAggregatedStatus.self, forKey: .waveAggregatedStatus)
        waveAggregatedStatus = waveAggregatedStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastModifiedDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedDateTime)
        lastModifiedDateTime = lastModifiedDateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MgnClientTypes.Wave: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Wave(arn: \(Swift.String(describing: arn)), creationDateTime: \(Swift.String(describing: creationDateTime)), description: \(Swift.String(describing: description)), isArchived: \(Swift.String(describing: isArchived)), lastModifiedDateTime: \(Swift.String(describing: lastModifiedDateTime)), name: \(Swift.String(describing: name)), waveAggregatedStatus: \(Swift.String(describing: waveAggregatedStatus)), waveID: \(Swift.String(describing: waveID)), tags: \"CONTENT_REDACTED\")"}
}

extension MgnClientTypes {
    public struct Wave {
        /// Wave ARN.
        public var arn: Swift.String?
        /// Wave creation dateTime.
        public var creationDateTime: Swift.String?
        /// Wave description.
        public var description: Swift.String?
        /// Wave archival status.
        public var isArchived: Swift.Bool?
        /// Wave last modified dateTime.
        public var lastModifiedDateTime: Swift.String?
        /// Wave name.
        public var name: Swift.String?
        /// Wave tags.
        public var tags: [Swift.String:Swift.String]?
        /// Wave aggregated status.
        public var waveAggregatedStatus: MgnClientTypes.WaveAggregatedStatus?
        /// Wave ID.
        public var waveID: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationDateTime: Swift.String? = nil,
            description: Swift.String? = nil,
            isArchived: Swift.Bool? = nil,
            lastModifiedDateTime: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            waveAggregatedStatus: MgnClientTypes.WaveAggregatedStatus? = nil,
            waveID: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.description = description
            self.isArchived = isArchived
            self.lastModifiedDateTime = lastModifiedDateTime
            self.name = name
            self.tags = tags
            self.waveAggregatedStatus = waveAggregatedStatus
            self.waveID = waveID
        }
    }

}

extension MgnClientTypes.WaveAggregatedStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthStatus
        case lastUpdateDateTime
        case progressStatus
        case replicationStartedDateTime
        case totalApplications
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let healthStatus = self.healthStatus {
            try encodeContainer.encode(healthStatus.rawValue, forKey: .healthStatus)
        }
        if let lastUpdateDateTime = self.lastUpdateDateTime {
            try encodeContainer.encode(lastUpdateDateTime, forKey: .lastUpdateDateTime)
        }
        if let progressStatus = self.progressStatus {
            try encodeContainer.encode(progressStatus.rawValue, forKey: .progressStatus)
        }
        if let replicationStartedDateTime = self.replicationStartedDateTime {
            try encodeContainer.encode(replicationStartedDateTime, forKey: .replicationStartedDateTime)
        }
        if totalApplications != 0 {
            try encodeContainer.encode(totalApplications, forKey: .totalApplications)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastUpdateDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdateDateTime)
        lastUpdateDateTime = lastUpdateDateTimeDecoded
        let replicationStartedDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationStartedDateTime)
        replicationStartedDateTime = replicationStartedDateTimeDecoded
        let healthStatusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.WaveHealthStatus.self, forKey: .healthStatus)
        healthStatus = healthStatusDecoded
        let progressStatusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.WaveProgressStatus.self, forKey: .progressStatus)
        progressStatus = progressStatusDecoded
        let totalApplicationsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalApplications) ?? 0
        totalApplications = totalApplicationsDecoded
    }
}

extension MgnClientTypes {
    /// Wave aggregated status.
    public struct WaveAggregatedStatus {
        /// Wave aggregated status health status.
        public var healthStatus: MgnClientTypes.WaveHealthStatus?
        /// Wave aggregated status last update dateTime.
        public var lastUpdateDateTime: Swift.String?
        /// Wave aggregated status progress status.
        public var progressStatus: MgnClientTypes.WaveProgressStatus?
        /// DateTime marking when the first source server in the wave started replication.
        public var replicationStartedDateTime: Swift.String?
        /// Wave aggregated status total applications amount.
        public var totalApplications: Swift.Int

        public init(
            healthStatus: MgnClientTypes.WaveHealthStatus? = nil,
            lastUpdateDateTime: Swift.String? = nil,
            progressStatus: MgnClientTypes.WaveProgressStatus? = nil,
            replicationStartedDateTime: Swift.String? = nil,
            totalApplications: Swift.Int = 0
        )
        {
            self.healthStatus = healthStatus
            self.lastUpdateDateTime = lastUpdateDateTime
            self.progressStatus = progressStatus
            self.replicationStartedDateTime = replicationStartedDateTime
            self.totalApplications = totalApplications
        }
    }

}

extension MgnClientTypes {
    public enum WaveHealthStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case healthy
        case lagging
        case sdkUnknown(Swift.String)

        public static var allCases: [WaveHealthStatus] {
            return [
                .error,
                .healthy,
                .lagging,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .healthy: return "HEALTHY"
            case .lagging: return "LAGGING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WaveHealthStatus(rawValue: rawValue) ?? WaveHealthStatus.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes {
    public enum WaveProgressStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case inProgress
        case notStarted
        case sdkUnknown(Swift.String)

        public static var allCases: [WaveProgressStatus] {
            return [
                .completed,
                .inProgress,
                .notStarted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WaveProgressStatus(rawValue: rawValue) ?? WaveProgressStatus.sdkUnknown(rawValue)
        }
    }
}
