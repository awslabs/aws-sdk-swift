// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[DescribePortfolioSharesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribePortfolioSharesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribePortfolioSharesOutputResponse`
extension ServiceCatalogClient {
    public func describePortfolioSharesPaginated(input: DescribePortfolioSharesInput) -> ClientRuntime.PaginatorSequence<DescribePortfolioSharesInput, DescribePortfolioSharesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribePortfolioSharesInput, DescribePortfolioSharesOutputResponse>(input: input, inputKey: \DescribePortfolioSharesInput.pageToken, outputKey: \DescribePortfolioSharesOutputResponse.nextPageToken, paginationFunction: self.describePortfolioShares(input:))
    }
}

extension DescribePortfolioSharesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribePortfolioSharesInput {
        return DescribePortfolioSharesInput(
            pageSize: self.pageSize,
            pageToken: token,
            portfolioId: self.portfolioId,
            type: self.type
        )}
}

/// Paginate over `[GetProvisionedProductOutputsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetProvisionedProductOutputsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetProvisionedProductOutputsOutputResponse`
extension ServiceCatalogClient {
    public func getProvisionedProductOutputsPaginated(input: GetProvisionedProductOutputsInput) -> ClientRuntime.PaginatorSequence<GetProvisionedProductOutputsInput, GetProvisionedProductOutputsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetProvisionedProductOutputsInput, GetProvisionedProductOutputsOutputResponse>(input: input, inputKey: \GetProvisionedProductOutputsInput.pageToken, outputKey: \GetProvisionedProductOutputsOutputResponse.nextPageToken, paginationFunction: self.getProvisionedProductOutputs(input:))
    }
}

extension GetProvisionedProductOutputsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetProvisionedProductOutputsInput {
        return GetProvisionedProductOutputsInput(
            acceptLanguage: self.acceptLanguage,
            outputKeys: self.outputKeys,
            pageSize: self.pageSize,
            pageToken: token,
            provisionedProductId: self.provisionedProductId,
            provisionedProductName: self.provisionedProductName
        )}
}

/// Paginate over `[ListAcceptedPortfolioSharesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAcceptedPortfolioSharesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAcceptedPortfolioSharesOutputResponse`
extension ServiceCatalogClient {
    public func listAcceptedPortfolioSharesPaginated(input: ListAcceptedPortfolioSharesInput) -> ClientRuntime.PaginatorSequence<ListAcceptedPortfolioSharesInput, ListAcceptedPortfolioSharesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAcceptedPortfolioSharesInput, ListAcceptedPortfolioSharesOutputResponse>(input: input, inputKey: \ListAcceptedPortfolioSharesInput.pageToken, outputKey: \ListAcceptedPortfolioSharesOutputResponse.nextPageToken, paginationFunction: self.listAcceptedPortfolioShares(input:))
    }
}

extension ListAcceptedPortfolioSharesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAcceptedPortfolioSharesInput {
        return ListAcceptedPortfolioSharesInput(
            acceptLanguage: self.acceptLanguage,
            pageSize: self.pageSize,
            pageToken: token,
            portfolioShareType: self.portfolioShareType
        )}
}

/// Paginate over `[ListBudgetsForResourceOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListBudgetsForResourceInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListBudgetsForResourceOutputResponse`
extension ServiceCatalogClient {
    public func listBudgetsForResourcePaginated(input: ListBudgetsForResourceInput) -> ClientRuntime.PaginatorSequence<ListBudgetsForResourceInput, ListBudgetsForResourceOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListBudgetsForResourceInput, ListBudgetsForResourceOutputResponse>(input: input, inputKey: \ListBudgetsForResourceInput.pageToken, outputKey: \ListBudgetsForResourceOutputResponse.nextPageToken, paginationFunction: self.listBudgetsForResource(input:))
    }
}

extension ListBudgetsForResourceInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBudgetsForResourceInput {
        return ListBudgetsForResourceInput(
            acceptLanguage: self.acceptLanguage,
            pageSize: self.pageSize,
            pageToken: token,
            resourceId: self.resourceId
        )}
}

/// Paginate over `[ListConstraintsForPortfolioOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListConstraintsForPortfolioInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListConstraintsForPortfolioOutputResponse`
extension ServiceCatalogClient {
    public func listConstraintsForPortfolioPaginated(input: ListConstraintsForPortfolioInput) -> ClientRuntime.PaginatorSequence<ListConstraintsForPortfolioInput, ListConstraintsForPortfolioOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListConstraintsForPortfolioInput, ListConstraintsForPortfolioOutputResponse>(input: input, inputKey: \ListConstraintsForPortfolioInput.pageToken, outputKey: \ListConstraintsForPortfolioOutputResponse.nextPageToken, paginationFunction: self.listConstraintsForPortfolio(input:))
    }
}

extension ListConstraintsForPortfolioInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListConstraintsForPortfolioInput {
        return ListConstraintsForPortfolioInput(
            acceptLanguage: self.acceptLanguage,
            pageSize: self.pageSize,
            pageToken: token,
            portfolioId: self.portfolioId,
            productId: self.productId
        )}
}

/// Paginate over `[ListLaunchPathsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListLaunchPathsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListLaunchPathsOutputResponse`
extension ServiceCatalogClient {
    public func listLaunchPathsPaginated(input: ListLaunchPathsInput) -> ClientRuntime.PaginatorSequence<ListLaunchPathsInput, ListLaunchPathsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListLaunchPathsInput, ListLaunchPathsOutputResponse>(input: input, inputKey: \ListLaunchPathsInput.pageToken, outputKey: \ListLaunchPathsOutputResponse.nextPageToken, paginationFunction: self.listLaunchPaths(input:))
    }
}

extension ListLaunchPathsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListLaunchPathsInput {
        return ListLaunchPathsInput(
            acceptLanguage: self.acceptLanguage,
            pageSize: self.pageSize,
            pageToken: token,
            productId: self.productId
        )}
}

/// Paginate over `[ListOrganizationPortfolioAccessOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListOrganizationPortfolioAccessInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListOrganizationPortfolioAccessOutputResponse`
extension ServiceCatalogClient {
    public func listOrganizationPortfolioAccessPaginated(input: ListOrganizationPortfolioAccessInput) -> ClientRuntime.PaginatorSequence<ListOrganizationPortfolioAccessInput, ListOrganizationPortfolioAccessOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListOrganizationPortfolioAccessInput, ListOrganizationPortfolioAccessOutputResponse>(input: input, inputKey: \ListOrganizationPortfolioAccessInput.pageToken, outputKey: \ListOrganizationPortfolioAccessOutputResponse.nextPageToken, paginationFunction: self.listOrganizationPortfolioAccess(input:))
    }
}

extension ListOrganizationPortfolioAccessInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListOrganizationPortfolioAccessInput {
        return ListOrganizationPortfolioAccessInput(
            acceptLanguage: self.acceptLanguage,
            organizationNodeType: self.organizationNodeType,
            pageSize: self.pageSize,
            pageToken: token,
            portfolioId: self.portfolioId
        )}
}

/// Paginate over `[ListPortfolioAccessOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListPortfolioAccessInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListPortfolioAccessOutputResponse`
extension ServiceCatalogClient {
    public func listPortfolioAccessPaginated(input: ListPortfolioAccessInput) -> ClientRuntime.PaginatorSequence<ListPortfolioAccessInput, ListPortfolioAccessOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListPortfolioAccessInput, ListPortfolioAccessOutputResponse>(input: input, inputKey: \ListPortfolioAccessInput.pageToken, outputKey: \ListPortfolioAccessOutputResponse.nextPageToken, paginationFunction: self.listPortfolioAccess(input:))
    }
}

extension ListPortfolioAccessInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPortfolioAccessInput {
        return ListPortfolioAccessInput(
            acceptLanguage: self.acceptLanguage,
            organizationParentId: self.organizationParentId,
            pageSize: self.pageSize,
            pageToken: token,
            portfolioId: self.portfolioId
        )}
}

/// Paginate over `[ListPortfoliosOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListPortfoliosInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListPortfoliosOutputResponse`
extension ServiceCatalogClient {
    public func listPortfoliosPaginated(input: ListPortfoliosInput) -> ClientRuntime.PaginatorSequence<ListPortfoliosInput, ListPortfoliosOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListPortfoliosInput, ListPortfoliosOutputResponse>(input: input, inputKey: \ListPortfoliosInput.pageToken, outputKey: \ListPortfoliosOutputResponse.nextPageToken, paginationFunction: self.listPortfolios(input:))
    }
}

extension ListPortfoliosInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPortfoliosInput {
        return ListPortfoliosInput(
            acceptLanguage: self.acceptLanguage,
            pageSize: self.pageSize,
            pageToken: token
        )}
}

/// Paginate over `[ListPortfoliosForProductOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListPortfoliosForProductInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListPortfoliosForProductOutputResponse`
extension ServiceCatalogClient {
    public func listPortfoliosForProductPaginated(input: ListPortfoliosForProductInput) -> ClientRuntime.PaginatorSequence<ListPortfoliosForProductInput, ListPortfoliosForProductOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListPortfoliosForProductInput, ListPortfoliosForProductOutputResponse>(input: input, inputKey: \ListPortfoliosForProductInput.pageToken, outputKey: \ListPortfoliosForProductOutputResponse.nextPageToken, paginationFunction: self.listPortfoliosForProduct(input:))
    }
}

extension ListPortfoliosForProductInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPortfoliosForProductInput {
        return ListPortfoliosForProductInput(
            acceptLanguage: self.acceptLanguage,
            pageSize: self.pageSize,
            pageToken: token,
            productId: self.productId
        )}
}

/// Paginate over `[ListPrincipalsForPortfolioOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListPrincipalsForPortfolioInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListPrincipalsForPortfolioOutputResponse`
extension ServiceCatalogClient {
    public func listPrincipalsForPortfolioPaginated(input: ListPrincipalsForPortfolioInput) -> ClientRuntime.PaginatorSequence<ListPrincipalsForPortfolioInput, ListPrincipalsForPortfolioOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListPrincipalsForPortfolioInput, ListPrincipalsForPortfolioOutputResponse>(input: input, inputKey: \ListPrincipalsForPortfolioInput.pageToken, outputKey: \ListPrincipalsForPortfolioOutputResponse.nextPageToken, paginationFunction: self.listPrincipalsForPortfolio(input:))
    }
}

extension ListPrincipalsForPortfolioInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPrincipalsForPortfolioInput {
        return ListPrincipalsForPortfolioInput(
            acceptLanguage: self.acceptLanguage,
            pageSize: self.pageSize,
            pageToken: token,
            portfolioId: self.portfolioId
        )}
}

/// Paginate over `[ListProvisioningArtifactsForServiceActionOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListProvisioningArtifactsForServiceActionInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListProvisioningArtifactsForServiceActionOutputResponse`
extension ServiceCatalogClient {
    public func listProvisioningArtifactsForServiceActionPaginated(input: ListProvisioningArtifactsForServiceActionInput) -> ClientRuntime.PaginatorSequence<ListProvisioningArtifactsForServiceActionInput, ListProvisioningArtifactsForServiceActionOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListProvisioningArtifactsForServiceActionInput, ListProvisioningArtifactsForServiceActionOutputResponse>(input: input, inputKey: \ListProvisioningArtifactsForServiceActionInput.pageToken, outputKey: \ListProvisioningArtifactsForServiceActionOutputResponse.nextPageToken, paginationFunction: self.listProvisioningArtifactsForServiceAction(input:))
    }
}

extension ListProvisioningArtifactsForServiceActionInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListProvisioningArtifactsForServiceActionInput {
        return ListProvisioningArtifactsForServiceActionInput(
            acceptLanguage: self.acceptLanguage,
            pageSize: self.pageSize,
            pageToken: token,
            serviceActionId: self.serviceActionId
        )}
}

/// Paginate over `[ListResourcesForTagOptionOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListResourcesForTagOptionInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListResourcesForTagOptionOutputResponse`
extension ServiceCatalogClient {
    public func listResourcesForTagOptionPaginated(input: ListResourcesForTagOptionInput) -> ClientRuntime.PaginatorSequence<ListResourcesForTagOptionInput, ListResourcesForTagOptionOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListResourcesForTagOptionInput, ListResourcesForTagOptionOutputResponse>(input: input, inputKey: \ListResourcesForTagOptionInput.pageToken, outputKey: \ListResourcesForTagOptionOutputResponse.pageToken, paginationFunction: self.listResourcesForTagOption(input:))
    }
}

extension ListResourcesForTagOptionInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResourcesForTagOptionInput {
        return ListResourcesForTagOptionInput(
            pageSize: self.pageSize,
            pageToken: token,
            resourceType: self.resourceType,
            tagOptionId: self.tagOptionId
        )}
}

/// Paginate over `[ListServiceActionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListServiceActionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListServiceActionsOutputResponse`
extension ServiceCatalogClient {
    public func listServiceActionsPaginated(input: ListServiceActionsInput) -> ClientRuntime.PaginatorSequence<ListServiceActionsInput, ListServiceActionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListServiceActionsInput, ListServiceActionsOutputResponse>(input: input, inputKey: \ListServiceActionsInput.pageToken, outputKey: \ListServiceActionsOutputResponse.nextPageToken, paginationFunction: self.listServiceActions(input:))
    }
}

extension ListServiceActionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListServiceActionsInput {
        return ListServiceActionsInput(
            acceptLanguage: self.acceptLanguage,
            pageSize: self.pageSize,
            pageToken: token
        )}
}

/// Paginate over `[ListServiceActionsForProvisioningArtifactOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListServiceActionsForProvisioningArtifactInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListServiceActionsForProvisioningArtifactOutputResponse`
extension ServiceCatalogClient {
    public func listServiceActionsForProvisioningArtifactPaginated(input: ListServiceActionsForProvisioningArtifactInput) -> ClientRuntime.PaginatorSequence<ListServiceActionsForProvisioningArtifactInput, ListServiceActionsForProvisioningArtifactOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListServiceActionsForProvisioningArtifactInput, ListServiceActionsForProvisioningArtifactOutputResponse>(input: input, inputKey: \ListServiceActionsForProvisioningArtifactInput.pageToken, outputKey: \ListServiceActionsForProvisioningArtifactOutputResponse.nextPageToken, paginationFunction: self.listServiceActionsForProvisioningArtifact(input:))
    }
}

extension ListServiceActionsForProvisioningArtifactInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListServiceActionsForProvisioningArtifactInput {
        return ListServiceActionsForProvisioningArtifactInput(
            acceptLanguage: self.acceptLanguage,
            pageSize: self.pageSize,
            pageToken: token,
            productId: self.productId,
            provisioningArtifactId: self.provisioningArtifactId
        )}
}

/// Paginate over `[ListTagOptionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListTagOptionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListTagOptionsOutputResponse`
extension ServiceCatalogClient {
    public func listTagOptionsPaginated(input: ListTagOptionsInput) -> ClientRuntime.PaginatorSequence<ListTagOptionsInput, ListTagOptionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTagOptionsInput, ListTagOptionsOutputResponse>(input: input, inputKey: \ListTagOptionsInput.pageToken, outputKey: \ListTagOptionsOutputResponse.pageToken, paginationFunction: self.listTagOptions(input:))
    }
}

extension ListTagOptionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTagOptionsInput {
        return ListTagOptionsInput(
            filters: self.filters,
            pageSize: self.pageSize,
            pageToken: token
        )}
}

/// Paginate over `[SearchProductsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[SearchProductsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `SearchProductsOutputResponse`
extension ServiceCatalogClient {
    public func searchProductsPaginated(input: SearchProductsInput) -> ClientRuntime.PaginatorSequence<SearchProductsInput, SearchProductsOutputResponse> {
        return ClientRuntime.PaginatorSequence<SearchProductsInput, SearchProductsOutputResponse>(input: input, inputKey: \SearchProductsInput.pageToken, outputKey: \SearchProductsOutputResponse.nextPageToken, paginationFunction: self.searchProducts(input:))
    }
}

extension SearchProductsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchProductsInput {
        return SearchProductsInput(
            acceptLanguage: self.acceptLanguage,
            filters: self.filters,
            pageSize: self.pageSize,
            pageToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

/// Paginate over `[SearchProductsAsAdminOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[SearchProductsAsAdminInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `SearchProductsAsAdminOutputResponse`
extension ServiceCatalogClient {
    public func searchProductsAsAdminPaginated(input: SearchProductsAsAdminInput) -> ClientRuntime.PaginatorSequence<SearchProductsAsAdminInput, SearchProductsAsAdminOutputResponse> {
        return ClientRuntime.PaginatorSequence<SearchProductsAsAdminInput, SearchProductsAsAdminOutputResponse>(input: input, inputKey: \SearchProductsAsAdminInput.pageToken, outputKey: \SearchProductsAsAdminOutputResponse.nextPageToken, paginationFunction: self.searchProductsAsAdmin(input:))
    }
}

extension SearchProductsAsAdminInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchProductsAsAdminInput {
        return SearchProductsAsAdminInput(
            acceptLanguage: self.acceptLanguage,
            filters: self.filters,
            pageSize: self.pageSize,
            pageToken: token,
            portfolioId: self.portfolioId,
            productSource: self.productSource,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

/// Paginate over `[SearchProvisionedProductsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[SearchProvisionedProductsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `SearchProvisionedProductsOutputResponse`
extension ServiceCatalogClient {
    public func searchProvisionedProductsPaginated(input: SearchProvisionedProductsInput) -> ClientRuntime.PaginatorSequence<SearchProvisionedProductsInput, SearchProvisionedProductsOutputResponse> {
        return ClientRuntime.PaginatorSequence<SearchProvisionedProductsInput, SearchProvisionedProductsOutputResponse>(input: input, inputKey: \SearchProvisionedProductsInput.pageToken, outputKey: \SearchProvisionedProductsOutputResponse.nextPageToken, paginationFunction: self.searchProvisionedProducts(input:))
    }
}

extension SearchProvisionedProductsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchProvisionedProductsInput {
        return SearchProvisionedProductsInput(
            acceptLanguage: self.acceptLanguage,
            accessLevelFilter: self.accessLevelFilter,
            filters: self.filters,
            pageSize: self.pageSize,
            pageToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}
